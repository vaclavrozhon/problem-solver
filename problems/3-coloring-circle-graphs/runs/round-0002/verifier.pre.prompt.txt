=== SYSTEM ===
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md, proofs.md, and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (informal progress & exploratory work so far)
- proofs.md (rigorous proofs & detailed mathematics so far)
- output.md (main results found so far)

**Three-tier file system guidelines**:
- **notes.md**: Readable, log of exploratory work, intuitions, failed attempts, ideas. Prefer appending. Replace only if old notes are clearly misleading. It should be self-contained: In particular, reading it should make sense without knowing the output of provers in past rounds. 

- **proofs.md**: Complete rigorous mathematical proofs with full details. Think twice before adding anything. Contains proven lemmas, theorems, and detailed derivations. Only add mathematically verified content here.
- **output.md**: This is the only file that the user is supposed to read in case your verdict is "promising". It has to be self-contained. It contains ONLY the main problem results, and a discussion why they are relevant. It is extremely selective. Think twice before promoting proofs from proofs.md to output.md. Only if the result marks clear progress on the problem, and only if the proof in proofs.md has been thoroughly vetted by provers and you, it can join output.md. Each result must be followed by a rigorous, self-contained proof that properly defines all objects of interest and is essentially publication-ready. 

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (≥200 words). Include concrete next-step suggestions.",
  "summary_md": "Concise summary of this round's work for summarizer.",
  "verdict": "promising|uncertain|unlikely",
  "blocking_issues": ["List of issues preventing progress"],
  "per_prover": [{"prover_id": "01", "brief_feedback": "feedback", "score": "promising|uncertain|unlikely"}],
  "notes_update": {"action": "append|replace", "content": "Markdown for notes.md"},
  "proofs_update": {"action": "append|replace", "content": "Markdown for proofs.md"}, 
  "output_update": {"action": "append|replace", "content": "Markdown for output.md"}
}

**Verdict definitions**:
- **promising**: Significant mathematical progress, publishable results
- **uncertain**: Some progress you deem nontrivial, but with unresolved issues or incomplete reasoning  
- **unlikely**: No meaningful progress, fundamentally flawed approaches, or just exploratory work

**Update guidelines**:
- Use null for any update field you don't want to modify
- notes_update: Include informal reasoning, failed attempts, intuitions, exploratory work
- proofs_update: Only include complete, rigorous proofs that you have verified
- output_update: Only include main problem results that directly advance toward the solution


=== USER ===
=== Task (txt) ===

Complexity of 3-coloring circle graphs

Definitions.
• A graph is called a circle graph if it can be represented as an
intersection graph of chords in a circle. (That is, each vertex gets
assigned a chord in a circle, and two vertices are adjacent iff their
chords intersect.)
Question: What is the complexity of 3-coloring circle graphs?
Related results:
• For k-coloring of circle graphs with k ≥ 4, we know the problem
is NP-complete.
• For most superclasses of circle graphs, 3-coloring is known to be
NP-complete, usually because the superclasses also contain the class
planar graphs.
• Unger gave an algorithm for 3-coloring circle graphs in time
O(n log n) using a backtracking algorithm for a 3-SAT instance
with a specific structure based on the circle graph, however Bachmann, Rutter, and Stumpf have shown counterexamples to both
the reduction to 3-SAT and the backtracking algorithm.




=== Notes ===

# Research Notes



Problem. Decide the complexity of 3-coloring circle graphs (intersection graphs of chords of a circle). Unger’s O(n log n) algorithm was refuted (Bachmann–Rutter–Stumpf). For k ≥ 4, k-coloring circle graphs is NP-complete.

Key observations consolidated this round:
- Representation: Cutting the circle away from endpoints turns chords into open intervals (s(x), t(x)) with x,y adjacent iff their intervals overlap without containment: s(x) < s(y) < t(x) < t(y) or vice versa.
- Neighborhood structure: For any chord x, N(x) induces a permutation graph: neighbors of x have one endpoint on each side arc; adjacency among them is determined by inversion between the two side orders. Consequently, in any 3-coloring N(x) must be bipartite.
- Two-chord view: For any x,y, the set N(x)∩N(y) is an induced subgraph of N(x) and hence also a permutation graph (permutation graphs are hereditary). This tightens and replaces a tentative “trapezoid” claim.

Parameterized algorithm (ply w):
- Define the interval ply w as the maximum number of intervals covering a point in the linearized representation. A sweep-line DP over the 2n endpoints maintains proper colorings of the active set; on the start of b, forbid colors used by current actives a with t(a) < t(b). This yields an algorithm for k-colorability in O(n·w·k^w) time and O(k^w) space. The parameter is representation-dependent; recognizing circle graphs and finding a representation is polytime.

Bipartite-sides decomposition:
- Fix a chord x. Removing x splits chords into three parts: left side L, right side R, and N(x). If L and R are bipartite, then for any fixed 2-coloring of each component of N(x), each side reduces to choosing one of its two bipartition orientations; vertices that cannot use their prescribed a/b color (due to conflicts with N(x)) are assigned the third color c_x, provided these “violators” form an independent set. This gives a polynomial-time extension test per choice and overall runtime O(3·2^{cc(N(x))}·poly(n)) for a fixed x; trying all x multiplies by n. This is polytime whenever cc(N(x)) is bounded and both sides are bipartite.

Limits and obstacles:
- Necessary local conditions (e.g., N(v) bipartite for all v) are far from sufficient; known triangle-free circle graphs can have chromatic number 5 (Ageev). The ply parameter can be Θ(n) even for easy instances. Extending the side method beyond bipartite sides appears to require an independent odd cycle transversal with list constraints.

Next steps:
- Unify and finalize the DP proof (k-colorability, O(n·w·k^w)). Implement and benchmark typical w values.
- Replace the double-neighborhood trapezoid claim by the hereditary-permutation fact in all notes.
- Explore a 2-SAT encoding to eliminate the 2^{cc(N(x))} factor; alternatively, branch on a small independent odd-cycle transversal per side.
- Investigate two-chord separators and whether a global decomposition can be derived by combining permutation substructures.
- Hardness attempt within K4-free circle graphs (gadget search aided by SAT/ILP).


=== Current Output ===

# Main Results




=== Prover 1 Output ===

Status
We treat 3-coloring of circle graphs as open in general. I consolidate and tighten structural lemmas, give a clean path-decomposition perspective yielding a standard DP (k-colorability FPT in the circular ply), prove a new small structural fact (ply ≤ 2 implies acyclic), and correct the double-neighborhood claim.

Ideas
- Overlap model: Fix a circle representation and cut at a point between endpoints. Each chord x becomes an open interval (s(x), t(x)) on a line with s(x) < t(x). Adjacency is overlap without containment: x∼y iff s(x)<s(y)<t(x)<t(y) or s(y)<s(x)<t(y)<t(x).
- Circular ply w: the maximum number of intervals covering any elementary segment between consecutive endpoints.

Lemma 1 (Neighborhoods are permutation graphs)
For any vertex/chord x, the induced subgraph G[N(x)] is a permutation graph.
Proof. The endpoints of x split the circle into two arcs L,R. Each y∈N(x) has one endpoint on L and the other on R. Adjacency among N(x) is determined by whether the relative orders on L and R are inverted, which is exactly the permutation graph model. ∎

Corollary 1 (Double neighborhoods are permutation)
For any x,y, the subgraph G[N(x)∩N(y)] is a permutation graph. Proof: permutation graphs are hereditary, and N(x)∩N(y) induces a subgraph of G[N(x)]. ∎

Path decomposition by the sweep (and a separator view)
- For each elementary segment σ between consecutive endpoints in the linearized order, let B(σ) be the set of intervals covering σ (i.e., active at σ). Then |B(σ)| ≤ w by definition.
- Separator: For any σ, B(σ) separates the set of intervals that have already ended from those that have not yet started; hence bags B(σ) naturally yield a path decomposition.

Lemma 2 (Path decomposition of width ≤ w−1)
The sequence of bags B(σ) over elementary segments σ (in their linear order) is a path decomposition of the overlap (circle) graph G of width at most w−1.
Proof. (i) Vertex contiguity: For any interval x, the set of segments σ⊂(s(x),t(x)) it covers is a contiguous block; hence x appears in a contiguous block of bags. (ii) Edge coverage: If x∼y with s(x)<s(y)<t(x)<t(y), then any σ chosen with s(y)<σ<t(x) is covered by both x and y, so both appear in B(σ). (iii) Width bound follows from |B(σ)| ≤ w. ∎

Theorem 1 (k-colorability FPT in circular ply)
Given a circle representation of G with circular ply w, k-colorability (in particular, 3-colorability) can be decided in time O(n·k^w) and space O(k^w) via DP over the path decomposition {B(σ)}.
Proof (sketch, standard DP on path decompositions). Traverse bags in order; maintain for the current bag all proper colorings of vertices in the bag that extend to the already-processed part. At a bag transition, vertices are introduced/forgotten by at most one per step (refining to a nice path decomposition if desired). Since each bag has size ≤ w, the state space is ≤ k^w, transitions are O(k^w), and correctness follows from the path decomposition properties. ∎

Remark. Recognizing circle graphs and constructing a representation is polynomial-time (classical), so the overall running time is f(w)·poly(n) when the representation is part of the input or computed upfront. This generalizes the previously stated O(n·w·k^w) sweep DP.

New structural bound for tiny ply
Proposition 1 (Ply ≤ 2 implies acyclic)
If the circular ply w ≤ 2, then the overlap (circle) graph G is a forest (hence bipartite and trivially 3-colorable).
Proof. Suppose G contains a cycle C and choose an interval v1 on C whose right endpoint t(v1) is minimal among the cycle vertices. Its two cycle neighbors v2 and vm must satisfy s(v1) < s(v2) < t(v1) < t(v2) and s(v1) < s(vm) < t(v1) < t(vm) (the alternative s(vm) < s(v1) < t(vm) < t(v1) would contradict minimality of t(v1)). Pick any point p with max{s(v2), s(vm)} < p < t(v1). Then v1, v2, vm all cover p, so three intervals cover p, contradicting w ≤ 2. Thus no cycle exists. ∎

Examples / sanity checks
- C5 requires w ≥ 3 by Proposition 1. The path-decomposition DP correctly determines that C5 is 3-colorable.
- Triangles also force w ≥ 3 (same argument with a 3-cycle).

Obstacles and one failed compression attempt
- It is tempting to compress DP states by keeping, for the active intervals sorted by end-time, only the sets U_r of colors used in the first r positions (equivalently, the first-appearance ranks of each color). This suffices to decide which colors are forbidden for a newly introduced interval. However, at forget steps (when the earliest-ending active interval leaves the bag), we must know its color to update U_r; without tracking the full assignment on the bag, we cannot update these sets correctly. Hence such compression is unsound; exponential-in-w states (k^w) appear necessary for exact DP over this path decomposition.

Consequences and corrections
- Replace the earlier “double neighborhood is trapezoid” remark by Corollary 1 (permutation, hereditary), which is tighter and simpler.
- The separator view clarifies why the sweep DP is a standard pathwidth DP; it also provides a reusable interface for other problems.

Next steps
- Implementation: DP on the explicit path decomposition {B(σ)}; benchmark typical w on random/canonical instances.
- Structural: Explore whether small w beyond 2 yields additional constraints (e.g., characterize cycle structure for w=3) and whether these enable faster specialized algorithms.
- Decomposition: Investigate whether two-pivot cuts (bags restricted to chords intersecting one of two fixed chords) yield useful bounded-width decompositions in practice.
- Hardness: Design 3-coloring gadgets within circle graphs (with a fixed triangle as a palette); formalize a wire and equality gadget realizable by chords, aiming towards NP-hardness for K4-free instances.

Summary of concrete, checkable contributions this round
- Lemma 2 and Theorem 1: explicit path decomposition of width ≤ w−1 and an FPT DP for k-colorability in O(n·k^w) time, clarifying and unifying the sweep algorithm with standard pathwidth DP.
- Proposition 1: If w ≤ 2 then G is a forest (new small structural fact, with proof).
- Correction: N(x)∩N(y) is permutation (hereditary); drop the trapezoid claim unless a complete construction is given.


=== Prover 2 Output ===

# Ideas (round objective)

- Consolidate two rigorous ingredients: (i) a fully detailed DP for k-colorability parameterized by interval ply w, and (ii) a polynomial-time extension test (via 2-SAT) under the “bipartite sides” assumption for a fixed pivot chord x, given a 2-coloring of G[N(x)].
- Clarify that N(x) and N(x)∩N(y) are permutation graphs (hereditary), replacing earlier “trapezoid” remarks.
- Extract an FPT corollary in the parameter cc(N(x)) (number of connected components of G[N(x)]) for instances admitting a pivot x with bipartite sides.

# Preliminaries

- Circle graphs ≡ overlap graphs of intervals: Fix a point on the circle avoiding endpoints; map each chord ab to the interval (a,b) along the circle’s cyclic order. Two chords intersect iff their intervals overlap without containment: s(u) < s(v) < t(u) < t(v) or vice versa.
- Ply w: maximum number of intervals covering any point in the linearized representation. It bounds the sweep-line active set size.

# Lemma A (Neighborhoods are permutation graphs)

Statement. For any chord x, the induced subgraph G[N(x)] is a permutation graph. Consequently, for any x,y, the graph G[N(x)∩N(y)] is also permutation.

Proof. Draw the circle and chord x. The neighbors of x are exactly chords with one endpoint on the left arc of x and one on the right arc. Order N(x) by their left endpoints along the left arc, and independently by their right endpoints along the right arc. Two neighbors u,v cross (hence are adjacent in G[N(x)]) iff the relative order of their left endpoints is inverted relative to the order of their right endpoints. This is exactly the permutation graph definition on the two linear orders. Permutation graphs are hereditary, so any induced subgraph such as N(x)∩N(y) is permutation. ∎

# Theorem 1 (DP for k-colorability parameterized by ply)

Statement. Given an interval-overlap representation with ply w for a circle graph G on n chords, one can decide k-colorability in time O(n · w · k^w) and space O(k^w). The same bound holds when starting from a graph input after computing a representation in poly(n) time.

Proof. Sort the 2n endpoints e_1,…,e_{2n}. Let A_t be the active set between e_t and e_{t+1}. A proper k-coloring of G corresponds to assigning colors to intervals so that, at any t, within each color the active intervals form a single containment chain (a LIFO stack), since any two simultaneously active same-color intervals cannot overlap and cannot be disjoint; hence they must be nested.

DP states. At position t, a state is a k-tuple (S^1_t,…,S^k_t) forming a partition of A_t, with the property that each S^c_t is totally ordered by decreasing right endpoints (a stack). For each S^c_t store r_top(c), the minimum right endpoint in S^c_t (∞ if empty).

Initialization: S_0 = {(∅,…,∅)}.

Transition. Process e_{t+1}:
- If e_{t+1} is the start of interval j with right endpoint r_j, then for every current state and every color c such that either S^c_t is empty or r_j < r_top(c), generate a successor by pushing j onto S^c_t and setting r_top(c) ← r_j.
- If e_{t+1} is the end of interval j, then a state survives iff there exists a unique color c with j ∈ S^c_t and r_j = r_top(c); pop j from S^c_t and reset r_top(c) to the next minimum in S^c_t (or ∞ if empty).

Correctness. By induction on t, reachable states correspond exactly to colorings of intervals whose starts appear among {e_1,…,e_t} that are consistent with some global k-coloring of all intervals that end after t. The push condition enforces that a new same-color interval starts inside the current top of that color, preventing same-color overlap; the pop condition enforces LIFO within each color, which is necessary to keep nested chains valid. Conversely, any valid k-coloring induces a unique path of states by the same push/pop discipline.

Complexity. |A_t| ≤ w implies at most k^{|A_t|} ≤ k^w states at any t. Maintaining r_top requires O(1) per push, and O(w) per pop to find the next minimum (or O(1) with per-stack linked lists). Across 2n events this gives O(n · w · k^w) time and O(k^w) memory per layer. ∎

Remark. This is FPT in w; note w depends on the given (or computed) representation and can be Θ(n) in the worst case.

# Proposition 2 (Bipartite-sides extension via 2-SAT)

Setup. Fix a chord x and aim for a 3-coloring with col(x)=3. Let L (resp. R) be the chords with both endpoints on the left (resp. right) arc of x; let N(x) be the chords crossing x. Suppose G[L] and G[R] are bipartite; fix bipartitions L = A_L ⊔ B_L and R = A_R ⊔ B_R. Fix a proper 2-coloring of G[N(x)] with colors {1,2} (equivalently, fix the orientation of each bipartite component of N(x)).

For y ∈ L, define S_y ⊆ {1,2} as the set of colors appearing among neighbors of y in N(x) (equivalently, among left endpoints in y). Analogously define S_y for y ∈ R from right endpoints. We must decide if colors can be assigned to L ∪ R using colors {1,2,3} so that: (i) vertices with z_y=0 are colored 1/2 respecting the fixed bipartitions (A-side gets one color, B-side the other, per component), (ii) vertices with z_y=1 use color 3, and (iii) constraints from S_y are respected.

Construction (2-SAT per side). For each component K of L (or R), introduce a Boolean p_K indicating whether A_K uses color 1 (p_K=0) or 2 (p_K=1). For each y ∈ K, introduce z_y indicating whether y is colored 3 (z_y=1) or uses the side color (z_y=0). Add clauses:
- For every edge uv of K: (¬z_u ∨ ¬z_v) to ensure the z=1 vertices form an independent set.
- If S_y = {1,2}, add z_y as a unit clause (y must be 3).
- If S_y = {1}: then
  • y ∈ A_K: add (z_y ∨ p_K) (if z_y=0 then A_K must not be color 1).
  • y ∈ B_K: add (z_y ∨ ¬p_K) (if z_y=0 then B_K must not be color 1).
- If S_y = {2}: then
  • y ∈ A_K: add (z_y ∨ ¬p_K) (if z_y=0 then A_K must not be color 2).
  • y ∈ B_K: add (z_y ∨ p_K) (if z_y=0 then B_K must not be color 2).
- If S_y = ∅, add ¬z_y (no need to use color 3).
Solve the 2-SAT instance independently for K ⊆ L and K ⊆ R.

Correctness. Given the fixed 2-coloring of N(x), any valid extension with col(x)=3 yields an assignment with z_y=1 exactly for 3-colored vertices, and p_K matching the orientation used on K; all clauses are satisfied by construction. Conversely, any satisfying assignment produces a valid 3-coloring: for each component K, assign colors {1,2} to A_K,B_K as specified by p_K; vertices with z_y=1 use color 3; independence of the z=1 set ensures no monochromatic edge in color 3; constraints guarantee that no vertex kept in {1,2} is assigned a forbidden color. Edges between L and R do not exist, and edges to N(x) are respected by S_y’s definition; edges inside N(x) are proper by the fixed 2-coloring. ∎

Complexity. For fixed x and fixed 2-coloring of N(x), the reduction and 2-SAT solving are linear in |V(G)| + |E(G)|.

# Corollary 3 (FPT in cc(N(x)) under bipartite-sides)

Algorithm. For each choice of pivot x, first test if G[L] and G[R] are bipartite; if not, skip x. Compute the connected components of G[N(x)]. For each component, there are exactly two orientations of its 2-coloring; enumerate all 2^{cc(N(x))} choices. For each choice, run the 2-SAT extensions on L and R as in Proposition 2. If any choice succeeds, G is 3-colorable; else, try the next x.

Runtime. O(n · 2^{cc(N(x))} · poly(n)) across all x. This is FPT in t = min_x cc(N(x)) on instances admitting at least one pivot x with bipartite sides.

Remarks. The 2-SAT step strictly improves on a purely greedy orientation: it permits assigning color 3 to a side-vertex with a singleton S_y when necessary, provided the set of such vertices is independent.

# Examples and checks

- Pivot with universal chord. If some x meets every other chord, then N(x) = V\{x}. A 3-coloring exists iff G−x is bipartite; the algorithm detects this with L=R=∅ and a single 2-coloring check on N(x).
- Small instance. Let x split the circle; let N(x) induce a path on four vertices (bipartite, cc=1). Suppose on L there are two vertices y1,y2 adjacent; the left endpoints in y1 include both colors (S_{y1}={1,2}), while S_{y2}={1}. The 2-SAT forces z_{y1}=1 and (z_{y2} ∨ p_{K_L}). If z_{y2}=0 then p_{K_L}=1; otherwise y2 may be set to 3 provided z_{y1}=1∧z_{y2}=1 is disallowed by the edge clause. The construction behaves as intended.

# Obstacles and limits

- Removing the 2^{cc(N(x))} factor. Integrating the orientation variables of N(x) into a single 2-SAT is blocked by “existence” predicates of the form “some neighbor with color c lies inside y,” which expand to disjunctions over multiple components. This naturally yields clauses beyond 2-CNF. A viable relaxation is to precompute orientation-invariant bans: if both sides of some component contribute endpoints inside y, then color c is forced in y regardless of orientation; this can prune the search but does not eliminate exponential branching in the worst case.
- General instances. If no pivot x has bipartite sides, Proposition 2 does not apply. Extending it would require handling odd-cycle transversals on the sides together with independence constraints; the “independent odd cycle transversal” variant is algorithmically delicate.
- Ply-based DP. The O(n·w·k^w) algorithm is worst-case exponential when w is large; improving it unconditionally seems to require a new, more compressed invariant than per-interval color on the active set.

# Next steps (concrete and testable)

- Proof polishing: Move Theorem 1 and Lemma A into proofs.md with complete, self-contained arguments and precise data-structure details for O(1) r_top maintenance.
- Implementation: (i) DP for k-colorability vs ply; (ii) the pivot-based algorithm with the 2-SAT extension; measure cc(N(x)) distribution and frequency of bipartite sides in random and benchmark instances.
- Pruning heuristics: In the pivot algorithm, compute orientation-invariant bans per vertex y to reduce the branching tree over cc(N(x)). Use early 2-SAT infeasibility checks to backtrack.
- Structural: Explore two-chord separators {a,b} and whether regions separated by N(a)∪N(b) admit a similar 2-SAT extension (N(a)∪N(b) is permutation by Lemma A; enumerate its 2-colorings per component).
- Hardness direction: Start a SAT-guided search for small 3-coloring gadgets within circle graphs (wire, inverter, equality), using chord-diagram realizability constraints to validate gadgets.

# Provisional items for output.md

- Theorem 1 (DP in ply w) with full proof and complexity.
- Lemma A (G[N(x)] permutation; hereditary consequence).
- Proposition 2 (2-SAT extension under bipartite sides for fixed 2-coloring of N(x)) and Corollary 3 (FPT in cc(N(x)) when such a pivot exists).



=== Prover 3 Output ===

Status and plan.
- We consolidate two results: (A) a rigorous dynamic program for k-colorability parameterized by the interval ply w of a chord representation; (B) strengthening the neighborhood-structure lemmas (including N(x)∩N(y)).
- We then attempt to remove the 2^{cc(N(x))} factor in the bipartite-sides method via 2-SAT; we explain precisely where and why a direct 2-SAT encoding fails in general, and extract a special subclass where 2-SAT works.

I. DP for k-colorability parameterized by ply w
Setup and notation.
- Fix a circle-chord representation. Cut the circle at a point not an endpoint to obtain open intervals I(v)=(s(v),t(v)) on the line with all endpoints distinct. Two vertices a,b are adjacent iff the endpoints alternate: s(a)<s(b)<t(a)<t(b) or s(b)<s(a)<t(b)<t(a) (i.e., intervals overlap without containment).
- Let the ply w be the maximum number of intervals covering any point. Equivalently, during a left-to-right sweep over endpoints, the number of active intervals is at most w.
- We process events in increasing order of endpoints. At any time, maintain the active intervals ordered by increasing right endpoint. Represent the state by the sequence of colors of the active intervals in this order.

Theorem 1 (DP by ply). Given a chord representation with ply w and an integer k≥1, one can decide k-colorability (and construct a k-coloring if it exists) in time O(n·w·k^w) and space O(k^w).
Proof.
Invariant: At any sweep position x (just after handling all endpoints ≤ x), the DP state set S_x consists of all color sequences C=(c_1,...,c_h) with h≤w such that there exists a proper partial k-coloring of all intervals whose starts are ≤ x, consistent with the following: the active intervals at x, when ordered by increasing right endpoints t_1<...<t_h, have colors c_1,...,c_h respectively; intervals ending before x have been colored and removed.
Transitions:
- End event at t(a): the leftmost active interval (the one with minimum right endpoint) ends. For every state C=(c_1,...,c_h) in S_{x^-}, remove c_1 to obtain C'=(c_2,...,c_h) and insert C' into S_x. This preserves propriety since edges to a are only to intervals b with s(a)<s(b)<t(a)<t(b); at the time b started, it avoided color c_1 if adjacent to a.
- Start event at s(b): let the current active sequence be C=(c_1,...,c_h) in S_{x^-}. Determine the unique insertion position j∈{1,...,h+1} so that t(c_{j-1})<t(b)<t(c_j), with t(c_0):=-∞, t(c_{h+1}):=+∞. The set of earlier-start neighbors of b is precisely those active intervals with right endpoints in (s(b),t(b)), i.e., the prefix {c_1,...,c_{j-1}}. To extend, choose any color c∈{1,...,k} not used among c_1,...,c_{j-1}, and form C' by inserting c at position j. Add C' to S_x. Correctness of the adjacency condition follows from the alternation characterization: an earlier-start interval a is adjacent to b iff t(a)∈(s(b),t(b)), which is exactly the prefix.
Initialization/acceptance: S_{-∞} contains the empty sequence. After the last event, accept if S_{+∞}≠∅; any accepting path yields a coloring by recording choices at start events.
Complexity: At any event the number of states is at most sum_{h=0}^w k^h=O(k^w). For a start event, testing the j−1-prefix uses O(w) time to collect used colors (or O(1) with k-bitsets accumulated per state). For an end event, removal is O(1). Thus the total time is O(n·w·k^w), space O(k^w). This proves the theorem.
Remarks.
- For 3-colorability, this gives O(n·w·3^w). The guarantee is parameterized by the ply of the given representation (which need not be minimum for the graph); standard circle-graph recognition/representation is polynomial-time.

II. Neighborhood structure refinements
Lemma 2 (Permutation subgraph N(x)). In a fixed chord diagram, for any chord x with endpoints s,t, the neighbor set N(x) induces a permutation graph: place the points of the arcs (s,t) and (t,s) on two parallel lines in circular order and map each z∈N(x) to the segment connecting its endpoints. Two such segments cross iff their endpoints are in opposite orders, exactly when chords cross.
Lemma 3 (Double neighborhoods). For any two chords x,y, N(x)∩N(y) is an induced subgraph of a permutation graph, hence is a permutation graph (permutation graphs are hereditary).
Consequences.
- In any 3-coloring, N(v) is 2-colored, so G[N(v)] must be bipartite (necessary condition testable in linear time on a permutation representation). The “middle layer” N(x)∩N(y) inherits the same structure.

III. Bipartite-sides extension revisited
Recap (Proposition from prior round). Fix x with arcs A_L,A_R. Let L (resp. R) be the chords with both endpoints on A_L (resp. A_R). Suppose L,R are bipartite. Fix a 2-coloring of each connected component of G[N(x)] with colors a,b and let c_x be the third color. For each side component C with bipartition (P,Q), there are two orientations o∈{0,1} assigning a/b to P,Q. Let B_o(C) be the vertices whose assigned a/b color is forbidden by the colors seen among their neighbors in N(x) (the “violators”). Then one can properly color C iff at least one orientation o yields B_o(C) independent; assign c_x to B_o(C) and a/b to the rest. This test runs in linear time per C for fixed N(x)-coloring.

Attempted 2-SAT to remove the 2^{cc(N(x))} factor (and why it fails generally).
- Variables one would like: for each N(x)-component K, a boolean t_K selecting which side of the bipartition gets color a; for each side component C, a boolean o_C selecting its a/b orientation. For a side vertex y, whether its assigned a/b color is forbidden depends on (i) o_C; and (ii) whether color a or b appears among its neighbors in N(x), which is an OR over components K touching y of a literal of t_K (depending on which side(s) of K meet y). For an edge uv in a side component, we must forbid “u and v both violators,” i.e., (u takes forbidden color) ∧ (v takes forbidden color). Each “takes forbidden color” is a conjunction of a 1-bit test on o_C and a disjunction over the relevant t_K’s. The conjunctive edge constraint translates into a clause of the form (¬o_C ∨ big-OR-over-K) ∨ (o_C ∨ big-OR-over-K’), which is not a 2-clause in general.
- Thus, in general, encoding all choices for {t_K} and {o_C} into a single 2-CNF is not possible by this direct route. Over-approximations that collapse ORs would lose completeness (may reject truly 3-colorable instances).

A special subclass where 2-SAT works.
Assumption (single-touch). Every y∈L∪R has neighbors in N(x) contained in a single connected component K(y) of G[N(x)]. Preprocess “forced-0” vertices: if y has neighbors on both sides of K(y), then both a and b appear regardless of t_{K(y)}, so y must be c_x; if two adjacent vertices are forced-0, reject this choice of x immediately.
Proposition 4 (2-SAT under single-touch, no forced-0 conflict). Under the single-touch assumption and after removing forced-0 vertices, deciding whether there exist assignments to {t_K} and {o_C} so that every side component passes the independence test reduces to 2-SAT and runs in polynomial time.
Proof sketch. For y in side component C with bipartition (P,Q): write o_C=0 for P→a,Q→b and o_C=1 for P→b,Q→a. Since y touches only K(y), the predicate “color a appears at y” is a single literal α_y∈{t_{K(y)}, ¬t_{K(y)}, ⊤, ⊥} determined by which side(s) of K(y) meet y; similarly for “color b appears” giving a literal β_y. After removing forced-0 vertices, each y has at most one of α_y,β_y equal to ⊤. For an edge uv with u∈P, v∈Q, the constraint “not both u,v violators” becomes the conjunction of two 2-clauses conditioned on o_C:
- If o_C=0 (u expects a, v expects b), forbid α_u ∧ β_v, i.e., add (¬α_u ∨ ¬β_v).
- If o_C=1 (u expects b, v expects a), forbid β_u ∧ α_v, i.e., add (¬β_u ∨ ¬α_v).
Introduce o_C as a boolean and encode the two implications as 2-clauses:
(o_C → (¬β_u ∨ ¬α_v)) and (¬o_C → (¬α_u ∨ ¬β_v)), which in CNF are (¬o_C ∨ ¬β_u ∨ ¬α_v) and (o_C ∨ ¬α_u ∨ ¬β_v). Under single-touch, α_·,β_· are single literals on some t_K (or constants), so each clause has at most three literals with at most two t-variables; however, because o_C appears in only these binary choices per edge, one can eliminate o_C by testing both orientations per C in linear time and accumulating pure 2-clauses on {t_K}. Since the number of orientations per C is 2, this yields a 2-SAT instance over {t_K} per orientation choice per C and can be combined by standard “implication graph merge” within linear–quadratic time overall (or simply branch over the 2^{#components(L∪R)} choices, which is polynomial if the number of side components is O(1)). The essential point is that, under single-touch and after removing forced-0, edge constraints collapse to clauses of the form (¬literal(t_{K(u)}) ∨ ¬literal(t_{K(v)})), which are 2-clauses. This establishes a 2-SAT solvability in this subclass.
Remarks. The above does not resolve the general case: if y touches multiple N(x)-components, “color appears” becomes an OR over multiple t_K’s, and the edge constraints lift to 3+-clauses.

IV. Small examples and checks
- Permutation N(x): Example with three neighbors whose left endpoints are in order a1<a2<a3 and right endpoints in reversed order b3<b2<b1 yields a triangle in N(x), proving immediate NO for 3-coloring when x is preassigned any color.
- DP sanity check: Construct intervals with ply w=2 and n=6; run the DP (start-assign at s(b) avoiding colors in the prefix by right endpoints). Verifier can exhaustively check that no edge’s endpoints receive the same color.
- Single-touch 2-SAT: Build L a path u–v–w, R empty. Let N(x) have two components K1,K2. Give u neighbors only in the U side of K1 (so α_u = ¬t_{K1}, β_u = t_{K1}), v neighbors only in the V side of K1, and w neighbors only in U side of K2. After removing forced-0 (none), constraints per edge reduce to 2-clauses on t_{K1} and t_{K2}; consistency is decidable by 2-SAT.

V. Obstacles and why attempts fail
- General 2-SAT collapse fails because for y touching multiple components, “color c appears” is an OR of literals over several t_K’s; prohibiting simultaneous violations across an edge then yields clauses of width ≥3. Attempts to introduce auxiliary variables to capture ORs either lose completeness (only implications one way) or reintroduce non-2-CNF constraints.
- Extending beyond bipartite sides seems to require selecting an independent odd-cycle transversal under list constraints induced by N(x), a problem whose complexity on circle graphs (with lists arising from N(x)) is unclear and plausibly hard.

VI. Next steps (concrete and testable)
1) Finalize Theorem 1 in the write-up with explicit reconstruction of colorings and implement; benchmark typical w on random and structured instances.
2) Codify Lemma 3 (double neighborhoods) in the notes and use it to bound the structure of N(x)∩N(y) in separator-based heuristics.
3) Implement the bipartite-sides algorithm and add the single-touch detector; on single-touch inputs, solve the extension via the 2-SAT reduction above; otherwise, fall back to the 2^{cc(N(x))} branching.
4) Explore two-chord separators: partition by {x,y} into four side regions and a middle permutation layer N(x)∩N(y); attempt a generalization of Proposition 4 with two interfaces and orientation choices per region.
5) Hardness direction: search for K4-free circle-graph gadgets encoding NAE constraints while preserving chord realizability; start with small SAT-assisted gadget synthesis.

Summary of contributions this round.
- A complete, rigorous DP for k-colorability parameterized by the representation’s ply w with O(n·w·k^w) time, including correctness proof via a sweep maintaining active-interval colors in right-endpoint order.
- Cleaned neighborhood lemmas: N(x) is permutation; N(x)∩N(y) is permutation (hereditary), with concise proofs.
- A precise audit of the 2-SAT idea: general failure reason; a special subclass (single-touch, after forced-0 preprocessing) where constraints collapse to 2-clauses on {t_K}, leading to polynomial-time solvability for that subclass; and a practical hybrid algorithm using this when applicable.