{
  "content": "# Refining the endpoint-DP: O(n \u00b7 k^{w+1}) with O(1)-time transitions\n\nWe restate and sharpen the k-colorability algorithm parameterized by the interval ply w of a given overlap representation.\n\nTheorem. Given an interval-overlap representation of a circle graph G on n chords with ply w, k-colorability is decidable in time O(n \u00b7 k^{w+1}) and space O(k^w). For k = 3 the runtime is O(n \u00b7 3^{w+1}).\n\nProof (algorithm and analysis). Sort the 2n endpoints e_1 < \u2026 < e_{2n}. Let A_t be the active set of intervals covering the open segment (e_t, e_{t+1}); |A_t| \u2264 w. In any proper k-coloring, for each color c, the simultaneously active intervals of color c form a chain under containment (hence a LIFO stack by right endpoints). A DP state at position t consists of:\n- a partition of A_t into k stacks S^1_t,\u2026,S^k_t,\n- for each c, a pointer top(c) to the unique interval with minimum right endpoint in S^c_t (undefined if empty).\nInitialization: S_0 = {(\u2205,\u2026,\u2205)}.\nTransition at event e_{t+1}:\n- If e_{t+1} starts interval j (with right endpoint r_j): From each state, branch to at most k successors by choosing any color c with either S^c_t = \u2205 or r_j < r_top(c); push j onto S^c_t and set top(c) \u2190 j.\n- If e_{t+1} ends interval j: A state survives iff j equals top(c) for exactly one color c; then pop j from S^c_t and set top(c) to the previous stack element in O(1).\nCorrectness follows by the usual push/pop invariant: same-color overlaps are precluded because pushes are allowed only strictly inside the current top; pops enforce LIFO nesting. Conversely, any valid coloring yields a unique run.\nComplexity: At any t, the number of partitions is \u2264 k^{|A_t|} \u2264 k^w. For a start event, each state branches to at most k successors; for an end event, checking j = top(c) for some c takes O(k) (constant for fixed k). Each push/pop updates top(c) in O(1) using a per-color linked stack inside the state. Over 2n events, time O(n \u00b7 k^{w+1}); memory O(k^w). \u220e\n\nRemark. This DP is precisely a standard path-decomposition DP (see next lemma), and the O(1)-time pop is achieved by maintaining, per state and per color, only the top pointers of the stacks together with back-pointers.\n\n# Path-decomposition viewpoint (rigorous)\n\nLemma (pathwidth bound). Let w be the ply of the interval family. For each elementary segment \u03c3 between consecutive endpoints, form the bag B(\u03c3) of intervals containing \u03c3. Then (B(\u03c3)) is a path decomposition of the overlap graph with width \u2264 w\u22121.\n\nProof. (i) Vertex coverage: An interval x appears in B(\u03c3) for every \u03c3 \u2282 (s(x), t(x)), a contiguous set along the path of segments. (ii) Edge coverage: If x,y overlap (say s(x)<s(y)<t(x)<t(y)), then every segment \u03c3 \u2282 (s(y), t(x)) is contained in both x and y, hence {x,y} \u2286 B(\u03c3). (iii) Width: |B(\u03c3)| equals the number of intervals covering \u03c3, bounded by w. Thus width \u2264 w\u22121. \u220e\n\nCorollary. The DP above is exactly the standard DP on this path decomposition with a specialized state compression (stacks), yielding the stated FPT bounds.\n\n# Interface lemma for a pivot chord\n\nSet-up. Fix a chord x with endpoints x_L, x_R. Let A be the left arc from x_L to x_R (clockwise), and B the right arc from x_R to x_L. Let L be chords with both endpoints on A, R those with both on B, and N(x) the chords crossing x.\n\nLemma (interface). For y \u2208 L, the neighbor set N(y) \u2229 N(x) consists exactly of those z \u2208 N(x) whose endpoint on A lies strictly between the endpoints of y along A. Symmetrically for y \u2208 R using the endpoint on B.\n\nProof. Any z \u2208 N(x) has one endpoint on A and its other endpoint on B. Two chords y (both endpoints on A) and z intersect iff, when traversing the circle, exactly one endpoint of z appears between the endpoints of y. Since both endpoints of y lie on A, this happens iff the unique endpoint of z on A lies strictly between the endpoints of y along A. The condition on the B-endpoint of z is then automatic (lies outside y). \u220e\n\nConsequence. Fix a proper 2-coloring of G[N(x)]. For any y \u2208 L, the set S_y \u2286 {1,2} of colors used by N(x)\u2229N(y) depends only on which colored endpoints of N(x) lie between y\u2019s endpoints along A, and can be computed by a sweep on A. This underpins the 2-SAT side-extension test.\n\n# Polynomial-time side extension via 2-SAT (formal packaging)\n\nGiven a pivot x, suppose G[L] and G[R] are bipartite. Fix a proper 2-coloring of each connected component of G[N(x)] with color names {1,2}. For each side component K \u2286 L (resp. R) with bipartition A_K \u2294 B_K, introduce a Boolean p_K indicating the orientation: p_K=0 means A_K\u21921, B_K\u21922; p_K=1 swaps them. For each y \u2208 K introduce a Boolean z_y that is 1 iff y takes color 3. By the interface lemma we can precompute S_y.\n\nFor each side K, the following 2-CNF constraints are necessary and sufficient for extendability on K:\n- (Independence of 3\u2019s) For each edge uv in K: (\u00acz_u \u2228 \u00acz_v).\n- (Forced 3\u2019s) If S_y = {1,2}: add unit clause z_y.\n- (Avoid forbidden color) If S_y = {1}:\n  \u2022 y \u2208 A_K: add (z_y \u2228 p_K), and if S_y = {2}: add (z_y \u2228 \u00acp_K).\n  \u2022 y \u2208 B_K: add (z_y \u2228 \u00acp_K), and if S_y = {2}: add (z_y \u2228 p_K).\n- If S_y = \u2205: add unit clause \u00acz_y.\nSolving the 2-SAT instance independently for K \u2286 L and K \u2286 R yields a polynomial-time test for extendability for the fixed coloring of N(x). This matches the earlier proposition and is now fully formalized.\n\nGlobal algorithm (pivot x): enumerate the 2-coloring orientations for each component of N(x) (two per component), solve the two independent 2-SATs for L and R per choice, accept if any succeeds. Runtime O(2^{cc(N(x))} \u00b7 poly(n)) per x.\n\n# Why one cannot (in general) avoid branching over orientations of N(x)\n\nAttempting to fold the orientation choices of the components of N(x) into a single 2-SAT leads to clauses of the form \u201cif y does not take color 3, then the color induced on y by p_K must differ from the color induced at y by the orientation q_C of some N(x)-component C that touches y.\u201d Formally, for y \u2208 K and a component C that contributes neighbors to y from a single side of its bipartition, one gets the conditional XOR constraint\n(\u00acz_y) \u21d2 (p_K \u2295 q_C = \u03b1_y),\nfor a fixed \u03b1_y \u2208 {0,1} depending on whether y lies in A_K or B_K and which side of C hits y. Such gated XOR constraints are not representable as 2-CNF in general; they require either (i) branching over the q_C (our algorithm), or (ii) moving to a strictly more general CSP than 2-SAT. This pinpoints the necessity of the 2^{cc(N(x))} factor in our current polynomial-time pivot framework.\n\n# Small examples illustrating the interface and 2-SAT\n\n- Construct x and four neighbors in N(x) whose A-endpoints along A are colored 1,2,1,2 in order. A side vertex y whose A-span covers the middle pair has S_y={1,2} and is forced to z_y=1. A y covering exactly the second A-endpoint has S_y={2}, yielding the single clause (z_y \u2228 constraint on p_K) as above.\n- A side component K as a path y1\u2013y2\u2013y3 with S_{y1}={1}, S_{y2}=\u2205, S_{y3}={2} gives the 2-SAT instance: (z1 \u2228 \u21131) \u2227 (\u00acz2) \u2227 (z3 \u2228 \u21133) \u2227 (\u00acz1 \u2228 \u00acz2) \u2227 (\u00acz2 \u2228 \u00acz3). Satisfiable iff either z1=z3=1 and z2=0 with independence, or an orientation p_K satisfies both \u21131 and \u21133 simultaneously.\n\n# Additional structural facts (recorded for proofs.md)\n\n- Ply \u2264 2 implies acyclic. Proof: Assume a cycle x1,\u2026,xm. Let xi be the interval in the cycle with minimum right endpoint r_i. Its two cycle neighbors both start before s(xi) and end after r_i, so the point just before r_i is covered by at least three intervals, contradicting w \u2264 2. \u220e\n- N(x) and N(x)\u2229N(y) are permutation graphs (and hereditary), hence polynomial-time 2-colorable and with rich structure usable as \u201cmiddle gadgets.\u201d\n\n# Obstacles\n\n- Eliminating the 2^{cc(N(x))} factor without strengthening assumptions appears to require solving a generalized 2-variable parity-CSP with clauses gated by vertex choices z_y. This embeds a signed-edge deletion problem (choose a set of z_y to drop parity constraints) that is not captured by 2-SAT and is unlikely to be polynomial in full generality.\n- The ply parameter is representation-dependent and can be \u0398(n) even for easy instances; unconditional P-time from the DP seems out of reach without a qualitatively new invariant.\n\n# Next steps (testable)\n\n- Implementation: (i) the O(n \u00b7 k^{w+1}) DP with explicit per-color stacks; (ii) the pivot algorithm with 2-SAT per side and early pruning via incremental orientation assignments; measure cc(N(x)) distributions and practical branching.\n- Two-pivot separators: formalize the four-region partition induced by two chords a,b and analyze whether the middle region N(a)\u2229N(b) admits a similar orientation-plus-2-SAT extension with fewer branches (enumerate orientations per connected component of N(a)\u2229N(b)).\n- Tiny ply study: enumerate all w=3 representations up to small n and verify that the DP is linear-time and that w=3 instances exhibit small cc(N(x)) for some pivot frequently (empirical evidence for practical algorithms).\n- Hardness direction: design and verify small circle-graph gadgets (palette, wire with 2-color domain, clause-like constraints) with explicit chord diagrams; attempt to propagate constraints through N(x) permutation subgraphs.\n\n# For output.md (provisional)\n\n- The DP theorem with strengthened O(n \u00b7 k^{w+1}) time via O(1) transitions and the path-decomposition lemma.\n- The interface lemma with a clean proof and its algorithmic corollary (fast computation of S_y).\n- The formal 2-SAT side-extension packaging and a precise statement of why global 2-SAT cannot combine the orientation choices, justifying the 2^{cc(N(x))} factor.\n"
}