# Refining the endpoint-DP: O(n · k^{w+1}) with O(1)-time transitions

We restate and sharpen the k-colorability algorithm parameterized by the interval ply w of a given overlap representation.

Theorem. Given an interval-overlap representation of a circle graph G on n chords with ply w, k-colorability is decidable in time O(n · k^{w+1}) and space O(k^w). For k = 3 the runtime is O(n · 3^{w+1}).

Proof (algorithm and analysis). Sort the 2n endpoints e_1 < … < e_{2n}. Let A_t be the active set of intervals covering the open segment (e_t, e_{t+1}); |A_t| ≤ w. In any proper k-coloring, for each color c, the simultaneously active intervals of color c form a chain under containment (hence a LIFO stack by right endpoints). A DP state at position t consists of:
- a partition of A_t into k stacks S^1_t,…,S^k_t,
- for each c, a pointer top(c) to the unique interval with minimum right endpoint in S^c_t (undefined if empty).
Initialization: S_0 = {(∅,…,∅)}.
Transition at event e_{t+1}:
- If e_{t+1} starts interval j (with right endpoint r_j): From each state, branch to at most k successors by choosing any color c with either S^c_t = ∅ or r_j < r_top(c); push j onto S^c_t and set top(c) ← j.
- If e_{t+1} ends interval j: A state survives iff j equals top(c) for exactly one color c; then pop j from S^c_t and set top(c) to the previous stack element in O(1).
Correctness follows by the usual push/pop invariant: same-color overlaps are precluded because pushes are allowed only strictly inside the current top; pops enforce LIFO nesting. Conversely, any valid coloring yields a unique run.
Complexity: At any t, the number of partitions is ≤ k^{|A_t|} ≤ k^w. For a start event, each state branches to at most k successors; for an end event, checking j = top(c) for some c takes O(k) (constant for fixed k). Each push/pop updates top(c) in O(1) using a per-color linked stack inside the state. Over 2n events, time O(n · k^{w+1}); memory O(k^w). ∎

Remark. This DP is precisely a standard path-decomposition DP (see next lemma), and the O(1)-time pop is achieved by maintaining, per state and per color, only the top pointers of the stacks together with back-pointers.

# Path-decomposition viewpoint (rigorous)

Lemma (pathwidth bound). Let w be the ply of the interval family. For each elementary segment σ between consecutive endpoints, form the bag B(σ) of intervals containing σ. Then (B(σ)) is a path decomposition of the overlap graph with width ≤ w−1.

Proof. (i) Vertex coverage: An interval x appears in B(σ) for every σ ⊂ (s(x), t(x)), a contiguous set along the path of segments. (ii) Edge coverage: If x,y overlap (say s(x)<s(y)<t(x)<t(y)), then every segment σ ⊂ (s(y), t(x)) is contained in both x and y, hence {x,y} ⊆ B(σ). (iii) Width: |B(σ)| equals the number of intervals covering σ, bounded by w. Thus width ≤ w−1. ∎

Corollary. The DP above is exactly the standard DP on this path decomposition with a specialized state compression (stacks), yielding the stated FPT bounds.

# Interface lemma for a pivot chord

Set-up. Fix a chord x with endpoints x_L, x_R. Let A be the left arc from x_L to x_R (clockwise), and B the right arc from x_R to x_L. Let L be chords with both endpoints on A, R those with both on B, and N(x) the chords crossing x.

Lemma (interface). For y ∈ L, the neighbor set N(y) ∩ N(x) consists exactly of those z ∈ N(x) whose endpoint on A lies strictly between the endpoints of y along A. Symmetrically for y ∈ R using the endpoint on B.

Proof. Any z ∈ N(x) has one endpoint on A and its other endpoint on B. Two chords y (both endpoints on A) and z intersect iff, when traversing the circle, exactly one endpoint of z appears between the endpoints of y. Since both endpoints of y lie on A, this happens iff the unique endpoint of z on A lies strictly between the endpoints of y along A. The condition on the B-endpoint of z is then automatic (lies outside y). ∎

Consequence. Fix a proper 2-coloring of G[N(x)]. For any y ∈ L, the set S_y ⊆ {1,2} of colors used by N(x)∩N(y) depends only on which colored endpoints of N(x) lie between y’s endpoints along A, and can be computed by a sweep on A. This underpins the 2-SAT side-extension test.

# Polynomial-time side extension via 2-SAT (formal packaging)

Given a pivot x, suppose G[L] and G[R] are bipartite. Fix a proper 2-coloring of each connected component of G[N(x)] with color names {1,2}. For each side component K ⊆ L (resp. R) with bipartition A_K ⊔ B_K, introduce a Boolean p_K indicating the orientation: p_K=0 means A_K→1, B_K→2; p_K=1 swaps them. For each y ∈ K introduce a Boolean z_y that is 1 iff y takes color 3. By the interface lemma we can precompute S_y.

For each side K, the following 2-CNF constraints are necessary and sufficient for extendability on K:
- (Independence of 3’s) For each edge uv in K: (¬z_u ∨ ¬z_v).
- (Forced 3’s) If S_y = {1,2}: add unit clause z_y.
- (Avoid forbidden color) If S_y = {1}:
  • y ∈ A_K: add (z_y ∨ p_K), and if S_y = {2}: add (z_y ∨ ¬p_K).
  • y ∈ B_K: add (z_y ∨ ¬p_K), and if S_y = {2}: add (z_y ∨ p_K).
- If S_y = ∅: add unit clause ¬z_y.
Solving the 2-SAT instance independently for K ⊆ L and K ⊆ R yields a polynomial-time test for extendability for the fixed coloring of N(x). This matches the earlier proposition and is now fully formalized.

Global algorithm (pivot x): enumerate the 2-coloring orientations for each component of N(x) (two per component), solve the two independent 2-SATs for L and R per choice, accept if any succeeds. Runtime O(2^{cc(N(x))} · poly(n)) per x.

# Why one cannot (in general) avoid branching over orientations of N(x)

Attempting to fold the orientation choices of the components of N(x) into a single 2-SAT leads to clauses of the form “if y does not take color 3, then the color induced on y by p_K must differ from the color induced at y by the orientation q_C of some N(x)-component C that touches y.” Formally, for y ∈ K and a component C that contributes neighbors to y from a single side of its bipartition, one gets the conditional XOR constraint
(¬z_y) ⇒ (p_K ⊕ q_C = α_y),
for a fixed α_y ∈ {0,1} depending on whether y lies in A_K or B_K and which side of C hits y. Such gated XOR constraints are not representable as 2-CNF in general; they require either (i) branching over the q_C (our algorithm), or (ii) moving to a strictly more general CSP than 2-SAT. This pinpoints the necessity of the 2^{cc(N(x))} factor in our current polynomial-time pivot framework.

# Small examples illustrating the interface and 2-SAT

- Construct x and four neighbors in N(x) whose A-endpoints along A are colored 1,2,1,2 in order. A side vertex y whose A-span covers the middle pair has S_y={1,2} and is forced to z_y=1. A y covering exactly the second A-endpoint has S_y={2}, yielding the single clause (z_y ∨ constraint on p_K) as above.
- A side component K as a path y1–y2–y3 with S_{y1}={1}, S_{y2}=∅, S_{y3}={2} gives the 2-SAT instance: (z1 ∨ ℓ1) ∧ (¬z2) ∧ (z3 ∨ ℓ3) ∧ (¬z1 ∨ ¬z2) ∧ (¬z2 ∨ ¬z3). Satisfiable iff either z1=z3=1 and z2=0 with independence, or an orientation p_K satisfies both ℓ1 and ℓ3 simultaneously.

# Additional structural facts (recorded for proofs.md)

- Ply ≤ 2 implies acyclic. Proof: Assume a cycle x1,…,xm. Let xi be the interval in the cycle with minimum right endpoint r_i. Its two cycle neighbors both start before s(xi) and end after r_i, so the point just before r_i is covered by at least three intervals, contradicting w ≤ 2. ∎
- N(x) and N(x)∩N(y) are permutation graphs (and hereditary), hence polynomial-time 2-colorable and with rich structure usable as “middle gadgets.”

# Obstacles

- Eliminating the 2^{cc(N(x))} factor without strengthening assumptions appears to require solving a generalized 2-variable parity-CSP with clauses gated by vertex choices z_y. This embeds a signed-edge deletion problem (choose a set of z_y to drop parity constraints) that is not captured by 2-SAT and is unlikely to be polynomial in full generality.
- The ply parameter is representation-dependent and can be Θ(n) even for easy instances; unconditional P-time from the DP seems out of reach without a qualitatively new invariant.

# Next steps (testable)

- Implementation: (i) the O(n · k^{w+1}) DP with explicit per-color stacks; (ii) the pivot algorithm with 2-SAT per side and early pruning via incremental orientation assignments; measure cc(N(x)) distributions and practical branching.
- Two-pivot separators: formalize the four-region partition induced by two chords a,b and analyze whether the middle region N(a)∩N(b) admits a similar orientation-plus-2-SAT extension with fewer branches (enumerate orientations per connected component of N(a)∩N(b)).
- Tiny ply study: enumerate all w=3 representations up to small n and verify that the DP is linear-time and that w=3 instances exhibit small cc(N(x)) for some pivot frequently (empirical evidence for practical algorithms).
- Hardness direction: design and verify small circle-graph gadgets (palette, wire with 2-color domain, clause-like constraints) with explicit chord diagrams; attempt to propagate constraints through N(x) permutation subgraphs.

# For output.md (provisional)

- The DP theorem with strengthened O(n · k^{w+1}) time via O(1) transitions and the path-decomposition lemma.
- The interface lemma with a clean proof and its algorithmic corollary (fast computation of S_y).
- The formal 2-SAT side-extension packaging and a precise statement of why global 2-SAT cannot combine the orientation choices, justifying the 2^{cc(N(x))} factor.
