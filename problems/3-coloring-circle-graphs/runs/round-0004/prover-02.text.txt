# Aim
Consolidate and extend auditable structural/algorithmic pieces toward the 3-coloring problem on circle graphs: finalize and tighten proofs flagged in feedback (balanced separator, degeneracy), add implementable subroutines (computing S(y) in linear time), and extract a modest new parameterized extension of the pivot approach.

# Preliminaries (overlap model)
- Represent chords as open intervals (s(x), t(x)) along the circle’s cyclic order after cutting at a non-endpoint. Adjacency: x ∼ y iff s(x) < s(y) < t(x) < t(y) or symmetrically.
- Ply w: the maximum number of intervals covering any point (between consecutive endpoints). Let the elementary segments be the open gaps between consecutive endpoints.

# Lemma 1 (each sweep bag is a permutation graph)
Fix an elementary segment σ. Let B(σ) be the set of intervals covering σ. Then G[B(σ)] is a permutation graph.

Proof. Every y ∈ B(σ) has one endpoint to the left of σ (its start s(y)) and one to the right (its end t(y)). Order B(σ) by the left endpoints {s(y)} and independently by the right endpoints {t(y)}. For u,v ∈ B(σ), u ∼ v iff their relative orders are inverted: say s(u) < s(v) but t(u) > t(v), or vice versa. This is exactly the permutation-graph definition. ∎

# Lemma 2 (path decomposition of width ≤ w−1)
Let σ_1, …, σ_{2n−1} be the elementary segments in order; define bags B_i = B(σ_i). Then (B_i) is a path decomposition of G with width ≤ w−1.

Proof. Vertex coverage/contiguity: An interval x covers precisely the contiguous set of segments σ ⊂ (s(x), t(x)), so the set of bags containing x is contiguous. Edge coverage: If x ∼ y (assume s(x)<s(y)<t(x)<t(y)), then every σ ⊂ (s(y), t(x)) is covered by both x and y, so some bag contains {x,y}. Width: |B_i| ≤ w by definition of ply. ∎

Corollary. The endpoint sweep DP for k-colorability is the standard DP over this path decomposition, with at most k^{|B_i|} ≤ k^w states per bag.

# Theorem A (DP for k-colorability: O(n·w·k^w))
Given an overlap representation with ply w, k-colorability can be decided in time O(n·w·k^w) and space O(k^w). The same holds starting from a graph after computing a representation in poly(n) time.

Proof sketch (finalized). At each event, maintain a state that partitions the active set A_t into k color-stacks; per color, store the top interval (minimum right endpoint). Start events push onto any color whose top has strictly larger right endpoint; end events pop iff the ending interval is the top of its color. Correctness follows from the invariant that same-color active intervals must form a containment chain; LIFO is necessary and sufficient for extensibility. There are ≤ k^{|A_t|} ≤ k^w states per layer; transitions per event cost O(k) (or O(1) amortized with fixed k) and pop recomputation O(1) with per-color linked stacks. Over 2n events: O(n·w·k^w) time, O(k^w) space. ∎

Extensions. The same DP handles list-k-coloring (restrict allowed push colors to L(j)) and counting colorings (carry counts per canonical state and sum over predecessors) within the same bounds.

# Lemma 3 (balanced separator by a sweep bag; corrected proof)
There exists an index i with a(i) := |{x : t(x) ≤ e_i}| ∈ [⌈n/3⌉, ⌊2n/3⌋], and for such i we have c(i) := |{x : s(x) ≥ e_{i+1}}| ≤ 2n/3 − 1. Consequently, removing S := B(σ_i) separates G into two induced subgraphs on at most 2n/3 vertices each.

Proof. The sequence a(i) is nondecreasing from a(0)=0 to a(2n−1)=n. Let i be the minimum index with a(i) ≥ n/3; thus a(i−1) < n/3 ≤ a(i). Since i lies between the first start and the last end, the segment σ_i is covered by at least one interval, so |B(σ_i)| ≥ 1. Using n = a(i) + |B(σ_i)| + c(i), we get c(i) = n − |B(σ_i)| − a(i) ≤ n − 1 − n/3 < 2n/3. The path-decomposition property of (B(σ)) implies that removing B(σ_i) disconnects vertices whose intervals end before e_{i+1} from those that start after e_{i+1}, so the removal separates G into the two parts counted by a(i) and c(i). ∎

Remark. This yields a standard divide-and-conquer template with separator S = B(σ_i), but no a priori bound on |S| beyond w is available in general.

# Lemma 4 (degeneracy bound ≤ 2w−2)
Any overlap graph with ply w is (2w−2)-degenerate. In particular, m ≤ (w−1)n.

Proof. Consider any induced subgraph H and pick a vertex b ∈ V(H) whose right endpoint t(b) is minimum among vertices of H. Classify neighbors of b in H as earlier-start (s(a) < s(b)) or later-start (s(a) > s(b)). If a is an earlier-start neighbor, then t(a) > s(b) (they overlap), so a is active immediately to the right of s(b). At that point, there are at most w−1 active intervals besides b; thus b has at most w−1 earlier-start neighbors. If a is a later-start neighbor, then s(a) < t(b) and t(a) > t(b), so a is active immediately to the left of t(b). There are at most w−1 active intervals besides b there, giving at most w−1 later-start neighbors. Hence deg_H(b) ≤ 2w−2, and every induced subgraph has a vertex of degree ≤ 2w−2. Summing degrees gives m ≤ (w−1)n. ∎

# Pivot interface and linear-time computation of S(y)
Fix a pivot chord x (with color fixed to 3 in the extension test). Let A be the left arc from x_L to x_R and B the right arc from x_R to x_L. Let L be chords with both endpoints on A, R analogously on B, and N(x) the chords crossing x.

Interface Lemma (restated). For y ∈ L, N(y)∩N(x) consists exactly of those z ∈ N(x) whose A-endpoint lies strictly between y’s endpoints along A. Symmetrically for y ∈ R via the B-endpoint.

Computing S(y) in O(|L|+|N(x)|). Fix a 2-coloring of G[N(x)] with colors {1,2}; color each z ∈ N(x) by its side endpoint on A (for L) or B (for R). Along arc A, sort the endpoints of N(x) and build prefix sums P_c over c ∈ {1,2} that count colored endpoints up to each elementary subarc. For y with endpoints at positions ℓ<r on A, define S_y ⊆ {1,2} by: c ∈ S_y iff P_c(r−1) − P_c(ℓ) > 0. This reports whether some z of color c lies between y’s endpoints, exactly as required by the interface lemma. The same holds for R using B. Overall O(|N(x)| + |L|) and O(|N(x)| + |R|) time per side after sorting.

# Proposition B (side extension via 2-SAT; formal)
Given pivot x with col(x)=3, if both G[L] and G[R] are bipartite and a 2-coloring of each component of G[N(x)] is fixed, then feasibility of a 3-coloring extending these choices is checkable in linear time by two independent 2-SAT instances (one per side), as previously specified: variables p_K per side component K (orientation) and z_y per vertex y (use of color 3), clauses enforcing (i) independence of z=1 vertices, (ii) forced z=1 when S_y={1,2}, (iii) avoidance of forbidden side color when S_y ∈ {1} or {2}, and (iv) forced z=0 when S_y=∅. See prior notes for the explicit clause mapping. This yields runtime O(2^{cc(N(x))}·poly(n)) per pivot over the orientations of G[N(x)].

# A modest FPT generalization of the pivot approach
We parameterize the number of side vertices colored 3 beyond those forced by S_y={1,2}. For a fixed pivot x with bipartite sides and a fixed orientation of G[N(x)] components, define F_side = {y : S_y={1,2}} (forced to z_y=1) and let t be a nonnegative integer. Consider whether there exists an extension coloring with at most t additional side vertices per side assigned color 3.

Proposition C (FPT in t + cc(N(x))). For fixed x, bipartite sides, and a chosen orientation of G[N(x)], one can decide whether there exists an extension with at most t additional 3-colored vertices per side in time O(f(t)·poly(n)), where f(t) = Σ_{i=0}^t (Δ^i) with Δ the maximum side degree, multiplied by 2^{cc(N(x))} across the orientations. Concretely, branch on choosing up to t vertices per side to set z=1 (always respecting independence via immediate pruning), then solve the resulting 2-SAT as in Proposition B (with all remaining z fixed to 0 except the forced ones). If any branch succeeds, accept.

Justification. After fixing a branch Z of optional z=1 vertices, the residual constraints are exactly those of Proposition B (with z fixed), which reduce to 2-SAT per side and can be solved in linear time. Independence of Z is enforced by branching only on independent augmentations (or by adding (¬z_u ∨ ¬z_v) for edges). The overall branching factor depends on the side graph’s degrees; depth ≤ t per side. While crude, this gives an explicit FPT extension beyond the purely bipartite-sides case (t=0). Note: More refined FPT in t is achievable by classic bounded-search on independent sets, but the above suffices as a testable, implementable baseline.

Caveat. The above does not address breaking odd cycles on the sides; it only allows relaxing color conflicts against N(x). Handling odd cycles suggests branching on an independent odd-cycle transversal per side; this is a natural parameterized avenue but requires additional machinery.

# Examples
- w ≤ 2 implies forest. Consider three intervals forming a 3-cycle x–y–z–x under overlap. Let x have minimum t(x). Then s(y) < s(x) < t(y) and s(z) < s(x) < t(z), so just right of s(x) at least x,y,z are active, contradicting w ≤ 2. Hence no cycles; the graph is a forest (bipartite).

- Pivot with modest branching. Let N(x) be a path on four vertices (cc=1). On side L, a component K is a 4-cycle y1–y2–y3–y4–y1 with S_{y1}={1,2} (forced z=1), S_{y2}={1}, S_{y3}={2}, S_{y4}=∅. Forced z_{y1}=1; z_{y4}=0. The 2-SAT clauses constrain p_K via y2,y3. If these conflict, we may branch with t≥1 to set z_{y2}=1 or z_{y3}=1 (while respecting independence), restoring satisfiability.

# Obstacles and clarifications
- Global 2-SAT over all orientations (no branching): Constraints induced by side vertices with S_y ∈ {1},{2} take the form (¬z_y) ⇒ (p_K ⊕ q_C = α_y). Parity between two orientation variables is 2-CNF only when not gated; the gate produces 3-clauses (z_y ∨ …), so a plain 2-CNF encoding is not available in general. This pinpoints why the 2^{cc(N(x))} branching is presently necessary.
- Separator-based subexponentiality: While Lemma 3 gives balanced separation, separator sizes are |B(σ)| with no sublinear bound in general; thus no general subexponential algorithm follows from this separator alone.
- Representation dependence: All ply-parameterized guarantees are for the given (or computed) representation; minimizing ply over all representations is nontrivial and not used here.

# Next steps (auditable)
- Move Lemmas 1–4 and Theorem A (with list/color-counting corollaries) to proofs.md with full details; include explicit data structures for O(1) push/pop and state hashing for DP.
- Implement: (i) the O(n·w·3^w) DP (including list-coloring and counting modes), (ii) the pivot algorithm with 2-SAT per side and with the optional FPT branching in Proposition C. Benchmark on random and structured instances; measure w, cc(N(x)), and empirical branching.
- Explore two-pivot separators structurally: formalize the four-arc partition induced by two chords a,b; prove that M:=N(a)∩N(b) is permutation and work out interface sets to outer arcs. Attempt an orientation-plus-2-SAT extension akin to the single-pivot case for subclasses where outer arcs are bipartite.
- Investigate characterization at tiny ply: for w=3,4, provide explicit linear-time deciders leveraging Theorem A and quantify typical w in computed circle representations.
- Hardness direction: Continue SAT-aided gadget search inside K4-free circle graphs (wires, equality, NAE constraints), guided by the N(x) permutation structure.

# Provisional items for output.md
- Theorem A (DP for k-colorability, list-coloring, counting) with path-decomposition proof and complexity O(n·w·k^w).
- Lemma 1 (bags are permutation graphs), Lemma 3 (balanced separator with corrected proof), Lemma 4 (degeneracy ≤ 2w−2; m ≤ (w−1)n).
- Pivot-side 2-SAT packaging and linear-time computation of S(y); Proposition B (polytime extension under bipartite sides) and Proposition C (FPT in t + cc(N(x)) generalization).
