{
  "progress_md": "Ideas and plan for NEXPTIME-hardness via feasible functions (and gaps spotted)\n\nContext recap and goal\n- We work with \u03b2-normalized, radius-1 LCLs on globally oriented paths, with explicit tables Cin\u2013out and Cout\u2013out. The classification into O(1), \u0398(log\u2217 n), \u0398(n) in the path/cycle case goes via the existence of a feasible function f on \u201ccontext types\u201d (mid-consistency F1 gives O(log\u2217 n) vs \u0398(n); adding bridging F2 gives O(1) vs \u03a9(log\u2217 n)), per Section 4 of the reference (Lemmas 10\u201315, 11, 12; Theorems 8\u20139).\n- The attached draft provides: (i) a NEXPTIME upper bound for deciding feasible-function existence (with an explicit bound Z \u2264 \u2113pump^2 for (F2) finite checks and an O(k \u03b2^2) DP for local extendibility), and (ii) a hardness sketch (Section B) intended to reduce Succinct-3SAT to mid-consistency (F1).\n\nCritical gaps in the current hardness sketch (Section B)\n1) Universal machine runtime and one-hot vectors: The draft says a fixed U runs in BO(1) to compute clause literals and uses a 2^B-long one-hot vector HotRID. Neither is feasible. Evaluating a size-s circuit C requires poly(s) steps; one-hot vectors of length 2^B cannot be produced/stored in a constant-alphabet radius-1 LCL with poly(s) footprint.\n2) Mid-consistency quantifies over all ordered pairs of contexts. The current design enforces that for (variable i, clause j) pairs the bridge only succeeds if i appears in j and the chosen colors match a picked literal. But f(Clj) is fixed per type; then for the other two variables in the same clause the bridge would fail, contradicting the \u201cfor all pairs\u201d requirement in (F1). This is a fundamental mismatch: 3SAT\u2019s \u201c\u2203 satisfied literal\u201d cannot be expressed by a constraint that must hold for every pairing.\n3) Type\u2013separation assumptions: The sketch implicitly needs exponentially many distinct context types (e.g., one per RID and per GID) and that type equality can be forced to depend on RID/GID. This needs a concrete mechanism to \u201cproject\u201d the index to a boundary-extendibility distinction (otherwise different indices could collapse to the same type).\n\nProposed pivot: reduce from Succinct 3-Coloring (NEXPTIME-complete)\nWhy it matches (F1):\n- Feasible-function mid-consistency induces pairwise constraints among context-types. 3-colorability of a succinctly described graph H on 2^B vertices is a pure pairwise constraint system: for each edge (u, v) we require color(u) \u2260 color(v). This aligns with \u201cfor all ordered pairs\u201d checks, provided we gate the bridge so that non-edges are trivial.\n- Succinct 3-coloring is NEXP-complete (Papadimitriou\u2013Yannakakis). The succinct adjacency oracle A(u, v) is a circuit of size s on 2B bits. This lets us stay within poly(s) resources inside a block.\n\nRefined reduction outline (mid-consistency (F1) only)\n- Instance: succinct graph G on V = {0,1}^B, circuit D(u, v) outputs 1 iff edge.\n- Build \u03b2-normalized LCL P_D with constant-radius verifier and \u03a3in = {0,1}; keep |\u03a3out| = \u03b2 = poly(s).\n- \u201cVertex contexts\u201d: For each u \u2208 {0,1}^B, we realize many contexts wa S wb whose interior carries a well-formed block encoding: a self-delimiting header (copy of D on input track), the index u, and a locally-checkable runzone computing a short \u201cseam handshake code\u201d Hu placed near the right boundary; symmetrically, the left boundary carries Lu. All of this is forced locally via Cout\u2013out. Error chains per \u00a73 of the reference allow any malformed block to be locally refuted, making such contexts effectively inactive.\n- Coloring choices via f: For each \u201cvertex-type\u201d \u03c4u (i.e., the type of contexts realizing u), f(\u03c4u) \u2208 {RED, GRN, BLU}^2 fixes a color token at S (two nodes). For all non-vertex types, set f(\u03c4) to a neutral token \u22a5\u22a5 that never activates constraints.\n- Gating only edges: In a bridge between (\u03c4u on the left, \u03c4v on the right), the seam region interprets Hu and the right\u2019s corresponding handshake. It then runs (in the bridge) a locally-checkable simulation of a fixed universal TM U on input (D, u, v) (time poly(s); we have length budget since \u2113pump \u226b poly(s)), to compute D(u, v). Error refutations are permitted, as usual. The cout\u2013out grammar enforces: the partial labeling extends if either (i) D(u, v) = 0 (non-edge) irrespective of colors; or (ii) D(u, v) = 1 and the two S colors are different. If D(u, v) = 1 and colors are equal, all completion paths get stuck, so the DP rejects.\n- All pairs outside the (vertex, vertex) role (or with malformed header/index) are trivially extendible (via \u22a5 plumbing), so they do not constrain f.\n- This creates the intended constraint family: for all ordered pairs, only edges impose \u201c\u2260\u201d; others are vacuous.\n\nWhy the above fixes the (F1) mismatch\n- With this gating, the (F1) universal quantification over ordered pairs exactly enforces a proper coloring constraint on every edge. There is no clause-like \u201cexists\u201d quantifier left that would clash with the universal pairing; non-edges require nothing.\n\nKey technical components to instantiate and verify\nA. Computing and checking at radius 1:\n- Block language: As in \u00a73, use a constant-alphabet, radius-1 nearest-neighbor checker for the header, index, and a row-by-row simulation of U for poly(s) steps. The input circuit D is copied from the input track (Cin\u2013out). The work alphabet of U is constant and independent of s.\n- Seam handshakes: Deterministically derive short fixed-size codes Lu, Hu from the index u and place them in O(1) cells adjacent to the context boundary; they are computed in the block and forced by Cout\u2013out.\n- Bridge computation: In wb\u25e6wc, run U for poly(s) steps using the adjacent copies of D and the seam codes Lu/Hv to reconstruct u and v and evaluate D(u, v). This is the same 1D-encoding recipe as \u00a73; errors are locally refutable.\nB. Separation of exponentially many vertex context types:\n- We need that for each u, there exist contexts whose type remembers the presence of Lu/Hu; more strongly, to assign different colors per u we only require that for each u there exists at least one type \u03c4u on which f can act. Distinctness of types can be enforced by a boundary-extendibility probe: add a reserved boundary-output pattern that triggers a local \u201cindex-check subroutine\u201d which accepts iff the seam code equals a prescribed function of u; different u yield different extendibility outcomes under that boundary pattern, hence different types. This uses the definition of Type (extendibility table on 4 boundary nodes).\n- Pumping to reach \u2113pump-sized buffers: Lemmas 12, 14\u201315 ensure we can embed the block and seam codes inside w1/w2 and pump to lengths \u2113pump or \u2113pump+1 without changing type (replacement lemma, Lemma 11).\nC. \u03b2 and time bounds:\n- The per-symbol state space (roles/phases/colors/\u22a5/error alphabet/U work letters) is constant; \u03b2 can be chosen poly(s) to absorb all tracks comfortably. The LCL description size is poly(\u03b2) = poly(s). The verifier\u2019s DP runs in O(k \u03b2^2) per string.\n\nCorrectness sketch under the new reduction\n- Completeness: If G is 3-colorable, pick any proper coloring \u03c7: V \u2192 {RED, GRN, BLU}. Define f(\u03c4u) = \u03c7(u). For any ordered pair (\u03c4u, \u03c4v), the bridge\u2019s local computation derives D(u, v); if D(u, v) = 0, we allow completion; if D(u, v) = 1, \u03c7(u) \u2260 \u03c7(v) so completion is allowed. All other context pairs are vacuous. Hence all (F1) checks pass.\n- Soundness: If a feasible f exists, read a color assignment \u03c7(u) = f(\u03c4u) (choosing any representative context type for each u; if several exist, they must all share the same f-value else (F1) would fail on the pair of those contexts). For any u, v with D(u, v) = 1, the bridge between \u03c4u and \u03c4v must be extendible, which forces \u03c7(u) \u2260 \u03c7(v). Thus \u03c7 is a proper 3-coloring, so G is 3-colorable.\n\nHandling (F2)\n- Make (F2) vacuous by allowing repeated sides wz\n1 and wz\n2 to be filled with \u22a5 (a self-looping buffer language in Cout\u2013out), independent of the chosen f on S. Then bridging checks in the upper bound accept for all z \u2264 \u2113pump^2 (and hence all z), without constraining f.\n\nExamples (toy sanity check)\n- Let B = 2, V = {00,01,10,11}. Let D encode a 4-cycle 00\u201301\u201311\u201310\u201300. Under the reduction, there are 4 vertex context types \u03c400,\u2026,\u03c411. Feasible f exist iff a 3-coloring of a 4-cycle exists (true). Pairs like (\u03c400, \u03c410) with D(00,10) = 0 are unconstrained; pairs like (\u03c400, \u03c401) with D(00,01) = 1 enforce f(\u03c400) \u2260 f(\u03c401).\n\nObstacles and open items to formalize next\n- Formal type-separation lemma: Specify the boundary-output probe and prove that contexts with distinct u become distinct types (by differing in at least one boundary-extendibility bit). This pins down the \u201cone type per vertex\u201d requirement.\n- Seam handshake construction details: Specify an O(1)-cell code and the local rules that move u from the block interior to the boundary deterministically.\n- Bridge computation layout: Spell out the row format and the interface that feeds D and (u, v) into the U-simulation, ensuring errors are caught locally.\n- Size bookkeeping: Choose concrete constants so that block length is poly(s), while \u2113pump = 2\u0398(\u03b2^4) dominates to allow pumping. Confirm Cin\u2013out/Cout\u2013out remain of size poly(\u03b2).\n\nWhy this yields NEXPTIME-hardness for feasible-function existence (and classification)\n- Feasible-function existence with (F1) alone is NEXPTIME-hard via succinct 3-coloring under the reduction above. Together with the NEXPTIME upper bound in the draft, this gives NEXPTIME-completeness for (F1)-feasibility in the explicit \u03b2-normalized, r=1 setting.\n- For full classification (O(1)/\u0398(log\u2217 n)/\u0398(n)), add the neutral \u22a5 repetition to trivialize (F2), so the hardness transfers to deciding whether (F1) holds\u2014hence to the classification problem that internally tests (F1).\n\nNext steps\n1) Write the explicit local rules for the seam gate and the bridge simulation (succinct adjacency computation) and verify they fit in radius 1.\n2) Prove the type-separation lemma rigorously (construct the boundary probe and show different u change the extendibility table).\n3) Integrate the error-chain library from \u00a73 to guarantee malformed blocks are always locally refutable, keeping non-vertex contexts harmless.\n4) Provide a fully quantified statement/theorem of the reduction with the poly-time construction mapping D \u21a6 P_D and the equivalence \u201cG 3-colorable \u21d4 (F1)-feasible f exists for P_D\u201d.\n\nNotes on the NEXPTIME upper bound (good to keep)\n- The finite z bound Z \u2264 \u2113pump^2 for (F2) follows cleanly from Lemma 15 periodicity and Lemma 12 composition; no circularity with f.\n- The layered DP (O(k \u03b2^2)) to decide extendibility of partially labeled paths gives an explicit verifier runtime bound compatible with 2poly(\u03b2).\n\nNo output.md was provided; these notes flag substantial issues in the current (3SAT-based) Section B and outline a repaired (3-coloring-based) reduction aligned with (F1)."
}