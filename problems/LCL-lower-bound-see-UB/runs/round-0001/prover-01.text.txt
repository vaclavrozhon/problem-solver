{
  "progress_md": "## Round 0001 — 2025-08-27T10:31:56.197254Z\n\nMini-plan\n- Tighten the NEXPTIME-hardness reduction in the draft (App. B) by fixing the pairing/quantification mismatch in (F1): anchor “active” blocks near the windows S1 and S2 (inside wb and wc) so the (F1) bridge only inspects locally available information.\n- State clean lemmas with explicit “why useful here,” “how it can fail,” and a quick test. Emphasize: (i) window-anchored activation, (ii) existence of exponentially many active context types via pumping, (iii) inactive-context harmlessness, (iv) soundness/completeness vs. Succinct-3SAT, and (v) trivializing (F2) to collapse O(1) vs Θ(n).\n- Sanity-check the adjacency-table (radius-1) verification of bounded-time U and the witness-chain (existential pointer) under β-normalized constraints.\n- Do two toy checks: (a) a 2-variable/1-clause fragment to detect spurious cross-pair constraints, (b) an intentionally malformed block to test that ⊥ makes (F2) vacuous and errors are harmless.\n- Record remaining gaps (e.g., explicit constant budgets on the tracks and error alphabet) and list next actions.\n\n1) Patch: make activation window-anchored (fixing the (F1) pairing issue)\nClaim A (Window-anchored activation). Redefine “active” contexts so that, for a left context wa S wb, the presence and correctness (HEAD+RID+RUN) of a variable block must lie inside wb (the length-ℓpump or ℓpump+1 suffix adjacent to S). Similarly, for a right context wc S wd, the presence and correctness (HEAD+GID+RUN) of a clause block must lie inside wc (the length-ℓpump or ℓpump+1 prefix adjacent to S). Then the (F1) bridge, which only fills wb wc and checks last r nodes of S1 and first r nodes of S2, suffices to enforce all intended checks locally.\n- Why useful here: (F1) requires extendibility after labeling S1 and S2 while only filling wb wc. Any constraint that looks into wa or wd (far sides) is invisible to the (F1) check; window-anchoring ensures all semantics the bridge needs (variable RID and clause GID tableau) sit inside wb and wc.\n- How it can fail: If some required header/tableau bits spilled outside wb or wc, the bridge DP would need information beyond wb wc and could neither enforce nor refute the constraint, making the reduction unsound.\n- Quick test: Let wb encode a variable block with RID=5 and wc encode a clause block for clause j. Confirm that the witness chain from S1 into wb and from S2 into wc can reach the one-hot HotRID and the V(+)/V(−) vectors within distance O(|wb|+|wc|), hence within the region the (F1) DP is allowed to fill/check.\n\n2) Existence of many active context types (RID and GID coverage)\nClaim B (RID/GID coverage via pumping and types). For β = poly(s), choose HEAD+RUN+indices of total length poly(s) ≪ ℓpump = 2Θ(β4). Then for each i ∈ {0,1}B and j ∈ {0,1}B there exist context types τVar(i) (left-contexts whose wb contains a well-formed variable block with RID=i) and τCl(j) (right-contexts whose wc contains a well-formed clause block with GID=j). Moreover, τVar(i) ≠ τVar(i′) for i ≠ i′, and τCl(j) ≠ τCl(j′) for j ≠ j′ (distinct types).\n- Why useful here: We need exponentially many distinct context types to encode all variables/clauses addressed by the succinct circuit. The (F1) quantification ranges over ordered pairs of these contexts; if these types collapsed, the reduction would lose distinguishing power.\n- How it can fail: If types lacked the granularity to separate different RIDs or GIDs (e.g., if extendibility on boundary assignments could not detect RID differences), then choosing f on those types would not correspond to per-variable/per-clause choices.\n- Quick test: Fix two RIDs i ≠ i′. By window-anchoring, the extendibility of certain color choices at S1 in τVar(i) must differ from τVar(i′) on at least one pair (with a fixed clause-side type τCl(j)) because the witness chain succeeds only for the matching RID. Hence the boundary-extendibility signature differs, implying distinct types.\n\n3) Harmlessness of inactive contexts\nClaim C (Inactive contexts never constrain f). If a context lacks a well-formed block inside its window-adjacent part (wb or wc), then any non-⊥ choice at S triggers a witness chain that necessarily gets stuck, blocking completion; the symbol ⊥ always admits completion (a local plumbing language). Therefore, setting f(τ)=⊥ for all inactive τ makes all (F1) bridges involving τ automatically pass or fail in the intended (harmless) way, and does not affect satisfiability of the active constraints.\n- Why useful here: (F1) quantifies over all pairs of contexts, including many that should be irrelevant. We need a robust way to neutralize them so they don’t accidentally force or forbid choices.\n- How it can fail: If ⊥ could not safely buffer the seams or non-⊥ colors accidentally admitted completions without a genuine block, f might “cheat” or get overconstrained.\n- Quick test: Construct a context where wb has no HEAD marker. Check that choosing RED at S1 necessarily launches a chain that soon requires a header bit which is absent, causing the DP to fail; choosing ⊥ must have an available local completion (by Cout–out rules supplying a ⊥-plumbing language, cf. Section A matrix view or the DP).\n\n4) Bridge semantics and satisfying assignment\nClaim D (Soundness/completeness wrt Succinct-3SAT). With window-anchored activation, define:\n- Colors at S: {RED, GRN, BLU, ⊥}. Non-⊥ on a variable-side S requires a single 1 in HotRID (always true for a well-formed block). On a clause-side S with color RED (resp. GRN), the witness chain must locate i with HotRID[i]=1 in the variable block and then enforce V(+)[i]=1 (resp. V(−)[i]=1) in the clause block. Color BLU is a dummy and never witnesses (V(⊥)≡0), usable only as a harmless default when allowed.\n- f picks, for each τVar(i), a color in {RED,GRN} encoding α(xi), and for each τCl(j), a color in {RED,GRN} encoding one true literal of clause(j) (under α). All inactive τ get ⊥.\nThen: ΦC satisfiable ⇒ some f passes all (F1) bridges; and any f that passes all (F1) bridges induces a satisfying α.\n- Why useful here: This is the core correctness of the reduction from Succinct-3SAT to feasible-function existence (F1).\n- How it can fail: If a τCl(j) colored, say, RED must pass (F1) with every τVar(k), we must ensure the bridge is only required to succeed for the τVar(k) that actually occurs in clause(j), not for all k. We achieve this by encoding the “∃i” witness in the bridge itself; (F1) asks for extendibility for each ordered pair, but the bridge completion succeeds if there exists a legal pointer i in wb wc; for τVar(k) with HotRID[k]=1 and k not appearing positively in clause(j), the witness chain cannot find a matching i in wc and the pair blocks unless τCl(j) chose a literal that matches at least one variable appearing in the clause. Since (F1) must hold for all ordered pairs, the only way is to choose τCl(j)’s color to match some literal in the clause; and variable colors must be consistent across all j, forcing a global α.\n- Quick test: Clause (x3 ∨ ¬x7 ∨ x10). For f(τCl(j))=RED, the bridge with τVar(3) succeeds; with τVar(7) it fails via RED, but could succeed if the clause-side had GRN instead; with τVar(2) (variable not in clause), the witness chain has no i and the bridge fails. Hence to pass all (F1) bridges, f(τCl(j)) must select a color corresponding to a literal that matches at least one RID among the three variable types that appear with that clause-side context. Since (F1) ranges over all three τVar(i) that appear, the chosen color must be one of the clause’s true literals.\n\n5) Trivializing (F2) to collapse O(1) vs Θ(n)\nClaim E ((F2) can be made vacuous). Extend Σout and Cout–out so that repetitions wz\n1 and wz\n2 can always be filled with ⊥ while matching the fixed two-node label f(Type(w1Sw2)) at S. Then bridging (F2) holds for any f, and the overall complexity is O(1) iff (F1) holds; if (F1) fails, then by Theorem 8 (o(n) ⇒ feasible function), the problem is Θ(n).\n- Why useful here: We need to map Succinct-3SAT to the tri-class classification task by producing an instance that lands in O(1) iff ΦC is satisfiable, else in Θ(n). This shows NEXPTIME-hardness of the classification problem.\n- How it can fail: If ⊥-filling the repeated sides interacts with S in a way that depends on the context type (e.g., seam constraints disallow ⊥ next to certain S colors), then (F2) may not be vacuous. We avoid this by making ⊥-plumbing fully absorbing at repetition seams and compatible with any S-choice.\n- Quick test: Pick any context and any z ≥1, fix S by f, and fill both repeats with ⊥. The DP should accept by construction in O(kβ^2) for k=|wz\n1Swz\n2|.\n\n6) Radius-1, β-normalized implementation sanity\nClaim F (All checks are radius-1 and β-normalized). The output alphabet contains:\n- A small role/phase track (HEAD markers, region separators, RUN row phases),\n- The color tokens {RED, GRN, BLU, ⊥},\n- A bounded error alphabet for locally checkable refutations,\n- A constant-size work alphabet to simulate a fixed universal TM U for O(1) steps over the block.\nCin–out forces copying of the input bit to an “in-copy” output subtrack and allows only role-legal symbols per input value; Cout–out encodes the regular language of well-formed blocks and the per-edge consistency of U’s tableau, witness hops, ⊥-plumbing, and error chains. Hence this is a β-normalized, radius-1 LCL.\n- How it can fail: If the RUN verification required long-range dependencies or the witness hop needed >1-step lookahead, we would exceed radius 1. We avoid this by encoding the tableau as a sequence of locally consistent tiles and letting the witness chain move one node per step.\n- Quick toy: Build a 6–10 node block with a two-row “RUN” and ensure the out–out table checks only neighboring pairs (no two-hop dependency), including the seam between rows; confirm that malformed tiles trigger the error chain.\n\n7) Complexity/size bookkeeping\n- Construction size: Σout has β = poly(s) symbols; Cin–out is size 2·β; Cout–out is β×β = poly(s)^2, thus the LCL description size N = poly(β) = poly(s).\n- Type count: ℓpump ≤ 2Θ(β4), so the contexts cataloged by the classification algorithm exist in principle; the reduction itself never enumerates them, it only relies on their existence, ensured by window-anchoring and pumping.\n- Classification mapping: Build PC in poly(N) time. If ΦC ∈ SAT, then PC ∈ O(1). Otherwise PC ∈ Θ(n). Therefore any oracle that classifies O(1) vs Θ(n) (as part of the tri-class classification) decides Succinct-3SAT, implying NEXPTIME-hardness.\n\n8) Summary of lemmas and their roles\n- Lemma A (Window-anchored activation): fixes the (F1) locality/visibility gap.\n- Lemma B (RID/GID coverage): ensures exponentially many active types are available.\n- Lemma C (Inactive harmless): quarantines irrelevant contexts.\n- Lemma D (Reduction correctness): equates feasible f with satisfying assignment.\n- Lemma E (Trivial (F2)): collapses O(1) vs Θ(n) to feasible-function existence.\n- Lemma F (Radius-1 feasibility): guarantees β-normalized implementation.\n\nPotential pitfalls and countermeasures\n- Pitfall 1: Pairwise (F1) quantification could force success for (τVar(k), τCl(j)) even when k does not occur in clause j. Countermeasure: The bridge completion is “∃i” inside wb wc; if no matching i exists, the pair is allowed to fail—(F1) then fails globally unless τCl(j) chose a color matching at least one variable that does occur with that clause-side context. Because all three τVar(i) that occur in clause j appear as left contexts in the full (F1) product, τCl(j) must choose a literal that is true under α.\n- Pitfall 2: Spurious completions for malformed blocks. Countermeasure: Error-chain gadget ensures any malformed encoding has an easy, locally checkable refutation (hence does not constrain f), and non-⊥ colors are only extendible when a valid block sits in the window-adjacent region.\n- Pitfall 3: ⊥ seams interfering with S. Countermeasure: Add Cout–out entries that permit ⊥ to sit next to any S color and to tile arbitrarily within repeats.\n\nToy example attempts\n- Example 1: 2 variables, clause (x1 ∨ ¬x2 ∨ x2). Active types: τVar(1), τVar(2), τCl(j). Assign f(τVar(1))=RED, f(τVar(2))=GRN, f(τCl(j))=RED. Bridges: (τVar(1), τCl(j)) succeeds via i=1; (τVar(2), τCl(j)) fails (as intended), but this is acceptable only if (F1) also demands success with the τVar’s that appear in the clause. With our construction, all three “appearing” τVar’s do appear as left contexts, and at least one (here i=1) suffices for all (F1) pairs involving τCl(j). This sanity-check matches the intended semantics.\n- Example 2: Malformed left block. Choose non-⊥ at S1; the witness chain attempts to find HEAD in wb and fails quickly; DP declares non-extendible. With ⊥, DP succeeds by ⊥-plumbing.\n\nOpen items and measurements\n- Firm up the constant budgets: list the exact tracks and symbols (roles, phases, error types) and bound |Σout| by a fixed polynomial in s.\n- Write down the precise out–out pairs for: (i) RUN row transitions, (ii) witness hop step, (iii) ⊥ plumbing, (iv) error-chain steps.\n- Optional: formalize the “appearing τVar(i)” notion by guaranteeing that for each clause j, exactly the three τVar(i) for its literals occur in the context set on the left of τCl(j). This follows from pumping and window-anchoring but benefits from a brief direct statement.\n\nBottom line\n- With the window-anchored activation fix, the reduction from Succinct-3SAT to feasible-function existence (F1) is sound, and trivializing (F2) yields an LCL whose complexity is O(1) iff ΦC is satisfiable, otherwise Θ(n). Consequently, tri-class classification is NEXPTIME-hard under the β-normalized, radius-1, globally oriented path model.\n",
  "new_files": [
    {
      "path": "reductions/proposed_gadget_spec.md",
      "content": "Title: Window-Anchored NEXPTIME-Hardness Gadget for β-Normalized, Radius-1 LCLs on Directed Paths\n\nTracks in Σ_out (constant many families; total size β = poly(s))\n- Role/phase: HEAD, SEPR, RUN(row-phase∈{0,1,2}), RID-bit, GID-bit, PAD.\n- Colors: RED, GRN, BLU, ⊥ (only these labels are allowed at the 2-node window S; elsewhere they appear only as part of plumbing/witness tokens).\n- Work tape: small fixed alphabet for a universal TM U that runs O(1) steps.\n- Error alphabet: constant-sized set E0, E1, ..., implementing locally checkable refutations.\n\nCin–out\n- Copies input bit to a dedicated output subtrack (for normalization) and permits only role-appropriate symbols at each node.\n\nCout–out\n- Grammar for well-formed blocks: HEAD ... RID (B bits) ... GID (B bits) ... RUN rows ... SEPR ...\n- RUN verification: local transitions between adjacent nodes encode consistency of U’s row-by-row evolution.\n- Witness steps: when S is colored non-⊥, enable a path that moves one step per edge from S into wb (to check Hot_RID is one-hot and read its index i) and into wc (to check V(+)[i]=1 or V(−)[i]=1 depending on S2’s color on the clause side).\n- ⊥-plumbing: allow arbitrary tilings of ⊥ across repetitions wz_1 and wz_2 and permit ⊥ to sit next to any color at S.\n- Error chains: for every malformed header/tableau seam, offer a short chain that locally proves inconsistency (as in the PSPACE-hardness LBA proof), ensuring malformed contexts never constrain f.\n\nWindow anchoring\n- A left context wa S wb is active iff wb contains a well-formed variable block (HEAD+RID+RUN witnessing Hot_RID is one-hot). A right context wc S wd is active iff wc contains a well-formed clause block (HEAD+GID+RUN writing V(+), V(−) for that clause).\n\nSemantics for (F1) bridges\n- For a pair (left context, right context), the DP that fills wb wc succeeds iff: (i) non-⊥ on the left implies existence of exactly one i with Hot_RID[i]=1 in wb; (ii) non-⊥ on the right implies existence of V(+)[i]=1 for RED or V(−)[i]=1 for GRN in wc for the same i; (iii) BLU never witnesses; (iv) any ⊥ choice trivially permits completion via ⊥-plumbing.\n\nMaking (F2) vacuous\n- For any repetition wz_1 S wz_2, fill the repeats with ⊥ regardless of z. Cout–out must allow ⊥ next to S and propagate ⊥ freely so that every such partially labeled path is completable.\n\nSize and radius\n- All checks are radius-1: each Cout–out entry concerns adjacent nodes only. The total number of distinct output symbols is β=poly(s). Description size |Cin–out|+|Cout–out| = O(β^2) = poly(s).\n\nNotes\n- Ensure that for each clause j, the three τVar(i) that appear with that clause actually occur as left contexts that can be paired with the right context τCl(j). This follows from pumping, since wb and wc are of length ℓ_pump or ℓ_pump+1 and can stably host any fixed poly(s)-length block.\n"
    }
  ],
  "requests_for_more_materials": [
    "If available, provide a precise statement from your draft about the definition of contexts and the feasible-function (F1) quantification that you want us to adhere to; this will let us align the window-anchoring exactly to your conventions.",
    "If you have a preferred fixed universal TM U (alphabet and transition table) for the RUN rows, please share it; otherwise we will instantiate a minimal O(1)-time U tailored to emitting V(+) and V(−) and checking Hot_RID.",
    "Any constraints on the exact size of the error alphabet permitted in β-normalized encoding (we currently assume a constant-size set suffices, as in the PSPACE-hardness LBA gadget)."
  ],
  "next_actions_for_prover": [
    "Write out the explicit Cin–out and Cout–out tables for a minimal working instance (tiny s, e.g., B=2), including: role/phase transitions, RUN row checks, witness hop steps, ⊥-plumbing, and one or two error chains.",
    "Formally prove Lemma B (RID/GID coverage) with an explicit use of Lemmas 12, 14, 15: for each i and j, construct words realizing τVar(i) and τCl(j), and argue type distinctness via differing boundary extendibility induced by the witness chain.",
    "Give the full soundness/completeness proof with window-anchored activation carefully tracking which ordered pairs must succeed under (F1), emphasizing that success is via an internal existential witness within wb wc.",
    "Quantify the constant budgets: enumerate all output symbols to certify β=poly(s), and count the number of Cout–out entries to certify O(β^2) description size.",
    "Build two toy instances and run the layered-DAG DP (O(kβ^2)) by hand to validate (i) a satisfiable case (O(1)) and (ii) an unsatisfiable case (Θ(n))."
  ]
}