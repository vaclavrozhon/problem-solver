{"progress_md":"Ideas and plan for NEXPTIME-hardness via feasible functions (and gaps spotted)\n\nContext recap and goal\n- We work with β-normalized, radius-1 LCLs on globally oriented paths, with explicit tables Cin–out and Cout–out. The classification into O(1), Θ(log∗ n), Θ(n) in the path/cycle case goes via the existence of a feasible function f on “context types” (mid-consistency F1 gives O(log∗ n) vs Θ(n); adding bridging F2 gives O(1) vs Ω(log∗ n)), per Section 4 of the reference (Lemmas 10–15, 11, 12; Theorems 8–9).\n- The attached draft provides: (i) a NEXPTIME upper bound for deciding feasible-function existence (with an explicit bound Z ≤ ℓpump^2 for (F2) finite checks and an O(k β^2) DP for local extendibility), and (ii) a hardness sketch (Section B) intended to reduce Succinct-3SAT to mid-consistency (F1).\n\nCritical gaps in the current hardness sketch (Section B)\n1) Universal machine runtime and one-hot vectors: The draft says a fixed U runs in BO(1) to compute clause literals and uses a 2^B-long one-hot vector HotRID. Neither is feasible. Evaluating a size-s circuit C requires poly(s) steps; one-hot vectors of length 2^B cannot be produced/stored in a constant-alphabet radius-1 LCL with poly(s) footprint.\n2) Mid-consistency quantifies over all ordered pairs of contexts. The current design enforces that for (variable i, clause j) pairs the bridge only succeeds if i appears in j and the chosen colors match a picked literal. But f(Clj) is fixed per type; then for the other two variables in the same clause the bridge would fail, contradicting the “for all pairs” requirement in (F1). This is a fundamental mismatch: 3SAT’s “∃ satisfied literal” cannot be expressed by a constraint that must hold for every pairing.\n3) Type–separation assumptions: The sketch implicitly needs exponentially many distinct context types (e.g., one per RID and per GID) and that type equality can be forced to depend on RID/GID. This needs a concrete mechanism to “project” the index to a boundary-extendibility distinction (otherwise different indices could collapse to the same type).\n\nProposed pivot: reduce from Succinct 3-Coloring (NEXPTIME-complete)\nWhy it matches (F1):\n- Feasible-function mid-consistency induces pairwise constraints among context-types. 3-colorability of a succinctly described graph H on 2^B vertices is a pure pairwise constraint system: for each edge (u, v) we require color(u) ≠ color(v). This aligns with “for all ordered pairs” checks, provided we gate the bridge so that non-edges are trivial.\n- Succinct 3-coloring is NEXP-complete (Papadimitriou–Yannakakis). The succinct adjacency oracle A(u, v) is a circuit of size s on 2B bits. This lets us stay within poly(s) resources inside a block.\n\nRefined reduction outline (mid-consistency (F1) only)\n- Instance: succinct graph G on V = {0,1}^B, circuit D(u, v) outputs 1 iff edge.\n- Build β-normalized LCL P_D with constant-radius verifier and Σin = {0,1}; keep |Σout| = β = poly(s).\n- “Vertex contexts”: For each u ∈ {0,1}^B, we realize many contexts wa S wb whose interior carries a well-formed block encoding: a self-delimiting header (copy of D on input track), the index u, and a locally-checkable runzone computing a short “seam handshake code” Hu placed near the right boundary; symmetrically, the left boundary carries Lu. All of this is forced locally via Cout–out. Error chains per §3 of the reference allow any malformed block to be locally refuted, making such contexts effectively inactive.\n- Coloring choices via f: For each “vertex-type” τu (i.e., the type of contexts realizing u), f(τu) ∈ {RED, GRN, BLU}^2 fixes a color token at S (two nodes). For all non-vertex types, set f(τ) to a neutral token ⊥⊥ that never activates constraints.\n- Gating only edges: In a bridge between (τu on the left, τv on the right), the seam region interprets Hu and the right’s corresponding handshake. It then runs (in the bridge) a locally-checkable simulation of a fixed universal TM U on input (D, u, v) (time poly(s); we have length budget since ℓpump ≫ poly(s)), to compute D(u, v). Error refutations are permitted, as usual. The cout–out grammar enforces: the partial labeling extends if either (i) D(u, v) = 0 (non-edge) irrespective of colors; or (ii) D(u, v) = 1 and the two S colors are different. If D(u, v) = 1 and colors are equal, all completion paths get stuck, so the DP rejects.\n- All pairs outside the (vertex, vertex) role (or with malformed header/index) are trivially extendible (via ⊥ plumbing), so they do not constrain f.\n- This creates the intended constraint family: for all ordered pairs, only edges impose “≠”; others are vacuous.\n\nWhy the above fixes the (F1) mismatch\n- With this gating, the (F1) universal quantification over ordered pairs exactly enforces a proper coloring constraint on every edge. There is no clause-like “exists” quantifier left that would clash with the universal pairing; non-edges require nothing.\n\nKey technical components to instantiate and verify\nA. Computing and checking at radius 1:\n- Block language: As in §3, use a constant-alphabet, radius-1 nearest-neighbor checker for the header, index, and a row-by-row simulation of U for poly(s) steps. The input circuit D is copied from the input track (Cin–out). The work alphabet of U is constant and independent of s.\n- Seam handshakes: Deterministically derive short fixed-size codes Lu, Hu from the index u and place them in O(1) cells adjacent to the context boundary; they are computed in the block and forced by Cout–out.\n- Bridge computation: In wb◦wc, run U for poly(s) steps using the adjacent copies of D and the seam codes Lu/Hv to reconstruct u and v and evaluate D(u, v). This is the same 1D-encoding recipe as §3; errors are locally refutable.\nB. Separation of exponentially many vertex context types:\n- We need that for each u, there exist contexts whose type remembers the presence of Lu/Hu; more strongly, to assign different colors per u we only require that for each u there exists at least one type τu on which f can act. Distinctness of types can be enforced by a boundary-extendibility probe: add a reserved boundary-output pattern that triggers a local “index-check subroutine” which accepts iff the seam code equals a prescribed function of u; different u yield different extendibility outcomes under that boundary pattern, hence different types. This uses the definition of Type (extendibility table on 4 boundary nodes).\n- Pumping to reach ℓpump-sized buffers: Lemmas 12, 14–15 ensure we can embed the block and seam codes inside w1/w2 and pump to lengths ℓpump or ℓpump+1 without changing type (replacement lemma, Lemma 11).\nC. β and time bounds:\n- The per-symbol state space (roles/phases/colors/⊥/error alphabet/U work letters) is constant; β can be chosen poly(s) to absorb all tracks comfortably. The LCL description size is poly(β) = poly(s). The verifier’s DP runs in O(k β^2) per string.\n\nCorrectness sketch under the new reduction\n- Completeness: If G is 3-colorable, pick any proper coloring χ: V → {RED, GRN, BLU}. Define f(τu) = χ(u). For any ordered pair (τu, τv), the bridge’s local computation derives D(u, v); if D(u, v) = 0, we allow completion; if D(u, v) = 1, χ(u) ≠ χ(v) so completion is allowed. All other context pairs are vacuous. Hence all (F1) checks pass.\n- Soundness: If a feasible f exists, read a color assignment χ(u) = f(τu) (choosing any representative context type for each u; if several exist, they must all share the same f-value else (F1) would fail on the pair of those contexts). For any u, v with D(u, v) = 1, the bridge between τu and τv must be extendible, which forces χ(u) ≠ χ(v). Thus χ is a proper 3-coloring, so G is 3-colorable.\n\nHandling (F2)\n- Make (F2) vacuous by allowing repeated sides wz\n1 and wz\n2 to be filled with ⊥ (a self-looping buffer language in Cout–out), independent of the chosen f on S. Then bridging checks in the upper bound accept for all z ≤ ℓpump^2 (and hence all z), without constraining f.\n\nExamples (toy sanity check)\n- Let B = 2, V = {00,01,10,11}. Let D encode a 4-cycle 00–01–11–10–00. Under the reduction, there are 4 vertex context types τ00,…,τ11. Feasible f exist iff a 3-coloring of a 4-cycle exists (true). Pairs like (τ00, τ10) with D(00,10) = 0 are unconstrained; pairs like (τ00, τ01) with D(00,01) = 1 enforce f(τ00) ≠ f(τ01).\n\nObstacles and open items to formalize next\n- Formal type-separation lemma: Specify the boundary-output probe and prove that contexts with distinct u become distinct types (by differing in at least one boundary-extendibility bit). This pins down the “one type per vertex” requirement.\n- Seam handshake construction details: Specify an O(1)-cell code and the local rules that move u from the block interior to the boundary deterministically.\n- Bridge computation layout: Spell out the row format and the interface that feeds D and (u, v) into the U-simulation, ensuring errors are caught locally.\n- Size bookkeeping: Choose concrete constants so that block length is poly(s), while ℓpump = 2Θ(β^4) dominates to allow pumping. Confirm Cin–out/Cout–out remain of size poly(β).\n\nWhy this yields NEXPTIME-hardness for feasible-function existence (and classification)\n- Feasible-function existence with (F1) alone is NEXPTIME-hard via succinct 3-coloring under the reduction above. Together with the NEXPTIME upper bound in the draft, this gives NEXPTIME-completeness for (F1)-feasibility in the explicit β-normalized, r=1 setting.\n- For full classification (O(1)/Θ(log∗ n)/Θ(n)), add the neutral ⊥ repetition to trivialize (F2), so the hardness transfers to deciding whether (F1) holds—hence to the classification problem that internally tests (F1).\n\nNext steps\n1) Write the explicit local rules for the seam gate and the bridge simulation (succinct adjacency computation) and verify they fit in radius 1.\n2) Prove the type-separation lemma rigorously (construct the boundary probe and show different u change the extendibility table).\n3) Integrate the error-chain library from §3 to guarantee malformed blocks are always locally refutable, keeping non-vertex contexts harmless.\n4) Provide a fully quantified statement/theorem of the reduction with the poly-time construction mapping D ↦ P_D and the equivalence “G 3-colorable ⇔ (F1)-feasible f exists for P_D”.\n\nNotes on the NEXPTIME upper bound (good to keep)\n- The finite z bound Z ≤ ℓpump^2 for (F2) follows cleanly from Lemma 15 periodicity and Lemma 12 composition; no circularity with f.\n- The layered DP (O(k β^2)) to decide extendibility of partially labeled paths gives an explicit verifier runtime bound compatible with 2poly(β).\n\nNo output.md was provided; these notes flag substantial issues in the current (3SAT-based) Section B and outline a repaired (3-coloring-based) reduction aligned with (F1)."}