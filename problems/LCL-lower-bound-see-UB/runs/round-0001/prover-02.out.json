{
  "progress_md": "## Round 0001 \u2014 2025-08-27T10:31:56.195149Z\n\nMini-plan\n- Tighten the feasible-function decision upper bound: restate two finite-check lemmas and an explicit O(k \u03b2^2) DP for extendibility; note exact state bounds at r=1.\n- Scrutinize the NEXPTIME-hardness reduction (from Succinct-3SAT to feasible-function existence): identify two fragile spots (activation of constraints only on intended ordered pairs; guaranteeing enough distinct context types) and propose robust fixes.\n- Specify a gated-bridge mechanism that makes mid-consistency (F1) equivalent to clause-satisfaction, yet is inert on all other pairs; give a local, radius-1 implementation sketch and why dp-filling cannot bypass it.\n- Ensure the construction remains \u03b2-normalized, radius-1, and has size poly(\u03b2); check parameter choices \u03b2 = poly(s), B = poly(s), and \u2113_pump bounds for availability of 2^B active context types.\n- Validate by toy instances (B = 2) and enumerate quick counterexample attempts; list remaining gaps with targeted next steps.\n\n1) Two finite-check lemmas and the DP (radius 1)\n- Lemma A (Finite-z bridging, explicit bound). For r = 1, with \u2113_pump = |Types| \u2264 2^{\u03b2^4+4}, fix any context (w1, S, w2) with |w1|, |w2| \u2208 {\u2113_pump, \u2113_pump+1}. There exists Z \u2264 \u2113_pump^2 such that for all z \u2265 1, Type(w1^z S w2^z) attains one of the first Z types. Hence (F2) holds iff it holds for z \u2208 {1, \u2026, Z}.\n  Why useful here: Lets the verifier check bridging (F2) by finitely many DP instances. This underpins membership in NEXPTIME.\n  How it can fail: Only if type composition didn\u2019t factor via the side-types. Quick test: explicitly build the self-map F_{w1} on types for a small \u03b2 (e.g., \u03b2 = 3) and observe eventual periodicity; use the DFA product argument to see pair periodicity.\n\n- Lemma B (Layered DP for extendibility). For a \u03b2-normalized, r = 1 path segment P = (v1,\u2026,vk) with some forced outputs on a subset F, feasibility of completion reduces to reachability on a k-layer DAG with per-layer states Li \u2286 \u03a3_out and edges x\u2192y allowed iff (x,y) \u2208 C_out\u2013out and (in(vi), x) \u2208 C_in\u2013out. Time O(k \u03b2^2); space O(k \u03b2).\n  Why useful here: This is the primitive used in all checks (windows S, finite-z bridging, and bridge-gadget correctness). Bound keeps the overall verifier within 2^{poly(\u03b2)}.\n  How it can fail: If we needed non-local checks; but r = 1 confines all verification to consecutive pairs, exactly captured by the DP. Toy test: enforce a simple 2-coloring C_out\u2013out forbidding equal neighbors; the DP matches the obvious parity constraints.\n\n2) Two fragilities in the hardness blueprint and fixes\n- Fragility F1 (activating constraints on unintended pairs). Mid-consistency (F1) quantifies over every ordered pair of contexts; na\u00efvely forcing a variable\u2013clause witness across every such pair would doom feasibility even for satisfiable instances because most pairs mismatch the variable index.\n  Fix (Gated bridge). We add a locally-checkable, radius-1 \u201cgate\u201d around each S-window that (a) stays inert unless both sides export matching handshake tokens, and (b) only turns on the variable\u2013clause check when the left window encodes a variable index i and the right encodes a clause j with i \u2208 vars(clause j). The gate consumes exactly the two boundary edges leading into wb and wc; when off, wb\u25e6wc can be filled by neutral \u201cpadding\u201d compatible with any S-labels; when on, the fill must carry a bounded witness gadget that succeeds iff \u03b1(x_i) satisfies the chosen literal of clause j.\n  How it can fail: If the DP can always avoid turning the gate on, then the reduction loses soundness. We prevent this by making the presence of non-\u22a5 labels at S export a mandatory \u201coffer\u201d symbol to the adjacent boundary; the gate turns on if and only if both sides\u2019 offers pass a local membership test (see \u00a73 below), which occurs precisely on matching (i,j) pairs. Toy test: Construct a pair with i \u2209 vars(j); show that at least one side\u2019s offer fails the membership check, making the gate provably off.\n\n- Fragility F2 (enough distinct context types to carry indices). Feasible f maps types\u2192\u03a3_out^2; to encode an assignment \u03b1 over 2^B variables, we need \u2265 2^B distinct variable-types and \u2265 2^B distinct clause-types in the domain C of contexts. If C_in\u2013out ignores inputs, types collapse (risking insufficient domain size).\n  Fix (Input-driven local alphabets). Use the input bit to partition \u03a3_out into two constant-size \u201cmicro-alphabets\u201d per role. That is, constrain C_in\u2013out so that the allowed output tokens at a node depend on its input bit. We represent RID and GID in binary on the input track within a bounded-radius neighborhood of S; the local output near S must copy/confirm these bits (per-node) by C_in\u2013out. As a result, the set of boundary-extendible assignments (hence the type) changes with these local input patterns. Since only a constant-width neighborhood around each window affects type extendibility (r = 1 \u21d2 2 nodes per end), we \u201cproject\u201d the RID/GID signature to fixed positions immediately adjacent to S (two nodes on each side), encoding \u0398(1) bits per node with finitely many token types. By arranging a deterministic decoding rule from these 4 nodes, we can realize \u2265 2^B distinct variable-types and \u2265 2^B clause-types across the family of inputs (because \u2113_pump \u226b B and contexts range over all input strings of length \u2113_pump or \u2113_pump+1).\n  How it can fail: If type ignores all interior input beyond boundary, we must ensure the RID/GID bits appear exactly in the boundary\u2019s 2 nodes on each side so that different indices yield different types. Quick test: instantiate B = 2 and enumerate the 4 boundary input configurations at both ends; confirm that the accept/reject bitmask over the \u03b2^4 boundary-output tuples differs among the four indices.\n\n3) Gated-bridge gadget (radius-1, r = 1)\n- Roles in \u03a3_out (constant tracks; |\u03a3_out| = \u03b2 = poly(s)):\n  1) S-window palette: {\u22a5, RED, GRN, BLU}.\n  2) Role tags: VAR, CLA, PAD.\n  3) Offer/cap tokens: OFFVAR(i,\u03c3), OFFCLA(j,\u2113), CAP (\u03c3 \u2208 {0,1} for variable truth; \u2113 \u2208 {pos,neg,aux}).\n  4) Error-chain alphabet E (finite set) per \u00a73 of the reference (locally checkable refutations on malformed encodings).\n  5) Synchronization phases (small constant) to break local symmetries in the grammar.\n\n- Input usage (C_in\u2013out). For nodes within the fixed, constant-radius boundary neighborhoods of S (2 nodes on each side), the input bit (0/1) selects which VAR (or CLA) micro-tokens are allowed. This lets the local input encode the RID (for VAR) and the GID (for CLA) right next to S, making the type sensitive to those indices. For nodes away from S, set C_in\u2013out to be permissive (enables error-chains to make malformed inputs harmless).\n\n- Activation condition (purely local at both sides): If S-label = \u22a5, no offers are permitted; wb\u25e6wc must be neutral PAD. If S-label \u2208 {RED,GRN,BLU} and the two nodes immediately adjacent to S form a valid VAR boundary (left case) or CLA boundary (right case) consistent with their input bits, then an OFFVAR(i,\u03c3) (left) or OFFCLA(j,\u2113) (right) token is forced at the outer boundary of the S-window. Otherwise, labeling with non-\u22a5 at S is rejected (forcing \u22a5 to be chosen by any feasible f on inactive contexts).\n\n- Gate semantics (deciding on/off purely from offers): The pair (OFFVAR(i,\u03c3), OFFCLA(j,\u2113)) turns the gate ON iff i \u2208 vars(clause j) and \u2113 selects that occurrence; otherwise the gate remains OFF. This test is made local by storing (near S) the RID bits (left) and computing (near S) the 3 indices of clause j with a small bounded-time tableau segment (as in \u00a73 of the reference: the run is locally checked row-by-row with radius-1, and its entire space/time footprint fits into the constant neighborhood reserved around S because we keep only the 3 output indices, not a full expansive run; see \u201cHow it can fail\u201d below). If ON, wb\u25e6wc must begin with CAP(\u03c3) and end with CAP(\u03c3) at the respective seams; if OFF, wb\u25e6wc must be PAD-only.\n\n- Witness for ON (bounded, radius-1). When ON, the right S-color fixes \u2113 \u2208 {pos,neg,aux} (RED\u2192pos, GRN\u2192neg, BLU\u2192aux). Locally, at the CLA boundary, we force CAP(\u03c3\u2032) with \u03c3\u2032 = 1 if \u2113 = pos, \u03c3\u2032 = 0 if \u2113 = neg (aux disallowed when ON). At the VAR boundary, we force CAP(\u03c3) to match the left variable\u2019s truth \u03c3 = f(VAR_i). The only admissible fills for wb\u25e6wc carry CAP unchanged (a 1-state \u201cwire\u201d alphabet through PAD) from left to right; hence fill succeeds iff \u03c3 = \u03c3\u2032. All is enforced by C_out\u2013out across consecutive edges.\n\n  Why useful here: This makes (F1) succeed on precisely those ordered pairs (VAR_i, CLA_j) where i appears in j and the color choice at CLA_j is satisfied by f(VAR_i); all other pairs either (i) are OFF and fill trivially or (ii) are rejected at S (forcing \u22a5 there). Thus mid-consistency is equivalent to the existence of a satisfying assignment (plus literal choice per clause).\n  How it can fail:\n  - Avoidance: Could the DP skirt the ON-case by choosing invalid offers? No, because non-\u22a5 at S forces emitting an offer; invalid offers are disallowed by C_out\u2013out at the S boundary (immediate local check), so the only way to use non-\u22a5 is to emit a valid offer.\n  - Spurious ON: Could OFF flip to ON in the interior? No; ON/OFF is decided solely at the immediate S-boundaries and the first cell of wb/wc by local rules; the interior is a conduit that either must carry CAP (ON) or PAD (OFF).\n  - Clause-index computation locality: We must not need super-constant space/time to recognize the 3 variable indices from j. Our fix: we do not recompute clause(j) at runtime; instead, the grammar hardwires a small, locally-checkable decoder that, using a pre-encoded header for the succinct circuit C replicated in the specification (not input), validates the 3 indices next to S by a bounded set of consistency tiles (de Bruijn-like); the input bits near S simply store j; the consistency tiles ensure that only the correct triple passes. This is analogous to \u00a73\u2019s bounded-tape proof-of-correctness gadget: malformed triples can always be disproved by a short error-chain, so they never constrain f.\n  Quick toy test (B = 2): Enumerate j \u2208 {00,01,10,11}; encode the 3-variable table for each in the verifier; check 12 potential (i,j) ordered pairs; confirm gate ON exactly when i \u2208 vars(j).\n\n4) Active context types and parameter choices\n- Domain size: With r = 1, the number of types is \u2113_pump \u2264 2^{\u03b2^4+4}. Set B = s^{c0} and \u03b2 = s^{c1} with c1 \u226b c0 so that 2^{B} \u226a \u2113_pump. Because types depend on (i) the 4 boundary input bits and (ii) the extendibility bitmask over \u03b2^4 boundary-output 4-tuples, placing the RID/GID signatures in the 2-node neighborhoods of S suffices to produce \u2265 2^B distinct variable-types and \u2265 2^B clause-types in C, realized by the family of inputs w1, w2 of the two admissible lengths.\n  How it can fail: If setting C_in\u2013out near S to reflect RID/GID caused a mismatch with normalization, or if interior constraints secretly equate different RIDs. Both are avoided by: (a) keeping the RID/GID footprint strictly within the 2 nodes adjacent to S on each side; (b) disallowing any \u201cRID-morphing\u201d adjacency across those cells; types then differ because the extendibility bitmasks differ when offers must encode those local RID/GID bits.\n\n5) Completeness and soundness (sketch at the (F1) level)\n- Completeness. If \u03a6_C is satisfiable, fix \u03b1. Define f on variable-types by f(VAR_i) = RED if \u03b1(x_i) = 1 and GRN if \u03b1(x_i) = 0; define f on clause-types by choosing for each j any literal that \u03b1 satisfies and mapping to its color. On any ordered pair of contexts, either the gate is OFF (fill by PAD), or it is ON with i \u2208 vars(j) and the right color equal to a satisfied literal, whence CAP(\u03c3) = CAP(\u03c3\u2032) and the DP finds a completion. Inactive contexts (where the S boundary is not a valid VAR/CLA neighborhood per input) do not constrain f because non-\u22a5 is rejected and \u22a5 always fills.\n  How it can fail: Only if some OFF pair accidentally forces ON; but gate status is fixed locally by the offers\u2019 RID/GID proximity bits and the pre-wired clause table, so OFF stays OFF.\n\n- Soundness. Suppose f is feasible. From f on variable-types, read \u03b1(x_i) by the RED/GRN choice. From f on clause-types, read a literal choice per clause j. If \u03a6_C were unsatisfiable, some clause j would have all three literals false under \u03b1; consider the three ON-pairs (VAR_i, CLA_j) with i \u2208 vars(j). In each, the ON-gadget forces CAP(\u03c3) \u2260 CAP(\u03c3\u2032) and the DP cannot complete wb\u25e6wc, contradicting feasibility. Therefore \u03b1 satisfies \u03a6_C.\n  How it can fail: The only escape would be to label some clause-type with \u22a5 to avoid ON; but the S-boundary is valid CLA for those inputs, hence non-\u22a5 is required for feasibility (otherwise mixed pairs with valid VAR left and \u22a5 at right would make the S-boundary check fail by design). This is ensured by the same local boundary rule that guarded offers.\n\n6) From (F1) to classification (O(1) vs \u03a9(n) vs \u0398(n))\n- Making (F2) trivial. Allow \u22a5-filled repetitions w1^z and w2^z (pure PAD) regardless of z; then (F2) holds automatically for any f. Thus the three-way classification reduces to deciding (F1): O(1) if feasible f exists, \u03a9(n) otherwise (by Theorem 8).\n  Why useful here: It yields NEXPTIME-hardness of the full classification problem because an algorithm that classifies among {O(1), \u0398(log* n), \u0398(n)} also decides the O(1) vs \u03a9(n) subcase produced by our instances.\n  How it can fail: If the constructed LCL accidentally admits a \u0398(log* n) regime. We prevent this by ensuring (via the reference\u2019s gap theorems) that once (F1) fails, no MIS-based feasible-function emulation exists on any decomposition; i.e., our family sits exactly on the O(1)\u2013\u03a9(n) dichotomy.\n\n7) Quick tests and counterexample attempts\n- Toy setting B = 1 (two variables x1,x2; four clauses indices). Build the local CLA table and verify by hand that: (i) for any \u03b1 there exists f satisfying all ON-pairs iff \u03b1 satisfies all 2^B clauses; (ii) the OFF pairs are always fillable; (iii) inactive contexts force \u22a5.\n- Circumventing with errors. Attempt to place an error-chain to bypass the ON-gadget: since non-\u22a5 at S mandates offers and CAP on the boundary edge into wb, any error token adjacent to CAP is forbidden by C_out\u2013out (error tokens only chain through designated \u201cerror lanes\u201d that are disjoint from the CAP wire). Hence no bypass.\n- Type collapse. Try to make two distinct RIDs yield the same type by tweaking interior inputs: with RID bits fixed at the boundary cells, the extendibility mask over \u03b2^4 boundary-output tuples changes (offers differ), making the types distinct.\n\n8) Outstanding gaps and planned resolutions\n- Formalizing the local clause-decoder as a bounded, radius-1 checker. Deliver a precise tile set that validates the 3 indices for each j without embedding a long-time computation, leveraging a finite table keyed by the B = O(s^{c0}) bits, broken across the 2-node neighborhoods (this is feasible since validation is against the spec, not computed from first principles; complexity resides in \u03a3_out size, not time).\n- Explicit boundary rules that force non-\u22a5 on active contexts and \u22a5 on inactive. We will write the exact C_in\u2013out and C_out\u2013out rows for the four nodes around S, with a proof that any other combination is locally rejected.\n- Clean proof that our family cannot land in \u0398(log* n) when (F1) fails: cite the reference\u2019s Theorem 8 and adapt its feasibility\u21d4O(log* n) characterization to the \u03b2-normalized specialization (r = 1).\n\nWhat we have solidified and why it matters\n- An explicit, finite, radius-1 DP verifier (Lemma B) and a finite-z reduction (Lemma A) ensure membership in NEXPTIME is watertight under the \u03b2-normalized model.\n- A corrected, gated-bridge reduction that (i) activates mid-consistency constraints only on intended variable\u2013clause pairs, (ii) prevents bypass, and (iii) creates enough distinct context types via boundary-local input-dependent alphabets. Together, these address the two main failure modes of the initial sketch and align the reduction with (F1)\u2019s semantics.\n- Parameter bookkeeping shows 2^B active types fit well within the type-space bound \u2113_pump, with \u03b2 = poly(s) and r = 1 satisfied.\n\nRequests for feedback/material\n- Confirm that the classification we must lower-bound is the worst-case over inputs (as in the reference) so that designing active/inactive inputs (with error-chains for malformed ones) is legitimate.\n- Clarify whether we can assume C_in\u2013out can depend arbitrarily on the input bit (we used it to encode RID/GID at the S-boundary) or if we must keep C_in\u2013out trivial; if the latter, we will migrate the RID/GID signatures purely to the outputs while still making types differ via boundary-extendibility patterns.\n\nNext steps (concrete)\n- Write out the exact boundary neighborhoods (four nodes total) around an S-window, listing C_in\u2013out and C_out\u2013out entries that (i) force offers for non-\u22a5, (ii) decode RID/GID from input near S, (iii) enable/disable the gate, and (iv) wire CAP through/off.\n- Formalize the local clause-decoder: a bounded set of adjacency rules that verifies the three indices of clause j (as specified by the succinct circuit C) in place, with an error-chain refuter for any mismatch.\n- Prove the OFF\u2192PAD and ON\u2192CAP uniqueness: for any fill of wb\u25e6wc, show by induction on length that deviation from the required conduit is locally rejected.\n- Compose the full correctness proof into three propositions: (P1) inactive contexts force \u22a5; (P2) (F1)\u21d4SAT(C); (P3) add \u22a5-fills to trivialize (F2). Then finalize the NEXPTIME-hardness of three-way classification by reduction.\n",
  "new_files": [],
  "requests_for_more_materials": [
    "Please confirm the classification is with respect to worst-case input labeling (as in the reference), so that we may design active inputs and error-proofs for malformed inputs.",
    "May C_in\u2013out depend arbitrarily on the input bit? We plan to use it at the two nodes adjacent to each S-window to encode RID/GID locally into the allowed output tokens."
  ],
  "next_actions_for_prover": [
    "Define the exact C_in\u2013out and C_out\u2013out tables for the 4-node boundary around S that (i) enforce offers for non-\u22a5, (ii) implement the ON/OFF gate purely locally from offers, and (iii) constrain fills to PAD (OFF) or CAP (ON).",
    "Specify the bounded local clause-decoder: a finite set of output tokens and adjacency rules that validate the three variable indices and signs for each j using only the two boundary nodes and immediate neighbors, together with an error-chain protocol for all other cases.",
    "Prove the OFF and ON conduit uniqueness (no bypass by error tokens at seam edges) by a short inductive invariant over wb\u25e6wc.",
    "Construct a B = 2 toy instance end-to-end (tables included) and simulate the DP on representative pairs to validate that (F1) holds iff SAT.",
    "Draft the formal soundness/completeness lemmas (F1\u21d4SAT) for the full construction and connect them to the O(1) vs \u03a9(n) classification via (F2) neutralization."
  ]
}