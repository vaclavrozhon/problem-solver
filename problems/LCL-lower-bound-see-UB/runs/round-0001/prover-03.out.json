{
  "progress_md": "Ideas and plan\n- Goal: Prove NEXPTIME-hardness of the 3-way classification (O(1) vs. \u03a9(log* n) vs. \u03a9(n)) for \u03b2-normalized, radius-1 LCLs on oriented paths. By the Balliu\u2013Brandt\u2013Chang\u2013Olivetti\u2013Rabie\u2013Suomela framework (Section 4), the 3-way classification reduces to existence of a feasible function f with two properties: (F1) mid-consistency and (F2) bridging. If (F1) fails then the complexity is \u0398(n); if (F1) holds and (F2) fails then \u0398(log* n); if (F1)+(F2) holds then O(1). Hence NEXPTIME-hardness follows if we can reduce a NEXPTIME-hard problem (e.g., Succinct-3SAT) to deciding existence of f.\n- Upper bound: The attached draft \u201cLCL_classification.pdf\u201d sketches an NEXPTIME upper bound for Feasible-Function Existence (FFE) via types and bounded DP checks. I re-checked: the type bound |Types| \u2264 2^{\u0398(\u03b2^4)} for r=1 is sound, the \u201cfinite z\u201d lemma for (F2) with Z \u2264 \u2113_pump^2 is correct, and the layered-DAG DP is O(k\u03b2^2) for a length-k path. Hence membership in NEXPTIME looks solid.\n\nGaps/concerns in output.md (hardness part B)\n- Quantifier mismatch in (F1): (F1) universally quantifies over all ordered pairs of contexts (wa S1 wb, wc S2 wd), not merely pairs \u201cvariable on left, clause on right\u201d with a shared variable. In Section B, the bridge is made to succeed only if a witness i connects the left \u201cvariable RID i\u201d to a right \u201cclause V(\u00b7)[i]=1\u201d. This enforces success only for some pairs. But (F1) requires success for all ordered pairs simultaneously. As written, if there exist \u201cvariable\u201d types Vari that are not among the three variables of a given clause type Clj, then the ordered pair (Vari, Clj) will cause the bridge DP to fail for the f chosen, violating (F1). The text attempts to restrict to pairs \u201cwhere i ranges over variables occurring in clause(j)\u201d, but (F1) does not allow restricting the universal set of pairs; every pair of context types appearing in C must pass.\n- \u201cInactive contexts\u201d and pair filtering: The draft claims we can trivialize all pairs that are not (variable, clause) or have malformed blocks by allowing \u22a5. However, (F1) still quantifies over ordered pairs regardless of internal content. If the left is a \u201cvariable\u201d context (i fixed) and the right a \u201cclause\u201d context (j), but i /\u2208 vars(clause j), the pair remains \u201cvariable\u2013clause\u201d and is not falsifiable by declaring one side \u201cinactive\u201d: that would force f to assign \u22a5 to at least one side for all contexts of that type, collapsing the intended encoding (we need variable/clause contexts to be active to constrain f). No mechanism was given that makes those specific pairs inactive without also deactivating the entire type.\n- Types vs. interior degrees of freedom: The argument \u201cthere are 2^B distinct variable types Vari and 2^B clause types Clj\u201d uses that differing RID/GID values must give distinct types because extendibility from S differs \u201cfor some bridge\u201d. But Type(\u00b7) is defined by which boundary assignments are extendible; it existentially quantifies over all interior labelings. If a context admits multiple interior RIDs, then for many S-labelings the existence of some witness RID can make extendibility identical across many RIDs. Thus different RID values need not force different types unless we can tie RID deterministically to boundary information. The current construction does not ensure RID/GID are uniquely determined by the context\u2019s boundary behavior.\n- Context locality: The construction wants a large, well-formed block to sit \u201cinside\u201d w1 (resp. w2). But (F1) only fixes the two outputs on S; the remaining outputs (including inside w1 and w2) can be chosen arbitrarily in each check. This is intended, but it then exacerbates the previous issue: types correspond to sets of interior completions. One must ensure the property \u201cRID equals i\u201d is forced by boundary behavior, otherwise types conflate many RIDs.\n- Pair-wise gating by clause membership: The hardness relies on only pairs (Vari, Clj) with i \u2208 vars(clause j) being active (i.e., constrained by the witness chain). However, no local, radius-1 gating was given that makes all other variable/clause pairs trivially extendible while keeping those of interest constraining, especially given that the grammar cannot refer to \u201cpair identity\u201d globally. A local activation must be derivable from S and nearby labels, not from global pairing information.\n\nSmall positive results we can reuse (from output.md)\n- Type bound for r=1: M := |Types| \u2264 24\u00b72^{\u03b2^4} = 2^{\u0398(\u03b2^4)}; set \u2113_pump := M.\n- Finite z for (F2): For each fixed context (w1, S, w2), the set {Type(w1^z S w2^z)} has size \u2264 \u2113_pump^2, so it suffices to check 1 \u2264 z \u2264 Z with Z \u2264 \u2113_pump^2.\n- DP feasibility test: For radius-1 \u03b2-normalized LCLs, partial-to-total extension on a given path with some outputs forced is decidable by a layered-DAG DP in O(k\u03b2^2) time.\n\nProposed corrections/patches to the hardness construction\n- Force RID/GID by boundary behavior: To obtain a family of 2^B distinct \u201cvariable\u201d context types Vari, we can build a left-anchored gadget whose unique continuation from the S-window outwards deterministically encodes the index i in the nearest O(1) outputs (e.g., a self-delimiting, gray-coded header with radius-1 local rules). Concretely, add a \u201cphase\u201d track that rigidly positions the start of a short RID header of length \u0398(B) within distance O(1) from the S-window. Enforce, via Cout\u2013out, that whenever the S-window carries a designated activation token and the phase indicates \u201cvariable mode\u201d, the next O(B) outputs are uniquely determined (one-hot RID with a fixed delimiter). This ensures: (i) the interior labelings consistent with an activated S-window determine exactly one RID, (ii) types differ across different i because the set of boundary-extendible S-outputs differs.\n- Clause contexts likewise: Symmetrically enforce a GID header near S on the right context, again determined uniquely upon activation, and attach RUN rows that compute the literal set for clause j based on the fixed circuit C (hardwired in the adjacency table). As before, activation at S forces a unique GID.\n- Local gating of pairs: Introduce a \u201chandshake\u201d protocol across the bridge that makes a pair active only if both windows are activated and their local roles match a prescribed pattern (left role=VAR, right role=CL). All other combinations, including (VAR, CL) with at least one window deactivated (\u22a5), are assigned a trivial buffer language that always extends. This satisfies (F1) over all pairs once we ensure that, for each type, f can choose \u22a5 to deactivate it when needed; but now activation will be needed only on the types we purposefully created (Vari, Clj), and deactivation on all other types is harmless.\n- Still need to address \u201cwrong variable for a clause\u201d: To avoid the quantifier mismatch, ensure that for a given right clause context Clj, only those left context types Vari with i \u2208 vars(clause j) can be simultaneously activated: implement a local test that compares the variable index i (encoded near the left S-window) with the finite set of three indices embedded near the right S-window (also encoded near its S-window), and only if there is equality do we allow the activation token to persist across the bridge; otherwise the only locally valid option is to turn off activation on at least one S-window (i.e., f must set \u22a5 for one of the two types). This way, for a fixed clause type Clj, there are exactly three variable types Vari whose joint activation with Clj is locally legal. All other pairs are forced to be inactive (and thus trivial). This preserves the universal quantifier of (F1): we require success for all pairs, but for non-matching pairs success is guaranteed by deactivation.\n- Encoding satisfiability: Now (F1) for the three matching pairs (Vari1, Clj), (Vari2, Clj), (Vari3, Clj) amounts to requiring that, with the f-choices of colors on these types, at least one pair\u2019s witness chain can complete (using the V(+)/V(\u2212) bits from the RUN gadget). To phrase this with universal quantification, we allow only one activated pair per clause to persist in any given bridge instance: locally, at the mid-bridge we place a \u201cchoice\u201d gadget that nondeterministically selects one of the three matching i; the DP succeeds iff the selected i\u2019s witness check passes. Since (F1) demands existence of some completion, it suffices that at least one of the three literal checks can succeed for the f-choice at Clj. This exactly encodes that each clause has a satisfied literal under the assignment extracted from f(Vari).\n- Trivializing (F2): As in the draft, add a neutral symbol \u22a5 and permit filling wz with \u22a5 regardless of the context, so (F2) is always true. This keeps the 3-way classification hinging on (F1) alone: satisfiable \u21d2 (F1) holds \u21d2 O(1); unsatisfiable \u21d2 (F1) fails for some clause \u21d2 \u0398(n).\n\nToy counterexample of the current draft\u2019s (F1) usage\n- Consider a clause type Clj whose literals are over indices {i1, i2, i3}. For a variable type Vari with i \u2209 {i1, i2, i3}, the proposed grammar makes the pair active (since it is a (variable, clause) pair) and then the witness chain must fail (no V-bit at i), violating (F1) unless f sets \u22a5 on Vari or Clj. But if f sets \u22a5 on Vari to fix this pair, it also deactivates all its interactions with the correct clauses, undermining the intended encoding. This shows the need for local gating to force all non-matching pairs inactive irrespective of f.\n\nWhy the capacity (number of types) suffices\n- With \u03b2 = poly(|C|), \u2113_pump = 2^{\u0398(\u03b2^4)} gives room for exponentially many distinct context types. The \u201cphase+RID/GID near S\u201d gadgets use only O(B) symbols, so they comfortably fit into contexts of length \u2265 \u2113_pump. Deterministic forcing from S ensures that different i (or j) yield different type behaviors (distinct sets of extendible S-labelings), so we can realize 2^B variable types and 2^B clause types.\n\nConcrete micro-lemmas to formalize next\n1) RID-forcing lemma. There is a radius-1 adjacency schema over a constant-size role/phase alphabet that, upon placing a VAR-activation token on S, deterministically fixes a unique B-bit one-hot RID string within the next O(B) positions. Distinct RIDs induce distinct type behaviors at the boundary (different activated S choices are extendible).\n2) Pair-gating lemma. There is a radius-1 schema that, given left VAR with RID=i and right CL with a three-element set {i1,i2,i3} encoded within O(1) of S, allows activation across the bridge if and only if i \u2208 {i1,i2,i3}; otherwise the only legal option is to deactivate (\u22a5) at one or both S-windows (enforced locally by Cout\u2013out).\n3) Clause-choice lemma. There is a radius-1 gadget on the bridge that nondeterministically chooses one of the three matching i and routes a witness chain to check the corresponding RUN subtrack; DP success is equivalent to the existence of a satisfied literal among the three under the f-colors.\n\nObstacles and open items\n- The exact encoding of the \u201cchoice\u201d on the bridge needs to be pinned down so that: (i) choice is local, (ii) its existence suffices for DP success (so (F1) is existential per pair), (iii) it cannot enable success for non-matching pairs.\n- We must verify that deactivation (\u22a5) never creates spurious constraints: for every non-matching pair, there is always a completion that uses \u22a5, regardless of f\u2019s color on other types.\n- We must confirm that the uniqueness of RID/GID under activation really separates types (no alternative interior labeling can fake a different RID/GID without violating adjacency), so the number of types available is exponential in B.\n\nNext steps\n- Write the RID-forcing and clause-gating gadgets precisely as out\u2013out adjacency tables, with a short formal proof of their correctness (local determinism from S; matching-only activation across the bridge).\n- Prove that the \u201cchoice-on-bridge\u201d gadget yields the right existential semantics for (F1) and that the entire pair space satisfies (F1) iff \u03a6_C is satisfiable.\n- Check that (F2) can be made vacuous with \u22a5 without interfering with (F1).\n- Once the above is settled, we can present a full reduction from Succinct-3SAT to FFE(F1), yielding NEXPTIME-hardness; by the known gap characterizations, this yields NEXPTIME-hardness for the 3-way classification.\n\nSummary\n- The NEXPTIME-membership part of output.md is in good shape. The hardness section B has a fundamental quantifier gap for (F1) and needs a corrected local \u201cgating\u201d mechanism so that only the intended (Vari, Clj) pairs are active, and even then the (F1)-existential nature must be implemented via a local nondeterministic choice on the bridge. I outlined concrete gadgets (RID-forcing, pair-gating, clause-choice) that, once formalized, should fix these issues while staying within radius-1, \u03b2-normalized constraints. I will next encode these gadgets into explicit Cout\u2013out tables and prove their properties."
}