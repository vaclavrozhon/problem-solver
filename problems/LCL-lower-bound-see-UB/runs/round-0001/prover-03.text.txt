{"progress_md":"Ideas and plan\n- Goal: Prove NEXPTIME-hardness of the 3-way classification (O(1) vs. Ω(log* n) vs. Ω(n)) for β-normalized, radius-1 LCLs on oriented paths. By the Balliu–Brandt–Chang–Olivetti–Rabie–Suomela framework (Section 4), the 3-way classification reduces to existence of a feasible function f with two properties: (F1) mid-consistency and (F2) bridging. If (F1) fails then the complexity is Θ(n); if (F1) holds and (F2) fails then Θ(log* n); if (F1)+(F2) holds then O(1). Hence NEXPTIME-hardness follows if we can reduce a NEXPTIME-hard problem (e.g., Succinct-3SAT) to deciding existence of f.\n- Upper bound: The attached draft “LCL_classification.pdf” sketches an NEXPTIME upper bound for Feasible-Function Existence (FFE) via types and bounded DP checks. I re-checked: the type bound |Types| ≤ 2^{Θ(β^4)} for r=1 is sound, the “finite z” lemma for (F2) with Z ≤ ℓ_pump^2 is correct, and the layered-DAG DP is O(kβ^2) for a length-k path. Hence membership in NEXPTIME looks solid.\n\nGaps/concerns in output.md (hardness part B)\n- Quantifier mismatch in (F1): (F1) universally quantifies over all ordered pairs of contexts (wa S1 wb, wc S2 wd), not merely pairs “variable on left, clause on right” with a shared variable. In Section B, the bridge is made to succeed only if a witness i connects the left “variable RID i” to a right “clause V(·)[i]=1”. This enforces success only for some pairs. But (F1) requires success for all ordered pairs simultaneously. As written, if there exist “variable” types Vari that are not among the three variables of a given clause type Clj, then the ordered pair (Vari, Clj) will cause the bridge DP to fail for the f chosen, violating (F1). The text attempts to restrict to pairs “where i ranges over variables occurring in clause(j)”, but (F1) does not allow restricting the universal set of pairs; every pair of context types appearing in C must pass.\n- “Inactive contexts” and pair filtering: The draft claims we can trivialize all pairs that are not (variable, clause) or have malformed blocks by allowing ⊥. However, (F1) still quantifies over ordered pairs regardless of internal content. If the left is a “variable” context (i fixed) and the right a “clause” context (j), but i /∈ vars(clause j), the pair remains “variable–clause” and is not falsifiable by declaring one side “inactive”: that would force f to assign ⊥ to at least one side for all contexts of that type, collapsing the intended encoding (we need variable/clause contexts to be active to constrain f). No mechanism was given that makes those specific pairs inactive without also deactivating the entire type.\n- Types vs. interior degrees of freedom: The argument “there are 2^B distinct variable types Vari and 2^B clause types Clj” uses that differing RID/GID values must give distinct types because extendibility from S differs “for some bridge”. But Type(·) is defined by which boundary assignments are extendible; it existentially quantifies over all interior labelings. If a context admits multiple interior RIDs, then for many S-labelings the existence of some witness RID can make extendibility identical across many RIDs. Thus different RID values need not force different types unless we can tie RID deterministically to boundary information. The current construction does not ensure RID/GID are uniquely determined by the context’s boundary behavior.\n- Context locality: The construction wants a large, well-formed block to sit “inside” w1 (resp. w2). But (F1) only fixes the two outputs on S; the remaining outputs (including inside w1 and w2) can be chosen arbitrarily in each check. This is intended, but it then exacerbates the previous issue: types correspond to sets of interior completions. One must ensure the property “RID equals i” is forced by boundary behavior, otherwise types conflate many RIDs.\n- Pair-wise gating by clause membership: The hardness relies on only pairs (Vari, Clj) with i ∈ vars(clause j) being active (i.e., constrained by the witness chain). However, no local, radius-1 gating was given that makes all other variable/clause pairs trivially extendible while keeping those of interest constraining, especially given that the grammar cannot refer to “pair identity” globally. A local activation must be derivable from S and nearby labels, not from global pairing information.\n\nSmall positive results we can reuse (from output.md)\n- Type bound for r=1: M := |Types| ≤ 24·2^{β^4} = 2^{Θ(β^4)}; set ℓ_pump := M.\n- Finite z for (F2): For each fixed context (w1, S, w2), the set {Type(w1^z S w2^z)} has size ≤ ℓ_pump^2, so it suffices to check 1 ≤ z ≤ Z with Z ≤ ℓ_pump^2.\n- DP feasibility test: For radius-1 β-normalized LCLs, partial-to-total extension on a given path with some outputs forced is decidable by a layered-DAG DP in O(kβ^2) time.\n\nProposed corrections/patches to the hardness construction\n- Force RID/GID by boundary behavior: To obtain a family of 2^B distinct “variable” context types Vari, we can build a left-anchored gadget whose unique continuation from the S-window outwards deterministically encodes the index i in the nearest O(1) outputs (e.g., a self-delimiting, gray-coded header with radius-1 local rules). Concretely, add a “phase” track that rigidly positions the start of a short RID header of length Θ(B) within distance O(1) from the S-window. Enforce, via Cout–out, that whenever the S-window carries a designated activation token and the phase indicates “variable mode”, the next O(B) outputs are uniquely determined (one-hot RID with a fixed delimiter). This ensures: (i) the interior labelings consistent with an activated S-window determine exactly one RID, (ii) types differ across different i because the set of boundary-extendible S-outputs differs.\n- Clause contexts likewise: Symmetrically enforce a GID header near S on the right context, again determined uniquely upon activation, and attach RUN rows that compute the literal set for clause j based on the fixed circuit C (hardwired in the adjacency table). As before, activation at S forces a unique GID.\n- Local gating of pairs: Introduce a “handshake” protocol across the bridge that makes a pair active only if both windows are activated and their local roles match a prescribed pattern (left role=VAR, right role=CL). All other combinations, including (VAR, CL) with at least one window deactivated (⊥), are assigned a trivial buffer language that always extends. This satisfies (F1) over all pairs once we ensure that, for each type, f can choose ⊥ to deactivate it when needed; but now activation will be needed only on the types we purposefully created (Vari, Clj), and deactivation on all other types is harmless.\n- Still need to address “wrong variable for a clause”: To avoid the quantifier mismatch, ensure that for a given right clause context Clj, only those left context types Vari with i ∈ vars(clause j) can be simultaneously activated: implement a local test that compares the variable index i (encoded near the left S-window) with the finite set of three indices embedded near the right S-window (also encoded near its S-window), and only if there is equality do we allow the activation token to persist across the bridge; otherwise the only locally valid option is to turn off activation on at least one S-window (i.e., f must set ⊥ for one of the two types). This way, for a fixed clause type Clj, there are exactly three variable types Vari whose joint activation with Clj is locally legal. All other pairs are forced to be inactive (and thus trivial). This preserves the universal quantifier of (F1): we require success for all pairs, but for non-matching pairs success is guaranteed by deactivation.\n- Encoding satisfiability: Now (F1) for the three matching pairs (Vari1, Clj), (Vari2, Clj), (Vari3, Clj) amounts to requiring that, with the f-choices of colors on these types, at least one pair’s witness chain can complete (using the V(+)/V(−) bits from the RUN gadget). To phrase this with universal quantification, we allow only one activated pair per clause to persist in any given bridge instance: locally, at the mid-bridge we place a “choice” gadget that nondeterministically selects one of the three matching i; the DP succeeds iff the selected i’s witness check passes. Since (F1) demands existence of some completion, it suffices that at least one of the three literal checks can succeed for the f-choice at Clj. This exactly encodes that each clause has a satisfied literal under the assignment extracted from f(Vari).\n- Trivializing (F2): As in the draft, add a neutral symbol ⊥ and permit filling wz with ⊥ regardless of the context, so (F2) is always true. This keeps the 3-way classification hinging on (F1) alone: satisfiable ⇒ (F1) holds ⇒ O(1); unsatisfiable ⇒ (F1) fails for some clause ⇒ Θ(n).\n\nToy counterexample of the current draft’s (F1) usage\n- Consider a clause type Clj whose literals are over indices {i1, i2, i3}. For a variable type Vari with i ∉ {i1, i2, i3}, the proposed grammar makes the pair active (since it is a (variable, clause) pair) and then the witness chain must fail (no V-bit at i), violating (F1) unless f sets ⊥ on Vari or Clj. But if f sets ⊥ on Vari to fix this pair, it also deactivates all its interactions with the correct clauses, undermining the intended encoding. This shows the need for local gating to force all non-matching pairs inactive irrespective of f.\n\nWhy the capacity (number of types) suffices\n- With β = poly(|C|), ℓ_pump = 2^{Θ(β^4)} gives room for exponentially many distinct context types. The “phase+RID/GID near S” gadgets use only O(B) symbols, so they comfortably fit into contexts of length ≥ ℓ_pump. Deterministic forcing from S ensures that different i (or j) yield different type behaviors (distinct sets of extendible S-labelings), so we can realize 2^B variable types and 2^B clause types.\n\nConcrete micro-lemmas to formalize next\n1) RID-forcing lemma. There is a radius-1 adjacency schema over a constant-size role/phase alphabet that, upon placing a VAR-activation token on S, deterministically fixes a unique B-bit one-hot RID string within the next O(B) positions. Distinct RIDs induce distinct type behaviors at the boundary (different activated S choices are extendible).\n2) Pair-gating lemma. There is a radius-1 schema that, given left VAR with RID=i and right CL with a three-element set {i1,i2,i3} encoded within O(1) of S, allows activation across the bridge if and only if i ∈ {i1,i2,i3}; otherwise the only legal option is to deactivate (⊥) at one or both S-windows (enforced locally by Cout–out).\n3) Clause-choice lemma. There is a radius-1 gadget on the bridge that nondeterministically chooses one of the three matching i and routes a witness chain to check the corresponding RUN subtrack; DP success is equivalent to the existence of a satisfied literal among the three under the f-colors.\n\nObstacles and open items\n- The exact encoding of the “choice” on the bridge needs to be pinned down so that: (i) choice is local, (ii) its existence suffices for DP success (so (F1) is existential per pair), (iii) it cannot enable success for non-matching pairs.\n- We must verify that deactivation (⊥) never creates spurious constraints: for every non-matching pair, there is always a completion that uses ⊥, regardless of f’s color on other types.\n- We must confirm that the uniqueness of RID/GID under activation really separates types (no alternative interior labeling can fake a different RID/GID without violating adjacency), so the number of types available is exponential in B.\n\nNext steps\n- Write the RID-forcing and clause-gating gadgets precisely as out–out adjacency tables, with a short formal proof of their correctness (local determinism from S; matching-only activation across the bridge).\n- Prove that the “choice-on-bridge” gadget yields the right existential semantics for (F1) and that the entire pair space satisfies (F1) iff Φ_C is satisfiable.\n- Check that (F2) can be made vacuous with ⊥ without interfering with (F1).\n- Once the above is settled, we can present a full reduction from Succinct-3SAT to FFE(F1), yielding NEXPTIME-hardness; by the known gap characterizations, this yields NEXPTIME-hardness for the 3-way classification.\n\nSummary\n- The NEXPTIME-membership part of output.md is in good shape. The hardness section B has a fundamental quantifier gap for (F1) and needs a corrected local “gating” mechanism so that only the intended (Vari, Clj) pairs are active, and even then the (F1)-existential nature must be implemented via a local nondeterministic choice on the bridge. I outlined concrete gadgets (RID-forcing, pair-gating, clause-choice) that, once formalized, should fix these issues while staying within radius-1, β-normalized constraints. I will next encode these gadgets into explicit Cout–out tables and prove their properties."}