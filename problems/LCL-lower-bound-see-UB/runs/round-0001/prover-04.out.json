{
  "progress_md": "Status and goal\n- Target: Show NEXPTIME-hardness of the 3-way classification problem for \u03b2-normalized, radius-1 LCLs on globally oriented paths: decide whether the LOCAL complexity is O(1) vs. \u03a9(log* n) vs. \u03a9(n).\n- Strategy adopted: Factor classification through the \u201cfeasible function\u201d certificates that characterize the two gaps on paths/cycles (Balliu\u2013Brandt\u2013Chang\u2013Olivetti\u2013Rabie\u2013Suomela, \u00a74). Prove:\n  1) Feasible-Function Existence for r=1, \u03b2-normalized LCLs is NEXPTIME-complete (mid-consistency (F1) only).\n  2) Reduce this to the 3-way classification by neutralizing bridging (F2) so that instances in the image are either O(1) (if (F1) holds) or \u03a9(n) (if (F1) fails), hence the 3-way decision is at least as hard.\n  3) Record a tight, finite verification procedure for (F1)+(F2) in 2^{poly(\u03b2)} to support membership (optional).\n\nQuick recap of types/pumping for r=1 (specialized bounds)\n- Boundary sets (radius r=1): B1 = {first, last}, B2 = {second, second-to-last}. The type of a path is determined by (i) its 4 boundary input bits and (ii) the extendibility bit-vector for all \u03b2^4 assignments of outputs to B1\u222aB2. Hence the number of types is\n  |Types| \u2264 2^4 \u00b7 2^{\u03b2^4} = 2^{\u03b2^4+4} =: \u2113_pump.\n- Pumping and replacement follow \u00a74, Lemmas 10\u201315: same-type replacement preserves extendibility and local legality; for any nonempty w there exist a,b>0 with a+b \u2264 \u2113_pump such that Type(w^{a t+b}) is t-invariant. We will use these facts repeatedly to (i) realize \u201cactive\u201d contexts of the needed form and (ii) bound finite checks below.\n\nFinite check for bridging (F2)\n- For any fixed context (w1,S,w2) with |w_i|\u2208{\u2113_pump,\u2113_pump+1} and |S|=2, the type of w1^z S w2^z depends only on the pair (Type(w1^z), Type(w2^z)). By periodicity of w_i (Lemma 15), each side cycles with period \u2264 \u2113_pump after \u2264 \u2113_pump prefix, hence the pair takes \u2264 \u2113_pump^2 values. Therefore there exists Z \u2264 \u2113_pump^2 such that (F2) holds iff the partial labeling on S extends for all z\u2208{1,\u2026,Z}.\n- Verification of extension on a partially labeled path is a standard layered-DAG DP in O(k \u03b2^2) time for a path of length k: layer i keeps allowed outputs matching Cin\u2013out (and any forced output); edges between adjacent layers match Cout\u2013out.\n\nNEXPTIME upper bound for Feasible-Function Existence (supporting algorithmics)\n- Precompute all types in time 2^{poly(\u03b2)} by exploring the boundary-extendibility DFA (composition Lemma 12); set \u2113_pump = |Types|.\n- Let C be the set of context types realized by w1 S w2 with |w_i|\u2208{\u2113_pump,\u2113_pump+1}. Nondeterministically guess f: C\u2192\u03a3_out^2. Verify:\n  (V1) Mid-consistency (F1): For every ordered pair of contexts, run the DP on wa S1 wb wc S2 wd with S1,S2 forced to f; accept iff extendible.\n  (V2) Bridging (F2): For each context (w1,S,w2) and each z \u2264 Z:=\u2113_pump^2, run the DP on w1^z S w2^z with S forced to f.\n- Complexity: 2^{poly(\u03b2)} overall; sound/complete for feasible-function existence.\n\nHardness core: Feasible-Function Existence (F1) is NEXPTIME-hard\n- Source: Succinct-3SAT (circuit C of size s \u201cgenerates\u201d a 3-CNF \u03a6_C over 2^B variables); NEXPTIME-complete.\n- Parameters: choose B = s^{c0}, \u03b2 = s^{c1} for constants 1 \u226a c0 \u226a c1. Then \u2113_pump = 2^{\u0398(\u03b2^4)} = 2^{poly(s)}.\n- Target instance P_C (\u03b2-normalized, r=1): \u03a3_in={0,1}; \u03a3_out of size \u03b2 contains constant tracks: role/phase, three colors {RED,GRN,BLU} and a neutral \u22a5, a finite error-alphabet, and a constant work alphabet for a fixed universal TM U.\n- Well-formed block language (output-regular, radius-1 checkable): a block = HEAD_C \u00b7 RID \u00b7 GID \u00b7 RUN \u00b7 PAD laid out along the path. Cin\u2013out enforces that role symbols copy designated input bits (so nodes in HEAD_C positions must see the corresponding input header bit). Cout\u2013out enforces adjacency, phase progress, and single-step consistency of U across seams; malformed fragments admit locally checkable \u201cerror chains\u201d (as in \u00a73) that always yield completions and hence never constrain f.\n- Semantics: the 2-node window S admits only colors or \u22a5. Non-\u22a5 at S \u201cactivates\u201d a witness-chain gadget: an existential pointer (radius-1) that (i) chooses an index i, (ii) walks to bit i inside the left block (variable) and checks Hot_RID[i]=1, and (iii) walks to bit i inside the right block (clause) and checks V^{(+)}[i]=1 (for RED) or V^{(-)}[i]=1 (for GRN). If any subcheck fails the chain gets stuck \u2192 no completion. When S=\u22a5, a self-looping \u22a5-plumbing language (independent of input) always completes. Thus inactive contexts (no valid block on either side) are tautologically satisfied by f(\u00b7)=\u22a5.\n- Existence of exponentially many active context types: Since the HEAD+RID/GID+RUN length is poly(s) \u226a \u2113_pump, pumping/replacement allow us to realize, within contexts (length \u2248\u2113_pump), many variants where the left side encodes any RID\u2208{0,1}^B and the right side encodes any GID\u2208{0,1}^B. Types differing in RID (or GID) are distinct because extendibility from S depends on Hot_RID and V^{(\u00b7)} at the chosen i. Hence we obtain 2^B variable-types {Var_i} and 2^B clause-types {Cl_j} in the context set C.\n- Correctness of reduction:\n  \u2022 Completeness: If \u03a6_C is satisfiable, pick a satisfying assignment \u03b1. Define f on variable types by f(Var_i)=RED if \u03b1(x_i)=1 and GRN otherwise; for each clause type Cl_j set f(Cl_j) to a true literal\u2019s color. All other (inactive) context types map to \u22a5. Every (F1) bridge wa S1 wb wc S2 wd either is trivial (inactive or non-(variable,clause)) or admits an i witnessing the chosen literal, so the DP completes.\n  \u2022 Soundness: If f satisfies (F1), define \u03b1 by reading f(Var_i) (RED\u21921, GRN\u21920; BLU arbitrary). For any clause j, (F1) applied to (Var_i,Cl_j) over all i occurring in clause j forces at least one match at i with the color chosen at Cl_j; hence \u03b1 satisfies clause j. Thus \u03b1 satisfies \u03a6_C.\n  \u2022 Inactive contexts never constrain: non-\u22a5 colors at S trigger witness chains that require a valid block; absent one, chains get stuck (no completion); \u22a5 always extends. Error chains ensure malformed encodings accept with a consistent \u201crefutation\u201d output.\n- Conclusion: Feasible-Function Existence (mid-consistency (F1) only) is NEXPTIME-hard for \u03b2-normalized, r=1 LCLs on oriented paths.\n\nFrom FFE(F1) to the 3-way classification\n- We construct, from P_C, a P_C^\u22c6 whose bridging (F2) is neutral:\n  \u2022 Keep P_C unchanged around S (so (F1) semantics identical).\n  \u2022 Permit, in Cout\u2013out and Cin\u2013out, a global \u22a5-filler language on repetitions w_1^z and w_2^z that is compatible with any boundary (including adjacency to S) and with any input. Then for every context and every z\u22651, the partial labeling that fixes S to f(Type(w1 S w2)) extends by filling w_i^z with \u22a5. Thus (F2) holds vacuously for every f.\n- Hence for P_C^\u22c6:\n  \u2022 If a feasible f (for (F1)) exists, both (F1) and (F2) hold, so the problem is O(1) by the standard construction (MIS-free partition with fill-in; \u00a74.5, Lemmas 26\u201327).\n  \u2022 If no feasible f exists, the (\u03c9(log* n)\u2013o(n)) dichotomy (Theorem 8) forces \u03a9(n) complexity.\n  \u2022 The \u03a9(log* n) class does not occur for P_C^\u22c6, so the 3-way classifier, when applied to P_C^\u22c6, outputs either O(1) or \u03a9(n). Deciding which is equivalent to deciding (F1) for P_C, which is NEXPTIME-hard.\n- Therefore, the 3-way classification problem is NEXPTIME-hard.\n\nWhy worst-case over inputs is handled (important subtlety)\n- Complexity is measured in the worst-case over input labelings. Our constructions ensure that malformed inputs are always completable in O(1) (\u22a5-plumbing or error chains), so the adversary\u2019s worst-case choice will include well-formed active contexts. In the satisfiable case, the O(1)-algorithm derived from f works on all inputs; in the unsatisfiable case, Theorem 8 yields a global \u03a9(n) lower bound (no f exists \u2192 no sublinear algorithm on cycles/paths).\n\nPotential gaps to firm up (action items)\n1) Radius-1 realizability of the block grammar: We sketched role/phase tracks and single-step checks for U across row seams; to be fully formal, we should list the finite set of out\u2013out pairs permitted at row separators and the Cin\u2013out masks that tie \u201crole-phase\u201d symbols to input bits. This is standard but should be written once.\n2) Witness chain details: spell out the constant-size alphabet and local rules for the existential pointer that safely walks to bit i in both blocks and enforces Hot_RID[i] \u2227 (V^{(+)}[i] or V^{(-)}[i]). This reuses the error-pointer pattern from \u00a73, but a concrete table will help verification.\n3) Active context separability: we used that distinct RID/GID induce distinct context types. A short lemma should argue: if two left contexts have different Hot vectors, there exists a right clause context and a color such that the extendibility bits differ\u2014hence types differ. (This reduces to the existence of some j and color where the witness succeeds for one RID but not the other.)\n4) Enumeration of types (upper bound side): we outlined a DFA exploration; adding an explicit construction based on the boolean-matrix view C_w (Appendix A of draft) would make precomputation and composition clearer.\n5) Three-class mapping clarity: While our hardness instances never realize the \u03a9(log* n) class, explaining explicitly that hardness for a subfamily suffices (since the classifier must be correct on all inputs) would avoid confusion.\n\nSmall sanity checks / examples\n- Toy DP: For a tiny \u03b2 (say \u03b2=3), define Cin\u2013out to allow \u22a5 on both input bits and restrict colors to input bit 1; define Cout\u2013out so that a colored S must be followed on the right by a specific symbol. Running the layered DP checks extendibility quickly; this matches the O(k \u03b2^2) bound.\n- Finite-Z for bridging: For a fixed (w1,S,w2), one can compute the two self-maps F_{w1}, F_{w2} on the type set, find their cycles, and set Z to lcm of periods times max preperiod (\u2264 \u2113_pump^2). On a random small instance, we indeed observe stabilization after a few iterations.\n\nNext steps (concrete deliverables)\n- Write the explicit out\u2013out adjacency tables for: (i) row separators and U\u2019s transition seams, (ii) error-pointer steps; specify the small work alphabet.\n- Prove the \u201cactive context separability\u201d lemma rigorously.\n- Package the reduction P_C \u21a6 P_C^\u22c6 with exact \u03b2 = poly(s) and tables\u2019 sizes \u0398(\u03b2^2); verify radius is 1 everywhere.\n- Optionally, extend the NEXPTIME-membership argument from feasible-function existence to the full 3-way classifier by adding the finite-Z bridging checks; this would give NEXPTIME-completeness if desired.\n\nNotes on attached materials (possible gaps)\n- In the draft (LCL_classification.pdf), Section B (hardness) sketches the block/witness gadgets but leaves adjacency tables implicit; these must be concretized to eliminate ambiguity about radius and alphabet size.\n- The claim \u201ctypes differing in RID/GID are distinct\u201d is stated but not proved; adding the separability lemma as noted above will close this gap.\n- The finite-Z lemma for (F2) is stated with Z \u2264 \u2113_pump^2; a brief derivation from the type DFA (pair product) would strengthen the presentation.\n\nSummary claim (ready to formalize)\n- The 3-way classification problem for \u03b2-normalized, radius-1 LCLs on oriented paths is NEXPTIME-hard. Reduction: Succinct-3SAT \u2192 Feasible-Function Existence (F1) (NEXPTIME-hard) \u2192 classification via bridging neutralization. The gadgets needed are all radius-1 and use \u03b2 = poly(|C|). The upper-bound side (finite checks via types + DP) sits in NEXPTIME and can be added to obtain completeness if needed."
}