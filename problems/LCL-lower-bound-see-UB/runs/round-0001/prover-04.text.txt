{"progress_md":"Status and goal\n- Target: Show NEXPTIME-hardness of the 3-way classification problem for β-normalized, radius-1 LCLs on globally oriented paths: decide whether the LOCAL complexity is O(1) vs. Ω(log* n) vs. Ω(n).\n- Strategy adopted: Factor classification through the “feasible function” certificates that characterize the two gaps on paths/cycles (Balliu–Brandt–Chang–Olivetti–Rabie–Suomela, §4). Prove:\n  1) Feasible-Function Existence for r=1, β-normalized LCLs is NEXPTIME-complete (mid-consistency (F1) only).\n  2) Reduce this to the 3-way classification by neutralizing bridging (F2) so that instances in the image are either O(1) (if (F1) holds) or Ω(n) (if (F1) fails), hence the 3-way decision is at least as hard.\n  3) Record a tight, finite verification procedure for (F1)+(F2) in 2^{poly(β)} to support membership (optional).\n\nQuick recap of types/pumping for r=1 (specialized bounds)\n- Boundary sets (radius r=1): B1 = {first, last}, B2 = {second, second-to-last}. The type of a path is determined by (i) its 4 boundary input bits and (ii) the extendibility bit-vector for all β^4 assignments of outputs to B1∪B2. Hence the number of types is\n  |Types| ≤ 2^4 · 2^{β^4} = 2^{β^4+4} =: ℓ_pump.\n- Pumping and replacement follow §4, Lemmas 10–15: same-type replacement preserves extendibility and local legality; for any nonempty w there exist a,b>0 with a+b ≤ ℓ_pump such that Type(w^{a t+b}) is t-invariant. We will use these facts repeatedly to (i) realize “active” contexts of the needed form and (ii) bound finite checks below.\n\nFinite check for bridging (F2)\n- For any fixed context (w1,S,w2) with |w_i|∈{ℓ_pump,ℓ_pump+1} and |S|=2, the type of w1^z S w2^z depends only on the pair (Type(w1^z), Type(w2^z)). By periodicity of w_i (Lemma 15), each side cycles with period ≤ ℓ_pump after ≤ ℓ_pump prefix, hence the pair takes ≤ ℓ_pump^2 values. Therefore there exists Z ≤ ℓ_pump^2 such that (F2) holds iff the partial labeling on S extends for all z∈{1,…,Z}.\n- Verification of extension on a partially labeled path is a standard layered-DAG DP in O(k β^2) time for a path of length k: layer i keeps allowed outputs matching Cin–out (and any forced output); edges between adjacent layers match Cout–out.\n\nNEXPTIME upper bound for Feasible-Function Existence (supporting algorithmics)\n- Precompute all types in time 2^{poly(β)} by exploring the boundary-extendibility DFA (composition Lemma 12); set ℓ_pump = |Types|.\n- Let C be the set of context types realized by w1 S w2 with |w_i|∈{ℓ_pump,ℓ_pump+1}. Nondeterministically guess f: C→Σ_out^2. Verify:\n  (V1) Mid-consistency (F1): For every ordered pair of contexts, run the DP on wa S1 wb wc S2 wd with S1,S2 forced to f; accept iff extendible.\n  (V2) Bridging (F2): For each context (w1,S,w2) and each z ≤ Z:=ℓ_pump^2, run the DP on w1^z S w2^z with S forced to f.\n- Complexity: 2^{poly(β)} overall; sound/complete for feasible-function existence.\n\nHardness core: Feasible-Function Existence (F1) is NEXPTIME-hard\n- Source: Succinct-3SAT (circuit C of size s “generates” a 3-CNF Φ_C over 2^B variables); NEXPTIME-complete.\n- Parameters: choose B = s^{c0}, β = s^{c1} for constants 1 ≪ c0 ≪ c1. Then ℓ_pump = 2^{Θ(β^4)} = 2^{poly(s)}.\n- Target instance P_C (β-normalized, r=1): Σ_in={0,1}; Σ_out of size β contains constant tracks: role/phase, three colors {RED,GRN,BLU} and a neutral ⊥, a finite error-alphabet, and a constant work alphabet for a fixed universal TM U.\n- Well-formed block language (output-regular, radius-1 checkable): a block = HEAD_C · RID · GID · RUN · PAD laid out along the path. Cin–out enforces that role symbols copy designated input bits (so nodes in HEAD_C positions must see the corresponding input header bit). Cout–out enforces adjacency, phase progress, and single-step consistency of U across seams; malformed fragments admit locally checkable “error chains” (as in §3) that always yield completions and hence never constrain f.\n- Semantics: the 2-node window S admits only colors or ⊥. Non-⊥ at S “activates” a witness-chain gadget: an existential pointer (radius-1) that (i) chooses an index i, (ii) walks to bit i inside the left block (variable) and checks Hot_RID[i]=1, and (iii) walks to bit i inside the right block (clause) and checks V^{(+)}[i]=1 (for RED) or V^{(-)}[i]=1 (for GRN). If any subcheck fails the chain gets stuck → no completion. When S=⊥, a self-looping ⊥-plumbing language (independent of input) always completes. Thus inactive contexts (no valid block on either side) are tautologically satisfied by f(·)=⊥.\n- Existence of exponentially many active context types: Since the HEAD+RID/GID+RUN length is poly(s) ≪ ℓ_pump, pumping/replacement allow us to realize, within contexts (length ≈ℓ_pump), many variants where the left side encodes any RID∈{0,1}^B and the right side encodes any GID∈{0,1}^B. Types differing in RID (or GID) are distinct because extendibility from S depends on Hot_RID and V^{(·)} at the chosen i. Hence we obtain 2^B variable-types {Var_i} and 2^B clause-types {Cl_j} in the context set C.\n- Correctness of reduction:\n  • Completeness: If Φ_C is satisfiable, pick a satisfying assignment α. Define f on variable types by f(Var_i)=RED if α(x_i)=1 and GRN otherwise; for each clause type Cl_j set f(Cl_j) to a true literal’s color. All other (inactive) context types map to ⊥. Every (F1) bridge wa S1 wb wc S2 wd either is trivial (inactive or non-(variable,clause)) or admits an i witnessing the chosen literal, so the DP completes.\n  • Soundness: If f satisfies (F1), define α by reading f(Var_i) (RED→1, GRN→0; BLU arbitrary). For any clause j, (F1) applied to (Var_i,Cl_j) over all i occurring in clause j forces at least one match at i with the color chosen at Cl_j; hence α satisfies clause j. Thus α satisfies Φ_C.\n  • Inactive contexts never constrain: non-⊥ colors at S trigger witness chains that require a valid block; absent one, chains get stuck (no completion); ⊥ always extends. Error chains ensure malformed encodings accept with a consistent “refutation” output.\n- Conclusion: Feasible-Function Existence (mid-consistency (F1) only) is NEXPTIME-hard for β-normalized, r=1 LCLs on oriented paths.\n\nFrom FFE(F1) to the 3-way classification\n- We construct, from P_C, a P_C^⋆ whose bridging (F2) is neutral:\n  • Keep P_C unchanged around S (so (F1) semantics identical).\n  • Permit, in Cout–out and Cin–out, a global ⊥-filler language on repetitions w_1^z and w_2^z that is compatible with any boundary (including adjacency to S) and with any input. Then for every context and every z≥1, the partial labeling that fixes S to f(Type(w1 S w2)) extends by filling w_i^z with ⊥. Thus (F2) holds vacuously for every f.\n- Hence for P_C^⋆:\n  • If a feasible f (for (F1)) exists, both (F1) and (F2) hold, so the problem is O(1) by the standard construction (MIS-free partition with fill-in; §4.5, Lemmas 26–27).\n  • If no feasible f exists, the (ω(log* n)–o(n)) dichotomy (Theorem 8) forces Ω(n) complexity.\n  • The Ω(log* n) class does not occur for P_C^⋆, so the 3-way classifier, when applied to P_C^⋆, outputs either O(1) or Ω(n). Deciding which is equivalent to deciding (F1) for P_C, which is NEXPTIME-hard.\n- Therefore, the 3-way classification problem is NEXPTIME-hard.\n\nWhy worst-case over inputs is handled (important subtlety)\n- Complexity is measured in the worst-case over input labelings. Our constructions ensure that malformed inputs are always completable in O(1) (⊥-plumbing or error chains), so the adversary’s worst-case choice will include well-formed active contexts. In the satisfiable case, the O(1)-algorithm derived from f works on all inputs; in the unsatisfiable case, Theorem 8 yields a global Ω(n) lower bound (no f exists → no sublinear algorithm on cycles/paths).\n\nPotential gaps to firm up (action items)\n1) Radius-1 realizability of the block grammar: We sketched role/phase tracks and single-step checks for U across row seams; to be fully formal, we should list the finite set of out–out pairs permitted at row separators and the Cin–out masks that tie “role-phase” symbols to input bits. This is standard but should be written once.\n2) Witness chain details: spell out the constant-size alphabet and local rules for the existential pointer that safely walks to bit i in both blocks and enforces Hot_RID[i] ∧ (V^{(+)}[i] or V^{(-)}[i]). This reuses the error-pointer pattern from §3, but a concrete table will help verification.\n3) Active context separability: we used that distinct RID/GID induce distinct context types. A short lemma should argue: if two left contexts have different Hot vectors, there exists a right clause context and a color such that the extendibility bits differ—hence types differ. (This reduces to the existence of some j and color where the witness succeeds for one RID but not the other.)\n4) Enumeration of types (upper bound side): we outlined a DFA exploration; adding an explicit construction based on the boolean-matrix view C_w (Appendix A of draft) would make precomputation and composition clearer.\n5) Three-class mapping clarity: While our hardness instances never realize the Ω(log* n) class, explaining explicitly that hardness for a subfamily suffices (since the classifier must be correct on all inputs) would avoid confusion.\n\nSmall sanity checks / examples\n- Toy DP: For a tiny β (say β=3), define Cin–out to allow ⊥ on both input bits and restrict colors to input bit 1; define Cout–out so that a colored S must be followed on the right by a specific symbol. Running the layered DP checks extendibility quickly; this matches the O(k β^2) bound.\n- Finite-Z for bridging: For a fixed (w1,S,w2), one can compute the two self-maps F_{w1}, F_{w2} on the type set, find their cycles, and set Z to lcm of periods times max preperiod (≤ ℓ_pump^2). On a random small instance, we indeed observe stabilization after a few iterations.\n\nNext steps (concrete deliverables)\n- Write the explicit out–out adjacency tables for: (i) row separators and U’s transition seams, (ii) error-pointer steps; specify the small work alphabet.\n- Prove the “active context separability” lemma rigorously.\n- Package the reduction P_C ↦ P_C^⋆ with exact β = poly(s) and tables’ sizes Θ(β^2); verify radius is 1 everywhere.\n- Optionally, extend the NEXPTIME-membership argument from feasible-function existence to the full 3-way classifier by adding the finite-Z bridging checks; this would give NEXPTIME-completeness if desired.\n\nNotes on attached materials (possible gaps)\n- In the draft (LCL_classification.pdf), Section B (hardness) sketches the block/witness gadgets but leaves adjacency tables implicit; these must be concretized to eliminate ambiguity about radius and alphabet size.\n- The claim “types differing in RID/GID are distinct” is stated but not proved; adding the separability lemma as noted above will close this gap.\n- The finite-Z lemma for (F2) is stated with Z ≤ ℓ_pump^2; a brief derivation from the type DFA (pair product) would strengthen the presentation.\n\nSummary claim (ready to formalize)\n- The 3-way classification problem for β-normalized, radius-1 LCLs on oriented paths is NEXPTIME-hard. Reduction: Succinct-3SAT → Feasible-Function Existence (F1) (NEXPTIME-hard) → classification via bridging neutralization. The gadgets needed are all radius-1 and use β = poly(|C|). The upper-bound side (finite checks via types + DP) sits in NEXPTIME and can be added to obtain completeness if needed."}