--- SYSTEM ---
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (summary so far)
- output.md (rigorously proven results so far)

Guidelines:
- notes.md: should be a readable running log of interesting work. Prefer appending. Replace only if old notes are clearly misleading. Remember -- notes should be self-contained and should make sense even without seeing outputs of past provers. 
- output.md:  Think twice before you add something to this file. Everything here should be rigorous, almost publication-ready. It should contain only fully proven theorems that are clearly an interesting step towards the solution (or the solution itself). The beginning of the file is a clear list of interesting theorems you can prove, together with a discussion about why it is relevant. From the statement of the theorem it has to be clear that this constitutes nontrivial progress towards solution. The rest of the file contains a fully rigorous list of the proofs of the theorems. Keep only proven theorems with clear proofs. If a statement in that file is flawed / unprecise and you cannot fix it on the spot, remove it from output.md and instead add it to notes.md with explanation.
- Be careful with the booleans `new_notes_append` and `new_outputs_append`: default is True (append). Use False only when deliberately rewriting everything.

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (â‰¥200 words). Include concrete next-step suggestions. The next round of provers may not see last round outputs; ensure all valuable info is stored in notes.",
  "new_notes_md": "Markdown (KaTeX allowed). Usually appended to notes.",
  "new_notes_append": "True|False",
  "new_outputs_md": "Markdown (KaTeX allowed). Usually appended to output.md.",
  "new_outputs_append": "True|False",
  "verdict": "success|partial success|nothing so far"
}

**Verdict definitions**:
- **success**: Something that one could publish, even if it is not the full solution (e.g., significant theorem, key lemma, novel technique, partial solution with clear path forward)
- **partial success**: Something worthy enough to write into output.md (e.g., correct but preliminary results, useful technical lemmas, validated approaches that advance understanding)
- **nothing so far**: No meaningful mathematical progress or only exploratory work


--- USER ---
You receive multiple prover reports. Evaluate correctness, value, and pick promising directions. Update notes.md (append/replace) with useful ideas and update output.md (append/replace) ONLY with rigorously verified results.

Prover reports (JSON):
[{"prover_id": "01", "progress_md": "Ideas and plan for NEXPTIME-hardness via feasible functions (and gaps spotted)\n\nContext recap and goal\n- We work with \u03b2-normalized, radius-1 LCLs on globally oriented paths, with explicit tables Cin\u2013out and Cout\u2013out. The classification into O(1), \u0398(log\u2217 n), \u0398(n) in the path/cycle case goes via the existence of a feasible function f on \u201ccontext types\u201d (mid-consistency F1 gives O(log\u2217 n) vs \u0398(n); adding bridging F2 gives O(1) vs \u03a9(log\u2217 n)), per Section 4 of the reference (Lemmas 10\u201315, 11, 12; Theorems 8\u20139).\n- The attached draft provides: (i) a NEXPTIME upper bound for deciding feasible-function existence (with an explicit bound Z \u2264 \u2113pump^2 for (F2) finite checks and an O(k \u03b2^2) DP for local extendibility), and (ii) a hardness sketch (Section B) intended to reduce Succinct-3SAT to mid-consistency (F1).\n\nCritical gaps in the current hardness sketch (Section B)\n1) Universal machine runtime and one-hot vectors: The draft says a fixed U runs in BO(1) to compute clause literals and uses a 2^B-long one-hot vector HotRID. Neither is feasible. Evaluating a size-s circuit C requires poly(s) steps; one-hot vectors of length 2^B cannot be produced/stored in a constant-alphabet radius-1 LCL with poly(s) footprint.\n2) Mid-consistency quantifies over all ordered pairs of contexts. The current design enforces that for (variable i, clause j) pairs the bridge only succeeds if i appears in j and the chosen colors match a picked literal. But f(Clj) is fixed per type; then for the other two variables in the same clause the bridge would fail, contradicting the \u201cfor all pairs\u201d requirement in (F1). This is a fundamental mismatch: 3SAT\u2019s \u201c\u2203 satisfied literal\u201d cannot be expressed by a constraint that must hold for every pairing.\n3) Type\u2013separation assumptions: The sketch implicitly needs exponentially many distinct context types (e.g., one per RID and per GID) and that type equality can be forced to depend on RID/GID. This needs a concrete mechanism to \u201cproject\u201d the index to a boundary-extendibility distinction (otherwise different indices could collapse to the same type).\n\nProposed pivot: reduce from Succinct 3-Coloring (NEXPTIME-complete)\nWhy it matches (F1):\n- Feasible-function mid-consistency induces pairwise constraints among context-types. 3-colorability of a succinctly described graph H on 2^B vertices is a pure pairwise constraint system: for each edge (u, v) we require color(u) \u2260 color(v). This aligns with \u201cfor all ordered pairs\u201d checks, provided we gate the bridge so that non-edges are trivial.\n- Succinct 3-coloring is NEXP-complete (Papadimitriou\u2013Yannakakis). The succinct adjacency oracle A(u, v) is a circuit of size s on 2B bits. This lets us stay within poly(s) resources inside a block.\n\nRefined reduction outline (mid-consistency (F1) only)\n- Instance: succinct graph G on V = {0,1}^B, circuit D(u, v) outputs 1 iff edge.\n- Build \u03b2-normalized LCL P_D with constant-radius verifier and \u03a3in = {0,1}; keep |\u03a3out| = \u03b2 = poly(s).\n- \u201cVertex contexts\u201d: For each u \u2208 {0,1}^B, we realize many contexts wa S wb whose interior carries a well-formed block encoding: a self-delimiting header (copy of D on input track), the index u, and a locally-checkable runzone computing a short \u201cseam handshake code\u201d Hu placed near the right boundary; symmetrically, the left boundary carries Lu. All of this is forced locally via Cout\u2013out. Error chains per \u00a73 of the reference allow any malformed block to be locally refuted, making such contexts effectively inactive.\n- Coloring choices via f: For each \u201cvertex-type\u201d \u03c4u (i.e., the type of contexts realizing u), f(\u03c4u) \u2208 {RED, GRN, BLU}^2 fixes a color token at S (two nodes). For all non-vertex types, set f(\u03c4) to a neutral token \u22a5\u22a5 that never activates constraints.\n- Gating only edges: In a bridge between (\u03c4u on the left, \u03c4v on the right), the seam region interprets Hu and the right\u2019s corresponding handshake. It then runs (in the bridge) a locally-checkable simulation of a fixed universal TM U on input (D, u, v) (time poly(s); we have length budget since \u2113pump \u226b poly(s)), to compute D(u, v). Error refutations are permitted, as usual. The cout\u2013out grammar enforces: the partial labeling extends if either (i) D(u, v) = 0 (non-edge) irrespective of colors; or (ii) D(u, v) = 1 and the two S colors are different. If D(u, v) = 1 and colors are equal, all completion paths get stuck, so the DP rejects.\n- All pairs outside the (vertex, vertex) role (or with malformed header/index) are trivially extendible (via \u22a5 plumbing), so they do not constrain f.\n- This creates the intended constraint family: for all ordered pairs, only edges impose \u201c\u2260\u201d; others are vacuous.\n\nWhy the above fixes the (F1) mismatch\n- With this gating, the (F1) universal quantification over ordered pairs exactly enforces a proper coloring constraint on every edge. There is no clause-like \u201cexists\u201d quantifier left that would clash with the universal pairing; non-edges require nothing.\n\nKey technical components to instantiate and verify\nA. Computing and checking at radius 1:\n- Block language: As in \u00a73, use a constant-alphabet, radius-1 nearest-neighbor checker for the header, index, and a row-by-row simulation of U for poly(s) steps. The input circuit D is copied from the input track (Cin\u2013out). The work alphabet of U is constant and independent of s.\n- Seam handshakes: Deterministically derive short fixed-size codes Lu, Hu from the index u and place them in O(1) cells adjacent to the context boundary; they are computed in the block and forced by Cout\u2013out.\n- Bridge computation: In wb\u25e6wc, run U for poly(s) steps using the adjacent copies of D and the seam codes Lu/Hv to reconstruct u and v and evaluate D(u, v). This is the same 1D-encoding recipe as \u00a73; errors are locally refutable.\nB. Separation of exponentially many vertex context types:\n- We need that for each u, there exist contexts whose type remembers the presence of Lu/Hu; more strongly, to assign different colors per u we only require that for each u there exists at least one type \u03c4u on which f can act. Distinctness of types can be enforced by a boundary-extendibility probe: add a reserved boundary-output pattern that triggers a local \u201cindex-check subroutine\u201d which accepts iff the seam code equals a prescribed function of u; different u yield different extendibility outcomes under that boundary pattern, hence different types. This uses the definition of Type (extendibility table on 4 boundary nodes).\n- Pumping to reach \u2113pump-sized buffers: Lemmas 12, 14\u201315 ensure we can embed the block and seam codes inside w1/w2 and pump to lengths \u2113pump or \u2113pump+1 without changing type (replacement lemma, Lemma 11).\nC. \u03b2 and time bounds:\n- The per-symbol state space (roles/phases/colors/\u22a5/error alphabet/U work letters) is constant; \u03b2 can be chosen poly(s) to absorb all tracks comfortably. The LCL description size is poly(\u03b2) = poly(s). The verifier\u2019s DP runs in O(k \u03b2^2) per string.\n\nCorrectness sketch under the new reduction\n- Completeness: If G is 3-colorable, pick any proper coloring \u03c7: V \u2192 {RED, GRN, BLU}. Define f(\u03c4u) = \u03c7(u). For any ordered pair (\u03c4u, \u03c4v), the bridge\u2019s local computation derives D(u, v); if D(u, v) = 0, we allow completion; if D(u, v) = 1, \u03c7(u) \u2260 \u03c7(v) so completion is allowed. All other context pairs are vacuous. Hence all (F1) checks pass.\n- Soundness: If a feasible f exists, read a color assignment \u03c7(u) = f(\u03c4u) (choosing any representative context type for each u; if several exist, they must all share the same f-value else (F1) would fail on the pair of those contexts). For any u, v with D(u, v) = 1, the bridge between \u03c4u and \u03c4v must be extendible, which forces \u03c7(u) \u2260 \u03c7(v). Thus \u03c7 is a proper 3-coloring, so G is 3-colorable.\n\nHandling (F2)\n- Make (F2) vacuous by allowing repeated sides wz\n1 and wz\n2 to be filled with \u22a5 (a self-looping buffer language in Cout\u2013out), independent of the chosen f on S. Then bridging checks in the upper bound accept for all z \u2264 \u2113pump^2 (and hence all z), without constraining f.\n\nExamples (toy sanity check)\n- Let B = 2, V = {00,01,10,11}. Let D encode a 4-cycle 00\u201301\u201311\u201310\u201300. Under the reduction, there are 4 vertex context types \u03c400,\u2026,\u03c411. Feasible f exist iff a 3-coloring of a 4-cycle exists (true). Pairs like (\u03c400, \u03c410) with D(00,10) = 0 are unconstrained; pairs like (\u03c400, \u03c401) with D(00,01) = 1 enforce f(\u03c400) \u2260 f(\u03c401).\n\nObstacles and open items to formalize next\n- Formal type-separation lemma: Specify the boundary-output probe and prove that contexts with distinct u become distinct types (by differing in at least one boundary-extendibility bit). This pins down the \u201cone type per vertex\u201d requirement.\n- Seam handshake construction details: Specify an O(1)-cell code and the local rules that move u from the block interior to the boundary deterministically.\n- Bridge computation layout: Spell out the row format and the interface that feeds D and (u, v) into the U-simulation, ensuring errors are caught locally.\n- Size bookkeeping: Choose concrete constants so that block length is poly(s), while \u2113pump = 2\u0398(\u03b2^4) dominates to allow pumping. Confirm Cin\u2013out/Cout\u2013out remain of size poly(\u03b2).\n\nWhy this yields NEXPTIME-hardness for feasible-function existence (and classification)\n- Feasible-function existence with (F1) alone is NEXPTIME-hard via succinct 3-coloring under the reduction above. Together with the NEXPTIME upper bound in the draft, this gives NEXPTIME-completeness for (F1)-feasibility in the explicit \u03b2-normalized, r=1 setting.\n- For full classification (O(1)/\u0398(log\u2217 n)/\u0398(n)), add the neutral \u22a5 repetition to trivialize (F2), so the hardness transfers to deciding whether (F1) holds\u2014hence to the classification problem that internally tests (F1).\n\nNext steps\n1) Write the explicit local rules for the seam gate and the bridge simulation (succinct adjacency computation) and verify they fit in radius 1.\n2) Prove the type-separation lemma rigorously (construct the boundary probe and show different u change the extendibility table).\n3) Integrate the error-chain library from \u00a73 to guarantee malformed blocks are always locally refutable, keeping non-vertex contexts harmless.\n4) Provide a fully quantified statement/theorem of the reduction with the poly-time construction mapping D \u21a6 P_D and the equivalence \u201cG 3-colorable \u21d4 (F1)-feasible f exists for P_D\u201d.\n\nNotes on the NEXPTIME upper bound (good to keep)\n- The finite z bound Z \u2264 \u2113pump^2 for (F2) follows cleanly from Lemma 15 periodicity and Lemma 12 composition; no circularity with f.\n- The layered DP (O(k \u03b2^2)) to decide extendibility of partially labeled paths gives an explicit verifier runtime bound compatible with 2poly(\u03b2).\n\nNo output.md was provided; these notes flag substantial issues in the current (3SAT-based) Section B and outline a repaired (3-coloring-based) reduction aligned with (F1)."}, {"prover_id": "02", "progress_md": "Headlines\n- Goal: Prove NEXPTIME-hardness for classifying \u03b2-normalized, radius-1 LCLs on globally oriented paths into O(1) vs. \u03a9(log* n) vs. \u03a9(n).\n- Status: The attached draft gives an NEXPTIME upper bound for feasible-function existence (FFE) and sketches NEXPTIME-hardness via a reduction from Succinct-3SAT. I identified a subtlety in the hardness appendix: \u201cactivity\u201d of a context must be type-invariant, since f is defined on context types, not on concrete words. I propose a corrected construction that makes the relevant property depend only on the boundary-extendibility behavior (hence on the type), and I outline the checks that keep everything radius-1 and \u03b2-normalized.\n\nGaps / issues spotted in the attached draft (Appendix B)\n- Context activity vs. type invariance. Appendix B uses \u201cactive contexts\u201d that contain a well-formed header+indices+RUN somewhere \u201cinside w1/w2.\u201d As written, the property \u201cthis concrete context contains a valid block\u201d may not be constant within a type: two words of the same type (agreeing on D1\u222aD2 extendibility) can differ arbitrarily in the interior. Since f is defined on types, we must ensure that for any type \u03c4 we use as a variable or clause type, every representative of \u03c4 is active in exactly the same way (otherwise (F1) could fail on some representative).\n- Where the exponential blow-up resides. The draft claims there are 2^B variable and 2^B clause context types present in C. This is plausible only if \u201cRID/GID\u201d information is encoded into the boundary-extendibility function of the whole context (thus affecting the type). It is not enough to place RID/GID far in the interior, as that would not be reflected in the type (which only depends on boundary inputs and the extendibility table for the 4 boundary outputs). A clean way is to make \u201cRID/GID\u201d selection manifest at the context\u2019s boundaries, via boundary key states whose permitted continuations encode the 2^B possibilities.\n- Uniform extendibility vs. S-only forcing. In the (F1) verification, only the two S nodes are forced; the verifier chooses all other outputs (including the 4 boundary nodes). Hence, any variable/clause identity must be \u201cselected\u201d by the existence of some consistent completion, not by externally fixing boundary outputs. The construction must ensure: for each variable-type \u03c4i, some (and in fact many) boundary assignments lead to a completion that realizes RID = i and no assignment leads to RID \u2260 i; analogously for clause types. Otherwise two different RIDs could collapse to the same type.\n\nKey idea: boundary-keyed types and seam-certified witnesses\n- Boundary-keyed types. For each variable index i\u2208{0,1}^B, define a distinct boundary behavior at the right end of a variable-context (the last two nodes of wa S1 wb), witnessed by a \u201ckey\u201d pair (kv,i, rv,i) of output symbols. Dually, for each clause index j define a distinct boundary behavior at the left end (first two nodes of wc S2 wd), with a key pair (kc,j, lc,j). The adjacency table is set so that:\n  - A variable-context of type Vari is characterized by: there exists a completion consistent with S free such that the last-two-boundary symbols are exactly (kv,i, rv,i), and conversely, no completion exists that realizes the last-two-boundary symbols from any other key (kv,i\u2032, rv,i\u2032) with i\u2032\u2260i. The same for clause-context types Clj at their first two boundary nodes.\n  - This makes RID/GID selection a property of the context\u2019s type (since the type is precisely the yes/no table of extendibility for all 4-boundary assignments). Because the type equivalence class records, for each of \u03b2^4 boundary assignments, whether a completion exists, we have more than enough capacity to separate 2^B different behaviors when \u03b2 = poly(s) and B = s^{c0} with a larger constant in \u03b2.\n- Witness chains initiated at S. Upon placing a non-\u22a5 color at S (RED/GRN/BLU), the out\u2013out rules enable a local \u201cwitness chain\u201d that walks from S to (i) the right boundary of the left context and (ii) the left boundary of the right context. At those boundaries, it must latch onto the proper keys (kv,i, rv,i) and (kc,j, lc,j). From the keys, the chain enters the corresponding interior block modules that encode, via a row-by-row 1D tableau, the vectors HotRID (one-hot) and the three clause-indicator vectors V(+),V(\u2212),V(\u22a5) computed by a fixed universal TM U on input (C, RID, GID). The chain succeeds iff for the chosen color, there exists a bit position p such that HotRID[p]=1 and V(\u00b1/\u22a5)[p]=1 as appropriate. If any subcheck fails, the chain cannot be completed (no completion exists, hence the DP rejects). All of this is radius-1: pointer segments are finite-state \u201cpipes\u201d checked by Cout\u2013out, and each tape row transition in RUN is enforced by nearest-neighbor constraints, exactly as in \u00a73 of the reference.\n- Uniformity within types. Because keys reside at the 4 boundary nodes and the admissible continuations for a given key are baked into the out\u2013out table, the existence/non-existence of a successful witness is purely a type property. That is, any two representatives of the same type have identical extendibility tables for all 4-boundary assignments; hence for a fixed color at S, either both admit some completion (with the appropriate key) or neither do.\n\nWhy exponentially many (context) types are available\n- Type count. For r=1, types are determined by: (i) 2^4 choices of boundary inputs and (ii) a \u03b2^4-bit truth table indicating which 4-boundary output assignments are extendible. Hence |Types| \u2264 2^4 \u00b7 2^{\u03b2^4} = 2^{\u0398(\u03b2^4)}. With \u03b2 = s^{c1}, pick c1\u226bc0 so that 2^{\u03b2^4} \u226b 2^B. Thus we can assign pairwise distinct truth tables to the 2^B desired variable keys and to the 2^B clause keys, leaving plenty of slack for all other contexts.\n- Realization by radius-1 rules. Each distinct truth table is realized by tailoring the local \u201cplumbing\u201d around the 4 boundary nodes: for each of the \u03b2^4 boundary assignments, either permit at least one outgoing legal extension (by supplying a small admissible gadget that grows into the variable/clause block and RUN) or forbid any extension (by forcing dead ends unless an error-chain is emitted, which we disallow when S carries a non-\u22a5 color). This is purely in Cout\u2013out and Cin\u2013out and does not depend on interior inputs.\n\nSoundness and completeness of the reduction (cleaned)\n- Source: Succinct-3SAT instance C of size s. We set \u03b2 = s^{c1} and work in the explicit \u03b2-normalized, radius-1 model.\n- Target: PC = (\u03a3in={0,1}, \u03a3out of size \u03b2, Cin\u2013out, Cout\u2013out). The alphabet has fixed tracks: role/phase, \u22a5, 3 colors {RED,GRN,BLU}, finitely many error symbols, and the work alphabet for U (all independent of B), as in \u00a73.\n- Variable and clause types. We reserve 2^B variable types {Vari} and 2^B clause types {Clj} by their boundary keys, as above. All other types are \u201cinactive\u201d and accept \u22a5 at S unconditionally.\n- (\u21d2) If \u03a6C is satisfiable, define f on types by: f(Vari)=RED if \u03b1(xi)=1 else GRN; f(Clj) is set to a color that corresponds to some true literal in clause(j) (RED for positive, GRN for negative; BLU is unused/dummy); f(\u03c4)=\u22a5 for all inactive types. For any ordered pair of contexts, if both are active and in roles (variable,clause), the witness chain succeeds by picking the unique hot position for RID (enforced by the variable block) and the matching 1 in V(\u00b1) (enforced by the clause block). All other ordered pairs are trivialized (either inactive or the grammar ignores colors in those role combinations), hence all (F1) DP checks pass.\n- (\u21d0) If there exists f satisfying (F1), read an assignment \u03b1 from the variable types: \u03b1(xi)=1 iff f(Vari)=RED, \u03b1(xi)=0 iff f(Vari)=GRN (BLU impossible for variable types by construction; if allowed, fix it arbitrarily). Fix any clause j. Since (F1) must hold for the ordered pair (Vari, Clj) for the i appearing in clause(j), the only way the DP can succeed (given the grammar) is that f(Clj) picks a color that matches a true literal under \u03b1 (the witness chain cannot otherwise be completed). Hence every clause has a true literal and \u03b1 satisfies \u03a6C.\n- Inactive contexts never constrain f: for any type without the proper boundary keys and RUN plumbing, any non-\u22a5 color at S leads to a dead-end (no completion), whereas \u22a5 always admits a completion via the neutral plumbing and/or the standard error-chain (per \u00a73). Thus assigning f(\u03c4)=\u22a5 for all such \u03c4 ensures all mixed-type (F1) checks pass.\n\nFrom FFE(F1) to the tri-class classification\n- As in the draft: (F1) characterizes O(log* n) vs. \u0398(n) (Theorem 8 machinery), and adding a neutral \u22a5 that freely fills repetitions makes (F2) vacuous, whence (F1)+(F2) yields O(1) (Theorem 9 machinery). Therefore:\n  - Distinguishing \u0398(n) vs. sublinear (i.e., the existence of a feasible f) is NEXPTIME-hard.\n  - Distinguishing O(1) vs. \u03a9(log* n) (by toggling (F2) via \u22a5-filling) is also NEXPTIME-hard.\n  - Hence the full three-way classification is NEXPTIME-hard under the explicit \u03b2-normalized encoding.\n\nCheckability and complexity bookkeeping\n- Radius 1: All constraints (role placement, boundary keys, pointer pipes, RUN row-to-row evolution, and error-chains) involve each node and its predecessor only, i.e., exactly Cin\u2013out and Cout\u2013out.\n- Alphabet size: \u03a3out is of size \u03b2 = poly(s); the number of \u201cstates\u201d required for roles, phases, pipes, and U is constant. The heavy lifting (2^B distinct behaviors) is encoded not in new symbols but in the accept/reject decisions for the \u03b2^4 boundary assignments (the type truth tables), which are programmed into Cout\u2013out.\n- Lengths: Contexts have length \u2248\u2113pump (double-exponential in s), so there is ample room to host the O(poly(s))-size headers/indices and RUNs needed to compute clause(j) from C.\n\nExamples / sanity checks\n- Toy instance: Fix B=2, so there are 4 variable and 4 clause types. Assign four disjoint pairs of boundary keys for the variables on the right and four for the clauses on the left. The seam witness for RED requires a position p with HotRID[p]=1 and V(+)[p]=1; the grammar enforces that exactly one p has HotRID[p]=1, and RUN computes V(+) correctly from C and GID. Testing all 16 ordered pairs (Vari, Clj) by hand recovers the truth table of satisfaction.\n\nNext steps (concrete, verifiable)\n1) Formalize the boundary-keyed type lemma: Given \u03b2, construct Cout\u2013out so that for any prescribed subset S\u2286[\u03b2]^4 (boundary assignments) of size \u22642^B we can realize a type whose extendibility table equals the indicator of S. This pins down the \u201ctruth table capacity\u201d rigorously.\n2) Write the exact local transition rules for the pointer pipes and RUN rows, following \u00a73 of the reference, and count the number of symbols added (to check \u03b2=poly(s) suffices).\n3) Prove the uniformity lemma: For any two words of the same type, the success/failure of the (F1) DP for a fixed pair of types and a fixed color at S is identical. This uses Lemma 11 (replacement) to justify that only the boundary truth tables matter.\n4) Integrate the \u22a5-filling trick to make (F2) vacuous and connect the hardness to the O(1) vs. \u03a9(log* n) gap explicitly.\n\nWhy useful here\n- The boundary-keyed construction eliminates the \u201cactivity\u201d non-invariance and anchors the reduction in the type semantics used by the NEXPTIME verifier. Establishing this rigorously will convert the hardness sketch into a clean, auditable proof.\n"}, {"prover_id": "03", "progress_md": "Ideas and plan\n- Goal: Prove NEXPTIME-hardness of the 3-way classification (O(1) vs. \u03a9(log* n) vs. \u03a9(n)) for \u03b2-normalized, radius-1 LCLs on oriented paths. By the Balliu\u2013Brandt\u2013Chang\u2013Olivetti\u2013Rabie\u2013Suomela framework (Section 4), the 3-way classification reduces to existence of a feasible function f with two properties: (F1) mid-consistency and (F2) bridging. If (F1) fails then the complexity is \u0398(n); if (F1) holds and (F2) fails then \u0398(log* n); if (F1)+(F2) holds then O(1). Hence NEXPTIME-hardness follows if we can reduce a NEXPTIME-hard problem (e.g., Succinct-3SAT) to deciding existence of f.\n- Upper bound: The attached draft \u201cLCL_classification.pdf\u201d sketches an NEXPTIME upper bound for Feasible-Function Existence (FFE) via types and bounded DP checks. I re-checked: the type bound |Types| \u2264 2^{\u0398(\u03b2^4)} for r=1 is sound, the \u201cfinite z\u201d lemma for (F2) with Z \u2264 \u2113_pump^2 is correct, and the layered-DAG DP is O(k\u03b2^2) for a length-k path. Hence membership in NEXPTIME looks solid.\n\nGaps/concerns in output.md (hardness part B)\n- Quantifier mismatch in (F1): (F1) universally quantifies over all ordered pairs of contexts (wa S1 wb, wc S2 wd), not merely pairs \u201cvariable on left, clause on right\u201d with a shared variable. In Section B, the bridge is made to succeed only if a witness i connects the left \u201cvariable RID i\u201d to a right \u201cclause V(\u00b7)[i]=1\u201d. This enforces success only for some pairs. But (F1) requires success for all ordered pairs simultaneously. As written, if there exist \u201cvariable\u201d types Vari that are not among the three variables of a given clause type Clj, then the ordered pair (Vari, Clj) will cause the bridge DP to fail for the f chosen, violating (F1). The text attempts to restrict to pairs \u201cwhere i ranges over variables occurring in clause(j)\u201d, but (F1) does not allow restricting the universal set of pairs; every pair of context types appearing in C must pass.\n- \u201cInactive contexts\u201d and pair filtering: The draft claims we can trivialize all pairs that are not (variable, clause) or have malformed blocks by allowing \u22a5. However, (F1) still quantifies over ordered pairs regardless of internal content. If the left is a \u201cvariable\u201d context (i fixed) and the right a \u201cclause\u201d context (j), but i /\u2208 vars(clause j), the pair remains \u201cvariable\u2013clause\u201d and is not falsifiable by declaring one side \u201cinactive\u201d: that would force f to assign \u22a5 to at least one side for all contexts of that type, collapsing the intended encoding (we need variable/clause contexts to be active to constrain f). No mechanism was given that makes those specific pairs inactive without also deactivating the entire type.\n- Types vs. interior degrees of freedom: The argument \u201cthere are 2^B distinct variable types Vari and 2^B clause types Clj\u201d uses that differing RID/GID values must give distinct types because extendibility from S differs \u201cfor some bridge\u201d. But Type(\u00b7) is defined by which boundary assignments are extendible; it existentially quantifies over all interior labelings. If a context admits multiple interior RIDs, then for many S-labelings the existence of some witness RID can make extendibility identical across many RIDs. Thus different RID values need not force different types unless we can tie RID deterministically to boundary information. The current construction does not ensure RID/GID are uniquely determined by the context\u2019s boundary behavior.\n- Context locality: The construction wants a large, well-formed block to sit \u201cinside\u201d w1 (resp. w2). But (F1) only fixes the two outputs on S; the remaining outputs (including inside w1 and w2) can be chosen arbitrarily in each check. This is intended, but it then exacerbates the previous issue: types correspond to sets of interior completions. One must ensure the property \u201cRID equals i\u201d is forced by boundary behavior, otherwise types conflate many RIDs.\n- Pair-wise gating by clause membership: The hardness relies on only pairs (Vari, Clj) with i \u2208 vars(clause j) being active (i.e., constrained by the witness chain). However, no local, radius-1 gating was given that makes all other variable/clause pairs trivially extendible while keeping those of interest constraining, especially given that the grammar cannot refer to \u201cpair identity\u201d globally. A local activation must be derivable from S and nearby labels, not from global pairing information.\n\nSmall positive results we can reuse (from output.md)\n- Type bound for r=1: M := |Types| \u2264 24\u00b72^{\u03b2^4} = 2^{\u0398(\u03b2^4)}; set \u2113_pump := M.\n- Finite z for (F2): For each fixed context (w1, S, w2), the set {Type(w1^z S w2^z)} has size \u2264 \u2113_pump^2, so it suffices to check 1 \u2264 z \u2264 Z with Z \u2264 \u2113_pump^2.\n- DP feasibility test: For radius-1 \u03b2-normalized LCLs, partial-to-total extension on a given path with some outputs forced is decidable by a layered-DAG DP in O(k\u03b2^2) time.\n\nProposed corrections/patches to the hardness construction\n- Force RID/GID by boundary behavior: To obtain a family of 2^B distinct \u201cvariable\u201d context types Vari, we can build a left-anchored gadget whose unique continuation from the S-window outwards deterministically encodes the index i in the nearest O(1) outputs (e.g., a self-delimiting, gray-coded header with radius-1 local rules). Concretely, add a \u201cphase\u201d track that rigidly positions the start of a short RID header of length \u0398(B) within distance O(1) from the S-window. Enforce, via Cout\u2013out, that whenever the S-window carries a designated activation token and the phase indicates \u201cvariable mode\u201d, the next O(B) outputs are uniquely determined (one-hot RID with a fixed delimiter). This ensures: (i) the interior labelings consistent with an activated S-window determine exactly one RID, (ii) types differ across different i because the set of boundary-extendible S-outputs differs.\n- Clause contexts likewise: Symmetrically enforce a GID header near S on the right context, again determined uniquely upon activation, and attach RUN rows that compute the literal set for clause j based on the fixed circuit C (hardwired in the adjacency table). As before, activation at S forces a unique GID.\n- Local gating of pairs: Introduce a \u201chandshake\u201d protocol across the bridge that makes a pair active only if both windows are activated and their local roles match a prescribed pattern (left role=VAR, right role=CL). All other combinations, including (VAR, CL) with at least one window deactivated (\u22a5), are assigned a trivial buffer language that always extends. This satisfies (F1) over all pairs once we ensure that, for each type, f can choose \u22a5 to deactivate it when needed; but now activation will be needed only on the types we purposefully created (Vari, Clj), and deactivation on all other types is harmless.\n- Still need to address \u201cwrong variable for a clause\u201d: To avoid the quantifier mismatch, ensure that for a given right clause context Clj, only those left context types Vari with i \u2208 vars(clause j) can be simultaneously activated: implement a local test that compares the variable index i (encoded near the left S-window) with the finite set of three indices embedded near the right S-window (also encoded near its S-window), and only if there is equality do we allow the activation token to persist across the bridge; otherwise the only locally valid option is to turn off activation on at least one S-window (i.e., f must set \u22a5 for one of the two types). This way, for a fixed clause type Clj, there are exactly three variable types Vari whose joint activation with Clj is locally legal. All other pairs are forced to be inactive (and thus trivial). This preserves the universal quantifier of (F1): we require success for all pairs, but for non-matching pairs success is guaranteed by deactivation.\n- Encoding satisfiability: Now (F1) for the three matching pairs (Vari1, Clj), (Vari2, Clj), (Vari3, Clj) amounts to requiring that, with the f-choices of colors on these types, at least one pair\u2019s witness chain can complete (using the V(+)/V(\u2212) bits from the RUN gadget). To phrase this with universal quantification, we allow only one activated pair per clause to persist in any given bridge instance: locally, at the mid-bridge we place a \u201cchoice\u201d gadget that nondeterministically selects one of the three matching i; the DP succeeds iff the selected i\u2019s witness check passes. Since (F1) demands existence of some completion, it suffices that at least one of the three literal checks can succeed for the f-choice at Clj. This exactly encodes that each clause has a satisfied literal under the assignment extracted from f(Vari).\n- Trivializing (F2): As in the draft, add a neutral symbol \u22a5 and permit filling wz with \u22a5 regardless of the context, so (F2) is always true. This keeps the 3-way classification hinging on (F1) alone: satisfiable \u21d2 (F1) holds \u21d2 O(1); unsatisfiable \u21d2 (F1) fails for some clause \u21d2 \u0398(n).\n\nToy counterexample of the current draft\u2019s (F1) usage\n- Consider a clause type Clj whose literals are over indices {i1, i2, i3}. For a variable type Vari with i \u2209 {i1, i2, i3}, the proposed grammar makes the pair active (since it is a (variable, clause) pair) and then the witness chain must fail (no V-bit at i), violating (F1) unless f sets \u22a5 on Vari or Clj. But if f sets \u22a5 on Vari to fix this pair, it also deactivates all its interactions with the correct clauses, undermining the intended encoding. This shows the need for local gating to force all non-matching pairs inactive irrespective of f.\n\nWhy the capacity (number of types) suffices\n- With \u03b2 = poly(|C|), \u2113_pump = 2^{\u0398(\u03b2^4)} gives room for exponentially many distinct context types. The \u201cphase+RID/GID near S\u201d gadgets use only O(B) symbols, so they comfortably fit into contexts of length \u2265 \u2113_pump. Deterministic forcing from S ensures that different i (or j) yield different type behaviors (distinct sets of extendible S-labelings), so we can realize 2^B variable types and 2^B clause types.\n\nConcrete micro-lemmas to formalize next\n1) RID-forcing lemma. There is a radius-1 adjacency schema over a constant-size role/phase alphabet that, upon placing a VAR-activation token on S, deterministically fixes a unique B-bit one-hot RID string within the next O(B) positions. Distinct RIDs induce distinct type behaviors at the boundary (different activated S choices are extendible).\n2) Pair-gating lemma. There is a radius-1 schema that, given left VAR with RID=i and right CL with a three-element set {i1,i2,i3} encoded within O(1) of S, allows activation across the bridge if and only if i \u2208 {i1,i2,i3}; otherwise the only legal option is to deactivate (\u22a5) at one or both S-windows (enforced locally by Cout\u2013out).\n3) Clause-choice lemma. There is a radius-1 gadget on the bridge that nondeterministically chooses one of the three matching i and routes a witness chain to check the corresponding RUN subtrack; DP success is equivalent to the existence of a satisfied literal among the three under the f-colors.\n\nObstacles and open items\n- The exact encoding of the \u201cchoice\u201d on the bridge needs to be pinned down so that: (i) choice is local, (ii) its existence suffices for DP success (so (F1) is existential per pair), (iii) it cannot enable success for non-matching pairs.\n- We must verify that deactivation (\u22a5) never creates spurious constraints: for every non-matching pair, there is always a completion that uses \u22a5, regardless of f\u2019s color on other types.\n- We must confirm that the uniqueness of RID/GID under activation really separates types (no alternative interior labeling can fake a different RID/GID without violating adjacency), so the number of types available is exponential in B.\n\nNext steps\n- Write the RID-forcing and clause-gating gadgets precisely as out\u2013out adjacency tables, with a short formal proof of their correctness (local determinism from S; matching-only activation across the bridge).\n- Prove that the \u201cchoice-on-bridge\u201d gadget yields the right existential semantics for (F1) and that the entire pair space satisfies (F1) iff \u03a6_C is satisfiable.\n- Check that (F2) can be made vacuous with \u22a5 without interfering with (F1).\n- Once the above is settled, we can present a full reduction from Succinct-3SAT to FFE(F1), yielding NEXPTIME-hardness; by the known gap characterizations, this yields NEXPTIME-hardness for the 3-way classification.\n\nSummary\n- The NEXPTIME-membership part of output.md is in good shape. The hardness section B has a fundamental quantifier gap for (F1) and needs a corrected local \u201cgating\u201d mechanism so that only the intended (Vari, Clj) pairs are active, and even then the (F1)-existential nature must be implemented via a local nondeterministic choice on the bridge. I outlined concrete gadgets (RID-forcing, pair-gating, clause-choice) that, once formalized, should fix these issues while staying within radius-1, \u03b2-normalized constraints. I will next encode these gadgets into explicit Cout\u2013out tables and prove their properties."}, {"prover_id": "04", "progress_md": "Status and goal\n- Target: Show NEXPTIME-hardness of the 3-way classification problem for \u03b2-normalized, radius-1 LCLs on globally oriented paths: decide whether the LOCAL complexity is O(1) vs. \u03a9(log* n) vs. \u03a9(n).\n- Strategy adopted: Factor classification through the \u201cfeasible function\u201d certificates that characterize the two gaps on paths/cycles (Balliu\u2013Brandt\u2013Chang\u2013Olivetti\u2013Rabie\u2013Suomela, \u00a74). Prove:\n  1) Feasible-Function Existence for r=1, \u03b2-normalized LCLs is NEXPTIME-complete (mid-consistency (F1) only).\n  2) Reduce this to the 3-way classification by neutralizing bridging (F2) so that instances in the image are either O(1) (if (F1) holds) or \u03a9(n) (if (F1) fails), hence the 3-way decision is at least as hard.\n  3) Record a tight, finite verification procedure for (F1)+(F2) in 2^{poly(\u03b2)} to support membership (optional).\n\nQuick recap of types/pumping for r=1 (specialized bounds)\n- Boundary sets (radius r=1): B1 = {first, last}, B2 = {second, second-to-last}. The type of a path is determined by (i) its 4 boundary input bits and (ii) the extendibility bit-vector for all \u03b2^4 assignments of outputs to B1\u222aB2. Hence the number of types is\n  |Types| \u2264 2^4 \u00b7 2^{\u03b2^4} = 2^{\u03b2^4+4} =: \u2113_pump.\n- Pumping and replacement follow \u00a74, Lemmas 10\u201315: same-type replacement preserves extendibility and local legality; for any nonempty w there exist a,b>0 with a+b \u2264 \u2113_pump such that Type(w^{a t+b}) is t-invariant. We will use these facts repeatedly to (i) realize \u201cactive\u201d contexts of the needed form and (ii) bound finite checks below.\n\nFinite check for bridging (F2)\n- For any fixed context (w1,S,w2) with |w_i|\u2208{\u2113_pump,\u2113_pump+1} and |S|=2, the type of w1^z S w2^z depends only on the pair (Type(w1^z), Type(w2^z)). By periodicity of w_i (Lemma 15), each side cycles with period \u2264 \u2113_pump after \u2264 \u2113_pump prefix, hence the pair takes \u2264 \u2113_pump^2 values. Therefore there exists Z \u2264 \u2113_pump^2 such that (F2) holds iff the partial labeling on S extends for all z\u2208{1,\u2026,Z}.\n- Verification of extension on a partially labeled path is a standard layered-DAG DP in O(k \u03b2^2) time for a path of length k: layer i keeps allowed outputs matching Cin\u2013out (and any forced output); edges between adjacent layers match Cout\u2013out.\n\nNEXPTIME upper bound for Feasible-Function Existence (supporting algorithmics)\n- Precompute all types in time 2^{poly(\u03b2)} by exploring the boundary-extendibility DFA (composition Lemma 12); set \u2113_pump = |Types|.\n- Let C be the set of context types realized by w1 S w2 with |w_i|\u2208{\u2113_pump,\u2113_pump+1}. Nondeterministically guess f: C\u2192\u03a3_out^2. Verify:\n  (V1) Mid-consistency (F1): For every ordered pair of contexts, run the DP on wa S1 wb wc S2 wd with S1,S2 forced to f; accept iff extendible.\n  (V2) Bridging (F2): For each context (w1,S,w2) and each z \u2264 Z:=\u2113_pump^2, run the DP on w1^z S w2^z with S forced to f.\n- Complexity: 2^{poly(\u03b2)} overall; sound/complete for feasible-function existence.\n\nHardness core: Feasible-Function Existence (F1) is NEXPTIME-hard\n- Source: Succinct-3SAT (circuit C of size s \u201cgenerates\u201d a 3-CNF \u03a6_C over 2^B variables); NEXPTIME-complete.\n- Parameters: choose B = s^{c0}, \u03b2 = s^{c1} for constants 1 \u226a c0 \u226a c1. Then \u2113_pump = 2^{\u0398(\u03b2^4)} = 2^{poly(s)}.\n- Target instance P_C (\u03b2-normalized, r=1): \u03a3_in={0,1}; \u03a3_out of size \u03b2 contains constant tracks: role/phase, three colors {RED,GRN,BLU} and a neutral \u22a5, a finite error-alphabet, and a constant work alphabet for a fixed universal TM U.\n- Well-formed block language (output-regular, radius-1 checkable): a block = HEAD_C \u00b7 RID \u00b7 GID \u00b7 RUN \u00b7 PAD laid out along the path. Cin\u2013out enforces that role symbols copy designated input bits (so nodes in HEAD_C positions must see the corresponding input header bit). Cout\u2013out enforces adjacency, phase progress, and single-step consistency of U across seams; malformed fragments admit locally checkable \u201cerror chains\u201d (as in \u00a73) that always yield completions and hence never constrain f.\n- Semantics: the 2-node window S admits only colors or \u22a5. Non-\u22a5 at S \u201cactivates\u201d a witness-chain gadget: an existential pointer (radius-1) that (i) chooses an index i, (ii) walks to bit i inside the left block (variable) and checks Hot_RID[i]=1, and (iii) walks to bit i inside the right block (clause) and checks V^{(+)}[i]=1 (for RED) or V^{(-)}[i]=1 (for GRN). If any subcheck fails the chain gets stuck \u2192 no completion. When S=\u22a5, a self-looping \u22a5-plumbing language (independent of input) always completes. Thus inactive contexts (no valid block on either side) are tautologically satisfied by f(\u00b7)=\u22a5.\n- Existence of exponentially many active context types: Since the HEAD+RID/GID+RUN length is poly(s) \u226a \u2113_pump, pumping/replacement allow us to realize, within contexts (length \u2248\u2113_pump), many variants where the left side encodes any RID\u2208{0,1}^B and the right side encodes any GID\u2208{0,1}^B. Types differing in RID (or GID) are distinct because extendibility from S depends on Hot_RID and V^{(\u00b7)} at the chosen i. Hence we obtain 2^B variable-types {Var_i} and 2^B clause-types {Cl_j} in the context set C.\n- Correctness of reduction:\n  \u2022 Completeness: If \u03a6_C is satisfiable, pick a satisfying assignment \u03b1. Define f on variable types by f(Var_i)=RED if \u03b1(x_i)=1 and GRN otherwise; for each clause type Cl_j set f(Cl_j) to a true literal\u2019s color. All other (inactive) context types map to \u22a5. Every (F1) bridge wa S1 wb wc S2 wd either is trivial (inactive or non-(variable,clause)) or admits an i witnessing the chosen literal, so the DP completes.\n  \u2022 Soundness: If f satisfies (F1), define \u03b1 by reading f(Var_i) (RED\u21921, GRN\u21920; BLU arbitrary). For any clause j, (F1) applied to (Var_i,Cl_j) over all i occurring in clause j forces at least one match at i with the color chosen at Cl_j; hence \u03b1 satisfies clause j. Thus \u03b1 satisfies \u03a6_C.\n  \u2022 Inactive contexts never constrain: non-\u22a5 colors at S trigger witness chains that require a valid block; absent one, chains get stuck (no completion); \u22a5 always extends. Error chains ensure malformed encodings accept with a consistent \u201crefutation\u201d output.\n- Conclusion: Feasible-Function Existence (mid-consistency (F1) only) is NEXPTIME-hard for \u03b2-normalized, r=1 LCLs on oriented paths.\n\nFrom FFE(F1) to the 3-way classification\n- We construct, from P_C, a P_C^\u22c6 whose bridging (F2) is neutral:\n  \u2022 Keep P_C unchanged around S (so (F1) semantics identical).\n  \u2022 Permit, in Cout\u2013out and Cin\u2013out, a global \u22a5-filler language on repetitions w_1^z and w_2^z that is compatible with any boundary (including adjacency to S) and with any input. Then for every context and every z\u22651, the partial labeling that fixes S to f(Type(w1 S w2)) extends by filling w_i^z with \u22a5. Thus (F2) holds vacuously for every f.\n- Hence for P_C^\u22c6:\n  \u2022 If a feasible f (for (F1)) exists, both (F1) and (F2) hold, so the problem is O(1) by the standard construction (MIS-free partition with fill-in; \u00a74.5, Lemmas 26\u201327).\n  \u2022 If no feasible f exists, the (\u03c9(log* n)\u2013o(n)) dichotomy (Theorem 8) forces \u03a9(n) complexity.\n  \u2022 The \u03a9(log* n) class does not occur for P_C^\u22c6, so the 3-way classifier, when applied to P_C^\u22c6, outputs either O(1) or \u03a9(n). Deciding which is equivalent to deciding (F1) for P_C, which is NEXPTIME-hard.\n- Therefore, the 3-way classification problem is NEXPTIME-hard.\n\nWhy worst-case over inputs is handled (important subtlety)\n- Complexity is measured in the worst-case over input labelings. Our constructions ensure that malformed inputs are always completable in O(1) (\u22a5-plumbing or error chains), so the adversary\u2019s worst-case choice will include well-formed active contexts. In the satisfiable case, the O(1)-algorithm derived from f works on all inputs; in the unsatisfiable case, Theorem 8 yields a global \u03a9(n) lower bound (no f exists \u2192 no sublinear algorithm on cycles/paths).\n\nPotential gaps to firm up (action items)\n1) Radius-1 realizability of the block grammar: We sketched role/phase tracks and single-step checks for U across row seams; to be fully formal, we should list the finite set of out\u2013out pairs permitted at row separators and the Cin\u2013out masks that tie \u201crole-phase\u201d symbols to input bits. This is standard but should be written once.\n2) Witness chain details: spell out the constant-size alphabet and local rules for the existential pointer that safely walks to bit i in both blocks and enforces Hot_RID[i] \u2227 (V^{(+)}[i] or V^{(-)}[i]). This reuses the error-pointer pattern from \u00a73, but a concrete table will help verification.\n3) Active context separability: we used that distinct RID/GID induce distinct context types. A short lemma should argue: if two left contexts have different Hot vectors, there exists a right clause context and a color such that the extendibility bits differ\u2014hence types differ. (This reduces to the existence of some j and color where the witness succeeds for one RID but not the other.)\n4) Enumeration of types (upper bound side): we outlined a DFA exploration; adding an explicit construction based on the boolean-matrix view C_w (Appendix A of draft) would make precomputation and composition clearer.\n5) Three-class mapping clarity: While our hardness instances never realize the \u03a9(log* n) class, explaining explicitly that hardness for a subfamily suffices (since the classifier must be correct on all inputs) would avoid confusion.\n\nSmall sanity checks / examples\n- Toy DP: For a tiny \u03b2 (say \u03b2=3), define Cin\u2013out to allow \u22a5 on both input bits and restrict colors to input bit 1; define Cout\u2013out so that a colored S must be followed on the right by a specific symbol. Running the layered DP checks extendibility quickly; this matches the O(k \u03b2^2) bound.\n- Finite-Z for bridging: For a fixed (w1,S,w2), one can compute the two self-maps F_{w1}, F_{w2} on the type set, find their cycles, and set Z to lcm of periods times max preperiod (\u2264 \u2113_pump^2). On a random small instance, we indeed observe stabilization after a few iterations.\n\nNext steps (concrete deliverables)\n- Write the explicit out\u2013out adjacency tables for: (i) row separators and U\u2019s transition seams, (ii) error-pointer steps; specify the small work alphabet.\n- Prove the \u201cactive context separability\u201d lemma rigorously.\n- Package the reduction P_C \u21a6 P_C^\u22c6 with exact \u03b2 = poly(s) and tables\u2019 sizes \u0398(\u03b2^2); verify radius is 1 everywhere.\n- Optionally, extend the NEXPTIME-membership argument from feasible-function existence to the full 3-way classifier by adding the finite-Z bridging checks; this would give NEXPTIME-completeness if desired.\n\nNotes on attached materials (possible gaps)\n- In the draft (LCL_classification.pdf), Section B (hardness) sketches the block/witness gadgets but leaves adjacency tables implicit; these must be concretized to eliminate ambiguity about radius and alphabet size.\n- The claim \u201ctypes differing in RID/GID are distinct\u201d is stated but not proved; adding the separability lemma as noted above will close this gap.\n- The finite-Z lemma for (F2) is stated with Z \u2264 \u2113_pump^2; a brief derivation from the type DFA (pair product) would strengthen the presentation.\n\nSummary claim (ready to formalize)\n- The 3-way classification problem for \u03b2-normalized, radius-1 LCLs on oriented paths is NEXPTIME-hard. Reduction: Succinct-3SAT \u2192 Feasible-Function Existence (F1) (NEXPTIME-hard) \u2192 classification via bridging neutralization. The gadgets needed are all radius-1 and use \u03b2 = poly(|C|). The upper-bound side (finite checks via types + DP) sits in NEXPTIME and can be added to obtain completeness if needed."}]

Current notes.md:


Current output.md (if any):

