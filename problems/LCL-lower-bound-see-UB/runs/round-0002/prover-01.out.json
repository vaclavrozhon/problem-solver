{
  "progress_md": "## Round 0002 \u2014 2025-08-27T11:23:07.543718Z\n\nMini-plan\n- Recast feasible-function existence (F1) as an implicit exponential-sized SAT instance over type-choices, then map Succinct-3SAT to it. Make the quantifier structure transparent.\n- Fix the bridge semantics: clause-side chooses one of its 3 occurrences (not a sign), variable-side chooses its truth; the gate is ON only for the matching occurrence/variable-index pair; ON enforces truth=sign(occ). OFF pairs are trivially fillable. This aligns \u201cfor all ordered pairs\u201d with \u201c\u2203 a satisfied literal.\u201d\n- State a clean SAT-of-types lemma and the gating-correctness lemma with how-it-can-fail and quick tests (B=2 toy). Tie to radius-1 and \u03b2-normalized implementation.\n- Prove existence and separability of exponentially many active context types (2^B variable-types and 2^B clause-types) using pumping and window anchoring; include a crisp type-separation witness.\n- Specify the poly(s)-length, radius-1 clause-verification tableau that exposes (i1, i2, i3) and their signs next to S; add error-chain refuters. Conclude soundness/completeness for (F1) and show how to trivialize (F2) for classification hardness.\n\n1) SAT-of-types view of (F1)\nClaim G (Implicit SAT for feasible-function existence). For a fixed \u03b2-normalized, r=1 LCL P and its context-type set C (types of w1 S w2 with |w1|,|w2|\u2208{\u2113pump,\u2113pump+1}), there is an implicit exponentially large SAT instance F(P) over variables encoding f(\u03c4) (the 2-node label at S for each \u03c4\u2208C), and for each ordered pair (\u03c4L,\u03c4R) a local constraint R(\u03c4L,\u03c4R,f(\u03c4L),f(\u03c4R)) that holds iff the DP on the bridge wa S1 wb wc S2 wd (with types \u03c4L,\u03c4R) succeeds. Then there exists a feasible f satisfying (F1) iff F(P) is satisfiable.\n- Why useful here: Reducing Succinct-3SAT to F(P) (or vice versa) yields NEXPTIME-hardness via an implicit exponential SAT. It also clarifies that our bridge-gadget just defines a pairwise constraint language on type-colors decidable by the O(k\u03b2^2) DP.\n- How it can fail: If C depended on f (circularity), or if the pairwise DP check were not radius-1 decidable, we could not encode constraints locally. Here, C is defined purely by input types (Section 4 types) and the DP is radius-1.\n- Quick test: Pick a small \u03a3out (\u03b2=5), enumerate 2\u20133 contexts with actual strings, run the DP to tabulate which f-choices on S1,S2 are extendible. The truth table matches a Boolean constraint R for those (\u03c4L,\u03c4R).\n\n2) Correct bridge semantics: clause chooses occurrence, variable chooses truth\nPatch H (Occurrence-selected gate). Modify the S-alphabet and gate:\n- Variable-side S palette: VT (true) or VF (false). Interpreted as \u03b1(x_i)=1 iff VT.\n- Clause-side S palette: O1,O2,O3 (select occurrence t\u2208{1,2,3} of clause j). No sign is chosen at S; signs are read from the clause RUN for that occurrence.\n- Gate ON condition (purely local): the left wb contains a well-formed variable block with RID=i; the right wc contains a well-formed clause block with the triple (i1,sgn1),(i2,sgn2),(i3,sgn3). If clause S-color=Ot and RID=i equals it, gate=ON; otherwise OFF. Window anchoring places all needed bits inside wb or wc.\n- ON-bridge semantics: enforce that VT iff sgnt=+ and VF iff sgnt=\u2212, via a one-bit CAP conduit from S1 to S2 (compare variable truth with required sign of the selected occurrence t). OFF-bridge semantics: wb\u25e6wc is PAD-plumbable regardless of S colors.\n- Why useful here: Fixes the earlier quantification mismatch: for a clause j, only the pair with the variable-type matching the chosen occurrence turns ON; the other two pairs turn OFF and are trivial, so (F1)\u2019s universal quantifier no longer overconstrains clauses.\n- How it can fail: (i) If the DP can deviate and turn ON without RID=it equality (no: ON is determined at the immediate seam by tokens and checked locally); (ii) If OFF were rejected due to seam interactions (we ensure PAD-plumbing accepts all OFF seams); (iii) If we needed to encode it (the occurrence index) at S (we do not: S carries only Ot; equality to RID is tested by a witness path inside wb and wc).\n- Quick test: Clause j with occurrences (i1=3,+), (i2=7,\u2212), (i3=10,+). If f(\u03c4Cl(j))=O2, only pairs with \u03c4Var(7) are ON; their success requires VF at S1. Pairs with \u03c4Var(3) and \u03c4Var(10) are OFF and always fill. Thus f(\u03c4Cl(j))=O2 works iff \u03b1(x7)=0.\n\n3) Equivalence to Succinct-3SAT via implicit SAT\nClaim I (SAT-of-types \u2261 Succinct-3SAT under Patch H). Let C be a succinct generator of a 3-CNF \u03a6C over variables x1,\u2026,x_{2^B}. Build PC so that active context types include all \u03c4Var(i) (all i\u2208{0,1}^B) and all \u03c4Cl(j) (all j\u2208{0,1}^B). Under Patch H, (F1) holds for some f iff \u03a6C is satisfiable.\n- Informal proof sketch: Introduce Boolean variables A_i (truth of x_i) corresponding to f(\u03c4Var(i))\u2208{VT,VF}, and 3-way selector T_j\u2208{1,2,3} corresponding to f(\u03c4Cl(j))\u2208{O1,O2,O3}. The bridge constraints across all ordered pairs conjoin, for each j, the single ON-pair constraint: if T_j=t then A_{i_t} must equal sgn_t. OFF pairs are tautologies. This is exactly the clause-satisfaction condition \u201c\u2203t with A_{i_t}=sgn_t.\u201d Hence f exists iff there is {A_i},{T_j} satisfying \u2227_j \u2228_{t=1}^3 (A_{i_t}=sgn_t), i.e., \u03a6C is satisfiable.\n- How it can fail: If some \u03c4Cl(j) could choose an O_t that is not one of its occurrences (e.g., unverified (i_t,sgn_t)), the constraint could be cheated. We prevent this by the clause-run tableau and local checker exposing (i_t,sgn_t) and rejecting any Ot whose occurrence record is malformed.\n- Quick test: B=2 example with 4 variables. Let clause j encode (x1 \u2228 \u00acx2 \u2228 x3). If \u03b1(x1)=0, \u03b1(x2)=1, \u03b1(x3)=0, the only working choice is T_j=2 (select occurrence 2: \u00acx2). The only ON-pair is with \u03c4Var(2) and requires VF at left; holds. Other pairs OFF.\n\n4) Active type coverage and type separation\nClaim J (Coverage and separation of active types). With \u03b2=poly(s), choose B=s^c0 and \u2113pump=2^{\u0398(\u03b2^4)}. Using window-anchored blocks, for each i and each j there exist context types \u03c4Var(i) (left context whose wb contains a valid variable block with RID=i) and \u03c4Cl(j) (right context whose wc contains a valid clause block with GID=j and tableau exposing its 3 occurrences). Moreover, \u03c4Var(i)\u2260\u03c4Var(i\u2032) for i\u2260i\u2032, and \u03c4Cl(j)\u2260\u03c4Cl(j\u2032) for j\u2260j\u2032.\n- Why useful here: We need 2^B many distinct variable-types and 2^B many distinct clause-types so that {A_i} and {T_j} are well-defined choices over C.\n- How it can fail: (i) If the header+indices+RUN footprint exceeded the window length, activation wouldn\u2019t be local (fix: windows are size \u2113pump with \u2113pump\u226bpoly(s)); (ii) If types collapsed despite different RIDs/GIDs (fix: separation by boundary-extendibility: pick a partner type so that an ON-bridge exists for one index but is impossible for the other, hence their boundary-extendibility signatures differ).\n- Quick test (type-separation witness): Fix j and pick Ot selecting its first occurrence i1; Build the ordered pair (\u03c4Var(i1),\u03c4Cl(j)). The ON-bridge can succeed if VT=sgn1; For i\u2032\u2260i1, the gate is OFF and we can enforce a different outcome by forcing non-\u22a5 on the variable side with a mismatching token that is locally rejected; the sets of boundary-extendible labelings differ, so the types differ.\n\n5) Clause-verification tableau and radius-1 implementation\nClaim K (Poly(s)-length, radius-1 verification inside wc/wb). The clause-side block encodes in RUN a radius-1 checkable tableau of length poly(s) that, given (C,GID=j), exposes in fixed rows: (i1,sgn1),(i2,sgn2),(i3,sgn3) in one-hot form next to the S-neighborhood. The variable-side block exposes HotRID in one-hot. Cout\u2013out enforces stepwise consistency; malformed encodings admit a short error-chain refuter; well-formed ones cannot be refuted.\n- Why useful here: Ensures Ot actually corresponds to a validated occurrence and exposes sgnt locally, making the ON conduit comparison well-defined and radius-1 checkable.\n- How it can fail: If the verifier were O(1)-time, it could not validate the succinct circuit\u2019s output; we instead unroll a poly(s)-length tableau (still radius-1, constant alphabet overhead). If errors were non-refutable, inactive contexts could force constraints; the error-chain gadget prevents that.\n- Quick test: For a hand-built clause-index j, create a tiny RUN with 3 marked rows carrying the one-hot i_t and sgnt bits at fixed offsets. Flip one bit and confirm that an error-chain can be placed locally and that any non-\u22a5 S-choice against a malformed block is rejected by the DP.\n\n6) Inactive contexts are harmless; (F2) trivialization\nClaim L (Inactive contexts force \u22a5; (F2) is made vacuous). If a context\u2019s wb (resp. wc) lacks a well-formed variable (resp. clause) block, any non-\u22a5 at S is locally rejected (witness chain cannot find headers/indices). A dedicated PAD/\u22a5-plumbing language in Cout\u2013out allows arbitrary filling when OFF or \u22a5 at S. If we further allow wz repeats to be \u22a5-fillable regardless of z, (F2) holds for any f, and the classification collapses to O(1) iff (F1) feasible, else \u0398(n) by the gap theorem.\n- Why useful here: Neutralizes irrelevant pairs and reduces the tri-class decision to (F1) on our instances.\n- How it can fail: If PAD/\u22a5 seams were incompatible with S choices, OFF wouldn\u2019t be trivially fillable; we explicitly include seam-compatible PAD/\u22a5 pairs in Cout\u2013out.\n- Quick test: Take an inactive left context and any right context. Try S=VT; the DP fails early (no HEAD/RID found). Set S=\u22a5; the DP runs a PAD/\u22a5 conduit and succeeds.\n\n7) Putting it together: reduction to implicit SAT (Succinct-3SAT \u2192 F(P))\n- Source: circuit C of size s defining \u03a6C with 2^B variables and 2^B clauses, each clause(j) has three occurrences (i1,sgn1),(i2,sgn2),(i3,sgn3).\n- Target: PC with \u03a3out and Cout\u2013out implementing Claims H\u2013L; \u03b2=poly(s), r=1, |description|=poly(\u03b2)=poly(s). By Claim J, C\u2019s type set contains all \u03c4Var(i) and \u03c4Cl(j). By Claim I, there exists f satisfying (F1) for PC iff \u03a6C is satisfiable. By Claim L, we can trivialize (F2) if we target full classification hardness.\n- Complexity: Types count \u2113pump=2^{\u0398(\u03b2^4)}=2^{poly(s)}; we never enumerate them in the reduction. Verification of each bridge is via O(k\u03b2^2) DP (k=\u0398(\u2113pump)), consistent with the NEXPTIME upper bound.\n\n8) Toy worked example (B=2, indices 00..11)\n- Let clause j encode (x01 \u2228 \u00acx10 \u2228 x11). Suppose \u03b1(x01)=0, \u03b1(x10)=1, \u03b1(x11)=0.\n- Choices: set f(\u03c4Var(01))=VF, f(\u03c4Var(10))=VT, f(\u03c4Var(11))=VF. Set f(\u03c4Cl(j))=O2 (choose occurrence 2: \u00acx10). For ordered pairs: (\u03c4Var(10),\u03c4Cl(j)) ON and requires VT= (sgn2=\u2212)? No, ON demands VF when sgnt=\u2212. Oops: we must require VT iff sgnt=+ and VF iff sgnt=\u2212; thus for occurrence 2 (negative), left must be VF to pass. Since \u03b1(x10)=1, O2 would fail. Correct choice is O1 or O3? O1 has sgn1=+, requires VT at Var(01), but \u03b1(x01)=0, so fail. O3 has sgn3=+, requires VT at Var(11), but \u03b1(x11)=0, so fail. Therefore, \u03b1 does not satisfy this clause; no O_t makes the ON-pair succeed, as intended. If we flip \u03b1(x10)=0, then O2 makes (\u03c4Var(10),\u03c4Cl(j)) succeed and all other pairs OFF; (F1) holds for this j.\n- Takeaway: For each clause j, there exists exactly those Ot consistent with \u03b1 that make all pairs pass; otherwise (F1) fails.\n\n9) Open items and quantitative checks\n- Boundary tables: Write explicit Cin\u2013out/Cout\u2013out rows for S-seams enforcing: (i) non-\u22a5 at S emits Offer tokens and forbids PAD unless OFF, (ii) OFF\u21d4mismatch of (RID,it), (iii) ON enforces CAP wire equality truth\u2194sgn_t, (iv) PAD/\u22a5 seams accept any colors when OFF.\n- Clause RUN tiles: Provide a fixed set of row-local tiles producing/exposing (i_t,sgn_t) and validating them against header C and GID=j, with a bounded error alphabet E to refute any malformed run.\n- Type separation proof: Formally exhibit, for i\u2260i\u2032, some counterpart type so that the sets of extendible boundary assignments differ (hence distinct types). Likewise for clauses.\n- Rule budgets: Count tracks/symbols to confirm |\u03a3out|=\u03b2=poly(s). \u2113pump\u226bpoly(s) so that windows can host headers+indices+RUN comfortably.\n\nHow this answers \u201creduce to implicit exponential-sized SAT formula\u201d\n- The existence of a feasible f is equivalent to satisfiability of the implicit SAT F(P): variables are (A_i) and (T_j), constraints are local bridge constraints per (\u03c4Var(i),\u03c4Cl(j)), exponentially many but specified implicitly by P (via DP over \u2113pump-length contexts). Our reduction from C maps \u03a6C to F(PC) with the property F(PC) satisfiable iff \u03a6C satisfiable. This yields NEXPTIME-hardness of feasible-function existence, and (by trivializing (F2)) the full O(1) vs \u0398(n) classification.\n",
  "requests_for_more_materials": [
    "Confirm we may allocate 5 distinct S-tokens (VT,VF,O1,O2,O3) within \u03a3out; \u03b2=poly(s) so this is fine, but we will size the palette explicitly.",
    "Provide any preference on the universal machine U and the clause-decoder format (truth-table vs direct index computation) so we can pin down the exact RUN tiles."
  ],
  "next_actions_for_prover": [
    "Write explicit Cin\u2013out/Cout\u2013out tables for the 4-node neighborhoods around S on both sides implementing Patch H (OFF/ON, PAD/\u22a5 plumbing, CAP wire).",
    "Specify the clause-verification tableau: tracks, phases, row transitions, and the error-chain alphabet; prove radius-1 local checkability and poly(s) footprint.",
    "Prove the Type Separation Lemma formally: construct a fixed counterpart type that distinguishes \u03c4Var(i) from \u03c4Var(i\u2032), and \u03c4Cl(j) from \u03c4Cl(j\u2032), via boundary-extendibility signatures.",
    "Build a complete B=2 worked example: enumerate all 12 (\u03c4Var(i),\u03c4Cl(j)) pairs, tabulate ON/OFF and DP outcomes under sample assignments \u03b1; verify that (F1) holds iff \u03b1 satisfies all clauses.",
    "Finalize the (F2) trivialization by listing Cout\u2013out seam rules that make repeats wz universally \u22a5-fillable regardless of z."
  ]
}