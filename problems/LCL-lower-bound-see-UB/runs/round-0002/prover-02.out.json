{
  "progress_md": "Status. We have a solid upper-bound skeleton (types, composition, periodicity, finite-Z for (F2), and the O(k\u03b2^2) DP) captured in output.md. To push hardness to NEXPTIME for the 3-way classifier, I focus on formalizing the succinct 3-coloring reduction via (F1), with two key technical lemmas: (i) type-separation per vertex index u using a boundary-probe truth-table signature realized by a radius-1 checker; (ii) a seam gadget that, on colored S-windows, locally simulates D(u,v) (adjacency) across the bridge, accepting iff either non-edge or colors differ. I also point out a minor optional tightening in output.md and confirm its current statements are correct as written.\n\nGaps/remarks on output.md (minor). \n- The \u2113^2 bound in Corollary 4 is correct and sufficient; optionally, one can refine Z to preperiod1 + preperiod2 + lcm(period1, period2) \u2264 2\u2113 + \u2113 \u2264 3\u2113 (or \u2264 lcm periods) by analyzing the pair map on T\u00d7T, but this is nonessential. The current deterministic DP lemma (Theorem 5) is correct; an explicit treatment of boundary inputs when k<4 is trivial and can be omitted. No correctness issues spotted.\n\nPlan and why useful. \n- Pivot source to Succinct 3-Coloring (NEXP-complete). For a circuit D of size s deciding adjacency on V={0,1}^B (B=s^{c0}), we construct a \u03b2-normalized, r=1 LCL P_D with \u03b2=s^{c1} (c1\u226bc0) so that: existence of a feasible function (F1) \u21d4 G is 3-colorable. This matches (F1)\u2019s universal quantification (pairwise inequality on edges) and avoids clause-level \u2203-quantifiers.\n\nCore technical ingredients (new lemmas, concrete gadgets).\n\nLemma A (Type-separation via boundary-probe signature). Fix integers B=s^{c0} and \u03b2=s^{c1} with 4c1>c0. There exists a radius-1 \u03b2-normalized LCL fragment that enforces: for any path segment W that contains a well-formed vertex block encoding an index u\u2208{0,1}^B (and no errors), the type Type(W) has extendibility truth-table over the \u03b2^4 boundary-output assignments equal to an injective signature g(u)\u2208{0,1}^{\u03b2^4}. In particular, u\u2260u\u2032 \u21d2 Type(W)\u2260Type(W\u2032).\n- Construction sketch (radius-1):\n  \u2022 Reserve in \u03a3_out constant tracks: role/phase, error alphabet, a \u22a5-plumbing symbol, and a RUN track for a fixed universal TM U. The vertex block stores u in a self-delimiting header and includes a short RUN zone computing on demand bits of an injective signature g(u) of length L=\u03b2^4\u22652^B (we can set g(u) to the length-L zero-padded copy of u followed by a fixed injective encoding). The run budget is poly(s).\n  \u2022 Boundary-probe coding: Each of the four boundary outputs carries an index digit in base \u03b2; together they encode b\u2208[\u03b2^4] (the probe index). Adjacency rules copy these 4 base-\u03b2 digits along \u201ccarrier\u201d subtracks deterministically from both ends toward the interior (radius-1 constraints enforcing equality along edges). If the two ends encode different b, a detector in the middle halts with an unsatisfiable local pattern \u21d2 that boundary assignment is rejected (truth-table bit 0). If they match, the bridge enables U to read (u,b) from the interior/carriers and compute g(u)[b] in poly(s) steps within W. Local acceptance (extendibility) is permitted iff g(u)[b]=1 (otherwise the RUN must end in a dead configuration). Malformed interiors open an error-chain (always extendible) and are hence excluded when defining vertex types.\n- Why useful: It produces \u22652^B distinct types attributable to different u while using only \u03b2 symbols and radius 1; f can then assign colors per vertex-type \u03c4_u.\n\nLemma B (Realization of vertex context types near S). For each u, there exist contexts (w_1,S,w_2) with |w_i|\u2208{\u2113_pump,\u2113_pump+1} whose left (or right) side contains a well-formed vertex block for u adjacent (within O(1)) to S, and whose type equals the Type(W) from Lemma A. Moreover, replacement/pumping (Lemmas 11, 14\u201315) ensure that these contexts persist under padding to the required lengths.\n- Why useful: Guarantees the context set C contains, for each u, at least one \u201cvertex\u201d type \u03c4_u on which f can act.\n\nLemma C (Seam gadget for succinct adjacency and color inequality). There is a radius-1 out\u2013out grammar across the seam between a left \u03c4_u-context and a right \u03c4_v-context such that, when both S windows are colored, the bridge wa S_1 wb wc S_2 wd admits a completion iff either D(u,v)=0 (non-edge) or D(u,v)=1 and the two colors differ. If either side is not a vertex context (no valid block), the seam always completes (via \u22a5-plumbing or error chains) irrespective of S.\n- Construction sketch:\n  \u2022 Seam handshake: Near each S window, a constant-size \u201chandshake\u201d subtrack asserts role=VERTEX, and opens a bounded-width corridor through wb\u2218wc where a fixed TM U simulates D(u,v) for poly(s) steps using the copies of D from the interiors and seam pointers that fetch u (on the left) and v (on the right). As in \u00a73 of the attached paper, each tableau row is locally checked by Cout\u2013out; malformed runs are locally refutable (error-chain), keeping non-vertex contexts harmless.\n  \u2022 Acceptance policy: The corridor exposes a verdict bit Edge(u,v). The adjacency table then enforces: if Edge=0, accept regardless of colors; if Edge=1, require Color(S_1)\u2260Color(S_2) (three colors in a constant subalphabet). Violations force a dead pattern (no completion). All checks are radius-1 because comparisons are between adjacent row/phase symbols and the two S outputs.\n- Why useful: Encodes the exact pairwise 3-coloring constraint on edges within (F1)\u2019s universal pair quantification; non-edges/vacuous pairs always pass.\n\nLemma D (Bridging neutralization). Add \u22a5-repetition plumbing: for any context (w_1,S,w_2), all repetitions w_1^z and w_2^z can be filled entirely with \u22a5 while remaining compatible with any S outputs and the fixed boundary inputs. Then (F2) holds for every f.\n- Why useful: Collapses the three-class decision to (F1)-feasibility, transferring NEXP-hardness to the classifier (O(1) vs \u03a9(n) on our instances).\n\nSoundness/completeness outline for the reduction (auditable).\n- Parameters: Choose c1\u226bc0 so that \u03b2^4 = s^{4c1} \u2265 2B; then \u2113_pump = 2^{\u0398(\u03b2^4)} = 2^{poly(s)}. Block length is poly(s)\u226a\u2113_pump.\n- Cmpltns:\n  \u2022 If G is 3-colorable with \u03c7:V\u2192{R,G,B}, define f(\u03c4_u) = (\u03c7(u) on S) and f(\u03c4)=\u22a5 for non-vertex types. For any ordered pair (\u03c4_left, \u03c4_right), the seam gadget computes Edge(u,v); non-edges accept; edges accept iff \u03c7(u)\u2260\u03c7(v). Hence all (F1) checks pass. (F2) is vacuous by Lemma D.\n- Sndnss:\n  \u2022 If f satisfies (F1), read \u03c7(u)=f(\u03c4_u). Consider any edge (u,v). The pair (\u03c4_u, \u03c4_v) must pass the (F1) DP; by Lemma C, this forces \u03c7(u)\u2260\u03c7(v). Therefore \u03c7 is a proper 3-coloring.\n\nKey implementation details (to be checked next, but radius-1 and \u03b2=poly(s)).\n- Fixed tracks in \u03a3_out (constant multiplicity): role/phase states; three color tokens and \u22a5; RUN work alphabet of the fixed U; error-chain symbols. The total |\u03a3_out|=\u03b2 can be chosen polynomial in s to host these tracks.\n- Probe carriers: The four boundary positions provide base-\u03b2 digits (b_1,b_2,b_3,b_4) coding b\u2208[\u03b2^4]; per-edge Cout\u2013out permits copying these digits unchanged along special carrier tracks. A small synchronizer ensures two carriers meet and agree before the RUN consults b.\n- Robustness: Any malformed header/index/RUN admits a locally checkable error-chain (as in the LBA construction), so such contexts never constrain f; they can be mapped to \u22a5 by f.\n\nToy sanity checks.\n- Tiny \u03b2 example: Let \u03b2=3, reserve 3 colors+\u22a5 and minimal RUN symbols. With B=2 (four vertices), choose a trivial D; the seam accepts iff colors differ on the unique edge case. The probe signature g(u) can be just the 9-bit (\u03b2^4=81 in general; here smaller) table determined by U\u2019s response to the four boundary symbols; in the toy, let g(u) encode u across a few \u201cdistinguishing\u201d boundary assignments to see Type(W_u)\u2260Type(W_v) by direct DP.\n\nObstacles and mitigations.\n- Probe capacity vs. 2^B: We cannot dedicate a distinct boundary 4-tuple per u since \u03b2^4\u226a2^B; instead we use the full truth-table over \u03b2^4 probes, mapping u\u21a6g(u)\u2208{0,1}^{\u03b2^4} injectively (possible since \u03b2^4\u2265B). The grammar is uniform; dependence on u enters only via the interior-encoded u read by U.\n- Uniformity within types: Because the probe acceptance policy is fixed and depends only on (boundary 4-tuple, interior u), all representatives of the same type (i.e., same interior u and no errors) yield identical extendibility tables, satisfying type-invariance.\n- Ensuring active \u03c4_u exist: Use Lemma 11 (replacement) and Lemmas 14\u201315 (pumping) to embed the O(poly(s))-length block adjacent to S within words of length \u2113_pump or \u2113_pump+1 on each side, without changing the type.\n\nNext concrete steps (incremental, testable).\n1) Formalize Lemma A. Specify: (i) the base-\u03b2 boundary-digit carriers and their radius-1 propagation; (ii) the U-simulation that, given (u,b), outputs g(u)[b] and how Cout\u2013out enforces acceptance iff 1. Prove type-separation: u\u2260u\u2032 \u21d2 the truth tables differ in at least one b.\n2) Formalize Lemma C. Write the exact row interface and verdict wiring so that (Edge=0) \u21d2 unconditional acceptance, (Edge=1) \u21d2 require Color(S_1)\u2260Color(S_2). Include the local refutation for malformed runs.\n3) Prove Lemma B: a clean pumping/replacement embedding argument placing blocks within contexts of the required lengths while preserving type.\n4) Package the construction P_D and the equivalence \u201cG 3-colorable \u21d4 (F1)-feasible f exists,\u201d then add the \u22a5-repetition rules (Lemma D) to transfer hardness to the O(1)/\u03a9(n) classification.\n\nWhy this is progress.\n- It addresses the main unresolved pieces flagged by the verifier: a type-invariant \u201cactivity\u201d mechanism and a pairwise constraint that matches (F1). The boundary-probe signature provides exponentially many distinct types with \u03b2=poly(s) and radius-1 rules; the seam gadget exactly encodes edge constraints suitable for (F1). These are compact, checkable subclaims that can be verified independently using the O(k\u03b2^2) DP.\n"
}