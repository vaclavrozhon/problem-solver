{"progress_md":"Status. We have a solid upper-bound skeleton (types, composition, periodicity, finite-Z for (F2), and the O(kβ^2) DP) captured in output.md. To push hardness to NEXPTIME for the 3-way classifier, I focus on formalizing the succinct 3-coloring reduction via (F1), with two key technical lemmas: (i) type-separation per vertex index u using a boundary-probe truth-table signature realized by a radius-1 checker; (ii) a seam gadget that, on colored S-windows, locally simulates D(u,v) (adjacency) across the bridge, accepting iff either non-edge or colors differ. I also point out a minor optional tightening in output.md and confirm its current statements are correct as written.\n\nGaps/remarks on output.md (minor). \n- The ℓ^2 bound in Corollary 4 is correct and sufficient; optionally, one can refine Z to preperiod1 + preperiod2 + lcm(period1, period2) ≤ 2ℓ + ℓ ≤ 3ℓ (or ≤ lcm periods) by analyzing the pair map on T×T, but this is nonessential. The current deterministic DP lemma (Theorem 5) is correct; an explicit treatment of boundary inputs when k<4 is trivial and can be omitted. No correctness issues spotted.\n\nPlan and why useful. \n- Pivot source to Succinct 3-Coloring (NEXP-complete). For a circuit D of size s deciding adjacency on V={0,1}^B (B=s^{c0}), we construct a β-normalized, r=1 LCL P_D with β=s^{c1} (c1≫c0) so that: existence of a feasible function (F1) ⇔ G is 3-colorable. This matches (F1)’s universal quantification (pairwise inequality on edges) and avoids clause-level ∃-quantifiers.\n\nCore technical ingredients (new lemmas, concrete gadgets).\n\nLemma A (Type-separation via boundary-probe signature). Fix integers B=s^{c0} and β=s^{c1} with 4c1>c0. There exists a radius-1 β-normalized LCL fragment that enforces: for any path segment W that contains a well-formed vertex block encoding an index u∈{0,1}^B (and no errors), the type Type(W) has extendibility truth-table over the β^4 boundary-output assignments equal to an injective signature g(u)∈{0,1}^{β^4}. In particular, u≠u′ ⇒ Type(W)≠Type(W′).\n- Construction sketch (radius-1):\n  • Reserve in Σ_out constant tracks: role/phase, error alphabet, a ⊥-plumbing symbol, and a RUN track for a fixed universal TM U. The vertex block stores u in a self-delimiting header and includes a short RUN zone computing on demand bits of an injective signature g(u) of length L=β^4≥2^B (we can set g(u) to the length-L zero-padded copy of u followed by a fixed injective encoding). The run budget is poly(s).\n  • Boundary-probe coding: Each of the four boundary outputs carries an index digit in base β; together they encode b∈[β^4] (the probe index). Adjacency rules copy these 4 base-β digits along “carrier” subtracks deterministically from both ends toward the interior (radius-1 constraints enforcing equality along edges). If the two ends encode different b, a detector in the middle halts with an unsatisfiable local pattern ⇒ that boundary assignment is rejected (truth-table bit 0). If they match, the bridge enables U to read (u,b) from the interior/carriers and compute g(u)[b] in poly(s) steps within W. Local acceptance (extendibility) is permitted iff g(u)[b]=1 (otherwise the RUN must end in a dead configuration). Malformed interiors open an error-chain (always extendible) and are hence excluded when defining vertex types.\n- Why useful: It produces ≥2^B distinct types attributable to different u while using only β symbols and radius 1; f can then assign colors per vertex-type τ_u.\n\nLemma B (Realization of vertex context types near S). For each u, there exist contexts (w_1,S,w_2) with |w_i|∈{ℓ_pump,ℓ_pump+1} whose left (or right) side contains a well-formed vertex block for u adjacent (within O(1)) to S, and whose type equals the Type(W) from Lemma A. Moreover, replacement/pumping (Lemmas 11, 14–15) ensure that these contexts persist under padding to the required lengths.\n- Why useful: Guarantees the context set C contains, for each u, at least one “vertex” type τ_u on which f can act.\n\nLemma C (Seam gadget for succinct adjacency and color inequality). There is a radius-1 out–out grammar across the seam between a left τ_u-context and a right τ_v-context such that, when both S windows are colored, the bridge wa S_1 wb wc S_2 wd admits a completion iff either D(u,v)=0 (non-edge) or D(u,v)=1 and the two colors differ. If either side is not a vertex context (no valid block), the seam always completes (via ⊥-plumbing or error chains) irrespective of S.\n- Construction sketch:\n  • Seam handshake: Near each S window, a constant-size “handshake” subtrack asserts role=VERTEX, and opens a bounded-width corridor through wb∘wc where a fixed TM U simulates D(u,v) for poly(s) steps using the copies of D from the interiors and seam pointers that fetch u (on the left) and v (on the right). As in §3 of the attached paper, each tableau row is locally checked by Cout–out; malformed runs are locally refutable (error-chain), keeping non-vertex contexts harmless.\n  • Acceptance policy: The corridor exposes a verdict bit Edge(u,v). The adjacency table then enforces: if Edge=0, accept regardless of colors; if Edge=1, require Color(S_1)≠Color(S_2) (three colors in a constant subalphabet). Violations force a dead pattern (no completion). All checks are radius-1 because comparisons are between adjacent row/phase symbols and the two S outputs.\n- Why useful: Encodes the exact pairwise 3-coloring constraint on edges within (F1)’s universal pair quantification; non-edges/vacuous pairs always pass.\n\nLemma D (Bridging neutralization). Add ⊥-repetition plumbing: for any context (w_1,S,w_2), all repetitions w_1^z and w_2^z can be filled entirely with ⊥ while remaining compatible with any S outputs and the fixed boundary inputs. Then (F2) holds for every f.\n- Why useful: Collapses the three-class decision to (F1)-feasibility, transferring NEXP-hardness to the classifier (O(1) vs Ω(n) on our instances).\n\nSoundness/completeness outline for the reduction (auditable).\n- Parameters: Choose c1≫c0 so that β^4 = s^{4c1} ≥ 2B; then ℓ_pump = 2^{Θ(β^4)} = 2^{poly(s)}. Block length is poly(s)≪ℓ_pump.\n- Cmpltns:\n  • If G is 3-colorable with χ:V→{R,G,B}, define f(τ_u) = (χ(u) on S) and f(τ)=⊥ for non-vertex types. For any ordered pair (τ_left, τ_right), the seam gadget computes Edge(u,v); non-edges accept; edges accept iff χ(u)≠χ(v). Hence all (F1) checks pass. (F2) is vacuous by Lemma D.\n- Sndnss:\n  • If f satisfies (F1), read χ(u)=f(τ_u). Consider any edge (u,v). The pair (τ_u, τ_v) must pass the (F1) DP; by Lemma C, this forces χ(u)≠χ(v). Therefore χ is a proper 3-coloring.\n\nKey implementation details (to be checked next, but radius-1 and β=poly(s)).\n- Fixed tracks in Σ_out (constant multiplicity): role/phase states; three color tokens and ⊥; RUN work alphabet of the fixed U; error-chain symbols. The total |Σ_out|=β can be chosen polynomial in s to host these tracks.\n- Probe carriers: The four boundary positions provide base-β digits (b_1,b_2,b_3,b_4) coding b∈[β^4]; per-edge Cout–out permits copying these digits unchanged along special carrier tracks. A small synchronizer ensures two carriers meet and agree before the RUN consults b.\n- Robustness: Any malformed header/index/RUN admits a locally checkable error-chain (as in the LBA construction), so such contexts never constrain f; they can be mapped to ⊥ by f.\n\nToy sanity checks.\n- Tiny β example: Let β=3, reserve 3 colors+⊥ and minimal RUN symbols. With B=2 (four vertices), choose a trivial D; the seam accepts iff colors differ on the unique edge case. The probe signature g(u) can be just the 9-bit (β^4=81 in general; here smaller) table determined by U’s response to the four boundary symbols; in the toy, let g(u) encode u across a few “distinguishing” boundary assignments to see Type(W_u)≠Type(W_v) by direct DP.\n\nObstacles and mitigations.\n- Probe capacity vs. 2^B: We cannot dedicate a distinct boundary 4-tuple per u since β^4≪2^B; instead we use the full truth-table over β^4 probes, mapping u↦g(u)∈{0,1}^{β^4} injectively (possible since β^4≥B). The grammar is uniform; dependence on u enters only via the interior-encoded u read by U.\n- Uniformity within types: Because the probe acceptance policy is fixed and depends only on (boundary 4-tuple, interior u), all representatives of the same type (i.e., same interior u and no errors) yield identical extendibility tables, satisfying type-invariance.\n- Ensuring active τ_u exist: Use Lemma 11 (replacement) and Lemmas 14–15 (pumping) to embed the O(poly(s))-length block adjacent to S within words of length ℓ_pump or ℓ_pump+1 on each side, without changing the type.\n\nNext concrete steps (incremental, testable).\n1) Formalize Lemma A. Specify: (i) the base-β boundary-digit carriers and their radius-1 propagation; (ii) the U-simulation that, given (u,b), outputs g(u)[b] and how Cout–out enforces acceptance iff 1. Prove type-separation: u≠u′ ⇒ the truth tables differ in at least one b.\n2) Formalize Lemma C. Write the exact row interface and verdict wiring so that (Edge=0) ⇒ unconditional acceptance, (Edge=1) ⇒ require Color(S_1)≠Color(S_2). Include the local refutation for malformed runs.\n3) Prove Lemma B: a clean pumping/replacement embedding argument placing blocks within contexts of the required lengths while preserving type.\n4) Package the construction P_D and the equivalence “G 3-colorable ⇔ (F1)-feasible f exists,” then add the ⊥-repetition rules (Lemma D) to transfer hardness to the O(1)/Ω(n) classification.\n\nWhy this is progress.\n- It addresses the main unresolved pieces flagged by the verifier: a type-invariant “activity” mechanism and a pairwise constraint that matches (F1). The boundary-probe signature provides exponentially many distinct types with β=poly(s) and radius-1 rules; the seam gadget exactly encodes edge constraints suitable for (F1). These are compact, checkable subclaims that can be verified independently using the O(kβ^2) DP.\n"}