{
  "progress_md": "Ideas \u2014 pivot formalization via succinct 3-coloring and type separation\n- Goal of this round: Make the NEXPTIME-hardness route auditable by (i) aligning (F1) semantics with a pairwise constraint problem (succinct 3-coloring), and (ii) pinning down a concrete, radius-1 mechanism that guarantees exponentially many distinct context types (one per vertex u \u2208 {0,1}^B) even though f is defined on types (not concrete words). We state small lemmas with proof sketches and bookkeeping, and we flag minor clarifications for output.md.\n\nClaim A (3-coloring matches (F1)). Why useful here: It resolves the quantifier mismatch that plagued 3SAT-style reductions; (F1) enforces universal pairwise constraints, exactly color(u) \u2260 color(v) for edges.\n- Source: Succinct 3-Coloring instance D: {0,1}^{2B} \u2192 {0,1}, circuit of size s; vertices V = {0,1}^B.\n- Target semantics (mid-consistency (F1) only): Context types corresponding to vertices \u03c4_u on both sides; the (F1) bridge between (\u03c4_u, \u03c4_v) must succeed (extend) iff either (i) D(u,v)=0 (non-edge; vacuous) or (ii) D(u,v)=1 and f(\u03c4_u) \u2260 f(\u03c4_v).\n- Implementation sketch: When S is colored, the bridge launches a row-by-row, radius-1-checked U-simulation on input (D,u,v) embedded in the inputs near the seam. Local rules guarantee: if D(u,v)=1 and colors equal, the bridge dead-ends; otherwise the bridge always extends. All other role pairings and inactive contexts allow trivial completions (\u22a5-plumbing). This aligns (F1) with 3-colorability.\n\nClaim B (Type separation via boundary test family; B.1). Why useful here: Ensures at least 2^B distinct context types \u03c4_u exist, allowing f to encode a color per vertex.\n- Parameters: Choose integers B = s^{c0}, \u03b2 = s^{c1} with 1 \u226a c0 \u226a c1 so that \u03b2 \u2265 B and \u2113_pump = 2^{\u0398(\u03b2^4)} = 2^{poly(s)}.\n- Reserved test boundary assignments: Fix one boundary-input 4-tuple a\u22c6. Reserve a collection J of size M := \u03b2 distinct boundary-output 4-tuples {b_t : t \u2208 [M]}; choosing b_t means \u201cactivate test id t\u201d. All other boundary outputs are filler. This uses only O(\u03b2) reserved symbols (poly(s)).\n- Input layout inside \u03c4_u: The input track near the left end contains (i) a mask table row M_t \u2208 {0,1}^B for each t \u2208 [M] (packed contiguously and self-delimited), and (ii) a vertex-index block RID(u) \u2208 {0,1}^B stored once in a fixed phase near S. The right end is symmetric or carries only fillers (not used for separation). We require well-formedness by radius-1 local rules; malformed encodings are locally refutable by error chains (as in \u00a73 of the reference), hence \u201cinactive.\u201d\n- Local test protocol: Under the boundary assignment (a\u22c6, b_t), the out\u2013out rules enable a pointer that (1) walks from the left boundary to read the t-th mask row M_t, (2) walks to the RID block, and (3) computes parity \u27e8M_t, u\u27e9 mod 2 using a fixed U-simulation in O(B) steps, all radius-1 checkable. If parity = 1, the pointer can terminate in an accepting sink; if parity = 0, no accepting continuation exists (the DP gets stuck). For all other boundary-output assignments (non-reserved), we permit a trivial completion (\u22a5 buffers) so they don\u2019t affect separation.\n- Linear independence: Pick M \u2265 B masks whose rows form a full-rank B\u00d7M matrix over GF(2); since M=\u03b2 \u2265B, this is possible. Then the signature map Sig(u) := (\u27e8M_t,u\u27e9)_{t\u2208[M]} \u2208 {0,1}^M is injective on {0,1}^B. For the fixed boundary-input a\u22c6, the extendibility table for reserved outputs is exactly E_{w(u)}(a\u22c6)[b_t] = Sig(u)_t. Consequently, u \u2260 u\u2032 \u21d2 Type(w(u)) \u2260 Type(w(u\u2032)).\n- Radius/size: The checker is constant-radius (pointers and row-to-row tableau), uses a constant work alphabet, with \u03b2 = poly(s) large enough to host reserved symbols. The mask table sits in the input (binary) and is read by the pointer; malformed tables are harmless due to error chains.\n\nClaim C (Realization of exponentially many vertex context types; B.2). Why useful here: Guarantees that, among contexts w_1 S w_2 with |w_i| \u2208 {\u2113_pump, \u2113_pump+1}, there are at least 2^B distinct types representing all vertices u.\n- Using Claim B, fix for each u an input string W(u) that realizes the left block (table + RID(u)), a neutral S, and a right filler block; ensure via pumping (Lemma 14/15) that both sides have length \u2113_pump or \u2113_pump+1 and that replacement preserves type (Lemma 11). Then Type(W(u)) are all distinct and populate C (the context-type domain for f). The same construction symmetrically realizes right-side vertex contexts \u03c4_v.\n\nClaim D (Bridge gating for succinct adjacency; B.3). Why useful here: Implements the pairwise constraint \u201cif edge then colors differ, else vacuous\u201d under (F1).\n- Input near both sides supplies (i) a copy of D\u2019s encoding (as in the LBA proof, stored in binary and copied by outputs), (ii) the local RID blocks (u and v). Upon non-\u22a5 colors at S, the bridge runs U on input (D,u,v) for poly(s) steps; rules enforce success as follows:\n  \u2022 If the simulation yields D(u,v)=0 (non-edge), accept irrespective of colors by enabling a trivial acceptor after the run.\n  \u2022 If D(u,v)=1 (edge), accept iff two color tokens at S are different; if equal, dead-end. The \u201ccolor-different\u201d test is purely local across the S seam.\n- Robustness: Inactive/malformed blocks admit the standard error chains; colored S then cannot complete and hence forces f to map such types to \u22a5.\n\nClaim E (From (F1) to classification hardness; B.4). Why useful here: Transfers hardness from (F1)-feasibility to the 3-way decision by neutralizing (F2).\n- Add a global \u22a5-filler language for repetitions so that for any context (w_1,S,w_2) and any z\u22651, w_1^z and w_2^z can be labeled with \u22a5 (independent of inputs). Thus (F2) holds vacuously for any f. Therefore, deciding whether (F1) holds (i.e., whether G is 3-colorable) is as hard as the 3-way classification on our instances.\n\nProof sketches for soundness/completeness (FFE(F1) \u2194 3-coloring)\n- Completeness: Given a proper 3-coloring \u03c7: V \u2192 {RED,GRN,BLU}, define f(\u03c4_u)=\u03c7(u). For any pair (\u03c4_u,\u03c4_v), the bridge computes D(u,v); if non-edge it accepts; if edge, \u03c7(u)\u2260\u03c7(v) by proper coloring, so acceptance follows. Inactive contexts mapped to \u22a5 are trivially satisfied.\n- Soundness: If f satisfies (F1), define \u03c7(u)=f(\u03c4_u). For any edge (u,v), (F1) requires that the bridge succeeds; the only way it can succeed on edges is with \u03c7(u)\u2260\u03c7(v). Hence \u03c7 is a proper 3-coloring.\n\nInstantiation details to verify next (concrete, checkable)\n1) Pointer/test gadget (radius-1): Specify the constant-size out\u2013out automaton for the test: states \u201cgo-to-row t\u201d, \u201cscan mask bits\u201d, \u201caccumulate parity\u201d, \u201cjump to RID\u201d, \u201caccumulate parity\u201d, \u201caccept if 1\u201d; verify all transitions read-only from input and are nearest-neighbor.\n2) Mask addressing with small boundary ID: Limit test IDs t to [\u03b2], each encoded by one of \u03b2 reserved symbols. In input, arrange the mask table as \u03b2 rows of length B with clear row delimiters; the \u201cgo-to-row t\u201d stage follows row delimiters counted via the ID implicit in the chosen boundary symbol. Local rules ensure the pointer\u2019s row-counter matches the selected symbol; wrong row \u21d2 dead-end (so the DP cannot cheat by reading a different row).\n3) Existence of contexts of length \u2113_pump: Use pumping/replacement to pad left/right to prescribed lengths without changing types, ensuring that (i) the reserved boundary tests remain available at the outermost two boundary nodes, and (ii) the interior test and RID regions remain intact.\n4) Bridge TM: Use the same row-by-row U-simulation as in \u00a73 to evaluate D(u,v) in poly(s) time. Errors are locally refutable; malformed inputs cannot permit a colored-S completion, making such contexts inactive.\n5) Size bookkeeping: \u03a3_out tracks: roles/phases, 3 colors + \u22a5, error alphabet, and U\u2019s work alphabet are constant; plus \u03b2 many reserved test symbols and a constant amount of plumbing. Tables Cin\u2013out, Cout\u2013out remain size poly(\u03b2)=poly(s). Input length is unbounded and holds the mask table, RID blocks, and circuit D wherever needed.\n\nToy example (sanity)\n- Take B=2, \u03b2=8, masks M_t \u2208 {00,01,10,11,01,10,11,00} (first 4 rows linearly independent). For u\u2208{00,01,10,11}, the reserved boundary outputs b_t induce an extendibility pattern equal to the parity vector across the first 4 tests; the four \u03c4_u types differ on these 4 bits. On the bridge, if D is a 4-cycle adjacency, f(\u03c4_u) = u mod 3 gives a valid coloring; pairs on edges with equal colors are forbidden locally.\n\nNotes/obstacles\n- Mask-table on input vs. grammar size: We deliberately read mask rows from input to avoid hardwiring O(\u03b2\u00b7B) bits into Cout\u2013out; only the per-test control (\u03b2 distinct boundary tokens) are baked into Cout\u2013out.\n- Dependence only on type: The separation relies on fixed boundary-input a\u22c6 and the reserved family {b_t}. For any two words with the same input content (table + RID) but otherwise different interiors, the existence or non-existence of a completion under (a\u22c6, b_t) is forced by the local test, hence is type-invariant. Distinct u\u2019s yield distinct yes/no pattern across {b_t}, so types differ.\n- Ensuring non-edges are vacuous: The bridge must accept for D(u,v)=0 irrespective of colors. We implement this by enabling a finishing acceptor after the U-run concludes \u201c0\u201d, independent of S\u2019s colors.\n\nMinor clarifications/suggestions for output.md\n- Types and fixed inputs: In \u201cDefinitions (radius 1)\u201d, clarify that E_w(a) is with respect to the fixed input string on the entire path; the parenthetical \u201cinterior inputs may be arbitrary\u201d could be read as allowing the verifier to choose internal inputs. For our model, the input word is fixed; the extension existentially quantifies outputs only.\n- Context set C size: Where LCL_classification.pdf states \u201cNote |C| \u2264 \u2113_pump,\u201d consider adding a short justification: a context type is a specific element of the global type set T realized by a word of the form w_1 S w_2 with |w_i| \u2208 {\u2113_pump,\u2113_pump+1}; hence |C| \u2264 |T| = \u2113_pump.\n\nNext steps\n- Write the explicit local rule set for the boundary test gadget and prove the Type-Separation Lemma rigorously (injectivity from M\u2265B linearly independent masks).\n- Specify the seam U-simulation interface and the local rule that gates acceptance by \u201cD(u,v)=0 or colors differ.\u201d\n- Package the reduction formally: map D \u21a6 P_D with \u03b2=poly(s), prove \u201cG 3-colorable \u21d4 (F1)-feasible f exists\u201d, and add the \u22a5 repetition to neutralize (F2). This will give a clean NEXPTIME-hardness statement for the 3-way classification.\n"
}