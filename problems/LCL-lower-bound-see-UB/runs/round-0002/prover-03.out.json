{
  "progress_md": "## Round 0002 \u2014 2025-08-27T11:23:07.548697Z\n\nMini-plan\n- Formalize an implicit exponential-sized SAT encoding F(L) whose satisfiability is equivalent to the existence of a feasible function f for a given \u03b2-normalized, radius-1 LCL instance L on oriented paths. This cleanly connects (F1) and (F2) to a succinct-SAT instance.\n- Specialize the encoding to our reduction family PC (from a succinct 3CNF generator C), using window-anchored active blocks and a gated bridge. Show that F(PC) is essentially the succinct 3SAT instance for C with auxiliary \u201cliteral-pick\u201d variables Y.\n- State and test three core lemmas: (i) succinct SAT capture of (F1) and (F2) with an explicit 2poly(\u03b2) bound, (ii) ON/OFF gate \u21d2 CNF constraints of the form (\u00acY \u2228 X), and (iii) type-separation by boundary-extendibility patterns induced by interior witness behavior (no reliance on 2-node boundaries).\n- Patch the previously flagged fragilities: ensure OFF for all unintended pairs (use offer/cap tokens), and move clause-decoding to a poly(s)-length, radius-1 tableau with error-chain refutations.\n- Work out a small B=2 toy to validate the SAT constraints and counterexample probes; list next instrumentation (explicit Cin\u2013out/Cout\u2013out tables for the window seam, offers, PAD/CAP conduits, and the tableau seam rules).\n\n1) Encoding feasible-function existence as an implicit exponential-sized SAT\nClaim S1 (Succinct-SAT capture of (F1)+(F2)).\nGiven a \u03b2-normalized, radius-1 LCL L on oriented paths, there is a Boolean formula F(L) of size at most 2poly(\u03b2), given succinctly by a poly(\u03b2)-size circuit, such that F(L) is satisfiable iff there exists a feasible function f (i.e., f passes (F1) and (F2)). Variables are the choice bits of f on each context type \u03c4 and the auxiliary bridge/witness choices where needed. The clauses encode: (i) one-hot consistency of f(\u03c4) \u2208 \u03a3out^2 on each \u03c4, (ii) for every ordered context pair (\u03c41, \u03c42), the \u201cbridge succeeds\u201d constraint computed by the layered DP, and (iii) for (F2), the finitely many repetition lengths z \u2264 Z with Z \u2264 \u2113_pump^2 (per Lemma 1 in the draft), also checked via the DP.\n- Why useful here: It gives a direct NEXPTIME upper bound (already in our draft) and sets up hardness by letting us reduce succinct 3SAT to F(L) through a specific LCL family PC. It cleanly isolates correctness to the equivalence F(L) \u21d4 feasible f.\n- How it can fail: If the number of context types exceeded 2poly(\u03b2) or the DP check needed super-polynomial circuits, the succinct-SAT size would blow up. Also, if (F2) required infinite z checks, we could not confine to finite clauses. Both are avoided by type bounds and periodicity.\n- Quick test: For a toy LCL with \u03b2 = O(1) that enforces proper 2-coloring (no equal neighbors), contexts and pairs are O(1), and F(L) becomes a tiny CNF: per \u03c4 choose color, per pair forbid equal-colored windows. The DP is trivial and the formula is equivalent to 2-colorability of the context graph.\n\nSketch of construction and size: Let T be the type set, |T| = \u2113_pump \u2264 2\u0398(\u03b2^4). Let C \u2286 T be the context-type set: those realized by w1Sw2 with |wi| \u2208 {\u2113_pump, \u2113_pump+1}. Introduce variables {X_{\u03c4,c}} encoding f(\u03c4)=c, with one-hot constraints per \u03c4. For each ordered pair (\u03c41, \u03c42) introduce a polynomial-size circuit that runs the O(k\u03b2^2) DP (k = O(\u2113_pump)) on the bridge instance to produce a clause-set forcing the DP to accept. For (F2), for each \u03c4 and z \u2208 {1,\u2026,Z}, add analogous DP constraints for wz_1Swz_2. The number of \u03c4\u2019s is \u2264 \u2113_pump, pairs \u2264 \u2113_pump^2, and z\u2019s \u2264 \u2113_pump^2. Each DP instance has size polynomial in \u03b2 and \u2113_pump. Therefore the entire formula is of size at most 2poly(\u03b2), given succinctly by a poly(\u03b2)-size generator.\n\n2) Specializing to the hardness family PC: ON/OFF gate \u21d2 local CNF constraints\nClaim S2 (Gated bridge yields per-clause local CNF). For the reduction PC built from a succinct-3CNF generator C (size s), we define \u03a3out and Cout\u2013out so that for every clause index j and its three literals \u2113 \u2208 {1,2,3}, there is a \u201cliteral-pick\u201d color at the clause window S representing a choice Y_{j,\u2113}, and at each variable i there is a 1-bit choice X_i \u2208 {RED,GRN} representing \u03b1(x_i). Then (F1) on PC translates to the CNF:\n- One-hot per clause: exactly one Y_{j,\u2113} is chosen (enforced via one-hot encoding at the clause-side S).\n- For each j and each occurrence i of literal \u2113 in clause j with sign s \u2208 {+,\u2212}, the bridge constraint contributes a Horn clause of the form (\u00acY_{j,\u2113} \u2228 (X_i = RED)) if s=+, or (\u00acY_{j,\u2113} \u2228 (X_i = GRN)) if s=\u2212.\nAll other ordered pairs (including all mismatched (i,j) where Y_{j,\u2113} points to some i\u2032 \u2260 i, or where the left/right side is inactive) compile to tautologies thanks to the OFF gate and \u22a5-plumbing. Therefore, (F1) is equivalent to the satisfiability of the succinct CNF that encodes \u201cfor each clause j, the selected literal is true under \u03b1\u201d.\n- Why useful here: This resolves the universal quantification across all ordered pairs: OFF pairs impose no constraint, and the ON pair per clause imposes exactly one Horn clause linking the clause\u2019s pick Y_{j,\u2113} to the variable\u2019s truth X_i. It also shows that our (F1) feasibility is precisely succinct-3SAT.\n- How it can fail: If the gate could turn ON on unintended pairs (e.g., when Y_{j,\u2113} selects i\u2032 but the pair is with i \u2260 i\u2032), we would accumulate impossible constraints across all three i\u2019s and lose completeness. If malformed clause blocks could fake an ON, spurious Horn clauses could be added. We avoid both by: (i) offers/caps at the S boundary that make ON depend only on the clause-side Y pick and the RUN-decoded occurrence i; (ii) a poly(s)-length, radius-1 verifier tableau that pins the three occurrences and signs; malformed encodings divert to error-chains and never activate ON.\n- Quick test: Clause j = (x3 \u2228 \u00acx7 \u2228 x10): introduce one-hot Y_{j,1},Y_{j,2},Y_{j,3}. Constraints: (\u00acY_{j,1} \u2228 X_3=RED), (\u00acY_{j,2} \u2228 X_7=GRN), (\u00acY_{j,3} \u2228 X_10=RED). If \u03b1 sets X_3=RED, picking Y_{j,1} satisfies all three clauses tied to j; other pairs with variables not equal to 3 are OFF.\n\n3) Window-anchored activation and OFF-pair neutrality\nClaim S3 (OFF pairs are neutral; active iff block in window). The out\u2013out grammar is arranged so that: (i) the two S-nodes can be labeled only from {\u22a5, RED, GRN, BLU}, (ii) non-\u22a5 at S forces an \u201coffer\u201d token to be emitted into wb (left) or wc (right), which is locally legal only at boundaries of well-formed blocks whose HEADC matches the fixed C header; otherwise non-\u22a5 is locally rejected and only \u22a5 is extendible, and (iii) the gate turns ON iff both offers are present and the clause-side literal pick Y_{j,\u2113} matches the variable occurrence i (decoded from clause j by the tableau) at the other side; otherwise the gate remains OFF, and PAD-only conduits fill wb\u25e6wc.\n- Why useful here: Guarantees that (F1) constraints are only active precisely on intended (variable, selected-literal-of-clause) pairs; all other pairs are fillable regardless of f (by PAD/\u22a5), so they do not constrain the SAT.\n- How it can fail: If \u22a5 could not always fill wb\u25e6wc (e.g., blocked by a seam rule), we could get unwanted constraints from inactive contexts. If the offer legality were not locally checkable, an adversarial DP could slip in a fake ON. We prevent both by (1) including a fully absorbing \u22a5-plumbing sublanguage compatible with any S label, and (2) forcing an offer symbol adjacent to S for each non-\u22a5 S label; that offer is legal only when the immediately following few cells match the HEAD/role syntax of a block.\n- Quick test: Construct a pair of contexts where the left wb is malformed (no HEAD marker). Choose RED at S. The left offer is illegal at the boundary; thus non-\u22a5 is locally rejected and only \u22a5 can pass, making the pair OFF/neutral.\n\n4) Clause decoding via a radius-1, poly(s)-length tableau (no O(1) checker)\nClaim S4 (Local verification of succinct clause outputs). The clause-side wc contains (after HEAD and GID) a poly(s)-length, radius-1 tableau for a fixed universal TM U, whose job is to check that the three occurrence indices and their signs (stored in RUN subtracks) equal the outputs of the succinct generator C on input j. The adjacency table Cout\u2013out enforces single-step consistency across rows; any mismatch triggers a short error-chain gadget (accepted locally), which prevents the clause block from being \u201cactive\u201d and hence prevents gate ON.\n- Why useful here: Fixes the previously broken claim of an O(1) decoder and ensures malformed clause encodings are harmless (cannot create ON). It also keeps the LCL description size polynomial in s and hence in \u03b2.\n- How it can fail: If the tableau needed long-range dependencies or cross-row lookahead, we would exceed r=1. We avoid this by standard 1D Turing-tile encodings: every row encodes the work tape and head; Cout\u2013out allows only legal transitions of U, checked locally per neighbor pair. Errors are locally witnessed via error tokens.\n- Quick test: Build a 2-row tableau snippet with an intentional transition mismatch; verify that the only locally allowed continuation is to switch into an error-chain that absorbs the entire block, thus deactivating the gate.\n\n5) Type separation without 2-node boundary signatures\nClaim S5 (Distinct RID/GID yield distinct context types via differential extendibility). For each i \u2260 i\u2032, the context types \u03c4Var(i) (wb contains a well-formed variable block with HotRID[i]=1) and \u03c4Var(i\u2032) are distinct: there exists some fixed clause-side active type \u03c4Cl(j,\u2113) and a fixed S-label choice such that the bridge DP succeeds with \u03c4Var(i) and fails with \u03c4Var(i\u2032). Analogous distinctness holds for clause types.\n- Why useful here: We cannot rely on 2-node boundary encodings to separate 2^B indices. This shows distinctness emerges from differential extendibility behavior under the gated bridge with a suitable fixed partner, leveraging interior content (the RUN tracks) rather than boundary micro-alphabets.\n- How it can fail: If C never produces a clause where i appears and i\u2032 does not, a single \u03c4Cl(j,\u2113) may not separate \u03c4Var(i) and \u03c4Var(i\u2032). However, we can fix \u03c4Cl to be any clause-side active type whose decoded triplet includes i but not i\u2032; such a j exists among 2^B possible indices by padding C with a verifier that, when presented with a reserved \u201ctester\u201d j\u2217 (chosen at construction), outputs a clause whose single ON literal is x_i. This tester is validated by the same tableau mechanism. Thus separation does not rely on arbitrary properties of C.\n- Quick test: Introduce j\u2217 whose decoded clause is (xk \u2228 dummy \u2228 dummy) for k set at construction. Then with \u03c4Var(k) and \u03c4Var(k\u2032\u2260k), the bridge under S=RED is ON for \u03c4Var(k) and OFF for \u03c4Var(k\u2032), distinguishing types.\n\n6) From (F1) to tri-class classification via trivial (F2)\nClaim S6 (Trivializing (F2) preserves succinct-SAT shape). Extend Cout\u2013out so that wz_1 and wz_2 repetitions can always be filled with \u22a5 (PAD) regardless of z. Then (F2) holds for any f, and feasible-function existence reduces to (F1), i.e., the succinct CNF in Claim S2. Therefore, mapping a succinct 3SAT instance C to PC shows NEXPTIME-hardness of the O(1) vs. \u0398(n) sub-classification; in combination with the decidability framework (Theorems 8\u20139 in the reference), the three-way classification is NEXPTIME-hard.\n- Why useful here: Eliminates (F2) constraints, preventing an unintentional \u0398(log* n) regime. The family sits on the O(1)\u2013\u0398(n) dichotomy, simplifying the reduction target.\n- How it can fail: If the PAD/\u22a5 seam conflicts with the S-label fixed by f, (F2) could still impose constraints. We avoid this by permitting \u22a5 adjacent to any S-color and by making PAD/\u22a5 internally self-compatible.\n- Quick test: Pick any context and z=17. Force S by f; fill wz_1 and wz_2 with \u22a5. The DP finds a trivial path since every PAD/\u22a5 pair is admitted by Cout\u2013out.\n\n7) Toy worked example (B=2) under the SAT view\n- Variables: X_1, X_2, X_3, X_4 \u2208 {RED,GRN} (encode \u03b1(x1..x4))\n- One clause j with literals (x3 \u2228 \u00acx1 \u2228 x4). Clause picks: one-hot Y_{j,1},Y_{j,2},Y_{j,3}.\n- CNF clauses from the bridge: (\u00acY_{j,1} \u2228 X_3=RED), (\u00acY_{j,2} \u2228 X_1=GRN), (\u00acY_{j,3} \u2228 X_4=RED).\n- All other ordered pairs are OFF/neutral or forced \u22a5. Thus F(PC) is satisfiable iff there exist X\u2019s and a one-hot Y making one of those literals true\u2014exactly the clause\u2019s satisfiability. Multiple clauses add independent groups of three Horn clauses plus a one-hot.\nCounterexample attempt: If the gate were missing, we would need all three implications simultaneously for all i occurring in j, which would force X_3=RED and X_1=GRN and X_4=RED at the same time, and would also erroneously constrain pairs with variables not in the clause; the gate avoids this by OFF pairs and ON only for the selected literal.\n\n8) Outstanding spec to finalize\n- Cin\u2013out and Cout\u2013out tables at the window seam: explicit rows that (i) force an offer on non-\u22a5 S, (ii) reject non-\u22a5 unless a valid block boundary follows, (iii) implement OFF\u2192PAD conduits, and (iv) implement ON\u2192CAP conduit and CAP equality test.\n- Clause-side tableau tile set: list of allowed (state,symbol) pairs across rows; error-chain tokens that must appear when a mismatch occurs.\n- Tester j\u2217 mechanism (for type-separation robustness): specify reserved GID and the corresponding hard-wired outputs of U, validated by the same tableau (kept radius-1) so that \u03c4Var(i) types are provably distinct.\n- Confirm size bounds: |\u03a3out| = \u03b2 = poly(s); tables of size O(\u03b2^2); tableau length poly(s); type bound \u2113_pump = 2\u0398(\u03b2^4); hence contexts/pairs \u2264 2poly(\u03b2); DP verifiers run in O(k\u03b2^2) per instance.\n\nWhat we have accomplished this round\n- Provided a clean, succinct-SAT formulation of feasible-function existence (S1), which aligns exactly with the required NEXPTIME framework.\n- Instantiated the SAT constraints for the reduction family PC (S2\u2013S3), addressing the earlier fragile spots (pairwise quantification and activation locality) and eliminating reliance on boundary-only signatures (S5).\n- Replaced the O(1) clause decoder with a poly(s)-length, radius-1 tableau and an error-chain refuter (S4).\n- Validated by a B=2 toy and articulated the remaining explicit-table tasks needed to cement the construction.\n",
  "requests_for_more_materials": [
    "Precise format of the succinct 3SAT generator C: input/output bit-widths, how clause literals (variable indices and signs) are encoded, and whether a reserved index value can be allocated for a tester clause j* (we can also hardwire one within the LCL if not).",
    "Confirmation that the classification target is the worst-case over inputs, so we may freely neutralize malformed contexts via error-chains and \u22a5-plumbing without affecting hardness claims.",
    "Any constraints on the allowed size of the error alphabet and work-tape alphabet for the universal TM U beyond being polynomial in s (to tune \u03b2 = poly(s))."
  ],
  "next_actions_for_prover": [
    "Write explicit Cin\u2013out and Cout\u2013out entries for the S-window seam: offers on non-\u22a5, OFF\u2192PAD and ON\u2192CAP conduits, and compatibility of \u22a5 with all neighbors (including S).",
    "Specify the clause-verification tableau: states, tape alphabet, row encodings, and the adjacency pairs checking U\u2019s single-step consistency; define the error-chain tokens and local acceptance rules.",
    "Formalize and prove the tester j* lemma: construct a clause-side active type that singles out a chosen variable i, and use it to separate \u03c4Var(i) from \u03c4Var(i\u2032).",
    "Produce the full B=2 worked example with concrete small alphabets and tables; run the layered DP by hand on all 12 ordered pairs to confirm OFF/ON behavior and clause-Horn constraints.",
    "Draft the succinct circuit that generates F(PC) (variables X and Y one-hots, per-clause Horns), and prove F(PC) is satisfiable iff \u03a6_C is."
  ]
}