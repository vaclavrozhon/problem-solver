{"progress_md":"## Round 0002 — 2025-08-27T11:23:07.548697Z\n\nMini-plan\n- Formalize an implicit exponential-sized SAT encoding F(L) whose satisfiability is equivalent to the existence of a feasible function f for a given β-normalized, radius-1 LCL instance L on oriented paths. This cleanly connects (F1) and (F2) to a succinct-SAT instance.\n- Specialize the encoding to our reduction family PC (from a succinct 3CNF generator C), using window-anchored active blocks and a gated bridge. Show that F(PC) is essentially the succinct 3SAT instance for C with auxiliary “literal-pick” variables Y.\n- State and test three core lemmas: (i) succinct SAT capture of (F1) and (F2) with an explicit 2poly(β) bound, (ii) ON/OFF gate ⇒ CNF constraints of the form (¬Y ∨ X), and (iii) type-separation by boundary-extendibility patterns induced by interior witness behavior (no reliance on 2-node boundaries).\n- Patch the previously flagged fragilities: ensure OFF for all unintended pairs (use offer/cap tokens), and move clause-decoding to a poly(s)-length, radius-1 tableau with error-chain refutations.\n- Work out a small B=2 toy to validate the SAT constraints and counterexample probes; list next instrumentation (explicit Cin–out/Cout–out tables for the window seam, offers, PAD/CAP conduits, and the tableau seam rules).\n\n1) Encoding feasible-function existence as an implicit exponential-sized SAT\nClaim S1 (Succinct-SAT capture of (F1)+(F2)).\nGiven a β-normalized, radius-1 LCL L on oriented paths, there is a Boolean formula F(L) of size at most 2poly(β), given succinctly by a poly(β)-size circuit, such that F(L) is satisfiable iff there exists a feasible function f (i.e., f passes (F1) and (F2)). Variables are the choice bits of f on each context type τ and the auxiliary bridge/witness choices where needed. The clauses encode: (i) one-hot consistency of f(τ) ∈ Σout^2 on each τ, (ii) for every ordered context pair (τ1, τ2), the “bridge succeeds” constraint computed by the layered DP, and (iii) for (F2), the finitely many repetition lengths z ≤ Z with Z ≤ ℓ_pump^2 (per Lemma 1 in the draft), also checked via the DP.\n- Why useful here: It gives a direct NEXPTIME upper bound (already in our draft) and sets up hardness by letting us reduce succinct 3SAT to F(L) through a specific LCL family PC. It cleanly isolates correctness to the equivalence F(L) ⇔ feasible f.\n- How it can fail: If the number of context types exceeded 2poly(β) or the DP check needed super-polynomial circuits, the succinct-SAT size would blow up. Also, if (F2) required infinite z checks, we could not confine to finite clauses. Both are avoided by type bounds and periodicity.\n- Quick test: For a toy LCL with β = O(1) that enforces proper 2-coloring (no equal neighbors), contexts and pairs are O(1), and F(L) becomes a tiny CNF: per τ choose color, per pair forbid equal-colored windows. The DP is trivial and the formula is equivalent to 2-colorability of the context graph.\n\nSketch of construction and size: Let T be the type set, |T| = ℓ_pump ≤ 2Θ(β^4). Let C ⊆ T be the context-type set: those realized by w1Sw2 with |wi| ∈ {ℓ_pump, ℓ_pump+1}. Introduce variables {X_{τ,c}} encoding f(τ)=c, with one-hot constraints per τ. For each ordered pair (τ1, τ2) introduce a polynomial-size circuit that runs the O(kβ^2) DP (k = O(ℓ_pump)) on the bridge instance to produce a clause-set forcing the DP to accept. For (F2), for each τ and z ∈ {1,…,Z}, add analogous DP constraints for wz_1Swz_2. The number of τ’s is ≤ ℓ_pump, pairs ≤ ℓ_pump^2, and z’s ≤ ℓ_pump^2. Each DP instance has size polynomial in β and ℓ_pump. Therefore the entire formula is of size at most 2poly(β), given succinctly by a poly(β)-size generator.\n\n2) Specializing to the hardness family PC: ON/OFF gate ⇒ local CNF constraints\nClaim S2 (Gated bridge yields per-clause local CNF). For the reduction PC built from a succinct-3CNF generator C (size s), we define Σout and Cout–out so that for every clause index j and its three literals ℓ ∈ {1,2,3}, there is a “literal-pick” color at the clause window S representing a choice Y_{j,ℓ}, and at each variable i there is a 1-bit choice X_i ∈ {RED,GRN} representing α(x_i). Then (F1) on PC translates to the CNF:\n- One-hot per clause: exactly one Y_{j,ℓ} is chosen (enforced via one-hot encoding at the clause-side S).\n- For each j and each occurrence i of literal ℓ in clause j with sign s ∈ {+,−}, the bridge constraint contributes a Horn clause of the form (¬Y_{j,ℓ} ∨ (X_i = RED)) if s=+, or (¬Y_{j,ℓ} ∨ (X_i = GRN)) if s=−.\nAll other ordered pairs (including all mismatched (i,j) where Y_{j,ℓ} points to some i′ ≠ i, or where the left/right side is inactive) compile to tautologies thanks to the OFF gate and ⊥-plumbing. Therefore, (F1) is equivalent to the satisfiability of the succinct CNF that encodes “for each clause j, the selected literal is true under α”.\n- Why useful here: This resolves the universal quantification across all ordered pairs: OFF pairs impose no constraint, and the ON pair per clause imposes exactly one Horn clause linking the clause’s pick Y_{j,ℓ} to the variable’s truth X_i. It also shows that our (F1) feasibility is precisely succinct-3SAT.\n- How it can fail: If the gate could turn ON on unintended pairs (e.g., when Y_{j,ℓ} selects i′ but the pair is with i ≠ i′), we would accumulate impossible constraints across all three i’s and lose completeness. If malformed clause blocks could fake an ON, spurious Horn clauses could be added. We avoid both by: (i) offers/caps at the S boundary that make ON depend only on the clause-side Y pick and the RUN-decoded occurrence i; (ii) a poly(s)-length, radius-1 verifier tableau that pins the three occurrences and signs; malformed encodings divert to error-chains and never activate ON.\n- Quick test: Clause j = (x3 ∨ ¬x7 ∨ x10): introduce one-hot Y_{j,1},Y_{j,2},Y_{j,3}. Constraints: (¬Y_{j,1} ∨ X_3=RED), (¬Y_{j,2} ∨ X_7=GRN), (¬Y_{j,3} ∨ X_10=RED). If α sets X_3=RED, picking Y_{j,1} satisfies all three clauses tied to j; other pairs with variables not equal to 3 are OFF.\n\n3) Window-anchored activation and OFF-pair neutrality\nClaim S3 (OFF pairs are neutral; active iff block in window). The out–out grammar is arranged so that: (i) the two S-nodes can be labeled only from {⊥, RED, GRN, BLU}, (ii) non-⊥ at S forces an “offer” token to be emitted into wb (left) or wc (right), which is locally legal only at boundaries of well-formed blocks whose HEADC matches the fixed C header; otherwise non-⊥ is locally rejected and only ⊥ is extendible, and (iii) the gate turns ON iff both offers are present and the clause-side literal pick Y_{j,ℓ} matches the variable occurrence i (decoded from clause j by the tableau) at the other side; otherwise the gate remains OFF, and PAD-only conduits fill wb◦wc.\n- Why useful here: Guarantees that (F1) constraints are only active precisely on intended (variable, selected-literal-of-clause) pairs; all other pairs are fillable regardless of f (by PAD/⊥), so they do not constrain the SAT.\n- How it can fail: If ⊥ could not always fill wb◦wc (e.g., blocked by a seam rule), we could get unwanted constraints from inactive contexts. If the offer legality were not locally checkable, an adversarial DP could slip in a fake ON. We prevent both by (1) including a fully absorbing ⊥-plumbing sublanguage compatible with any S label, and (2) forcing an offer symbol adjacent to S for each non-⊥ S label; that offer is legal only when the immediately following few cells match the HEAD/role syntax of a block.\n- Quick test: Construct a pair of contexts where the left wb is malformed (no HEAD marker). Choose RED at S. The left offer is illegal at the boundary; thus non-⊥ is locally rejected and only ⊥ can pass, making the pair OFF/neutral.\n\n4) Clause decoding via a radius-1, poly(s)-length tableau (no O(1) checker)\nClaim S4 (Local verification of succinct clause outputs). The clause-side wc contains (after HEAD and GID) a poly(s)-length, radius-1 tableau for a fixed universal TM U, whose job is to check that the three occurrence indices and their signs (stored in RUN subtracks) equal the outputs of the succinct generator C on input j. The adjacency table Cout–out enforces single-step consistency across rows; any mismatch triggers a short error-chain gadget (accepted locally), which prevents the clause block from being “active” and hence prevents gate ON.\n- Why useful here: Fixes the previously broken claim of an O(1) decoder and ensures malformed clause encodings are harmless (cannot create ON). It also keeps the LCL description size polynomial in s and hence in β.\n- How it can fail: If the tableau needed long-range dependencies or cross-row lookahead, we would exceed r=1. We avoid this by standard 1D Turing-tile encodings: every row encodes the work tape and head; Cout–out allows only legal transitions of U, checked locally per neighbor pair. Errors are locally witnessed via error tokens.\n- Quick test: Build a 2-row tableau snippet with an intentional transition mismatch; verify that the only locally allowed continuation is to switch into an error-chain that absorbs the entire block, thus deactivating the gate.\n\n5) Type separation without 2-node boundary signatures\nClaim S5 (Distinct RID/GID yield distinct context types via differential extendibility). For each i ≠ i′, the context types τVar(i) (wb contains a well-formed variable block with HotRID[i]=1) and τVar(i′) are distinct: there exists some fixed clause-side active type τCl(j,ℓ) and a fixed S-label choice such that the bridge DP succeeds with τVar(i) and fails with τVar(i′). Analogous distinctness holds for clause types.\n- Why useful here: We cannot rely on 2-node boundary encodings to separate 2^B indices. This shows distinctness emerges from differential extendibility behavior under the gated bridge with a suitable fixed partner, leveraging interior content (the RUN tracks) rather than boundary micro-alphabets.\n- How it can fail: If C never produces a clause where i appears and i′ does not, a single τCl(j,ℓ) may not separate τVar(i) and τVar(i′). However, we can fix τCl to be any clause-side active type whose decoded triplet includes i but not i′; such a j exists among 2^B possible indices by padding C with a verifier that, when presented with a reserved “tester” j∗ (chosen at construction), outputs a clause whose single ON literal is x_i. This tester is validated by the same tableau mechanism. Thus separation does not rely on arbitrary properties of C.\n- Quick test: Introduce j∗ whose decoded clause is (xk ∨ dummy ∨ dummy) for k set at construction. Then with τVar(k) and τVar(k′≠k), the bridge under S=RED is ON for τVar(k) and OFF for τVar(k′), distinguishing types.\n\n6) From (F1) to tri-class classification via trivial (F2)\nClaim S6 (Trivializing (F2) preserves succinct-SAT shape). Extend Cout–out so that wz_1 and wz_2 repetitions can always be filled with ⊥ (PAD) regardless of z. Then (F2) holds for any f, and feasible-function existence reduces to (F1), i.e., the succinct CNF in Claim S2. Therefore, mapping a succinct 3SAT instance C to PC shows NEXPTIME-hardness of the O(1) vs. Θ(n) sub-classification; in combination with the decidability framework (Theorems 8–9 in the reference), the three-way classification is NEXPTIME-hard.\n- Why useful here: Eliminates (F2) constraints, preventing an unintentional Θ(log* n) regime. The family sits on the O(1)–Θ(n) dichotomy, simplifying the reduction target.\n- How it can fail: If the PAD/⊥ seam conflicts with the S-label fixed by f, (F2) could still impose constraints. We avoid this by permitting ⊥ adjacent to any S-color and by making PAD/⊥ internally self-compatible.\n- Quick test: Pick any context and z=17. Force S by f; fill wz_1 and wz_2 with ⊥. The DP finds a trivial path since every PAD/⊥ pair is admitted by Cout–out.\n\n7) Toy worked example (B=2) under the SAT view\n- Variables: X_1, X_2, X_3, X_4 ∈ {RED,GRN} (encode α(x1..x4))\n- One clause j with literals (x3 ∨ ¬x1 ∨ x4). Clause picks: one-hot Y_{j,1},Y_{j,2},Y_{j,3}.\n- CNF clauses from the bridge: (¬Y_{j,1} ∨ X_3=RED), (¬Y_{j,2} ∨ X_1=GRN), (¬Y_{j,3} ∨ X_4=RED).\n- All other ordered pairs are OFF/neutral or forced ⊥. Thus F(PC) is satisfiable iff there exist X’s and a one-hot Y making one of those literals true—exactly the clause’s satisfiability. Multiple clauses add independent groups of three Horn clauses plus a one-hot.\nCounterexample attempt: If the gate were missing, we would need all three implications simultaneously for all i occurring in j, which would force X_3=RED and X_1=GRN and X_4=RED at the same time, and would also erroneously constrain pairs with variables not in the clause; the gate avoids this by OFF pairs and ON only for the selected literal.\n\n8) Outstanding spec to finalize\n- Cin–out and Cout–out tables at the window seam: explicit rows that (i) force an offer on non-⊥ S, (ii) reject non-⊥ unless a valid block boundary follows, (iii) implement OFF→PAD conduits, and (iv) implement ON→CAP conduit and CAP equality test.\n- Clause-side tableau tile set: list of allowed (state,symbol) pairs across rows; error-chain tokens that must appear when a mismatch occurs.\n- Tester j∗ mechanism (for type-separation robustness): specify reserved GID and the corresponding hard-wired outputs of U, validated by the same tableau (kept radius-1) so that τVar(i) types are provably distinct.\n- Confirm size bounds: |Σout| = β = poly(s); tables of size O(β^2); tableau length poly(s); type bound ℓ_pump = 2Θ(β^4); hence contexts/pairs ≤ 2poly(β); DP verifiers run in O(kβ^2) per instance.\n\nWhat we have accomplished this round\n- Provided a clean, succinct-SAT formulation of feasible-function existence (S1), which aligns exactly with the required NEXPTIME framework.\n- Instantiated the SAT constraints for the reduction family PC (S2–S3), addressing the earlier fragile spots (pairwise quantification and activation locality) and eliminating reliance on boundary-only signatures (S5).\n- Replaced the O(1) clause decoder with a poly(s)-length, radius-1 tableau and an error-chain refuter (S4).\n- Validated by a B=2 toy and articulated the remaining explicit-table tasks needed to cement the construction.\n","requests_for_more_materials":["Precise format of the succinct 3SAT generator C: input/output bit-widths, how clause literals (variable indices and signs) are encoded, and whether a reserved index value can be allocated for a tester clause j* (we can also hardwire one within the LCL if not).","Confirmation that the classification target is the worst-case over inputs, so we may freely neutralize malformed contexts via error-chains and ⊥-plumbing without affecting hardness claims.","Any constraints on the allowed size of the error alphabet and work-tape alphabet for the universal TM U beyond being polynomial in s (to tune β = poly(s))."],"next_actions_for_prover":["Write explicit Cin–out and Cout–out entries for the S-window seam: offers on non-⊥, OFF→PAD and ON→CAP conduits, and compatibility of ⊥ with all neighbors (including S).","Specify the clause-verification tableau: states, tape alphabet, row encodings, and the adjacency pairs checking U’s single-step consistency; define the error-chain tokens and local acceptance rules.","Formalize and prove the tester j* lemma: construct a clause-side active type that singles out a chosen variable i, and use it to separate τVar(i) from τVar(i′).","Produce the full B=2 worked example with concrete small alphabets and tables; run the layered DP by hand on all 12 ordered pairs to confirm OFF/ON behavior and clause-Horn constraints.","Draft the succinct circuit that generates F(PC) (variables X and Y one-hots, per-clause Horns), and prove F(PC) is satisfiable iff Φ_C is."]}