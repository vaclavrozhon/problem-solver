--- SYSTEM ---
You are a research **summarizer**. Summarize this *last round only* for a human log.

Include:
- 3–7 bullet **Highlights** (facts learned, reductions, counterexamples, partial bounds).
- 1–3 **Open questions / TODOs** for the next round.
- 1–3 **Citations to files** you relied on (e.g. round files or papers by name).

**Return strictly JSON**:
{
  "summary_md": "Readable summary of the round (≤200 words)",
  "highlights": [],
  "next_questions": []
}

--- USER ---
=== prover-01.out.json (progress_md) ===
## Round 0002 — 2025-08-28T11:43:33Z

Focus and plan for this round
- Goal: push the NEXPTIME-hardness via Succinct 3-Coloring (S3Col) by cleanly aligning (F1) mid-consistency with pairwise edge constraints “color(u) ≠ color(v) when D(u,v)=1”. Make (F2) vacuous via ⊥-filler. Deliver concrete, radius-1 gadgets and type-separation lemmas that are checkable and do not rely on per-type ad hoc rules.
- This round: (i) state and justify a “boundary-anchored vertex-type separation” lemma; (ii) design a seam simulation gadget that, on active vertex–vertex pairs, computes D(u,v) in the bridge and enforces inequality if D(u,v)=1 while accepting any colors if D(u,v)=0; (iii) detail the ⊥-filler that neutralizes (F2); (iv) give a small B=2 sanity check; (v) log minor clarifications for output.md.

Context recap from last round
- Use S3Col: input is circuit D of size s deciding an undirected succinct graph on V={0,1}^B (we can symmetrize by using D′(u,v):=D(u,v)∨D(v,u)). Set B=s^{c0}, choose |Σ_out|=β=s^{c1} with c1≫c0. ℓ_pump=2^{Θ(β^4)}≫poly(s) so we have ample pumping room. We only need vertex-types (no clause-types).

Key new lemmas (informal statements, why useful, and how to validate)
1) Boundary-anchored vertex-type separation (existence of 2^B distinct vertex types)
- Statement. There exists a β-normalized, radius-1 schema (global Cin–out, Cout–out) with constant role/phase/error/work tracks such that for each index u∈{0,1}^B there is at least one context type τ_u in the context set C (realizable by some input word w_1 S w_2) with the following properties:
  (A) Vertex activation near S on the left side: if the two-node window S is colored (non-⊥) and the left side is intended to be a vertex, then a radius-1 forced “index header” of length Θ(B) is determined immediately to the left of S; this header copies the B input bits (RID-track) adjacent to S via Cin–out, so the u encoded in input is fixed. All malformed attempts can be locally refuted by error-chains.
  (B) Probe distinguishability: there exists a fixed 4-tuple b⋆ of boundary outputs on the four boundary nodes of w_1 (two leftmost and two “second” nodes) such that E_{w_1}(b⋆)=1 iff the input RID next to S equals u. Consequently, if u≠u′, then τ_u≠τ_{u′} (types differ on b⋆).
- Why useful: gives us exponentially many pairwise distinct vertex context types, allowing a map f on types to encode a coloring χ(u)∈{RED,GRN,BLU}.
- How enforced at radius 1. We predefine a reserved “probe-left” boundary pattern b⋆ using symbols that (i) fix a role/phase state at the two boundary layers and (ii) enable a single deterministic pipe that walks inward for B steps, checking at position j that the RID-output symbol agrees with the local input bit (Cin–out) and with a constant j-th bit of the target u. If any check fails, the pipe has no legal continuation (no extension). If all pass, the pipe halts into a neutral filler. Because the pipe is unique, the existential nature of types cannot “cheat” by choosing a different interior: existence of a completion under b⋆ exactly encodes “RID equals u”.
- Validation: The pipe is exactly the standard radius-1 pointer gadget (Section 3 in the attached paper) but with a bounded, fixed length B and equality tests via Cin–out. The existence of contexts carrying any prescribed B-bit RID adjacent to S is guaranteed by considering input words over Σ_in; malformed inputs are harmless due to error-chains.

2) Seam-simulation gadget for pairwise constraints (edge gating and color inequality)
- Statement. There is a radius-1 out–out schema such that for any ordered pair of active vertex types (τ_u on the left, τ_v on the right):
  (i) If D(u,v)=0, there is a completion irrespective of the colors f(τ_u), f(τ_v) placed on the window S; (ii) If D(u,v)=1, there is a completion iff the two colors differ; and (iii) For any pair where at least one side is inactive (no well-formed vertex near S), there is always a completion (via ⊥-plumbing), independent of the other side.
- Why useful: This aligns (F1)’s universal quantification with 3-coloring constraints: f feasible ⇔ χ(u)≠χ(v) for all edges (u,v).
- Seam layout (radius-1):
  • Near-boundary index tapes. On each side, the Θ(B)-long RID tape sits immediately adjacent to S (by Lemma 1). We also place a fixed-size “header acceptance” bit (valid if the embedded header equals the constant D-encoding)
  • Bridge tableau. On the wb◦wc bridge, allow a standard 1D row-by-row simulation of a fixed universal TM U for poly(s) steps to evaluate D(u,v), reading the two B-bit tapes and the constant header. Each row transition is enforced by nearest-neighbor Cout–out constraints; malformed rows can be refuted by error-chains as in §3.
  • Acceptance signals. The simulation emits a bit EDGE∈{0,1}. Local rules at S admit completion if (EDGE=0) or (EDGE=1 and colors on S are unequal). If EDGE=1 and colors equal, all continuations are forbidden. All these checks involve only constant-size neighborhoods around S.
- Validation: Standard “computation-by-tiling” for 1D simulations as in §3 and §4; run time is poly(s)≪ℓ_pump and space sits in wb◦wc (length ≥ℓ_pump). Robustness via error-chains ensures that malformed headers and/or runs never constrain f.

3) Neutralizing bridging (F2) by a ⊥-filler
- Statement. Add a self-looping ⊥-track and allow wz (for any z≥1) to be filled entirely with ⊥ irrespective of boundary outputs adjacent to S. Then for every context (w_1,S,w_2) and z, the partial S-label from f extends by filling both sides with ⊥, making (F2) hold vacuously.
- Why useful: Reduces the classification to (F1) only on our instances, hence the 3-way classifier must output O(1) iff a feasible f exists and Ω(n) otherwise; the Θ(log* n) case is eliminated for our reduction family.
- Validation: This is compatible with the DP in output.md (Theorem 5) and with Lemma 1 (finite-Z) but stronger: it makes every z trivially feasible. It does not interfere with (F1) since (F1) instances use one copy of each side and the bridge; those are left unchanged by the ⊥-filler language.

Blueprint of the alphabet/tracks and local rules (radius-1, β=poly(s))
- Fixed tracks in Σ_out (constant per node, combined into a single symbol):
  1) Role/phase: {HEAD, VERT, RUN, PAD, PIPE, ERR_k, …}×{phase modulo c}.
  2) Header bits: output track that must match a fixed string enc(D) under HEAD-role; Cin–out ties head-bit outputs to Σ_in bits so only inputs matching enc(D) allow HEAD.
  3) RID tape: B bits adjacent to S on each vertex side; Cin–out enforces that RID-bit output equals the input bit at that node (copy constraint) when in VERT-role.
  4) Bridge-run work alphabet: constant-size tape symbols for U.
  5) Color tokens and ⊥ at S: {RED, GRN, BLU, ⊥} available only at S positions (enforced by phases/roles around S).
  6) Error-chain alphabet from §3 to refute malformed fragments locally.
- Cin–out usage: ties HEAD bits to input; ties RID bits to input; allows generic symbols elsewhere. This guarantees that whether a vertex is well-formed is determined by inputs (hence activity is type-invariant once the boundary role is fixed).
- Cout–out (nearest-neighbor): enumerates allowed pairs that (i) implement the deterministic PIPE for Lemma 1 (RID-forcing/probe), (ii) implement the RUN tableau rows and acceptance edge-bit, (iii) enforce color inequality test when EDGE=1, and (iv) allow ⊥-plumbing everywhere if chosen.

Soundness/completeness sketches of the reduction (S3Col → FFE(F1))
- Completeness (G 3-colorable ⇒ feasible f exists): choose χ:V→{R,G,B}. For each vertex-type τ_u, set f(τ_u)=χ(u); for all other (inactive) types, set f(τ)=⊥. For any ordered pair, if both are active, the bridge computes EDGE=D(u,v). If EDGE=0, completion exists; if EDGE=1 then χ(u)≠χ(v) ensures completion by inequality check. All non-active pairs are vacuous due to ⊥-plumbing. Hence (F1) holds.
- Soundness (feasible f ⇒ G 3-colorable): for each u, define χ(u)=f(τ_u) (well-defined since otherwise the ordered pair of two τ_u representatives would violate (F1) via the bridge rules that require consistent acceptance conditions). For any edge (u,v), the bridge yields EDGE=1; thus (F1) forces f(τ_u)≠f(τ_v). Therefore χ is a proper 3-coloring.

Toy sanity check (B=2)
- Suppose V={00,01,10,11} and D encodes a 4-cycle 00–01–11–10–00. Contexts include τ_00,…,τ_11, each with RID=that index adjacent to S on the left or right side. The bridge-run reads those 2-bit RID tapes, computes EDGE (using D hardwired), and enforces inequality iff EDGE=1. A valid f assigns a 3-coloring of the 4-cycle; the DP on each (F1) instance accepts exactly under that condition.

Obstacles and how we address them
- Type invariance vs. interior nondeterminism: Lemma 1’s PIPE is deterministic and initiated solely by boundary outputs; if the probe is selected, the only way to extend is to carry the unique pipeline and match the B-bit RID from input. Thus the existence/non-existence of an extension under the probe is a property of the fixed input substring near the boundary, hence of the type.
- Non-edges must accept any colors: We ensure the bridge-run emits EDGE=0 in that case, and acceptance rules ignore S colors. Since (F1) only needs existence of one completion, this suffices.
- Symmetry of edges: Replace D by D′(u,v)=D(u,v)∨D(v,u) in the instance to guarantee undirected adjacency while keeping size poly(s).
- Global inputs adversarial: Our complexity claim is worst-case over inputs. The construction ensures malformed inputs are always completable (⊥/error-chain) and do not constrain f; active contexts (those that matter) arise from many input strings (enough to ensure all τ_u exist as realizable types), which suffices because (F1) quantifies over all contexts.

Gaps/clarifications in output.md (minor)
- Composition lemma wording (Lemma 2): the proof mentions “two internal adjacencies across the seam” using (p_left,p_right); to avoid confusion, note explicitly that (i) the adjacency within u between its last two outputs and within v between its first two outputs are already captured by Type(u), Type(v), and (ii) the seam adjacency is only between the last output of u (p_right) and the first of v (p_left); the boolean-matrix view in Appendix A already encodes this correctly.
- Types vs. interior inputs: Definition currently says “interior inputs may be arbitrary”; in our β-normalized model inputs are fixed per instance. It may help to state explicitly that E_w(a) is computed with the interior inputs fixed to those of w; this is consistent with Lemmas 10–15 in the attached paper and with the DP in Theorem 5.

Why the new lemmas are auditable now
- Lemma 1 reduces to a finite-radius PIPE with length B=poly(s) (bounded independent of ℓ_pump) that is checkable by local tables; E_w(b⋆) depends only on the fixed w (hence on Type(w)). The verifier can test a concrete instantiation on a small B (e.g., B=2) by brute-force DP to observe the extendibility difference.
- The seam simulation is a standard 1D tableau simulation; a checker can write out the row alphabet and the local transition constraints for a small instance (with a 2-input AND gate as D) and verify the edge/inequality behavior.

Next steps (concrete, checkable deliverables)
1) Write the explicit adjacency fragments:
   - RID-PIPE: list states for “step j” (0≤j≤B), legal successors, and Cin–out masks that tie role=RID,j to the input bit.
   - Bridge-run: define the U-row alphabet and per-row local constraints; define the EDGE output; layout how it reads RID tapes.
   - Color-check rules at S conditional on EDGE.
2) Prove the vertex-type separation lemma formally: select b⋆, show E_w(b⋆)=1⇔RID(u) and that u≠u′ gives differing extendibility tables ⇒ distinct types.
3) Formalize the soundness/completeness argument into a theorem “S3Col ≤_m FFE(F1) for β-normalized r=1” with explicit size bounds (|Σ_out|=poly(s), tables of size Θ(β^2)).
4) Integrate the ⊥-filler rules and note that (F2) is vacuous; state the corollary “3-way classification is NEXPTIME-hard on our family”.

Potential stretch: tighten the (F2) finite-Z bound in output.md from ℓ^2 to lcm(periods)×(max preperiod) (still ≤ℓ^2) and add a remark on how to compute it from the type DFA; not needed for hardness but improves the upper-bound section.


=== prover-02.out.json (progress_md) ===
Status. We have a solid upper-bound skeleton (types, composition, periodicity, finite-Z for (F2), and the O(kβ^2) DP) captured in output.md. To push hardness to NEXPTIME for the 3-way classifier, I focus on formalizing the succinct 3-coloring reduction via (F1), with two key technical lemmas: (i) type-separation per vertex index u using a boundary-probe truth-table signature realized by a radius-1 checker; (ii) a seam gadget that, on colored S-windows, locally simulates D(u,v) (adjacency) across the bridge, accepting iff either non-edge or colors differ. I also point out a minor optional tightening in output.md and confirm its current statements are correct as written.

Gaps/remarks on output.md (minor). 
- The ℓ^2 bound in Corollary 4 is correct and sufficient; optionally, one can refine Z to preperiod1 + preperiod2 + lcm(period1, period2) ≤ 2ℓ + ℓ ≤ 3ℓ (or ≤ lcm periods) by analyzing the pair map on T×T, but this is nonessential. The current deterministic DP lemma (Theorem 5) is correct; an explicit treatment of boundary inputs when k<4 is trivial and can be omitted. No correctness issues spotted.

Plan and why useful. 
- Pivot source to Succinct 3-Coloring (NEXP-complete). For a circuit D of size s deciding adjacency on V={0,1}^B (B=s^{c0}), we construct a β-normalized, r=1 LCL P_D with β=s^{c1} (c1≫c0) so that: existence of a feasible function (F1) ⇔ G is 3-colorable. This matches (F1)’s universal quantification (pairwise inequality on edges) and avoids clause-level ∃-quantifiers.

Core technical ingredients (new lemmas, concrete gadgets).

Lemma A (Type-separation via boundary-probe signature). Fix integers B=s^{c0} and β=s^{c1} with 4c1>c0. There exists a radius-1 β-normalized LCL fragment that enforces: for any path segment W that contains a well-formed vertex block encoding an index u∈{0,1}^B (and no errors), the type Type(W) has extendibility truth-table over the β^4 boundary-output assignments equal to an injective signature g(u)∈{0,1}^{β^4}. In particular, u≠u′ ⇒ Type(W)≠Type(W′).
- Construction sketch (radius-1):
  • Reserve in Σ_out constant tracks: role/phase, error alphabet, a ⊥-plumbing symbol, and a RUN track for a fixed universal TM U. The vertex block stores u in a self-delimiting header and includes a short RUN zone computing on demand bits of an injective signature g(u) of length L=β^4≥2^B (we can set g(u) to the length-L zero-padded copy of u followed by a fixed injective encoding). The run budget is poly(s).
  • Boundary-probe coding: Each of the four boundary outputs carries an index digit in base β; together they encode b∈[β^4] (the probe index). Adjacency rules copy these 4 base-β digits along “carrier” subtracks deterministically from both ends toward the interior (radius-1 constraints enforcing equality along edges). If the two ends encode different b, a detector in the middle halts with an unsatisfiable local pattern ⇒ that boundary assignment is rejected (truth-table bit 0). If they match, the bridge enables U to read (u,b) from the interior/carriers and compute g(u)[b] in poly(s) steps within W. Local acceptance (extendibility) is permitted iff g(u)[b]=1 (otherwise the RUN must end in a dead configuration). Malformed interiors open an error-chain (always extendible) and are hence excluded when defining vertex types.
- Why useful: It produces ≥2^B distinct types attributable to different u while using only β symbols and radius 1; f can then assign colors per vertex-type τ_u.

Lemma B (Realization of vertex context types near S). For each u, there exist contexts (w_1,S,w_2) with |w_i|∈{ℓ_pump,ℓ_pump+1} whose left (or right) side contains a well-formed vertex block for u adjacent (within O(1)) to S, and whose type equals the Type(W) from Lemma A. Moreover, replacement/pumping (Lemmas 11, 14–15) ensure that these contexts persist under padding to the required lengths.
- Why useful: Guarantees the context set C contains, for each u, at least one “vertex” type τ_u on which f can act.

Lemma C (Seam gadget for succinct adjacency and color inequality). There is a radius-1 out–out grammar across the seam between a left τ_u-context and a right τ_v-context such that, when both S windows are colored, the bridge wa S_1 wb wc S_2 wd admits a completion iff either D(u,v)=0 (non-edge) or D(u,v)=1 and the two colors differ. If either side is not a vertex context (no valid block), the seam always completes (via ⊥-plumbing or error chains) irrespective of S.
- Construction sketch:
  • Seam handshake: Near each S window, a constant-size “handshake” subtrack asserts role=VERTEX, and opens a bounded-width corridor through wb∘wc where a fixed TM U simulates D(u,v) for poly(s) steps using the copies of D from the interiors and seam pointers that fetch u (on the left) and v (on the right). As in §3 of the attached paper, each tableau row is locally checked by Cout–out; malformed runs are locally refutable (error-chain), keeping non-vertex contexts harmless.
  • Acceptance policy: The corridor exposes a verdict bit Edge(u,v). The adjacency table then enforces: if Edge=0, accept regardless of colors; if Edge=1, require Color(S_1)≠Color(S_2) (three colors in a constant subalphabet). Violations force a dead pattern (no completion). All checks are radius-1 because comparisons are between adjacent row/phase symbols and the two S outputs.
- Why useful: Encodes the exact pairwise 3-coloring constraint on edges within (F1)’s universal pair quantification; non-edges/vacuous pairs always pass.

Lemma D (Bridging neutralization). Add ⊥-repetition plumbing: for any context (w_1,S,w_2), all repetitions w_1^z and w_2^z can be filled entirely with ⊥ while remaining compatible with any S outputs and the fixed boundary inputs. Then (F2) holds for every f.
- Why useful: Collapses the three-class decision to (F1)-feasibility, transferring NEXP-hardness to the classifier (O(1) vs Ω(n) on our instances).

Soundness/completeness outline for the reduction (auditable).
- Parameters: Choose c1≫c0 so that β^4 = s^{4c1} ≥ 2B; then ℓ_pump = 2^{Θ(β^4)} = 2^{poly(s)}. Block length is poly(s)≪ℓ_pump.
- Cmpltns:
  • If G is 3-colorable with χ:V→{R,G,B}, define f(τ_u) = (χ(u) on S) and f(τ)=⊥ for non-vertex types. For any ordered pair (τ_left, τ_right), the seam gadget computes Edge(u,v); non-edges accept; edges accept iff χ(u)≠χ(v). Hence all (F1) checks pass. (F2) is vacuous by Lemma D.
- Sndnss:
  • If f satisfies (F1), read χ(u)=f(τ_u). Consider any edge (u,v). The pair (τ_u, τ_v) must pass the (F1) DP; by Lemma C, this forces χ(u)≠χ(v). Therefore χ is a proper 3-coloring.

Key implementation details (to be checked next, but radius-1 and β=poly(s)).
- Fixed tracks in Σ_out (constant multiplicity): role/phase states; three color tokens and ⊥; RUN work alphabet of the fixed U; error-chain symbols. The total |Σ_out|=β can be chosen polynomial in s to host these tracks.
- Probe carriers: The four boundary positions provide base-β digits (b_1,b_2,b_3,b_4) coding b∈[β^4]; per-edge Cout–out permits copying these digits unchanged along special carrier tracks. A small synchronizer ensures two carriers meet and agree before the RUN consults b.
- Robustness: Any malformed header/index/RUN admits a locally checkable error-chain (as in the LBA construction), so such contexts never constrain f; they can be mapped to ⊥ by f.

Toy sanity checks.
- Tiny β example: Let β=3, reserve 3 colors+⊥ and minimal RUN symbols. With B=2 (four vertices), choose a trivial D; the seam accepts iff colors differ on the unique edge case. The probe signature g(u) can be just the 9-bit (β^4=81 in general; here smaller) table determined by U’s response to the four boundary symbols; in the toy, let g(u) encode u across a few “distinguishing” boundary assignments to see Type(W_u)≠Type(W_v) by direct DP.

Obstacles and mitigations.
- Probe capacity vs. 2^B: We cannot dedicate a distinct boundary 4-tuple per u since β^4≪2^B; instead we use the full truth-table over β^4 probes, mapping u↦g(u)∈{0,1}^{β^4} injectively (possible since β^4≥B). The grammar is uniform; dependence on u enters only via the interior-encoded u read by U.
- Uniformity within types: Because the probe acceptance policy is fixed and depends only on (boundary 4-tuple, interior u), all representatives of the same type (i.e., same interior u and no errors) yield identical extendibility tables, satisfying type-invariance.
- Ensuring active τ_u exist: Use Lemma 11 (replacement) and Lemmas 14–15 (pumping) to embed the O(poly(s))-length block adjacent to S within words of length ℓ_pump or ℓ_pump+1 on each side, without changing the type.

Next concrete steps (incremental, testable).
1) Formalize Lemma A. Specify: (i) the base-β boundary-digit carriers and their radius-1 propagation; (ii) the U-simulation that, given (u,b), outputs g(u)[b] and how Cout–out enforces acceptance iff 1. Prove type-separation: u≠u′ ⇒ the truth tables differ in at least one b.
2) Formalize Lemma C. Write the exact row interface and verdict wiring so that (Edge=0) ⇒ unconditional acceptance, (Edge=1) ⇒ require Color(S_1)≠Color(S_2). Include the local refutation for malformed runs.
3) Prove Lemma B: a clean pumping/replacement embedding argument placing blocks within contexts of the required lengths while preserving type.
4) Package the construction P_D and the equivalence “G 3-colorable ⇔ (F1)-feasible f exists,” then add the ⊥-repetition rules (Lemma D) to transfer hardness to the O(1)/Ω(n) classification.

Why this is progress.
- It addresses the main unresolved pieces flagged by the verifier: a type-invariant “activity” mechanism and a pairwise constraint that matches (F1). The boundary-probe signature provides exponentially many distinct types with β=poly(s) and radius-1 rules; the seam gadget exactly encodes edge constraints suitable for (F1). These are compact, checkable subclaims that can be verified independently using the O(kβ^2) DP.


=== prover-03.out.json (progress_md) ===
Ideas — pivot formalization via succinct 3-coloring and type separation
- Goal of this round: Make the NEXPTIME-hardness route auditable by (i) aligning (F1) semantics with a pairwise constraint problem (succinct 3-coloring), and (ii) pinning down a concrete, radius-1 mechanism that guarantees exponentially many distinct context types (one per vertex u ∈ {0,1}^B) even though f is defined on types (not concrete words). We state small lemmas with proof sketches and bookkeeping, and we flag minor clarifications for output.md.

Claim A (3-coloring matches (F1)). Why useful here: It resolves the quantifier mismatch that plagued 3SAT-style reductions; (F1) enforces universal pairwise constraints, exactly color(u) ≠ color(v) for edges.
- Source: Succinct 3-Coloring instance D: {0,1}^{2B} → {0,1}, circuit of size s; vertices V = {0,1}^B.
- Target semantics (mid-consistency (F1) only): Context types corresponding to vertices τ_u on both sides; the (F1) bridge between (τ_u, τ_v) must succeed (extend) iff either (i) D(u,v)=0 (non-edge; vacuous) or (ii) D(u,v)=1 and f(τ_u) ≠ f(τ_v).
- Implementation sketch: When S is colored, the bridge launches a row-by-row, radius-1-checked U-simulation on input (D,u,v) embedded in the inputs near the seam. Local rules guarantee: if D(u,v)=1 and colors equal, the bridge dead-ends; otherwise the bridge always extends. All other role pairings and inactive contexts allow trivial completions (⊥-plumbing). This aligns (F1) with 3-colorability.

Claim B (Type separation via boundary test family; B.1). Why useful here: Ensures at least 2^B distinct context types τ_u exist, allowing f to encode a color per vertex.
- Parameters: Choose integers B = s^{c0}, β = s^{c1} with 1 ≪ c0 ≪ c1 so that β ≥ B and ℓ_pump = 2^{Θ(β^4)} = 2^{poly(s)}.
- Reserved test boundary assignments: Fix one boundary-input 4-tuple a⋆. Reserve a collection J of size M := β distinct boundary-output 4-tuples {b_t : t ∈ [M]}; choosing b_t means “activate test id t”. All other boundary outputs are filler. This uses only O(β) reserved symbols (poly(s)).
- Input layout inside τ_u: The input track near the left end contains (i) a mask table row M_t ∈ {0,1}^B for each t ∈ [M] (packed contiguously and self-delimited), and (ii) a vertex-index block RID(u) ∈ {0,1}^B stored once in a fixed phase near S. The right end is symmetric or carries only fillers (not used for separation). We require well-formedness by radius-1 local rules; malformed encodings are locally refutable by error chains (as in §3 of the reference), hence “inactive.”
- Local test protocol: Under the boundary assignment (a⋆, b_t), the out–out rules enable a pointer that (1) walks from the left boundary to read the t-th mask row M_t, (2) walks to the RID block, and (3) computes parity ⟨M_t, u⟩ mod 2 using a fixed U-simulation in O(B) steps, all radius-1 checkable. If parity = 1, the pointer can terminate in an accepting sink; if parity = 0, no accepting continuation exists (the DP gets stuck). For all other boundary-output assignments (non-reserved), we permit a trivial completion (⊥ buffers) so they don’t affect separation.
- Linear independence: Pick M ≥ B masks whose rows form a full-rank B×M matrix over GF(2); since M=β ≥B, this is possible. Then the signature map Sig(u) := (⟨M_t,u⟩)_{t∈[M]} ∈ {0,1}^M is injective on {0,1}^B. For the fixed boundary-input a⋆, the extendibility table for reserved outputs is exactly E_{w(u)}(a⋆)[b_t] = Sig(u)_t. Consequently, u ≠ u′ ⇒ Type(w(u)) ≠ Type(w(u′)).
- Radius/size: The checker is constant-radius (pointers and row-to-row tableau), uses a constant work alphabet, with β = poly(s) large enough to host reserved symbols. The mask table sits in the input (binary) and is read by the pointer; malformed tables are harmless due to error chains.

Claim C (Realization of exponentially many vertex context types; B.2). Why useful here: Guarantees that, among contexts w_1 S w_2 with |w_i| ∈ {ℓ_pump, ℓ_pump+1}, there are at least 2^B distinct types representing all vertices u.
- Using Claim B, fix for each u an input string W(u) that realizes the left block (table + RID(u)), a neutral S, and a right filler block; ensure via pumping (Lemma 14/15) that both sides have length ℓ_pump or ℓ_pump+1 and that replacement preserves type (Lemma 11). Then Type(W(u)) are all distinct and populate C (the context-type domain for f). The same construction symmetrically realizes right-side vertex contexts τ_v.

Claim D (Bridge gating for succinct adjacency; B.3). Why useful here: Implements the pairwise constraint “if edge then colors differ, else vacuous” under (F1).
- Input near both sides supplies (i) a copy of D’s encoding (as in the LBA proof, stored in binary and copied by outputs), (ii) the local RID blocks (u and v). Upon non-⊥ colors at S, the bridge runs U on input (D,u,v) for poly(s) steps; rules enforce success as follows:
  • If the simulation yields D(u,v)=0 (non-edge), accept irrespective of colors by enabling a trivial acceptor after the run.
  • If D(u,v)=1 (edge), accept iff two color tokens at S are different; if equal, dead-end. The “color-different” test is purely local across the S seam.
- Robustness: Inactive/malformed blocks admit the standard error chains; colored S then cannot complete and hence forces f to map such types to ⊥.

Claim E (From (F1) to classification hardness; B.4). Why useful here: Transfers hardness from (F1)-feasibility to the 3-way decision by neutralizing (F2).
- Add a global ⊥-filler language for repetitions so that for any context (w_1,S,w_2) and any z≥1, w_1^z and w_2^z can be labeled with ⊥ (independent of inputs). Thus (F2) holds vacuously for any f. Therefore, deciding whether (F1) holds (i.e., whether G is 3-colorable) is as hard as the 3-way classification on our instances.

Proof sketches for soundness/completeness (FFE(F1) ↔ 3-coloring)
- Completeness: Given a proper 3-coloring χ: V → {RED,GRN,BLU}, define f(τ_u)=χ(u). For any pair (τ_u,τ_v), the bridge computes D(u,v); if non-edge it accepts; if edge, χ(u)≠χ(v) by proper coloring, so acceptance follows. Inactive contexts mapped to ⊥ are trivially satisfied.
- Soundness: If f satisfies (F1), define χ(u)=f(τ_u). For any edge (u,v), (F1) requires that the bridge succeeds; the only way it can succeed on edges is with χ(u)≠χ(v). Hence χ is a proper 3-coloring.

Instantiation details to verify next (concrete, checkable)
1) Pointer/test gadget (radius-1): Specify the constant-size out–out automaton for the test: states “go-to-row t”, “scan mask bits”, “accumulate parity”, “jump to RID”, “accumulate parity”, “accept if 1”; verify all transitions read-only from input and are nearest-neighbor.
2) Mask addressing with small boundary ID: Limit test IDs t to [β], each encoded by one of β reserved symbols. In input, arrange the mask table as β rows of length B with clear row delimiters; the “go-to-row t” stage follows row delimiters counted via the ID implicit in the chosen boundary symbol. Local rules ensure the pointer’s row-counter matches the selected symbol; wrong row ⇒ dead-end (so the DP cannot cheat by reading a different row).
3) Existence of contexts of length ℓ_pump: Use pumping/replacement to pad left/right to prescribed lengths without changing types, ensuring that (i) the reserved boundary tests remain available at the outermost two boundary nodes, and (ii) the interior test and RID regions remain intact.
4) Bridge TM: Use the same row-by-row U-simulation as in §3 to evaluate D(u,v) in poly(s) time. Errors are locally refutable; malformed inputs cannot permit a colored-S completion, making such contexts inactive.
5) Size bookkeeping: Σ_out tracks: roles/phases, 3 colors + ⊥, error alphabet, and U’s work alphabet are constant; plus β many reserved test symbols and a constant amount of plumbing. Tables Cin–out, Cout–out remain size poly(β)=poly(s). Input length is unbounded and holds the mask table, RID blocks, and circuit D wherever needed.

Toy example (sanity)
- Take B=2, β=8, masks M_t ∈ {00,01,10,11,01,10,11,00} (first 4 rows linearly independent). For u∈{00,01,10,11}, the reserved boundary outputs b_t induce an extendibility pattern equal to the parity vector across the first 4 tests; the four τ_u types differ on these 4 bits. On the bridge, if D is a 4-cycle adjacency, f(τ_u) = u mod 3 gives a valid coloring; pairs on edges with equal colors are forbidden locally.

Notes/obstacles
- Mask-table on input vs. grammar size: We deliberately read mask rows from input to avoid hardwiring O(β·B) bits into Cout–out; only the per-test control (β distinct boundary tokens) are baked into Cout–out.
- Dependence only on type: The separation relies on fixed boundary-input a⋆ and the reserved family {b_t}. For any two words with the same input content (table + RID) but otherwise different interiors, the existence or non-existence of a completion under (a⋆, b_t) is forced by the local test, hence is type-invariant. Distinct u’s yield distinct yes/no pattern across {b_t}, so types differ.
- Ensuring non-edges are vacuous: The bridge must accept for D(u,v)=0 irrespective of colors. We implement this by enabling a finishing acceptor after the U-run concludes “0”, independent of S’s colors.

Minor clarifications/suggestions for output.md
- Types and fixed inputs: In “Definitions (radius 1)”, clarify that E_w(a) is with respect to the fixed input string on the entire path; the parenthetical “interior inputs may be arbitrary” could be read as allowing the verifier to choose internal inputs. For our model, the input word is fixed; the extension existentially quantifies outputs only.
- Context set C size: Where LCL_classification.pdf states “Note |C| ≤ ℓ_pump,” consider adding a short justification: a context type is a specific element of the global type set T realized by a word of the form w_1 S w_2 with |w_i| ∈ {ℓ_pump,ℓ_pump+1}; hence |C| ≤ |T| = ℓ_pump.

Next steps
- Write the explicit local rule set for the boundary test gadget and prove the Type-Separation Lemma rigorously (injectivity from M≥B linearly independent masks).
- Specify the seam U-simulation interface and the local rule that gates acceptance by “D(u,v)=0 or colors differ.”
- Package the reduction formally: map D ↦ P_D with β=poly(s), prove “G 3-colorable ⇔ (F1)-feasible f exists”, and add the ⊥ repetition to neutralize (F2). This will give a clean NEXPTIME-hardness statement for the 3-way classification.


=== prover-04.out.json (progress_md) ===
Ideas: boundary-probe separation for vertex types; succinct 3-coloring bridge
- Pivot retained: Reduce Succinct 3-Coloring (NEXP-complete) to Feasible-Function Existence (F1) for β-normalized, r=1 LCLs on oriented paths. Colors at the S-window implement the vertex coloring; the bridge between two contexts simulates D(u,v) and enforces “≠” iff D(u,v)=1.
- New ingredient (type separation without per-type tailoring): Design a fixed family of boundary-output “probe patterns” Q_j (one per bit index j∈[B]) that, when set on the four boundary nodes of a context, uniformly trigger a radius-1 pointer that reads the j-th bit of an interior u-block positioned O(1) from S. The existence (extendibility) of a completion under probe Q_j equals that bit. Therefore the vector (ext_Q_j)_{j=1..B} encodes u, and different u yield different types. This avoids the flawed idea of “programming arbitrary boundary truth tables per type”.

Clean statements (to be proven/verified)
- Lemma A (Probe-bits). There exist global Cin–out, Cout–out and, for the left-side vertex-context shape W(u) (|W(u)|∈{ℓ_pump,ℓ_pump+1}), a fixed family of boundary-output 4-tuples {Q_j: j∈[B]} such that, for any boundary input assignment a, Gw:=W(u) has a legal completion with boundary outputs Q_j on its four boundary nodes iff the j-th bit of u equals 1. Consequently, Type(W(u))≠Type(W(u′)) for u≠u′.
  Why useful: Gives 2^B distinct vertex context types using only B=poly(s) probes, well within the β^4 boundary assignments. The construction is uniform and radius-1 (probes trigger a constant-symbol “probe role” that spawns a pointer reading the port region where u’s bits are pre-exposed near S; failures dead-end).
- Lemma B (Canonical vertex-context family). There exist two canonical context shapes L(u):=W_L(u) S F_R and R(v):=F_L S W_R(v) with |W_L(u)|,|W_R(v)|∈{ℓ_pump,ℓ_pump+1} and fixed fillers F_L,F_R (no vertex data) such that:
  (i) L(u) and R(v) are active (contain well-formed u- or v-blocks anchored O(1) from S),
  (ii) Type(L(u)) (resp. Type(R(v))) is determined by u (resp. v) via Lemma A, and
  (iii) any other context type without such a block is inactive: any non-⊥ color at S leads to a locally-detectable dead end; ⊥ always extends via neutral plumbing.
  Why useful: Ensures exactly one (or at least a unique canonical) type per vertex; non-vertex types force f(·)=⊥ by (F1) universal quantification.
- Lemma C (Bridge semantics for 3-coloring). There is a fixed, radius-1 seam gadget (placed across the concatenation of L(u) and R(v) in an (F1) instance) that locally simulates a universal TM U for poly(s) steps to evaluate D(u,v) using:
  (i) a copy of D stored in each block (copied from Σ_in via Cin–out), and
  (ii) the B-bit ports of u (on the right edge of L(u)) and v (on the left edge of R(v)).
  The bridge admits a completion iff [D(u,v)=0] or [D(u,v)=1 and the two S colors differ]. Malformed simulations are locally refutable (standard error-chain); spurious accept is impossible due to row-to-row radius-1 checks.
  Why useful: Matches (F1)’s universal pair check with “≠ on edges, trivial on non-edges”.

Sketch of constructions (radius-1 and uniform)
- Vertex block (near S): A constant-role phase track places a “port zone” of length Θ(B) immediately adjacent to S inside W_L(u) (to the right) and W_R(v) (to the left). This port zone carries the B bits (u_1,…,u_B) (resp. v) twice with parity/check bits; its layout is enforced by Cout–out (deterministic pattern given activation at S). The rest of the block includes a self-delimiting header and a RUN zone encoding U’s tableau on input D (copied from the input track) and the index, all standard and locally checkable.
- Probe patterns Q_j: Four special outputs on the boundary (two per side of the word) encode a “probe-bit j” token with local phase. Cout–out has rules: if a probe token sits on the boundary, the unique legal continuation from that boundary is a finite-state pointer that advances into the port zone, lands on the j-th cell, and requires its bit=1; otherwise no outgoing legal edge exists in the layered DP. This uses O(1) symbols and maintains radius-1 (pointer heads advance cell-by-cell with locally checkable direction and countdown in unary up to j encoded by constant number of “repeat until phase X” steps; the step count is derived by walking, not stored in boundary symbols). Result: extendibility under Q_j discriminates u_j.
- Bridge simulation: In wa S1 wb wc S2 wd with wa S1 wb=L(u), wc S2 wd=R(v), the seam region wb wc contains a fixed-width (poly(s)+O(B)) “bridge RUN” where U takes as inputs (D, u, v) read from the adjacent port zones and computes d:=D(u,v). Cout–out enforces single-step tableau constraints, with local error-escape allowed only for malformed inputs; a dedicated final row propagates d to a 1-bit flag near S2. Separate local rules check “if d=1 then colors at S1,S2 must be unequal; if d=0 then no constraint on colors”.

Correctness of the reduction (succinct 3-coloring ⇒ (F1) and vice versa)
- Completeness: If G is 3-colorable, fix χ: {0,1}^B→{RED,GRN,BLU}. Define f on vertex types by f(Type(L(u))) = χ(u) and f(Type(R(v))) = χ(v); define f(τ)=⊥ for all inactive (non-vertex) types. For any ordered pair of contexts in the (F1) check, either both are vertex-types (u,v): the bridge computes D(u,v) and enforces χ(u)≠χ(v) when D=1 (holds by proper coloring), or at least one is inactive, in which case ⊥ plumbing makes the DP succeed. Hence (F1) holds.
- Soundness: If some f satisfies (F1), read χ(u) := f(Type(L(u))). For any u,v with D(u,v)=1, the bridge between Type(L(u)) and Type(R(v)) must be extendible; the simulation forces χ(u)≠χ(v). Thus χ is a proper 3-coloring. Non-vertex types cannot be mapped to a color, else some pair (inactive, anything) would violate (F1) due to the local “colors-only-when-vertex” gating; therefore setting them to ⊥ is necessary and consistent.

Neutralizing (F2) and hardness for the tri-class classifier
- As in previous rounds, add a global ⊥-filler language permitted on repeated sides w_i^z independent of context; then (F2) is true for every f by Lemma 1 in output.md. Therefore the classifier answers O(1) iff (F1) holds, and Ω(n) otherwise (Theorem 8 machinery). Since feasible-function existence (mid-consistency) is NEXPTIME-hard by the reduction above and in NEXPTIME (output LCL_classification.pdf), the three-way classification is NEXPTIME-hard.

Examples and sanity checks
- Tiny case B=2: u∈{00,01,10,11}. Define Q_1,Q_2 probes. For the four left-contexts L(u), the 2-bit vector (ext_Q1, ext_Q2) equals u. The bridge runs D on pairs and requires color-inequality only on edges.
- DP perspective: The probe under Q_j forces a unique finite path in the layered automaton that reaches the j-th port cell; existence of an outgoing edge at that cell hinges on the bit=1. The bridge tableau likewise becomes a layered composition check; any inconsistency blocks all paths, so the DP precisely mirrors the existence of a legal completion.

Obstacles / things to make explicit next
- Probe pointer encoding: Make the boundary probe tokens and the in-block “port zone” phases explicit, with a table showing (current symbol, next symbol) pairs permitted by Cout–out. Verify that the pointer is guaranteed to stop on the exact j-th cell (walk semantics) without storing j in the boundary symbol (to keep alphabet constant).
- Seam I/O interface: Specify how the bridge RUN reads u and v: either by duplicating the B-bit ports directly adjacent to the bridge (preferred), or via pointers with locally checkable handshakes. The former is cleaner and fits ℓ_pump.
- Error-chain integration: Ensure malformed blocks are always completable via the error alphabet (like §3), and that the color-at-S activation is allowed only when the vertex role is present, preventing spurious constraints on inactive types.
- Size bookkeeping: Enumerate the tracks and show |Σ_out| = β = poly(s) suffices: roles/phases O(1), colors+⊥ (4), error alphabet O(1), U’s work tape O(1), plus finitely many probe/pointer states O(1). The “O(B)-long” ports are spatial, not alphabetic.

Gaps/notes on output.md
- The core lemmas (type bound, composition, periodicity, finite-Z, DP) are sound and sufficient for our verifier. Minor clarification: in Theorem 5 the DP assumes fixed input string; the construction adapts by restricting layer i to Cin–out[Input(i)]. No action needed.
- The bound Z≤ℓ^2 (Cor. 4) is non-tight but usable; we will carry it as-is for (F2) neutralization.

Next steps (auditable deliverables)
1) Formalize Lemma A with a concrete probe alphabet and Cout–out snippet; prove the “iff u_j=1” claim rigorously.
2) Specify the canonical L(u), R(v) layouts with exact offsets: positions of the port zones, header footprint, and RUN rows. Provide a bound O(poly(s)) for occupied length.
3) Write the seam tableau interface and prove Lemma C: that the only accepting completions correspond to the correct d = D(u,v) and enforce inequality when d=1.
4) Package the reduction C↦P_D, including ⊥-filler for (F2), and finalize the completeness/soundness argument with explicit references to the output lemmas (replacement, pumping) to guarantee existence of required contexts within lengths ℓ_pump or ℓ_pump+1.


=== Verifier (summary_md) ===

=== Verifier (verdict) ===
partial success

