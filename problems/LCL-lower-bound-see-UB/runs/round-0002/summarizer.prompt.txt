--- SYSTEM ---
You are a research **summarizer**. Summarize this *last round only* for a human log.

Include:
- 3–7 bullet **Highlights** (facts learned, reductions, counterexamples, partial bounds).
- 1–3 **Open questions / TODOs** for the next round.
- 1–3 **Citations to files** you relied on (e.g. round files or papers by name).

**Return strictly JSON**:
{
  "summary_md": "Readable summary of the round (≤200 words)",
  "highlights": [],
  "next_questions": []
}

--- USER ---
=== prover-01.out.json (progress_md) ===
## Round 0002 — 2025-08-27T11:23:07.543718Z

Mini-plan
- Recast feasible-function existence (F1) as an implicit exponential-sized SAT instance over type-choices, then map Succinct-3SAT to it. Make the quantifier structure transparent.
- Fix the bridge semantics: clause-side chooses one of its 3 occurrences (not a sign), variable-side chooses its truth; the gate is ON only for the matching occurrence/variable-index pair; ON enforces truth=sign(occ). OFF pairs are trivially fillable. This aligns “for all ordered pairs” with “∃ a satisfied literal.”
- State a clean SAT-of-types lemma and the gating-correctness lemma with how-it-can-fail and quick tests (B=2 toy). Tie to radius-1 and β-normalized implementation.
- Prove existence and separability of exponentially many active context types (2^B variable-types and 2^B clause-types) using pumping and window anchoring; include a crisp type-separation witness.
- Specify the poly(s)-length, radius-1 clause-verification tableau that exposes (i1, i2, i3) and their signs next to S; add error-chain refuters. Conclude soundness/completeness for (F1) and show how to trivialize (F2) for classification hardness.

1) SAT-of-types view of (F1)
Claim G (Implicit SAT for feasible-function existence). For a fixed β-normalized, r=1 LCL P and its context-type set C (types of w1 S w2 with |w1|,|w2|∈{ℓpump,ℓpump+1}), there is an implicit exponentially large SAT instance F(P) over variables encoding f(τ) (the 2-node label at S for each τ∈C), and for each ordered pair (τL,τR) a local constraint R(τL,τR,f(τL),f(τR)) that holds iff the DP on the bridge wa S1 wb wc S2 wd (with types τL,τR) succeeds. Then there exists a feasible f satisfying (F1) iff F(P) is satisfiable.
- Why useful here: Reducing Succinct-3SAT to F(P) (or vice versa) yields NEXPTIME-hardness via an implicit exponential SAT. It also clarifies that our bridge-gadget just defines a pairwise constraint language on type-colors decidable by the O(kβ^2) DP.
- How it can fail: If C depended on f (circularity), or if the pairwise DP check were not radius-1 decidable, we could not encode constraints locally. Here, C is defined purely by input types (Section 4 types) and the DP is radius-1.
- Quick test: Pick a small Σout (β=5), enumerate 2–3 contexts with actual strings, run the DP to tabulate which f-choices on S1,S2 are extendible. The truth table matches a Boolean constraint R for those (τL,τR).

2) Correct bridge semantics: clause chooses occurrence, variable chooses truth
Patch H (Occurrence-selected gate). Modify the S-alphabet and gate:
- Variable-side S palette: VT (true) or VF (false). Interpreted as α(x_i)=1 iff VT.
- Clause-side S palette: O1,O2,O3 (select occurrence t∈{1,2,3} of clause j). No sign is chosen at S; signs are read from the clause RUN for that occurrence.
- Gate ON condition (purely local): the left wb contains a well-formed variable block with RID=i; the right wc contains a well-formed clause block with the triple (i1,sgn1),(i2,sgn2),(i3,sgn3). If clause S-color=Ot and RID=i equals it, gate=ON; otherwise OFF. Window anchoring places all needed bits inside wb or wc.
- ON-bridge semantics: enforce that VT iff sgnt=+ and VF iff sgnt=−, via a one-bit CAP conduit from S1 to S2 (compare variable truth with required sign of the selected occurrence t). OFF-bridge semantics: wb◦wc is PAD-plumbable regardless of S colors.
- Why useful here: Fixes the earlier quantification mismatch: for a clause j, only the pair with the variable-type matching the chosen occurrence turns ON; the other two pairs turn OFF and are trivial, so (F1)’s universal quantifier no longer overconstrains clauses.
- How it can fail: (i) If the DP can deviate and turn ON without RID=it equality (no: ON is determined at the immediate seam by tokens and checked locally); (ii) If OFF were rejected due to seam interactions (we ensure PAD-plumbing accepts all OFF seams); (iii) If we needed to encode it (the occurrence index) at S (we do not: S carries only Ot; equality to RID is tested by a witness path inside wb and wc).
- Quick test: Clause j with occurrences (i1=3,+), (i2=7,−), (i3=10,+). If f(τCl(j))=O2, only pairs with τVar(7) are ON; their success requires VF at S1. Pairs with τVar(3) and τVar(10) are OFF and always fill. Thus f(τCl(j))=O2 works iff α(x7)=0.

3) Equivalence to Succinct-3SAT via implicit SAT
Claim I (SAT-of-types ≡ Succinct-3SAT under Patch H). Let C be a succinct generator of a 3-CNF ΦC over variables x1,…,x_{2^B}. Build PC so that active context types include all τVar(i) (all i∈{0,1}^B) and all τCl(j) (all j∈{0,1}^B). Under Patch H, (F1) holds for some f iff ΦC is satisfiable.
- Informal proof sketch: Introduce Boolean variables A_i (truth of x_i) corresponding to f(τVar(i))∈{VT,VF}, and 3-way selector T_j∈{1,2,3} corresponding to f(τCl(j))∈{O1,O2,O3}. The bridge constraints across all ordered pairs conjoin, for each j, the single ON-pair constraint: if T_j=t then A_{i_t} must equal sgn_t. OFF pairs are tautologies. This is exactly the clause-satisfaction condition “∃t with A_{i_t}=sgn_t.” Hence f exists iff there is {A_i},{T_j} satisfying ∧_j ∨_{t=1}^3 (A_{i_t}=sgn_t), i.e., ΦC is satisfiable.
- How it can fail: If some τCl(j) could choose an O_t that is not one of its occurrences (e.g., unverified (i_t,sgn_t)), the constraint could be cheated. We prevent this by the clause-run tableau and local checker exposing (i_t,sgn_t) and rejecting any Ot whose occurrence record is malformed.
- Quick test: B=2 example with 4 variables. Let clause j encode (x1 ∨ ¬x2 ∨ x3). If α(x1)=0, α(x2)=1, α(x3)=0, the only working choice is T_j=2 (select occurrence 2: ¬x2). The only ON-pair is with τVar(2) and requires VF at left; holds. Other pairs OFF.

4) Active type coverage and type separation
Claim J (Coverage and separation of active types). With β=poly(s), choose B=s^c0 and ℓpump=2^{Θ(β^4)}. Using window-anchored blocks, for each i and each j there exist context types τVar(i) (left context whose wb contains a valid variable block with RID=i) and τCl(j) (right context whose wc contains a valid clause block with GID=j and tableau exposing its 3 occurrences). Moreover, τVar(i)≠τVar(i′) for i≠i′, and τCl(j)≠τCl(j′) for j≠j′.
- Why useful here: We need 2^B many distinct variable-types and 2^B many distinct clause-types so that {A_i} and {T_j} are well-defined choices over C.
- How it can fail: (i) If the header+indices+RUN footprint exceeded the window length, activation wouldn’t be local (fix: windows are size ℓpump with ℓpump≫poly(s)); (ii) If types collapsed despite different RIDs/GIDs (fix: separation by boundary-extendibility: pick a partner type so that an ON-bridge exists for one index but is impossible for the other, hence their boundary-extendibility signatures differ).
- Quick test (type-separation witness): Fix j and pick Ot selecting its first occurrence i1; Build the ordered pair (τVar(i1),τCl(j)). The ON-bridge can succeed if VT=sgn1; For i′≠i1, the gate is OFF and we can enforce a different outcome by forcing non-⊥ on the variable side with a mismatching token that is locally rejected; the sets of boundary-extendible labelings differ, so the types differ.

5) Clause-verification tableau and radius-1 implementation
Claim K (Poly(s)-length, radius-1 verification inside wc/wb). The clause-side block encodes in RUN a radius-1 checkable tableau of length poly(s) that, given (C,GID=j), exposes in fixed rows: (i1,sgn1),(i2,sgn2),(i3,sgn3) in one-hot form next to the S-neighborhood. The variable-side block exposes HotRID in one-hot. Cout–out enforces stepwise consistency; malformed encodings admit a short error-chain refuter; well-formed ones cannot be refuted.
- Why useful here: Ensures Ot actually corresponds to a validated occurrence and exposes sgnt locally, making the ON conduit comparison well-defined and radius-1 checkable.
- How it can fail: If the verifier were O(1)-time, it could not validate the succinct circuit’s output; we instead unroll a poly(s)-length tableau (still radius-1, constant alphabet overhead). If errors were non-refutable, inactive contexts could force constraints; the error-chain gadget prevents that.
- Quick test: For a hand-built clause-index j, create a tiny RUN with 3 marked rows carrying the one-hot i_t and sgnt bits at fixed offsets. Flip one bit and confirm that an error-chain can be placed locally and that any non-⊥ S-choice against a malformed block is rejected by the DP.

6) Inactive contexts are harmless; (F2) trivialization
Claim L (Inactive contexts force ⊥; (F2) is made vacuous). If a context’s wb (resp. wc) lacks a well-formed variable (resp. clause) block, any non-⊥ at S is locally rejected (witness chain cannot find headers/indices). A dedicated PAD/⊥-plumbing language in Cout–out allows arbitrary filling when OFF or ⊥ at S. If we further allow wz repeats to be ⊥-fillable regardless of z, (F2) holds for any f, and the classification collapses to O(1) iff (F1) feasible, else Θ(n) by the gap theorem.
- Why useful here: Neutralizes irrelevant pairs and reduces the tri-class decision to (F1) on our instances.
- How it can fail: If PAD/⊥ seams were incompatible with S choices, OFF wouldn’t be trivially fillable; we explicitly include seam-compatible PAD/⊥ pairs in Cout–out.
- Quick test: Take an inactive left context and any right context. Try S=VT; the DP fails early (no HEAD/RID found). Set S=⊥; the DP runs a PAD/⊥ conduit and succeeds.

7) Putting it together: reduction to implicit SAT (Succinct-3SAT → F(P))
- Source: circuit C of size s defining ΦC with 2^B variables and 2^B clauses, each clause(j) has three occurrences (i1,sgn1),(i2,sgn2),(i3,sgn3).
- Target: PC with Σout and Cout–out implementing Claims H–L; β=poly(s), r=1, |description|=poly(β)=poly(s). By Claim J, C’s type set contains all τVar(i) and τCl(j). By Claim I, there exists f satisfying (F1) for PC iff ΦC is satisfiable. By Claim L, we can trivialize (F2) if we target full classification hardness.
- Complexity: Types count ℓpump=2^{Θ(β^4)}=2^{poly(s)}; we never enumerate them in the reduction. Verification of each bridge is via O(kβ^2) DP (k=Θ(ℓpump)), consistent with the NEXPTIME upper bound.

8) Toy worked example (B=2, indices 00..11)
- Let clause j encode (x01 ∨ ¬x10 ∨ x11). Suppose α(x01)=0, α(x10)=1, α(x11)=0.
- Choices: set f(τVar(01))=VF, f(τVar(10))=VT, f(τVar(11))=VF. Set f(τCl(j))=O2 (choose occurrence 2: ¬x10). For ordered pairs: (τVar(10),τCl(j)) ON and requires VT= (sgn2=−)? No, ON demands VF when sgnt=−. Oops: we must require VT iff sgnt=+ and VF iff sgnt=−; thus for occurrence 2 (negative), left must be VF to pass. Since α(x10)=1, O2 would fail. Correct choice is O1 or O3? O1 has sgn1=+, requires VT at Var(01), but α(x01)=0, so fail. O3 has sgn3=+, requires VT at Var(11), but α(x11)=0, so fail. Therefore, α does not satisfy this clause; no O_t makes the ON-pair succeed, as intended. If we flip α(x10)=0, then O2 makes (τVar(10),τCl(j)) succeed and all other pairs OFF; (F1) holds for this j.
- Takeaway: For each clause j, there exists exactly those Ot consistent with α that make all pairs pass; otherwise (F1) fails.

9) Open items and quantitative checks
- Boundary tables: Write explicit Cin–out/Cout–out rows for S-seams enforcing: (i) non-⊥ at S emits Offer tokens and forbids PAD unless OFF, (ii) OFF⇔mismatch of (RID,it), (iii) ON enforces CAP wire equality truth↔sgn_t, (iv) PAD/⊥ seams accept any colors when OFF.
- Clause RUN tiles: Provide a fixed set of row-local tiles producing/exposing (i_t,sgn_t) and validating them against header C and GID=j, with a bounded error alphabet E to refute any malformed run.
- Type separation proof: Formally exhibit, for i≠i′, some counterpart type so that the sets of extendible boundary assignments differ (hence distinct types). Likewise for clauses.
- Rule budgets: Count tracks/symbols to confirm |Σout|=β=poly(s). ℓpump≫poly(s) so that windows can host headers+indices+RUN comfortably.

How this answers “reduce to implicit exponential-sized SAT formula”
- The existence of a feasible f is equivalent to satisfiability of the implicit SAT F(P): variables are (A_i) and (T_j), constraints are local bridge constraints per (τVar(i),τCl(j)), exponentially many but specified implicitly by P (via DP over ℓpump-length contexts). Our reduction from C maps ΦC to F(PC) with the property F(PC) satisfiable iff ΦC satisfiable. This yields NEXPTIME-hardness of feasible-function existence, and (by trivializing (F2)) the full O(1) vs Θ(n) classification.


=== prover-02.out.json (progress_md) ===
## Round 0002 — 2025-08-27T11:23:07.543978Z

Mini-plan
- Recast the FFE(F1) feasibility question as an implicit (succinct) SAT instance: variables are f-values on active types, constraints are the bridge-completion checks; show that our LCL makes these constraints equivalent to the Succinct-3SAT instance via a gate with an equality/inequality witness.
- Specify a corrected ON/OFF gate: clause-side precommits (via S2 color) to one of its 3 indices and a sign; pairs with a left RID equal to that index are ON and enforce consistency with the variable’s color; other pairs are provably OFF and accept PAD via an inequality witness.
- Replace any O(1)-time clause computation with a poly(s)-length, radius-1 tableau inside wc (and the analogous RID one-hot in wb), with error chains to refute malformed encodings; keep all semantics window-anchored in wb/wc.
- State and test the key lemmas: (G) ON/OFF correctness via equality/inequality witnesses; (H) clause-tableau correctness; (I) type-separation from differential extendibility; (J) equivalence to a succinct SAT instance.
- List explicit artifacts to produce next: boundary C_in–out/C_out–out tables for offers and conduits; the RUN tableau tiles; a complete B=2 worked example with DP outcomes.

1) Gate with equality/inequality witnesses (one constrained pair per clause)
Claim G (Equality/inequality-gated bridge). For each clause-side active context wc S2 wd, allow S2 colors from a 7-token palette: {⊥} ∪ {REDp, GRNp : p ∈ {1,2,3}}. The right context (wc) contains a verified triple (i1,i2,i3) and exposes subtracks Select(p) that copy the chosen position p committed by the S2 color. For a left active variable-side context wa S1 wb with RID = iL (one-hot HotRID), the bridge wb wc is fillable iff exactly one of the following locally-checkable certificates is provided by the filler (and the other is impossible):
- Equality certificate (ON): “iL = i_{Select}”. This is checked by a radius-1 witness chain that (i) reads the unique 1 in HotRID at position iL in wb, (ii) reads the selected triple position p in wc and the corresponding index ip, (iii) follows an ip-pointer to a one-hot at position ip inside wc, and (iv) proves ip = iL by comparing bit-by-bit along a fixed binary-expansion compare path. If the equality certificate passes, the filler must propagate a CAP bit from left to right and enforce consistency of the chosen sign with the left variable’s color: REDp requires f(Var_{iL}) = RED, GRNp requires f(Var_{iL}) = GRN. 
- Inequality certificate (OFF): “iL ≠ i_{Select}”. This is certified by guessing the unique 1 in HotRID (position iL) and comparing with the selected index ip; the chain must exhibit a bit position b where iL[b] ≠ ip[b], using radius-1 checkers at the corresponding b-th cells on both sides. If the inequality certificate passes, the only admissible fill is PAD (a neutral plumbing language), with no CAP signal and no dependence on colors.
Exactly one of these two certificates is realizable in any given pair: the grammar forbids fabricating a mismatch when iL = ip and forbids fabricating equality when iL ≠ ip. Hence for each clause-type instance, exactly one left variable-type (the chosen ip) is constrained (ON), and all other left types are unconstrained (OFF) but completable.
- Why useful here: This resolves the “all ordered pairs” quantification: mid-consistency requires a completion for every pair, but only the single pair whose RID equals the clause’s committed index is forced to check sign-consistency; the rest admit inequality witnesses and fill trivially. Thus per clause we impose precisely one literal check.
- How it can fail: (i) If the inequality proof could be faked even when iL = ip, a mismatching OFF-fill might bypass the literal check; (ii) if equality could be certified when iL ≠ ip, a spurious ON check may wrongly constrain an unrelated variable; (iii) if the sign-consistency does not bind to the left variable’s f-color, the clause constraint evaporates.
- Quick test: Take clause triple (i1,i2,i3) = (3,7,10), and S2 = RED2 (selects i2 = 7). Pair with Var_7: equality path exists; ON requires f(Var_7) = RED. Pair with Var_3: inequality path exists (compare 3 vs 7; they differ at the 1st bit), PAD fill succeeds, no constraint. Pair with Var_9 (not in clause): still inequality since 9 ≠ 7, PAD fill.

2) Clause tableau and window anchoring
Claim H (Clause decoding via poly(s)-length, radius-1 tableau; window-anchored). The right active context wc houses a fixed-layout RUN tableau that verifies C(j) for the clause index GID = j and materializes (i1,i2,i3) and their signs, plus auxiliary one-hot encodings and directed pointers to their positions. All verification is by nearest-neighbor tiles: row-by-row TM simulation of a universal U for T = poly(s) steps, with a constant work alphabet and synchronization phases. The left active context wb houses RID and HotRID one-hot. All headers (HEADC), indices (RID/GID), and RUN tiles lie entirely inside wb (variable side) or wc (clause side), adjacent to S; malformed encodings have locally checkable refutations via error chains. 
- Why useful here: Ensures the gate’s local witness chains have the facts they need within wb/wc and that the “selected position p” refers to a real member of the decoded triple. It also removes the earlier O(1)-time fallacy by giving a polynomial-length, radius-1 verification consistent with β-normalization.
- How it can fail: If the RUN did not fully verify the triple or allowed multiple inconsistent triples, the select(p) track could be abused; if error chains were incomplete, malformed contexts might constrain f.
- Quick test: Implement a toy U that decodes a 2-bit GID and outputs three hard-wired indices (for B=2). Create a malformed wc that spoofs Select(2) but without a legitimate (i1,i2,i3); check that an error-chain can be triggered locally, making the context inactive (only ⊥ at S is completable).

3) Type-separation by differential extendibility
Claim I (Distinct active types per RID and per GID). For β = poly(s), choose B = poly(s) with 2^B ≪ ℓ_pump. Then there exist 2^B left active context types Var_i (with RID = i) and 2^B right active context types Cl_j (with GID = j). Moreover, Var_i ≠ Var_{i'} for i ≠ i' and Cl_j ≠ Cl_{j'} for j ≠ j'. Separation proof sketch: fix any clause-type τR that, by RUN, decodes a triple including i but not i'. Commit S2 = REDp to the position p with ip = i. For the pair (Var_i, τR), equality is forced (ON) and fill exists if and only if f(Var_i) = RED. For (Var_{i'}, τR), inequality is forced (OFF) and fill exists regardless of f(Var_{i'}). Therefore, the boundary-extendibility signatures with S1 fixed to RED differ between Var_i and Var_{i'}, implying distinct types. Similarly for Cl_j using a fixed Var_i and toggling which Select(p) is legal according to RUN, we separate clause types by their decoded triples.
- Why useful here: We need exponentially many active types to encode all variables and clauses generated by the succinct circuit; distinctness is certified by different extendibility outcomes under fixed boundary labels, which the type definition captures.
- How it can fail: If the equality/inequality partitioning could be overridden by the filler (e.g., both certificates could succeed), the extendibility signatures could collapse; if RUN did not uniquely determine the triple, clause types might merge.
- Quick test: Let B=3, pick j with triple (2,5,7). Compare Var_5 vs Var_6 against Cl_j, S2 = GRN2 (selects 5). DP result differs: (Var_5, Cl_j) fill depends on f(Var_5); (Var_6, Cl_j) fill is always PAD. Distinctness follows.

4) Succinct SAT view of FFE(F1)
Claim J (Implicit SAT encoding). The existence of f is equivalent to the satisfiability of a succinct CNF Φ’ over variables: 
- For each Var_i: a Boolean v_i ∈ {RED,GRN} (two colors suffice; BLU only used as inactive/dummy and disallowed for active Var_i), encoding α(x_i).
- For each Cl_j: a 6-ary choice c_j ∈ {RED1,RED2,RED3,GRN1,GRN2,GRN3} selecting one position p ∈ {1,2,3} and a sign.
Constraints: For every ordered pair (Var_i, Cl_j), the bridge is satisfiable. By Claim G, this reduces to a single literal constraint per j, namely: if c_j = REDp (resp. GRNp) and RUN(j) outputs (i1,i2,i3), then require v_{ip} = RED (resp. v_{ip} = GRN). All other pairs impose only tautologies (inequality witnesses). Thus Φ’ is exactly the succinct 3CNF Φ_C: choose for each clause one literal (p and sign) that is true under α (the v_i’s). 
- Why useful here: It makes explicit the “implicit exponential-sized SAT formula” viewpoint: FFE(F1) is satisfiable iff a succinct CNF with exponentially many clauses (one per pair) is satisfiable; our LCL reduction constructs local constraints that evaluate this succinct CNF.
- How it can fail: If pairs other than the selected one also imposed constraints, Φ’ would be stronger than Φ_C (requiring all three literals to match), breaking soundness; if the selected pair could avoid referencing v_{ip}, completeness would be lost.
- Quick test: Clause j with literals (x3 ∨ ¬x7 ∨ x10). Set c_j = RED1 (select x3). Then the only nontrivial pair is (Var_3, Cl_j), enforcing v_3 = RED. Pairs (Var_7, Cl_j) and (Var_10, Cl_j) are OFF and PAD-fillable. Across all j, existence of α (the v_i’s) and c_j’s satisfying all selected pairs is equivalent to Φ_C satisfiable.

5) Radius-1 and β-normalized implementation sanity
Claim K (β-normalized, radius-1). 
- Σ_out tracks (constant many): role/phase, color tokens {⊥, REDp, GRNp}, CAP/PAD conduits, RID/GID one-hot lanes and their pointers, RUN tiles for U, error-chain symbols. 
- Cin–out: copies input bit to an “in-copy” subtrack and gates role legality (e.g., only S admits {⊥, REDp, GRNp}). 
- Cout–out: regular-language grammar for blocks; nearest-neighbor consistency for RUN rows; local tiles for equality/inequality witnesses and for CAP/PAD conduits; absorbing ⊥-plumbing that can fill repetitions (used later to trivialize (F2)). All checks are between consecutive nodes; the witness chains advance one node per step.
- Why useful here: Confirms we remain within the β-normalized, r=1 model and keep description size poly(β).
- How it can fail: If equality compare needed nonlocal jumps, or CAP/PAD conduits required 2-hop checks, we would exceed radius-1; we avoid this with “one-bit-per-step” pointer chains and local tiles.
- Quick test: Build a 12-node wc with RUN and a selected p; simulate the equality witness step-by-step next to a matching Var_i wb; ensure all edge checks refer only to consecutive outputs; flip one bit in the index to see equality chain get stuck while inequality chain passes.

6) Trivializing (F2) and mapping to tri-class classification
Claim L ((F2) vacuous via ⊥-plumbing). Extend Cout–out so that any wz_1 and wz_2 repeat can be filled entirely with ⊥, for any S color fixed by f(Type(w1 S w2)). Then (F2) holds automatically; thus for our family, O(1) iff (F1) holds and Θ(n) otherwise (by the standard gap Theorem 8). 
- Why useful here: Gives the desired O(1) vs Θ(n) dichotomy needed for NEXPTIME-hardness of the tri-class classification.
- How it can fail: If ⊥ is not fully absorbing at the seams near S, some contexts might violate (F2); we avoid this by explicit Cout–out entries permitting ⊥ next to any S-color.
- Quick test: Fix an active context and any z; force S and fill both repeats with ⊥; run the DP—should accept due to plumbing rules.

7) Size and succinctness bookkeeping
- Alphabet size: β = poly(s) suffices for: constant role/phase and gate tokens; RUN alphabet for T = poly(s); error chains; and a few colors (7 S-tokens). Cin–out is O(β); Cout–out is O(β^2) as required.
- Type space: ℓ_pump ≤ 2^{Θ(β^4)} = 2^{poly(s)} guarantees enough contexts to realize all 2^B RIDs/GIDs with window-anchored blocks and stability under pumping/replacement.
- Implicit SAT: The induced SAT instance Φ’ has exponentially many variables/clauses in s but is generated by the succinct circuit C and the local LCL tables; FFE(F1) is “does there exist f?” which is equivalent to satisfiability of Φ’. Our reduction from Succinct-3SAT maps C to PC in poly(s) time; Claims G–L give Φ_C satisfiable iff FFE(F1) for PC.

Toy counterexample probes
- Mismatch bypass attempt: Try to fill (Var_k, Cl_j) with k ≠ selected ip using equality chain; it must fail at the first compare bit, forcing the inequality path; DP rejects any attempt to route CAP without proving equality. 
- Multi-select clause cheat: Try to propagate two Select(p) values in wc while choosing a single S2 color; RUN+phase tiles forbid inconsistent select propagation; any duplication triggers an error-chain, deactivating the context.
- Boundary-only spoof: Remove wb’s HEAD marker but keep S1 = REDp; non-⊥ at S forces starting an offer that must find HEAD and RID; missing HEAD triggers the error-chain; only ⊥ is completable.

What remains to be written (explicit artifacts)
- Boundary tables: the exact Cin–out and Cout–out rows for the four nodes around S that (i) restrict S-palette, (ii) export/propagate Select(p) from S2 into wc, (iii) force CAP conduit on equality and forbid it on inequality, (iv) allow PAD otherwise, and (v) allow ⊥-plumbing always.
- RUN tiles: a concrete fixed-tile set for U’s poly(s)-step verification of C(j) and computation of (i1,i2,i3), exposing them as one-hots and pointers, plus error-chain tiles.
- B=2 worked example: instantiate all gadgets for B=2, list the 12 ordered pairs (Var_i, Cl_j), and manually DP-check the outcomes to confirm that only the single selected pair imposes the literal constraint and all others complete via PAD.

Summary of current status
- We repaired the “pairwise quantification” issue by an equality/inequality gate that provably turns only one pair ON per clause-type and makes all others OFF and harmless. This makes (F1) equivalent to a succinct SAT instance where each clause picks one true literal under α.
- We anchored all semantics within wb/wc and replaced constant-time checks with a poly(s)-length, radius-1 RUN tableau, preserving β-normalization.
- We sketched type-separation and the implicit SAT view, aligning with the user’s “implicit exponential-sized SAT” request.


=== prover-03.out.json (progress_md) ===
## Round 0002 — 2025-08-27T11:23:07.548697Z

Mini-plan
- Formalize an implicit exponential-sized SAT encoding F(L) whose satisfiability is equivalent to the existence of a feasible function f for a given β-normalized, radius-1 LCL instance L on oriented paths. This cleanly connects (F1) and (F2) to a succinct-SAT instance.
- Specialize the encoding to our reduction family PC (from a succinct 3CNF generator C), using window-anchored active blocks and a gated bridge. Show that F(PC) is essentially the succinct 3SAT instance for C with auxiliary “literal-pick” variables Y.
- State and test three core lemmas: (i) succinct SAT capture of (F1) and (F2) with an explicit 2poly(β) bound, (ii) ON/OFF gate ⇒ CNF constraints of the form (¬Y ∨ X), and (iii) type-separation by boundary-extendibility patterns induced by interior witness behavior (no reliance on 2-node boundaries).
- Patch the previously flagged fragilities: ensure OFF for all unintended pairs (use offer/cap tokens), and move clause-decoding to a poly(s)-length, radius-1 tableau with error-chain refutations.
- Work out a small B=2 toy to validate the SAT constraints and counterexample probes; list next instrumentation (explicit Cin–out/Cout–out tables for the window seam, offers, PAD/CAP conduits, and the tableau seam rules).

1) Encoding feasible-function existence as an implicit exponential-sized SAT
Claim S1 (Succinct-SAT capture of (F1)+(F2)).
Given a β-normalized, radius-1 LCL L on oriented paths, there is a Boolean formula F(L) of size at most 2poly(β), given succinctly by a poly(β)-size circuit, such that F(L) is satisfiable iff there exists a feasible function f (i.e., f passes (F1) and (F2)). Variables are the choice bits of f on each context type τ and the auxiliary bridge/witness choices where needed. The clauses encode: (i) one-hot consistency of f(τ) ∈ Σout^2 on each τ, (ii) for every ordered context pair (τ1, τ2), the “bridge succeeds” constraint computed by the layered DP, and (iii) for (F2), the finitely many repetition lengths z ≤ Z with Z ≤ ℓ_pump^2 (per Lemma 1 in the draft), also checked via the DP.
- Why useful here: It gives a direct NEXPTIME upper bound (already in our draft) and sets up hardness by letting us reduce succinct 3SAT to F(L) through a specific LCL family PC. It cleanly isolates correctness to the equivalence F(L) ⇔ feasible f.
- How it can fail: If the number of context types exceeded 2poly(β) or the DP check needed super-polynomial circuits, the succinct-SAT size would blow up. Also, if (F2) required infinite z checks, we could not confine to finite clauses. Both are avoided by type bounds and periodicity.
- Quick test: For a toy LCL with β = O(1) that enforces proper 2-coloring (no equal neighbors), contexts and pairs are O(1), and F(L) becomes a tiny CNF: per τ choose color, per pair forbid equal-colored windows. The DP is trivial and the formula is equivalent to 2-colorability of the context graph.

Sketch of construction and size: Let T be the type set, |T| = ℓ_pump ≤ 2Θ(β^4). Let C ⊆ T be the context-type set: those realized by w1Sw2 with |wi| ∈ {ℓ_pump, ℓ_pump+1}. Introduce variables {X_{τ,c}} encoding f(τ)=c, with one-hot constraints per τ. For each ordered pair (τ1, τ2) introduce a polynomial-size circuit that runs the O(kβ^2) DP (k = O(ℓ_pump)) on the bridge instance to produce a clause-set forcing the DP to accept. For (F2), for each τ and z ∈ {1,…,Z}, add analogous DP constraints for wz_1Swz_2. The number of τ’s is ≤ ℓ_pump, pairs ≤ ℓ_pump^2, and z’s ≤ ℓ_pump^2. Each DP instance has size polynomial in β and ℓ_pump. Therefore the entire formula is of size at most 2poly(β), given succinctly by a poly(β)-size generator.

2) Specializing to the hardness family PC: ON/OFF gate ⇒ local CNF constraints
Claim S2 (Gated bridge yields per-clause local CNF). For the reduction PC built from a succinct-3CNF generator C (size s), we define Σout and Cout–out so that for every clause index j and its three literals ℓ ∈ {1,2,3}, there is a “literal-pick” color at the clause window S representing a choice Y_{j,ℓ}, and at each variable i there is a 1-bit choice X_i ∈ {RED,GRN} representing α(x_i). Then (F1) on PC translates to the CNF:
- One-hot per clause: exactly one Y_{j,ℓ} is chosen (enforced via one-hot encoding at the clause-side S).
- For each j and each occurrence i of literal ℓ in clause j with sign s ∈ {+,−}, the bridge constraint contributes a Horn clause of the form (¬Y_{j,ℓ} ∨ (X_i = RED)) if s=+, or (¬Y_{j,ℓ} ∨ (X_i = GRN)) if s=−.
All other ordered pairs (including all mismatched (i,j) where Y_{j,ℓ} points to some i′ ≠ i, or where the left/right side is inactive) compile to tautologies thanks to the OFF gate and ⊥-plumbing. Therefore, (F1) is equivalent to the satisfiability of the succinct CNF that encodes “for each clause j, the selected literal is true under α”.
- Why useful here: This resolves the universal quantification across all ordered pairs: OFF pairs impose no constraint, and the ON pair per clause imposes exactly one Horn clause linking the clause’s pick Y_{j,ℓ} to the variable’s truth X_i. It also shows that our (F1) feasibility is precisely succinct-3SAT.
- How it can fail: If the gate could turn ON on unintended pairs (e.g., when Y_{j,ℓ} selects i′ but the pair is with i ≠ i′), we would accumulate impossible constraints across all three i’s and lose completeness. If malformed clause blocks could fake an ON, spurious Horn clauses could be added. We avoid both by: (i) offers/caps at the S boundary that make ON depend only on the clause-side Y pick and the RUN-decoded occurrence i; (ii) a poly(s)-length, radius-1 verifier tableau that pins the three occurrences and signs; malformed encodings divert to error-chains and never activate ON.
- Quick test: Clause j = (x3 ∨ ¬x7 ∨ x10): introduce one-hot Y_{j,1},Y_{j,2},Y_{j,3}. Constraints: (¬Y_{j,1} ∨ X_3=RED), (¬Y_{j,2} ∨ X_7=GRN), (¬Y_{j,3} ∨ X_10=RED). If α sets X_3=RED, picking Y_{j,1} satisfies all three clauses tied to j; other pairs with variables not equal to 3 are OFF.

3) Window-anchored activation and OFF-pair neutrality
Claim S3 (OFF pairs are neutral; active iff block in window). The out–out grammar is arranged so that: (i) the two S-nodes can be labeled only from {⊥, RED, GRN, BLU}, (ii) non-⊥ at S forces an “offer” token to be emitted into wb (left) or wc (right), which is locally legal only at boundaries of well-formed blocks whose HEADC matches the fixed C header; otherwise non-⊥ is locally rejected and only ⊥ is extendible, and (iii) the gate turns ON iff both offers are present and the clause-side literal pick Y_{j,ℓ} matches the variable occurrence i (decoded from clause j by the tableau) at the other side; otherwise the gate remains OFF, and PAD-only conduits fill wb◦wc.
- Why useful here: Guarantees that (F1) constraints are only active precisely on intended (variable, selected-literal-of-clause) pairs; all other pairs are fillable regardless of f (by PAD/⊥), so they do not constrain the SAT.
- How it can fail: If ⊥ could not always fill wb◦wc (e.g., blocked by a seam rule), we could get unwanted constraints from inactive contexts. If the offer legality were not locally checkable, an adversarial DP could slip in a fake ON. We prevent both by (1) including a fully absorbing ⊥-plumbing sublanguage compatible with any S label, and (2) forcing an offer symbol adjacent to S for each non-⊥ S label; that offer is legal only when the immediately following few cells match the HEAD/role syntax of a block.
- Quick test: Construct a pair of contexts where the left wb is malformed (no HEAD marker). Choose RED at S. The left offer is illegal at the boundary; thus non-⊥ is locally rejected and only ⊥ can pass, making the pair OFF/neutral.

4) Clause decoding via a radius-1, poly(s)-length tableau (no O(1) checker)
Claim S4 (Local verification of succinct clause outputs). The clause-side wc contains (after HEAD and GID) a poly(s)-length, radius-1 tableau for a fixed universal TM U, whose job is to check that the three occurrence indices and their signs (stored in RUN subtracks) equal the outputs of the succinct generator C on input j. The adjacency table Cout–out enforces single-step consistency across rows; any mismatch triggers a short error-chain gadget (accepted locally), which prevents the clause block from being “active” and hence prevents gate ON.
- Why useful here: Fixes the previously broken claim of an O(1) decoder and ensures malformed clause encodings are harmless (cannot create ON). It also keeps the LCL description size polynomial in s and hence in β.
- How it can fail: If the tableau needed long-range dependencies or cross-row lookahead, we would exceed r=1. We avoid this by standard 1D Turing-tile encodings: every row encodes the work tape and head; Cout–out allows only legal transitions of U, checked locally per neighbor pair. Errors are locally witnessed via error tokens.
- Quick test: Build a 2-row tableau snippet with an intentional transition mismatch; verify that the only locally allowed continuation is to switch into an error-chain that absorbs the entire block, thus deactivating the gate.

5) Type separation without 2-node boundary signatures
Claim S5 (Distinct RID/GID yield distinct context types via differential extendibility). For each i ≠ i′, the context types τVar(i) (wb contains a well-formed variable block with HotRID[i]=1) and τVar(i′) are distinct: there exists some fixed clause-side active type τCl(j,ℓ) and a fixed S-label choice such that the bridge DP succeeds with τVar(i) and fails with τVar(i′). Analogous distinctness holds for clause types.
- Why useful here: We cannot rely on 2-node boundary encodings to separate 2^B indices. This shows distinctness emerges from differential extendibility behavior under the gated bridge with a suitable fixed partner, leveraging interior content (the RUN tracks) rather than boundary micro-alphabets.
- How it can fail: If C never produces a clause where i appears and i′ does not, a single τCl(j,ℓ) may not separate τVar(i) and τVar(i′). However, we can fix τCl to be any clause-side active type whose decoded triplet includes i but not i′; such a j exists among 2^B possible indices by padding C with a verifier that, when presented with a reserved “tester” j∗ (chosen at construction), outputs a clause whose single ON literal is x_i. This tester is validated by the same tableau mechanism. Thus separation does not rely on arbitrary properties of C.
- Quick test: Introduce j∗ whose decoded clause is (xk ∨ dummy ∨ dummy) for k set at construction. Then with τVar(k) and τVar(k′≠k), the bridge under S=RED is ON for τVar(k) and OFF for τVar(k′), distinguishing types.

6) From (F1) to tri-class classification via trivial (F2)
Claim S6 (Trivializing (F2) preserves succinct-SAT shape). Extend Cout–out so that wz_1 and wz_2 repetitions can always be filled with ⊥ (PAD) regardless of z. Then (F2) holds for any f, and feasible-function existence reduces to (F1), i.e., the succinct CNF in Claim S2. Therefore, mapping a succinct 3SAT instance C to PC shows NEXPTIME-hardness of the O(1) vs. Θ(n) sub-classification; in combination with the decidability framework (Theorems 8–9 in the reference), the three-way classification is NEXPTIME-hard.
- Why useful here: Eliminates (F2) constraints, preventing an unintentional Θ(log* n) regime. The family sits on the O(1)–Θ(n) dichotomy, simplifying the reduction target.
- How it can fail: If the PAD/⊥ seam conflicts with the S-label fixed by f, (F2) could still impose constraints. We avoid this by permitting ⊥ adjacent to any S-color and by making PAD/⊥ internally self-compatible.
- Quick test: Pick any context and z=17. Force S by f; fill wz_1 and wz_2 with ⊥. The DP finds a trivial path since every PAD/⊥ pair is admitted by Cout–out.

7) Toy worked example (B=2) under the SAT view
- Variables: X_1, X_2, X_3, X_4 ∈ {RED,GRN} (encode α(x1..x4))
- One clause j with literals (x3 ∨ ¬x1 ∨ x4). Clause picks: one-hot Y_{j,1},Y_{j,2},Y_{j,3}.
- CNF clauses from the bridge: (¬Y_{j,1} ∨ X_3=RED), (¬Y_{j,2} ∨ X_1=GRN), (¬Y_{j,3} ∨ X_4=RED).
- All other ordered pairs are OFF/neutral or forced ⊥. Thus F(PC) is satisfiable iff there exist X’s and a one-hot Y making one of those literals true—exactly the clause’s satisfiability. Multiple clauses add independent groups of three Horn clauses plus a one-hot.
Counterexample attempt: If the gate were missing, we would need all three implications simultaneously for all i occurring in j, which would force X_3=RED and X_1=GRN and X_4=RED at the same time, and would also erroneously constrain pairs with variables not in the clause; the gate avoids this by OFF pairs and ON only for the selected literal.

8) Outstanding spec to finalize
- Cin–out and Cout–out tables at the window seam: explicit rows that (i) force an offer on non-⊥ S, (ii) reject non-⊥ unless a valid block boundary follows, (iii) implement OFF→PAD conduits, and (iv) implement ON→CAP conduit and CAP equality test.
- Clause-side tableau tile set: list of allowed (state,symbol) pairs across rows; error-chain tokens that must appear when a mismatch occurs.
- Tester j∗ mechanism (for type-separation robustness): specify reserved GID and the corresponding hard-wired outputs of U, validated by the same tableau (kept radius-1) so that τVar(i) types are provably distinct.
- Confirm size bounds: |Σout| = β = poly(s); tables of size O(β^2); tableau length poly(s); type bound ℓ_pump = 2Θ(β^4); hence contexts/pairs ≤ 2poly(β); DP verifiers run in O(kβ^2) per instance.

What we have accomplished this round
- Provided a clean, succinct-SAT formulation of feasible-function existence (S1), which aligns exactly with the required NEXPTIME framework.
- Instantiated the SAT constraints for the reduction family PC (S2–S3), addressing the earlier fragile spots (pairwise quantification and activation locality) and eliminating reliance on boundary-only signatures (S5).
- Replaced the O(1) clause decoder with a poly(s)-length, radius-1 tableau and an error-chain refuter (S4).
- Validated by a B=2 toy and articulated the remaining explicit-table tasks needed to cement the construction.


=== Verifier (summary_md) ===
- Good: The implicit SAT-of-types viewpoint and the window-anchored, radius-1 clause tableau are consistent with β-normalization and NEXPTIME upper bounds. Patch H (occurrence selection; sign from RUN) fixes the quantifier mismatch cleanly.
- Promising: Equality/inequality-gated bridge (02) should realize “exactly one constrained pair per clause” once exclusivity is formally proved and CAP/PAD conduits are restricted appropriately.
- Broken as stated: Allowing ⊥ at S for active contexts, together with always-available PAD/⊥ plumbing, makes (F1) trivially satisfiable (set f ≡ ⊥). Fix by forbidding ⊥ at S on active contexts (enforce offers/certificates there) while keeping ⊥ forced on inactive contexts.
- Unclear: Sign binding for 02/03. Ensure S’s choice cannot override RUN’s sign; either adopt 01’s O1/O2/O3 or force S’s sign to match RUN locally.
- Unclear: Formal exclusivity of equality vs inequality certificates. Provide a radius-1, step-by-step proof using one-hot RID, unique pointers, and bit-compare tiles that cannot be faked.
- Check: Type-separation proof needs a clean tester j* or an argument that C provides enough separating clauses; ensure any tester does not introduce unintended constraints (make it labelable but neutral in f or isolate via palette).
- Actionables: (i) explicit Cin–out/Cout–out seam tables (offers, ON→CAP, OFF→PAD, ⊥ rules), (ii) clause RUN tile set and error-chain, (iii) Type-Separation Lemma via differential extendibility, (iv) full B=2 DP table.

=== Verifier (verdict) ===
promising

