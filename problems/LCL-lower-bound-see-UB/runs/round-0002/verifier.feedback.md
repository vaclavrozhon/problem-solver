High-level assessment: All four reports move in a coherent direction (reduce Succinct 3-Coloring to (F1) by separating vertex types and simulating D(u,v) across the seam; neutralize (F2) with a ⊥-filler). The overall plan is promising and consistent with our DP/type framework. However, only informal sketches are given; several key points require correction or formalization before anything can move to output.md.

Major issues and corrections:
- Prover 01’s Lemma 1 (single fixed probe b⋆) is not viable as stated. With global rules fixed, a single boundary-output 4-tuple cannot distinguish 2^B many indices; the check “agree with a constant j-th bit of the target u” cannot depend on u unless u comes from the interior. If the probe only checks RID equals the adjacent input RID, then the test always accepts and cannot separate types. We need a family of probes indexed by boundary outputs (as in Provers 02/03/04) so acceptance depends on u.
- Consistency of f on the same u across multiple types: The proposed soundness arguments sometimes rely on the pair (τ_u, τ_u) enforcing equal colors. That is not guaranteed if D(u,u)=0 (typically true), because the seam accepts irrespective of colors for non-edges. Therefore we must either (i) engineer that there is exactly one “active” left-type and one “active” right-type per u (all other contexts are inactive and cannot carry colors), or (ii) enforce a same-u consistency constraint separately. The clean approach is (i): design canonical vertex-context shapes L(u), R(v) that are the only contexts allowed to place color tokens at S; all other contexts are inactive and any non-⊥ at S dead-ends locally.
- Error-chain robustness: In all probe and seam gadgets, ensure the “error alphabet” does not provide an alternative accepting continuation under a reserved probe. Under a reserved probe boundary pattern, the only legal continuation must be the deterministic pointer/run; if a check fails, there must be no error-escape. Conversely, in non-probe modes and for malformed interiors, an error-chain must exist to avoid constraining f.
- Radius-1 feasibility and alphabet sizing: Pointer/counting mechanisms that must reach the j-th port cell need either O(B) pointer states or an address field in the port zone. Both are acceptable because β is polynomial in s and can be chosen with c1 ≥ c0 so β ≥ B. Avoid claims that a constant-state pointer can hit arbitrary j without an address field.
- Definition of types vs fixed inputs: Be explicit that E_w(a) is computed with the interior input string fixed to that of w. Several sketches implicitly use this; we should state it clearly in output.md (a minor clarification only).

Promising directions to consolidate:
- Type separation: Prefer either (A) the per-bit probe family Q_j (Prover 04) with an O(B)-symbol address field in the port zone so that extendibility under Q_j equals u_j, or (B) the mask/parity probe family (Prover 03) with M ≥ B tests and an injective signature Sig(u) = (⟨M_t,u⟩) that is enforced by a deterministic pointer+RUN gadget. Both are radius-1 and use β = poly(s). Prover 02’s base-β^4 encoding of a probe index b is also fine but heavier than needed; using M = Θ(B) probes suffices to separate 2^B vertices.
- Canonical vertex contexts: Fix L(u) and R(v) shapes that alone unlock the “color-at-S” role; all other contexts must forbid color tokens at S (inactive). This avoids the need to prove equality of f on multiple types representing the same u.
- Seam gadget: The row-by-row 1D tableau simulation across the bridge that reads u, v from adjacent port zones and evaluates D(u,v) in poly(s) time is standard (nearest-neighbor checks); gate acceptance by (EDGE=0) or (EDGE=1 and colors differ). This is the right alignment with (F1).
- Neutralize (F2): The global ⊥-plumbing on repetitions is compatible with keeping (F1) unchanged. Just ensure it never alters S’s positions or the “vertex role” gating.

Concrete next steps (what to write down explicitly so we can verify by the O(kβ^2) DP):
1) Pick and fully specify one type-separation gadget. If choosing per-bit probes Q_j:
   - Define the port zone layout: B addressed cells adjacent to S with an address track Addr∈{1,…,B} and a data track RID∈{0,1}.
   - Define the boundary-reserved outputs Q_j and show the only legal continuation is a deterministic pointer that moves to the unique cell with Addr=j and accepts iff RID=1.
   - Prove the Type-Separation Lemma: for a fixed boundary-input a⋆, E_{L(u)}(a⋆)[Q_j]=u_j; hence Type(L(u)) ≠ Type(L(u′)) for u≠u′.
2) Define canonical L(u), R(v) shapes precisely: lengths, offsets of headers, port zones, and RUN zones. Add local rules that permit color tokens at S only when the adjacent block is a well-formed vertex block.
3) Specify the seam tableau alphabet and local constraints: how the bridge reads the two B-bit ports, how the final EDGE bit is emitted, and the local check that enforces “if EDGE=1 then colors differ, else accept.” Include the refutation for malformed rows.
4) Integrate ⊥-plumbing for (F2) and explicitly state that it never touches S or overrides the vertex-role gating.
5) Provide a small B=2 instance and brute-force the DP to validate the separation and seam behavior.

If the above is written concretely, we can start moving the Type-Separation Lemma and the Seam Gadget Lemma (with full local rule tables) into output.md. Until then, no new theorems are publication-ready.
