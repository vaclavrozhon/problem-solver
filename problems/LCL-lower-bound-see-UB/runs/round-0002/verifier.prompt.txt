--- SYSTEM ---
You are a strict mathematical verifier & research manager.

Tasks:
1) Audit correctness & rigor. Identify leaps, gaps, unjustified claims, likely false statements; produce the simplest counterexample or the minimal missing lemma.
2) Triage value. Separate genuine progress from noise.
3) Guide next steps. Suggest the next experiments/lemmas that most raise confidence.

Include a 3-row table:
| Claim (short) | Status [OK/Unclear/Broken] | Why |

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique for the prover (≥150 words)",
  "summary_md": "2–10 bullets for the human: what works, what fails, next steps",
  "verdict": "promising|uncertain|unlikely",
  "blocking_issues": []
}

--- USER ---
You receive multiple prover reports. Evaluate correctness, value, and pick promising directions. Optionally update notes and decide whether to call the writer.

Prover reports (JSON):
[{"prover_id": "01", "progress_md": "## Round 0002 \u2014 2025-08-27T11:23:07.543718Z\n\nMini-plan\n- Recast feasible-function existence (F1) as an implicit exponential-sized SAT instance over type-choices, then map Succinct-3SAT to it. Make the quantifier structure transparent.\n- Fix the bridge semantics: clause-side chooses one of its 3 occurrences (not a sign), variable-side chooses its truth; the gate is ON only for the matching occurrence/variable-index pair; ON enforces truth=sign(occ). OFF pairs are trivially fillable. This aligns \u201cfor all ordered pairs\u201d with \u201c\u2203 a satisfied literal.\u201d\n- State a clean SAT-of-types lemma and the gating-correctness lemma with how-it-can-fail and quick tests (B=2 toy). Tie to radius-1 and \u03b2-normalized implementation.\n- Prove existence and separability of exponentially many active context types (2^B variable-types and 2^B clause-types) using pumping and window anchoring; include a crisp type-separation witness.\n- Specify the poly(s)-length, radius-1 clause-verification tableau that exposes (i1, i2, i3) and their signs next to S; add error-chain refuters. Conclude soundness/completeness for (F1) and show how to trivialize (F2) for classification hardness.\n\n1) SAT-of-types view of (F1)\nClaim G (Implicit SAT for feasible-function existence). For a fixed \u03b2-normalized, r=1 LCL P and its context-type set C (types of w1 S w2 with |w1|,|w2|\u2208{\u2113pump,\u2113pump+1}), there is an implicit exponentially large SAT instance F(P) over variables encoding f(\u03c4) (the 2-node label at S for each \u03c4\u2208C), and for each ordered pair (\u03c4L,\u03c4R) a local constraint R(\u03c4L,\u03c4R,f(\u03c4L),f(\u03c4R)) that holds iff the DP on the bridge wa S1 wb wc S2 wd (with types \u03c4L,\u03c4R) succeeds. Then there exists a feasible f satisfying (F1) iff F(P) is satisfiable.\n- Why useful here: Reducing Succinct-3SAT to F(P) (or vice versa) yields NEXPTIME-hardness via an implicit exponential SAT. It also clarifies that our bridge-gadget just defines a pairwise constraint language on type-colors decidable by the O(k\u03b2^2) DP.\n- How it can fail: If C depended on f (circularity), or if the pairwise DP check were not radius-1 decidable, we could not encode constraints locally. Here, C is defined purely by input types (Section 4 types) and the DP is radius-1.\n- Quick test: Pick a small \u03a3out (\u03b2=5), enumerate 2\u20133 contexts with actual strings, run the DP to tabulate which f-choices on S1,S2 are extendible. The truth table matches a Boolean constraint R for those (\u03c4L,\u03c4R).\n\n2) Correct bridge semantics: clause chooses occurrence, variable chooses truth\nPatch H (Occurrence-selected gate). Modify the S-alphabet and gate:\n- Variable-side S palette: VT (true) or VF (false). Interpreted as \u03b1(x_i)=1 iff VT.\n- Clause-side S palette: O1,O2,O3 (select occurrence t\u2208{1,2,3} of clause j). No sign is chosen at S; signs are read from the clause RUN for that occurrence.\n- Gate ON condition (purely local): the left wb contains a well-formed variable block with RID=i; the right wc contains a well-formed clause block with the triple (i1,sgn1),(i2,sgn2),(i3,sgn3). If clause S-color=Ot and RID=i equals it, gate=ON; otherwise OFF. Window anchoring places all needed bits inside wb or wc.\n- ON-bridge semantics: enforce that VT iff sgnt=+ and VF iff sgnt=\u2212, via a one-bit CAP conduit from S1 to S2 (compare variable truth with required sign of the selected occurrence t). OFF-bridge semantics: wb\u25e6wc is PAD-plumbable regardless of S colors.\n- Why useful here: Fixes the earlier quantification mismatch: for a clause j, only the pair with the variable-type matching the chosen occurrence turns ON; the other two pairs turn OFF and are trivial, so (F1)\u2019s universal quantifier no longer overconstrains clauses.\n- How it can fail: (i) If the DP can deviate and turn ON without RID=it equality (no: ON is determined at the immediate seam by tokens and checked locally); (ii) If OFF were rejected due to seam interactions (we ensure PAD-plumbing accepts all OFF seams); (iii) If we needed to encode it (the occurrence index) at S (we do not: S carries only Ot; equality to RID is tested by a witness path inside wb and wc).\n- Quick test: Clause j with occurrences (i1=3,+), (i2=7,\u2212), (i3=10,+). If f(\u03c4Cl(j))=O2, only pairs with \u03c4Var(7) are ON; their success requires VF at S1. Pairs with \u03c4Var(3) and \u03c4Var(10) are OFF and always fill. Thus f(\u03c4Cl(j))=O2 works iff \u03b1(x7)=0.\n\n3) Equivalence to Succinct-3SAT via implicit SAT\nClaim I (SAT-of-types \u2261 Succinct-3SAT under Patch H). Let C be a succinct generator of a 3-CNF \u03a6C over variables x1,\u2026,x_{2^B}. Build PC so that active context types include all \u03c4Var(i) (all i\u2208{0,1}^B) and all \u03c4Cl(j) (all j\u2208{0,1}^B). Under Patch H, (F1) holds for some f iff \u03a6C is satisfiable.\n- Informal proof sketch: Introduce Boolean variables A_i (truth of x_i) corresponding to f(\u03c4Var(i))\u2208{VT,VF}, and 3-way selector T_j\u2208{1,2,3} corresponding to f(\u03c4Cl(j))\u2208{O1,O2,O3}. The bridge constraints across all ordered pairs conjoin, for each j, the single ON-pair constraint: if T_j=t then A_{i_t} must equal sgn_t. OFF pairs are tautologies. This is exactly the clause-satisfaction condition \u201c\u2203t with A_{i_t}=sgn_t.\u201d Hence f exists iff there is {A_i},{T_j} satisfying \u2227_j \u2228_{t=1}^3 (A_{i_t}=sgn_t), i.e., \u03a6C is satisfiable.\n- How it can fail: If some \u03c4Cl(j) could choose an O_t that is not one of its occurrences (e.g., unverified (i_t,sgn_t)), the constraint could be cheated. We prevent this by the clause-run tableau and local checker exposing (i_t,sgn_t) and rejecting any Ot whose occurrence record is malformed.\n- Quick test: B=2 example with 4 variables. Let clause j encode (x1 \u2228 \u00acx2 \u2228 x3). If \u03b1(x1)=0, \u03b1(x2)=1, \u03b1(x3)=0, the only working choice is T_j=2 (select occurrence 2: \u00acx2). The only ON-pair is with \u03c4Var(2) and requires VF at left; holds. Other pairs OFF.\n\n4) Active type coverage and type separation\nClaim J (Coverage and separation of active types). With \u03b2=poly(s), choose B=s^c0 and \u2113pump=2^{\u0398(\u03b2^4)}. Using window-anchored blocks, for each i and each j there exist context types \u03c4Var(i) (left context whose wb contains a valid variable block with RID=i) and \u03c4Cl(j) (right context whose wc contains a valid clause block with GID=j and tableau exposing its 3 occurrences). Moreover, \u03c4Var(i)\u2260\u03c4Var(i\u2032) for i\u2260i\u2032, and \u03c4Cl(j)\u2260\u03c4Cl(j\u2032) for j\u2260j\u2032.\n- Why useful here: We need 2^B many distinct variable-types and 2^B many distinct clause-types so that {A_i} and {T_j} are well-defined choices over C.\n- How it can fail: (i) If the header+indices+RUN footprint exceeded the window length, activation wouldn\u2019t be local (fix: windows are size \u2113pump with \u2113pump\u226bpoly(s)); (ii) If types collapsed despite different RIDs/GIDs (fix: separation by boundary-extendibility: pick a partner type so that an ON-bridge exists for one index but is impossible for the other, hence their boundary-extendibility signatures differ).\n- Quick test (type-separation witness): Fix j and pick Ot selecting its first occurrence i1; Build the ordered pair (\u03c4Var(i1),\u03c4Cl(j)). The ON-bridge can succeed if VT=sgn1; For i\u2032\u2260i1, the gate is OFF and we can enforce a different outcome by forcing non-\u22a5 on the variable side with a mismatching token that is locally rejected; the sets of boundary-extendible labelings differ, so the types differ.\n\n5) Clause-verification tableau and radius-1 implementation\nClaim K (Poly(s)-length, radius-1 verification inside wc/wb). The clause-side block encodes in RUN a radius-1 checkable tableau of length poly(s) that, given (C,GID=j), exposes in fixed rows: (i1,sgn1),(i2,sgn2),(i3,sgn3) in one-hot form next to the S-neighborhood. The variable-side block exposes HotRID in one-hot. Cout\u2013out enforces stepwise consistency; malformed encodings admit a short error-chain refuter; well-formed ones cannot be refuted.\n- Why useful here: Ensures Ot actually corresponds to a validated occurrence and exposes sgnt locally, making the ON conduit comparison well-defined and radius-1 checkable.\n- How it can fail: If the verifier were O(1)-time, it could not validate the succinct circuit\u2019s output; we instead unroll a poly(s)-length tableau (still radius-1, constant alphabet overhead). If errors were non-refutable, inactive contexts could force constraints; the error-chain gadget prevents that.\n- Quick test: For a hand-built clause-index j, create a tiny RUN with 3 marked rows carrying the one-hot i_t and sgnt bits at fixed offsets. Flip one bit and confirm that an error-chain can be placed locally and that any non-\u22a5 S-choice against a malformed block is rejected by the DP.\n\n6) Inactive contexts are harmless; (F2) trivialization\nClaim L (Inactive contexts force \u22a5; (F2) is made vacuous). If a context\u2019s wb (resp. wc) lacks a well-formed variable (resp. clause) block, any non-\u22a5 at S is locally rejected (witness chain cannot find headers/indices). A dedicated PAD/\u22a5-plumbing language in Cout\u2013out allows arbitrary filling when OFF or \u22a5 at S. If we further allow wz repeats to be \u22a5-fillable regardless of z, (F2) holds for any f, and the classification collapses to O(1) iff (F1) feasible, else \u0398(n) by the gap theorem.\n- Why useful here: Neutralizes irrelevant pairs and reduces the tri-class decision to (F1) on our instances.\n- How it can fail: If PAD/\u22a5 seams were incompatible with S choices, OFF wouldn\u2019t be trivially fillable; we explicitly include seam-compatible PAD/\u22a5 pairs in Cout\u2013out.\n- Quick test: Take an inactive left context and any right context. Try S=VT; the DP fails early (no HEAD/RID found). Set S=\u22a5; the DP runs a PAD/\u22a5 conduit and succeeds.\n\n7) Putting it together: reduction to implicit SAT (Succinct-3SAT \u2192 F(P))\n- Source: circuit C of size s defining \u03a6C with 2^B variables and 2^B clauses, each clause(j) has three occurrences (i1,sgn1),(i2,sgn2),(i3,sgn3).\n- Target: PC with \u03a3out and Cout\u2013out implementing Claims H\u2013L; \u03b2=poly(s), r=1, |description|=poly(\u03b2)=poly(s). By Claim J, C\u2019s type set contains all \u03c4Var(i) and \u03c4Cl(j). By Claim I, there exists f satisfying (F1) for PC iff \u03a6C is satisfiable. By Claim L, we can trivialize (F2) if we target full classification hardness.\n- Complexity: Types count \u2113pump=2^{\u0398(\u03b2^4)}=2^{poly(s)}; we never enumerate them in the reduction. Verification of each bridge is via O(k\u03b2^2) DP (k=\u0398(\u2113pump)), consistent with the NEXPTIME upper bound.\n\n8) Toy worked example (B=2, indices 00..11)\n- Let clause j encode (x01 \u2228 \u00acx10 \u2228 x11). Suppose \u03b1(x01)=0, \u03b1(x10)=1, \u03b1(x11)=0.\n- Choices: set f(\u03c4Var(01))=VF, f(\u03c4Var(10))=VT, f(\u03c4Var(11))=VF. Set f(\u03c4Cl(j))=O2 (choose occurrence 2: \u00acx10). For ordered pairs: (\u03c4Var(10),\u03c4Cl(j)) ON and requires VT= (sgn2=\u2212)? No, ON demands VF when sgnt=\u2212. Oops: we must require VT iff sgnt=+ and VF iff sgnt=\u2212; thus for occurrence 2 (negative), left must be VF to pass. Since \u03b1(x10)=1, O2 would fail. Correct choice is O1 or O3? O1 has sgn1=+, requires VT at Var(01), but \u03b1(x01)=0, so fail. O3 has sgn3=+, requires VT at Var(11), but \u03b1(x11)=0, so fail. Therefore, \u03b1 does not satisfy this clause; no O_t makes the ON-pair succeed, as intended. If we flip \u03b1(x10)=0, then O2 makes (\u03c4Var(10),\u03c4Cl(j)) succeed and all other pairs OFF; (F1) holds for this j.\n- Takeaway: For each clause j, there exists exactly those Ot consistent with \u03b1 that make all pairs pass; otherwise (F1) fails.\n\n9) Open items and quantitative checks\n- Boundary tables: Write explicit Cin\u2013out/Cout\u2013out rows for S-seams enforcing: (i) non-\u22a5 at S emits Offer tokens and forbids PAD unless OFF, (ii) OFF\u21d4mismatch of (RID,it), (iii) ON enforces CAP wire equality truth\u2194sgn_t, (iv) PAD/\u22a5 seams accept any colors when OFF.\n- Clause RUN tiles: Provide a fixed set of row-local tiles producing/exposing (i_t,sgn_t) and validating them against header C and GID=j, with a bounded error alphabet E to refute any malformed run.\n- Type separation proof: Formally exhibit, for i\u2260i\u2032, some counterpart type so that the sets of extendible boundary assignments differ (hence distinct types). Likewise for clauses.\n- Rule budgets: Count tracks/symbols to confirm |\u03a3out|=\u03b2=poly(s). \u2113pump\u226bpoly(s) so that windows can host headers+indices+RUN comfortably.\n\nHow this answers \u201creduce to implicit exponential-sized SAT formula\u201d\n- The existence of a feasible f is equivalent to satisfiability of the implicit SAT F(P): variables are (A_i) and (T_j), constraints are local bridge constraints per (\u03c4Var(i),\u03c4Cl(j)), exponentially many but specified implicitly by P (via DP over \u2113pump-length contexts). Our reduction from C maps \u03a6C to F(PC) with the property F(PC) satisfiable iff \u03a6C satisfiable. This yields NEXPTIME-hardness of feasible-function existence, and (by trivializing (F2)) the full O(1) vs \u0398(n) classification.\n", "requests_for_more_materials": ["Confirm we may allocate 5 distinct S-tokens (VT,VF,O1,O2,O3) within \u03a3out; \u03b2=poly(s) so this is fine, but we will size the palette explicitly.", "Provide any preference on the universal machine U and the clause-decoder format (truth-table vs direct index computation) so we can pin down the exact RUN tiles."], "next_actions_for_prover": ["Write explicit Cin\u2013out/Cout\u2013out tables for the 4-node neighborhoods around S on both sides implementing Patch H (OFF/ON, PAD/\u22a5 plumbing, CAP wire).", "Specify the clause-verification tableau: tracks, phases, row transitions, and the error-chain alphabet; prove radius-1 local checkability and poly(s) footprint.", "Prove the Type Separation Lemma formally: construct a fixed counterpart type that distinguishes \u03c4Var(i) from \u03c4Var(i\u2032), and \u03c4Cl(j) from \u03c4Cl(j\u2032), via boundary-extendibility signatures.", "Build a complete B=2 worked example: enumerate all 12 (\u03c4Var(i),\u03c4Cl(j)) pairs, tabulate ON/OFF and DP outcomes under sample assignments \u03b1; verify that (F1) holds iff \u03b1 satisfies all clauses.", "Finalize the (F2) trivialization by listing Cout\u2013out seam rules that make repeats wz universally \u22a5-fillable regardless of z."]}, {"prover_id": "02", "progress_md": "## Round 0002 \u2014 2025-08-27T11:23:07.543978Z\n\nMini-plan\n- Recast the FFE(F1) feasibility question as an implicit (succinct) SAT instance: variables are f-values on active types, constraints are the bridge-completion checks; show that our LCL makes these constraints equivalent to the Succinct-3SAT instance via a gate with an equality/inequality witness.\n- Specify a corrected ON/OFF gate: clause-side precommits (via S2 color) to one of its 3 indices and a sign; pairs with a left RID equal to that index are ON and enforce consistency with the variable\u2019s color; other pairs are provably OFF and accept PAD via an inequality witness.\n- Replace any O(1)-time clause computation with a poly(s)-length, radius-1 tableau inside wc (and the analogous RID one-hot in wb), with error chains to refute malformed encodings; keep all semantics window-anchored in wb/wc.\n- State and test the key lemmas: (G) ON/OFF correctness via equality/inequality witnesses; (H) clause-tableau correctness; (I) type-separation from differential extendibility; (J) equivalence to a succinct SAT instance.\n- List explicit artifacts to produce next: boundary C_in\u2013out/C_out\u2013out tables for offers and conduits; the RUN tableau tiles; a complete B=2 worked example with DP outcomes.\n\n1) Gate with equality/inequality witnesses (one constrained pair per clause)\nClaim G (Equality/inequality-gated bridge). For each clause-side active context wc S2 wd, allow S2 colors from a 7-token palette: {\u22a5} \u222a {REDp, GRNp : p \u2208 {1,2,3}}. The right context (wc) contains a verified triple (i1,i2,i3) and exposes subtracks Select(p) that copy the chosen position p committed by the S2 color. For a left active variable-side context wa S1 wb with RID = iL (one-hot HotRID), the bridge wb wc is fillable iff exactly one of the following locally-checkable certificates is provided by the filler (and the other is impossible):\n- Equality certificate (ON): \u201ciL = i_{Select}\u201d. This is checked by a radius-1 witness chain that (i) reads the unique 1 in HotRID at position iL in wb, (ii) reads the selected triple position p in wc and the corresponding index ip, (iii) follows an ip-pointer to a one-hot at position ip inside wc, and (iv) proves ip = iL by comparing bit-by-bit along a fixed binary-expansion compare path. If the equality certificate passes, the filler must propagate a CAP bit from left to right and enforce consistency of the chosen sign with the left variable\u2019s color: REDp requires f(Var_{iL}) = RED, GRNp requires f(Var_{iL}) = GRN. \n- Inequality certificate (OFF): \u201ciL \u2260 i_{Select}\u201d. This is certified by guessing the unique 1 in HotRID (position iL) and comparing with the selected index ip; the chain must exhibit a bit position b where iL[b] \u2260 ip[b], using radius-1 checkers at the corresponding b-th cells on both sides. If the inequality certificate passes, the only admissible fill is PAD (a neutral plumbing language), with no CAP signal and no dependence on colors.\nExactly one of these two certificates is realizable in any given pair: the grammar forbids fabricating a mismatch when iL = ip and forbids fabricating equality when iL \u2260 ip. Hence for each clause-type instance, exactly one left variable-type (the chosen ip) is constrained (ON), and all other left types are unconstrained (OFF) but completable.\n- Why useful here: This resolves the \u201call ordered pairs\u201d quantification: mid-consistency requires a completion for every pair, but only the single pair whose RID equals the clause\u2019s committed index is forced to check sign-consistency; the rest admit inequality witnesses and fill trivially. Thus per clause we impose precisely one literal check.\n- How it can fail: (i) If the inequality proof could be faked even when iL = ip, a mismatching OFF-fill might bypass the literal check; (ii) if equality could be certified when iL \u2260 ip, a spurious ON check may wrongly constrain an unrelated variable; (iii) if the sign-consistency does not bind to the left variable\u2019s f-color, the clause constraint evaporates.\n- Quick test: Take clause triple (i1,i2,i3) = (3,7,10), and S2 = RED2 (selects i2 = 7). Pair with Var_7: equality path exists; ON requires f(Var_7) = RED. Pair with Var_3: inequality path exists (compare 3 vs 7; they differ at the 1st bit), PAD fill succeeds, no constraint. Pair with Var_9 (not in clause): still inequality since 9 \u2260 7, PAD fill.\n\n2) Clause tableau and window anchoring\nClaim H (Clause decoding via poly(s)-length, radius-1 tableau; window-anchored). The right active context wc houses a fixed-layout RUN tableau that verifies C(j) for the clause index GID = j and materializes (i1,i2,i3) and their signs, plus auxiliary one-hot encodings and directed pointers to their positions. All verification is by nearest-neighbor tiles: row-by-row TM simulation of a universal U for T = poly(s) steps, with a constant work alphabet and synchronization phases. The left active context wb houses RID and HotRID one-hot. All headers (HEADC), indices (RID/GID), and RUN tiles lie entirely inside wb (variable side) or wc (clause side), adjacent to S; malformed encodings have locally checkable refutations via error chains. \n- Why useful here: Ensures the gate\u2019s local witness chains have the facts they need within wb/wc and that the \u201cselected position p\u201d refers to a real member of the decoded triple. It also removes the earlier O(1)-time fallacy by giving a polynomial-length, radius-1 verification consistent with \u03b2-normalization.\n- How it can fail: If the RUN did not fully verify the triple or allowed multiple inconsistent triples, the select(p) track could be abused; if error chains were incomplete, malformed contexts might constrain f.\n- Quick test: Implement a toy U that decodes a 2-bit GID and outputs three hard-wired indices (for B=2). Create a malformed wc that spoofs Select(2) but without a legitimate (i1,i2,i3); check that an error-chain can be triggered locally, making the context inactive (only \u22a5 at S is completable).\n\n3) Type-separation by differential extendibility\nClaim I (Distinct active types per RID and per GID). For \u03b2 = poly(s), choose B = poly(s) with 2^B \u226a \u2113_pump. Then there exist 2^B left active context types Var_i (with RID = i) and 2^B right active context types Cl_j (with GID = j). Moreover, Var_i \u2260 Var_{i'} for i \u2260 i' and Cl_j \u2260 Cl_{j'} for j \u2260 j'. Separation proof sketch: fix any clause-type \u03c4R that, by RUN, decodes a triple including i but not i'. Commit S2 = REDp to the position p with ip = i. For the pair (Var_i, \u03c4R), equality is forced (ON) and fill exists if and only if f(Var_i) = RED. For (Var_{i'}, \u03c4R), inequality is forced (OFF) and fill exists regardless of f(Var_{i'}). Therefore, the boundary-extendibility signatures with S1 fixed to RED differ between Var_i and Var_{i'}, implying distinct types. Similarly for Cl_j using a fixed Var_i and toggling which Select(p) is legal according to RUN, we separate clause types by their decoded triples.\n- Why useful here: We need exponentially many active types to encode all variables and clauses generated by the succinct circuit; distinctness is certified by different extendibility outcomes under fixed boundary labels, which the type definition captures.\n- How it can fail: If the equality/inequality partitioning could be overridden by the filler (e.g., both certificates could succeed), the extendibility signatures could collapse; if RUN did not uniquely determine the triple, clause types might merge.\n- Quick test: Let B=3, pick j with triple (2,5,7). Compare Var_5 vs Var_6 against Cl_j, S2 = GRN2 (selects 5). DP result differs: (Var_5, Cl_j) fill depends on f(Var_5); (Var_6, Cl_j) fill is always PAD. Distinctness follows.\n\n4) Succinct SAT view of FFE(F1)\nClaim J (Implicit SAT encoding). The existence of f is equivalent to the satisfiability of a succinct CNF \u03a6\u2019 over variables: \n- For each Var_i: a Boolean v_i \u2208 {RED,GRN} (two colors suffice; BLU only used as inactive/dummy and disallowed for active Var_i), encoding \u03b1(x_i).\n- For each Cl_j: a 6-ary choice c_j \u2208 {RED1,RED2,RED3,GRN1,GRN2,GRN3} selecting one position p \u2208 {1,2,3} and a sign.\nConstraints: For every ordered pair (Var_i, Cl_j), the bridge is satisfiable. By Claim G, this reduces to a single literal constraint per j, namely: if c_j = REDp (resp. GRNp) and RUN(j) outputs (i1,i2,i3), then require v_{ip} = RED (resp. v_{ip} = GRN). All other pairs impose only tautologies (inequality witnesses). Thus \u03a6\u2019 is exactly the succinct 3CNF \u03a6_C: choose for each clause one literal (p and sign) that is true under \u03b1 (the v_i\u2019s). \n- Why useful here: It makes explicit the \u201cimplicit exponential-sized SAT formula\u201d viewpoint: FFE(F1) is satisfiable iff a succinct CNF with exponentially many clauses (one per pair) is satisfiable; our LCL reduction constructs local constraints that evaluate this succinct CNF.\n- How it can fail: If pairs other than the selected one also imposed constraints, \u03a6\u2019 would be stronger than \u03a6_C (requiring all three literals to match), breaking soundness; if the selected pair could avoid referencing v_{ip}, completeness would be lost.\n- Quick test: Clause j with literals (x3 \u2228 \u00acx7 \u2228 x10). Set c_j = RED1 (select x3). Then the only nontrivial pair is (Var_3, Cl_j), enforcing v_3 = RED. Pairs (Var_7, Cl_j) and (Var_10, Cl_j) are OFF and PAD-fillable. Across all j, existence of \u03b1 (the v_i\u2019s) and c_j\u2019s satisfying all selected pairs is equivalent to \u03a6_C satisfiable.\n\n5) Radius-1 and \u03b2-normalized implementation sanity\nClaim K (\u03b2-normalized, radius-1). \n- \u03a3_out tracks (constant many): role/phase, color tokens {\u22a5, REDp, GRNp}, CAP/PAD conduits, RID/GID one-hot lanes and their pointers, RUN tiles for U, error-chain symbols. \n- Cin\u2013out: copies input bit to an \u201cin-copy\u201d subtrack and gates role legality (e.g., only S admits {\u22a5, REDp, GRNp}). \n- Cout\u2013out: regular-language grammar for blocks; nearest-neighbor consistency for RUN rows; local tiles for equality/inequality witnesses and for CAP/PAD conduits; absorbing \u22a5-plumbing that can fill repetitions (used later to trivialize (F2)). All checks are between consecutive nodes; the witness chains advance one node per step.\n- Why useful here: Confirms we remain within the \u03b2-normalized, r=1 model and keep description size poly(\u03b2).\n- How it can fail: If equality compare needed nonlocal jumps, or CAP/PAD conduits required 2-hop checks, we would exceed radius-1; we avoid this with \u201cone-bit-per-step\u201d pointer chains and local tiles.\n- Quick test: Build a 12-node wc with RUN and a selected p; simulate the equality witness step-by-step next to a matching Var_i wb; ensure all edge checks refer only to consecutive outputs; flip one bit in the index to see equality chain get stuck while inequality chain passes.\n\n6) Trivializing (F2) and mapping to tri-class classification\nClaim L ((F2) vacuous via \u22a5-plumbing). Extend Cout\u2013out so that any wz_1 and wz_2 repeat can be filled entirely with \u22a5, for any S color fixed by f(Type(w1 S w2)). Then (F2) holds automatically; thus for our family, O(1) iff (F1) holds and \u0398(n) otherwise (by the standard gap Theorem 8). \n- Why useful here: Gives the desired O(1) vs \u0398(n) dichotomy needed for NEXPTIME-hardness of the tri-class classification.\n- How it can fail: If \u22a5 is not fully absorbing at the seams near S, some contexts might violate (F2); we avoid this by explicit Cout\u2013out entries permitting \u22a5 next to any S-color.\n- Quick test: Fix an active context and any z; force S and fill both repeats with \u22a5; run the DP\u2014should accept due to plumbing rules.\n\n7) Size and succinctness bookkeeping\n- Alphabet size: \u03b2 = poly(s) suffices for: constant role/phase and gate tokens; RUN alphabet for T = poly(s); error chains; and a few colors (7 S-tokens). Cin\u2013out is O(\u03b2); Cout\u2013out is O(\u03b2^2) as required.\n- Type space: \u2113_pump \u2264 2^{\u0398(\u03b2^4)} = 2^{poly(s)} guarantees enough contexts to realize all 2^B RIDs/GIDs with window-anchored blocks and stability under pumping/replacement.\n- Implicit SAT: The induced SAT instance \u03a6\u2019 has exponentially many variables/clauses in s but is generated by the succinct circuit C and the local LCL tables; FFE(F1) is \u201cdoes there exist f?\u201d which is equivalent to satisfiability of \u03a6\u2019. Our reduction from Succinct-3SAT maps C to PC in poly(s) time; Claims G\u2013L give \u03a6_C satisfiable iff FFE(F1) for PC.\n\nToy counterexample probes\n- Mismatch bypass attempt: Try to fill (Var_k, Cl_j) with k \u2260 selected ip using equality chain; it must fail at the first compare bit, forcing the inequality path; DP rejects any attempt to route CAP without proving equality. \n- Multi-select clause cheat: Try to propagate two Select(p) values in wc while choosing a single S2 color; RUN+phase tiles forbid inconsistent select propagation; any duplication triggers an error-chain, deactivating the context.\n- Boundary-only spoof: Remove wb\u2019s HEAD marker but keep S1 = REDp; non-\u22a5 at S forces starting an offer that must find HEAD and RID; missing HEAD triggers the error-chain; only \u22a5 is completable.\n\nWhat remains to be written (explicit artifacts)\n- Boundary tables: the exact Cin\u2013out and Cout\u2013out rows for the four nodes around S that (i) restrict S-palette, (ii) export/propagate Select(p) from S2 into wc, (iii) force CAP conduit on equality and forbid it on inequality, (iv) allow PAD otherwise, and (v) allow \u22a5-plumbing always.\n- RUN tiles: a concrete fixed-tile set for U\u2019s poly(s)-step verification of C(j) and computation of (i1,i2,i3), exposing them as one-hots and pointers, plus error-chain tiles.\n- B=2 worked example: instantiate all gadgets for B=2, list the 12 ordered pairs (Var_i, Cl_j), and manually DP-check the outcomes to confirm that only the single selected pair imposes the literal constraint and all others complete via PAD.\n\nSummary of current status\n- We repaired the \u201cpairwise quantification\u201d issue by an equality/inequality gate that provably turns only one pair ON per clause-type and makes all others OFF and harmless. This makes (F1) equivalent to a succinct SAT instance where each clause picks one true literal under \u03b1.\n- We anchored all semantics within wb/wc and replaced constant-time checks with a poly(s)-length, radius-1 RUN tableau, preserving \u03b2-normalization.\n- We sketched type-separation and the implicit SAT view, aligning with the user\u2019s \u201cimplicit exponential-sized SAT\u201d request.\n", "requests_for_more_materials": ["Confirm we can allocate 6 distinct S2 tokens {RED1,RED2,RED3,GRN1,GRN2,GRN3} (plus \u22a5) without violating any model constraint; this is a constant blowup in \u03a3out.", "Provide an explicit succinct-circuit interface format for C so we can describe the clause-verification tableau U (inputs/outputs/promise on size poly(s)).", "Clarify whether we should also anchor a variable-side RUN (to recompute HotRID from RID) or treat HotRID as purely structural; both are implementable\u2014preference?", "Any constraints on using binary-compare witness chains of length O(B) inside wb/wc (still radius-1); we will implement bit-by-bit with local tiles."], "next_actions_for_prover": ["Write the boundary Cin\u2013out/Cout\u2013out tables around S to realize the 7-token S2 palette, Select(p) propagation, and CAP/PAD conduits with equality/inequality exclusivity.", "Specify the RUN tableau for clause decoding: tile set, phases, row separators, and error-chain rules; quantify alphabet usage to keep |\u03a3out| = poly(s).", "Prove formally Claim I (type-separation) by constructing the boundary-extendibility signature that differs between Var_i and Var_{i'} (and analogously for Cl_j).", "Build the full B=2 worked example: enumerate all pairs, simulate the layered DP, and record accept/fail outcomes to validate Claims G\u2013J.", "Integrate \u22a5-plumbing rules that trivialize (F2) and verify no interference with S-boundary colors across repeats."]}, {"prover_id": "03", "progress_md": "## Round 0002 \u2014 2025-08-27T11:23:07.548697Z\n\nMini-plan\n- Formalize an implicit exponential-sized SAT encoding F(L) whose satisfiability is equivalent to the existence of a feasible function f for a given \u03b2-normalized, radius-1 LCL instance L on oriented paths. This cleanly connects (F1) and (F2) to a succinct-SAT instance.\n- Specialize the encoding to our reduction family PC (from a succinct 3CNF generator C), using window-anchored active blocks and a gated bridge. Show that F(PC) is essentially the succinct 3SAT instance for C with auxiliary \u201cliteral-pick\u201d variables Y.\n- State and test three core lemmas: (i) succinct SAT capture of (F1) and (F2) with an explicit 2poly(\u03b2) bound, (ii) ON/OFF gate \u21d2 CNF constraints of the form (\u00acY \u2228 X), and (iii) type-separation by boundary-extendibility patterns induced by interior witness behavior (no reliance on 2-node boundaries).\n- Patch the previously flagged fragilities: ensure OFF for all unintended pairs (use offer/cap tokens), and move clause-decoding to a poly(s)-length, radius-1 tableau with error-chain refutations.\n- Work out a small B=2 toy to validate the SAT constraints and counterexample probes; list next instrumentation (explicit Cin\u2013out/Cout\u2013out tables for the window seam, offers, PAD/CAP conduits, and the tableau seam rules).\n\n1) Encoding feasible-function existence as an implicit exponential-sized SAT\nClaim S1 (Succinct-SAT capture of (F1)+(F2)).\nGiven a \u03b2-normalized, radius-1 LCL L on oriented paths, there is a Boolean formula F(L) of size at most 2poly(\u03b2), given succinctly by a poly(\u03b2)-size circuit, such that F(L) is satisfiable iff there exists a feasible function f (i.e., f passes (F1) and (F2)). Variables are the choice bits of f on each context type \u03c4 and the auxiliary bridge/witness choices where needed. The clauses encode: (i) one-hot consistency of f(\u03c4) \u2208 \u03a3out^2 on each \u03c4, (ii) for every ordered context pair (\u03c41, \u03c42), the \u201cbridge succeeds\u201d constraint computed by the layered DP, and (iii) for (F2), the finitely many repetition lengths z \u2264 Z with Z \u2264 \u2113_pump^2 (per Lemma 1 in the draft), also checked via the DP.\n- Why useful here: It gives a direct NEXPTIME upper bound (already in our draft) and sets up hardness by letting us reduce succinct 3SAT to F(L) through a specific LCL family PC. It cleanly isolates correctness to the equivalence F(L) \u21d4 feasible f.\n- How it can fail: If the number of context types exceeded 2poly(\u03b2) or the DP check needed super-polynomial circuits, the succinct-SAT size would blow up. Also, if (F2) required infinite z checks, we could not confine to finite clauses. Both are avoided by type bounds and periodicity.\n- Quick test: For a toy LCL with \u03b2 = O(1) that enforces proper 2-coloring (no equal neighbors), contexts and pairs are O(1), and F(L) becomes a tiny CNF: per \u03c4 choose color, per pair forbid equal-colored windows. The DP is trivial and the formula is equivalent to 2-colorability of the context graph.\n\nSketch of construction and size: Let T be the type set, |T| = \u2113_pump \u2264 2\u0398(\u03b2^4). Let C \u2286 T be the context-type set: those realized by w1Sw2 with |wi| \u2208 {\u2113_pump, \u2113_pump+1}. Introduce variables {X_{\u03c4,c}} encoding f(\u03c4)=c, with one-hot constraints per \u03c4. For each ordered pair (\u03c41, \u03c42) introduce a polynomial-size circuit that runs the O(k\u03b2^2) DP (k = O(\u2113_pump)) on the bridge instance to produce a clause-set forcing the DP to accept. For (F2), for each \u03c4 and z \u2208 {1,\u2026,Z}, add analogous DP constraints for wz_1Swz_2. The number of \u03c4\u2019s is \u2264 \u2113_pump, pairs \u2264 \u2113_pump^2, and z\u2019s \u2264 \u2113_pump^2. Each DP instance has size polynomial in \u03b2 and \u2113_pump. Therefore the entire formula is of size at most 2poly(\u03b2), given succinctly by a poly(\u03b2)-size generator.\n\n2) Specializing to the hardness family PC: ON/OFF gate \u21d2 local CNF constraints\nClaim S2 (Gated bridge yields per-clause local CNF). For the reduction PC built from a succinct-3CNF generator C (size s), we define \u03a3out and Cout\u2013out so that for every clause index j and its three literals \u2113 \u2208 {1,2,3}, there is a \u201cliteral-pick\u201d color at the clause window S representing a choice Y_{j,\u2113}, and at each variable i there is a 1-bit choice X_i \u2208 {RED,GRN} representing \u03b1(x_i). Then (F1) on PC translates to the CNF:\n- One-hot per clause: exactly one Y_{j,\u2113} is chosen (enforced via one-hot encoding at the clause-side S).\n- For each j and each occurrence i of literal \u2113 in clause j with sign s \u2208 {+,\u2212}, the bridge constraint contributes a Horn clause of the form (\u00acY_{j,\u2113} \u2228 (X_i = RED)) if s=+, or (\u00acY_{j,\u2113} \u2228 (X_i = GRN)) if s=\u2212.\nAll other ordered pairs (including all mismatched (i,j) where Y_{j,\u2113} points to some i\u2032 \u2260 i, or where the left/right side is inactive) compile to tautologies thanks to the OFF gate and \u22a5-plumbing. Therefore, (F1) is equivalent to the satisfiability of the succinct CNF that encodes \u201cfor each clause j, the selected literal is true under \u03b1\u201d.\n- Why useful here: This resolves the universal quantification across all ordered pairs: OFF pairs impose no constraint, and the ON pair per clause imposes exactly one Horn clause linking the clause\u2019s pick Y_{j,\u2113} to the variable\u2019s truth X_i. It also shows that our (F1) feasibility is precisely succinct-3SAT.\n- How it can fail: If the gate could turn ON on unintended pairs (e.g., when Y_{j,\u2113} selects i\u2032 but the pair is with i \u2260 i\u2032), we would accumulate impossible constraints across all three i\u2019s and lose completeness. If malformed clause blocks could fake an ON, spurious Horn clauses could be added. We avoid both by: (i) offers/caps at the S boundary that make ON depend only on the clause-side Y pick and the RUN-decoded occurrence i; (ii) a poly(s)-length, radius-1 verifier tableau that pins the three occurrences and signs; malformed encodings divert to error-chains and never activate ON.\n- Quick test: Clause j = (x3 \u2228 \u00acx7 \u2228 x10): introduce one-hot Y_{j,1},Y_{j,2},Y_{j,3}. Constraints: (\u00acY_{j,1} \u2228 X_3=RED), (\u00acY_{j,2} \u2228 X_7=GRN), (\u00acY_{j,3} \u2228 X_10=RED). If \u03b1 sets X_3=RED, picking Y_{j,1} satisfies all three clauses tied to j; other pairs with variables not equal to 3 are OFF.\n\n3) Window-anchored activation and OFF-pair neutrality\nClaim S3 (OFF pairs are neutral; active iff block in window). The out\u2013out grammar is arranged so that: (i) the two S-nodes can be labeled only from {\u22a5, RED, GRN, BLU}, (ii) non-\u22a5 at S forces an \u201coffer\u201d token to be emitted into wb (left) or wc (right), which is locally legal only at boundaries of well-formed blocks whose HEADC matches the fixed C header; otherwise non-\u22a5 is locally rejected and only \u22a5 is extendible, and (iii) the gate turns ON iff both offers are present and the clause-side literal pick Y_{j,\u2113} matches the variable occurrence i (decoded from clause j by the tableau) at the other side; otherwise the gate remains OFF, and PAD-only conduits fill wb\u25e6wc.\n- Why useful here: Guarantees that (F1) constraints are only active precisely on intended (variable, selected-literal-of-clause) pairs; all other pairs are fillable regardless of f (by PAD/\u22a5), so they do not constrain the SAT.\n- How it can fail: If \u22a5 could not always fill wb\u25e6wc (e.g., blocked by a seam rule), we could get unwanted constraints from inactive contexts. If the offer legality were not locally checkable, an adversarial DP could slip in a fake ON. We prevent both by (1) including a fully absorbing \u22a5-plumbing sublanguage compatible with any S label, and (2) forcing an offer symbol adjacent to S for each non-\u22a5 S label; that offer is legal only when the immediately following few cells match the HEAD/role syntax of a block.\n- Quick test: Construct a pair of contexts where the left wb is malformed (no HEAD marker). Choose RED at S. The left offer is illegal at the boundary; thus non-\u22a5 is locally rejected and only \u22a5 can pass, making the pair OFF/neutral.\n\n4) Clause decoding via a radius-1, poly(s)-length tableau (no O(1) checker)\nClaim S4 (Local verification of succinct clause outputs). The clause-side wc contains (after HEAD and GID) a poly(s)-length, radius-1 tableau for a fixed universal TM U, whose job is to check that the three occurrence indices and their signs (stored in RUN subtracks) equal the outputs of the succinct generator C on input j. The adjacency table Cout\u2013out enforces single-step consistency across rows; any mismatch triggers a short error-chain gadget (accepted locally), which prevents the clause block from being \u201cactive\u201d and hence prevents gate ON.\n- Why useful here: Fixes the previously broken claim of an O(1) decoder and ensures malformed clause encodings are harmless (cannot create ON). It also keeps the LCL description size polynomial in s and hence in \u03b2.\n- How it can fail: If the tableau needed long-range dependencies or cross-row lookahead, we would exceed r=1. We avoid this by standard 1D Turing-tile encodings: every row encodes the work tape and head; Cout\u2013out allows only legal transitions of U, checked locally per neighbor pair. Errors are locally witnessed via error tokens.\n- Quick test: Build a 2-row tableau snippet with an intentional transition mismatch; verify that the only locally allowed continuation is to switch into an error-chain that absorbs the entire block, thus deactivating the gate.\n\n5) Type separation without 2-node boundary signatures\nClaim S5 (Distinct RID/GID yield distinct context types via differential extendibility). For each i \u2260 i\u2032, the context types \u03c4Var(i) (wb contains a well-formed variable block with HotRID[i]=1) and \u03c4Var(i\u2032) are distinct: there exists some fixed clause-side active type \u03c4Cl(j,\u2113) and a fixed S-label choice such that the bridge DP succeeds with \u03c4Var(i) and fails with \u03c4Var(i\u2032). Analogous distinctness holds for clause types.\n- Why useful here: We cannot rely on 2-node boundary encodings to separate 2^B indices. This shows distinctness emerges from differential extendibility behavior under the gated bridge with a suitable fixed partner, leveraging interior content (the RUN tracks) rather than boundary micro-alphabets.\n- How it can fail: If C never produces a clause where i appears and i\u2032 does not, a single \u03c4Cl(j,\u2113) may not separate \u03c4Var(i) and \u03c4Var(i\u2032). However, we can fix \u03c4Cl to be any clause-side active type whose decoded triplet includes i but not i\u2032; such a j exists among 2^B possible indices by padding C with a verifier that, when presented with a reserved \u201ctester\u201d j\u2217 (chosen at construction), outputs a clause whose single ON literal is x_i. This tester is validated by the same tableau mechanism. Thus separation does not rely on arbitrary properties of C.\n- Quick test: Introduce j\u2217 whose decoded clause is (xk \u2228 dummy \u2228 dummy) for k set at construction. Then with \u03c4Var(k) and \u03c4Var(k\u2032\u2260k), the bridge under S=RED is ON for \u03c4Var(k) and OFF for \u03c4Var(k\u2032), distinguishing types.\n\n6) From (F1) to tri-class classification via trivial (F2)\nClaim S6 (Trivializing (F2) preserves succinct-SAT shape). Extend Cout\u2013out so that wz_1 and wz_2 repetitions can always be filled with \u22a5 (PAD) regardless of z. Then (F2) holds for any f, and feasible-function existence reduces to (F1), i.e., the succinct CNF in Claim S2. Therefore, mapping a succinct 3SAT instance C to PC shows NEXPTIME-hardness of the O(1) vs. \u0398(n) sub-classification; in combination with the decidability framework (Theorems 8\u20139 in the reference), the three-way classification is NEXPTIME-hard.\n- Why useful here: Eliminates (F2) constraints, preventing an unintentional \u0398(log* n) regime. The family sits on the O(1)\u2013\u0398(n) dichotomy, simplifying the reduction target.\n- How it can fail: If the PAD/\u22a5 seam conflicts with the S-label fixed by f, (F2) could still impose constraints. We avoid this by permitting \u22a5 adjacent to any S-color and by making PAD/\u22a5 internally self-compatible.\n- Quick test: Pick any context and z=17. Force S by f; fill wz_1 and wz_2 with \u22a5. The DP finds a trivial path since every PAD/\u22a5 pair is admitted by Cout\u2013out.\n\n7) Toy worked example (B=2) under the SAT view\n- Variables: X_1, X_2, X_3, X_4 \u2208 {RED,GRN} (encode \u03b1(x1..x4))\n- One clause j with literals (x3 \u2228 \u00acx1 \u2228 x4). Clause picks: one-hot Y_{j,1},Y_{j,2},Y_{j,3}.\n- CNF clauses from the bridge: (\u00acY_{j,1} \u2228 X_3=RED), (\u00acY_{j,2} \u2228 X_1=GRN), (\u00acY_{j,3} \u2228 X_4=RED).\n- All other ordered pairs are OFF/neutral or forced \u22a5. Thus F(PC) is satisfiable iff there exist X\u2019s and a one-hot Y making one of those literals true\u2014exactly the clause\u2019s satisfiability. Multiple clauses add independent groups of three Horn clauses plus a one-hot.\nCounterexample attempt: If the gate were missing, we would need all three implications simultaneously for all i occurring in j, which would force X_3=RED and X_1=GRN and X_4=RED at the same time, and would also erroneously constrain pairs with variables not in the clause; the gate avoids this by OFF pairs and ON only for the selected literal.\n\n8) Outstanding spec to finalize\n- Cin\u2013out and Cout\u2013out tables at the window seam: explicit rows that (i) force an offer on non-\u22a5 S, (ii) reject non-\u22a5 unless a valid block boundary follows, (iii) implement OFF\u2192PAD conduits, and (iv) implement ON\u2192CAP conduit and CAP equality test.\n- Clause-side tableau tile set: list of allowed (state,symbol) pairs across rows; error-chain tokens that must appear when a mismatch occurs.\n- Tester j\u2217 mechanism (for type-separation robustness): specify reserved GID and the corresponding hard-wired outputs of U, validated by the same tableau (kept radius-1) so that \u03c4Var(i) types are provably distinct.\n- Confirm size bounds: |\u03a3out| = \u03b2 = poly(s); tables of size O(\u03b2^2); tableau length poly(s); type bound \u2113_pump = 2\u0398(\u03b2^4); hence contexts/pairs \u2264 2poly(\u03b2); DP verifiers run in O(k\u03b2^2) per instance.\n\nWhat we have accomplished this round\n- Provided a clean, succinct-SAT formulation of feasible-function existence (S1), which aligns exactly with the required NEXPTIME framework.\n- Instantiated the SAT constraints for the reduction family PC (S2\u2013S3), addressing the earlier fragile spots (pairwise quantification and activation locality) and eliminating reliance on boundary-only signatures (S5).\n- Replaced the O(1) clause decoder with a poly(s)-length, radius-1 tableau and an error-chain refuter (S4).\n- Validated by a B=2 toy and articulated the remaining explicit-table tasks needed to cement the construction.\n", "requests_for_more_materials": ["Precise format of the succinct 3SAT generator C: input/output bit-widths, how clause literals (variable indices and signs) are encoded, and whether a reserved index value can be allocated for a tester clause j* (we can also hardwire one within the LCL if not).", "Confirmation that the classification target is the worst-case over inputs, so we may freely neutralize malformed contexts via error-chains and \u22a5-plumbing without affecting hardness claims.", "Any constraints on the allowed size of the error alphabet and work-tape alphabet for the universal TM U beyond being polynomial in s (to tune \u03b2 = poly(s))."], "next_actions_for_prover": ["Write explicit Cin\u2013out and Cout\u2013out entries for the S-window seam: offers on non-\u22a5, OFF\u2192PAD and ON\u2192CAP conduits, and compatibility of \u22a5 with all neighbors (including S).", "Specify the clause-verification tableau: states, tape alphabet, row encodings, and the adjacency pairs checking U\u2019s single-step consistency; define the error-chain tokens and local acceptance rules.", "Formalize and prove the tester j* lemma: construct a clause-side active type that singles out a chosen variable i, and use it to separate \u03c4Var(i) from \u03c4Var(i\u2032).", "Produce the full B=2 worked example with concrete small alphabets and tables; run the layered DP by hand on all 12 ordered pairs to confirm OFF/ON behavior and clause-Horn constraints.", "Draft the succinct circuit that generates F(PC) (variables X and Y one-hots, per-clause Horns), and prove F(PC) is satisfiable iff \u03a6_C is."]}]

Current notes.md:
Verifier notes (2025-08-27):
- Adopt a hybrid: use Prover 02’s gate to separate ON (i∈vars(j)) from OFF pairs, and Prover 01’s window-anchored blocks to keep all semantics within wb/wc.
- Replace any O(1)-time checker with a poly(s)-length, radius-1 tableau inside wc (and wb as needed) that verifies C(j) and exposes the needed bits to the gate; ensure error-chain refutations for malformed headers.
- Do not rely on boundary-only signatures for type multiplicity; instead, separate types by differential boundary-extendibility induced by interior content (witness success/failure under fixed S-labels).
- Action items: (i) write explicit boundary tables (offers, gate, PAD/CAP conduits), (ii) specify the clause-verification tableau and its alphabet, (iii) prove type-separation and OFF/ON correctness, (iv) complete a B=2 worked example with DP simulation.

Current outputs.tex (if any):

