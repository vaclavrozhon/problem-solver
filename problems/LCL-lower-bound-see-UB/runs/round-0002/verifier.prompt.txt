--- SYSTEM ---
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (summary so far)
- output.md (rigorously proven results so far)

Guidelines:
- notes.md: should be a readable running log of interesting work. Prefer appending. Replace only if old notes are clearly misleading. Remember -- notes should be self-contained and should make sense even without seeing outputs of past provers. 
- output.md:  Think twice before you add something to this file. Everything here should be rigorous, almost publication-ready. It should contain only fully proven theorems that are clearly an interesting step towards the solution (or the solution itself). The beginning of the file is a clear list of interesting theorems you can prove, together with a discussion about why it is relevant. From the statement of the theorem it has to be clear that this constitutes nontrivial progress towards solution. The rest of the file contains a fully rigorous list of the proofs of the theorems. Keep only proven theorems with clear proofs. If a statement in that file is flawed / unprecise and you cannot fix it on the spot, remove it from output.md and instead add it to notes.md with explanation.
- Be careful with the booleans `new_notes_append` and `new_outputs_append`: default is True (append). Use False only when deliberately rewriting everything.

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (≥200 words). Include concrete next-step suggestions. The next round of provers may not see last round outputs; ensure all valuable info is stored in notes.",
  "new_notes_md": "Markdown (KaTeX allowed). Usually appended to notes.",
  "new_notes_append": "True|False",
  "new_outputs_md": "Markdown (KaTeX allowed). Usually appended to output.md.",
  "new_outputs_append": "True|False",
  "verdict": "success|partial success|nothing so far"
}

**Verdict definitions**:
- **success**: Something that one could publish, even if it is not the full solution (e.g., significant theorem, key lemma, novel technique, partial solution with clear path forward)
- **partial success**: Something worthy enough to write into output.md (e.g., correct but preliminary results, useful technical lemmas, validated approaches that advance understanding)
- **nothing so far**: No meaningful mathematical progress or only exploratory work


--- USER ---
You receive multiple prover reports. Evaluate correctness, value, and pick promising directions. Update notes.md (append/replace) with useful ideas and update output.md (append/replace) ONLY with rigorously verified results.

Prover reports (JSON):
[{"prover_id": "01", "progress_md": "## Round 0002 \u2014 2025-08-28T11:43:33Z\n\nFocus and plan for this round\n- Goal: push the NEXPTIME-hardness via Succinct 3-Coloring (S3Col) by cleanly aligning (F1) mid-consistency with pairwise edge constraints \u201ccolor(u) \u2260 color(v) when D(u,v)=1\u201d. Make (F2) vacuous via \u22a5-filler. Deliver concrete, radius-1 gadgets and type-separation lemmas that are checkable and do not rely on per-type ad hoc rules.\n- This round: (i) state and justify a \u201cboundary-anchored vertex-type separation\u201d lemma; (ii) design a seam simulation gadget that, on active vertex\u2013vertex pairs, computes D(u,v) in the bridge and enforces inequality if D(u,v)=1 while accepting any colors if D(u,v)=0; (iii) detail the \u22a5-filler that neutralizes (F2); (iv) give a small B=2 sanity check; (v) log minor clarifications for output.md.\n\nContext recap from last round\n- Use S3Col: input is circuit D of size s deciding an undirected succinct graph on V={0,1}^B (we can symmetrize by using D\u2032(u,v):=D(u,v)\u2228D(v,u)). Set B=s^{c0}, choose |\u03a3_out|=\u03b2=s^{c1} with c1\u226bc0. \u2113_pump=2^{\u0398(\u03b2^4)}\u226bpoly(s) so we have ample pumping room. We only need vertex-types (no clause-types).\n\nKey new lemmas (informal statements, why useful, and how to validate)\n1) Boundary-anchored vertex-type separation (existence of 2^B distinct vertex types)\n- Statement. There exists a \u03b2-normalized, radius-1 schema (global Cin\u2013out, Cout\u2013out) with constant role/phase/error/work tracks such that for each index u\u2208{0,1}^B there is at least one context type \u03c4_u in the context set C (realizable by some input word w_1 S w_2) with the following properties:\n  (A) Vertex activation near S on the left side: if the two-node window S is colored (non-\u22a5) and the left side is intended to be a vertex, then a radius-1 forced \u201cindex header\u201d of length \u0398(B) is determined immediately to the left of S; this header copies the B input bits (RID-track) adjacent to S via Cin\u2013out, so the u encoded in input is fixed. All malformed attempts can be locally refuted by error-chains.\n  (B) Probe distinguishability: there exists a fixed 4-tuple b\u22c6 of boundary outputs on the four boundary nodes of w_1 (two leftmost and two \u201csecond\u201d nodes) such that E_{w_1}(b\u22c6)=1 iff the input RID next to S equals u. Consequently, if u\u2260u\u2032, then \u03c4_u\u2260\u03c4_{u\u2032} (types differ on b\u22c6).\n- Why useful: gives us exponentially many pairwise distinct vertex context types, allowing a map f on types to encode a coloring \u03c7(u)\u2208{RED,GRN,BLU}.\n- How enforced at radius 1. We predefine a reserved \u201cprobe-left\u201d boundary pattern b\u22c6 using symbols that (i) fix a role/phase state at the two boundary layers and (ii) enable a single deterministic pipe that walks inward for B steps, checking at position j that the RID-output symbol agrees with the local input bit (Cin\u2013out) and with a constant j-th bit of the target u. If any check fails, the pipe has no legal continuation (no extension). If all pass, the pipe halts into a neutral filler. Because the pipe is unique, the existential nature of types cannot \u201ccheat\u201d by choosing a different interior: existence of a completion under b\u22c6 exactly encodes \u201cRID equals u\u201d.\n- Validation: The pipe is exactly the standard radius-1 pointer gadget (Section 3 in the attached paper) but with a bounded, fixed length B and equality tests via Cin\u2013out. The existence of contexts carrying any prescribed B-bit RID adjacent to S is guaranteed by considering input words over \u03a3_in; malformed inputs are harmless due to error-chains.\n\n2) Seam-simulation gadget for pairwise constraints (edge gating and color inequality)\n- Statement. There is a radius-1 out\u2013out schema such that for any ordered pair of active vertex types (\u03c4_u on the left, \u03c4_v on the right):\n  (i) If D(u,v)=0, there is a completion irrespective of the colors f(\u03c4_u), f(\u03c4_v) placed on the window S; (ii) If D(u,v)=1, there is a completion iff the two colors differ; and (iii) For any pair where at least one side is inactive (no well-formed vertex near S), there is always a completion (via \u22a5-plumbing), independent of the other side.\n- Why useful: This aligns (F1)\u2019s universal quantification with 3-coloring constraints: f feasible \u21d4 \u03c7(u)\u2260\u03c7(v) for all edges (u,v).\n- Seam layout (radius-1):\n  \u2022 Near-boundary index tapes. On each side, the \u0398(B)-long RID tape sits immediately adjacent to S (by Lemma 1). We also place a fixed-size \u201cheader acceptance\u201d bit (valid if the embedded header equals the constant D-encoding)\n  \u2022 Bridge tableau. On the wb\u25e6wc bridge, allow a standard 1D row-by-row simulation of a fixed universal TM U for poly(s) steps to evaluate D(u,v), reading the two B-bit tapes and the constant header. Each row transition is enforced by nearest-neighbor Cout\u2013out constraints; malformed rows can be refuted by error-chains as in \u00a73.\n  \u2022 Acceptance signals. The simulation emits a bit EDGE\u2208{0,1}. Local rules at S admit completion if (EDGE=0) or (EDGE=1 and colors on S are unequal). If EDGE=1 and colors equal, all continuations are forbidden. All these checks involve only constant-size neighborhoods around S.\n- Validation: Standard \u201ccomputation-by-tiling\u201d for 1D simulations as in \u00a73 and \u00a74; run time is poly(s)\u226a\u2113_pump and space sits in wb\u25e6wc (length \u2265\u2113_pump). Robustness via error-chains ensures that malformed headers and/or runs never constrain f.\n\n3) Neutralizing bridging (F2) by a \u22a5-filler\n- Statement. Add a self-looping \u22a5-track and allow wz (for any z\u22651) to be filled entirely with \u22a5 irrespective of boundary outputs adjacent to S. Then for every context (w_1,S,w_2) and z, the partial S-label from f extends by filling both sides with \u22a5, making (F2) hold vacuously.\n- Why useful: Reduces the classification to (F1) only on our instances, hence the 3-way classifier must output O(1) iff a feasible f exists and \u03a9(n) otherwise; the \u0398(log* n) case is eliminated for our reduction family.\n- Validation: This is compatible with the DP in output.md (Theorem 5) and with Lemma 1 (finite-Z) but stronger: it makes every z trivially feasible. It does not interfere with (F1) since (F1) instances use one copy of each side and the bridge; those are left unchanged by the \u22a5-filler language.\n\nBlueprint of the alphabet/tracks and local rules (radius-1, \u03b2=poly(s))\n- Fixed tracks in \u03a3_out (constant per node, combined into a single symbol):\n  1) Role/phase: {HEAD, VERT, RUN, PAD, PIPE, ERR_k, \u2026}\u00d7{phase modulo c}.\n  2) Header bits: output track that must match a fixed string enc(D) under HEAD-role; Cin\u2013out ties head-bit outputs to \u03a3_in bits so only inputs matching enc(D) allow HEAD.\n  3) RID tape: B bits adjacent to S on each vertex side; Cin\u2013out enforces that RID-bit output equals the input bit at that node (copy constraint) when in VERT-role.\n  4) Bridge-run work alphabet: constant-size tape symbols for U.\n  5) Color tokens and \u22a5 at S: {RED, GRN, BLU, \u22a5} available only at S positions (enforced by phases/roles around S).\n  6) Error-chain alphabet from \u00a73 to refute malformed fragments locally.\n- Cin\u2013out usage: ties HEAD bits to input; ties RID bits to input; allows generic symbols elsewhere. This guarantees that whether a vertex is well-formed is determined by inputs (hence activity is type-invariant once the boundary role is fixed).\n- Cout\u2013out (nearest-neighbor): enumerates allowed pairs that (i) implement the deterministic PIPE for Lemma 1 (RID-forcing/probe), (ii) implement the RUN tableau rows and acceptance edge-bit, (iii) enforce color inequality test when EDGE=1, and (iv) allow \u22a5-plumbing everywhere if chosen.\n\nSoundness/completeness sketches of the reduction (S3Col \u2192 FFE(F1))\n- Completeness (G 3-colorable \u21d2 feasible f exists): choose \u03c7:V\u2192{R,G,B}. For each vertex-type \u03c4_u, set f(\u03c4_u)=\u03c7(u); for all other (inactive) types, set f(\u03c4)=\u22a5. For any ordered pair, if both are active, the bridge computes EDGE=D(u,v). If EDGE=0, completion exists; if EDGE=1 then \u03c7(u)\u2260\u03c7(v) ensures completion by inequality check. All non-active pairs are vacuous due to \u22a5-plumbing. Hence (F1) holds.\n- Soundness (feasible f \u21d2 G 3-colorable): for each u, define \u03c7(u)=f(\u03c4_u) (well-defined since otherwise the ordered pair of two \u03c4_u representatives would violate (F1) via the bridge rules that require consistent acceptance conditions). For any edge (u,v), the bridge yields EDGE=1; thus (F1) forces f(\u03c4_u)\u2260f(\u03c4_v). Therefore \u03c7 is a proper 3-coloring.\n\nToy sanity check (B=2)\n- Suppose V={00,01,10,11} and D encodes a 4-cycle 00\u201301\u201311\u201310\u201300. Contexts include \u03c4_00,\u2026,\u03c4_11, each with RID=that index adjacent to S on the left or right side. The bridge-run reads those 2-bit RID tapes, computes EDGE (using D hardwired), and enforces inequality iff EDGE=1. A valid f assigns a 3-coloring of the 4-cycle; the DP on each (F1) instance accepts exactly under that condition.\n\nObstacles and how we address them\n- Type invariance vs. interior nondeterminism: Lemma 1\u2019s PIPE is deterministic and initiated solely by boundary outputs; if the probe is selected, the only way to extend is to carry the unique pipeline and match the B-bit RID from input. Thus the existence/non-existence of an extension under the probe is a property of the fixed input substring near the boundary, hence of the type.\n- Non-edges must accept any colors: We ensure the bridge-run emits EDGE=0 in that case, and acceptance rules ignore S colors. Since (F1) only needs existence of one completion, this suffices.\n- Symmetry of edges: Replace D by D\u2032(u,v)=D(u,v)\u2228D(v,u) in the instance to guarantee undirected adjacency while keeping size poly(s).\n- Global inputs adversarial: Our complexity claim is worst-case over inputs. The construction ensures malformed inputs are always completable (\u22a5/error-chain) and do not constrain f; active contexts (those that matter) arise from many input strings (enough to ensure all \u03c4_u exist as realizable types), which suffices because (F1) quantifies over all contexts.\n\nGaps/clarifications in output.md (minor)\n- Composition lemma wording (Lemma 2): the proof mentions \u201ctwo internal adjacencies across the seam\u201d using (p_left,p_right); to avoid confusion, note explicitly that (i) the adjacency within u between its last two outputs and within v between its first two outputs are already captured by Type(u), Type(v), and (ii) the seam adjacency is only between the last output of u (p_right) and the first of v (p_left); the boolean-matrix view in Appendix A already encodes this correctly.\n- Types vs. interior inputs: Definition currently says \u201cinterior inputs may be arbitrary\u201d; in our \u03b2-normalized model inputs are fixed per instance. It may help to state explicitly that E_w(a) is computed with the interior inputs fixed to those of w; this is consistent with Lemmas 10\u201315 in the attached paper and with the DP in Theorem 5.\n\nWhy the new lemmas are auditable now\n- Lemma 1 reduces to a finite-radius PIPE with length B=poly(s) (bounded independent of \u2113_pump) that is checkable by local tables; E_w(b\u22c6) depends only on the fixed w (hence on Type(w)). The verifier can test a concrete instantiation on a small B (e.g., B=2) by brute-force DP to observe the extendibility difference.\n- The seam simulation is a standard 1D tableau simulation; a checker can write out the row alphabet and the local transition constraints for a small instance (with a 2-input AND gate as D) and verify the edge/inequality behavior.\n\nNext steps (concrete, checkable deliverables)\n1) Write the explicit adjacency fragments:\n   - RID-PIPE: list states for \u201cstep j\u201d (0\u2264j\u2264B), legal successors, and Cin\u2013out masks that tie role=RID,j to the input bit.\n   - Bridge-run: define the U-row alphabet and per-row local constraints; define the EDGE output; layout how it reads RID tapes.\n   - Color-check rules at S conditional on EDGE.\n2) Prove the vertex-type separation lemma formally: select b\u22c6, show E_w(b\u22c6)=1\u21d4RID(u) and that u\u2260u\u2032 gives differing extendibility tables \u21d2 distinct types.\n3) Formalize the soundness/completeness argument into a theorem \u201cS3Col \u2264_m FFE(F1) for \u03b2-normalized r=1\u201d with explicit size bounds (|\u03a3_out|=poly(s), tables of size \u0398(\u03b2^2)).\n4) Integrate the \u22a5-filler rules and note that (F2) is vacuous; state the corollary \u201c3-way classification is NEXPTIME-hard on our family\u201d.\n\nPotential stretch: tighten the (F2) finite-Z bound in output.md from \u2113^2 to lcm(periods)\u00d7(max preperiod) (still \u2264\u2113^2) and add a remark on how to compute it from the type DFA; not needed for hardness but improves the upper-bound section.\n"}, {"prover_id": "02", "progress_md": "Status. We have a solid upper-bound skeleton (types, composition, periodicity, finite-Z for (F2), and the O(k\u03b2^2) DP) captured in output.md. To push hardness to NEXPTIME for the 3-way classifier, I focus on formalizing the succinct 3-coloring reduction via (F1), with two key technical lemmas: (i) type-separation per vertex index u using a boundary-probe truth-table signature realized by a radius-1 checker; (ii) a seam gadget that, on colored S-windows, locally simulates D(u,v) (adjacency) across the bridge, accepting iff either non-edge or colors differ. I also point out a minor optional tightening in output.md and confirm its current statements are correct as written.\n\nGaps/remarks on output.md (minor). \n- The \u2113^2 bound in Corollary 4 is correct and sufficient; optionally, one can refine Z to preperiod1 + preperiod2 + lcm(period1, period2) \u2264 2\u2113 + \u2113 \u2264 3\u2113 (or \u2264 lcm periods) by analyzing the pair map on T\u00d7T, but this is nonessential. The current deterministic DP lemma (Theorem 5) is correct; an explicit treatment of boundary inputs when k<4 is trivial and can be omitted. No correctness issues spotted.\n\nPlan and why useful. \n- Pivot source to Succinct 3-Coloring (NEXP-complete). For a circuit D of size s deciding adjacency on V={0,1}^B (B=s^{c0}), we construct a \u03b2-normalized, r=1 LCL P_D with \u03b2=s^{c1} (c1\u226bc0) so that: existence of a feasible function (F1) \u21d4 G is 3-colorable. This matches (F1)\u2019s universal quantification (pairwise inequality on edges) and avoids clause-level \u2203-quantifiers.\n\nCore technical ingredients (new lemmas, concrete gadgets).\n\nLemma A (Type-separation via boundary-probe signature). Fix integers B=s^{c0} and \u03b2=s^{c1} with 4c1>c0. There exists a radius-1 \u03b2-normalized LCL fragment that enforces: for any path segment W that contains a well-formed vertex block encoding an index u\u2208{0,1}^B (and no errors), the type Type(W) has extendibility truth-table over the \u03b2^4 boundary-output assignments equal to an injective signature g(u)\u2208{0,1}^{\u03b2^4}. In particular, u\u2260u\u2032 \u21d2 Type(W)\u2260Type(W\u2032).\n- Construction sketch (radius-1):\n  \u2022 Reserve in \u03a3_out constant tracks: role/phase, error alphabet, a \u22a5-plumbing symbol, and a RUN track for a fixed universal TM U. The vertex block stores u in a self-delimiting header and includes a short RUN zone computing on demand bits of an injective signature g(u) of length L=\u03b2^4\u22652^B (we can set g(u) to the length-L zero-padded copy of u followed by a fixed injective encoding). The run budget is poly(s).\n  \u2022 Boundary-probe coding: Each of the four boundary outputs carries an index digit in base \u03b2; together they encode b\u2208[\u03b2^4] (the probe index). Adjacency rules copy these 4 base-\u03b2 digits along \u201ccarrier\u201d subtracks deterministically from both ends toward the interior (radius-1 constraints enforcing equality along edges). If the two ends encode different b, a detector in the middle halts with an unsatisfiable local pattern \u21d2 that boundary assignment is rejected (truth-table bit 0). If they match, the bridge enables U to read (u,b) from the interior/carriers and compute g(u)[b] in poly(s) steps within W. Local acceptance (extendibility) is permitted iff g(u)[b]=1 (otherwise the RUN must end in a dead configuration). Malformed interiors open an error-chain (always extendible) and are hence excluded when defining vertex types.\n- Why useful: It produces \u22652^B distinct types attributable to different u while using only \u03b2 symbols and radius 1; f can then assign colors per vertex-type \u03c4_u.\n\nLemma B (Realization of vertex context types near S). For each u, there exist contexts (w_1,S,w_2) with |w_i|\u2208{\u2113_pump,\u2113_pump+1} whose left (or right) side contains a well-formed vertex block for u adjacent (within O(1)) to S, and whose type equals the Type(W) from Lemma A. Moreover, replacement/pumping (Lemmas 11, 14\u201315) ensure that these contexts persist under padding to the required lengths.\n- Why useful: Guarantees the context set C contains, for each u, at least one \u201cvertex\u201d type \u03c4_u on which f can act.\n\nLemma C (Seam gadget for succinct adjacency and color inequality). There is a radius-1 out\u2013out grammar across the seam between a left \u03c4_u-context and a right \u03c4_v-context such that, when both S windows are colored, the bridge wa S_1 wb wc S_2 wd admits a completion iff either D(u,v)=0 (non-edge) or D(u,v)=1 and the two colors differ. If either side is not a vertex context (no valid block), the seam always completes (via \u22a5-plumbing or error chains) irrespective of S.\n- Construction sketch:\n  \u2022 Seam handshake: Near each S window, a constant-size \u201chandshake\u201d subtrack asserts role=VERTEX, and opens a bounded-width corridor through wb\u2218wc where a fixed TM U simulates D(u,v) for poly(s) steps using the copies of D from the interiors and seam pointers that fetch u (on the left) and v (on the right). As in \u00a73 of the attached paper, each tableau row is locally checked by Cout\u2013out; malformed runs are locally refutable (error-chain), keeping non-vertex contexts harmless.\n  \u2022 Acceptance policy: The corridor exposes a verdict bit Edge(u,v). The adjacency table then enforces: if Edge=0, accept regardless of colors; if Edge=1, require Color(S_1)\u2260Color(S_2) (three colors in a constant subalphabet). Violations force a dead pattern (no completion). All checks are radius-1 because comparisons are between adjacent row/phase symbols and the two S outputs.\n- Why useful: Encodes the exact pairwise 3-coloring constraint on edges within (F1)\u2019s universal pair quantification; non-edges/vacuous pairs always pass.\n\nLemma D (Bridging neutralization). Add \u22a5-repetition plumbing: for any context (w_1,S,w_2), all repetitions w_1^z and w_2^z can be filled entirely with \u22a5 while remaining compatible with any S outputs and the fixed boundary inputs. Then (F2) holds for every f.\n- Why useful: Collapses the three-class decision to (F1)-feasibility, transferring NEXP-hardness to the classifier (O(1) vs \u03a9(n) on our instances).\n\nSoundness/completeness outline for the reduction (auditable).\n- Parameters: Choose c1\u226bc0 so that \u03b2^4 = s^{4c1} \u2265 2B; then \u2113_pump = 2^{\u0398(\u03b2^4)} = 2^{poly(s)}. Block length is poly(s)\u226a\u2113_pump.\n- Cmpltns:\n  \u2022 If G is 3-colorable with \u03c7:V\u2192{R,G,B}, define f(\u03c4_u) = (\u03c7(u) on S) and f(\u03c4)=\u22a5 for non-vertex types. For any ordered pair (\u03c4_left, \u03c4_right), the seam gadget computes Edge(u,v); non-edges accept; edges accept iff \u03c7(u)\u2260\u03c7(v). Hence all (F1) checks pass. (F2) is vacuous by Lemma D.\n- Sndnss:\n  \u2022 If f satisfies (F1), read \u03c7(u)=f(\u03c4_u). Consider any edge (u,v). The pair (\u03c4_u, \u03c4_v) must pass the (F1) DP; by Lemma C, this forces \u03c7(u)\u2260\u03c7(v). Therefore \u03c7 is a proper 3-coloring.\n\nKey implementation details (to be checked next, but radius-1 and \u03b2=poly(s)).\n- Fixed tracks in \u03a3_out (constant multiplicity): role/phase states; three color tokens and \u22a5; RUN work alphabet of the fixed U; error-chain symbols. The total |\u03a3_out|=\u03b2 can be chosen polynomial in s to host these tracks.\n- Probe carriers: The four boundary positions provide base-\u03b2 digits (b_1,b_2,b_3,b_4) coding b\u2208[\u03b2^4]; per-edge Cout\u2013out permits copying these digits unchanged along special carrier tracks. A small synchronizer ensures two carriers meet and agree before the RUN consults b.\n- Robustness: Any malformed header/index/RUN admits a locally checkable error-chain (as in the LBA construction), so such contexts never constrain f; they can be mapped to \u22a5 by f.\n\nToy sanity checks.\n- Tiny \u03b2 example: Let \u03b2=3, reserve 3 colors+\u22a5 and minimal RUN symbols. With B=2 (four vertices), choose a trivial D; the seam accepts iff colors differ on the unique edge case. The probe signature g(u) can be just the 9-bit (\u03b2^4=81 in general; here smaller) table determined by U\u2019s response to the four boundary symbols; in the toy, let g(u) encode u across a few \u201cdistinguishing\u201d boundary assignments to see Type(W_u)\u2260Type(W_v) by direct DP.\n\nObstacles and mitigations.\n- Probe capacity vs. 2^B: We cannot dedicate a distinct boundary 4-tuple per u since \u03b2^4\u226a2^B; instead we use the full truth-table over \u03b2^4 probes, mapping u\u21a6g(u)\u2208{0,1}^{\u03b2^4} injectively (possible since \u03b2^4\u2265B). The grammar is uniform; dependence on u enters only via the interior-encoded u read by U.\n- Uniformity within types: Because the probe acceptance policy is fixed and depends only on (boundary 4-tuple, interior u), all representatives of the same type (i.e., same interior u and no errors) yield identical extendibility tables, satisfying type-invariance.\n- Ensuring active \u03c4_u exist: Use Lemma 11 (replacement) and Lemmas 14\u201315 (pumping) to embed the O(poly(s))-length block adjacent to S within words of length \u2113_pump or \u2113_pump+1 on each side, without changing the type.\n\nNext concrete steps (incremental, testable).\n1) Formalize Lemma A. Specify: (i) the base-\u03b2 boundary-digit carriers and their radius-1 propagation; (ii) the U-simulation that, given (u,b), outputs g(u)[b] and how Cout\u2013out enforces acceptance iff 1. Prove type-separation: u\u2260u\u2032 \u21d2 the truth tables differ in at least one b.\n2) Formalize Lemma C. Write the exact row interface and verdict wiring so that (Edge=0) \u21d2 unconditional acceptance, (Edge=1) \u21d2 require Color(S_1)\u2260Color(S_2). Include the local refutation for malformed runs.\n3) Prove Lemma B: a clean pumping/replacement embedding argument placing blocks within contexts of the required lengths while preserving type.\n4) Package the construction P_D and the equivalence \u201cG 3-colorable \u21d4 (F1)-feasible f exists,\u201d then add the \u22a5-repetition rules (Lemma D) to transfer hardness to the O(1)/\u03a9(n) classification.\n\nWhy this is progress.\n- It addresses the main unresolved pieces flagged by the verifier: a type-invariant \u201cactivity\u201d mechanism and a pairwise constraint that matches (F1). The boundary-probe signature provides exponentially many distinct types with \u03b2=poly(s) and radius-1 rules; the seam gadget exactly encodes edge constraints suitable for (F1). These are compact, checkable subclaims that can be verified independently using the O(k\u03b2^2) DP.\n"}, {"prover_id": "03", "progress_md": "Ideas \u2014 pivot formalization via succinct 3-coloring and type separation\n- Goal of this round: Make the NEXPTIME-hardness route auditable by (i) aligning (F1) semantics with a pairwise constraint problem (succinct 3-coloring), and (ii) pinning down a concrete, radius-1 mechanism that guarantees exponentially many distinct context types (one per vertex u \u2208 {0,1}^B) even though f is defined on types (not concrete words). We state small lemmas with proof sketches and bookkeeping, and we flag minor clarifications for output.md.\n\nClaim A (3-coloring matches (F1)). Why useful here: It resolves the quantifier mismatch that plagued 3SAT-style reductions; (F1) enforces universal pairwise constraints, exactly color(u) \u2260 color(v) for edges.\n- Source: Succinct 3-Coloring instance D: {0,1}^{2B} \u2192 {0,1}, circuit of size s; vertices V = {0,1}^B.\n- Target semantics (mid-consistency (F1) only): Context types corresponding to vertices \u03c4_u on both sides; the (F1) bridge between (\u03c4_u, \u03c4_v) must succeed (extend) iff either (i) D(u,v)=0 (non-edge; vacuous) or (ii) D(u,v)=1 and f(\u03c4_u) \u2260 f(\u03c4_v).\n- Implementation sketch: When S is colored, the bridge launches a row-by-row, radius-1-checked U-simulation on input (D,u,v) embedded in the inputs near the seam. Local rules guarantee: if D(u,v)=1 and colors equal, the bridge dead-ends; otherwise the bridge always extends. All other role pairings and inactive contexts allow trivial completions (\u22a5-plumbing). This aligns (F1) with 3-colorability.\n\nClaim B (Type separation via boundary test family; B.1). Why useful here: Ensures at least 2^B distinct context types \u03c4_u exist, allowing f to encode a color per vertex.\n- Parameters: Choose integers B = s^{c0}, \u03b2 = s^{c1} with 1 \u226a c0 \u226a c1 so that \u03b2 \u2265 B and \u2113_pump = 2^{\u0398(\u03b2^4)} = 2^{poly(s)}.\n- Reserved test boundary assignments: Fix one boundary-input 4-tuple a\u22c6. Reserve a collection J of size M := \u03b2 distinct boundary-output 4-tuples {b_t : t \u2208 [M]}; choosing b_t means \u201cactivate test id t\u201d. All other boundary outputs are filler. This uses only O(\u03b2) reserved symbols (poly(s)).\n- Input layout inside \u03c4_u: The input track near the left end contains (i) a mask table row M_t \u2208 {0,1}^B for each t \u2208 [M] (packed contiguously and self-delimited), and (ii) a vertex-index block RID(u) \u2208 {0,1}^B stored once in a fixed phase near S. The right end is symmetric or carries only fillers (not used for separation). We require well-formedness by radius-1 local rules; malformed encodings are locally refutable by error chains (as in \u00a73 of the reference), hence \u201cinactive.\u201d\n- Local test protocol: Under the boundary assignment (a\u22c6, b_t), the out\u2013out rules enable a pointer that (1) walks from the left boundary to read the t-th mask row M_t, (2) walks to the RID block, and (3) computes parity \u27e8M_t, u\u27e9 mod 2 using a fixed U-simulation in O(B) steps, all radius-1 checkable. If parity = 1, the pointer can terminate in an accepting sink; if parity = 0, no accepting continuation exists (the DP gets stuck). For all other boundary-output assignments (non-reserved), we permit a trivial completion (\u22a5 buffers) so they don\u2019t affect separation.\n- Linear independence: Pick M \u2265 B masks whose rows form a full-rank B\u00d7M matrix over GF(2); since M=\u03b2 \u2265B, this is possible. Then the signature map Sig(u) := (\u27e8M_t,u\u27e9)_{t\u2208[M]} \u2208 {0,1}^M is injective on {0,1}^B. For the fixed boundary-input a\u22c6, the extendibility table for reserved outputs is exactly E_{w(u)}(a\u22c6)[b_t] = Sig(u)_t. Consequently, u \u2260 u\u2032 \u21d2 Type(w(u)) \u2260 Type(w(u\u2032)).\n- Radius/size: The checker is constant-radius (pointers and row-to-row tableau), uses a constant work alphabet, with \u03b2 = poly(s) large enough to host reserved symbols. The mask table sits in the input (binary) and is read by the pointer; malformed tables are harmless due to error chains.\n\nClaim C (Realization of exponentially many vertex context types; B.2). Why useful here: Guarantees that, among contexts w_1 S w_2 with |w_i| \u2208 {\u2113_pump, \u2113_pump+1}, there are at least 2^B distinct types representing all vertices u.\n- Using Claim B, fix for each u an input string W(u) that realizes the left block (table + RID(u)), a neutral S, and a right filler block; ensure via pumping (Lemma 14/15) that both sides have length \u2113_pump or \u2113_pump+1 and that replacement preserves type (Lemma 11). Then Type(W(u)) are all distinct and populate C (the context-type domain for f). The same construction symmetrically realizes right-side vertex contexts \u03c4_v.\n\nClaim D (Bridge gating for succinct adjacency; B.3). Why useful here: Implements the pairwise constraint \u201cif edge then colors differ, else vacuous\u201d under (F1).\n- Input near both sides supplies (i) a copy of D\u2019s encoding (as in the LBA proof, stored in binary and copied by outputs), (ii) the local RID blocks (u and v). Upon non-\u22a5 colors at S, the bridge runs U on input (D,u,v) for poly(s) steps; rules enforce success as follows:\n  \u2022 If the simulation yields D(u,v)=0 (non-edge), accept irrespective of colors by enabling a trivial acceptor after the run.\n  \u2022 If D(u,v)=1 (edge), accept iff two color tokens at S are different; if equal, dead-end. The \u201ccolor-different\u201d test is purely local across the S seam.\n- Robustness: Inactive/malformed blocks admit the standard error chains; colored S then cannot complete and hence forces f to map such types to \u22a5.\n\nClaim E (From (F1) to classification hardness; B.4). Why useful here: Transfers hardness from (F1)-feasibility to the 3-way decision by neutralizing (F2).\n- Add a global \u22a5-filler language for repetitions so that for any context (w_1,S,w_2) and any z\u22651, w_1^z and w_2^z can be labeled with \u22a5 (independent of inputs). Thus (F2) holds vacuously for any f. Therefore, deciding whether (F1) holds (i.e., whether G is 3-colorable) is as hard as the 3-way classification on our instances.\n\nProof sketches for soundness/completeness (FFE(F1) \u2194 3-coloring)\n- Completeness: Given a proper 3-coloring \u03c7: V \u2192 {RED,GRN,BLU}, define f(\u03c4_u)=\u03c7(u). For any pair (\u03c4_u,\u03c4_v), the bridge computes D(u,v); if non-edge it accepts; if edge, \u03c7(u)\u2260\u03c7(v) by proper coloring, so acceptance follows. Inactive contexts mapped to \u22a5 are trivially satisfied.\n- Soundness: If f satisfies (F1), define \u03c7(u)=f(\u03c4_u). For any edge (u,v), (F1) requires that the bridge succeeds; the only way it can succeed on edges is with \u03c7(u)\u2260\u03c7(v). Hence \u03c7 is a proper 3-coloring.\n\nInstantiation details to verify next (concrete, checkable)\n1) Pointer/test gadget (radius-1): Specify the constant-size out\u2013out automaton for the test: states \u201cgo-to-row t\u201d, \u201cscan mask bits\u201d, \u201caccumulate parity\u201d, \u201cjump to RID\u201d, \u201caccumulate parity\u201d, \u201caccept if 1\u201d; verify all transitions read-only from input and are nearest-neighbor.\n2) Mask addressing with small boundary ID: Limit test IDs t to [\u03b2], each encoded by one of \u03b2 reserved symbols. In input, arrange the mask table as \u03b2 rows of length B with clear row delimiters; the \u201cgo-to-row t\u201d stage follows row delimiters counted via the ID implicit in the chosen boundary symbol. Local rules ensure the pointer\u2019s row-counter matches the selected symbol; wrong row \u21d2 dead-end (so the DP cannot cheat by reading a different row).\n3) Existence of contexts of length \u2113_pump: Use pumping/replacement to pad left/right to prescribed lengths without changing types, ensuring that (i) the reserved boundary tests remain available at the outermost two boundary nodes, and (ii) the interior test and RID regions remain intact.\n4) Bridge TM: Use the same row-by-row U-simulation as in \u00a73 to evaluate D(u,v) in poly(s) time. Errors are locally refutable; malformed inputs cannot permit a colored-S completion, making such contexts inactive.\n5) Size bookkeeping: \u03a3_out tracks: roles/phases, 3 colors + \u22a5, error alphabet, and U\u2019s work alphabet are constant; plus \u03b2 many reserved test symbols and a constant amount of plumbing. Tables Cin\u2013out, Cout\u2013out remain size poly(\u03b2)=poly(s). Input length is unbounded and holds the mask table, RID blocks, and circuit D wherever needed.\n\nToy example (sanity)\n- Take B=2, \u03b2=8, masks M_t \u2208 {00,01,10,11,01,10,11,00} (first 4 rows linearly independent). For u\u2208{00,01,10,11}, the reserved boundary outputs b_t induce an extendibility pattern equal to the parity vector across the first 4 tests; the four \u03c4_u types differ on these 4 bits. On the bridge, if D is a 4-cycle adjacency, f(\u03c4_u) = u mod 3 gives a valid coloring; pairs on edges with equal colors are forbidden locally.\n\nNotes/obstacles\n- Mask-table on input vs. grammar size: We deliberately read mask rows from input to avoid hardwiring O(\u03b2\u00b7B) bits into Cout\u2013out; only the per-test control (\u03b2 distinct boundary tokens) are baked into Cout\u2013out.\n- Dependence only on type: The separation relies on fixed boundary-input a\u22c6 and the reserved family {b_t}. For any two words with the same input content (table + RID) but otherwise different interiors, the existence or non-existence of a completion under (a\u22c6, b_t) is forced by the local test, hence is type-invariant. Distinct u\u2019s yield distinct yes/no pattern across {b_t}, so types differ.\n- Ensuring non-edges are vacuous: The bridge must accept for D(u,v)=0 irrespective of colors. We implement this by enabling a finishing acceptor after the U-run concludes \u201c0\u201d, independent of S\u2019s colors.\n\nMinor clarifications/suggestions for output.md\n- Types and fixed inputs: In \u201cDefinitions (radius 1)\u201d, clarify that E_w(a) is with respect to the fixed input string on the entire path; the parenthetical \u201cinterior inputs may be arbitrary\u201d could be read as allowing the verifier to choose internal inputs. For our model, the input word is fixed; the extension existentially quantifies outputs only.\n- Context set C size: Where LCL_classification.pdf states \u201cNote |C| \u2264 \u2113_pump,\u201d consider adding a short justification: a context type is a specific element of the global type set T realized by a word of the form w_1 S w_2 with |w_i| \u2208 {\u2113_pump,\u2113_pump+1}; hence |C| \u2264 |T| = \u2113_pump.\n\nNext steps\n- Write the explicit local rule set for the boundary test gadget and prove the Type-Separation Lemma rigorously (injectivity from M\u2265B linearly independent masks).\n- Specify the seam U-simulation interface and the local rule that gates acceptance by \u201cD(u,v)=0 or colors differ.\u201d\n- Package the reduction formally: map D \u21a6 P_D with \u03b2=poly(s), prove \u201cG 3-colorable \u21d4 (F1)-feasible f exists\u201d, and add the \u22a5 repetition to neutralize (F2). This will give a clean NEXPTIME-hardness statement for the 3-way classification.\n"}, {"prover_id": "04", "progress_md": "Ideas: boundary-probe separation for vertex types; succinct 3-coloring bridge\n- Pivot retained: Reduce Succinct 3-Coloring (NEXP-complete) to Feasible-Function Existence (F1) for \u03b2-normalized, r=1 LCLs on oriented paths. Colors at the S-window implement the vertex coloring; the bridge between two contexts simulates D(u,v) and enforces \u201c\u2260\u201d iff D(u,v)=1.\n- New ingredient (type separation without per-type tailoring): Design a fixed family of boundary-output \u201cprobe patterns\u201d Q_j (one per bit index j\u2208[B]) that, when set on the four boundary nodes of a context, uniformly trigger a radius-1 pointer that reads the j-th bit of an interior u-block positioned O(1) from S. The existence (extendibility) of a completion under probe Q_j equals that bit. Therefore the vector (ext_Q_j)_{j=1..B} encodes u, and different u yield different types. This avoids the flawed idea of \u201cprogramming arbitrary boundary truth tables per type\u201d.\n\nClean statements (to be proven/verified)\n- Lemma A (Probe-bits). There exist global Cin\u2013out, Cout\u2013out and, for the left-side vertex-context shape W(u) (|W(u)|\u2208{\u2113_pump,\u2113_pump+1}), a fixed family of boundary-output 4-tuples {Q_j: j\u2208[B]} such that, for any boundary input assignment a, Gw:=W(u) has a legal completion with boundary outputs Q_j on its four boundary nodes iff the j-th bit of u equals 1. Consequently, Type(W(u))\u2260Type(W(u\u2032)) for u\u2260u\u2032.\n  Why useful: Gives 2^B distinct vertex context types using only B=poly(s) probes, well within the \u03b2^4 boundary assignments. The construction is uniform and radius-1 (probes trigger a constant-symbol \u201cprobe role\u201d that spawns a pointer reading the port region where u\u2019s bits are pre-exposed near S; failures dead-end).\n- Lemma B (Canonical vertex-context family). There exist two canonical context shapes L(u):=W_L(u) S F_R and R(v):=F_L S W_R(v) with |W_L(u)|,|W_R(v)|\u2208{\u2113_pump,\u2113_pump+1} and fixed fillers F_L,F_R (no vertex data) such that:\n  (i) L(u) and R(v) are active (contain well-formed u- or v-blocks anchored O(1) from S),\n  (ii) Type(L(u)) (resp. Type(R(v))) is determined by u (resp. v) via Lemma A, and\n  (iii) any other context type without such a block is inactive: any non-\u22a5 color at S leads to a locally-detectable dead end; \u22a5 always extends via neutral plumbing.\n  Why useful: Ensures exactly one (or at least a unique canonical) type per vertex; non-vertex types force f(\u00b7)=\u22a5 by (F1) universal quantification.\n- Lemma C (Bridge semantics for 3-coloring). There is a fixed, radius-1 seam gadget (placed across the concatenation of L(u) and R(v) in an (F1) instance) that locally simulates a universal TM U for poly(s) steps to evaluate D(u,v) using:\n  (i) a copy of D stored in each block (copied from \u03a3_in via Cin\u2013out), and\n  (ii) the B-bit ports of u (on the right edge of L(u)) and v (on the left edge of R(v)).\n  The bridge admits a completion iff [D(u,v)=0] or [D(u,v)=1 and the two S colors differ]. Malformed simulations are locally refutable (standard error-chain); spurious accept is impossible due to row-to-row radius-1 checks.\n  Why useful: Matches (F1)\u2019s universal pair check with \u201c\u2260 on edges, trivial on non-edges\u201d.\n\nSketch of constructions (radius-1 and uniform)\n- Vertex block (near S): A constant-role phase track places a \u201cport zone\u201d of length \u0398(B) immediately adjacent to S inside W_L(u) (to the right) and W_R(v) (to the left). This port zone carries the B bits (u_1,\u2026,u_B) (resp. v) twice with parity/check bits; its layout is enforced by Cout\u2013out (deterministic pattern given activation at S). The rest of the block includes a self-delimiting header and a RUN zone encoding U\u2019s tableau on input D (copied from the input track) and the index, all standard and locally checkable.\n- Probe patterns Q_j: Four special outputs on the boundary (two per side of the word) encode a \u201cprobe-bit j\u201d token with local phase. Cout\u2013out has rules: if a probe token sits on the boundary, the unique legal continuation from that boundary is a finite-state pointer that advances into the port zone, lands on the j-th cell, and requires its bit=1; otherwise no outgoing legal edge exists in the layered DP. This uses O(1) symbols and maintains radius-1 (pointer heads advance cell-by-cell with locally checkable direction and countdown in unary up to j encoded by constant number of \u201crepeat until phase X\u201d steps; the step count is derived by walking, not stored in boundary symbols). Result: extendibility under Q_j discriminates u_j.\n- Bridge simulation: In wa S1 wb wc S2 wd with wa S1 wb=L(u), wc S2 wd=R(v), the seam region wb wc contains a fixed-width (poly(s)+O(B)) \u201cbridge RUN\u201d where U takes as inputs (D, u, v) read from the adjacent port zones and computes d:=D(u,v). Cout\u2013out enforces single-step tableau constraints, with local error-escape allowed only for malformed inputs; a dedicated final row propagates d to a 1-bit flag near S2. Separate local rules check \u201cif d=1 then colors at S1,S2 must be unequal; if d=0 then no constraint on colors\u201d.\n\nCorrectness of the reduction (succinct 3-coloring \u21d2 (F1) and vice versa)\n- Completeness: If G is 3-colorable, fix \u03c7: {0,1}^B\u2192{RED,GRN,BLU}. Define f on vertex types by f(Type(L(u))) = \u03c7(u) and f(Type(R(v))) = \u03c7(v); define f(\u03c4)=\u22a5 for all inactive (non-vertex) types. For any ordered pair of contexts in the (F1) check, either both are vertex-types (u,v): the bridge computes D(u,v) and enforces \u03c7(u)\u2260\u03c7(v) when D=1 (holds by proper coloring), or at least one is inactive, in which case \u22a5 plumbing makes the DP succeed. Hence (F1) holds.\n- Soundness: If some f satisfies (F1), read \u03c7(u) := f(Type(L(u))). For any u,v with D(u,v)=1, the bridge between Type(L(u)) and Type(R(v)) must be extendible; the simulation forces \u03c7(u)\u2260\u03c7(v). Thus \u03c7 is a proper 3-coloring. Non-vertex types cannot be mapped to a color, else some pair (inactive, anything) would violate (F1) due to the local \u201ccolors-only-when-vertex\u201d gating; therefore setting them to \u22a5 is necessary and consistent.\n\nNeutralizing (F2) and hardness for the tri-class classifier\n- As in previous rounds, add a global \u22a5-filler language permitted on repeated sides w_i^z independent of context; then (F2) is true for every f by Lemma 1 in output.md. Therefore the classifier answers O(1) iff (F1) holds, and \u03a9(n) otherwise (Theorem 8 machinery). Since feasible-function existence (mid-consistency) is NEXPTIME-hard by the reduction above and in NEXPTIME (output LCL_classification.pdf), the three-way classification is NEXPTIME-hard.\n\nExamples and sanity checks\n- Tiny case B=2: u\u2208{00,01,10,11}. Define Q_1,Q_2 probes. For the four left-contexts L(u), the 2-bit vector (ext_Q1, ext_Q2) equals u. The bridge runs D on pairs and requires color-inequality only on edges.\n- DP perspective: The probe under Q_j forces a unique finite path in the layered automaton that reaches the j-th port cell; existence of an outgoing edge at that cell hinges on the bit=1. The bridge tableau likewise becomes a layered composition check; any inconsistency blocks all paths, so the DP precisely mirrors the existence of a legal completion.\n\nObstacles / things to make explicit next\n- Probe pointer encoding: Make the boundary probe tokens and the in-block \u201cport zone\u201d phases explicit, with a table showing (current symbol, next symbol) pairs permitted by Cout\u2013out. Verify that the pointer is guaranteed to stop on the exact j-th cell (walk semantics) without storing j in the boundary symbol (to keep alphabet constant).\n- Seam I/O interface: Specify how the bridge RUN reads u and v: either by duplicating the B-bit ports directly adjacent to the bridge (preferred), or via pointers with locally checkable handshakes. The former is cleaner and fits \u2113_pump.\n- Error-chain integration: Ensure malformed blocks are always completable via the error alphabet (like \u00a73), and that the color-at-S activation is allowed only when the vertex role is present, preventing spurious constraints on inactive types.\n- Size bookkeeping: Enumerate the tracks and show |\u03a3_out| = \u03b2 = poly(s) suffices: roles/phases O(1), colors+\u22a5 (4), error alphabet O(1), U\u2019s work tape O(1), plus finitely many probe/pointer states O(1). The \u201cO(B)-long\u201d ports are spatial, not alphabetic.\n\nGaps/notes on output.md\n- The core lemmas (type bound, composition, periodicity, finite-Z, DP) are sound and sufficient for our verifier. Minor clarification: in Theorem 5 the DP assumes fixed input string; the construction adapts by restricting layer i to Cin\u2013out[Input(i)]. No action needed.\n- The bound Z\u2264\u2113^2 (Cor. 4) is non-tight but usable; we will carry it as-is for (F2) neutralization.\n\nNext steps (auditable deliverables)\n1) Formalize Lemma A with a concrete probe alphabet and Cout\u2013out snippet; prove the \u201ciff u_j=1\u201d claim rigorously.\n2) Specify the canonical L(u), R(v) layouts with exact offsets: positions of the port zones, header footprint, and RUN rows. Provide a bound O(poly(s)) for occupied length.\n3) Write the seam tableau interface and prove Lemma C: that the only accepting completions correspond to the correct d = D(u,v) and enforce inequality when d=1.\n4) Package the reduction C\u21a6P_D, including \u22a5-filler for (F2), and finalize the completeness/soundness argument with explicit references to the output lemmas (replacement, pumping) to guarantee existence of required contexts within lengths \u2113_pump or \u2113_pump+1.\n"}]

Current notes.md:
Working model and notation (radius 1, β-normalized)
- We study LCLs on globally oriented paths with fixed input alphabet Σ_in and output alphabet Σ_out of size β. The local legality is given by two global relations: Cin–out relating each input symbol to allowed output symbols at a node, and Cout–out relating allowed pairs of consecutive output symbols. The radius is 1.
- A path segment w has four boundary nodes (two on the left, two on the right). For a fixed assignment to the four boundary inputs, we define the extendibility bitvector over all β^4 assignments to the four boundary outputs indicating for which boundary-output assignments there exists a legal extension to the interior.
- The type Type(w) is the collection, over all 4-boundary input assignments, of these extendibility bitvectors. Two words share a type if they have identical extendibility behavior for all boundary input/output assignments. Let T be the finite set of all types realizable by some word.

Verified technical facts (recorded in output.md)
- Type bound: |T| ≤ |Σ_in|^4 · 2^{β^4}. Reason: a type is determined by four boundary input symbols and a Boolean function on the β^4 boundary output assignments.
- Composition lemma: There is a computable binary operation ⊛ on T such that Type(uv) = Type(u) ⊛ Type(v) for all words u, v. Intuition: to decide extendibility of uv under a boundary-output assignment, one needs only (i) the extendibility tables of u and v, and (ii) existentially quantify over the two internal boundary outputs to satisfy Cout–out at the join.
- Periodicity: For any fixed word w, the sequence τ_z := Type(w^z) is ultimately periodic with preperiod and period ≤ |T|. Thus the pair sequence (Type(w1^z), Type(w2^z)) is ultimately periodic with preperiod ≤ 2|T| and period ≤ |T|.
- Finite-Z for (F2): Given any context (w1, S, w2), whether the (F2) check passes for all z ≥ 1 depends only on finitely many pairs (Type(w1^z), Type(w2^z)); it suffices to check z up to Z ≤ |T|^2 (a non-tight but simple bound).
- DP for extension: For a fixed path with some outputs forced (e.g., on S), the existence of a global completion can be decided in O(k β^2) time for a length-k path by a layered dynamic program over output symbols.

Hardness direction we will pursue (pivot suggested by Prover 01)
- Source problem: Succinct 3-Coloring of a graph G on V={0,1}^B, given by a circuit D(u,v) (size s) deciding adjacency; NEXP-complete.
- Target LCL: Construct a β-normalized, r=1 instance P_D with Σ_out size β = poly(s). The plan:
  1) For each u, build at least one context type τ_u whose boundary behavior (detected via a reserved boundary-probe) certifies that the interior encodes the index u in a standard, radius-1-checkable block. The interior also stores a copy of D on an input track and a runzone for a fixed TM U.
  2) In a bridge between τ_u and τ_v, locally simulate U on input (D,u,v) across the seam for poly(s) steps to evaluate D(u,v); malformed simulations are locally refutable.
  3) Gate constraints: if D(u,v)=0 (non-edge) allow completion regardless of colors; if D(u,v)=1 enforce color inequality across S. All other pairings (not recognized as vertex–vertex) are trivial.
  4) Assigning a color to each τ_u by a feasible function f is then exactly a proper 3-coloring of G.
  5) Make (F2) vacuous by allowing repeated sides to be filled with a globally available ⊥-plumbing language.

Open technical items for hardness (to be formalized next)
- Boundary-probe/type-separation lemma: Exhibit a fixed boundary-output probe that, when used, triggers an interior index-check subroutine; show that for distinct indices u ≠ u′, the probe’s extendibility bit differs, hence τ_u ≠ τ_{u′}.
- Seam handshake and computation: Specify the constant-size interface by which the bridge accesses (via pointers) the interior encodings of u and v and runs the 1D tableau for U for poly(s) steps, with radius-1 local checks and robust error refutations.
- Alphabet/size bookkeeping: Keep Σ_out constant tracks (roles, colors, error, U’s work alphabet) constant, with β = poly(s) sufficient for all auxiliary symbols.
- Soundness/completeness proof for the reduction P_D: G is 3-colorable iff a feasible f exists for P_D (with (F2) neutralized).

Caveats and corrections logged
- Short seam codes cannot distinguish exponentially many indices; instead use constant-size pointers/handshakes plus interior blocks that store and validate indices.
- Do not attempt to “program arbitrary boundary truth tables per type” via Cout–out; all rules are global. Use boundary probes plus uniform interior checks to separate types.
- For 3SAT-based reductions, the (F1) universal quantifier clashes with clause-level existential quantification unless one adds complex nondeterministic gating. The succinct 3-coloring pivot avoids this.


Current output.md (if any):
Results validated for radius-1, β-normalized LCLs on oriented paths

Why these results matter
- The decision procedures for feasible-function existence (and hence the O(1)/Θ(log* n)/Θ(n) classification on paths) rely on two ingredients: (i) that path segments admit a finite set of “types” which compose under concatenation, and (ii) that extendibility of partially labeled paths can be checked efficiently. The theorems below formalize these facts for radius 1 and yield a finite bound for the bridging (F2) checks.

Definitions (radius 1)
- Fix finite alphabets Σ_in and Σ_out (|Σ_out| = β). Cin–out ⊆ Σ_in × Σ_out specifies allowed output symbols at a node given its input symbol. Cout–out ⊆ Σ_out × Σ_out specifies allowed pairs of consecutive output symbols along the oriented path. A labeling of outputs y_1…y_k over an input x_1…x_k is legal if (x_i, y_i) ∈ Cin–out for all i and (y_i, y_{i+1}) ∈ Cout–out for all i.
- For a word w of length k ≥ 2, let the four boundary positions be i=1,2 and i=k-1,k. For a fixed assignment a ∈ Σ_in^4 to the boundary inputs (x_1, x_2, x_{k-1}, x_k), define E_w(a) ⊆ Σ_out^4 to be the set of boundary-output assignments b = (y_1, y_2, y_{k-1}, y_k) for which there exists a legal output labeling y_1…y_k extending b, given the boundary inputs a (interior inputs may be arbitrary in Σ_in; if the model fixes interior inputs, the definition is with respect to those fixed inputs). The type of w, Type(w), is the map a ↦ E_w(a). Let T be the set of all types realized by some w.

Theorem 1 (Finite number of types and an explicit bound)
Let m := |Σ_in|. For radius 1 we have |T| ≤ m^4 · 2^{β^4}.
Proof. For each fixed boundary-input assignment a there are exactly β^4 possible boundary-output assignments; E_w(a) is an arbitrary subset of these, hence at most 2^{β^4} possibilities. There are m^4 possible a’s. The type is fully determined by the tuple (a, E_w(a))_{a∈Σ_in^4}. Thus the total number of distinct types is at most m^4 · 2^{β^4}.

Lemma 2 (Composition of types under concatenation)
There is a computable binary operation ⊛: T × T → T such that for all words u, v we have Type(uv) = Type(u) ⊛ Type(v).
Proof. Fix boundary inputs a on uv, i.e., inputs on positions 1,2 and at the last two positions of uv. For each boundary-outputs choice b on uv, extendibility is equivalent to the existence of output symbols p,q ∈ Σ_out at the shared boundary between u and v (the last two outputs of u = first two of v) such that:
- (i) (Type(u) under its corresponding boundary inputs) accepts the boundary outputs given by the left two outputs of b together with p,q; and
- (ii) (Type(v) under its corresponding boundary inputs) accepts p,q together with the right two outputs of b; and
- (iii) the two internal adjacencies across the u|v seam are allowed by Cout–out (these involve only (y_{|u|-1}, y_{|u|}) = (p_left, p_right) and (p_left, p_right) = (y_1, y_2) of v, but these are exactly the p,q we quantify over).
Because radius is 1, no other interior constraints couple u and v. Thus extendibility of uv under (a,b) can be decided solely from Type(u), Type(v), and Cout–out by existentially quantifying p,q. Defining ⊛ to implement this decision for all (a,b) yields Type(uv) = Type(u) ⊛ Type(v).

Lemma 3 (Ultimate periodicity of repeated concatenation)
Fix w and let τ := Type(w). Define the sequence σ_1, σ_2, … in T by σ_z := Type(w^z). Then σ_{z+1} = σ_z ⊛ τ for all z ≥ 1. Consequently, the sequence (σ_z) is ultimately periodic with preperiod and period at most |T|.
Proof. By Lemma 2, σ_{z+1} = Type(w^{z+1}) = Type(w^z w) = Type(w^z) ⊛ Type(w) = σ_z ⊛ τ. Since T is finite, the sequence must revisit a previous value within at most |T| steps, after which it evolves deterministically with fixed period ≤ |T|.

Corollary 4 (Finite bound for the bridging (F2) check)
Let ℓ := |T|. Fix a context (w_1, S, w_2) with |S| = 2 and a forced output assignment s ∈ Σ_out^2 on S. For each z ≥ 1, consider the path w_1^z S w_2^z with S fixed to s, and let P(z) be the predicate “there exists a legal completion of outputs on w_1^z and w_2^z consistent with s.” Then P(z) depends only on the pair (Type(w_1^z), Type(w_2^z)). Moreover, it suffices to check P(z) for 1 ≤ z ≤ Z with Z ≤ ℓ^2; if all these hold then P(z) holds for all z ≥ 1.
Proof. For fixed s, feasibility is determined by whether there exist outputs on the two boundary nodes adjacent to S on each side such that the two segments extend and Cout–out holds across the two adjacencies touching S; this depends only on Type(w_1^z) and Type(w_2^z). By Lemma 3, each of the two type sequences is ultimately periodic with preperiod and period ≤ ℓ. Hence the pair sequence (Type(w_1^z), Type(w_2^z)) takes values in a set of size ≤ ℓ^2 and is ultimately periodic. If P(z) holds for one full traversal of the distinct pairs (which occurs within the first ℓ^2 indices), it holds for all subsequent z.

Theorem 5 (DP for extension on a partially labeled path)
Given a path of length k with a fixed input string and some outputs preassigned on a subset of nodes, there is an O(k β^2) time algorithm that decides whether the outputs can be completed to a legal labeling.
Proof. Construct a layered graph with k layers, each layer’s vertices being the output symbols allowed at that node by Cin–out and any preassignment. Add a directed edge from y at layer i to y′ at layer i+1 iff (y, y′) ∈ Cout–out. There exists a legal completion iff there is a path from some vertex in layer 1 to some vertex in layer k. The graph has O(k β) vertices and O(k β^2) edges; reachability is decidable in O(k β^2).

Remarks
- The bounds above are not tight (e.g., the ℓ^2 bound in Corollary 4 can be improved using lcm of periods), but they suffice for verification in exponential time in β. They also isolate exactly where only the types matter (composition and periodicity), which is crucial for hardness reductions that aim to make (F2) vacuous and focus on (F1).

