--- SYSTEM ---
You are a research **summarizer**. Summarize this *last round only* for a human log.

Include:
- 3–7 bullet **Highlights** (facts learned, reductions, counterexamples, partial bounds).
- 1–3 **Open questions / TODOs** for the next round.
- 1–3 **Citations to files** you relied on (e.g. round files or papers by name).

**Return strictly JSON**:
{
  "summary_md": "Readable summary of the round (≤200 words)",
  "highlights": [],
  "next_questions": []
}

--- USER ---
=== prover-01.out.json (progress_md) ===
Round goal
- Deliver a clean, radius-1, per-bit boundary-probe Type-Separation Lemma (Option A) that yields 2^B distinct “vertex” context types τ_u, with a concrete deterministic pointer gadget and explicit gating against error-escapes under reserved probes.
- State the canonical vertex-context lemma (existence of L(u), R(v) types adjacent to S only) with a pumping-based padding argument to hit lengths ℓ_pump or ℓ_pump+1 without disturbing the port zone.
- Formalize the seam gadget lemma that simulates D(u,v) across the bridge and gates acceptance by “if EDGE=1 then colors differ, else vacuous,” while keeping error-chains disabled in the active bridge mode. Provide alphabet/radius bookkeeping and a B=2 sanity check blueprint.

Context recap and constraints we must respect
- β-normalized, radius-1: Cin–out ties outputs to input bits locally; Cout–out is the only adjacency checker. All gadgets must be nearest-neighbor.
- Types are defined over fixed interior inputs (clarified in output.md remarks). Distinguishing types only requires showing E_w(a⋆) differs for some fixed boundary-input tuple a⋆.
- Feasible-function existence (F1) is the only property we reduce to (we neutralize (F2) later by ⊥-filler). We must ensure that colored S is only legal on canonical vertex contexts, so f is only “free” on τ_u and is forced to ⊥ elsewhere.

Lemma TS (Per-bit probe type separation, radius 1)
Statement. Fix parameters B = s^{c0}, β = s^{c1} with c1 ≥ c0. There exist global Cin–out, Cout–out and a family of β′ ≥ B reserved boundary-output 4-tuples {Q_j: j ∈ [B]} and a fixed boundary-input assignment a⋆ ∈ Σ_in^4 such that the following holds. For any word W_L(u) that contains a well-formed left-vertex block (defined below) positioned O(1) from S and encoding u ∈ {0,1}^B adjacent to S, and has no errors:
- E_{W_L(u)}(a⋆)[Q_j] = 1 iff u_j = 1.
Consequently, for u ≠ u′, Type(W_L(u)) ≠ Type(W_L(u′)) (they differ on E(·)(a⋆) for some Q_j), so there are at least 2^B distinct left-vertex types. Symmetrically for right-vertex types.

Design (radius-1 with uniform global rules)
- Tracks in Σ_out (constant multiplicity; folded into single symbols):
  1) Role/phase ∈ {HEAD, PORT, BRIDGE, PAD, ERR} × {phase mod c}.
  2) RID data bit (output track) required to equal the input bit when Role=PORT (Cin–out enforces copy).
  3) Address track Addr ∈ {1,2,…,B} present only when Role=PORT. Each Addr=j is a distinct output symbol component; total O(B).
  4) Probe corridor states Probe_j,Move and Probe_j,Test (two local phases) for each j ∈ [B]. These travel inside W_L(u) when a probe is active. Total O(B) many “probe-id” states, permitted since β = poly(s).
  5) Neutral ⊥ and error-chain alphabet (ERR_x) as in §3 of the reference, but these are disabled in probe-active mode (see below).
- Reserved boundary outputs Q_j (two-node boundary on the far-left and the two nodes just inside it) place a start-token that forces the unique corridor Role=BRIDGE with state Probe_j,Move to appear immediately to the right of the left boundary, propagating deterministically rightward cell-by-cell.
- Corridor-path and uniqueness: Cout–out enumerates exactly one successor for each Probe_j,Move, forcing the head to march right until it meets a cell whose Role=PORT. If no PORT appears within the allowed window, no outgoing pair is allowed: the DP dies (reject). Error-chain and ⊥ are disallowed adjacent to Probe_j,* by omitting such pairs from Cout–out.
- Address match and test: At a PORT cell, Cout–out allows Probe_j,Move to step to Probe_j,Test iff the PORT cell carries Addr=j; otherwise it must continue moving (still Probe_j,Move). In Probe_j,Test, Cout–out further requires the PORT cell’s RID bit be 1; only then does it allow a local acceptor “sink” (a short fixed BRIDGE→PAD termination sequence). If RID=0, there is simply no legal outgoing pair for Probe_j,Test at this site (reject). Again, no error-escape pairs exist in these states.
- Disabling probes when not selected: For any boundary-output 4-tuple not in {Q_j}, Cout–out never enables Probe_* states at the boundary; instead it allows generic PAD/⊥-plumbing, so these assignments do not influence separation.

Why E_{W_L(u)}(a⋆)[Q_j] = u_j
- “⇒”: If Q_j is used and the interior is a well-formed vertex block, the corridor deterministically reaches the PORT zone adjacent to S (see vertex blocks below), then walks along PORT cells until encountering Addr=j; at that cell, Probe_j,Test checks RID=1. If u_j=1, Cin–out forces the PORT symbol’s RID=1 (copy of input), so the test passes and the sink terminator exists, so the DP has a path.
- “⇐”: If u_j=0, then at the unique cell with Addr=j the RID bit is 0, so Probe_j,Test has no legal continuation; there are no alternative continuations (no error, no ⊥ permitted in probe mode), and the unique path dies. Therefore E=0.
- Type-invariance: E_{W_L(u)}(a⋆)[Q_j] depends only on the fixed boundary inputs a⋆ and the presence/contents of the PORT zone (encodes u). Any two representatives with the same u and no errors admit the same probe behavior. Thus the bitvector over {Q_j} is the same across all words of that type.

Vertex blocks and canonical contexts
- Canonical left-context L(u) and right-context R(v): A well-formed left block W_L(u) begins O(1) to the left of S and is laid out as HEAD · RIDPORT · SPACER · PAD, with:
  • HEAD: a self-delimiting header containing enc(D) (copied from Σ_in via Cin–out) and marks the start of the block (constant size overhead, independent of B).
  • RIDPORT: a contiguous port zone of exactly B cells adjacent to S, each with Role=PORT, the address track Addr=1..B in increasing order left-to-right, and the RID bit track which Cin–out ties to the node’s input bit so that the zone encodes u verbatim.
  • SPACER and PAD: a constant-length SPACER followed by a long padding segment PAD with Role=PAD (any filler pattern consistent with Cout–out). Right blocks W_R(v) are symmetric to the right of S.
- Color-at-S gating: The two S nodes have access to color symbols {RED, GRN, BLU} only if their immediate neighbors on the inside are special handshake boundary symbols that must be adjacent (in Cout–out) to Role=PORT with the correct phase for a vertex block. If these adjacencies fail (i.e., the block is absent/malformed), then any attempt to place a non-⊥ color at S cannot be extended (no legal Cout–out pair), hence non-vertex contexts cannot carry colors. Conversely, if the block is well-formed, the handshake permits a colored S, activating the seam gadget (below). This implements “only canonical contexts permit colors,” using radius-1 adjacencies.
- Length normalization at ℓ_pump or ℓ_pump+1: For any fixed u, we construct a seed left word U_left(u) = P^z · HEAD · RIDPORT · SPACER, where P is a constant PAD primitive whose repetitions are allowed by Cout–out. Choose z so that |U_left(u)| equals ℓ_pump or ℓ_pump+1. This is always possible by taking z = ⌈(ℓ_pump − c)/|P|⌉ or z+1. The right side is a 
neutral filler F_R of the required length. By Lemma 12 (composition) and Lemma 11 (replacement), any further padding on the far sides preserves the type near S; the port zone stays adjacent to S because we do not insert repeats inside RIDPORT. Thus for each u there exists at least one left-context of the required lengths with the port zone at S; symmetrically for R(v).

Lemma SG (Seam gadget for succinct adjacency and color inequality)
Statement. There is a fixed radius-1 bridge schema such that for any ordered pair of canonical vertex contexts (L(u), R(v)), if both S windows are colored, the concatenation wa S1 wb wc S2 wd admits a completion iff either D(u,v)=0 or (D(u,v)=1 and the two colors differ). If either side is not a canonical vertex context, colors are forbidden by the handshake; if a side is malformed but S was colored regardless, the bridge offers no completion (no error-escape in active mode).
Design details (radius-1)
- Activation: The color-at-S handshake (above) also puts the inner neighbors of S into a special BRIDGE-Start phase. Cout–out allows entering a BRIDGE corridor across wb ◦ wc only from this phase.
- Inputs to the run: The two B-bit port zones are immediately adjacent to S. The bridge corridor accesses these bits by simple “read heads” that move one step into wb or wc and copy the bit into the first row of a RUN tableau (implemented in the bridge). The circuit D is present in HEAD on both sides (since enc(D) is copied from Σ_in to Σ_out under HEAD), or, alternatively, we can duplicate enc(D) in the bridge header as constant local data—both are radius-1 local.
- Tableau: A fixed universal TM U is simulated row-by-row across the bridge to compute d := D(u,v) in poly(s) steps. Cout–out enforces per-row local transitions; malformed rows admit no accepting continuation in the active mode (no ERR allowed adjacent to BRIDGE states). After the last row, a dedicated cell adjacent to the S2 side outputs EDGE ∈ {0,1}.
- Local acceptance: Cout–out encodes the rule that across S1 and S2 and the adjacent EDGE cell:
  • If EDGE=0 (non-edge), all three color-equality pairs at S are allowed.
  • If EDGE=1 (edge), the two S outputs must be unequal; the three equal-color pairs are disallowed, blocking all completions in those cases.
- Robustness: All ERR_x error-chain symbols are globally available for inactive modes (e.g., malformed vertex blocks when S is ⊥), but in bridge-active mode (colors present at S) the BRIDGE corridor allows no ERR transitions. Thus a malformed attempt in active mode rejects rather than escaping to ERR.

Alphabet and radius bookkeeping
- Σ_out size: roles/phases O(1); color tokens + ⊥ (4); error alphabet O(1) (global); PORT addresses (B); probe-id states per j (O(B)); RUN work alphabet for U (constant). Total |Σ_out| = β can be chosen s^{c1} with c1 ≥ c0 large enough so β ≥ C·B for a fixed constant C (absorbing all constants).
- Radius-1: Every constraint is between a node and its predecessor: Cin–out ties PORT.RID to the input bit; Cout–out enumerates the only legal neighbor pairs for PROBE movement, RUN row steps, BRIDGE activation, and color/EDGE gates.

Soundness/completeness sketches (Succinct 3-Coloring → FFE(F1))
- Type separation: By Lemma TS, for each u there is at least one canonical left (resp. right) vertex type τ^L_u (resp. τ^R_u), and τ^L_u ≠ τ^L_{u′} for u≠u′. All non-vertex contexts are inactive (color-at-S cannot be extended), so f must map them to ⊥.
- Completeness: Given a proper 3-coloring χ: {0,1}^B → {R,G,B}, define f(τ^L_u) = χ(u) and f(τ^R_v) = χ(v), f(τ)=⊥ for others. For any pair (τ^L_u, τ^R_v), the bridge simulates D(u,v); if D=0, acceptance is unconditional; if D=1, the inequality holds by χ, so the bridge accepts. All other pairings are vacuous by gating.
- Soundness: If f satisfies (F1), define χ(u) = f(τ^L_u). For any (u,v) with D(u,v)=1, the pair (τ^L_u, τ^R_v) must pass the (F1) DP; by Lemma SG’s gate, that forces χ(u)≠χ(v). Hence χ is a proper 3-coloring. Note the “same-u consistency” issue is avoided by construction: only the canonical τ^L_u and τ^R_v can carry colors, so f is single-valued on u.

Neutralizing (F2)
- Add global ⊥-plumbing on repeats: for any w and z≥1, the repetition wz can be filled entirely with ⊥ consistent with Cout–out (and respecting the handshake that forbids colors unless a vertex block is present). Then (F2) is vacuous for all contexts, so the three-way classifier reduces to deciding (F1)—hence NEXPTIME-hard.

Toy sanity check (B=2)
- Let β≥8. Port zone has two PORT cells with Addr=1,2 and RID matching input bits (u_1,u_2). Q_1, Q_2 probes: under Q_1 the corridor moves to Addr=1 and accepts iff u_1=1; similarly for Q_2. The 4 left-types τ^L_{00}, τ^L_{01}, τ^L_{10}, τ^L_{11} differ on the two probe bits. For a small D encoding (e.g., 4-cycle), the BRIDGE tableau reads u,v and emits EDGE=1 on edges; local gate forbids equal colors only then. A brute-force DP on the combined path verifies that all (F1) instances accept iff colors define a proper 3-coloring.

Obstacles and how addressed
- Unique continuation under reserved probes: We explicitly disallow ERR/⊥ adjacencies when any Probe_j,* state appears; the only permitted successor is the deterministic path, ensuring E(Q_j) reflects u_j.
- Keeping the port zone adjacent to S after length normalization: We choose padding only in PAD, outside RIDPORT, so the port stays adjacent to S; we do not rely on pumping to preserve the internal structure of RIDPORT.
- Same-u consistency: Avoided by gating colors at S exclusively to canonical vertex contexts; alternative contexts cannot carry colors, so f cannot assign contradictory colors to the same u across multiple types.

Gaps or clarifications for output.md (minor)
- Clarify explicitly (already noted in Remarks) that types E_w(a) are computed with respect to the fixed interior input string of w. Our reductions rely on Cin–out copying input bits into PORT.RID.
- Optional: Note that while Corollary 4 uses Z ≤ ℓ^2, for a fixed context one can compute smaller Z from the per-side type DFA cycles; not required for our hardness but may tighten constants.

Next steps (auditable deliverables)
1) Write the local Cout–out transitions for the probe gadget: list states {Probe_j,Move/Test}, allowed pairs with PORT cells (Addr≠j ⇒ Move; Addr=j and RID=1 ⇒ acceptor; disallow ERR/⊥ near probes). Provide a finite table parametrized by j with size O(B) to confirm β budget.
2) Give the exact HEAD and RIDPORT layouts with Cin–out masks: specify that when Role=PORT, only two output symbols (RID=0/1) are allowed and must match the input bit; when Role=HEAD, output must match the input encoding of D.
3) Specify the BRIDGE tableau alphabet and the final EDGE cell’s interface to S: define the three forbidden adjacent pairs across S when EDGE=1 (RR, GG, BB) and allow all when EDGE=0; verify radius-1 locality.
4) Provide a fully worked B=2 instance (explicit symbols) and run the O(kβ^2) DP to validate both Type-Separation and Seam Gadget behavior; we can submit this as a regression test to the verifier.
5) Integrate the global ⊥-filler rules for repetitions and restate the corollary: on our instances, the classifier’s O(1) vs. Ω(log* n) vs. Θ(n) reduces to (F1), hence NEXPTIME-hard.

Why useful here
- The per-bit probe lemma squarely addresses the verifier’s major issue: we do not “program” per-type tables; instead we use uniform global rules and reserved probes whose acceptance depends on the interior u via Cin–out, yielding exponentially many types. The seam gadget aligns exactly with (F1)’s universal pairwise check for 3-coloring. Both gadgets are radius-1 and fit the β budget, and they can be verified independently by the DP on small instances.


=== prover-02.out.json (progress_md) ===
Status and focus
- Goal: finalize a clean, radius-1 reduction from Succinct 3-Coloring (S3Col) to Feasible-Function Existence (F1) in the β-normalized model, with (F2) neutralized by ⊥-filling, thereby yielding NEXPTIME-hardness of the 3-way classifier.
- This round: (i) fix the probe/type-separation gadget using a family of per-bit probes Q_j; (ii) specify canonical vertex contexts and gating so only those contexts can carry non-⊥ colors at S; (iii) specify a seam tableau that computes Edge(u,v) and Eq(u,v) and enforces acceptance iff (Edge=0 or colors differ) and (Eq=0 or colors equal), which also forces left/right copies of the same vertex to share the same color; (iv) give concrete DP-checkable formulations and bookkeeping; (v) list verifiable next deliverables.

Gaps in output.md (minor clarifications, no changes made)
- Types vs fixed inputs: The definition of E_w(a) notes interior inputs may be arbitrary or fixed by the instance; our hardness builds contexts by choosing suitable interior inputs (binary strings) realizing the canonical blocks. It would help to add a sentence to output.md explicitly stating: “When we refer to Type(w), interior inputs are fixed to those of w; the type depends on the chosen input word w.” This is already consistent with the DP and Section 4 of the reference.
- Optional: Corollary 4’s bound Z ≤ ℓ^2 is sufficient (tightening via lcm of periods is possible but unnecessary here).

Idea 1 — Per-bit probe family Q_j gives 2^B distinct vertex types
Concrete tracks and symbols (radius 1, β-normalized)
- Σ_in = {0,1}. Σ_out tracks (combined into one symbol):
  1) Role/phase: {HEAD, VERT, PORT, RUN, PAD, PROBE, ERR_k, …} × {phase mod c} (constant size).
  2) S-color: {RED, GRN, BLU, ⊥} available only on the two S nodes (enforced by roles around S).
  3) Port zone outputs that must copy Σ_in via Cin–out: an address track Addr ∈ {1,…,B} (encoded in binary or unary across cells) and a data track RIDbit ∈ {0,1} for the index u.
  4) Pointer/probe track with states {Start_j, Head_j, Ok_j, Dead_j} for j∈[B]; Head_j carries probe-id j along the pointer path; this induces O(B) states; permitted because β = poly(s) and B = s^{c0}.
  5) RUN work alphabet for a fixed U (constant-size), error-chain alphabet as in §3 of the reference (constant).
- Reserved boundary outputs: choose a common boundary-input pattern a⋆, and for each j∈[B] a dedicated 4-tuple Q_j on the boundary outputs that sets the PROBE role to Start_j at both boundary sides and fixes neighbors to allow only the probe pipeline (see below).

Probe pipeline (only legal continuation under Q_j)
- Cout–out lists only the following successor pairs when the left boundary outputs equal Q_j: Start_j (at the outermost position) must be followed by Head_j moving deterministically right, keeping the j-tagged Head_j; along Head_j, the role PORT is required (locally enforced) and the port zone must be present adjacent to S within a fixed offset. Head_j advances cell-by-cell until it stands on a PORT cell whose output Addr equals j (comparison is local: the j-tag in Head_j must match Addr). At that cell:
  • If RIDbit=1, a transition Head_j→Ok_j is allowed, after which a short, locally-checked accept sink attaches to filler/PAD; the boundary assignment Q_j is extendible.
  • If RIDbit=0, there is no legal successor (no error-escape is listed under PROBE), so no completion exists; the boundary assignment Q_j is non-extendible.
- No error-chain or alternative plumbing is enabled while the PROBE role is active; this guarantees uniqueness of the computation under Q_j and prevents spurious accepting paths.

Lemma TS (Type-separation via Q_j). For each u∈{0,1}^B there exists a canonical left-context L(u)=W_L(u) S F_R (constructed below) with a well-formed PORT zone of length Θ(B) adjacent to S on the right, whose RIDbit track (copied from Σ_in via Cin–out) spells u and whose Addr track enumerates addresses 1,…,B. For the fixed boundary-input assignment a⋆ and boundary-outputs Q_j, E_{L(u)}(a⋆)[Q_j]=u_j. Consequently, if u≠u′ then Type(L(u))≠Type(L(u′)).
Why useful: Gives ≥2^B distinct left context types injectively indexed by u. The same construction mirrored yields right context types R(v).
Proof sketch: Under Q_j the only legal extension (by Cout–out) is the deterministic PROBE pipeline; it reaches the unique PORT cell with Addr=j. Cin–out forces RIDbit outputs to equal the input bits of W_L(u); hence Ok_j exists iff u_j=1. Thus the extendibility bit for Q_j equals u_j. Since the Type records, for each fixed boundary input a⋆, the yes/no table over all boundary-outputs, and the family {Q_j} lies within those outputs, the truth tables differ for u≠u′, hence types differ. Uniformity: under Q_j there is no alternative continuation, so E_w(a⋆)[Q_j] depends only on u, not on other interior nondeterminism.

Idea 2 — Canonical vertex contexts and color gating
Canonical shapes
- Left: L(u) = W_L(u) S F_R. The block W_L(u) is HEAD · VERT · PORT · RUN with O(poly(s)) length, anchored within O(1) of S (fixed offset). The right side F_R is neutral filler (PAD) of length ℓ_pump−O(poly(s)).
- Right: R(v) = F_L S W_R(v), symmetric.
Color gating at S (radius 1)
- Only when the immediate neighbors of S display role tokens GateL (on the left side) or GateR (on the right side), which appear exclusively in well-formed W_L(·)/W_R(·) at the fixed offsets, do the S nodes permit non-⊥ S-color outputs. Otherwise, S-color must be ⊥ and any non-⊥ choice yields no continuation (local dead-end). This makes all non-canonical contexts inactive.
- The existence of contexts with |W_L(u)|∈{ℓ_pump,ℓ_pump+1} follows from pumping/replacement (Lemmas 11, 14–15 in the reference). We pick fixed offsets so that GateL/GateR alignment is independent of the global length choice; padding happens in the outer PAD region.
Result: Only the canonical L(u), R(v) types are active; all others must be assigned ⊥ by any feasible f.

Idea 3 — Seam tableau computing Edge(u,v) and Eq(u,v) and local acceptance
Bridge layout and computation
- On a bridge instance wa S1 wb wc S2 wd with left=L(u) and right=R(v), the concatenation wb∘wc (length ≥ℓ_pump−O(poly(s))) hosts a standard row-by-row simulation of a fixed U for poly(s) steps. U reads:
  1) the encoding of the circuit D from HEAD (copied from Σ_in via Cin–out inside both W_L, W_R),
  2) the B-bit RID port u adjacent to S1, the B-bit GID (or v) adjacent to S2.
- The tableau checks nearest-neighbor consistency (Cout–out row transitions), with conventional error-chains available only when RUN is malformed or HEAD/RID is malformed; but if S carries a non-⊥ color while a side is malformed, the seam dead-ends (no accept path), ensuring non-canonical types cannot use colors.
- U emits two 1-bit flags near S: Edge = D(u,v) and Eq = [u=v] (computed by a simple bitwise equality scan).
Local acceptance policy (enforced by constant-size radius-1 constraints around S)
- Accept iff both conditions hold simultaneously:
  (A) Edge=0 OR (S-color1 ≠ S-color2), and
  (B) Eq=0 OR (S-color1 = S-color2).
- Intuition: (A) enforces inequality on edges, vacuous on non-edges; (B) forces left/right copies of the same vertex to carry identical colors (Eq=1 ⇒ colors equal), which also makes all duplicate types for a given u consistent via pairing with the unique right-type R(u).
- If either side is inactive (color at S forbidden), a colored attempt dead-ends; with ⊥ at S, the seam always accepts (⊥-plumbing), making all non-canonical pairs trivial.

Why this aligns with (F1) and fixes prior concerns
- Pairwise constraint matches (F1): every ordered pair of contexts is checked; edges impose inequality; non-edges impose nothing; in addition Eq=1 imposes left/right consistency, removing the need for uniqueness of types per u.
- Determinism under probes prevents “cheating” via error-chains.

Neutralizing (F2)
- Add a global ⊥-filler: for any context (w1,S,w2) and any z≥1, allow wz_1, wz_2 to be entirely labeled with ⊥ via Cout–out, independent of boundary inputs/outputs and independent of the internal roles. This never overrides S nor GateL/GateR, and thus does not affect (F1). Consequently, (F2) is always true for any f on our instances; the classifier reduces to (F1)-feasibility.

Soundness/completeness (sketch with the new Eq gating)
- Completeness (3-colorable ⇒ feasible f): Given a proper 3-coloring χ:V→{R,G,B}, define f(Type(L(u))) = χ(u) and f(Type(R(v))) = χ(v); all inactive types map to ⊥. For any ordered pair (L(u),R(v)), U computes Edge and Eq. If Edge=1 then χ(u)≠χ(v) and (A) holds; if Edge=0 then (A) holds trivially. If Eq=1 (thus u=v), then χ(u)=χ(v) by definition of f on left/right copies and (B) holds; if Eq=0, (B) is vacuous. Thus all (F1) instances accept. (F2) is vacuous by ⊥-filling.
- Soundness (feasible f ⇒ 3-colorable): Define χ(u):=f(Type(L(u))) (well-defined because pairing (L(u),R(u)) forces equality via (B)). For any edge (u,v), pairing (L(u),R(v)) yields Edge=1, so (A) forces χ(u)≠χ(v). Hence χ is a proper 3-coloring.

DP-checkable toy instance (B=2)
- Set β≥8. Build L(00), L(01), L(10), L(11), and R(·) analogously. Reserve Q_1,Q_2. Verify:
  • E_{L(u)}(a⋆)[Q_1] = u_1, E_{L(u)}(a⋆)[Q_2] = u_2 (the DP fails/succeeds under the unique probe pipeline).
  • On a small D (e.g., a 4-cycle), the seam tableau sets Edge accordingly; local acceptance enforces inequality on edges; Eq enforces equality across (L(u),R(u)) pairs.
- The verifier can brute-force all ordered pairs of these contexts and check that (F1) holds iff a 3-coloring exists.

Alphabet and complexity bookkeeping
- Tracks: roles/phases O(1), colors+⊥ (4), error alphabet O(1), RUN alphabet O(1), probe/pointer states O(B), plus a constant variety of plumbing symbols. Choose β = s^{c1} with c1≥c0 so β≥Θ(B); the global tables Cin–out (2×β) and Cout–out (β×β) remain poly(β).
- Lengths: HEAD+PORT+RUN = poly(s) ≪ ℓ_pump = 2^{Θ(β^4)}; pumping/replacement embeds blocks adjacent to S within contexts of length ℓ_pump or ℓ_pump+1.
- Radius 1: every check (probe step, address match, bit read, row-to-row evolution, local acceptance at S) is nearest-neighbor.

Obstacles addressed and remaining
- Fixed single-probe issue resolved: we use a family {Q_j} and carry the j-id in Head_j; acceptance depends on u.
- Consistency across duplicate types: ensured by Eq gating across (L(u),R(u)). This propagates equality across all left/right duplicates via (F1).
- Error-chain leakage: explicitly disabled under PROBE; enabled only in malformed RUN/head regions not under probe or color activation.
- Remaining work: write explicit Cout–out pairs for pointer transitions and RUN rows (constant-size schemas); specify the exact offsets and phases that isolate GateL/GateR to canonical contexts; present a small B=2 instantiation with explicit tables that the verifier can DP-check.

Next concrete steps (auditable)
1) Write the pointer/probe transitions: the set of allowed (y_i,y_{i+1}) pairs for Start_j, Head_j, Ok_j, including the guard that Head_j may move only over PORT cells and must compare its j-tag to Addr.
2) Formalize Lemma TS: a fully self-contained proof in our r=1 model that E_{L(u)}(a⋆)[Q_j]=u_j (no alternative accepting continuation) and that u≠u′ ⇒ types differ. Include a precise statement of a⋆ and the reserved outputs Q_j.
3) Specify canonical L(u), R(v) layouts: exact offsets for HEAD, PORT, RUN relative to S; a small constant-phase scheme that ensures GateL/GateR appear only at those offsets; show padding preserves type (Lemmas 11,14–15).
4) Write the seam U-tableau alphabet and local rules; define where Edge and Eq flags appear; list the constant-size local acceptance checks at S implementing (A) and (B).
5) Provide a B=2 toy with explicit Cin–out,Cout–out snippets and run the O(kβ^2) DP to confirm: (i) probe acceptance patterns; (ii) seam behavior on all pairs; (iii) ⊥-filling for (F2).

Why this is progress
- We now have concrete, verifiable lemmas addressing the verifier’s critiques: a radius-1, globally uniform probe family that separates 2^B types; canonical gating to single out active contexts; and a seam that enforces both edge-inequality and same-vertex equality, removing the latent ambiguity across duplicates. Each component is amenable to the O(kβ^2) DP, and the size/radius constraints stay within the β-normalized model.

=== prover-03.out.json (progress_md) ===
Status and aim
- Objective: push the NEXPTIME-hardness reduction (Succinct 3-Coloring → Feasible-Function Existence (F1)) to a checkable state by pinning down two core gadgets with radius-1 rules and polynomial alphabet: (i) per-bit boundary probes that separate 2^B vertex types, and (ii) a seam tableau that computes D(u,v) and enforces color inequality on edges. Also enforce “must-color” only on canonical vertex contexts and neutralize (F2) via ⊥-filling.
- Output.md: no correctness issues spotted for the upper bound (types, DP, finite-Z). Clarification already noted there (“fixed inputs” interpretation) is consistent with what we use below. The NEXPTIME verifier section is still informal; we supply precise, testable lemmas and constraints to move pieces into output.md.

Lemma TS (Per-bit probe type separation; radius-1, β=poly(s))
- Parameters: B = s^{c0}, β = s^{c1} with c1 > c0 so β ≥ B and there is headroom for O(B) reserved symbols.
- Canonical left vertex block L(u): a fixed-format segment W_L(u) adjacent to S with the following O(B)-length subzones (roles enforced by Cout–out phases):
  1) HEAD_C: a short header whose out-track copies (via Cin–out) a fixed binary description enc(C) of the succinct adjacency circuit. Any deviation allows an error-chain in non-probe contexts, but see “Probe discipline” below.
  2) PORT: B consecutive cells immediately to the right of S. Each PORT cell carries two output subtracks: Addr ∈ {1,…,B} and RidBit ∈ {0,1}. Local Cout–out rules require Addr to increase by 1 from left to right, starting at 1 and ending at B, and RidBit to equal the input bit (Cin–out tie) at that node under role=PORT. The vector (RidBit[1..B]) encodes u.
  3) RUN_L: a fixed-width corridor (constant tracks) that hosts a row-by-row 1D tableau for U; unused in the probe; used later by the seam gadget.
- Reserved boundary-output family: Define B distinct boundary-output 4-tuples {Q_j : j∈[B]}. Implementationally, allocate four disjoint reserved symbol families in Σ_out: for the four boundary nodes of L(u), allow only the 4-tuple (ProbeL1(j), ProbeL2(j), ProbeR2(j), ProbeR1(j)) when “probing j”. The set {Probe•(j)} across all j uses O(B) distinct symbols, feasible as β ≥ B and we have ample slack for other tracks.
- Pointer and acceptance (radius-1): Under boundary inputs fixed to a⋆ (choose any constant 4-tuple; e.g., all zeros) and boundary outputs Q_j, Cout–out enforces a deterministic, unique continuation into a “probe mode”: a finite-state pointer head propagates rightward from the left boundary through PORT, matching successive Addr values and halting exactly when Addr=j. The only legal continuation at that cell is to accept iff RidBit=1; if RidBit=0 then the probe path dead-ends (no completion). No alternative transitions (e.g., error-chain) are permitted while “probe mode” is active (see probe discipline below). Outside reserved probes, normal error-chains exist so malformed interiors never constrain f.
- Probe discipline (no error-escape): Cout–out tags each transition in a binary “mode” track. When Q_j is present, the mode is forced to PROBE in a bounded prefix of W_L(u) and error symbols are disallowed in PROBE mode; the only legal edges follow the deterministic pointer/run described above. If any local check fails (role/phase, Addr monotonicity, reaching j, or RidBit), no outgoing pair is allowed ⇒ the DP rejects that boundary 4-tuple.
- Claim (Type-Separation): For any u∈{0,1}^B and any j∈[B], E_{Type(L(u))}(a⋆)[Q_j] = 1 iff u_j=1. Hence the B-bit vector (E(a⋆)[Q_j])_{j=1..B} equals u. In particular, u≠u′ ⇒ Type(L(u))≠Type(L(u′)).
  Why: Under Q_j the continuation is unique; extendibility equals the truth of RidBit[j]=1 in the PORT zone. Because E_w(a) is defined with interior inputs fixed (as in output.md), this bit is a property of the concrete L(u) and thus of its type. Since at least one probe outcome differs when u≠u′, the types differ. Radius-1 holds (only nearest-neighbor checks); Σ_out budget is O(B) for Addr values, O(B) for reserved Q_j symbols, plus O(1) for roles, phases, ⊥, colors, errors, U’s alphabet ⇒ β = poly(s) suffices.

Lemma RG (Role gating and must-color for canonical contexts)
- Gating: Two special role markers are allowed at S’s two nodes: Color and ⊥. Cout–out permits Color tokens {RED, GRN, BLU} at S iff and only if the adjacent interior begins with a well-formed canonical vertex header: HEAD_C followed immediately by the PORT zone (left side for L(·), right side for R(·)). Otherwise (inactive contexts), Color at S has no legal continuation (dead); ⊥ at S always has a legal continuation via neutral plumbing (a self-looping ⊥ language as in the upper bound DP).
- Must-color on active pairs: On a bridge instance between an active left L(u) and an active right R(v) (see next lemma), the seam accepts only if both S nodes carry Color (non-⊥). Thus any feasible f must assign a color to each canonical vertex type; assigning ⊥ would falsify (F1) on its pairings with some active opposite.
- Consequence: f is only free to color canonical types; any attempt to color an inactive type causes (F1) to fail on some pair (inactive, anything) because Color-at-S would be unextendible on the inactive side. Therefore f must map all inactive types to ⊥.

Lemma SG (Seam tableau for succinct adjacency and inequality)
- Canonical right vertex block R(v): symmetric to L(u), with its PORT zone immediately to the left of S; it exposes Addr and RidBit tracks encoding v.
- Seam layout: In the bridge wb∘wc between L(u)’s right side and R(v)’s left side, Cout–out allocates a fixed-width corridor RUN_B that hosts a row-by-row simulation of a universal TM U on input (enc(C), u, v). The input (enc(C)) is present in both HEAD_C zones, and u,v are read from the PORT zones (local wiring at the near seam). Each row transition is enforced by nearest-neighbor Cout–out constraints; malformed rows cannot continue (no error-escape inside RUN_B). The final row writes EDGE ∈ {0,1} at a fixed seam-local cell.
- Acceptance policy at S (radius-1): Local rules enforce: (i) if EDGE=0, accept regardless of colors at S; (ii) if EDGE=1, accept iff the two S colors differ; (iii) on an active-active pair, ⊥ is not permitted (must-color). All checks refer only to the two S outputs and the nearby EDGE bit.
- Robustness: If either side is inactive or malformed (HEAD_C absent, corrupted PORT), the only allowed S symbol is ⊥ and a neutral ⊥-plumbing fills both sides, ensuring these contexts never constrain f (consistent with Lemma RG).
- Correctness: On active-active pairs, the tableau computes D(u,v) in poly(s) time and exposes EDGE correctly; the final local check enforces exactly the 3-coloring constraint “colors must differ on edges and arbitrary on non-edges”.

Canonicality and existence of active types
- Canonical shapes: Define L(u)=W_L(u) S F_R and R(v)=F_L S W_R(v) with W_L, W_R as above and fixed fillers F_L, F_R (PAD-roles). Cout–out recognizes only these shapes as vertex roles (for gating). Any other context is inactive (no Color at S).
- Existence via pumping/replacement: HEAD_C+PORT+RUN zones have length poly(s) ≪ ℓ_pump = 2^{Θ(β^4)}. By Lemma 11 (replacement) and Lemmas 14–15 (pumping), we can place W_L(u) adjacent to S inside words of length ℓ_pump or ℓ_pump+1 on the designated side, preserving the type of W_L(u); ditto for W_R(v). Thus the context set C contains, for each u (resp. v), at least one canonical left (resp. right) type, and Lemma TS gives at least 2^B distinct left-types and 2^B distinct right-types.

Soundness/completeness of the reduction (sketch tightened)
- Completeness (⇒): Given a proper 3-coloring χ: {0,1}^B → {RED,GRN,BLU} of the succinct graph defined by C, define f on canonical types by f(Type(L(u)))=χ(u) and f(Type(R(v)))=χ(v); set f(τ)=⊥ on all inactive types. By Lemma SG, every active-active (F1) pair accepts iff χ(u)≠χ(v) when D(u,v)=1 and always if D(u,v)=0. All other pairings accept via ⊥-plumbing. Hence (F1) holds.
- Soundness (⇐): If some f satisfies (F1), Lemma RG forces f to assign colors to canonical vertex types and ⊥ to all inactive types. Read χ(u):= f(Type(L(u))). For any edge (u,v) with D(u,v)=1, the seam between Type(L(u)) and Type(R(v)) must be extendible; by Lemma SG this implies χ(u)≠χ(v). Non-edges impose no restriction. Thus χ is a proper 3-coloring.

Neutralizing (F2)
- Add a global ⊥-filler language: For any repetition w_1^z and w_2^z (z≥1), Cout–out admits labeling all repeated sides with ⊥ regardless of boundary outputs, without touching S or the vertex-role gating. Then (F2) holds for any f, reducing the three-way classifier to deciding (F1)-feasibility on our instances (NEXPTIME-hard).

Alphabet/size and radius bookkeeping
- Σ_out tracks (all merged into symbols): roles/phases O(1); colors+⊥ (4); error alphabet O(1); U’s row alphabet O(1); Addr values {1,…,B} (O(B)); reserved probe symbols for Q_j (O(B)); a few pointer states O(1). Total |Σ_out| = β = poly(s). All constraints are radius-1 (depend on current and predecessor outputs only).

Sanity example (B=2)
- Reserve Q_1, Q_2 for the left boundary. L(00), L(01), L(10), L(11) yield extendibility vectors (E(a⋆)[Q_1], E(a⋆)[Q_2]) equal to (0,0), (1,0), (0,1), (1,1) respectively. On the seam, with C encoding a 4-cycle, the tableau sets EDGE=1 exactly on adjacency pairs; the local check enforces color inequality on those.

Obstacles and how addressed (verifier feedback alignment)
- “Single fixed probe” issue: we use a family {Q_j} indexed by boundary outputs; acceptance depends on interior u via the deterministic pointer (no dependence on a globally fixed j). Addresses or O(B)-many probe symbols ensure radius-1 feasibility without exponential symbol blowup.
- Consistency on same u: avoided by canonical gating. Only L(u), R(v) allow colors; mapping any other type to a color breaks (F1). Thus each u is represented by exactly one colorable type per side.
- Error-escape under probes: disallowed by a probe-mode bit; in probe mode, error-chain symbols are not permitted in Cout–out’s allowed neighbor pairs.

Next steps (concrete, verifiable)
1) Write explicit local rule snippets for the probe gadget:
   - The four reserved boundary symbols and their immediate successors in “probe mode”.
   - PORT zone neighbor pairs enforcing Addr increment and RidBit copy.
   - Pointer transitions and the accept/dead-end at Addr=j with RidBit test.
   Provide a small B=2 instance and brute-force the DP to observe E(a⋆)[Q_j] = u_j.
2) Formalize Lemma RG: list Cout–out pairs that allow Color at S only next to HEAD_C+PORT; add dead-end rules otherwise; add the ⊥ self-loop plumbing.
3) Specify RUN_B alphabet and row transitions for U; define EDGE emission and the local color-inequality check at S. Verify on a toy circuit D by DP.
4) Package the reduction D ↦ P_D with precise β sizing and radius-1 constraints; add the ⊥-filler rules. Then move Lemmas TS, RG, SG and the reduction theorem into output.md.

Why useful here
- The per-bit probe family and probe discipline directly resolve the main gaps flagged by the verifier: we now separate 2^B types without per-type tailoring, and we prevent error-escape in reserved probes. The role-gating and must-color rules ensure f assigns colors only to canonical vertex types, avoiding consistency pitfalls. The seam tableau matches (F1)’s pairwise nature. All components are radius-1 and compatible with the O(kβ^2) DP for audit.


=== prover-04.out.json (progress_md) ===
Status and focus
- Objective: firm up the NEXPTIME-hardness reduction by fully specifying two auditable gadgets: (i) a per-bit boundary probe that separates 2^B vertex indices into distinct context types; (ii) a seam gadget that simulates D(u,v) across the bridge and enforces color-inequality iff D(u,v)=1. Also enforce “color gating” so only canonical vertex contexts may carry colors, making all non-canonical types inactive and mapped to ⊥.
- This round delivers precise lemmas with radius-1 local behavior, alphabet budgeting, and proof sketches that can be checked by the O(k β^2) DP on toy instances (e.g., B=2).

Gaps in output.md (minor clarifications)
- Types vs. fixed inputs: output.md’s Definitions allow “interior inputs may be arbitrary.” Our reductions assume the interior inputs are fixed to the instance string; E_w(a) is computed w.r.t. that fixed string. Suggest adding a parenthetical: “if the model fixes interior inputs, E_w(a) is computed with respect to those fixed inputs,” to avoid ambiguity when we later rely on interior-encoded indices.
- Context set C: it is useful to note explicitly that C consists of types realized by words of the form w_1 S w_2 with |w_i| ∈ {ℓ_pump, ℓ_pump+1}. This plays a role in gating colors and in counting how many “active” types we can realize.

Lemma TS (Type Separation via per-bit boundary probes)
- Parameters: B = s^{c0}, β = s^{c1} with c1 ≥ c0 so β ≥ B. Fix one boundary-input pattern a⋆ ∈ Σ_in^4.
- Port zone layout (left contexts): In every canonical left vertex block W_L(u), immediately to the right of S there is a port zone of length B with two read-only subtracks: Addr ∈ {1,…,B} (hardwired per position) and RID ∈ {0,1} (copied from input via Cin–out). Outside the port zone and a short header, the block is neutral PAD/error-plumbed.
- Reserved boundary outputs: For each j ∈ [B], define a distinct reserved 4-tuple Q_j of boundary outputs (the four symbols on the two leftmost and two rightmost boundary nodes of w_1). Under Q_j, Cout–out allows only a deterministic “probe-j” pipeline that flows from the left boundary across w_1, enters the port zone, and stops at the unique cell where Addr=j. This pipeline is implemented by a pointer head state P_j carried on a dedicated track; adjacency rules enforce P_j → P_j deterministically, moving one step per edge. At the target cell, the only legal successor enforces RID=1 at that cell; if RID=0, the pipeline has no legal continuation (dead end). Upon RID=1, the pipeline transitions to a local ACCEPT sink that splices into a neutral filler for the remaining interior, enabling completion.
- No error escape under probes: Under boundary outputs Q_j the error-chain alphabet is disabled (no error transition is permitted from P_j states). For all non-reserved boundary outputs, standard error-chains and PAD are enabled.
- Claim (formal). For any canonical left vertex word L(u) and fixed boundary inputs a⋆, E_{L(u)}(a⋆)[Q_j] = 1 if and only if u_j = 1. Moreover, for j ≠ j′, Q_j ≠ Q_{j′}, and under any other 4-tuple, E behaves as generic PAD/error-plumbing.
- Why type separation holds: Let Sig(u) ∈ {0,1}^B be (E_{L(u)}(a⋆)[Q_j])_{j=1..B}. Then Sig(u)=u, so u≠u′ ⇒ Sig(u)≠Sig(u′). Hence Type(L(u))≠Type(L(u′)). This uses only global Cin–out/Cout–out and is radius-1.
- Alphabet budget: the pointer heads P_j and reserved Q_j consume O(B) symbols; permitted since β ≥ B and Σ_out size is β = poly(s). The rest of the tracks (roles/phases, PAD, error, etc.) are O(1).
- Why useful: Gives ≥ 2^B distinct left-context types τ^L_u. A symmetric construction gives ≥ 2^B right-context types τ^R_v.

Lemma CG (Color gating for canonical vertex contexts)
- Statement. There is a role/phase track and Cin–out/Cout–out rules such that: the two S nodes may carry non-⊥ colors {RED,GRN,BLU} if and only if the adjacent side is a well-formed canonical vertex block (W_L(u) on the left of S, W_R(v) on the right of S). In all other contexts, any non-⊥ symbol at S has no legal continuation (dead end), whereas ⊥ at S always admits a completion via PAD/error plumbing.
- Implementation at radius 1: Gate the color tokens by an “ACT” flag emitted by a short handshake subtrack that is present only when the port-and-header structure near S is well-formed. Cin–out forbids colors unless ACT=true. Cout–out disables the error alphabet on transitions emanating from colored S unless ACT=true, so colors on inactive types cannot be extended.
- Why useful: Ensures f can assign colors only to τ^L_u and τ^R_v; all other types must be mapped to ⊥ to satisfy (F1).

Lemma Seam (Seam gadget for succinct adjacency and inequality)
- Statement. There is a fixed radius-1 seam gadget such that for any ordered pair (τ^L_u, τ^R_v): the bridge segment wb∘wc between S_1 and S_2 hosts a 1D tableau of a universal TM U that, in poly(s) steps, reads the B-bit ports u and v and computes d := D(u,v). A final verdict bit EDGE=d is exposed near S_2 together with a forwarded copy of Color(S_1). Local rules at S_2 enforce: if EDGE=0, accept regardless of colors; if EDGE=1, accept iff Color(S_2) ≠ ForwardedColor(S_1). All checks are nearest-neighbor.
- I/O wiring details:
  - Inputs to U: The header encodes C; adjacent to S_1 (resp. S_2) the port zone exposes u (resp. v). A seam handshake opens a corridor across wb∘wc for the tableau. Each tableau row is a constant-width word; Cout–out enforces per-row transitions of U.
  - Verdict wiring: The last row writes EDGE∈{0,1} and copies Color(S_1) into a “forwarded color” register next to S_2. Cout–out contains pairs that check (EDGE=1) ⇒ neighbor-to-S_2 carries a color different from S_2; if equal, no legal transition. If EDGE=0, both equal and unequal are allowed.
- Robustness:
  - Malformed runs or headers: standard error-chain refutations are allowed when ACT=false or when S is ⊥; these make such contexts inactive. Under ACT=true with colors at S, malformed rows have no accepting continuation (no error escape), so (F1) cannot be satisfied by cheating.
- Why useful: Aligns (F1)’s universal pair constraint with 3-coloring: feasibility of f is equivalent to the existence of a proper 3-coloring χ with χ(u)≠χ(v) whenever D(u,v)=1.

Soundness/completeness of the S3Col → FFE(F1) reduction (recap with the new lemmas)
- Active types: For each u, pick canonical L(u) and R(u) shapes; by Lemma TS they yield distinct types τ^L_u and τ^R_u. By Lemma CG, only these may carry colors.
- Completeness: Given a proper 3-coloring χ, set f(τ^L_u)=χ(u), f(τ^R_v)=χ(v), and f(τ)=⊥ for all other τ. For any pair (τ_left, τ_right), if both are active, Lemma Seam computes d=D(u,v) and enforces inequality iff d=1; satisfied by χ. If one or both are inactive, ⊥-plumbing admits completion. Hence (F1) holds.
- Soundness: If f satisfies (F1), read χ(u):=f(τ^L_u). For any edge (u,v) (i.e., D(u,v)=1), Lemma Seam forces f(τ^L_u)≠f(τ^R_v), so χ is a proper 3-coloring. Inactive types cannot be colored by f (or some pair would violate Lemma CG’s gating), hence f(τ)=⊥ there.

Neutralizing (F2)
- Add global ⊥-filler: allow wz to be labeled entirely ⊥ for all z ≥ 1, consistent with any boundary assignments and regardless of interior; S remains untouched; ACT gating remains enforced. Then (F2) holds trivially for any f, reducing the tri-class decision to (F1)-feasibility on our family.

Alphabet and radius-1 bookkeeping (explicit)
- Σ_out tracks (constant unless noted): roles/phases O(1), colors {RED,GRN,BLU,⊥} (4), error alphabet O(1), U’s work alphabet O(1), PAD O(1). Additional O(B) symbols for {Q_j} and {P_j} suffice for Lemma TS. Choose β ≥ c·B for a suitable constant c, which holds for c1 ≥ c0 in β = s^{c1}, B = s^{c0}.
- All constraints are radius-1: probes and pointer moves are enforced by nearest-neighbor pairs; tableau rows by local step relations; color inequality is a single adjacency near S_2.

Sanity check plan (B=2)
- Build a toy instance with β≥8, reserve Q_1,Q_2 and P_1,P_2, port zone of length 2 adjacent to S. Verify by brute DP: E_{L(00)}(a⋆)[Q_1,Q_2]=(0,0), E_{L(01)}=(0,1), E_{L(10)}=(1,0), E_{L(11)}=(1,1). Instantiate a tiny D (e.g., a 4-cycle) and check the bridge DP accepts iff colors differ on edges.

Why this is progress
- We have replaced informal sketches with concrete, radius-1 gadgets and clean lemmas (TS, CG, Seam) that are directly checkable via the DP. The per-bit probe avoids the flawed “single probe” idea and uses only O(B) extra symbols, admissible within β=poly(s). Color gating resolves the earlier consistency issue on multiple types per u. The seam gadget specifies exactly how to locally enforce inequality conditioned on D(u,v).

Next steps (auditable deliverables)
1) Write the small adjacency tables for the probe pipeline: list states {PROBE_L, P_j, ACCEPT, PAD} and allowed successors, and the Cin–out masks that gate colors by ACT. Provide a concrete symbol count to confirm β ≥ B+O(1) suffices.
2) Specify the tableau alphabet for U and the local transition rules that output EDGE and forward Color(S_1); include the exact pair checks near S_2 used to enforce inequality.
3) Produce a B=2 machine-readable instance (inputs and tables) and have the verifier’s O(kβ^2) DP validate: (i) separation under Q_1,Q_2; (ii) seam acceptance iff inequality on edges.
4) Integrate a short note into output.md clarifying fixed interior inputs in E_w(a), and (optionally) the explicit definition of C to avoid ambiguity when we later reference “inactive” types.


=== Verifier (summary_md) ===

=== Verifier (verdict) ===
partial success

