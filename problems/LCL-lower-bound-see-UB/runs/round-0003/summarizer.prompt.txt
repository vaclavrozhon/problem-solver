--- SYSTEM ---
You are a research **summarizer**. Summarize this *last round only* for a human log.

Include:
- 3–7 bullet **Highlights** (facts learned, reductions, counterexamples, partial bounds).
- 1–3 **Open questions / TODOs** for the next round.
- 1–3 **Citations to files** you relied on (e.g. round files or papers by name).

**Return strictly JSON**:
{
  "summary_md": "Readable summary of the round (≤200 words)",
  "highlights": [],
  "next_questions": []
}

--- USER ---
=== prover-01.out.json (progress_md) ===
## Round 0003 — 2025-08-27T11:30:44.028451Z

Mini-plan
- Pin down the S-seam gadget: explicit tokens and two families of edge rules that (i) forbid ⊥ at S on active contexts and (ii) allow PAD on inactive ones. Make activation depend only on a constant-size input code around S so it is type-local and radius-1 enforceable.
- Prove Exclusivity Lemma for equality/inequality witnesses: give the invariant (one-hot RID, binary ip, integrity of pointers), and the per-bit comparator tiles so exactly one certificate is realizable.
- Bind sign to RUN and avoid clause-side sign cheats: use S palette {O1,O2,O3} only; the selected occurrence’s sign is exported from RUN into the ON check.
- Show OFF pairs and inactive contexts are neutral: they always have a PAD/⊥ completion and impose no constraints on f.
- Address (F2): argue that our bridge interacts only with the nearest blocks; repetitions add disjoint, self-satisfying structure, hence for our family (F2) holds automatically once (F1) does. Give a local “barrier” that cuts witness chains at one block away from S.
- Validate with a B=2 toy: list the S-seam tokens on the four seam-adjacent nodes, simulate the witness chain on one ON and one OFF pair, and show ⊥ at S is rejected only in active contexts.

1) S-seam gadget with input-coded activation (explicit tokens and local rules)
Definition (tokens and code).
- S tokens: ΣS = {⊥, O1, O2, O3} (occurrence-only palette).
- Left seam-adjacent node uL (immediately left of the left S node) and right seam-adjacent node vR (immediately right of the right S node) carry special seam-interface roles:
  - DoorVar on uL when left side is variable-active; DoorPAD otherwise.
  - DoorCl on vR when right side is clause-active; DoorPAD otherwise.
- Activation code (input-only): we reserve a 2-bit code on each of uL and vR using the node’s own input bit and its predecessor’s input bit (both are available in the two-node S-window contexts). Concretely, we treat the input bit of uL, vR and the bit of their predecessor as “flags” that Cin–out checks to gate the role subtrack:
  - Code 10 on uL (meaning: pred(uL).in=1, uL.in=0) enables only DoorVar; all other outputs at uL are forbidden by Cin–out.
  - Code 01 on vR (meaning: pred(vR).in=0, vR.in=1) enables only DoorCl; all other outputs at vR are forbidden by Cin–out.
  - Any other code enables only DoorPAD at that node.
- Seam edges (Cout–out) enforce:
  - (DoorVar) — (O1|O2|O3) allowed; (DoorVar) — (⊥) forbidden.
  - (O1|O2|O3) — (DoorCl) allowed; (⊥) — (DoorCl) forbidden.
  - (DoorPAD) — (any S token) allowed; (any S token) — (DoorPAD) allowed (inactive side is neutral at seam).
- Inside the left/right blocks (wb/wc), Cout–out enforces a unique expansion from DoorVar/DoorCl: they must start a well-formed block of the designated role (variable/clause) with header HEADC (fixed), RID/GID segments, and RUN tableau (Section 3 recipe). DoorPAD starts a locally consistent PAD sublanguage independent of S.
Why useful here: This forces non-⊥ at S when both sides exhibit the activation code (active context), while keeping inactive contexts neutral: DoorPAD tolerates any S token including ⊥. Activation depends only on constant many nearby input bits and radius-1 seam edges.
How it can fail:
- If the activation code cannot be recognized with r=1, we would leak to nonlocal checks. Here we use only the node’s own input and its predecessor’s input, which Cin–out can gate (per-node pair check), and seam edges are between neighbors.
- If the DP can avoid DoorVar/DoorCl by choosing other outputs: forbidden by Cin–out under the 10/01 codes (they make DoorVar/DoorCl the only legal outputs on those nodes).
Quick test (hand check): choose inputs so that pred(uL).in=1, uL.in=0, pred(vR).in=0, vR.in=1; then uL must output DoorVar, vR must output DoorCl by Cin–out; hence S=⊥ fails at both seam edges. Flip any one flag (e.g., pred(uL).in:=0): Cin–out now allows only DoorPAD at uL; S=⊥ is accepted at that seam.

2) Equality/inequality witness exclusivity (radius-1 certificates)
Claim E (Exclusivity of equality vs inequality certificates). In an active pair where DoorVar (left) and DoorCl (right) start well-formed blocks, and S is O_p selecting occurrence p, exactly one of the following radius-1 witness chains is realizable:
- Equality chain: follows a pointer from S to the clause’s index ip (in binary lanes b=1..B), and from DoorVar to the RID index iL (HotRID one-hot and its binary), and steps bit-by-bit along both binary representations enforcing equality at each bit; only if all bits match does the chain reach a CAP emitter that allows CAP propagation across S. Any mismatch yields a dead end.
- Inequality chain: guesses a bit position b via a bounded fan-out chain from S, steps to the b-th bit lane on both sides, and demands a local mismatch predicate (RID[b] ≠ ip[b]) to reach a PAD emitter that forbids CAP and completes with PAD.
Invariant and tiles:
- Integrity: RID has a one-hot encoding HotRID; its binary RID[b] is also exported on B lanes with local equality between the one-hot position and the binary value; similarly ip has binary lanes exported by RUN. Local Cout–out tiles enforce these equalities and ensure uniqueness.
- Comparator tiles:
  - Equality tile for bit b: requires RID[b]=ip[b], else no outgoing edge.
  - Inequality tile for bit b: requires RID[b]≠ip[b], else no outgoing edge.
- Chain structure: both chains are simple nearest-neighbor cursors. Equality must visit all B bit lanes (fixed-length path) and only then may emit CAP; inequality visits a chosen b and only emits PAD if mismatch holds.
Why useful here: It ensures per (Var_i, Cl_j, O_p) exactly one bridge semantics applies: ON (CAP) if i=ip, OFF (PAD) otherwise. This gives the “one constrained pair per clause pick.”
How it can fail:
- Faking mismatch when equal: impossible because the inequality tile for bit b has no legal continuation if RID[b]=ip[b].
- Faking equality when different: the equality chain stalls at the first b with RID[b]≠ip[b]. There is no alternate bypass due to the uniqueness of the cursor track enforced by Cout–out.
Quick test (B=3): RID=101 (5), ip=111 (7). Equality chain: at b=2 sees 0 vs 1 → dead end. Inequality chain: pick b=2, demands 0≠1 → succeeds; emits PAD.

3) Sign binding via occurrence-only S palette
Claim S (Occurrence-only selection; sign tied to RUN). The clause-side RUN computes for j=GID: three indices (i1,i2,i3) and their signs (sgn1,sgn2,sgn3), exposing binary lanes for indices and one-bit signs per occurrence. The S palette is ΣS={O1,O2,O3}. If S=Op, the equality chain uses ip and the ON-bridge demands VT iff sgnp=+ and VF iff sgnp=− (VT/VF are the two variable-side colors). No sign appears in S;
Cout–out contains local tiles that read sgnp from RUN at the end of the equality chain to gate the CAP emitter (mismatch of variable color vs sgnp blocks CAP).
Why useful here: Prevents “sign cheating” at S and collapses the clause pick to the intended occurrence choice; the sign is immutable (verified by the tableau) and locally read.
How it can fail:
- If RUN could expose multiple inconsistent signs: disallowed by the tableau consistency and single-row export; inconsistencies are locally refuted (error chain), which deactivates the context (only DoorPAD remains legal at the seam via Cin–out code mismatch).
- If S could carry sign: by construction it does not; ΣS lacks sign tokens.
Quick test: Clause j encodes (x3, ¬x7, x10). S=O2; equality O2 with Var_7 succeeds only if left S color is VF; with Var_7 color VT, the CAP gate blocks.

4) OFF pairs and inactive contexts are neutral
Claim N (Neutrality). For any ordered pair where either (i) the activation code does not hold on at least one side (so that side is DoorPAD), or (ii) S=Op but iL≠ip (inequality), or (iii) roles are not (variable, clause), there exists a PAD-only completion independent of f’s other choices. This is implemented by:
- DoorPAD forcing a PAD sublanguage chunk adjacent to S that is seam-compatible with any S token; the remainder of wb/wc can be filled with PAD or well-formed blocks that terminate internally (no CAP).
- Inequality chain emission of PAD, which is the only admissible completion when iL≠ip.
Why useful here: This eliminates spurious constraints from nonselected pairs and from inputs lacking activation codes. Only ON cases constrain f.
How it can fail:
- If PAD conflicts with nearby mandatory block starts: prevented by using Cin–out to permit only DoorPAD (not DoorVar/Cl) when activation code is absent; the PAD language is self-contained and seam-compatible.
- If PAD could carry CAP: prohibited; PAD emitters never produce CAP and Cout–out forbids CAP adjacency except from the equality chain’s emitter.
Quick test: Left inactive (DoorPAD), right active (DoorCl), S arbitrary. The seam edges accept; both wb and wc can be filled by PAD (on left) and a proper block (on right) whose “barriers” (see next claim) absorb internally; DP succeeds.

5) Bridging (F2) holds automatically for our family
Claim B (Nearest-block locality; barriers cut repetition). For any context (w1, S, w2) activated on both sides, and any z≥1, the repeated bridge wz_1 S wz_2 has a completion whenever the base bridge w1 S w2 has one. Reason: the only interactions with S are (a) the seam edges DoorVar/Cl — S and (b) the equality/inequality witness chains, both of which operate exclusively within the nearest blocks contiguous to S, terminated by a local “barrier” token one node beyond the RUN footer that refuses witness cursors. Blocks beyond the nearest ones are separated by barriers and have an internal “sink” completion (PAD-neutral endcaps). Therefore, adding extra copies of w1 or w2 does not introduce any additional seam constraints; all seams between adjacent copies are block-internal and satisfy Cout–out by the block grammar.
Why useful here: We avoid the need to trivialize (F2) via ⊥. With barriers, (F2) is independent of z and thus holds iff the base ON/OFF semantics allow the nearest left/right blocks.
How it can fail:
- If witness chains could jump barriers: prevented by local tiles that forbid the cursor token from crossing the barrier symbols.
- If blocks required cross-copy synchronization: they do not; RUN is self-contained per block and Cout–out only relates neighbors;
repeated copies simply obey the same tiles.
Quick test: Evaluate w1 S w2 with S=O2, success on equality → CAP. Now consider w1^5 S w2^7. The nearest copies to S are identical; their barriers stop any further traversal; the rest can be tiled independently. DP outcome identical.

6) B=2 toy worked seam and bridge
Setup: B=2 so variables x0..x3; pick clause j with (i1=01:+), (i2=10:−), (i3=11:+). Choose inputs around S to encode activation code 10 at uL and 01 at vR, hence Cin–out forces DoorVar at uL and DoorCl at vR.
- Pair (Var_10, Cl_j, S=O2): Equality path: RID=10, ip=10 → equality passes; RUN exposes sgn2=−; CAP emitter requires left S color VF; if we set left S color VF, CAP propagates and DP completes; if VT, the CAP gate blocks and DP fails. Inequality path is blocked since all bits equal.
- Pair (Var_01, Cl_j, S=O2): RID=01, ip=10 differ at b=1; equality chain stalls at b=1; inequality chain pins b=1 and succeeds, emits PAD; DP completes with PAD plumbing and no CAP dependency.
- ⊥ at S: With activation code present, uL is DoorVar and vR is DoorCl, and (DoorVar,⊥) or (⊥,DoorCl) are forbidden at both seam edges; hence DP fails. Remove activation on left (flip pred(uL).in), DoorPAD appears; (DoorPAD,⊥) allowed, DP succeeds.

7) Soundness/completeness of the succinct-SAT reduction (recap under the patched gadget)
- Variables: for each active Var_i type, f(Var_i) ∈ {VT,VF} encodes α(x_i).
- Clauses: for each active Cl_j type, f(Cl_j) ∈ {O1,O2,O3} selects an occurrence p.
- Constraints: by Claim E and S, the only nontrivial bridge per j is with (Var_{i_p}, Cl_j, S=Op), which succeeds iff α(x_{i_p}) matches sgn_p. All other ordered pairs are neutral by Claim N.
- Therefore, (F1) holds iff there exist α and picks p_j such that each clause has a satisfied literal: exactly Succinct-3SAT for C.
- By Claim B, (F2) holds automatically for our family (nearest-block locality with barriers), ensuring that if (F1) holds then f is fully feasible (O(1) side); if (F1) fails then by Theorem 8 (reference) the complexity is Θ(n), giving the desired O(1) vs Θ(n) dichotomy on our instances.

What changed vs previous round (addressing verifier’s gaps)
- Forbid ⊥ at S on active contexts: implemented by Cin–out seam code (10 at uL, 01 at vR) forcing DoorVar/DoorCl and Cout–out disallowing ⊥ adjacent to those. Inactive contexts (other codes) get DoorPAD and remain neutral.
- Sign bound to RUN: S palette is occurrence-only; sign is read from RUN in the equality chain’s CAP gate.
- Exclusivity: Equality/inequality witnesses are backed by explicit per-bit tiles and cursor tracks with one-hot and binary consistency; we argued both directions cannot succeed simultaneously.
- (F2) no longer “trivialized by ⊥”: instead, we ensure bridge locality and add block-internal barriers so repetitions do not affect the S-bridge. This preserves nontriviality of (F1) while still making (F2) automatically hold for our reduction family.

Open edge cases and quick counterexample probes
- Could DP choose to label an active-coded seam node (code 10/01) with DoorPAD to allow ⊥? No: Cin–out at those nodes only permits DoorVar/DoorCl under that code.
- Could DP avoid blocks behind DoorVar/DoorCl? No: Cout–out enforces a unique expansion starting from DoorVar/DoorCl into a well-formed block prefix; deviations are locally rejected.
- Could extra copies in wz_1,wz_2 inject an unexpected ON? No: barriers forbid cursor tokens from crossing block boundaries beyond the nearest; only the nearest block talks to S.

Summary impact
- We now have a radius-1, β-normalized seam and bridge specification that (i) activates constraints precisely where intended, (ii) forbids ⊥ at S on active contexts, (iii) ties sign to RUN, (iv) grants exclusivity of equality/inequality witnesses, (v) renders (F2) independent of z via nearest-block locality and barriers.
- The reduction to Succinct-3SAT remains intact and cleaner: the implicit exponential SAT constraints are exactly of the form “if S picks Op then Var_{i_p} must have color matching sgn_p”, with all other pairs neutral.



=== prover-02.out.json (progress_md) ===
## Round 0003 — 2025-08-27T11:30:44.027502Z

Mini-plan
- Fix the three correctness gaps flagged by the verifier: (A) forbid ⊥ at S on active seams via explicit radius-1 seam rules; (B) bind the sign to the clause RUN by adopting the occurrence-only palette {O1,O2,O3}; (C) prove exclusivity of equality vs inequality certificates with local invariants.
- Specify the seam grammar around S: enumerate allowed Cout–out pairs between S and its two neighbors; define the Offer/Accept handshake and CAP/PAD conduits; make OFF pairs neutral and ON pairs enforce the equality-and-sign check.
- Formalize the pointer/witness chains and the one-hot/binary compare: what tracks exist, how the chain advances, and what local checks prevent faking.
- Provide a robust type-separation lemma (using a tester clause j⋆ if needed) and a B=2 toy check of ON/OFF behavior.
- Reconcile with the reduction: with (F1) only, the family lands in {Θ(log* n), Θ(n)} depending on SAT(C); we do not need to trivialize (F2) (avoid the ⊥-plumbing pitfall for (F1)).

1) Seam grammar around S: tokens, roles, and local rules
We introduce constant-size output tokens and roles used only in the 2 nodes S and their immediate neighbors on each side.
- S-side tokens (clause side): ClauseSelect ∈ {O1, O2, O3}. No sign is encoded at S.
- S-side tokens (variable side): VarTruth ∈ {VT, VF}.
- S-side token ⊥ exists but is forbidden when the adjacent neighbor is active (defined below).
- Interface roles at the neighbor cells (the nodes immediately adjacent to S within wb or wc):
  - AccVar: boundary interface of a well-formed variable block adjacent to S on the left (contains anchors/pointers to RID one-hot and binary RID bits; see §3).
  - AccCla: boundary interface of a well-formed clause block adjacent to S on the right (contains anchors/pointers to the RUN outputs for occurrence indices and signs; see §2).
  - Neutral: any non-interface role (PAD, error-chain, or malformed)—used to deactivate the seam locally.
- Handshake (radius-1) via Cout–out on the two seam edges (left seam: neighbor←→S; right seam: S←→neighbor):
  - If neighbor role is AccVar: allowed S outputs are VarTruth ∈ {VT,VF}; S = ⊥ is forbidden (no Cout–out entry (AccVar, ⊥)).
  - If neighbor role is AccCla: allowed S outputs are ClauseSelect ∈ {O1,O2,O3}; S = ⊥ is forbidden (no Cout–out entry (⊥, AccCla)).
  - If neighbor role is Neutral: allowed S outputs include ⊥ and the non-⊥ tokens but all non-⊥ must emit Offer tokens (see below) that are immediately rejected unless the neighbor upgrades to an Acc● role (making the seam locally deciding). Practically: (Neutral, VarTruth) and (ClauseSelect, Neutral) have no accepting continuations except via immediate error-chain admission; (Neutral, ⊥) and (⊥, Neutral) are always allowed (PAD), ensuring inactive seams are neutral.
- Offer/Accept and certificate start: Non-⊥ at S forces emission of a certificate-start token CertStart on the first interior edge; CertStart is legal only if the adjacent neighbor is AccVar (left seam) or AccCla (right seam). Otherwise, Cout–out rejects and only ⊥ is feasible. This enforces “non-⊥ ⇒ active seam” locally.
- CAP/PAD conduits: Once CertStart is accepted on both sides, a CAP conduit is enabled only under equality (see §3), otherwise only a PAD conduit is enabled (OFF). The Cout–out table forbids placing any error-chain token adjacent to CAP (to prevent bypass), while PAD accepts error-chain tokens (to guarantee neutral fill when OFF).
Why useful here: This replaces the informal “activation” with explicit, radius-1 seam rules. It ensures (i) ⊥ cannot be used at S on active seams, preventing the trivial f ≡ ⊥; (ii) S non-⊥ forces the bridge to engage the certificate machinery; (iii) inactive contexts are always completable via ⊥ and PAD.
How it can fail: If AccVar/AccCla could appear spuriously at non-block neighbors, we would misclassify seams as active. We prevent this by tying Acc● to the internal block grammar: the only roles allowed adjacent to S with Acc● are those that anchor HEAD/RID (variable) or HEAD/GID/RUN (clause); any other role adjacent to S is Neutral, as enforced by Cout–out.
Quick test: In a malformed right context, label S with O2. The neighbor is Neutral, so CertStart is rejected and no completion exists, forcing ⊥ at S (or an error-chain). In a well-formed clause context, O2 is accepted and the certificate starts.

2) Sign binding (occurrence-only palette) and RUN exposure
We adopt the occurrence-only palette at clause S: ClauseSelect ∈ {O1,O2,O3}. The sign is read from the verified RUN.
- Clause RUN: Inside wc (clause side), a radius-1 tableau encodes U(C, GID=j), exposing at fixed offsets near the interface:
  - three B-bit binary indices (i1, i2, i3) and one-hot lanes Hot(i1), Hot(i2), Hot(i3),
  - three sign bits sgn1, sgn2, sgn3 ∈ {+,−}.
- Variable RUN (optional): Inside wb (variable side), expose RID in two redundant forms: B-bit binary RIDbits and a one-hot HotRID.
- Binding rule: If S carries Op, the only enabled clause-side pointer is to the p-th occurrence’s index bits ip and sign sgnp; other occurrence pointers are disabled locally by Cout–out. The variable-side S carries VarTruth ∈ {VT,VF}.
- Sign check: Under equality (see §3), the CAP conduit requires (VarTruth = VT if sgnp=+, else VarTruth = VF if sgnp=−). There is no way to route CAP if this check fails (no Cout–out entries for a mismatched sign at the CAP seam).
Why useful here: The clause cannot cheat on the sign; the only freedom at S is selecting which occurrence p to pick, and the sign is forced by RUN. This matches the intended “pick one literal among the three.”
How it can fail: If RUN could be inconsistent or if multiple occurrence pointers were simultaneously enabled, the clause could dodge constraints. The tableau tiles enforce a single, consistent set of outputs (nearest-neighbor TM transitions), and an error-chain path is available to refute any inconsistency, which automatically deactivates the seam (Neutral role).
Quick test: Clause j with occurrences (i1=3,+),(i2=7,−),(i3=10,+). With O2 at S and equality to RID=7, CAP requires VarTruth=VF. With VarTruth=VT, CAP is disabled and the bridge fails.

3) Equality vs inequality certificates: local invariants and exclusivity
We specify the witness chains and prove exclusivity.
- Tracks and anchors at AccVar (variable side):
  - Binary RIDbits[0..B−1]; One-hot HotRID[1..2^B]; a stable pointer origin PtrRID.
- Tracks and anchors at AccCla (clause side, after selecting p):
  - Binary ip_bits[0..B−1]; One-hot Hot(ip)[1..2^B]; sign sgnp; pointer origin Ptr(ip).
- Chain types and their first steps (must start at S with CertStart):
  - Equality chain Eq: deterministically iterates b=0..B−1; at each step reads (RIDbits[b], ip_bits[b]); local rule requires equality at that bit; if it holds, advance; if a mismatch occurs, the chain dead-ends (no accepting continuation). After b=B−1 succeeds, emit CAP-Enable.
  - Inequality chain Neq: nondeterministically chooses a bit index b (via a small unary counter subchain); then reads (RIDbits[b], ip_bits[b]); local rule requires inequality at that bit; if equal, the chain dead-ends. On success, emit PAD-Enable.
- Pointer integrity: From PtrRID to RIDbits[b] (resp. Ptr(ip) to ip_bits[b]) the chain carries a bit-selector subtrack sel(b) that is checked against a de Bruijn-like local addressing pattern baked into the block; any attempt to “fake” a bit value will contradict the address/bit consistency with an immediate local mismatch. Similarly, the one-hot tracks and the selected occurrence Hot(ip) tie the binary and one-hot encodings.
- Exclusivity Lemma (E): For any active ordered pair (AccVar,AccCla) with selection p, exactly one of Eq or Neq admits a complete witness chain.
  - Proof sketch: If RID = ip, then at every b we have RIDbits[b] = ip_bits[b]. Eq progresses through all b and reaches CAP-Enable; Neq cannot pick any b with differing bits, so it dead-ends immediately for all choices. If RID ≠ ip, then there exists some b with RIDbits[b] ≠ ip_bits[b]. Neq can choose such a b and succeed (PAD-Enable); Eq necessarily fails at the first mismatched b. Radius-1 ensures that each step checks only adjacent outputs; pointer integrity prevents inventing contradictory bit values.
- CAP/PAD propagation and mutual exclusion: Cout–out allows CAP to propagate only if CAP-Enable has been emitted (i.e., Eq has fully succeeded), and PAD to propagate only if PAD-Enable has been emitted (i.e., Neq has succeeded). No rule allows both CAP and PAD simultaneously; the start token CertStart has a one-of-two production that initiates either Eq or Neq but not both.
Why useful here: This yields the intended ON/OFF split: the unique variable whose RID equals the selected occurrence ip turns the pair ON (CAP), and all other variables are OFF (PAD). It also ensures that an adversarial filler cannot bypass the ON-case by choosing the inequality chain.
How it can fail: If bit addressing could be spoofed, the filler might fabricate a mismatch (or match). We design the address path to be self-consistent and locally validated (standard binary counter lane across the RID/ip blocks); the certificate must follow these lanes, and any deviation leads to missing Cout–out entries.
Quick test (B=3): RID=5 (101), ip=5 (101): Eq reads 1=1,0=0,1=1 and enables CAP; Neq can pick b=0,1,2 but all yield equal bits, so dead-end. With RID=6 (110), ip=5 (101): Eq fails at b=0; Neq can pick b=0 (0≠1) and succeed.

4) OFF neutrality and ON enforcement
- OFF pairs (RID ≠ ip): Neq yields PAD-Enable. The only permitted fill is the PAD conduit: a regular-language subgrammar that is oblivious to VarTruth and ClauseSelect and ignores CAP. Error-chain tokens are allowed along PAD, guaranteeing completion regardless of interior content. Thus OFF pairs do not constrain f.
- ON pairs (RID = ip): Only Eq yields CAP-Enable, and the CAP seam enforces the sign check VarTruth↔sgnp. If VarTruth disagrees with sgnp, Cout–out forbids completing the CAP conduit. There is no PAD path in this case (PAD-Enable is not emitted), so the bridge fails.
Why useful here: Exactly one constrained pair per clause selection p, and its success is equivalent to the chosen literal being true under α. All other pairs are tautologies.
How it can fail: If PAD were allowed in ON pairs, constraints would be vacuous. This cannot happen because PAD-Enable is only produced by a successful Neq, which is impossible when RID=ip.
Quick test: Clause j selects O3 with ip=10 and sgn3=+. For pair (Var_10, Cl_j), ON requires VT. For (Var_11, Cl_j), OFF PAD completes trivially.

5) Type separation and availability at scale
Claim TS (Type separation and coverage). There exist 2^B distinct variable context types Var_i and 2^B distinct clause context types Cl_j realized by contexts with |w1|,|w2| ∈ {ℓ_pump, ℓ_pump+1}. Moreover, Var_i ≠ Var_{i′} for i ≠ i′ and Cl_j ≠ Cl_{j′}.
- Coverage: The block footprints (HEAD, RID/GID, RUN anchors) occupy poly(s) cells, while ℓ_pump = 2^{Θ(β^4)} = 2^{poly(s)}. Pumping and replacement allow placing these blocks adjacent to S inside wb/wc while keeping the overall type well-defined (§4, Lemmas 11–15 of the reference).
- Separation (variables): Fix any clause-type Cl_j that selects O1 with ip=i and is otherwise well-formed. For the ordered pairs (Var_i, Cl_j) and (Var_{i′}, Cl_j) with i′≠i, their boundary-extendibility signatures differ under S labels (VT vs VF) because the former admits a CAP (if the sign check is met) and the latter admits only PAD. Hence the types Var_i and Var_{i′} differ. If C does not produce such a j for some i, add a tester j⋆ in the construction with a hard-wired clause whose first occurrence equals i (validated by the same tableau), ensuring separation without relying on C’s structure.
- Separation (clauses): Symmetrically, fix a Var_i and compare Cl_j vs Cl_{j′} by picking selections that include i versus exclude i; their extendibility behavior under a fixed VarTruth differs (ON vs OFF), hence types differ.
Why useful here: Ensures we have enough active types to encode all variables and clauses, and that choices of f over these types correspond to α and clause literal picks.
How it can fail: If Acc● could be placed without the interior RUN/RID content, types might collapse. Our grammar ties Acc● to valid interior content (or to an error-chain that deactivates the seam), preventing spurious activation.
Quick test: Build two clause types Cl_j (with i in its triple) and Cl_{j′} (without i). Pair each with Var_i and set S to select the occurrence containing i: (Var_i, Cl_j) is ON; (Var_i, Cl_{j′}) is OFF. Types differ.

6) Correctness of the reduction (FFE(F1)) with the patched seam and certificates
- Completeness: Given a satisfying assignment α, define f(Var_i) = VT if α(x_i)=1 else VF; define f(Cl_j) = Op selecting any true literal p in clause(j). For any ordered pair, if it is OFF, PAD completes; if it is the ON pair (RID=ip), the Eq certificate emits CAP and the sign check is satisfied by our choice, so the bridge completes.
- Soundness: Suppose f satisfies (F1). Read α from variable types (VT/VF). For each j, O_p must be such that the ON pair (Var_{ip}, Cl_j) completes; otherwise the bridge would fail (no PAD in the equality case). Hence the selected literal is true under α, and all clauses are satisfied.
- Inactive contexts: By the seam rules, any non-⊥ at S is rejected unless the neighbor is Acc●, so f must set ⊥ on inactive types; conversely ⊥ always completes via PAD. Thus inactive contexts impose no constraints.
- No trivialization via ⊥: On active seams, ⊥ at S is locally rejected; hence f cannot trivialize (F1) by using ⊥.
Why useful here: These arguments, now anchored in explicit seam rules and exclusive certificates, close the two key soundness/completeness gaps under the β-normalized, radius-1 model.
How it can fail: If PAD were allowed adjacent to S under non-⊥, an adversary could bypass ON. Our seam+certificate rules forbid PAD unless Neq succeeds (RID≠ip), eliminating this loophole.
Quick test (B=2 worked micro-instance): Variables {x1..x4}, clause j with (x3 ∨ ¬x1 ∨ x4). If α=(x1=0,x3=1,x4=0), set f(Var_3)=VT, f(Cl_j)=O1; only (Var_3, Cl_j) is ON and succeeds; (Var_1, Cl_j),(Var_4, Cl_j) are OFF and PAD-fillable; all other ordered pairs trivial.

7) Size, radius, and locality checks
- Radius-1: All checks are between adjacent nodes: seam handshakes, certificate steps (bit-by-bit compare along pointer lanes), CAP/PAD conduits, and RUN row transitions.
- Alphabet size β: Constant-number of role/phase/handshake tokens; equality/inequality chains add O(1) symbols; RID/GID/RUN alphabets are poly(s); overall |Σ_out| = β = poly(s).
- Type count: ℓ_pump ≤ 2^{Θ(β^4)} = 2^{poly(s)}; enough to realize 2^B active types.
- Error-chains: As in the reference §3, malformed headers or inconsistent RUN rows are locally refutable and lead to Neutral seams (allowing ⊥/PAD), never to Acc●.

8) Why we do not trivialize (F2) here
To avoid the pitfall identified by the verifier (⊥ at S trivializing (F1)), we keep (F2) as in the reference (finite z checks in the upper bound) and prove NEXPTIME-hardness for FFE(F1). This already implies NEXPTIME-hardness for the three-way classification (the algorithm must distinguish at least between Θ(log* n) and Θ(n) on our family).

What changed/was fixed this round (vs. Round 0002)
- Added explicit seam rules forbidding ⊥ at S on active seams and forcing CertStart.
- Adopted occurrence-only clause palette; bound the sign to RUN; eliminated any opportunity to choose a sign at S.
- Stated and justified the exclusivity lemma for equality vs inequality witnesses, with local invariants (pointer integrity, bit checks) and mutual exclusion of CAP/PAD.
- Clarified OFF neutrality and ON enforcement via CAP/PAD-Enable gates.
- Provided a robust type-separation argument with an optional tester clause j⋆ for worst-case C.

Open items and next steps
- Write a concrete micro-table for the seam edges (enumerate Cout–out entries for pairs among {AccVar,AccCla,Neutral}×{VT,VF,O1,O2,O3,⊥,CertStart,CAP,PAD}).
- Spell out the de Bruijn-like addressing and the exact pointer tiles from PtrRID/Ptr(ip) to RIDbits[b]/ip_bits[b]; prove that any deviation is caught in ≤2 local steps.
- Produce an explicit RUN tile set for U with fixed phases and the exposure of (i1,i2,i3) and (sgn1,sgn2,sgn3); include the error-chain tiles and show bounded local refutations for all malformed patterns.
- Work out the full B=2 DP table on 12 ordered pairs to sanity-check exclusivity, sign binding, OFF neutrality, and active-⊥ forbiddance.


=== prover-03.out.json (progress_md) ===
## Round 0003 — 2025-08-27T11:30:44.019901Z

Mini-plan
- Patch the active-window semantics: forbid ⊥ at S on active contexts; adopt occurrence-only clause palette {O1,O2,O3}; bind sign from the verified RUN tracks.
- State and prove a radius-1 Exclusivity Lemma for equality vs. inequality witness chains; pin down the local invariants (one-hot, pointer integrity, eq_so_far register).
- Specify seam rules (offers, ON/OFF gate, CAP/PAD conduits) at the two S-nodes; show (F2) can be trivialized via PAD on repeats without trivializing (F1).
- Add a type-separation lemma using a neutral tester clause j* to guarantee distinct Var_i types independent of C.
- Validate with a B=2 toy: enumerate one clause and 3 variable pairs; check ON/OFF and sign-binding behavior; probe a couple of cheating attempts.

1) Patch A: Active S forbids ⊥; occurrence-only palette with sign bound to RUN
Claim A1 (Active-window S palette and sign binding).
- Clause-side S2 palette is occurrence-only: {O1, O2, O3} (no sign); variable-side S1 palette is truth-only: {VT, VF}. The sign of occurrence p ∈ {1,2,3} is exported from the clause RUN on a local subtrack sgn[p] ∈ {+,−}.
- Activity and ⊥. Introduce boundary Offer tokens emitted by well-formed blocks immediately adjacent to S. Cout–out forbids S ∈ {⊥} adjacent to an Offer; permits S ∈ {⊥} iff the adjacent side emits NoOffer (which only happens if the side is inactive or error-refuted). Thus: S is forced non-⊥ on active contexts; ⊥ allowed only on inactive ones.
- ON condition: Both sides active and clause S2 = Op. The gate is ON iff RID = ip (selected occurrence index) (checked by the witness in Claim E below). On ON, CAP conduit must be used and enforces VT iff sgn[p] = + and VF iff sgn[p] = −.
- OFF condition: If not (RID = ip), the inequality witness must be used (Claim E), and only PAD conduit is permitted; no CAP may be present.
Why useful here: This patch addresses two critical issues: it prevents f(·) ≡ ⊥ from trivially satisfying (F1), and it removes sign choices from S, forcing the sign to match the verified RUN output.
How it can fail:
- If a malformed right block could still legally emit Offer near S, the instance could be forced active without a valid RUN, breaking soundness. We prevent this by making Offer admissible only at the unique boundary positions of the HEADC/RUN grammar; any malformed structure must switch to error-chain tracks that never emit Offer.
- If sign[p] could be spoofed locally, the clause could cheat its sign. We enforce sgn[p] as a read-only track driven by the RUN tableau; any mismatch with RUN is locally refutable via an error-chain, and there is no permitted local transition that sets sgn[p] arbitrarily.
Quick test/counterexample attempt: Construct a right context missing the RUN rows but with an Offer token. The seam rule at the HEADC→RUN boundary refuses changing from PAD to Offer without the exact RUN row header; thus S cannot be non-⊥; with S forced to ⊥, the pair is inactive and imposes no constraint.

2) Lemma E: Exclusivity of equality vs inequality witnesses (radius-1)
Claim E (Exclusivity and determinism of the ON/OFF gate). For an active ordered pair with clause pick p and indices (RID on left, ip on right), the following holds under radius-1 witness semantics:
- There exists a valid equality witness path if and only if RID = ip. If such a path exists, the grammar enables CAP and forbids PAD at the seam.
- There exists a valid inequality witness path if and only if RID ≠ ip. If such a path exists, the grammar enables PAD and forbids CAP at the seam.
- The two witnesses are mutually exclusive: at most one is realizable for any given pair.
Local invariants and implementation (tracks and transitions):
- One-hot indices. Left block exports HotRID[1..B] with exactly one 1; right block exports Occ[p][1..B] with exactly one 1 (Occ is the one-hot for ip, selected by S2 = Op through fixed local pointers inside RUN’s outputs). Nearest-neighbor consistency enforces one-hotness rowwise.
- Bit-lanes. Both blocks expose the binary expansions RID_bits[1..B] and ip_bits[1..B] alongside the one-hots.
- Witness chain and eq_so_far register. A single-symbol-width chain walks across bit positions b = 1..B. The chain carries a mode flag eq ∈ {0,1}. Start at b = 1 with eq = 1. At each step, the only allowed transition updates eq ← eq ∧ (RID_bits[b] == ip_bits[b]). At b = B + 1, the chain halts.
- Acceptance rules. Equality certificate accepts iff the chain reaches b = B + 1 with eq = 1. Inequality certificate accepts iff at some b a designated Mismatch token is placed; placing Mismatch is legal only on steps where (RID_bits[b] ≠ ip_bits[b]) and eq was 1 just before the step. Once Mismatch is placed, the remaining steps propagate a neq-mode that cannot flip back to eq = 1, and acceptance is at the end.
- CAP/PAD gating. CAP may be emitted only if the equality certificate accepts; PAD may be emitted only if the inequality certificate accepts. There is no rule allowing CAP (resp., PAD) without the corresponding accepted witness state.
Why useful here: Encodes the ON/OFF dichotomy so that exactly one of the two certificates can succeed, with all checks performed by two-node constraints.
How it can fail:
- Fabricating a Mismatch when RID = ip: disallowed since setting Mismatch requires (RID_bits[b] ≠ ip_bits[b]) locally, which is false at every b if equal.
- Forcing eq to remain 1 when RID ≠ ip: impossible because eq updates are locally determined by the observed bits; a mismatch forces eq ← 0 and cannot flip back.
- Combining both CAP and PAD: impossible because CAP requires eq(B+1)=1 while PAD requires a Mismatch and eq must become 0; the mode flag prevents simultaneous acceptance.
Quick test/counterexample attempt (B=3):
- RID=5 (101), ip=5 (101): equality chain has eq path 1→1→1→1; accepts; PAD disallowed (no allowed Mismatch placement). RID=5, ip=6 (110): at b=2, bits differ; eq flips to 0; equality fails; inequality can place Mismatch at b=2 and accept; CAP disallowed.

3) Seam rules: offers, gate, CAP/PAD conduits; trivializing (F2) safely
Claim S (Seam rule schema around S).
- Left seam (wb↔S1). If the left neighbor outputs OfferL, then S1 ∈ {VT,VF} is required; S1=⊥ is forbidden. If the left neighbor outputs NoOfferL, then S1=⊥ is the only admissible S1 label.
- Right seam (S2↔wc). If the right neighbor outputs OfferR, then S2 ∈ {O1,O2,O3} is required; S2=⊥ is forbidden. If NoOfferR, then S2=⊥ is the only admissible S2 label.
- ON/OFF enforcement. If both seams present Offer and S2 = Op, Cout–out enables exactly one of two seam grammars depending on the witness mode: ON: CAP conduit (a single-bit wire that propagates from S1 to S2 and is locally compared to sgn[p]); OFF: PAD conduit (neutral filler). The CAP seam forbids PAD tokens; the PAD seam forbids CAP tokens.
- Repeat-PAD (for (F2)). For every context (w1,S,w2) and any z≥1, the tables admit filling each repetition wz_i by a RepeatPAD track that is locally compatible with any S color and with the block-seam on the opposite side of S. RepeatPAD never appears in bridges (wb◦wc) and never coexists with Offer within a block. Hence: (F2) holds vacuously for repeats while (F1) bridges remain nontrivial.
Why useful here: Keeps (F1) hard (since ON forbids PAD bypasses and requires CAP) while allowing (F2) to be made vacuous via RepeatPAD that ignores the length z and does not depend on equality.
How it can fail:
- If RepeatPAD were allowed inside bridges (wb◦wc), it could trivialize (F1); we explicitly forbid PAD on bridges when the gate is ON.
- If Offer could appear alongside RepeatPAD inside wz blocks, the context would become spuriously active; we forbid Offer transitions on RepeatPAD tracks.
Quick test/counterexample attempt: Consider an active context with both offers and S2 = O2, RID ≠ i2. Try to use RepeatPAD in wb◦wc: Cout–out rejects because bridges only allow PAD under an accepted inequality witness; RepeatPAD is only valid inside wz repeats in (F2), not inside bridges.

4) Type separation via a neutral tester clause j*
Claim T (Neutral tester guarantees distinct variable types). Add a reserved, well-formed clause type Cl_{j*} whose RUN deterministically outputs a clause with occurrences (i, dummy, dummy) and known sign, for each i in the needed range (or provide c different tester clause types if we need many). The construction validates these outputs by the same RUN checker and permits S2 ∈ {O1,O2,O3} accordingly.
- For any two variable types Var_i ≠ Var_{i'}, pair with Cl_{j*} configured to pick O1 (the i-occurrence). Under a fixed S1 (say VT), (Var_i, Cl_{j*}) is ON and completable iff VT matches the known sign; (Var_{i'}, Cl_{j*}) is OFF and completable via PAD. Therefore their boundary-extendibility signatures differ under the same S-color, forcing distinct types.
Why useful here: Ensures the existence of exponentially many distinct variable types without relying on idiosyncrasies of C; only needs the RUN tile set we already include.
How it can fail: If Cl_{j*} could be malformed yet still active, it might not separate types; the same Offer+RUN validation prevents that. If O1 could be set without binding to the i occurrence, the ON test could accidentally apply to i′; forbidden by the pointer integrity rules.
Quick test/counterexample attempt: Build Var_5 and Var_6 and pair with Cl_{j*} that exposes occurrence 1 = 5 (positive). With S1=VT and S2=O1, (Var_5,Cl_{j*}) has an equality witness and CAP passes; (Var_6,Cl_{j*}) only inequality witness exists and only PAD passes; types differ.

5) Clause RUN tile: sign-binding and occurrence selection
Claim R (RUN tableau exposes indices and signs; selection wiring is local). The right block’s RUN encodes a BO(1)-time simulation of U(C,j) that materializes:
- Three one-hot vectors Occ[1], Occ[2], Occ[3] ∈ {0,1}^B, each with a unique 1-bit at positions i1,i2,i3.
- Three sign bits sgn[1], sgn[2], sgn[3] ∈ {+,−}.
- Selection pointers: from S2 tokens Op, a fixed local wiring enables a Selected[·] subtrack that equals Occ[p] and a SelectedSgn that equals sgn[p].
The adjacency rules ensure that Op cannot enable Selected that disagrees with the underlying Occ/sgn. Any mismatch triggers an error-chain and deactivates the context (no Offer).
Why useful here: Guarantees the ON check uses the correct i_p and sign, with all information within radius-1 of S via short pointer chains, and aligns with Patch A’s palette.
How it can fail: If Selected could be chosen independently of RUN, the clause could cheat; we prevent by making Selected writable only when a local synchronization state (a phase bit) from the RUN row is present; otherwise, only error-chain transitions are legal. If we needed nonlocal access, that would break r=1; we avoid this by pre-exposing Occ and sgn as adjacent tracks.
Quick test/counterexample attempt: Force S2=O2 but flip sgn[2] in a RUN row. RUN consistency rejects the row; the only continuation is to switch into an error-chain that removes Offer; S must be ⊥ and the context becomes inactive.

6) B=2 toy validation
Setup: Variables x1..x4; one clause j encodes (x3 ∨ ¬x1 ∨ x4). Right RUN exports Occ[1]=one-hot for 3, sgn[1]=+; Occ[2]=one-hot for 1, sgn[2]=−; Occ[3]=one-hot for 4, sgn[3]=+.
- Case α: x1=1, x3=0, x4=0.
  - f(Var_1)=VT, f(Var_3)=VF, f(Var_4)=VF; pick S2=O1.
  - (Var_3, Cl_j): RID=3, ip=3 ⇒ equality witness exists; sgn[1]=+ but S1=VF, CAP comparison fails ⇒ bridge rejects. So O1 is incompatible with α.
  - Pick S2=O2 instead: (Var_1,Cl_j): RID=1, ip=1, equality witness exists; sgn[2]=− and S1=VT mismatches ⇒ reject. O3: (Var_4,Cl_j) equality exists but sgn[3]=+ vs S1=VF ⇒ reject. Thus no S2 works: clause unsatisfied under α.
- Flip α: x1=0,x3=1,x4=0 (i.e., f(Var_1)=VF, f(Var_3)=VT, f(Var_4)=VF).
  - With S2=O1: (Var_3,Cl_j) equality witness exists and sgn[1]=+ vs S1=VT matches; ON uses CAP; all other pairs OFF via inequality/PAD. (F1) passes for this clause.
Cheat probes:
- Try S=⊥ on active pair: forbidden by Offer seam; local check fails.
- Try to use PAD on ON: CAP-only seam disallows PAD tokens; DP dies immediately.
- Try equality witness with RID≠ip: eq_so_far flips to 0 at first mismatch; end state prevents CAP; DP fails.

7) SAT-of-types recapped under the patches
- Variables: for each Var_i active type, choose S1 ∈ {VT,VF} encoding α(x_i).
- Clause picks: for each Cl_j active type, choose S2 ∈ {O1,O2,O3} selecting one occurrence.
- Constraints: For each ordered pair (Var_i, Cl_j), the bridge succeeds iff either (i) it is OFF (RID≠ ip of the chosen p), or (ii) it is ON and α(x_{ip}) matches sgn[p]. Thus (F1) is equivalent to: for each j, there exists p such that the literal at position p is true under α. This is exactly Φ_C satisfiable.
Why useful here: Confirms the reduction still encodes the intended succinct-3SAT after the safety patches.
How it can fail: Only if OFF pairs imposed extra constraints; the Exclusivity Lemma and PAD-only rule guarantee they do not.
Quick test/counterexample attempt: For the toy clause above, selecting O2 enforces only α(x1)=0; pairs with Var_3 and Var_4 are OFF; no extra constraints appear.

What is now solid
- Active/inactive discipline at S (⊥ forbidden on active) and occurrence-only clause palette eliminate the two main pitfalls flagged by the verifier.
- A radius-1 exclusivity proof for equality vs. inequality witnesses (eq_so_far monotonicity, mismatch token rules) prevents bypasses and spurious ONs.
- A seam-rule schema that makes (F2) vacuous via RepeatPAD while keeping (F1) nontrivial.
- A neutral tester clause j* ensures type separation independent of C, addressing the multiplicity of active types robustly.

Open items to finalize (explicit artifacts)
- Enumerate the Cin–out/Cout–out entries at the four seams (left boundary→S1, S1→right bridge, left bridge→S2, S2→right boundary), specifying the exact allowed pairs for: Offer/NoOffer, CAP/PAD, witness-step tokens, and RepeatPAD adjacency.
- List the RUN tile set: the per-row neighbor constraints for U, and the local exposure of Occ[·] and sgn[·]; define the error-chain alphabet and transitions.
- Package the tester j* as a concrete right-block type with its own header tag, and show it does not interfere with the main reduction.
- A tabulated B=2 DP trace for 3–4 representative pairs to sanity-check all seam interactions (especially CAP comparison to sgn[p]).



=== Verifier (summary_md) ===
- Converging design: Adopt P02’s Offer/NoOffer seam with two S-side palettes (S1∈{VT,VF,⊥}, S2∈{O1,O2,O3,⊥}), and P01’s nearest-block barrier so F2 is automatic without trivializing F1.
- Fix P01’s S-palette inconsistency and ensure activation codes are truly radius-1 by locally forwarding predecessor input bits.
- Exclusivity (Eq vs Neq) is sound in concept across all reports; instantiate pointer-integrity tiles to preclude spoofed bits and start-state branching.
- Forbid ⊥ at S on active contexts: needs explicit Cout–out seam tables enumerating allowed pairs and CertStart/CAP/PAD conduits; current text is high-level only.
- F2: Prefer “barriers stop cursors one block away from S” over P03’s RepeatPAD-in-repeats; prove cursors cannot cross barriers and repeated blocks tile independently.
- Avoid adding a tester clause j*: it risks adding non-neutral constraints to F1. Seek type separation via clauses from C or internal extendibility distinctions.
- Provide a B=2 explicit DP trace (~12 nodes) for one ON and one OFF pair to sanity-check all seam interactions and sign gating.
- Yes: mapping SAT(C) to a dichotomy {Θ(log* n), Θ(n)} is sufficient for hardness of the 3-way classifier; O(1) need not be realized by this family.

=== Verifier (verdict) ===
promising

=== Writer (status) ===
success

