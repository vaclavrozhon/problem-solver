Overall: strong convergence on the key fixes (forbid ⊥ at S on active seams; occurrence-only clause palette; sign bound to RUN; exclusivity of Eq/Neq). The remaining work is to make these radius-1 and type-local with explicit tiles and to remove a couple of inconsistencies. The hybrid direction (P02’s seam/handshake plus P01’s nearest-block barriers) is the most robust.

| Claim (short) | Status [OK/Unclear/Broken] | Why |
| Forbid ⊥ at S on active seams | Unclear | All three outline local handshakes (Offer/NoOffer or activation codes), but no explicit seam tables are given; P01 also mixes S palettes across sides. Need exact Cout–out matrices and side-specific S palettes. |
| Eq/Neq exclusivity | OK | Each prover gives a radius-1 scheme (eq_so_far or per-bit tiles) where Eq succeeds iff RID=ip and Neq iff RID≠ip, with mutual exclusion via gating. Missing only the pointer-integrity tiles. |
| F2 via nearest-block barriers | Unclear | P01’s “barrier” story is plausible but uninstantiated; P03’s “RepeatPAD-in-repeats-only” risks leaking into bridges unless tied to local barrier tokens. Need explicit barrier tokens and a proof cursors cannot cross. |

Per-prover audit and minimal fixes/counterexamples:
- Prover 01: The activation via input code 10/01 is fine in spirit, but two issues: (i) S palette inconsistency: you use ΣS={⊥,O1,O2,O3} yet later require the “left S color” to be VT/VF. Fix by splitting S into two nodes/palettes: S1∈{VT,VF,⊥} on the variable side and S2∈{O1,O2,O3,⊥} on the clause side (as in P02/P03). (ii) Radius-1 gating that depends on pred(uL).in needs a locally available witness for that input bit. Without a rule that replicates predecessor input onto uL (or a local input-output constraint that can read neighbor’s input), your Cin–out gate cannot enforce the 10/01 codes. Minimal lemma: add a one-step input-forwarding track that copies each node’s input bit to its right neighbor’s output; then uL can see both bits with r=1. Your F2/barrier story is promising; please list the exact barrier tokens and show witness cursors cannot cross them.
- Prover 02: The Offer/NoOffer seam grammar and occurrence-only S2 palette cleanly forbid ⊥ at active seams and force CertStart. The Eq/Neq witness with pointer integrity is standard; just instantiate the tiles tying HotRID↔RIDbits and Selected(ip)↔RUN. Two cautions: (i) Avoid the “tester clause j*” unless you can prove it stays neutral in F1; an active j* will add constraints across all Var_i and can break completeness. Prefer to derive type separation from clauses produced by C (or via internal boundary-extendibility masks that do not introduce new active types). (ii) Your question about hardness: yes, mapping SAT(C) to a dichotomy {Θ(log* n), Θ(n)} is sufficient to prove NEXPTIME-hardness of the three-way classifier (it must still choose among three labels).
- Prover 03: Your eq_so_far register and mismatch token formalize exclusivity nicely. The RepeatPAD idea is risky: unless RepeatPAD is tied to barrier symbols that are guaranteed to be present strictly beyond the nearest blocks, it can accidentally appear in bridges and trivialize F1. Prefer P01’s barrier-only approach: nearest blocks interact with S; all others are separated by a locally-detectable barrier that blocks cursors. Also, the tester j* has the same neutrality pitfall as above. Occurrence-only palette {O1,O2,O3} with sign read from RUN is indeed preferred.

Next most valuable artifacts to raise confidence: (1) explicit seam tables (offers, ⊥-forbiddance, CertStart, CAP/PAD gating); (2) the bit-comparator and pointer-integrity tiles; (3) barrier tokens and a 1–2 step proof that cursors die at barriers; (4) a B=2 worked DP trace showing one ON (CAP) and one OFF (PAD) case; (5) a short formal for F2: adding copies of w to the left/right does not change boundary extendibility because only nearest blocks expose Offer and accept CertStart.
