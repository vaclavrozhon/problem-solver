--- SYSTEM ---
You are a strict mathematical verifier & research manager.

Tasks:
1) Audit correctness & rigor. Identify leaps, gaps, unjustified claims, likely false statements; produce the simplest counterexample or the minimal missing lemma.
2) Triage value. Separate genuine progress from noise.
3) Guide next steps. Suggest the next experiments/lemmas that most raise confidence.

Include a 3-row table:
| Claim (short) | Status [OK/Unclear/Broken] | Why |

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique for the prover (≥150 words)",
  "summary_md": "2–10 bullets for the human: what works, what fails, next steps",
  "verdict": "promising|uncertain|unlikely",
  "blocking_issues": []
}

--- USER ---
You receive multiple prover reports. Evaluate correctness, value, and pick promising directions. Optionally update notes and decide whether to call the writer.

Prover reports (JSON):
[{"prover_id": "01", "progress_md": "## Round 0003 \u2014 2025-08-27T11:30:44.028451Z\n\nMini-plan\n- Pin down the S-seam gadget: explicit tokens and two families of edge rules that (i) forbid \u22a5 at S on active contexts and (ii) allow PAD on inactive ones. Make activation depend only on a constant-size input code around S so it is type-local and radius-1 enforceable.\n- Prove Exclusivity Lemma for equality/inequality witnesses: give the invariant (one-hot RID, binary ip, integrity of pointers), and the per-bit comparator tiles so exactly one certificate is realizable.\n- Bind sign to RUN and avoid clause-side sign cheats: use S palette {O1,O2,O3} only; the selected occurrence\u2019s sign is exported from RUN into the ON check.\n- Show OFF pairs and inactive contexts are neutral: they always have a PAD/\u22a5 completion and impose no constraints on f.\n- Address (F2): argue that our bridge interacts only with the nearest blocks; repetitions add disjoint, self-satisfying structure, hence for our family (F2) holds automatically once (F1) does. Give a local \u201cbarrier\u201d that cuts witness chains at one block away from S.\n- Validate with a B=2 toy: list the S-seam tokens on the four seam-adjacent nodes, simulate the witness chain on one ON and one OFF pair, and show \u22a5 at S is rejected only in active contexts.\n\n1) S-seam gadget with input-coded activation (explicit tokens and local rules)\nDefinition (tokens and code).\n- S tokens: \u03a3S = {\u22a5, O1, O2, O3} (occurrence-only palette).\n- Left seam-adjacent node uL (immediately left of the left S node) and right seam-adjacent node vR (immediately right of the right S node) carry special seam-interface roles:\n  - DoorVar on uL when left side is variable-active; DoorPAD otherwise.\n  - DoorCl on vR when right side is clause-active; DoorPAD otherwise.\n- Activation code (input-only): we reserve a 2-bit code on each of uL and vR using the node\u2019s own input bit and its predecessor\u2019s input bit (both are available in the two-node S-window contexts). Concretely, we treat the input bit of uL, vR and the bit of their predecessor as \u201cflags\u201d that Cin\u2013out checks to gate the role subtrack:\n  - Code 10 on uL (meaning: pred(uL).in=1, uL.in=0) enables only DoorVar; all other outputs at uL are forbidden by Cin\u2013out.\n  - Code 01 on vR (meaning: pred(vR).in=0, vR.in=1) enables only DoorCl; all other outputs at vR are forbidden by Cin\u2013out.\n  - Any other code enables only DoorPAD at that node.\n- Seam edges (Cout\u2013out) enforce:\n  - (DoorVar) \u2014 (O1|O2|O3) allowed; (DoorVar) \u2014 (\u22a5) forbidden.\n  - (O1|O2|O3) \u2014 (DoorCl) allowed; (\u22a5) \u2014 (DoorCl) forbidden.\n  - (DoorPAD) \u2014 (any S token) allowed; (any S token) \u2014 (DoorPAD) allowed (inactive side is neutral at seam).\n- Inside the left/right blocks (wb/wc), Cout\u2013out enforces a unique expansion from DoorVar/DoorCl: they must start a well-formed block of the designated role (variable/clause) with header HEADC (fixed), RID/GID segments, and RUN tableau (Section 3 recipe). DoorPAD starts a locally consistent PAD sublanguage independent of S.\nWhy useful here: This forces non-\u22a5 at S when both sides exhibit the activation code (active context), while keeping inactive contexts neutral: DoorPAD tolerates any S token including \u22a5. Activation depends only on constant many nearby input bits and radius-1 seam edges.\nHow it can fail:\n- If the activation code cannot be recognized with r=1, we would leak to nonlocal checks. Here we use only the node\u2019s own input and its predecessor\u2019s input, which Cin\u2013out can gate (per-node pair check), and seam edges are between neighbors.\n- If the DP can avoid DoorVar/DoorCl by choosing other outputs: forbidden by Cin\u2013out under the 10/01 codes (they make DoorVar/DoorCl the only legal outputs on those nodes).\nQuick test (hand check): choose inputs so that pred(uL).in=1, uL.in=0, pred(vR).in=0, vR.in=1; then uL must output DoorVar, vR must output DoorCl by Cin\u2013out; hence S=\u22a5 fails at both seam edges. Flip any one flag (e.g., pred(uL).in:=0): Cin\u2013out now allows only DoorPAD at uL; S=\u22a5 is accepted at that seam.\n\n2) Equality/inequality witness exclusivity (radius-1 certificates)\nClaim E (Exclusivity of equality vs inequality certificates). In an active pair where DoorVar (left) and DoorCl (right) start well-formed blocks, and S is O_p selecting occurrence p, exactly one of the following radius-1 witness chains is realizable:\n- Equality chain: follows a pointer from S to the clause\u2019s index ip (in binary lanes b=1..B), and from DoorVar to the RID index iL (HotRID one-hot and its binary), and steps bit-by-bit along both binary representations enforcing equality at each bit; only if all bits match does the chain reach a CAP emitter that allows CAP propagation across S. Any mismatch yields a dead end.\n- Inequality chain: guesses a bit position b via a bounded fan-out chain from S, steps to the b-th bit lane on both sides, and demands a local mismatch predicate (RID[b] \u2260 ip[b]) to reach a PAD emitter that forbids CAP and completes with PAD.\nInvariant and tiles:\n- Integrity: RID has a one-hot encoding HotRID; its binary RID[b] is also exported on B lanes with local equality between the one-hot position and the binary value; similarly ip has binary lanes exported by RUN. Local Cout\u2013out tiles enforce these equalities and ensure uniqueness.\n- Comparator tiles:\n  - Equality tile for bit b: requires RID[b]=ip[b], else no outgoing edge.\n  - Inequality tile for bit b: requires RID[b]\u2260ip[b], else no outgoing edge.\n- Chain structure: both chains are simple nearest-neighbor cursors. Equality must visit all B bit lanes (fixed-length path) and only then may emit CAP; inequality visits a chosen b and only emits PAD if mismatch holds.\nWhy useful here: It ensures per (Var_i, Cl_j, O_p) exactly one bridge semantics applies: ON (CAP) if i=ip, OFF (PAD) otherwise. This gives the \u201cone constrained pair per clause pick.\u201d\nHow it can fail:\n- Faking mismatch when equal: impossible because the inequality tile for bit b has no legal continuation if RID[b]=ip[b].\n- Faking equality when different: the equality chain stalls at the first b with RID[b]\u2260ip[b]. There is no alternate bypass due to the uniqueness of the cursor track enforced by Cout\u2013out.\nQuick test (B=3): RID=101 (5), ip=111 (7). Equality chain: at b=2 sees 0 vs 1 \u2192 dead end. Inequality chain: pick b=2, demands 0\u22601 \u2192 succeeds; emits PAD.\n\n3) Sign binding via occurrence-only S palette\nClaim S (Occurrence-only selection; sign tied to RUN). The clause-side RUN computes for j=GID: three indices (i1,i2,i3) and their signs (sgn1,sgn2,sgn3), exposing binary lanes for indices and one-bit signs per occurrence. The S palette is \u03a3S={O1,O2,O3}. If S=Op, the equality chain uses ip and the ON-bridge demands VT iff sgnp=+ and VF iff sgnp=\u2212 (VT/VF are the two variable-side colors). No sign appears in S;\nCout\u2013out contains local tiles that read sgnp from RUN at the end of the equality chain to gate the CAP emitter (mismatch of variable color vs sgnp blocks CAP).\nWhy useful here: Prevents \u201csign cheating\u201d at S and collapses the clause pick to the intended occurrence choice; the sign is immutable (verified by the tableau) and locally read.\nHow it can fail:\n- If RUN could expose multiple inconsistent signs: disallowed by the tableau consistency and single-row export; inconsistencies are locally refuted (error chain), which deactivates the context (only DoorPAD remains legal at the seam via Cin\u2013out code mismatch).\n- If S could carry sign: by construction it does not; \u03a3S lacks sign tokens.\nQuick test: Clause j encodes (x3, \u00acx7, x10). S=O2; equality O2 with Var_7 succeeds only if left S color is VF; with Var_7 color VT, the CAP gate blocks.\n\n4) OFF pairs and inactive contexts are neutral\nClaim N (Neutrality). For any ordered pair where either (i) the activation code does not hold on at least one side (so that side is DoorPAD), or (ii) S=Op but iL\u2260ip (inequality), or (iii) roles are not (variable, clause), there exists a PAD-only completion independent of f\u2019s other choices. This is implemented by:\n- DoorPAD forcing a PAD sublanguage chunk adjacent to S that is seam-compatible with any S token; the remainder of wb/wc can be filled with PAD or well-formed blocks that terminate internally (no CAP).\n- Inequality chain emission of PAD, which is the only admissible completion when iL\u2260ip.\nWhy useful here: This eliminates spurious constraints from nonselected pairs and from inputs lacking activation codes. Only ON cases constrain f.\nHow it can fail:\n- If PAD conflicts with nearby mandatory block starts: prevented by using Cin\u2013out to permit only DoorPAD (not DoorVar/Cl) when activation code is absent; the PAD language is self-contained and seam-compatible.\n- If PAD could carry CAP: prohibited; PAD emitters never produce CAP and Cout\u2013out forbids CAP adjacency except from the equality chain\u2019s emitter.\nQuick test: Left inactive (DoorPAD), right active (DoorCl), S arbitrary. The seam edges accept; both wb and wc can be filled by PAD (on left) and a proper block (on right) whose \u201cbarriers\u201d (see next claim) absorb internally; DP succeeds.\n\n5) Bridging (F2) holds automatically for our family\nClaim B (Nearest-block locality; barriers cut repetition). For any context (w1, S, w2) activated on both sides, and any z\u22651, the repeated bridge wz_1 S wz_2 has a completion whenever the base bridge w1 S w2 has one. Reason: the only interactions with S are (a) the seam edges DoorVar/Cl \u2014 S and (b) the equality/inequality witness chains, both of which operate exclusively within the nearest blocks contiguous to S, terminated by a local \u201cbarrier\u201d token one node beyond the RUN footer that refuses witness cursors. Blocks beyond the nearest ones are separated by barriers and have an internal \u201csink\u201d completion (PAD-neutral endcaps). Therefore, adding extra copies of w1 or w2 does not introduce any additional seam constraints; all seams between adjacent copies are block-internal and satisfy Cout\u2013out by the block grammar.\nWhy useful here: We avoid the need to trivialize (F2) via \u22a5. With barriers, (F2) is independent of z and thus holds iff the base ON/OFF semantics allow the nearest left/right blocks.\nHow it can fail:\n- If witness chains could jump barriers: prevented by local tiles that forbid the cursor token from crossing the barrier symbols.\n- If blocks required cross-copy synchronization: they do not; RUN is self-contained per block and Cout\u2013out only relates neighbors;\nrepeated copies simply obey the same tiles.\nQuick test: Evaluate w1 S w2 with S=O2, success on equality \u2192 CAP. Now consider w1^5 S w2^7. The nearest copies to S are identical; their barriers stop any further traversal; the rest can be tiled independently. DP outcome identical.\n\n6) B=2 toy worked seam and bridge\nSetup: B=2 so variables x0..x3; pick clause j with (i1=01:+), (i2=10:\u2212), (i3=11:+). Choose inputs around S to encode activation code 10 at uL and 01 at vR, hence Cin\u2013out forces DoorVar at uL and DoorCl at vR.\n- Pair (Var_10, Cl_j, S=O2): Equality path: RID=10, ip=10 \u2192 equality passes; RUN exposes sgn2=\u2212; CAP emitter requires left S color VF; if we set left S color VF, CAP propagates and DP completes; if VT, the CAP gate blocks and DP fails. Inequality path is blocked since all bits equal.\n- Pair (Var_01, Cl_j, S=O2): RID=01, ip=10 differ at b=1; equality chain stalls at b=1; inequality chain pins b=1 and succeeds, emits PAD; DP completes with PAD plumbing and no CAP dependency.\n- \u22a5 at S: With activation code present, uL is DoorVar and vR is DoorCl, and (DoorVar,\u22a5) or (\u22a5,DoorCl) are forbidden at both seam edges; hence DP fails. Remove activation on left (flip pred(uL).in), DoorPAD appears; (DoorPAD,\u22a5) allowed, DP succeeds.\n\n7) Soundness/completeness of the succinct-SAT reduction (recap under the patched gadget)\n- Variables: for each active Var_i type, f(Var_i) \u2208 {VT,VF} encodes \u03b1(x_i).\n- Clauses: for each active Cl_j type, f(Cl_j) \u2208 {O1,O2,O3} selects an occurrence p.\n- Constraints: by Claim E and S, the only nontrivial bridge per j is with (Var_{i_p}, Cl_j, S=Op), which succeeds iff \u03b1(x_{i_p}) matches sgn_p. All other ordered pairs are neutral by Claim N.\n- Therefore, (F1) holds iff there exist \u03b1 and picks p_j such that each clause has a satisfied literal: exactly Succinct-3SAT for C.\n- By Claim B, (F2) holds automatically for our family (nearest-block locality with barriers), ensuring that if (F1) holds then f is fully feasible (O(1) side); if (F1) fails then by Theorem 8 (reference) the complexity is \u0398(n), giving the desired O(1) vs \u0398(n) dichotomy on our instances.\n\nWhat changed vs previous round (addressing verifier\u2019s gaps)\n- Forbid \u22a5 at S on active contexts: implemented by Cin\u2013out seam code (10 at uL, 01 at vR) forcing DoorVar/DoorCl and Cout\u2013out disallowing \u22a5 adjacent to those. Inactive contexts (other codes) get DoorPAD and remain neutral.\n- Sign bound to RUN: S palette is occurrence-only; sign is read from RUN in the equality chain\u2019s CAP gate.\n- Exclusivity: Equality/inequality witnesses are backed by explicit per-bit tiles and cursor tracks with one-hot and binary consistency; we argued both directions cannot succeed simultaneously.\n- (F2) no longer \u201ctrivialized by \u22a5\u201d: instead, we ensure bridge locality and add block-internal barriers so repetitions do not affect the S-bridge. This preserves nontriviality of (F1) while still making (F2) automatically hold for our reduction family.\n\nOpen edge cases and quick counterexample probes\n- Could DP choose to label an active-coded seam node (code 10/01) with DoorPAD to allow \u22a5? No: Cin\u2013out at those nodes only permits DoorVar/DoorCl under that code.\n- Could DP avoid blocks behind DoorVar/DoorCl? No: Cout\u2013out enforces a unique expansion starting from DoorVar/DoorCl into a well-formed block prefix; deviations are locally rejected.\n- Could extra copies in wz_1,wz_2 inject an unexpected ON? No: barriers forbid cursor tokens from crossing block boundaries beyond the nearest; only the nearest block talks to S.\n\nSummary impact\n- We now have a radius-1, \u03b2-normalized seam and bridge specification that (i) activates constraints precisely where intended, (ii) forbids \u22a5 at S on active contexts, (iii) ties sign to RUN, (iv) grants exclusivity of equality/inequality witnesses, (v) renders (F2) independent of z via nearest-block locality and barriers.\n- The reduction to Succinct-3SAT remains intact and cleaner: the implicit exponential SAT constraints are exactly of the form \u201cif S picks Op then Var_{i_p} must have color matching sgn_p\u201d, with all other pairs neutral.\n\n", "requests_for_more_materials": [], "next_actions_for_prover": ["Write the exact Cin\u2013out gates for the four seam-adjacent nodes (two S nodes and their immediate neighbors), enumerating which output-role tokens are permitted for each input-bit code (10/01/others), and the small Cout\u2013out table fragment for the seam edges (DoorVar/Cl vs \u03a3S).", "List the barrier tokens and their local tiles that (a) cap witness cursors one step beyond the nearest block and (b) ensure each additional copy of w1/w2 in repetitions terminates internally without interacting with S.", "Spell out the comparator tiles for equality/inequality and the integrity tiles linking HotRID one-hot to RID binary lanes, and linking clause ip binary lanes to RUN; include a short proof that both certificates cannot succeed simultaneously.", "Finish a fully explicit B=2 bridge DP walk-through: give a 10\u201314 node snippet around S with concrete outputs on each track (DoorVar, S=O2, comparator cursors, CAP/PAD emitters), and trace the reachability in the layered DP.", "Check the (F2) verifier cases: for z=1..Z (with Z from the type DFA), argue formally that Type(wz_1 S wz_2)=Type(w1 S w2) in our family because only the nearest blocks affect the boundary extendibility masks; reconcile with Lemma 1\u2019s bound.", "Integrate these artifacts into the completeness/soundness proposition and finalize the reduction text, with explicit references to the reference\u2019s Lemmas 10\u201315 (types/pumping/replacement) and Theorems 8\u20139 (gap implications)."]}, {"prover_id": "02", "progress_md": "## Round 0003 \u2014 2025-08-27T11:30:44.027502Z\n\nMini-plan\n- Fix the three correctness gaps flagged by the verifier: (A) forbid \u22a5 at S on active seams via explicit radius-1 seam rules; (B) bind the sign to the clause RUN by adopting the occurrence-only palette {O1,O2,O3}; (C) prove exclusivity of equality vs inequality certificates with local invariants.\n- Specify the seam grammar around S: enumerate allowed Cout\u2013out pairs between S and its two neighbors; define the Offer/Accept handshake and CAP/PAD conduits; make OFF pairs neutral and ON pairs enforce the equality-and-sign check.\n- Formalize the pointer/witness chains and the one-hot/binary compare: what tracks exist, how the chain advances, and what local checks prevent faking.\n- Provide a robust type-separation lemma (using a tester clause j\u22c6 if needed) and a B=2 toy check of ON/OFF behavior.\n- Reconcile with the reduction: with (F1) only, the family lands in {\u0398(log* n), \u0398(n)} depending on SAT(C); we do not need to trivialize (F2) (avoid the \u22a5-plumbing pitfall for (F1)).\n\n1) Seam grammar around S: tokens, roles, and local rules\nWe introduce constant-size output tokens and roles used only in the 2 nodes S and their immediate neighbors on each side.\n- S-side tokens (clause side): ClauseSelect \u2208 {O1, O2, O3}. No sign is encoded at S.\n- S-side tokens (variable side): VarTruth \u2208 {VT, VF}.\n- S-side token \u22a5 exists but is forbidden when the adjacent neighbor is active (defined below).\n- Interface roles at the neighbor cells (the nodes immediately adjacent to S within wb or wc):\n  - AccVar: boundary interface of a well-formed variable block adjacent to S on the left (contains anchors/pointers to RID one-hot and binary RID bits; see \u00a73).\n  - AccCla: boundary interface of a well-formed clause block adjacent to S on the right (contains anchors/pointers to the RUN outputs for occurrence indices and signs; see \u00a72).\n  - Neutral: any non-interface role (PAD, error-chain, or malformed)\u2014used to deactivate the seam locally.\n- Handshake (radius-1) via Cout\u2013out on the two seam edges (left seam: neighbor\u2190\u2192S; right seam: S\u2190\u2192neighbor):\n  - If neighbor role is AccVar: allowed S outputs are VarTruth \u2208 {VT,VF}; S = \u22a5 is forbidden (no Cout\u2013out entry (AccVar, \u22a5)).\n  - If neighbor role is AccCla: allowed S outputs are ClauseSelect \u2208 {O1,O2,O3}; S = \u22a5 is forbidden (no Cout\u2013out entry (\u22a5, AccCla)).\n  - If neighbor role is Neutral: allowed S outputs include \u22a5 and the non-\u22a5 tokens but all non-\u22a5 must emit Offer tokens (see below) that are immediately rejected unless the neighbor upgrades to an Acc\u25cf role (making the seam locally deciding). Practically: (Neutral, VarTruth) and (ClauseSelect, Neutral) have no accepting continuations except via immediate error-chain admission; (Neutral, \u22a5) and (\u22a5, Neutral) are always allowed (PAD), ensuring inactive seams are neutral.\n- Offer/Accept and certificate start: Non-\u22a5 at S forces emission of a certificate-start token CertStart on the first interior edge; CertStart is legal only if the adjacent neighbor is AccVar (left seam) or AccCla (right seam). Otherwise, Cout\u2013out rejects and only \u22a5 is feasible. This enforces \u201cnon-\u22a5 \u21d2 active seam\u201d locally.\n- CAP/PAD conduits: Once CertStart is accepted on both sides, a CAP conduit is enabled only under equality (see \u00a73), otherwise only a PAD conduit is enabled (OFF). The Cout\u2013out table forbids placing any error-chain token adjacent to CAP (to prevent bypass), while PAD accepts error-chain tokens (to guarantee neutral fill when OFF).\nWhy useful here: This replaces the informal \u201cactivation\u201d with explicit, radius-1 seam rules. It ensures (i) \u22a5 cannot be used at S on active seams, preventing the trivial f \u2261 \u22a5; (ii) S non-\u22a5 forces the bridge to engage the certificate machinery; (iii) inactive contexts are always completable via \u22a5 and PAD.\nHow it can fail: If AccVar/AccCla could appear spuriously at non-block neighbors, we would misclassify seams as active. We prevent this by tying Acc\u25cf to the internal block grammar: the only roles allowed adjacent to S with Acc\u25cf are those that anchor HEAD/RID (variable) or HEAD/GID/RUN (clause); any other role adjacent to S is Neutral, as enforced by Cout\u2013out.\nQuick test: In a malformed right context, label S with O2. The neighbor is Neutral, so CertStart is rejected and no completion exists, forcing \u22a5 at S (or an error-chain). In a well-formed clause context, O2 is accepted and the certificate starts.\n\n2) Sign binding (occurrence-only palette) and RUN exposure\nWe adopt the occurrence-only palette at clause S: ClauseSelect \u2208 {O1,O2,O3}. The sign is read from the verified RUN.\n- Clause RUN: Inside wc (clause side), a radius-1 tableau encodes U(C, GID=j), exposing at fixed offsets near the interface:\n  - three B-bit binary indices (i1, i2, i3) and one-hot lanes Hot(i1), Hot(i2), Hot(i3),\n  - three sign bits sgn1, sgn2, sgn3 \u2208 {+,\u2212}.\n- Variable RUN (optional): Inside wb (variable side), expose RID in two redundant forms: B-bit binary RIDbits and a one-hot HotRID.\n- Binding rule: If S carries Op, the only enabled clause-side pointer is to the p-th occurrence\u2019s index bits ip and sign sgnp; other occurrence pointers are disabled locally by Cout\u2013out. The variable-side S carries VarTruth \u2208 {VT,VF}.\n- Sign check: Under equality (see \u00a73), the CAP conduit requires (VarTruth = VT if sgnp=+, else VarTruth = VF if sgnp=\u2212). There is no way to route CAP if this check fails (no Cout\u2013out entries for a mismatched sign at the CAP seam).\nWhy useful here: The clause cannot cheat on the sign; the only freedom at S is selecting which occurrence p to pick, and the sign is forced by RUN. This matches the intended \u201cpick one literal among the three.\u201d\nHow it can fail: If RUN could be inconsistent or if multiple occurrence pointers were simultaneously enabled, the clause could dodge constraints. The tableau tiles enforce a single, consistent set of outputs (nearest-neighbor TM transitions), and an error-chain path is available to refute any inconsistency, which automatically deactivates the seam (Neutral role).\nQuick test: Clause j with occurrences (i1=3,+),(i2=7,\u2212),(i3=10,+). With O2 at S and equality to RID=7, CAP requires VarTruth=VF. With VarTruth=VT, CAP is disabled and the bridge fails.\n\n3) Equality vs inequality certificates: local invariants and exclusivity\nWe specify the witness chains and prove exclusivity.\n- Tracks and anchors at AccVar (variable side):\n  - Binary RIDbits[0..B\u22121]; One-hot HotRID[1..2^B]; a stable pointer origin PtrRID.\n- Tracks and anchors at AccCla (clause side, after selecting p):\n  - Binary ip_bits[0..B\u22121]; One-hot Hot(ip)[1..2^B]; sign sgnp; pointer origin Ptr(ip).\n- Chain types and their first steps (must start at S with CertStart):\n  - Equality chain Eq: deterministically iterates b=0..B\u22121; at each step reads (RIDbits[b], ip_bits[b]); local rule requires equality at that bit; if it holds, advance; if a mismatch occurs, the chain dead-ends (no accepting continuation). After b=B\u22121 succeeds, emit CAP-Enable.\n  - Inequality chain Neq: nondeterministically chooses a bit index b (via a small unary counter subchain); then reads (RIDbits[b], ip_bits[b]); local rule requires inequality at that bit; if equal, the chain dead-ends. On success, emit PAD-Enable.\n- Pointer integrity: From PtrRID to RIDbits[b] (resp. Ptr(ip) to ip_bits[b]) the chain carries a bit-selector subtrack sel(b) that is checked against a de Bruijn-like local addressing pattern baked into the block; any attempt to \u201cfake\u201d a bit value will contradict the address/bit consistency with an immediate local mismatch. Similarly, the one-hot tracks and the selected occurrence Hot(ip) tie the binary and one-hot encodings.\n- Exclusivity Lemma (E): For any active ordered pair (AccVar,AccCla) with selection p, exactly one of Eq or Neq admits a complete witness chain.\n  - Proof sketch: If RID = ip, then at every b we have RIDbits[b] = ip_bits[b]. Eq progresses through all b and reaches CAP-Enable; Neq cannot pick any b with differing bits, so it dead-ends immediately for all choices. If RID \u2260 ip, then there exists some b with RIDbits[b] \u2260 ip_bits[b]. Neq can choose such a b and succeed (PAD-Enable); Eq necessarily fails at the first mismatched b. Radius-1 ensures that each step checks only adjacent outputs; pointer integrity prevents inventing contradictory bit values.\n- CAP/PAD propagation and mutual exclusion: Cout\u2013out allows CAP to propagate only if CAP-Enable has been emitted (i.e., Eq has fully succeeded), and PAD to propagate only if PAD-Enable has been emitted (i.e., Neq has succeeded). No rule allows both CAP and PAD simultaneously; the start token CertStart has a one-of-two production that initiates either Eq or Neq but not both.\nWhy useful here: This yields the intended ON/OFF split: the unique variable whose RID equals the selected occurrence ip turns the pair ON (CAP), and all other variables are OFF (PAD). It also ensures that an adversarial filler cannot bypass the ON-case by choosing the inequality chain.\nHow it can fail: If bit addressing could be spoofed, the filler might fabricate a mismatch (or match). We design the address path to be self-consistent and locally validated (standard binary counter lane across the RID/ip blocks); the certificate must follow these lanes, and any deviation leads to missing Cout\u2013out entries.\nQuick test (B=3): RID=5 (101), ip=5 (101): Eq reads 1=1,0=0,1=1 and enables CAP; Neq can pick b=0,1,2 but all yield equal bits, so dead-end. With RID=6 (110), ip=5 (101): Eq fails at b=0; Neq can pick b=0 (0\u22601) and succeed.\n\n4) OFF neutrality and ON enforcement\n- OFF pairs (RID \u2260 ip): Neq yields PAD-Enable. The only permitted fill is the PAD conduit: a regular-language subgrammar that is oblivious to VarTruth and ClauseSelect and ignores CAP. Error-chain tokens are allowed along PAD, guaranteeing completion regardless of interior content. Thus OFF pairs do not constrain f.\n- ON pairs (RID = ip): Only Eq yields CAP-Enable, and the CAP seam enforces the sign check VarTruth\u2194sgnp. If VarTruth disagrees with sgnp, Cout\u2013out forbids completing the CAP conduit. There is no PAD path in this case (PAD-Enable is not emitted), so the bridge fails.\nWhy useful here: Exactly one constrained pair per clause selection p, and its success is equivalent to the chosen literal being true under \u03b1. All other pairs are tautologies.\nHow it can fail: If PAD were allowed in ON pairs, constraints would be vacuous. This cannot happen because PAD-Enable is only produced by a successful Neq, which is impossible when RID=ip.\nQuick test: Clause j selects O3 with ip=10 and sgn3=+. For pair (Var_10, Cl_j), ON requires VT. For (Var_11, Cl_j), OFF PAD completes trivially.\n\n5) Type separation and availability at scale\nClaim TS (Type separation and coverage). There exist 2^B distinct variable context types Var_i and 2^B distinct clause context types Cl_j realized by contexts with |w1|,|w2| \u2208 {\u2113_pump, \u2113_pump+1}. Moreover, Var_i \u2260 Var_{i\u2032} for i \u2260 i\u2032 and Cl_j \u2260 Cl_{j\u2032}.\n- Coverage: The block footprints (HEAD, RID/GID, RUN anchors) occupy poly(s) cells, while \u2113_pump = 2^{\u0398(\u03b2^4)} = 2^{poly(s)}. Pumping and replacement allow placing these blocks adjacent to S inside wb/wc while keeping the overall type well-defined (\u00a74, Lemmas 11\u201315 of the reference).\n- Separation (variables): Fix any clause-type Cl_j that selects O1 with ip=i and is otherwise well-formed. For the ordered pairs (Var_i, Cl_j) and (Var_{i\u2032}, Cl_j) with i\u2032\u2260i, their boundary-extendibility signatures differ under S labels (VT vs VF) because the former admits a CAP (if the sign check is met) and the latter admits only PAD. Hence the types Var_i and Var_{i\u2032} differ. If C does not produce such a j for some i, add a tester j\u22c6 in the construction with a hard-wired clause whose first occurrence equals i (validated by the same tableau), ensuring separation without relying on C\u2019s structure.\n- Separation (clauses): Symmetrically, fix a Var_i and compare Cl_j vs Cl_{j\u2032} by picking selections that include i versus exclude i; their extendibility behavior under a fixed VarTruth differs (ON vs OFF), hence types differ.\nWhy useful here: Ensures we have enough active types to encode all variables and clauses, and that choices of f over these types correspond to \u03b1 and clause literal picks.\nHow it can fail: If Acc\u25cf could be placed without the interior RUN/RID content, types might collapse. Our grammar ties Acc\u25cf to valid interior content (or to an error-chain that deactivates the seam), preventing spurious activation.\nQuick test: Build two clause types Cl_j (with i in its triple) and Cl_{j\u2032} (without i). Pair each with Var_i and set S to select the occurrence containing i: (Var_i, Cl_j) is ON; (Var_i, Cl_{j\u2032}) is OFF. Types differ.\n\n6) Correctness of the reduction (FFE(F1)) with the patched seam and certificates\n- Completeness: Given a satisfying assignment \u03b1, define f(Var_i) = VT if \u03b1(x_i)=1 else VF; define f(Cl_j) = Op selecting any true literal p in clause(j). For any ordered pair, if it is OFF, PAD completes; if it is the ON pair (RID=ip), the Eq certificate emits CAP and the sign check is satisfied by our choice, so the bridge completes.\n- Soundness: Suppose f satisfies (F1). Read \u03b1 from variable types (VT/VF). For each j, O_p must be such that the ON pair (Var_{ip}, Cl_j) completes; otherwise the bridge would fail (no PAD in the equality case). Hence the selected literal is true under \u03b1, and all clauses are satisfied.\n- Inactive contexts: By the seam rules, any non-\u22a5 at S is rejected unless the neighbor is Acc\u25cf, so f must set \u22a5 on inactive types; conversely \u22a5 always completes via PAD. Thus inactive contexts impose no constraints.\n- No trivialization via \u22a5: On active seams, \u22a5 at S is locally rejected; hence f cannot trivialize (F1) by using \u22a5.\nWhy useful here: These arguments, now anchored in explicit seam rules and exclusive certificates, close the two key soundness/completeness gaps under the \u03b2-normalized, radius-1 model.\nHow it can fail: If PAD were allowed adjacent to S under non-\u22a5, an adversary could bypass ON. Our seam+certificate rules forbid PAD unless Neq succeeds (RID\u2260ip), eliminating this loophole.\nQuick test (B=2 worked micro-instance): Variables {x1..x4}, clause j with (x3 \u2228 \u00acx1 \u2228 x4). If \u03b1=(x1=0,x3=1,x4=0), set f(Var_3)=VT, f(Cl_j)=O1; only (Var_3, Cl_j) is ON and succeeds; (Var_1, Cl_j),(Var_4, Cl_j) are OFF and PAD-fillable; all other ordered pairs trivial.\n\n7) Size, radius, and locality checks\n- Radius-1: All checks are between adjacent nodes: seam handshakes, certificate steps (bit-by-bit compare along pointer lanes), CAP/PAD conduits, and RUN row transitions.\n- Alphabet size \u03b2: Constant-number of role/phase/handshake tokens; equality/inequality chains add O(1) symbols; RID/GID/RUN alphabets are poly(s); overall |\u03a3_out| = \u03b2 = poly(s).\n- Type count: \u2113_pump \u2264 2^{\u0398(\u03b2^4)} = 2^{poly(s)}; enough to realize 2^B active types.\n- Error-chains: As in the reference \u00a73, malformed headers or inconsistent RUN rows are locally refutable and lead to Neutral seams (allowing \u22a5/PAD), never to Acc\u25cf.\n\n8) Why we do not trivialize (F2) here\nTo avoid the pitfall identified by the verifier (\u22a5 at S trivializing (F1)), we keep (F2) as in the reference (finite z checks in the upper bound) and prove NEXPTIME-hardness for FFE(F1). This already implies NEXPTIME-hardness for the three-way classification (the algorithm must distinguish at least between \u0398(log* n) and \u0398(n) on our family).\n\nWhat changed/was fixed this round (vs. Round 0002)\n- Added explicit seam rules forbidding \u22a5 at S on active seams and forcing CertStart.\n- Adopted occurrence-only clause palette; bound the sign to RUN; eliminated any opportunity to choose a sign at S.\n- Stated and justified the exclusivity lemma for equality vs inequality witnesses, with local invariants (pointer integrity, bit checks) and mutual exclusion of CAP/PAD.\n- Clarified OFF neutrality and ON enforcement via CAP/PAD-Enable gates.\n- Provided a robust type-separation argument with an optional tester clause j\u22c6 for worst-case C.\n\nOpen items and next steps\n- Write a concrete micro-table for the seam edges (enumerate Cout\u2013out entries for pairs among {AccVar,AccCla,Neutral}\u00d7{VT,VF,O1,O2,O3,\u22a5,CertStart,CAP,PAD}).\n- Spell out the de Bruijn-like addressing and the exact pointer tiles from PtrRID/Ptr(ip) to RIDbits[b]/ip_bits[b]; prove that any deviation is caught in \u22642 local steps.\n- Produce an explicit RUN tile set for U with fixed phases and the exposure of (i1,i2,i3) and (sgn1,sgn2,sgn3); include the error-chain tiles and show bounded local refutations for all malformed patterns.\n- Work out the full B=2 DP table on 12 ordered pairs to sanity-check exclusivity, sign binding, OFF neutrality, and active-\u22a5 forbiddance.\n", "requests_for_more_materials": ["Confirm that hardness for the three-way classifier is acceptable via a family mapping SAT to {\u0398(log* n), \u0398(n)} (without hitting O(1)); i.e., the reduction need not realize the O(1) case.", "If there are constraints on using a tester clause j\u22c6 hard-wired into the RUN (in addition to clauses generated by C), please specify; otherwise we will include j\u22c6 to guarantee variable-type separation independently of C."], "next_actions_for_prover": ["Enumerate the seam Cout\u2013out pairs explicitly for the four boundary edges: (AccVar\u2194S),(S\u2194AccCla) and their Neutral variants; include CertStart, CAP/PAD tokens, and rejection entries that forbid \u22a5 at active S.", "Specify the pointer/addressing gadget: define the sel(b) subtrack, the de Bruijn pattern, and the local tiles that tie sel(b) to RIDbits[b] and ip_bits[b]; prove a short invariant that any incorrect bit claim dead-ends in \u22642 steps.", "Write the clause RUN tile set for U: states, tape alphabet, row separators, exposure rows for (i1,i2,i3) and (sgn1,sgn2,sgn3), and the local rules that enable only the selected occurrence pointer p (O1/O2/O3).", "Construct the B=2 worked example: list the 12 ordered pairs (Var_i, Cl_j), run the DP reasoning to verify ON/OFF outcomes, and check that f must choose non-\u22a5 on active types and cannot bypass ON with PAD.", "Draft the formal proof of the exclusivity lemma with a diagrammatic 3-lane local transition system (RIDbits, ip_bits, sel(b)) and a mutual-exclusion lemma for CAP/PAD-Enable."]}, {"prover_id": "03", "progress_md": "## Round 0003 \u2014 2025-08-27T11:30:44.019901Z\n\nMini-plan\n- Patch the active-window semantics: forbid \u22a5 at S on active contexts; adopt occurrence-only clause palette {O1,O2,O3}; bind sign from the verified RUN tracks.\n- State and prove a radius-1 Exclusivity Lemma for equality vs. inequality witness chains; pin down the local invariants (one-hot, pointer integrity, eq_so_far register).\n- Specify seam rules (offers, ON/OFF gate, CAP/PAD conduits) at the two S-nodes; show (F2) can be trivialized via PAD on repeats without trivializing (F1).\n- Add a type-separation lemma using a neutral tester clause j* to guarantee distinct Var_i types independent of C.\n- Validate with a B=2 toy: enumerate one clause and 3 variable pairs; check ON/OFF and sign-binding behavior; probe a couple of cheating attempts.\n\n1) Patch A: Active S forbids \u22a5; occurrence-only palette with sign bound to RUN\nClaim A1 (Active-window S palette and sign binding).\n- Clause-side S2 palette is occurrence-only: {O1, O2, O3} (no sign); variable-side S1 palette is truth-only: {VT, VF}. The sign of occurrence p \u2208 {1,2,3} is exported from the clause RUN on a local subtrack sgn[p] \u2208 {+,\u2212}.\n- Activity and \u22a5. Introduce boundary Offer tokens emitted by well-formed blocks immediately adjacent to S. Cout\u2013out forbids S \u2208 {\u22a5} adjacent to an Offer; permits S \u2208 {\u22a5} iff the adjacent side emits NoOffer (which only happens if the side is inactive or error-refuted). Thus: S is forced non-\u22a5 on active contexts; \u22a5 allowed only on inactive ones.\n- ON condition: Both sides active and clause S2 = Op. The gate is ON iff RID = ip (selected occurrence index) (checked by the witness in Claim E below). On ON, CAP conduit must be used and enforces VT iff sgn[p] = + and VF iff sgn[p] = \u2212.\n- OFF condition: If not (RID = ip), the inequality witness must be used (Claim E), and only PAD conduit is permitted; no CAP may be present.\nWhy useful here: This patch addresses two critical issues: it prevents f(\u00b7) \u2261 \u22a5 from trivially satisfying (F1), and it removes sign choices from S, forcing the sign to match the verified RUN output.\nHow it can fail:\n- If a malformed right block could still legally emit Offer near S, the instance could be forced active without a valid RUN, breaking soundness. We prevent this by making Offer admissible only at the unique boundary positions of the HEADC/RUN grammar; any malformed structure must switch to error-chain tracks that never emit Offer.\n- If sign[p] could be spoofed locally, the clause could cheat its sign. We enforce sgn[p] as a read-only track driven by the RUN tableau; any mismatch with RUN is locally refutable via an error-chain, and there is no permitted local transition that sets sgn[p] arbitrarily.\nQuick test/counterexample attempt: Construct a right context missing the RUN rows but with an Offer token. The seam rule at the HEADC\u2192RUN boundary refuses changing from PAD to Offer without the exact RUN row header; thus S cannot be non-\u22a5; with S forced to \u22a5, the pair is inactive and imposes no constraint.\n\n2) Lemma E: Exclusivity of equality vs inequality witnesses (radius-1)\nClaim E (Exclusivity and determinism of the ON/OFF gate). For an active ordered pair with clause pick p and indices (RID on left, ip on right), the following holds under radius-1 witness semantics:\n- There exists a valid equality witness path if and only if RID = ip. If such a path exists, the grammar enables CAP and forbids PAD at the seam.\n- There exists a valid inequality witness path if and only if RID \u2260 ip. If such a path exists, the grammar enables PAD and forbids CAP at the seam.\n- The two witnesses are mutually exclusive: at most one is realizable for any given pair.\nLocal invariants and implementation (tracks and transitions):\n- One-hot indices. Left block exports HotRID[1..B] with exactly one 1; right block exports Occ[p][1..B] with exactly one 1 (Occ is the one-hot for ip, selected by S2 = Op through fixed local pointers inside RUN\u2019s outputs). Nearest-neighbor consistency enforces one-hotness rowwise.\n- Bit-lanes. Both blocks expose the binary expansions RID_bits[1..B] and ip_bits[1..B] alongside the one-hots.\n- Witness chain and eq_so_far register. A single-symbol-width chain walks across bit positions b = 1..B. The chain carries a mode flag eq \u2208 {0,1}. Start at b = 1 with eq = 1. At each step, the only allowed transition updates eq \u2190 eq \u2227 (RID_bits[b] == ip_bits[b]). At b = B + 1, the chain halts.\n- Acceptance rules. Equality certificate accepts iff the chain reaches b = B + 1 with eq = 1. Inequality certificate accepts iff at some b a designated Mismatch token is placed; placing Mismatch is legal only on steps where (RID_bits[b] \u2260 ip_bits[b]) and eq was 1 just before the step. Once Mismatch is placed, the remaining steps propagate a neq-mode that cannot flip back to eq = 1, and acceptance is at the end.\n- CAP/PAD gating. CAP may be emitted only if the equality certificate accepts; PAD may be emitted only if the inequality certificate accepts. There is no rule allowing CAP (resp., PAD) without the corresponding accepted witness state.\nWhy useful here: Encodes the ON/OFF dichotomy so that exactly one of the two certificates can succeed, with all checks performed by two-node constraints.\nHow it can fail:\n- Fabricating a Mismatch when RID = ip: disallowed since setting Mismatch requires (RID_bits[b] \u2260 ip_bits[b]) locally, which is false at every b if equal.\n- Forcing eq to remain 1 when RID \u2260 ip: impossible because eq updates are locally determined by the observed bits; a mismatch forces eq \u2190 0 and cannot flip back.\n- Combining both CAP and PAD: impossible because CAP requires eq(B+1)=1 while PAD requires a Mismatch and eq must become 0; the mode flag prevents simultaneous acceptance.\nQuick test/counterexample attempt (B=3):\n- RID=5 (101), ip=5 (101): equality chain has eq path 1\u21921\u21921\u21921; accepts; PAD disallowed (no allowed Mismatch placement). RID=5, ip=6 (110): at b=2, bits differ; eq flips to 0; equality fails; inequality can place Mismatch at b=2 and accept; CAP disallowed.\n\n3) Seam rules: offers, gate, CAP/PAD conduits; trivializing (F2) safely\nClaim S (Seam rule schema around S).\n- Left seam (wb\u2194S1). If the left neighbor outputs OfferL, then S1 \u2208 {VT,VF} is required; S1=\u22a5 is forbidden. If the left neighbor outputs NoOfferL, then S1=\u22a5 is the only admissible S1 label.\n- Right seam (S2\u2194wc). If the right neighbor outputs OfferR, then S2 \u2208 {O1,O2,O3} is required; S2=\u22a5 is forbidden. If NoOfferR, then S2=\u22a5 is the only admissible S2 label.\n- ON/OFF enforcement. If both seams present Offer and S2 = Op, Cout\u2013out enables exactly one of two seam grammars depending on the witness mode: ON: CAP conduit (a single-bit wire that propagates from S1 to S2 and is locally compared to sgn[p]); OFF: PAD conduit (neutral filler). The CAP seam forbids PAD tokens; the PAD seam forbids CAP tokens.\n- Repeat-PAD (for (F2)). For every context (w1,S,w2) and any z\u22651, the tables admit filling each repetition wz_i by a RepeatPAD track that is locally compatible with any S color and with the block-seam on the opposite side of S. RepeatPAD never appears in bridges (wb\u25e6wc) and never coexists with Offer within a block. Hence: (F2) holds vacuously for repeats while (F1) bridges remain nontrivial.\nWhy useful here: Keeps (F1) hard (since ON forbids PAD bypasses and requires CAP) while allowing (F2) to be made vacuous via RepeatPAD that ignores the length z and does not depend on equality.\nHow it can fail:\n- If RepeatPAD were allowed inside bridges (wb\u25e6wc), it could trivialize (F1); we explicitly forbid PAD on bridges when the gate is ON.\n- If Offer could appear alongside RepeatPAD inside wz blocks, the context would become spuriously active; we forbid Offer transitions on RepeatPAD tracks.\nQuick test/counterexample attempt: Consider an active context with both offers and S2 = O2, RID \u2260 i2. Try to use RepeatPAD in wb\u25e6wc: Cout\u2013out rejects because bridges only allow PAD under an accepted inequality witness; RepeatPAD is only valid inside wz repeats in (F2), not inside bridges.\n\n4) Type separation via a neutral tester clause j*\nClaim T (Neutral tester guarantees distinct variable types). Add a reserved, well-formed clause type Cl_{j*} whose RUN deterministically outputs a clause with occurrences (i, dummy, dummy) and known sign, for each i in the needed range (or provide c different tester clause types if we need many). The construction validates these outputs by the same RUN checker and permits S2 \u2208 {O1,O2,O3} accordingly.\n- For any two variable types Var_i \u2260 Var_{i'}, pair with Cl_{j*} configured to pick O1 (the i-occurrence). Under a fixed S1 (say VT), (Var_i, Cl_{j*}) is ON and completable iff VT matches the known sign; (Var_{i'}, Cl_{j*}) is OFF and completable via PAD. Therefore their boundary-extendibility signatures differ under the same S-color, forcing distinct types.\nWhy useful here: Ensures the existence of exponentially many distinct variable types without relying on idiosyncrasies of C; only needs the RUN tile set we already include.\nHow it can fail: If Cl_{j*} could be malformed yet still active, it might not separate types; the same Offer+RUN validation prevents that. If O1 could be set without binding to the i occurrence, the ON test could accidentally apply to i\u2032; forbidden by the pointer integrity rules.\nQuick test/counterexample attempt: Build Var_5 and Var_6 and pair with Cl_{j*} that exposes occurrence 1 = 5 (positive). With S1=VT and S2=O1, (Var_5,Cl_{j*}) has an equality witness and CAP passes; (Var_6,Cl_{j*}) only inequality witness exists and only PAD passes; types differ.\n\n5) Clause RUN tile: sign-binding and occurrence selection\nClaim R (RUN tableau exposes indices and signs; selection wiring is local). The right block\u2019s RUN encodes a BO(1)-time simulation of U(C,j) that materializes:\n- Three one-hot vectors Occ[1], Occ[2], Occ[3] \u2208 {0,1}^B, each with a unique 1-bit at positions i1,i2,i3.\n- Three sign bits sgn[1], sgn[2], sgn[3] \u2208 {+,\u2212}.\n- Selection pointers: from S2 tokens Op, a fixed local wiring enables a Selected[\u00b7] subtrack that equals Occ[p] and a SelectedSgn that equals sgn[p].\nThe adjacency rules ensure that Op cannot enable Selected that disagrees with the underlying Occ/sgn. Any mismatch triggers an error-chain and deactivates the context (no Offer).\nWhy useful here: Guarantees the ON check uses the correct i_p and sign, with all information within radius-1 of S via short pointer chains, and aligns with Patch A\u2019s palette.\nHow it can fail: If Selected could be chosen independently of RUN, the clause could cheat; we prevent by making Selected writable only when a local synchronization state (a phase bit) from the RUN row is present; otherwise, only error-chain transitions are legal. If we needed nonlocal access, that would break r=1; we avoid this by pre-exposing Occ and sgn as adjacent tracks.\nQuick test/counterexample attempt: Force S2=O2 but flip sgn[2] in a RUN row. RUN consistency rejects the row; the only continuation is to switch into an error-chain that removes Offer; S must be \u22a5 and the context becomes inactive.\n\n6) B=2 toy validation\nSetup: Variables x1..x4; one clause j encodes (x3 \u2228 \u00acx1 \u2228 x4). Right RUN exports Occ[1]=one-hot for 3, sgn[1]=+; Occ[2]=one-hot for 1, sgn[2]=\u2212; Occ[3]=one-hot for 4, sgn[3]=+.\n- Case \u03b1: x1=1, x3=0, x4=0.\n  - f(Var_1)=VT, f(Var_3)=VF, f(Var_4)=VF; pick S2=O1.\n  - (Var_3, Cl_j): RID=3, ip=3 \u21d2 equality witness exists; sgn[1]=+ but S1=VF, CAP comparison fails \u21d2 bridge rejects. So O1 is incompatible with \u03b1.\n  - Pick S2=O2 instead: (Var_1,Cl_j): RID=1, ip=1, equality witness exists; sgn[2]=\u2212 and S1=VT mismatches \u21d2 reject. O3: (Var_4,Cl_j) equality exists but sgn[3]=+ vs S1=VF \u21d2 reject. Thus no S2 works: clause unsatisfied under \u03b1.\n- Flip \u03b1: x1=0,x3=1,x4=0 (i.e., f(Var_1)=VF, f(Var_3)=VT, f(Var_4)=VF).\n  - With S2=O1: (Var_3,Cl_j) equality witness exists and sgn[1]=+ vs S1=VT matches; ON uses CAP; all other pairs OFF via inequality/PAD. (F1) passes for this clause.\nCheat probes:\n- Try S=\u22a5 on active pair: forbidden by Offer seam; local check fails.\n- Try to use PAD on ON: CAP-only seam disallows PAD tokens; DP dies immediately.\n- Try equality witness with RID\u2260ip: eq_so_far flips to 0 at first mismatch; end state prevents CAP; DP fails.\n\n7) SAT-of-types recapped under the patches\n- Variables: for each Var_i active type, choose S1 \u2208 {VT,VF} encoding \u03b1(x_i).\n- Clause picks: for each Cl_j active type, choose S2 \u2208 {O1,O2,O3} selecting one occurrence.\n- Constraints: For each ordered pair (Var_i, Cl_j), the bridge succeeds iff either (i) it is OFF (RID\u2260 ip of the chosen p), or (ii) it is ON and \u03b1(x_{ip}) matches sgn[p]. Thus (F1) is equivalent to: for each j, there exists p such that the literal at position p is true under \u03b1. This is exactly \u03a6_C satisfiable.\nWhy useful here: Confirms the reduction still encodes the intended succinct-3SAT after the safety patches.\nHow it can fail: Only if OFF pairs imposed extra constraints; the Exclusivity Lemma and PAD-only rule guarantee they do not.\nQuick test/counterexample attempt: For the toy clause above, selecting O2 enforces only \u03b1(x1)=0; pairs with Var_3 and Var_4 are OFF; no extra constraints appear.\n\nWhat is now solid\n- Active/inactive discipline at S (\u22a5 forbidden on active) and occurrence-only clause palette eliminate the two main pitfalls flagged by the verifier.\n- A radius-1 exclusivity proof for equality vs. inequality witnesses (eq_so_far monotonicity, mismatch token rules) prevents bypasses and spurious ONs.\n- A seam-rule schema that makes (F2) vacuous via RepeatPAD while keeping (F1) nontrivial.\n- A neutral tester clause j* ensures type separation independent of C, addressing the multiplicity of active types robustly.\n\nOpen items to finalize (explicit artifacts)\n- Enumerate the Cin\u2013out/Cout\u2013out entries at the four seams (left boundary\u2192S1, S1\u2192right bridge, left bridge\u2192S2, S2\u2192right boundary), specifying the exact allowed pairs for: Offer/NoOffer, CAP/PAD, witness-step tokens, and RepeatPAD adjacency.\n- List the RUN tile set: the per-row neighbor constraints for U, and the local exposure of Occ[\u00b7] and sgn[\u00b7]; define the error-chain alphabet and transitions.\n- Package the tester j* as a concrete right-block type with its own header tag, and show it does not interfere with the main reduction.\n- A tabulated B=2 DP trace for 3\u20134 representative pairs to sanity-check all seam interactions (especially CAP comparison to sgn[p]).\n\n", "requests_for_more_materials": ["Confirm that adopting the occurrence-only clause palette {O1,O2,O3} (with sign read from RUN) is acceptable and preferred over sign-coded S tokens.", "Provide any constraints on the allowed size of the error-chain alphabet (we currently assume a constant number of error symbols as in the LBA gadget).", "Confirm that RepeatPAD can be permitted adjacent to any S color in (F2) without violating the \u03b2-normalized radius-1 specification (we will encode RepeatPAD compatibility entirely in Cout\u2013out).", "If available, share a concrete universal TM U tile set that you prefer for the RUN tableau; otherwise we will define a standard small one."], "next_actions_for_prover": ["Write explicit Cout\u2013out seam tables implementing: Offer/NoOffer gating; forbidding \u22a5 at S on active contexts; CAP-only vs. PAD-only seams keyed to witness acceptance; RepeatPAD allowed only inside repeats.", "Detail the equality/inequality witness chain transitions with the eq_so_far register and Mismatch placement; prove a short formal lemma that the two acceptance conditions are exclusive and complete.", "Specify the RUN tile set (states, symbols, row synchronization) and the local exposure of Occ[1..3] and sgn[1..3]; add error-chain transitions for any malformed header/tableau.", "Instantiate the tester clause j* and prove type separation formally by differential extendibility under a fixed S-labeling.", "Produce a B=2 worked DP table (4\u20136 seam steps) for one ON pair and one OFF pair, showing exact local transitions and where attempts to cheat get stuck.", "Recheck size/radius bookkeeping: count tracks/symbols to keep |\u03a3_out| = poly(s) and verify that all checks remain radius-1."]}]

Current notes.md:
Verifier notes (2025-08-27):
- Adopt a hybrid: use Prover 02’s gate to separate ON (i∈vars(j)) from OFF pairs, and Prover 01’s window-anchored blocks to keep all semantics within wb/wc.
- Replace any O(1)-time checker with a poly(s)-length, radius-1 tableau inside wc (and wb as needed) that verifies C(j) and exposes the needed bits to the gate; ensure error-chain refutations for malformed headers.
- Do not rely on boundary-only signatures for type multiplicity; instead, separate types by differential boundary-extendibility induced by interior content (witness success/failure under fixed S-labels).
- Action items: (i) write explicit boundary tables (offers, gate, PAD/CAP conduits), (ii) specify the clause-verification tableau and its alphabet, (iii) prove type-separation and OFF/ON correctness, (iv) complete a B=2 worked example with DP simulation.
Verifier notes addendum (2025-08-27):
- Critical: Forbid ⊥ at S on active contexts. Adjust Cout–out so that when the window anchors a well-formed variable/clause block, the S palette excludes ⊥ and forces an offer; only inactive contexts allow ⊥. This preserves nontriviality of (F1).
- Adopt Prover 01’s occurrence-only S palette {O1,O2,O3}; read the sign from the verified RUN. If using sign-coded S tokens, add a local rule that forces the S-sign to equal the RUN’s sign for the selected occurrence.
- Gate exclusivity: Write and prove a radius-1 lemma that exactly one of equality/inequality certificates is realizable, with CAP allowed only under equality and PAD only under inequality.
- Type separation: Prefer a neutral tester j* (present as a type but labelable so it imposes no constraints under f) to guarantee distinct Var_i without relying on properties of C. Validate no side effects on (F1) or (F2).
- Proceed with explicit seam tables (offers, gate, CAP/PAD), the clause RUN tiles and error chains, and the B=2 worked DP table.

Current outputs.tex (if any):

