--- SYSTEM ---
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (summary so far)
- output.md (rigorously proven results so far)

Guidelines:
- notes.md: should be a readable running log of interesting work. Prefer appending. Replace only if old notes are clearly misleading. Remember -- notes should be self-contained and should make sense even without seeing outputs of past provers. 
- output.md:  Think twice before you add something to this file. Everything here should be rigorous, almost publication-ready. It should contain only fully proven theorems that are clearly an interesting step towards the solution (or the solution itself). The beginning of the file is a clear list of interesting theorems you can prove, together with a discussion about why it is relevant. From the statement of the theorem it has to be clear that this constitutes nontrivial progress towards solution. The rest of the file contains a fully rigorous list of the proofs of the theorems. Keep only proven theorems with clear proofs. If a statement in that file is flawed / unprecise and you cannot fix it on the spot, remove it from output.md and instead add it to notes.md with explanation.
- Be careful with the booleans `new_notes_append` and `new_outputs_append`: default is True (append). Use False only when deliberately rewriting everything.

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (â‰¥200 words). Include concrete next-step suggestions. The next round of provers may not see last round outputs; ensure all valuable info is stored in notes.",
  "new_notes_md": "Markdown (KaTeX allowed). Usually appended to notes.",
  "new_notes_append": "True|False",
  "new_outputs_md": "Markdown (KaTeX allowed). Usually appended to output.md.",
  "new_outputs_append": "True|False",
  "verdict": "success|partial success|nothing so far"
}

**Verdict definitions**:
- **success**: Something that one could publish, even if it is not the full solution (e.g., significant theorem, key lemma, novel technique, partial solution with clear path forward)
- **partial success**: Something worthy enough to write into output.md (e.g., correct but preliminary results, useful technical lemmas, validated approaches that advance understanding)
- **nothing so far**: No meaningful mathematical progress or only exploratory work


--- USER ---
You receive multiple prover reports. Evaluate correctness, value, and pick promising directions. Update notes.md (append/replace) with useful ideas and update output.md (append/replace) ONLY with rigorously verified results.

Prover reports (JSON):
[{"prover_id": "01", "progress_md": "Round goal\n- Deliver a clean, radius-1, per-bit boundary-probe Type-Separation Lemma (Option A) that yields 2^B distinct \u201cvertex\u201d context types \u03c4_u, with a concrete deterministic pointer gadget and explicit gating against error-escapes under reserved probes.\n- State the canonical vertex-context lemma (existence of L(u), R(v) types adjacent to S only) with a pumping-based padding argument to hit lengths \u2113_pump or \u2113_pump+1 without disturbing the port zone.\n- Formalize the seam gadget lemma that simulates D(u,v) across the bridge and gates acceptance by \u201cif EDGE=1 then colors differ, else vacuous,\u201d while keeping error-chains disabled in the active bridge mode. Provide alphabet/radius bookkeeping and a B=2 sanity check blueprint.\n\nContext recap and constraints we must respect\n- \u03b2-normalized, radius-1: Cin\u2013out ties outputs to input bits locally; Cout\u2013out is the only adjacency checker. All gadgets must be nearest-neighbor.\n- Types are defined over fixed interior inputs (clarified in output.md remarks). Distinguishing types only requires showing E_w(a\u22c6) differs for some fixed boundary-input tuple a\u22c6.\n- Feasible-function existence (F1) is the only property we reduce to (we neutralize (F2) later by \u22a5-filler). We must ensure that colored S is only legal on canonical vertex contexts, so f is only \u201cfree\u201d on \u03c4_u and is forced to \u22a5 elsewhere.\n\nLemma TS (Per-bit probe type separation, radius 1)\nStatement. Fix parameters B = s^{c0}, \u03b2 = s^{c1} with c1 \u2265 c0. There exist global Cin\u2013out, Cout\u2013out and a family of \u03b2\u2032 \u2265 B reserved boundary-output 4-tuples {Q_j: j \u2208 [B]} and a fixed boundary-input assignment a\u22c6 \u2208 \u03a3_in^4 such that the following holds. For any word W_L(u) that contains a well-formed left-vertex block (defined below) positioned O(1) from S and encoding u \u2208 {0,1}^B adjacent to S, and has no errors:\n- E_{W_L(u)}(a\u22c6)[Q_j] = 1 iff u_j = 1.\nConsequently, for u \u2260 u\u2032, Type(W_L(u)) \u2260 Type(W_L(u\u2032)) (they differ on E(\u00b7)(a\u22c6) for some Q_j), so there are at least 2^B distinct left-vertex types. Symmetrically for right-vertex types.\n\nDesign (radius-1 with uniform global rules)\n- Tracks in \u03a3_out (constant multiplicity; folded into single symbols):\n  1) Role/phase \u2208 {HEAD, PORT, BRIDGE, PAD, ERR} \u00d7 {phase mod c}.\n  2) RID data bit (output track) required to equal the input bit when Role=PORT (Cin\u2013out enforces copy).\n  3) Address track Addr \u2208 {1,2,\u2026,B} present only when Role=PORT. Each Addr=j is a distinct output symbol component; total O(B).\n  4) Probe corridor states Probe_j,Move and Probe_j,Test (two local phases) for each j \u2208 [B]. These travel inside W_L(u) when a probe is active. Total O(B) many \u201cprobe-id\u201d states, permitted since \u03b2 = poly(s).\n  5) Neutral \u22a5 and error-chain alphabet (ERR_x) as in \u00a73 of the reference, but these are disabled in probe-active mode (see below).\n- Reserved boundary outputs Q_j (two-node boundary on the far-left and the two nodes just inside it) place a start-token that forces the unique corridor Role=BRIDGE with state Probe_j,Move to appear immediately to the right of the left boundary, propagating deterministically rightward cell-by-cell.\n- Corridor-path and uniqueness: Cout\u2013out enumerates exactly one successor for each Probe_j,Move, forcing the head to march right until it meets a cell whose Role=PORT. If no PORT appears within the allowed window, no outgoing pair is allowed: the DP dies (reject). Error-chain and \u22a5 are disallowed adjacent to Probe_j,* by omitting such pairs from Cout\u2013out.\n- Address match and test: At a PORT cell, Cout\u2013out allows Probe_j,Move to step to Probe_j,Test iff the PORT cell carries Addr=j; otherwise it must continue moving (still Probe_j,Move). In Probe_j,Test, Cout\u2013out further requires the PORT cell\u2019s RID bit be 1; only then does it allow a local acceptor \u201csink\u201d (a short fixed BRIDGE\u2192PAD termination sequence). If RID=0, there is simply no legal outgoing pair for Probe_j,Test at this site (reject). Again, no error-escape pairs exist in these states.\n- Disabling probes when not selected: For any boundary-output 4-tuple not in {Q_j}, Cout\u2013out never enables Probe_* states at the boundary; instead it allows generic PAD/\u22a5-plumbing, so these assignments do not influence separation.\n\nWhy E_{W_L(u)}(a\u22c6)[Q_j] = u_j\n- \u201c\u21d2\u201d: If Q_j is used and the interior is a well-formed vertex block, the corridor deterministically reaches the PORT zone adjacent to S (see vertex blocks below), then walks along PORT cells until encountering Addr=j; at that cell, Probe_j,Test checks RID=1. If u_j=1, Cin\u2013out forces the PORT symbol\u2019s RID=1 (copy of input), so the test passes and the sink terminator exists, so the DP has a path.\n- \u201c\u21d0\u201d: If u_j=0, then at the unique cell with Addr=j the RID bit is 0, so Probe_j,Test has no legal continuation; there are no alternative continuations (no error, no \u22a5 permitted in probe mode), and the unique path dies. Therefore E=0.\n- Type-invariance: E_{W_L(u)}(a\u22c6)[Q_j] depends only on the fixed boundary inputs a\u22c6 and the presence/contents of the PORT zone (encodes u). Any two representatives with the same u and no errors admit the same probe behavior. Thus the bitvector over {Q_j} is the same across all words of that type.\n\nVertex blocks and canonical contexts\n- Canonical left-context L(u) and right-context R(v): A well-formed left block W_L(u) begins O(1) to the left of S and is laid out as HEAD \u00b7 RIDPORT \u00b7 SPACER \u00b7 PAD, with:\n  \u2022 HEAD: a self-delimiting header containing enc(D) (copied from \u03a3_in via Cin\u2013out) and marks the start of the block (constant size overhead, independent of B).\n  \u2022 RIDPORT: a contiguous port zone of exactly B cells adjacent to S, each with Role=PORT, the address track Addr=1..B in increasing order left-to-right, and the RID bit track which Cin\u2013out ties to the node\u2019s input bit so that the zone encodes u verbatim.\n  \u2022 SPACER and PAD: a constant-length SPACER followed by a long padding segment PAD with Role=PAD (any filler pattern consistent with Cout\u2013out). Right blocks W_R(v) are symmetric to the right of S.\n- Color-at-S gating: The two S nodes have access to color symbols {RED, GRN, BLU} only if their immediate neighbors on the inside are special handshake boundary symbols that must be adjacent (in Cout\u2013out) to Role=PORT with the correct phase for a vertex block. If these adjacencies fail (i.e., the block is absent/malformed), then any attempt to place a non-\u22a5 color at S cannot be extended (no legal Cout\u2013out pair), hence non-vertex contexts cannot carry colors. Conversely, if the block is well-formed, the handshake permits a colored S, activating the seam gadget (below). This implements \u201conly canonical contexts permit colors,\u201d using radius-1 adjacencies.\n- Length normalization at \u2113_pump or \u2113_pump+1: For any fixed u, we construct a seed left word U_left(u) = P^z \u00b7 HEAD \u00b7 RIDPORT \u00b7 SPACER, where P is a constant PAD primitive whose repetitions are allowed by Cout\u2013out. Choose z so that |U_left(u)| equals \u2113_pump or \u2113_pump+1. This is always possible by taking z = \u2308(\u2113_pump \u2212 c)/|P|\u2309 or z+1. The right side is a \nneutral filler F_R of the required length. By Lemma 12 (composition) and Lemma 11 (replacement), any further padding on the far sides preserves the type near S; the port zone stays adjacent to S because we do not insert repeats inside RIDPORT. Thus for each u there exists at least one left-context of the required lengths with the port zone at S; symmetrically for R(v).\n\nLemma SG (Seam gadget for succinct adjacency and color inequality)\nStatement. There is a fixed radius-1 bridge schema such that for any ordered pair of canonical vertex contexts (L(u), R(v)), if both S windows are colored, the concatenation wa S1 wb wc S2 wd admits a completion iff either D(u,v)=0 or (D(u,v)=1 and the two colors differ). If either side is not a canonical vertex context, colors are forbidden by the handshake; if a side is malformed but S was colored regardless, the bridge offers no completion (no error-escape in active mode).\nDesign details (radius-1)\n- Activation: The color-at-S handshake (above) also puts the inner neighbors of S into a special BRIDGE-Start phase. Cout\u2013out allows entering a BRIDGE corridor across wb \u25e6 wc only from this phase.\n- Inputs to the run: The two B-bit port zones are immediately adjacent to S. The bridge corridor accesses these bits by simple \u201cread heads\u201d that move one step into wb or wc and copy the bit into the first row of a RUN tableau (implemented in the bridge). The circuit D is present in HEAD on both sides (since enc(D) is copied from \u03a3_in to \u03a3_out under HEAD), or, alternatively, we can duplicate enc(D) in the bridge header as constant local data\u2014both are radius-1 local.\n- Tableau: A fixed universal TM U is simulated row-by-row across the bridge to compute d := D(u,v) in poly(s) steps. Cout\u2013out enforces per-row local transitions; malformed rows admit no accepting continuation in the active mode (no ERR allowed adjacent to BRIDGE states). After the last row, a dedicated cell adjacent to the S2 side outputs EDGE \u2208 {0,1}.\n- Local acceptance: Cout\u2013out encodes the rule that across S1 and S2 and the adjacent EDGE cell:\n  \u2022 If EDGE=0 (non-edge), all three color-equality pairs at S are allowed.\n  \u2022 If EDGE=1 (edge), the two S outputs must be unequal; the three equal-color pairs are disallowed, blocking all completions in those cases.\n- Robustness: All ERR_x error-chain symbols are globally available for inactive modes (e.g., malformed vertex blocks when S is \u22a5), but in bridge-active mode (colors present at S) the BRIDGE corridor allows no ERR transitions. Thus a malformed attempt in active mode rejects rather than escaping to ERR.\n\nAlphabet and radius bookkeeping\n- \u03a3_out size: roles/phases O(1); color tokens + \u22a5 (4); error alphabet O(1) (global); PORT addresses (B); probe-id states per j (O(B)); RUN work alphabet for U (constant). Total |\u03a3_out| = \u03b2 can be chosen s^{c1} with c1 \u2265 c0 large enough so \u03b2 \u2265 C\u00b7B for a fixed constant C (absorbing all constants).\n- Radius-1: Every constraint is between a node and its predecessor: Cin\u2013out ties PORT.RID to the input bit; Cout\u2013out enumerates the only legal neighbor pairs for PROBE movement, RUN row steps, BRIDGE activation, and color/EDGE gates.\n\nSoundness/completeness sketches (Succinct 3-Coloring \u2192 FFE(F1))\n- Type separation: By Lemma TS, for each u there is at least one canonical left (resp. right) vertex type \u03c4^L_u (resp. \u03c4^R_u), and \u03c4^L_u \u2260 \u03c4^L_{u\u2032} for u\u2260u\u2032. All non-vertex contexts are inactive (color-at-S cannot be extended), so f must map them to \u22a5.\n- Completeness: Given a proper 3-coloring \u03c7: {0,1}^B \u2192 {R,G,B}, define f(\u03c4^L_u) = \u03c7(u) and f(\u03c4^R_v) = \u03c7(v), f(\u03c4)=\u22a5 for others. For any pair (\u03c4^L_u, \u03c4^R_v), the bridge simulates D(u,v); if D=0, acceptance is unconditional; if D=1, the inequality holds by \u03c7, so the bridge accepts. All other pairings are vacuous by gating.\n- Soundness: If f satisfies (F1), define \u03c7(u) = f(\u03c4^L_u). For any (u,v) with D(u,v)=1, the pair (\u03c4^L_u, \u03c4^R_v) must pass the (F1) DP; by Lemma SG\u2019s gate, that forces \u03c7(u)\u2260\u03c7(v). Hence \u03c7 is a proper 3-coloring. Note the \u201csame-u consistency\u201d issue is avoided by construction: only the canonical \u03c4^L_u and \u03c4^R_v can carry colors, so f is single-valued on u.\n\nNeutralizing (F2)\n- Add global \u22a5-plumbing on repeats: for any w and z\u22651, the repetition wz can be filled entirely with \u22a5 consistent with Cout\u2013out (and respecting the handshake that forbids colors unless a vertex block is present). Then (F2) is vacuous for all contexts, so the three-way classifier reduces to deciding (F1)\u2014hence NEXPTIME-hard.\n\nToy sanity check (B=2)\n- Let \u03b2\u22658. Port zone has two PORT cells with Addr=1,2 and RID matching input bits (u_1,u_2). Q_1, Q_2 probes: under Q_1 the corridor moves to Addr=1 and accepts iff u_1=1; similarly for Q_2. The 4 left-types \u03c4^L_{00}, \u03c4^L_{01}, \u03c4^L_{10}, \u03c4^L_{11} differ on the two probe bits. For a small D encoding (e.g., 4-cycle), the BRIDGE tableau reads u,v and emits EDGE=1 on edges; local gate forbids equal colors only then. A brute-force DP on the combined path verifies that all (F1) instances accept iff colors define a proper 3-coloring.\n\nObstacles and how addressed\n- Unique continuation under reserved probes: We explicitly disallow ERR/\u22a5 adjacencies when any Probe_j,* state appears; the only permitted successor is the deterministic path, ensuring E(Q_j) reflects u_j.\n- Keeping the port zone adjacent to S after length normalization: We choose padding only in PAD, outside RIDPORT, so the port stays adjacent to S; we do not rely on pumping to preserve the internal structure of RIDPORT.\n- Same-u consistency: Avoided by gating colors at S exclusively to canonical vertex contexts; alternative contexts cannot carry colors, so f cannot assign contradictory colors to the same u across multiple types.\n\nGaps or clarifications for output.md (minor)\n- Clarify explicitly (already noted in Remarks) that types E_w(a) are computed with respect to the fixed interior input string of w. Our reductions rely on Cin\u2013out copying input bits into PORT.RID.\n- Optional: Note that while Corollary 4 uses Z \u2264 \u2113^2, for a fixed context one can compute smaller Z from the per-side type DFA cycles; not required for our hardness but may tighten constants.\n\nNext steps (auditable deliverables)\n1) Write the local Cout\u2013out transitions for the probe gadget: list states {Probe_j,Move/Test}, allowed pairs with PORT cells (Addr\u2260j \u21d2 Move; Addr=j and RID=1 \u21d2 acceptor; disallow ERR/\u22a5 near probes). Provide a finite table parametrized by j with size O(B) to confirm \u03b2 budget.\n2) Give the exact HEAD and RIDPORT layouts with Cin\u2013out masks: specify that when Role=PORT, only two output symbols (RID=0/1) are allowed and must match the input bit; when Role=HEAD, output must match the input encoding of D.\n3) Specify the BRIDGE tableau alphabet and the final EDGE cell\u2019s interface to S: define the three forbidden adjacent pairs across S when EDGE=1 (RR, GG, BB) and allow all when EDGE=0; verify radius-1 locality.\n4) Provide a fully worked B=2 instance (explicit symbols) and run the O(k\u03b2^2) DP to validate both Type-Separation and Seam Gadget behavior; we can submit this as a regression test to the verifier.\n5) Integrate the global \u22a5-filler rules for repetitions and restate the corollary: on our instances, the classifier\u2019s O(1) vs. \u03a9(log* n) vs. \u0398(n) reduces to (F1), hence NEXPTIME-hard.\n\nWhy useful here\n- The per-bit probe lemma squarely addresses the verifier\u2019s major issue: we do not \u201cprogram\u201d per-type tables; instead we use uniform global rules and reserved probes whose acceptance depends on the interior u via Cin\u2013out, yielding exponentially many types. The seam gadget aligns exactly with (F1)\u2019s universal pairwise check for 3-coloring. Both gadgets are radius-1 and fit the \u03b2 budget, and they can be verified independently by the DP on small instances.\n"}, {"prover_id": "02", "progress_md": "Status and focus\n- Goal: finalize a clean, radius-1 reduction from Succinct 3-Coloring (S3Col) to Feasible-Function Existence (F1) in the \u03b2-normalized model, with (F2) neutralized by \u22a5-filling, thereby yielding NEXPTIME-hardness of the 3-way classifier.\n- This round: (i) fix the probe/type-separation gadget using a family of per-bit probes Q_j; (ii) specify canonical vertex contexts and gating so only those contexts can carry non-\u22a5 colors at S; (iii) specify a seam tableau that computes Edge(u,v) and Eq(u,v) and enforces acceptance iff (Edge=0 or colors differ) and (Eq=0 or colors equal), which also forces left/right copies of the same vertex to share the same color; (iv) give concrete DP-checkable formulations and bookkeeping; (v) list verifiable next deliverables.\n\nGaps in output.md (minor clarifications, no changes made)\n- Types vs fixed inputs: The definition of E_w(a) notes interior inputs may be arbitrary or fixed by the instance; our hardness builds contexts by choosing suitable interior inputs (binary strings) realizing the canonical blocks. It would help to add a sentence to output.md explicitly stating: \u201cWhen we refer to Type(w), interior inputs are fixed to those of w; the type depends on the chosen input word w.\u201d This is already consistent with the DP and Section 4 of the reference.\n- Optional: Corollary 4\u2019s bound Z \u2264 \u2113^2 is sufficient (tightening via lcm of periods is possible but unnecessary here).\n\nIdea 1 \u2014 Per-bit probe family Q_j gives 2^B distinct vertex types\nConcrete tracks and symbols (radius 1, \u03b2-normalized)\n- \u03a3_in = {0,1}. \u03a3_out tracks (combined into one symbol):\n  1) Role/phase: {HEAD, VERT, PORT, RUN, PAD, PROBE, ERR_k, \u2026} \u00d7 {phase mod c} (constant size).\n  2) S-color: {RED, GRN, BLU, \u22a5} available only on the two S nodes (enforced by roles around S).\n  3) Port zone outputs that must copy \u03a3_in via Cin\u2013out: an address track Addr \u2208 {1,\u2026,B} (encoded in binary or unary across cells) and a data track RIDbit \u2208 {0,1} for the index u.\n  4) Pointer/probe track with states {Start_j, Head_j, Ok_j, Dead_j} for j\u2208[B]; Head_j carries probe-id j along the pointer path; this induces O(B) states; permitted because \u03b2 = poly(s) and B = s^{c0}.\n  5) RUN work alphabet for a fixed U (constant-size), error-chain alphabet as in \u00a73 of the reference (constant).\n- Reserved boundary outputs: choose a common boundary-input pattern a\u22c6, and for each j\u2208[B] a dedicated 4-tuple Q_j on the boundary outputs that sets the PROBE role to Start_j at both boundary sides and fixes neighbors to allow only the probe pipeline (see below).\n\nProbe pipeline (only legal continuation under Q_j)\n- Cout\u2013out lists only the following successor pairs when the left boundary outputs equal Q_j: Start_j (at the outermost position) must be followed by Head_j moving deterministically right, keeping the j-tagged Head_j; along Head_j, the role PORT is required (locally enforced) and the port zone must be present adjacent to S within a fixed offset. Head_j advances cell-by-cell until it stands on a PORT cell whose output Addr equals j (comparison is local: the j-tag in Head_j must match Addr). At that cell:\n  \u2022 If RIDbit=1, a transition Head_j\u2192Ok_j is allowed, after which a short, locally-checked accept sink attaches to filler/PAD; the boundary assignment Q_j is extendible.\n  \u2022 If RIDbit=0, there is no legal successor (no error-escape is listed under PROBE), so no completion exists; the boundary assignment Q_j is non-extendible.\n- No error-chain or alternative plumbing is enabled while the PROBE role is active; this guarantees uniqueness of the computation under Q_j and prevents spurious accepting paths.\n\nLemma TS (Type-separation via Q_j). For each u\u2208{0,1}^B there exists a canonical left-context L(u)=W_L(u) S F_R (constructed below) with a well-formed PORT zone of length \u0398(B) adjacent to S on the right, whose RIDbit track (copied from \u03a3_in via Cin\u2013out) spells u and whose Addr track enumerates addresses 1,\u2026,B. For the fixed boundary-input assignment a\u22c6 and boundary-outputs Q_j, E_{L(u)}(a\u22c6)[Q_j]=u_j. Consequently, if u\u2260u\u2032 then Type(L(u))\u2260Type(L(u\u2032)).\nWhy useful: Gives \u22652^B distinct left context types injectively indexed by u. The same construction mirrored yields right context types R(v).\nProof sketch: Under Q_j the only legal extension (by Cout\u2013out) is the deterministic PROBE pipeline; it reaches the unique PORT cell with Addr=j. Cin\u2013out forces RIDbit outputs to equal the input bits of W_L(u); hence Ok_j exists iff u_j=1. Thus the extendibility bit for Q_j equals u_j. Since the Type records, for each fixed boundary input a\u22c6, the yes/no table over all boundary-outputs, and the family {Q_j} lies within those outputs, the truth tables differ for u\u2260u\u2032, hence types differ. Uniformity: under Q_j there is no alternative continuation, so E_w(a\u22c6)[Q_j] depends only on u, not on other interior nondeterminism.\n\nIdea 2 \u2014 Canonical vertex contexts and color gating\nCanonical shapes\n- Left: L(u) = W_L(u) S F_R. The block W_L(u) is HEAD \u00b7 VERT \u00b7 PORT \u00b7 RUN with O(poly(s)) length, anchored within O(1) of S (fixed offset). The right side F_R is neutral filler (PAD) of length \u2113_pump\u2212O(poly(s)).\n- Right: R(v) = F_L S W_R(v), symmetric.\nColor gating at S (radius 1)\n- Only when the immediate neighbors of S display role tokens GateL (on the left side) or GateR (on the right side), which appear exclusively in well-formed W_L(\u00b7)/W_R(\u00b7) at the fixed offsets, do the S nodes permit non-\u22a5 S-color outputs. Otherwise, S-color must be \u22a5 and any non-\u22a5 choice yields no continuation (local dead-end). This makes all non-canonical contexts inactive.\n- The existence of contexts with |W_L(u)|\u2208{\u2113_pump,\u2113_pump+1} follows from pumping/replacement (Lemmas 11, 14\u201315 in the reference). We pick fixed offsets so that GateL/GateR alignment is independent of the global length choice; padding happens in the outer PAD region.\nResult: Only the canonical L(u), R(v) types are active; all others must be assigned \u22a5 by any feasible f.\n\nIdea 3 \u2014 Seam tableau computing Edge(u,v) and Eq(u,v) and local acceptance\nBridge layout and computation\n- On a bridge instance wa S1 wb wc S2 wd with left=L(u) and right=R(v), the concatenation wb\u2218wc (length \u2265\u2113_pump\u2212O(poly(s))) hosts a standard row-by-row simulation of a fixed U for poly(s) steps. U reads:\n  1) the encoding of the circuit D from HEAD (copied from \u03a3_in via Cin\u2013out inside both W_L, W_R),\n  2) the B-bit RID port u adjacent to S1, the B-bit GID (or v) adjacent to S2.\n- The tableau checks nearest-neighbor consistency (Cout\u2013out row transitions), with conventional error-chains available only when RUN is malformed or HEAD/RID is malformed; but if S carries a non-\u22a5 color while a side is malformed, the seam dead-ends (no accept path), ensuring non-canonical types cannot use colors.\n- U emits two 1-bit flags near S: Edge = D(u,v) and Eq = [u=v] (computed by a simple bitwise equality scan).\nLocal acceptance policy (enforced by constant-size radius-1 constraints around S)\n- Accept iff both conditions hold simultaneously:\n  (A) Edge=0 OR (S-color1 \u2260 S-color2), and\n  (B) Eq=0 OR (S-color1 = S-color2).\n- Intuition: (A) enforces inequality on edges, vacuous on non-edges; (B) forces left/right copies of the same vertex to carry identical colors (Eq=1 \u21d2 colors equal), which also makes all duplicate types for a given u consistent via pairing with the unique right-type R(u).\n- If either side is inactive (color at S forbidden), a colored attempt dead-ends; with \u22a5 at S, the seam always accepts (\u22a5-plumbing), making all non-canonical pairs trivial.\n\nWhy this aligns with (F1) and fixes prior concerns\n- Pairwise constraint matches (F1): every ordered pair of contexts is checked; edges impose inequality; non-edges impose nothing; in addition Eq=1 imposes left/right consistency, removing the need for uniqueness of types per u.\n- Determinism under probes prevents \u201ccheating\u201d via error-chains.\n\nNeutralizing (F2)\n- Add a global \u22a5-filler: for any context (w1,S,w2) and any z\u22651, allow wz_1, wz_2 to be entirely labeled with \u22a5 via Cout\u2013out, independent of boundary inputs/outputs and independent of the internal roles. This never overrides S nor GateL/GateR, and thus does not affect (F1). Consequently, (F2) is always true for any f on our instances; the classifier reduces to (F1)-feasibility.\n\nSoundness/completeness (sketch with the new Eq gating)\n- Completeness (3-colorable \u21d2 feasible f): Given a proper 3-coloring \u03c7:V\u2192{R,G,B}, define f(Type(L(u))) = \u03c7(u) and f(Type(R(v))) = \u03c7(v); all inactive types map to \u22a5. For any ordered pair (L(u),R(v)), U computes Edge and Eq. If Edge=1 then \u03c7(u)\u2260\u03c7(v) and (A) holds; if Edge=0 then (A) holds trivially. If Eq=1 (thus u=v), then \u03c7(u)=\u03c7(v) by definition of f on left/right copies and (B) holds; if Eq=0, (B) is vacuous. Thus all (F1) instances accept. (F2) is vacuous by \u22a5-filling.\n- Soundness (feasible f \u21d2 3-colorable): Define \u03c7(u):=f(Type(L(u))) (well-defined because pairing (L(u),R(u)) forces equality via (B)). For any edge (u,v), pairing (L(u),R(v)) yields Edge=1, so (A) forces \u03c7(u)\u2260\u03c7(v). Hence \u03c7 is a proper 3-coloring.\n\nDP-checkable toy instance (B=2)\n- Set \u03b2\u22658. Build L(00), L(01), L(10), L(11), and R(\u00b7) analogously. Reserve Q_1,Q_2. Verify:\n  \u2022 E_{L(u)}(a\u22c6)[Q_1] = u_1, E_{L(u)}(a\u22c6)[Q_2] = u_2 (the DP fails/succeeds under the unique probe pipeline).\n  \u2022 On a small D (e.g., a 4-cycle), the seam tableau sets Edge accordingly; local acceptance enforces inequality on edges; Eq enforces equality across (L(u),R(u)) pairs.\n- The verifier can brute-force all ordered pairs of these contexts and check that (F1) holds iff a 3-coloring exists.\n\nAlphabet and complexity bookkeeping\n- Tracks: roles/phases O(1), colors+\u22a5 (4), error alphabet O(1), RUN alphabet O(1), probe/pointer states O(B), plus a constant variety of plumbing symbols. Choose \u03b2 = s^{c1} with c1\u2265c0 so \u03b2\u2265\u0398(B); the global tables Cin\u2013out (2\u00d7\u03b2) and Cout\u2013out (\u03b2\u00d7\u03b2) remain poly(\u03b2).\n- Lengths: HEAD+PORT+RUN = poly(s) \u226a \u2113_pump = 2^{\u0398(\u03b2^4)}; pumping/replacement embeds blocks adjacent to S within contexts of length \u2113_pump or \u2113_pump+1.\n- Radius 1: every check (probe step, address match, bit read, row-to-row evolution, local acceptance at S) is nearest-neighbor.\n\nObstacles addressed and remaining\n- Fixed single-probe issue resolved: we use a family {Q_j} and carry the j-id in Head_j; acceptance depends on u.\n- Consistency across duplicate types: ensured by Eq gating across (L(u),R(u)). This propagates equality across all left/right duplicates via (F1).\n- Error-chain leakage: explicitly disabled under PROBE; enabled only in malformed RUN/head regions not under probe or color activation.\n- Remaining work: write explicit Cout\u2013out pairs for pointer transitions and RUN rows (constant-size schemas); specify the exact offsets and phases that isolate GateL/GateR to canonical contexts; present a small B=2 instantiation with explicit tables that the verifier can DP-check.\n\nNext concrete steps (auditable)\n1) Write the pointer/probe transitions: the set of allowed (y_i,y_{i+1}) pairs for Start_j, Head_j, Ok_j, including the guard that Head_j may move only over PORT cells and must compare its j-tag to Addr.\n2) Formalize Lemma TS: a fully self-contained proof in our r=1 model that E_{L(u)}(a\u22c6)[Q_j]=u_j (no alternative accepting continuation) and that u\u2260u\u2032 \u21d2 types differ. Include a precise statement of a\u22c6 and the reserved outputs Q_j.\n3) Specify canonical L(u), R(v) layouts: exact offsets for HEAD, PORT, RUN relative to S; a small constant-phase scheme that ensures GateL/GateR appear only at those offsets; show padding preserves type (Lemmas 11,14\u201315).\n4) Write the seam U-tableau alphabet and local rules; define where Edge and Eq flags appear; list the constant-size local acceptance checks at S implementing (A) and (B).\n5) Provide a B=2 toy with explicit Cin\u2013out,Cout\u2013out snippets and run the O(k\u03b2^2) DP to confirm: (i) probe acceptance patterns; (ii) seam behavior on all pairs; (iii) \u22a5-filling for (F2).\n\nWhy this is progress\n- We now have concrete, verifiable lemmas addressing the verifier\u2019s critiques: a radius-1, globally uniform probe family that separates 2^B types; canonical gating to single out active contexts; and a seam that enforces both edge-inequality and same-vertex equality, removing the latent ambiguity across duplicates. Each component is amenable to the O(k\u03b2^2) DP, and the size/radius constraints stay within the \u03b2-normalized model."}, {"prover_id": "03", "progress_md": "Status and aim\n- Objective: push the NEXPTIME-hardness reduction (Succinct 3-Coloring \u2192 Feasible-Function Existence (F1)) to a checkable state by pinning down two core gadgets with radius-1 rules and polynomial alphabet: (i) per-bit boundary probes that separate 2^B vertex types, and (ii) a seam tableau that computes D(u,v) and enforces color inequality on edges. Also enforce \u201cmust-color\u201d only on canonical vertex contexts and neutralize (F2) via \u22a5-filling.\n- Output.md: no correctness issues spotted for the upper bound (types, DP, finite-Z). Clarification already noted there (\u201cfixed inputs\u201d interpretation) is consistent with what we use below. The NEXPTIME verifier section is still informal; we supply precise, testable lemmas and constraints to move pieces into output.md.\n\nLemma TS (Per-bit probe type separation; radius-1, \u03b2=poly(s))\n- Parameters: B = s^{c0}, \u03b2 = s^{c1} with c1 > c0 so \u03b2 \u2265 B and there is headroom for O(B) reserved symbols.\n- Canonical left vertex block L(u): a fixed-format segment W_L(u) adjacent to S with the following O(B)-length subzones (roles enforced by Cout\u2013out phases):\n  1) HEAD_C: a short header whose out-track copies (via Cin\u2013out) a fixed binary description enc(C) of the succinct adjacency circuit. Any deviation allows an error-chain in non-probe contexts, but see \u201cProbe discipline\u201d below.\n  2) PORT: B consecutive cells immediately to the right of S. Each PORT cell carries two output subtracks: Addr \u2208 {1,\u2026,B} and RidBit \u2208 {0,1}. Local Cout\u2013out rules require Addr to increase by 1 from left to right, starting at 1 and ending at B, and RidBit to equal the input bit (Cin\u2013out tie) at that node under role=PORT. The vector (RidBit[1..B]) encodes u.\n  3) RUN_L: a fixed-width corridor (constant tracks) that hosts a row-by-row 1D tableau for U; unused in the probe; used later by the seam gadget.\n- Reserved boundary-output family: Define B distinct boundary-output 4-tuples {Q_j : j\u2208[B]}. Implementationally, allocate four disjoint reserved symbol families in \u03a3_out: for the four boundary nodes of L(u), allow only the 4-tuple (ProbeL1(j), ProbeL2(j), ProbeR2(j), ProbeR1(j)) when \u201cprobing j\u201d. The set {Probe\u2022(j)} across all j uses O(B) distinct symbols, feasible as \u03b2 \u2265 B and we have ample slack for other tracks.\n- Pointer and acceptance (radius-1): Under boundary inputs fixed to a\u22c6 (choose any constant 4-tuple; e.g., all zeros) and boundary outputs Q_j, Cout\u2013out enforces a deterministic, unique continuation into a \u201cprobe mode\u201d: a finite-state pointer head propagates rightward from the left boundary through PORT, matching successive Addr values and halting exactly when Addr=j. The only legal continuation at that cell is to accept iff RidBit=1; if RidBit=0 then the probe path dead-ends (no completion). No alternative transitions (e.g., error-chain) are permitted while \u201cprobe mode\u201d is active (see probe discipline below). Outside reserved probes, normal error-chains exist so malformed interiors never constrain f.\n- Probe discipline (no error-escape): Cout\u2013out tags each transition in a binary \u201cmode\u201d track. When Q_j is present, the mode is forced to PROBE in a bounded prefix of W_L(u) and error symbols are disallowed in PROBE mode; the only legal edges follow the deterministic pointer/run described above. If any local check fails (role/phase, Addr monotonicity, reaching j, or RidBit), no outgoing pair is allowed \u21d2 the DP rejects that boundary 4-tuple.\n- Claim (Type-Separation): For any u\u2208{0,1}^B and any j\u2208[B], E_{Type(L(u))}(a\u22c6)[Q_j] = 1 iff u_j=1. Hence the B-bit vector (E(a\u22c6)[Q_j])_{j=1..B} equals u. In particular, u\u2260u\u2032 \u21d2 Type(L(u))\u2260Type(L(u\u2032)).\n  Why: Under Q_j the continuation is unique; extendibility equals the truth of RidBit[j]=1 in the PORT zone. Because E_w(a) is defined with interior inputs fixed (as in output.md), this bit is a property of the concrete L(u) and thus of its type. Since at least one probe outcome differs when u\u2260u\u2032, the types differ. Radius-1 holds (only nearest-neighbor checks); \u03a3_out budget is O(B) for Addr values, O(B) for reserved Q_j symbols, plus O(1) for roles, phases, \u22a5, colors, errors, U\u2019s alphabet \u21d2 \u03b2 = poly(s) suffices.\n\nLemma RG (Role gating and must-color for canonical contexts)\n- Gating: Two special role markers are allowed at S\u2019s two nodes: Color and \u22a5. Cout\u2013out permits Color tokens {RED, GRN, BLU} at S iff and only if the adjacent interior begins with a well-formed canonical vertex header: HEAD_C followed immediately by the PORT zone (left side for L(\u00b7), right side for R(\u00b7)). Otherwise (inactive contexts), Color at S has no legal continuation (dead); \u22a5 at S always has a legal continuation via neutral plumbing (a self-looping \u22a5 language as in the upper bound DP).\n- Must-color on active pairs: On a bridge instance between an active left L(u) and an active right R(v) (see next lemma), the seam accepts only if both S nodes carry Color (non-\u22a5). Thus any feasible f must assign a color to each canonical vertex type; assigning \u22a5 would falsify (F1) on its pairings with some active opposite.\n- Consequence: f is only free to color canonical types; any attempt to color an inactive type causes (F1) to fail on some pair (inactive, anything) because Color-at-S would be unextendible on the inactive side. Therefore f must map all inactive types to \u22a5.\n\nLemma SG (Seam tableau for succinct adjacency and inequality)\n- Canonical right vertex block R(v): symmetric to L(u), with its PORT zone immediately to the left of S; it exposes Addr and RidBit tracks encoding v.\n- Seam layout: In the bridge wb\u2218wc between L(u)\u2019s right side and R(v)\u2019s left side, Cout\u2013out allocates a fixed-width corridor RUN_B that hosts a row-by-row simulation of a universal TM U on input (enc(C), u, v). The input (enc(C)) is present in both HEAD_C zones, and u,v are read from the PORT zones (local wiring at the near seam). Each row transition is enforced by nearest-neighbor Cout\u2013out constraints; malformed rows cannot continue (no error-escape inside RUN_B). The final row writes EDGE \u2208 {0,1} at a fixed seam-local cell.\n- Acceptance policy at S (radius-1): Local rules enforce: (i) if EDGE=0, accept regardless of colors at S; (ii) if EDGE=1, accept iff the two S colors differ; (iii) on an active-active pair, \u22a5 is not permitted (must-color). All checks refer only to the two S outputs and the nearby EDGE bit.\n- Robustness: If either side is inactive or malformed (HEAD_C absent, corrupted PORT), the only allowed S symbol is \u22a5 and a neutral \u22a5-plumbing fills both sides, ensuring these contexts never constrain f (consistent with Lemma RG).\n- Correctness: On active-active pairs, the tableau computes D(u,v) in poly(s) time and exposes EDGE correctly; the final local check enforces exactly the 3-coloring constraint \u201ccolors must differ on edges and arbitrary on non-edges\u201d.\n\nCanonicality and existence of active types\n- Canonical shapes: Define L(u)=W_L(u) S F_R and R(v)=F_L S W_R(v) with W_L, W_R as above and fixed fillers F_L, F_R (PAD-roles). Cout\u2013out recognizes only these shapes as vertex roles (for gating). Any other context is inactive (no Color at S).\n- Existence via pumping/replacement: HEAD_C+PORT+RUN zones have length poly(s) \u226a \u2113_pump = 2^{\u0398(\u03b2^4)}. By Lemma 11 (replacement) and Lemmas 14\u201315 (pumping), we can place W_L(u) adjacent to S inside words of length \u2113_pump or \u2113_pump+1 on the designated side, preserving the type of W_L(u); ditto for W_R(v). Thus the context set C contains, for each u (resp. v), at least one canonical left (resp. right) type, and Lemma TS gives at least 2^B distinct left-types and 2^B distinct right-types.\n\nSoundness/completeness of the reduction (sketch tightened)\n- Completeness (\u21d2): Given a proper 3-coloring \u03c7: {0,1}^B \u2192 {RED,GRN,BLU} of the succinct graph defined by C, define f on canonical types by f(Type(L(u)))=\u03c7(u) and f(Type(R(v)))=\u03c7(v); set f(\u03c4)=\u22a5 on all inactive types. By Lemma SG, every active-active (F1) pair accepts iff \u03c7(u)\u2260\u03c7(v) when D(u,v)=1 and always if D(u,v)=0. All other pairings accept via \u22a5-plumbing. Hence (F1) holds.\n- Soundness (\u21d0): If some f satisfies (F1), Lemma RG forces f to assign colors to canonical vertex types and \u22a5 to all inactive types. Read \u03c7(u):= f(Type(L(u))). For any edge (u,v) with D(u,v)=1, the seam between Type(L(u)) and Type(R(v)) must be extendible; by Lemma SG this implies \u03c7(u)\u2260\u03c7(v). Non-edges impose no restriction. Thus \u03c7 is a proper 3-coloring.\n\nNeutralizing (F2)\n- Add a global \u22a5-filler language: For any repetition w_1^z and w_2^z (z\u22651), Cout\u2013out admits labeling all repeated sides with \u22a5 regardless of boundary outputs, without touching S or the vertex-role gating. Then (F2) holds for any f, reducing the three-way classifier to deciding (F1)-feasibility on our instances (NEXPTIME-hard).\n\nAlphabet/size and radius bookkeeping\n- \u03a3_out tracks (all merged into symbols): roles/phases O(1); colors+\u22a5 (4); error alphabet O(1); U\u2019s row alphabet O(1); Addr values {1,\u2026,B} (O(B)); reserved probe symbols for Q_j (O(B)); a few pointer states O(1). Total |\u03a3_out| = \u03b2 = poly(s). All constraints are radius-1 (depend on current and predecessor outputs only).\n\nSanity example (B=2)\n- Reserve Q_1, Q_2 for the left boundary. L(00), L(01), L(10), L(11) yield extendibility vectors (E(a\u22c6)[Q_1], E(a\u22c6)[Q_2]) equal to (0,0), (1,0), (0,1), (1,1) respectively. On the seam, with C encoding a 4-cycle, the tableau sets EDGE=1 exactly on adjacency pairs; the local check enforces color inequality on those.\n\nObstacles and how addressed (verifier feedback alignment)\n- \u201cSingle fixed probe\u201d issue: we use a family {Q_j} indexed by boundary outputs; acceptance depends on interior u via the deterministic pointer (no dependence on a globally fixed j). Addresses or O(B)-many probe symbols ensure radius-1 feasibility without exponential symbol blowup.\n- Consistency on same u: avoided by canonical gating. Only L(u), R(v) allow colors; mapping any other type to a color breaks (F1). Thus each u is represented by exactly one colorable type per side.\n- Error-escape under probes: disallowed by a probe-mode bit; in probe mode, error-chain symbols are not permitted in Cout\u2013out\u2019s allowed neighbor pairs.\n\nNext steps (concrete, verifiable)\n1) Write explicit local rule snippets for the probe gadget:\n   - The four reserved boundary symbols and their immediate successors in \u201cprobe mode\u201d.\n   - PORT zone neighbor pairs enforcing Addr increment and RidBit copy.\n   - Pointer transitions and the accept/dead-end at Addr=j with RidBit test.\n   Provide a small B=2 instance and brute-force the DP to observe E(a\u22c6)[Q_j] = u_j.\n2) Formalize Lemma RG: list Cout\u2013out pairs that allow Color at S only next to HEAD_C+PORT; add dead-end rules otherwise; add the \u22a5 self-loop plumbing.\n3) Specify RUN_B alphabet and row transitions for U; define EDGE emission and the local color-inequality check at S. Verify on a toy circuit D by DP.\n4) Package the reduction D \u21a6 P_D with precise \u03b2 sizing and radius-1 constraints; add the \u22a5-filler rules. Then move Lemmas TS, RG, SG and the reduction theorem into output.md.\n\nWhy useful here\n- The per-bit probe family and probe discipline directly resolve the main gaps flagged by the verifier: we now separate 2^B types without per-type tailoring, and we prevent error-escape in reserved probes. The role-gating and must-color rules ensure f assigns colors only to canonical vertex types, avoiding consistency pitfalls. The seam tableau matches (F1)\u2019s pairwise nature. All components are radius-1 and compatible with the O(k\u03b2^2) DP for audit.\n"}, {"prover_id": "04", "progress_md": "Status and focus\n- Objective: firm up the NEXPTIME-hardness reduction by fully specifying two auditable gadgets: (i) a per-bit boundary probe that separates 2^B vertex indices into distinct context types; (ii) a seam gadget that simulates D(u,v) across the bridge and enforces color-inequality iff D(u,v)=1. Also enforce \u201ccolor gating\u201d so only canonical vertex contexts may carry colors, making all non-canonical types inactive and mapped to \u22a5.\n- This round delivers precise lemmas with radius-1 local behavior, alphabet budgeting, and proof sketches that can be checked by the O(k \u03b2^2) DP on toy instances (e.g., B=2).\n\nGaps in output.md (minor clarifications)\n- Types vs. fixed inputs: output.md\u2019s Definitions allow \u201cinterior inputs may be arbitrary.\u201d Our reductions assume the interior inputs are fixed to the instance string; E_w(a) is computed w.r.t. that fixed string. Suggest adding a parenthetical: \u201cif the model fixes interior inputs, E_w(a) is computed with respect to those fixed inputs,\u201d to avoid ambiguity when we later rely on interior-encoded indices.\n- Context set C: it is useful to note explicitly that C consists of types realized by words of the form w_1 S w_2 with |w_i| \u2208 {\u2113_pump, \u2113_pump+1}. This plays a role in gating colors and in counting how many \u201cactive\u201d types we can realize.\n\nLemma TS (Type Separation via per-bit boundary probes)\n- Parameters: B = s^{c0}, \u03b2 = s^{c1} with c1 \u2265 c0 so \u03b2 \u2265 B. Fix one boundary-input pattern a\u22c6 \u2208 \u03a3_in^4.\n- Port zone layout (left contexts): In every canonical left vertex block W_L(u), immediately to the right of S there is a port zone of length B with two read-only subtracks: Addr \u2208 {1,\u2026,B} (hardwired per position) and RID \u2208 {0,1} (copied from input via Cin\u2013out). Outside the port zone and a short header, the block is neutral PAD/error-plumbed.\n- Reserved boundary outputs: For each j \u2208 [B], define a distinct reserved 4-tuple Q_j of boundary outputs (the four symbols on the two leftmost and two rightmost boundary nodes of w_1). Under Q_j, Cout\u2013out allows only a deterministic \u201cprobe-j\u201d pipeline that flows from the left boundary across w_1, enters the port zone, and stops at the unique cell where Addr=j. This pipeline is implemented by a pointer head state P_j carried on a dedicated track; adjacency rules enforce P_j \u2192 P_j deterministically, moving one step per edge. At the target cell, the only legal successor enforces RID=1 at that cell; if RID=0, the pipeline has no legal continuation (dead end). Upon RID=1, the pipeline transitions to a local ACCEPT sink that splices into a neutral filler for the remaining interior, enabling completion.\n- No error escape under probes: Under boundary outputs Q_j the error-chain alphabet is disabled (no error transition is permitted from P_j states). For all non-reserved boundary outputs, standard error-chains and PAD are enabled.\n- Claim (formal). For any canonical left vertex word L(u) and fixed boundary inputs a\u22c6, E_{L(u)}(a\u22c6)[Q_j] = 1 if and only if u_j = 1. Moreover, for j \u2260 j\u2032, Q_j \u2260 Q_{j\u2032}, and under any other 4-tuple, E behaves as generic PAD/error-plumbing.\n- Why type separation holds: Let Sig(u) \u2208 {0,1}^B be (E_{L(u)}(a\u22c6)[Q_j])_{j=1..B}. Then Sig(u)=u, so u\u2260u\u2032 \u21d2 Sig(u)\u2260Sig(u\u2032). Hence Type(L(u))\u2260Type(L(u\u2032)). This uses only global Cin\u2013out/Cout\u2013out and is radius-1.\n- Alphabet budget: the pointer heads P_j and reserved Q_j consume O(B) symbols; permitted since \u03b2 \u2265 B and \u03a3_out size is \u03b2 = poly(s). The rest of the tracks (roles/phases, PAD, error, etc.) are O(1).\n- Why useful: Gives \u2265 2^B distinct left-context types \u03c4^L_u. A symmetric construction gives \u2265 2^B right-context types \u03c4^R_v.\n\nLemma CG (Color gating for canonical vertex contexts)\n- Statement. There is a role/phase track and Cin\u2013out/Cout\u2013out rules such that: the two S nodes may carry non-\u22a5 colors {RED,GRN,BLU} if and only if the adjacent side is a well-formed canonical vertex block (W_L(u) on the left of S, W_R(v) on the right of S). In all other contexts, any non-\u22a5 symbol at S has no legal continuation (dead end), whereas \u22a5 at S always admits a completion via PAD/error plumbing.\n- Implementation at radius 1: Gate the color tokens by an \u201cACT\u201d flag emitted by a short handshake subtrack that is present only when the port-and-header structure near S is well-formed. Cin\u2013out forbids colors unless ACT=true. Cout\u2013out disables the error alphabet on transitions emanating from colored S unless ACT=true, so colors on inactive types cannot be extended.\n- Why useful: Ensures f can assign colors only to \u03c4^L_u and \u03c4^R_v; all other types must be mapped to \u22a5 to satisfy (F1).\n\nLemma Seam (Seam gadget for succinct adjacency and inequality)\n- Statement. There is a fixed radius-1 seam gadget such that for any ordered pair (\u03c4^L_u, \u03c4^R_v): the bridge segment wb\u2218wc between S_1 and S_2 hosts a 1D tableau of a universal TM U that, in poly(s) steps, reads the B-bit ports u and v and computes d := D(u,v). A final verdict bit EDGE=d is exposed near S_2 together with a forwarded copy of Color(S_1). Local rules at S_2 enforce: if EDGE=0, accept regardless of colors; if EDGE=1, accept iff Color(S_2) \u2260 ForwardedColor(S_1). All checks are nearest-neighbor.\n- I/O wiring details:\n  - Inputs to U: The header encodes C; adjacent to S_1 (resp. S_2) the port zone exposes u (resp. v). A seam handshake opens a corridor across wb\u2218wc for the tableau. Each tableau row is a constant-width word; Cout\u2013out enforces per-row transitions of U.\n  - Verdict wiring: The last row writes EDGE\u2208{0,1} and copies Color(S_1) into a \u201cforwarded color\u201d register next to S_2. Cout\u2013out contains pairs that check (EDGE=1) \u21d2 neighbor-to-S_2 carries a color different from S_2; if equal, no legal transition. If EDGE=0, both equal and unequal are allowed.\n- Robustness:\n  - Malformed runs or headers: standard error-chain refutations are allowed when ACT=false or when S is \u22a5; these make such contexts inactive. Under ACT=true with colors at S, malformed rows have no accepting continuation (no error escape), so (F1) cannot be satisfied by cheating.\n- Why useful: Aligns (F1)\u2019s universal pair constraint with 3-coloring: feasibility of f is equivalent to the existence of a proper 3-coloring \u03c7 with \u03c7(u)\u2260\u03c7(v) whenever D(u,v)=1.\n\nSoundness/completeness of the S3Col \u2192 FFE(F1) reduction (recap with the new lemmas)\n- Active types: For each u, pick canonical L(u) and R(u) shapes; by Lemma TS they yield distinct types \u03c4^L_u and \u03c4^R_u. By Lemma CG, only these may carry colors.\n- Completeness: Given a proper 3-coloring \u03c7, set f(\u03c4^L_u)=\u03c7(u), f(\u03c4^R_v)=\u03c7(v), and f(\u03c4)=\u22a5 for all other \u03c4. For any pair (\u03c4_left, \u03c4_right), if both are active, Lemma Seam computes d=D(u,v) and enforces inequality iff d=1; satisfied by \u03c7. If one or both are inactive, \u22a5-plumbing admits completion. Hence (F1) holds.\n- Soundness: If f satisfies (F1), read \u03c7(u):=f(\u03c4^L_u). For any edge (u,v) (i.e., D(u,v)=1), Lemma Seam forces f(\u03c4^L_u)\u2260f(\u03c4^R_v), so \u03c7 is a proper 3-coloring. Inactive types cannot be colored by f (or some pair would violate Lemma CG\u2019s gating), hence f(\u03c4)=\u22a5 there.\n\nNeutralizing (F2)\n- Add global \u22a5-filler: allow wz to be labeled entirely \u22a5 for all z \u2265 1, consistent with any boundary assignments and regardless of interior; S remains untouched; ACT gating remains enforced. Then (F2) holds trivially for any f, reducing the tri-class decision to (F1)-feasibility on our family.\n\nAlphabet and radius-1 bookkeeping (explicit)\n- \u03a3_out tracks (constant unless noted): roles/phases O(1), colors {RED,GRN,BLU,\u22a5} (4), error alphabet O(1), U\u2019s work alphabet O(1), PAD O(1). Additional O(B) symbols for {Q_j} and {P_j} suffice for Lemma TS. Choose \u03b2 \u2265 c\u00b7B for a suitable constant c, which holds for c1 \u2265 c0 in \u03b2 = s^{c1}, B = s^{c0}.\n- All constraints are radius-1: probes and pointer moves are enforced by nearest-neighbor pairs; tableau rows by local step relations; color inequality is a single adjacency near S_2.\n\nSanity check plan (B=2)\n- Build a toy instance with \u03b2\u22658, reserve Q_1,Q_2 and P_1,P_2, port zone of length 2 adjacent to S. Verify by brute DP: E_{L(00)}(a\u22c6)[Q_1,Q_2]=(0,0), E_{L(01)}=(0,1), E_{L(10)}=(1,0), E_{L(11)}=(1,1). Instantiate a tiny D (e.g., a 4-cycle) and check the bridge DP accepts iff colors differ on edges.\n\nWhy this is progress\n- We have replaced informal sketches with concrete, radius-1 gadgets and clean lemmas (TS, CG, Seam) that are directly checkable via the DP. The per-bit probe avoids the flawed \u201csingle probe\u201d idea and uses only O(B) extra symbols, admissible within \u03b2=poly(s). Color gating resolves the earlier consistency issue on multiple types per u. The seam gadget specifies exactly how to locally enforce inequality conditioned on D(u,v).\n\nNext steps (auditable deliverables)\n1) Write the small adjacency tables for the probe pipeline: list states {PROBE_L, P_j, ACCEPT, PAD} and allowed successors, and the Cin\u2013out masks that gate colors by ACT. Provide a concrete symbol count to confirm \u03b2 \u2265 B+O(1) suffices.\n2) Specify the tableau alphabet for U and the local transition rules that output EDGE and forward Color(S_1); include the exact pair checks near S_2 used to enforce inequality.\n3) Produce a B=2 machine-readable instance (inputs and tables) and have the verifier\u2019s O(k\u03b2^2) DP validate: (i) separation under Q_1,Q_2; (ii) seam acceptance iff inequality on edges.\n4) Integrate a short note into output.md clarifying fixed interior inputs in E_w(a), and (optionally) the explicit definition of C to avoid ambiguity when we later reference \u201cinactive\u201d types.\n"}]

Current notes.md:
Working model and notation (radius 1, Î²-normalized)
- We study LCLs on globally oriented paths with fixed input alphabet Î£_in and output alphabet Î£_out of size Î². The local legality is given by two global relations: Cinâ€“out relating each input symbol to allowed output symbols at a node, and Coutâ€“out relating allowed pairs of consecutive output symbols. The radius is 1.
- A path segment w has four boundary nodes (two on the left, two on the right). For a fixed assignment to the four boundary inputs, we define the extendibility bitvector over all Î²^4 assignments to the four boundary outputs indicating for which boundary-output assignments there exists a legal extension to the interior.
- The type Type(w) is the collection, over all 4-boundary input assignments, of these extendibility bitvectors. Two words share a type if they have identical extendibility behavior for all boundary input/output assignments. Let T be the finite set of all types realizable by some word.

Verified technical facts (recorded in output.md)
- Type bound: |T| â‰¤ |Î£_in|^4 Â· 2^{Î²^4}. Reason: a type is determined by four boundary input symbols and a Boolean function on the Î²^4 boundary output assignments.
- Composition lemma: There is a computable binary operation âŠ› on T such that Type(uv) = Type(u) âŠ› Type(v) for all words u, v. Intuition: to decide extendibility of uv under a boundary-output assignment, one needs only (i) the extendibility tables of u and v, and (ii) existentially quantify over the two internal boundary outputs to satisfy Coutâ€“out at the join.
- Periodicity: For any fixed word w, the sequence Ï„_z := Type(w^z) is ultimately periodic with preperiod and period â‰¤ |T|. Thus the pair sequence (Type(w1^z), Type(w2^z)) is ultimately periodic with preperiod â‰¤ 2|T| and period â‰¤ |T|.
- Finite-Z for (F2): Given any context (w1, S, w2), whether the (F2) check passes for all z â‰¥ 1 depends only on finitely many pairs (Type(w1^z), Type(w2^z)); it suffices to check z up to Z â‰¤ |T|^2 (a non-tight but simple bound).
- DP for extension: For a fixed path with some outputs forced (e.g., on S), the existence of a global completion can be decided in O(k Î²^2) time for a length-k path by a layered dynamic program over output symbols.

Hardness direction we will pursue (pivot suggested by Prover 01)
- Source problem: Succinct 3-Coloring of a graph G on V={0,1}^B, given by a circuit D(u,v) (size s) deciding adjacency; NEXP-complete.
- Target LCL: Construct a Î²-normalized, r=1 instance P_D with Î£_out size Î² = poly(s). The plan:
  1) For each u, build at least one context type Ï„_u whose boundary behavior (detected via a reserved boundary-probe) certifies that the interior encodes the index u in a standard, radius-1-checkable block. The interior also stores a copy of D on an input track and a runzone for a fixed TM U.
  2) In a bridge between Ï„_u and Ï„_v, locally simulate U on input (D,u,v) across the seam for poly(s) steps to evaluate D(u,v); malformed simulations are locally refutable.
  3) Gate constraints: if D(u,v)=0 (non-edge) allow completion regardless of colors; if D(u,v)=1 enforce color inequality across S. All other pairings (not recognized as vertexâ€“vertex) are trivial.
  4) Assigning a color to each Ï„_u by a feasible function f is then exactly a proper 3-coloring of G.
  5) Make (F2) vacuous by allowing repeated sides to be filled with a globally available âŠ¥-plumbing language.

Open technical items for hardness (to be formalized next)
- Boundary-probe/type-separation lemma: Exhibit a fixed boundary-output probe that, when used, triggers an interior index-check subroutine; show that for distinct indices u â‰  uâ€², the probeâ€™s extendibility bit differs, hence Ï„_u â‰  Ï„_{uâ€²}.
- Seam handshake and computation: Specify the constant-size interface by which the bridge accesses (via pointers) the interior encodings of u and v and runs the 1D tableau for U for poly(s) steps, with radius-1 local checks and robust error refutations.
- Alphabet/size bookkeeping: Keep Î£_out constant tracks (roles, colors, error, Uâ€™s work alphabet) constant, with Î² = poly(s) sufficient for all auxiliary symbols.
- Soundness/completeness proof for the reduction P_D: G is 3-colorable iff a feasible f exists for P_D (with (F2) neutralized).

Caveats and corrections logged
- Short seam codes cannot distinguish exponentially many indices; instead use constant-size pointers/handshakes plus interior blocks that store and validate indices.
- Do not attempt to â€œprogram arbitrary boundary truth tables per typeâ€ via Coutâ€“out; all rules are global. Use boundary probes plus uniform interior checks to separate types.
- For 3SAT-based reductions, the (F1) universal quantifier clashes with clause-level existential quantification unless one adds complex nondeterministic gating. The succinct 3-coloring pivot avoids this.
Refined hardness plan via Succinct 3-Coloring: type separation and seam simulation (radius 1)

Parameters and normalization
- Given a succinct graph instance D of size s over V={0,1}^B with B=s^{c0}, choose Î²=s^{c1} with c1â‰¥c0 so Î²â‰¥B and the output alphabet Î£_out has size Î². The LCL instance P_D has radius 1 and is Î²-normalized (Cinâ€“out global, Coutâ€“out nearest-neighbor global). The DP and type framework from output.md applies with |T|â‰¤|Î£_in|^4Â·2^{Î²^4}.

Canonical vertex contexts and activity gating
- We will construct canonical context shapes L(u)=W_L(u) S F_R and R(v)=F_L S W_R(v) for each u,vâˆˆ{0,1}^B such that:
  1) W_L(u) (resp. W_R(v)) is a well-formed vertex block anchored O(1) from S; it exposes a port zone of length Î˜(B) immediately adjacent to S holding the index bits.
  2) Only these canonical contexts permit color tokens at S (role gating). Any context that is not a canonical vertex context is inactive: any non-âŠ¥ token at S dead-ends locally; âŠ¥ at S always extends via neutral plumbing.
  3) For each u (resp. v) the type Type(L(u)) (resp. Type(R(v))) depends only on u (resp. v) via a boundary-probe mechanism detailed below. Thus we obtain at least 2^B distinct left-types and 2^B distinct right-types.

Type separation via a family of boundary probes (two workable options)
- Option A (per-bit probes Q_j with address field): Reserve B distinct boundary-output 4-tuples {Q_j : jâˆˆ[B]}. In the port zone, include an address track Addrâˆˆ[B] and a data track RIDâˆˆ{0,1}. Local rules enforce that under boundary outputs Q_j the only legal continuation is a deterministic pointer that walks from the boundary to the unique port cell with Addr=j and then accepts iff RID=1 at that cell; otherwise no continuation exists. For all non-reserved boundary outputs we allow generic âŠ¥-plumbing so they do not affect separation. Fix a boundary-input pattern aâ‹†. Then for each u we have E_{L(u)}(aâ‹†)[Q_j]=u_j. Consequently, uâ‰ uâ€² implies Type(L(u))â‰ Type(L(uâ€²)). This uses O(B) extra symbols (addresses/pointer states) and remains within Î²=poly(s).
- Option B (mask/parity probes with Mâ‰¥B tests): Reserve M boundary-output 4-tuples {b_t : tâˆˆ[M]} with Mâ‰¥B. Store in the input of W_L(u) a table of M masks M_tâˆˆ{0,1}^B (with the BÃ—M matrix of full rank over GF(2)) and the RID block u. Under boundary outputs b_t, a deterministic pointer reads M_t and then the RID block and accumulates the inner product âŸ¨M_t,uâŸ© mod 2 using a small â€œRUNâ€ zone (row-by-row locally checked). Accept iff the parity is 1. Define Sig(u)=(âŸ¨M_t,uâŸ©)_tâˆˆ{0,1}^M; Sig is injective because Mâ‰¥B and the masks are independent. Fixing a boundary-input aâ‹†, E_{L(u)}(aâ‹†)[b_t]=Sig(u)_t, so types differ for distinct u. Again, the probe behavior is radius-1 and Î²=poly(s) suffices.
- In both options, under reserved probes the control is deterministic (no error-chain escape). Outside reserved probes, error-chains and âŠ¥-plumbing ensure malformed interiors do not constrain f.

Seam gadget for succinct adjacency and color inequality
- In an (F1) instance on L(u) seam R(v), the bridge wbâˆ˜wc hosts a row-by-row simulation of a fixed TM U that evaluates D(u,v) in poly(s) steps:
  1) The port zones adjacent to S on each side expose the B-bit strings u and v. A small handshake track opens a corridor through wbâˆ˜wc where Uâ€™s tableau is laid out.
  2) Coutâ€“out enforces nearest-neighbor consistency between successive rows; malformed rows are locally refutable (no accepting continuation). The run emits a verdict bit EDGEâˆˆ{0,1} at a fixed place near S.
  3) Local acceptance: If EDGE=0 (non-edge), admit completion irrespective of colors at S; if EDGE=1 (edge), admit completion iff the two color tokens at the two S nodes differ. These are radius-1 checks.
- If either side is inactive (not a canonical vertex context), a âŠ¥-plumbing language allows completion irrespective of the other side and the colors; however, the role gating forbids colors at S for inactive types, so mapping inactive types to a color would violate (F1) on some pair.

Neutralizing (F2)
- Add a global âŠ¥-filler that, for any context (w_1,S,w_2) and any zâ‰¥1, allows filling w_1^z and w_2^z entirely with âŠ¥ symbols, consistent with any boundary outputs and inputs, without altering the two S positions or the vertex-role gating. Then (F2) holds for every f, reducing the 3-way classification on this family to (F1)-feasibility.

Why this matches our DP/type framework
- Types are defined with respect to fixed inputs; the reserved-probe acceptance depends only on the interior index u and the chosen boundary 4-tuple, so it is type-invariant. The DP in O(kÎ²^2) can verify both probe behavior and seam runs on small test instances (e.g., B=2), giving a concrete auditable path.

Key cautions to enforce in the local rules
- Reserved probes must have a unique legal continuation (deterministic pointer/run); no error-chain may provide an alternative accepting path.
- Color tokens at S must be gated by the vertex role; inactive contexts cannot place colors, ensuring f is only free on canonical vertex types and âŠ¥ elsewhere.
- The seam gadget must accept for non-edges regardless of colors and enforce inequality for edges; malformed simulations must not accept.

Minimal sanity check (B=2)
- Use Option A with Q_1,Q_2 and an Addr track {1,2} in the port zone. For uâˆˆ{00,01,10,11}, the vector (E_{L(u)}(aâ‹†)[Q_1], E_{L(u)}(aâ‹†)[Q_2]) equals u. The seam gadget with a small circuit D (e.g., a 4-cycle) enforces inequality exactly on edges, which can be brute-forced by the DP.


Current output.md (if any):
Results validated for radius-1, Î²-normalized LCLs on oriented paths

Why these results matter
- The decision procedures for feasible-function existence (and hence the O(1)/Î˜(log* n)/Î˜(n) classification on paths) rely on two ingredients: (i) that path segments admit a finite set of â€œtypesâ€ which compose under concatenation, and (ii) that extendibility of partially labeled paths can be checked efficiently. The theorems below formalize these facts for radius 1 and yield a finite bound for the bridging (F2) checks.

Definitions (radius 1)
- Fix finite alphabets Î£_in and Î£_out (|Î£_out| = Î²). Cinâ€“out âŠ† Î£_in Ã— Î£_out specifies allowed output symbols at a node given its input symbol. Coutâ€“out âŠ† Î£_out Ã— Î£_out specifies allowed pairs of consecutive output symbols along the oriented path. A labeling of outputs y_1â€¦y_k over an input x_1â€¦x_k is legal if (x_i, y_i) âˆˆ Cinâ€“out for all i and (y_i, y_{i+1}) âˆˆ Coutâ€“out for all i.
- For a word w of length k â‰¥ 2, let the four boundary positions be i=1,2 and i=k-1,k. For a fixed assignment a âˆˆ Î£_in^4 to the boundary inputs (x_1, x_2, x_{k-1}, x_k), define E_w(a) âŠ† Î£_out^4 to be the set of boundary-output assignments b = (y_1, y_2, y_{k-1}, y_k) for which there exists a legal output labeling y_1â€¦y_k extending b, given the boundary inputs a (interior inputs may be arbitrary in Î£_in; if the model fixes interior inputs, the definition is with respect to those fixed inputs). The type of w, Type(w), is the map a â†¦ E_w(a). Let T be the set of all types realized by some w.

Theorem 1 (Finite number of types and an explicit bound)
Let m := |Î£_in|. For radius 1 we have |T| â‰¤ m^4 Â· 2^{Î²^4}.
Proof. For each fixed boundary-input assignment a there are exactly Î²^4 possible boundary-output assignments; E_w(a) is an arbitrary subset of these, hence at most 2^{Î²^4} possibilities. There are m^4 possible aâ€™s. The type is fully determined by the tuple (a, E_w(a))_{aâˆˆÎ£_in^4}. Thus the total number of distinct types is at most m^4 Â· 2^{Î²^4}.

Lemma 2 (Composition of types under concatenation)
There is a computable binary operation âŠ›: T Ã— T â†’ T such that for all words u, v we have Type(uv) = Type(u) âŠ› Type(v).
Proof. Fix boundary inputs a on uv, i.e., inputs on positions 1,2 and at the last two positions of uv. For each boundary-outputs choice b on uv, extendibility is equivalent to the existence of output symbols p,q âˆˆ Î£_out at the shared boundary between u and v (the last two outputs of u = first two of v) such that:
- (i) (Type(u) under its corresponding boundary inputs) accepts the boundary outputs given by the left two outputs of b together with p,q; and
- (ii) (Type(v) under its corresponding boundary inputs) accepts p,q together with the right two outputs of b; and
- (iii) the two internal adjacencies across the u|v seam are allowed by Coutâ€“out (these involve only (y_{|u|-1}, y_{|u|}) = (p_left, p_right) and (p_left, p_right) = (y_1, y_2) of v, but these are exactly the p,q we quantify over).
Because radius is 1, no other interior constraints couple u and v. Thus extendibility of uv under (a,b) can be decided solely from Type(u), Type(v), and Coutâ€“out by existentially quantifying p,q. Defining âŠ› to implement this decision for all (a,b) yields Type(uv) = Type(u) âŠ› Type(v).

Lemma 3 (Ultimate periodicity of repeated concatenation)
Fix w and let Ï„ := Type(w). Define the sequence Ïƒ_1, Ïƒ_2, â€¦ in T by Ïƒ_z := Type(w^z). Then Ïƒ_{z+1} = Ïƒ_z âŠ› Ï„ for all z â‰¥ 1. Consequently, the sequence (Ïƒ_z) is ultimately periodic with preperiod and period at most |T|.
Proof. By Lemma 2, Ïƒ_{z+1} = Type(w^{z+1}) = Type(w^z w) = Type(w^z) âŠ› Type(w) = Ïƒ_z âŠ› Ï„. Since T is finite, the sequence must revisit a previous value within at most |T| steps, after which it evolves deterministically with fixed period â‰¤ |T|.

Corollary 4 (Finite bound for the bridging (F2) check)
Let â„“ := |T|. Fix a context (w_1, S, w_2) with |S| = 2 and a forced output assignment s âˆˆ Î£_out^2 on S. For each z â‰¥ 1, consider the path w_1^z S w_2^z with S fixed to s, and let P(z) be the predicate â€œthere exists a legal completion of outputs on w_1^z and w_2^z consistent with s.â€ Then P(z) depends only on the pair (Type(w_1^z), Type(w_2^z)). Moreover, it suffices to check P(z) for 1 â‰¤ z â‰¤ Z with Z â‰¤ â„“^2; if all these hold then P(z) holds for all z â‰¥ 1.
Proof. For fixed s, feasibility is determined by whether there exist outputs on the two boundary nodes adjacent to S on each side such that the two segments extend and Coutâ€“out holds across the two adjacencies touching S; this depends only on Type(w_1^z) and Type(w_2^z). By Lemma 3, each of the two type sequences is ultimately periodic with preperiod and period â‰¤ â„“. Hence the pair sequence (Type(w_1^z), Type(w_2^z)) takes values in a set of size â‰¤ â„“^2 and is ultimately periodic. If P(z) holds for one full traversal of the distinct pairs (which occurs within the first â„“^2 indices), it holds for all subsequent z.

Theorem 5 (DP for extension on a partially labeled path)
Given a path of length k with a fixed input string and some outputs preassigned on a subset of nodes, there is an O(k Î²^2) time algorithm that decides whether the outputs can be completed to a legal labeling.
Proof. Construct a layered graph with k layers, each layerâ€™s vertices being the output symbols allowed at that node by Cinâ€“out and any preassignment. Add a directed edge from y at layer i to yâ€² at layer i+1 iff (y, yâ€²) âˆˆ Coutâ€“out. There exists a legal completion iff there is a path from some vertex in layer 1 to some vertex in layer k. The graph has O(k Î²) vertices and O(k Î²^2) edges; reachability is decidable in O(k Î²^2).

Remarks
- The bounds above are not tight (e.g., the â„“^2 bound in Corollary 4 can be improved using lcm of periods), but they suffice for verification in exponential time in Î². They also isolate exactly where only the types matter (composition and periodicity), which is crucial for hardness reductions that aim to make (F2) vacuous and focus on (F1).

