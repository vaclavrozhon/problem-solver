--- SYSTEM ---
You are a research mathematician. 

You are being run in a loop with a verifier that checks rigor. Your goal is to make **incremental, auditable progress**. You are not expected to solve the problem at once, but to generate new, testable ideas.

Inputs: 
- task statement 
- notes.md (summary of past progress; optional) 
- output.md (rigorously proven results curated so far; optional) 
- summary of past rounds (optional) 
- possibly some reference papers.

What counts as progress:
- Extract small lemmas/heuristics from literature and state them cleanly with one-line "why useful here".
- Explore small examples & try to break your own claims with toy counterexamples.
- Prove special cases or nontrivial bounds.
- If an approach fails, explain crisply why.
- Point out flaws in notes.md or output.md (but do not rewrite output.md yourself).

**Discipline.** 
- Read notes, outputs, summaries carefully before proposing new work. 
- Reference papers if relevant, but focus on *incremental, checkable steps*. 
- Do not output Markdown code fences, only raw JSON. 
- Length: at least ~200 words. 
- Organize your reasoning with short headings (Ideas, Examples, Obstacles, Next steps), make clear what your claims are and how they are supported. 
- Remember: the verifier curates notes and outputs, you only suggest.

**Return strictly JSON**:
{
  "progress_md": "Your progress notes for this round in Markdown (KaTeX allowed). Point out any gaps in output.md clearly. Do not modify output.md directly."
}


--- USER ---
Work on this problem context:

=== task.txt ===
﻿Task


\newcommand{\SigIn}{\Sigma_{\mathrm{in}}}
\newcommand{\SigOut}{\Sigma_{\mathrm{out}}}
\newcommand{\Cinout}{C_{\mathrm{in\text{--}out}}}
\newcommand{\Coutout}{C_{\mathrm{out\text{--}out}}}
\newcommand{\Type}{\mathrm{Type}}
\newcommand{\pumpLen}{\ell_{\mathrm{pump}}}


\paragraph{One-line summary.}
Prove NEXPTIME-hardness for the following problem. Given a $\beta$-normalized, radius-1 LCL on globally oriented paths, the problem is to decide whether the local complexity of that problem is $O(1)$ vs.\ $\Omega(\log^* n)$ vs.\ $\Omega(n)$.


\section*{Problem setup}


We work in the standard \textsc{Local} model on globally oriented paths. An LCL is \emph{$\beta$-normalized (radius 1)} if it has:
\begin{itemize}
  \item binary input alphabet $\SigIn=\{0,1\}$,
  \item output alphabet $\SigOut$ of size $\beta$,
  \item legality checked only by two tables: $\Cinout\subseteq\SigIn\times\SigOut$ and $\Coutout\subseteq\SigOut\times\SigOut$.
\end{itemize}
A labeling is legal iff $(\mathrm{in}(v),\mathrm{out}(v))\in \Cinout$ at each node $v$ and $(\mathrm{out}(u),\mathrm{out}(v))\in \Coutout$ on each directed edge $u\!\to\! v$.


\paragraph{Encoding size.}
We assume an explicit encoding of $(\Cinout,\Coutout)$ of size $\mathrm{poly}(\beta)$ (e.g., $\Cinout$ as a $2\times \beta$ Boolean table and $\Coutout$ as a $\beta\times \beta$ Boolean table). We measure time in the input length $N=\mathrm{poly}(\beta)$.


\paragraph{Your task}
Your task is to prove that this task is hard as possible. Aim for NEXPTIME-hardness. 


\paragraph{First attached paper}
The attached paper proves that the problem is PSPACE-hard. Their reduction shows that one can encode the execution of an automaton as a local problem. You have to understand that paper thoroughly, since your goal is to improve upon their result. However, that proof does not easily generalize – it is important that the tape of the simulated automaton has polynomial length, which naively cannot lead to a better than PSPACE hardness. 


\paragraph{Second attached draft}
The attached draft shows the sketch of a proof of a better NEXPTIME algorithm than the one in the original paper. This may give you some intuition about the computational bottleneck that can be used to prove hardness.

=== progress.md ===
...
ependence only on type: The separation relies on fixed boundary-input a⋆ and the reserved family {b_t}. For any two words with the same input content (table + RID) but otherwise different interiors, the existence or non-existence of a completion under (a⋆, b_t) is forced by the local test, hence is type-invariant. Distinct u’s yield distinct yes/no pattern across {b_t}, so types differ.
- Ensuring non-edges are vacuous: The bridge must accept for D(u,v)=0 irrespective of colors. We implement this by enabling a finishing acceptor after the U-run concludes “0”, independent of S’s colors.

Minor clarifications/suggestions for output.md
- Types and fixed inputs: In “Definitions (radius 1)”, clarify that E_w(a) is with respect to the fixed input string on the entire path; the parenthetical “interior inputs may be arbitrary” could be read as allowing the verifier to choose internal inputs. For our model, the input word is fixed; the extension existentially quantifies outputs only.
- Context set C size: Where LCL_classification.pdf states “Note |C| ≤ ℓ_pump,” consider adding a short justification: a context type is a specific element of the global type set T realized by a word of the form w_1 S w_2 with |w_i| ∈ {ℓ_pump,ℓ_pump+1}; hence |C| ≤ |T| = ℓ_pump.

Next steps
- Write the explicit local rule set for the boundary test gadget and prove the Type-Separation Lemma rigorously (injectivity from M≥B linearly independent masks).
- Specify the seam U-simulation interface and the local rule that gates acceptance by “D(u,v)=0 or colors differ.”
- Package the reduction formally: map D ↦ P_D with β=poly(s), prove “G 3-colorable ⇔ (F1)-feasible f exists”, and add the ⊥ repetition to neutralize (F2). This will give a clean NEXPTIME-hardness statement for the 3-way classification.

## Round 0003 — 2025-08-28T11:54:24.396122Z

Status and focus
- Objective: firm up the NEXPTIME-hardness reduction by fully specifying two auditable gadgets: (i) a per-bit boundary probe that separates 2^B vertex indices into distinct context types; (ii) a seam gadget that simulates D(u,v) across the bridge and enforces color-inequality iff D(u,v)=1. Also enforce “color gating” so only canonical vertex contexts may carry colors, making all non-canonical types inactive and mapped to ⊥.
- This round delivers precise lemmas with radius-1 local behavior, alphabet budgeting, and proof sketches that can be checked by the O(k β^2) DP on toy instances (e.g., B=2).

Gaps in output.md (minor clarifications)
- Types vs. fixed inputs: output.md’s Definitions allow “interior inputs may be arbitrary.” Our reductions assume the interior inputs are fixed to the instance string; E_w(a) is computed w.r.t. that fixed string. Suggest adding a parenthetical: “if the model fixes interior inputs, E_w(a) is computed with respect to those fixed inputs,” to avoid ambiguity when we later rely on interior-encoded indices.
- Context set C: it is useful to note explicitly that C consists of types realized by words of the form w_1 S w_2 with |w_i| ∈ {ℓ_pump, ℓ_pump+1}. This plays a role in gating colors and in counting how many “active” types we can realize.

Lemma TS (Type Separation via per-bit boundary probes)
- Parameters: B = s^{c0}, β = s^{c1} with c1 ≥ c0 so β ≥ B. Fix one boundary-input pattern a⋆ ∈ Σ_in^4.
- Port zone layout (left contexts): In every canonical left vertex block W_L(u), immediately to the right of S there is a port zone of length B with two read-only subtracks: Addr ∈ {1,…,B} (hardwired per position) and RID ∈ {0,1} (copied from input via Cin–out). Outside the port zone and a short header, the block is neutral PAD/error-plumbed.
- Reserved boundary outputs: For each j ∈ [B], define a distinct reserved 4-tuple Q_j of boundary outputs (the four symbols on the two leftmost and two rightmost boundary nodes of w_1). Under Q_j, Cout–out allows only a deterministic “probe-j” pipeline that flows from the left boundary across w_1, enters the port zone, and stops at the unique cell where Addr=j. This pipeline is implemented by a pointer head state P_j carried on a dedicated track; adjacency rules enforce P_j → P_j deterministically, moving one step per edge. At the target cell, the only legal successor enforces RID=1 at that cell; if RID=0, the pipeline has no legal continuation (dead end). Upon RID=1, the pipeline transitions to a local ACCEPT sink that splices into a neutral filler for the remaining interior, enabling completion.
- No error escape under probes: Under boundary outputs Q_j the error-chain alphabet is disabled (no error transition is permitted from P_j states). For all non-reserved boundary outputs, standard error-chains and PAD are enabled.
- Claim (formal). For any canonical left vertex word L(u) and fixed boundary inputs a⋆, E_{L(u)}(a⋆)[Q_j] = 1 if and only if u_j = 1. Moreover, for j ≠ j′, Q_j ≠ Q_{j′}, and under any other 4-tuple, E behaves as generic PAD/error-plumbing.
- Why type separation holds: Let Sig(u) ∈ {0,1}^B be (E_{L(u)}(a⋆)[Q_j])_{j=1..B}. Then Sig(u)=u, so u≠u′ ⇒ Sig(u)≠Sig(u′). Hence Type(L(u))≠Type(L(u′)). This uses only global Cin–out/Cout–out and is radius-1.
- Alphabet budget: the pointer heads P_j and reserved Q_j consume O(B) symbols; permitted since β ≥ B and Σ_out size is β = poly(s). The rest of the tracks (roles/phases, PAD, error, etc.) are O(1).
- Why useful: Gives ≥ 2^B distinct left-context types τ^L_u. A symmetric construction gives ≥ 2^B right-context types τ^R_v.

Lemma CG (Color gating for canonical vertex contexts)
- Statement. There is a role/phase track and Cin–out/Cout–out rules such that: the two S nodes may carry non-⊥ colors {RED,GRN,BLU} if and only if the adjacent side is a well-formed canonical vertex block (W_L(u) on the left of S, W_R(v) on the right of S). In all other contexts, any non-⊥ symbol at S has no legal continuation (dead end), whereas ⊥ at S always admits a completion via PAD/error plumbing.
- Implementation at radius 1: Gate the color tokens by an “ACT” flag emitted by a short handshake subtrack that is present only when the port-and-header structure near S is well-formed. Cin–out forbids colors unless ACT=true. Cout–out disables the error alphabet on transitions emanating from colored S unless ACT=true, so colors on inactive types cannot be extended.
- Why useful: Ensures f can assign colors only to τ^L_u and τ^R_v; all other types must be mapped to ⊥ to satisfy (F1).

Lemma Seam (Seam gadget for succinct adjacency and inequality)
- Statement. There is a fixed radius-1 seam gadget such that for any ordered pair (τ^L_u, τ^R_v): the bridge segment wb∘wc between S_1 and S_2 hosts a 1D tableau of a universal TM U that, in poly(s) steps, reads the B-bit ports u and v and computes d := D(u,v). A final verdict bit EDGE=d is exposed near S_2 together with a forwarded copy of Color(S_1). Local rules at S_2 enforce: if EDGE=0, accept regardless of colors; if EDGE=1, accept iff Color(S_2) ≠ ForwardedColor(S_1). All checks are nearest-neighbor.
- I/O wiring details:
  - Inputs to U: The header encodes C; adjacent to S_1 (resp. S_2) the port zone exposes u (resp. v). A seam handshake opens a corridor across wb∘wc for the tableau. Each tableau row is a constant-width word; Cout–out enforces per-row transitions of U.
  - Verdict wiring: The last row writes EDGE∈{0,1} and copies Color(S_1) into a “forwarded color” register next to S_2. Cout–out contains pairs that check (EDGE=1) ⇒ neighbor-to-S_2 carries a color different from S_2; if equal, no legal transition. If EDGE=0, both equal and unequal are allowed.
- Robustness:
  - Malformed runs or headers: standard error-chain refutations are allowed when ACT=false or when S is ⊥; these make such contexts inactive. Under ACT=true with colors at S, malformed rows have no accepting continuation (no error escape), so (F1) cannot be satisfied by cheating.
- Why useful: Aligns (F1)’s universal pair constraint with 3-coloring: feasibility of f is equivalent to the existence of a proper 3-coloring χ with χ(u)≠χ(v) whenever D(u,v)=1.

Soundness/completeness of the S3Col → FFE(F1) reduction (recap with the new lemmas)
- Active types: For each u, pick canonical L(u) and R(u) shapes; by Lemma TS they yield distinct types τ^L_u and τ^R_u. By Lemma CG, only these may carry colors.
- Completeness: Given a proper 3-coloring χ, set f(τ^L_u)=χ(u), f(τ^R_v)=χ(v), and f(τ)=⊥ for all other τ. For any pair (τ_left, τ_right), if both are active, Lemma Seam computes d=D(u,v) and enforces inequality iff d=1; satisfied by χ. If one or both are inactive, ⊥-plumbing admits completion. Hence (F1) holds.
- Soundness: If f satisfies (F1), read χ(u):=f(τ^L_u). For any edge (u,v) (i.e., D(u,v)=1), Lemma Seam forces f(τ^L_u)≠f(τ^R_v), so χ is a proper 3-coloring. Inactive types cannot be colored by f (or some pair would violate Lemma CG’s gating), hence f(τ)=⊥ there.

Neutralizing (F2)
- Add global ⊥-filler: allow wz to be labeled entirely ⊥ for all z ≥ 1, consistent with any boundary assignments and regardless of interior; S remains untouched; ACT gating remains enforced. Then (F2) holds trivially for any f, reducing the tri-class decision to (F1)-feasibility on our family.

Alphabet and radius-1 bookkeeping (explicit)
- Σ_out tracks (constant unless noted): roles/phases O(1), colors {RED,GRN,BLU,⊥} (4), error alphabet O(1), U’s work alphabet O(1), PAD O(1). Additional O(B) symbols for {Q_j} and {P_j} suffice for Lemma TS. Choose β ≥ c·B for a suitable constant c, which holds for c1 ≥ c0 in β = s^{c1}, B = s^{c0}.
- All constraints are radius-1: probes and pointer moves are enforced by nearest-neighbor pairs; tableau rows by local step relations; color inequality is a single adjacency near S_2.

Sanity check plan (B=2)
- Build a toy instance with β≥8, reserve Q_1,Q_2 and P_1,P_2, port zone of length 2 adjacent to S. Verify by brute DP: E_{L(00)}(a⋆)[Q_1,Q_2]=(0,0), E_{L(01)}=(0,1), E_{L(10)}=(1,0), E_{L(11)}=(1,1). Instantiate a tiny D (e.g., a 4-cycle) and check the bridge DP accepts iff colors differ on edges.

Why this is progress
- We have replaced informal sketches with concrete, radius-1 gadgets and clean lemmas (TS, CG, Seam) that are directly checkable via the DP. The per-bit probe avoids the flawed “single probe” idea and uses only O(B) extra symbols, admissible within β=poly(s). Color gating resolves the earlier consistency issue on multiple types per u. The seam gadget specifies exactly how to locally enforce inequality conditioned on D(u,v).

Next steps (auditable deliverables)
1) Write the small adjacency tables for the probe pipeline: list states {PROBE_L, P_j, ACCEPT, PAD} and allowed successors, and the Cin–out masks that gate colors by ACT. Provide a concrete symbol count to confirm β ≥ B+O(1) suffices.
2) Specify the tableau alphabet for U and the local transition rules that output EDGE and forward Color(S_1); include the exact pair checks near S_2 used to enforce inequality.
3) Produce a B=2 machine-readable instance (inputs and tables) and have the verifier’s O(kβ^2) DP validate: (i) separation under Q_1,Q_2; (ii) seam acceptance iff inequality on edges.
4) Integrate a short note into output.md clarifying fixed interior inputs in E_w(a), and (optionally) the explicit definition of C to avoid ambiguity when we later reference “inactive” types.

## Round 0003 — 2025-08-28T11:55:04.875014Z

Status and aim
- Objective: push the NEXPTIME-hardness reduction (Succinct 3-Coloring → Feasible-Function Existence (F1)) to a checkable state by pinning down two core gadgets with radius-1 rules and polynomial alphabet: (i) per-bit boundary probes that separate 2^B vertex types, and (ii) a seam tableau that computes D(u,v) and enforces color inequality on edges. Also enforce “must-color” only on canonical vertex contexts and neutralize (F2) via ⊥-filling.
- Output.md: no correctness issues spotted for the upper bound (types, DP, finite-Z). Clarification already noted there (“fixed inputs” interpretation) is consistent with what we use below. The NEXPTIME verifier section is still informal; we supply precise, testable lemmas and constraints to move pieces into output.md.

Lemma TS (Per-bit probe type separation; radius-1, β=poly(s))
- Parameters: B = s^{c0}, β = s^{c1} with c1 > c0 so β ≥ B and there is headroom for O(B) reserved symbols.
- Canonical left vertex block L(u): a fixed-format segment W_L(u) adjacent to S with the following O(B)-length subzones (roles enforced by Cout–out phases):
  1) HEAD_C: a short header whose out-track copies (via Cin–out) a fixed binary description enc(C) of the succinct adjacency circuit. Any deviation allows an error-chain in non-probe contexts, but see “Probe discipline” below.
  2) PORT: B consecutive cells immediately to the right of S. Each PORT cell carries two output subtracks: Addr ∈ {1,…,B} and RidBit ∈ {0,1}. Local Cout–out rules require Addr to increase by 1 from left to right, starting at 1 and ending at B, and RidBit to equal the input bit (Cin–out tie) at that node under role=PORT. The vector (RidBit[1..B]) encodes u.
  3) RUN_L: a fixed-width corridor (constant tracks) that hosts a row-by-row 1D tableau for U; unused in the probe; used later by the seam gadget.
- Reserved boundary-output family: Define B distinct boundary-output 4-tuples {Q_j : j∈[B]}. Implementationally, allocate four disjoint reserved symbol families in Σ_out: for the four boundary nodes of L(u), allow only the 4-tuple (ProbeL1(j), ProbeL2(j), ProbeR2(j), ProbeR1(j)) when “probing j”. The set {Probe•(j)} across all j uses O(B) distinct symbols, feasible as β ≥ B and we have ample slack for other tracks.
- Pointer and acceptance (radius-1): Under boundary inputs fixed to a⋆ (choose any constant 4-tuple; e.g., all zeros) and boundary outputs Q_j, Cout–out enforces a deterministic, unique continuation into a “probe mode”: a finite-state pointer head propagates rightward from the left boundary through PORT, matching successive Addr values and halting exactly when Addr=j. The only legal continuation at that cell is to accept iff RidBit=1; if RidBit=0 then the probe path dead-ends (no completion). No alternative transitions (e.g., error-chain) are permitted while “probe mode” is active (see probe discipline below). Outside reserved probes, normal error-chains exist so malformed interiors never constrain f.
- Probe discipline (no error-escape): Cout–out tags each transition in a binary “mode” track. When Q_j is present, the mode is forced to PROBE in a bounded prefix of W_L(u) and error symbols are disallowed in PROBE mode; the only legal edges follow the deterministic pointer/run described above. If any local check fails (role/phase, Addr monotonicity, reaching j, or RidBit), no outgoing pair is allowed ⇒ the DP rejects that boundary 4-tuple.
- Claim (Type-Separation): For any u∈{0,1}^B and any j∈[B], E_{Type(L(u))}(a⋆)[Q_j] = 1 iff u_j=1. Hence the B-bit vector (E(a⋆)[Q_j])_{j=1..B} equals u. In particular, u≠u′ ⇒ Type(L(u))≠Type(L(u′)).
  Why: Under Q_j the continuation is unique; extendibility equals the truth of RidBit[j]=1 in the PORT zone. Because E_w(a) is defined with interior inputs fixed (as in output.md), this bit is a property of the concrete L(u) and thus of its type. Since at least one probe outcome differs when u≠u′, the types differ. Radius-1 holds (only nearest-neighbor checks); Σ_out budget is O(B) for Addr values, O(B) for reserved Q_j symbols, plus O(1) for roles, phases, ⊥, colors, errors, U’s alphabet ⇒ β = poly(s) suffices.

Lemma RG (Role gating and must-color for canonical contexts)
- Gating: Two special role markers are allowed at S’s two nodes: Color and ⊥. Cout–out permits Color tokens {RED, GRN, BLU} at S iff and only if the adjacent interior begins with a well-formed canonical vertex header: HEAD_C followed immediately by the PORT zone (left side for L(·), right side for R(·)). Otherwise (inactive contexts), Color at S has no legal continuation (dead); ⊥ at S always has a legal continuation via neutral plumbing (a self-looping ⊥ language as in the upper bound DP).
- Must-color on active pairs: On a bridge instance between an active left L(u) and an active right R(v) (see next lemma), the seam accepts only if both S nodes carry Color (non-⊥). Thus any feasible f must assign a color to each canonical vertex type; assigning ⊥ would falsify (F1) on its pairings with some active opposite.
- Consequence: f is only free to color canonical types; any attempt to color an inactive type causes (F1) to fail on some pair (inactive, anything) because Color-at-S would be unextendible on the inactive side. Therefore f must map all inactive types to ⊥.

Lemma SG (Seam tableau for succinct adjacency and inequality)
- Canonical right vertex block R(v): symmetric to L(u), with its PORT zone immediately to the left of S; it exposes Addr and RidBit tracks encoding v.
- Seam layout: In the bridge wb∘wc between L(u)’s right side and R(v)’s left side, Cout–out allocates a fixed-width corridor RUN_B that hosts a row-by-row simulation of a universal TM U on input (enc(C), u, v). The input (enc(C)) is present in both HEAD_C zones, and u,v are read from the PORT zones (local wiring at the near seam). Each row transition is enforced by nearest-neighbor Cout–out constraints; malformed rows cannot continue (no error-escape inside RUN_B). The final row writes EDGE ∈ {0,1} at a fixed seam-local cell.
- Acceptance policy at S (radius-1): Local rules enforce: (i) if EDGE=0, accept regardless of colors at S; (ii) if EDGE=1, accept iff the two S colors differ; (iii) on an active-active pair, ⊥ is not permitted (must-color). All checks refer only to the two S outputs and the nearby EDGE bit.
- Robustness: If either side is inactive or malformed (HEAD_C absent, corrupted PORT), the only allowed S symbol is ⊥ and a neutral ⊥-plumbing fills both sides, ensuring these contexts never constrain f (consistent with Lemma RG).
- Correctness: On active-active pairs, the tableau computes D(u,v) in poly(s) time and exposes EDGE correctly; the final local check enforces exactly the 3-coloring constraint “colors must differ on edges and arbitrary on non-edges”.

Canonicality and existence of active types
- Canonical shapes: Define L(u)=W_L(u) S F_R and R(v)=F_L S W_R(v) with W_L, W_R as above and fixed fillers F_L, F_R (PAD-roles). Cout–out recognizes only these shapes as vertex roles (for gating). Any other context is inactive (no Color at S).
- Existence via pumping/replacement: HEAD_C+PORT+RUN zones have length poly(s) ≪ ℓ_pump = 2^{Θ(β^4)}. By Lemma 11 (replacement) and Lemmas 14–15 (pumping), we can place W_L(u) adjacent to S inside words of length ℓ_pump or ℓ_pump+1 on the designated side, preserving the type of W_L(u); ditto for W_R(v). Thus the context set C contains, for each u (resp. v), at least one canonical left (resp. right) type, and Lemma TS gives at least 2^B distinct left-types and 2^B distinct right-types.

Soundness/completeness of the reduction (sketch tightened)
- Completeness (⇒): Given a proper 3-coloring χ: {0,1}^B → {RED,GRN,BLU} of the succinct graph defined by C, define f on canonical types by f(Type(L(u)))=χ(u) and f(Type(R(v)))=χ(v); set f(τ)=⊥ on all inactive types. By Lemma SG, every active-active (F1) pair accepts iff χ(u)≠χ(v) when D(u,v)=1 and always if D(u,v)=0. All other pairings accept via ⊥-plumbing. Hence (F1) holds.
- Soundness (⇐): If some f satisfies (F1), Lemma RG forces f to assign colors to canonical vertex types and ⊥ to all inactive types. Read χ(u):= f(Type(L(u))). For any edge (u,v) with D(u,v)=1, the seam between Type(L(u)) and Type(R(v)) must be extendible; by Lemma SG this implies χ(u)≠χ(v). Non-edges impose no restriction. Thus χ is a proper 3-coloring.

Neutralizing (F2)
- Add a global ⊥-filler language: For any repetition w_1^z and w_2^z (z≥1), Cout–out admits labeling all repeated sides with ⊥ regardless of boundary outputs, without touching S or the vertex-role gating. Then (F2) holds for any f, reducing the three-way classifier to deciding (F1)-feasibility on our instances (NEXPTIME-hard).

Alphabet/size and radius bookkeeping
- Σ_out tracks (all merged into symbols): roles/phases O(1); colors+⊥ (4); error alphabet O(1); U’s row alphabet O(1); Addr values {1,…,B} (O(B)); reserved probe symbols for Q_j (O(B)); a few pointer states O(1). Total |Σ_out| = β = poly(s). All constraints are radius-1 (depend on current and predecessor outputs only).

Sanity example (B=2)
- Reserve Q_1, Q_2 for the left boundary. L(00), L(01), L(10), L(11) yield extendibility vectors (E(a⋆)[Q_1], E(a⋆)[Q_2]) equal to (0,0), (1,0), (0,1), (1,1) respectively. On the seam, with C encoding a 4-cycle, the tableau sets EDGE=1 exactly on adjacency pairs; the local check enforces color inequality on those.

Obstacles and how addressed (verifier feedback alignment)
- “Single fixed probe” issue: we use a family {Q_j} indexed by boundary outputs; acceptance depends on interior u via the deterministic pointer (no dependence on a globally fixed j). Addresses or O(B)-many probe symbols ensure radius-1 feasibility without exponential symbol blowup.
- Consistency on same u: avoided by canonical gating. Only L(u), R(v) allow colors; mapping any other type to a color breaks (F1). Thus each u is represented by exactly one colorable type per side.
- Error-escape under probes: disallowed by a probe-mode bit; in probe mode, error-chain symbols are not permitted in Cout–out’s allowed neighbor pairs.

Next steps (concrete, verifiable)
1) Write explicit local rule snippets for the probe gadget:
   - The four reserved boundary symbols and their immediate successors in “probe mode”.
   - PORT zone neighbor pairs enforcing Addr increment and RidBit copy.
   - Pointer transitions and the accept/dead-end at Addr=j with RidBit test.
   Provide a small B=2 instance and brute-force the DP to observe E(a⋆)[Q_j] = u_j.
2) Formalize Lemma RG: list Cout–out pairs that allow Color at S only next to HEAD_C+PORT; add dead-end rules otherwise; add the ⊥ self-loop plumbing.
3) Specify RUN_B alphabet and row transitions for U; define EDGE emission and the local color-inequality check at S. Verify on a toy circuit D by DP.
4) Package the reduction D ↦ P_D with precise β sizing and radius-1 constraints; add the ⊥-filler rules. Then move Lemmas TS, RG, SG and the reduction theorem into output.md.

Why useful here
- The per-bit probe family and probe discipline directly resolve the main gaps flagged by the verifier: we now separate 2^B types without per-type tailoring, and we prevent error-escape in reserved probes. The role-gating and must-color rules ensure f assigns colors only to canonical vertex types, avoiding consistency pitfalls. The seam tableau matches (F1)’s pairwise nature. All components are radius-1 and compatible with the O(kβ^2) DP for audit.

## Round 0003 — 2025-08-28T11:55:40.787420Z

Round goal
- Deliver a clean, radius-1, per-bit boundary-probe Type-Separation Lemma (Option A) that yields 2^B distinct “vertex” context types τ_u, with a concrete deterministic pointer gadget and explicit gating against error-escapes under reserved probes.
- State the canonical vertex-context lemma (existence of L(u), R(v) types adjacent to S only) with a pumping-based padding argument to hit lengths ℓ_pump or ℓ_pump+1 without disturbing the port zone.
- Formalize the seam gadget lemma that simulates D(u,v) across the bridge and gates acceptance by “if EDGE=1 then colors differ, else vacuous,” while keeping error-chains disabled in the active bridge mode. Provide alphabet/radius bookkeeping and a B=2 sanity check blueprint.

Context recap and constraints we must respect
- β-normalized, radius-1: Cin–out ties outputs to input bits locally; Cout–out is the only adjacency checker. All gadgets must be nearest-neighbor.
- Types are defined over fixed interior inputs (clarified in output.md remarks). Distinguishing types only requires showing E_w(a⋆) differs for some fixed boundary-input tuple a⋆.
- Feasible-function existence (F1) is the only property we reduce to (we neutralize (F2) later by ⊥-filler). We must ensure that colored S is only legal on canonical vertex contexts, so f is only “free” on τ_u and is forced to ⊥ elsewhere.

Lemma TS (Per-bit probe type separation, radius 1)
Statement. Fix parameters B = s^{c0}, β = s^{c1} with c1 ≥ c0. There exist global Cin–out, Cout–out and a family of β′ ≥ B reserved boundary-output 4-tuples {Q_j: j ∈ [B]} and a fixed boundary-input assignment a⋆ ∈ Σ_in^4 such that the following holds. For any word W_L(u) that contains a well-formed left-vertex block (defined below) positioned O(1) from S and encoding u ∈ {0,1}^B adjacent to S, and has no errors:
- E_{W_L(u)}(a⋆)[Q_j] = 1 iff u_j = 1.
Consequently, for u ≠ u′, Type(W_L(u)) ≠ Type(W_L(u′)) (they differ on E(·)(a⋆) for some Q_j), so there are at least 2^B distinct left-vertex types. Symmetrically for right-vertex types.

Design (radius-1 with uniform global rules)
- Tracks in Σ_out (constant multiplicity; folded into single symbols):
  1) Role/phase ∈ {HEAD, PORT, BRIDGE, PAD, ERR} × {phase mod c}.
  2) RID data bit (output track) required to equal the input bit when Role=PORT (Cin–out enforces copy).
  3) Address track Addr ∈ {1,2,…,B} present only when Role=PORT. Each Addr=j is a distinct output symbol component; total O(B).
  4) Probe corridor states Probe_j,Move and Probe_j,Test (two local phases) for each j ∈ [B]. These travel inside W_L(u) when a probe is active. Total O(B) many “probe-id” states, permitted since β = poly(s).
  5) Neutral ⊥ and error-chain alphabet (ERR_x) as in §3 of the reference, but these are disabled in probe-active mode (see below).
- Reserved boundary outputs Q_j (two-node boundary on the far-left and the two nodes just inside it) place a start-token that forces the unique corridor Role=BRIDGE with state Probe_j,Move to appear immediately to the right of the left boundary, propagating deterministically rightward cell-by-cell.
- Corridor-path and uniqueness: Cout–out enumerates exactly one successor for each Probe_j,Move, forcing the head to march right until it meets a cell whose Role=PORT. If no PORT appears within the allowed window, no outgoing pair is allowed: the DP dies (reject). Error-chain and ⊥ are disallowed adjacent to Probe_j,* by omitting such pairs from Cout–out.
- Address match and test: At a PORT cell, Cout–out allows Probe_j,Move to step to Probe_j,Test iff the PORT cell carries Addr=j; otherwise it must continue moving (still Probe_j,Move). In Probe_j,Test, Cout–out further requires the PORT cell’s RID bit be 1; only then does it allow a local acceptor “sink” (a short fixed BRIDGE→PAD termination sequence). If RID=0, there is simply no legal outgoing pair for Probe_j,Test at this site (reject). Again, no error-escape pairs exist in these states.
- Disabling probes when not selected: For any boundary-output 4-tuple not in {Q_j}, Cout–out never enables Probe_* states at the boundary; instead it allows generic PAD/⊥-plumbing, so these assignments do not influence separation.

Why E_{W_L(u)}(a⋆)[Q_j] = u_j
- “⇒”: If Q_j is used and the interior is a well-formed vertex block, the corridor deterministically reaches the PORT zone adjacent to S (see vertex blocks below), then walks along PORT cells until encountering Addr=j; at that cell, Probe_j,Test checks RID=1. If u_j=1, Cin–out forces the PORT symbol’s RID=1 (copy of input), so the test passes and the sink terminator exists, so the DP has a path.
- “⇐”: If u_j=0, then at the unique cell with Addr=j the RID bit is 0, so Probe_j,Test has no legal continuation; there are no alternative continuations (no error, no ⊥ permitted in probe mode), and the unique path dies. Therefore E=0.
- Type-invariance: E_{W_L(u)}(a⋆)[Q_j] depends only on the fixed boundary inputs a⋆ and the presence/contents of the PORT zone (encodes u). Any two representatives with the same u and no errors admit the same probe behavior. Thus the bitvector over {Q_j} is the same across all words of that type.

Vertex blocks and canonical contexts
- Canonical left-context L(u) and right-context R(v): A well-formed left block W_L(u) begins O(1) to the left of S and is laid out as HEAD · RIDPORT · SPACER · PAD, with:
  • HEAD: a self-delimiting header containing enc(D) (copied from Σ_in via Cin–out) and marks the start of the block (constant size overhead, independent of B).
  • RIDPORT: a contiguous port zone of exactly B cells adjacent to S, each with Role=PORT, the address track Addr=1..B in increasing order left-to-right, and the RID bit track which Cin–out ties to the node’s input bit so that the zone encodes u verbatim.
  • SPACER and PAD: a constant-length SPACER followed by a long padding segment PAD with Role=PAD (any filler pattern consistent with Cout–out). Right blocks W_R(v) are symmetric to the right of S.
- Color-at-S gating: The two S nodes have access to color symbols {RED, GRN, BLU} only if their immediate neighbors on the inside are special handshake boundary symbols that must be adjacent (in Cout–out) to Role=PORT with the correct phase for a vertex block. If these adjacencies fail (i.e., the block is absent/malformed), then any attempt to place a non-⊥ color at S cannot be extended (no legal Cout–out pair), hence non-vertex contexts cannot carry colors. Conversely, if the block is well-formed, the handshake permits a colored S, activating the seam gadget (below). This implements “only canonical contexts permit colors,” using radius-1 adjacencies.
- Length normalization at ℓ_pump or ℓ_pump+1: For any fixed u, we construct a seed left word U_left(u) = P^z · HEAD · RIDPORT · SPACER, where P is a constant PAD primitive whose repetitions are allowed by Cout–out. Choose z so that |U_left(u)| equals ℓ_pump or ℓ_pump+1. This is always possible by taking z = ⌈(ℓ_pump − c)/|P|⌉ or z+1. The right side is a 
neutral filler F_R of the required length. By Lemma 12 (composition) and Lemma 11 (replacement), any further padding on the far sides preserves the type near S; the port zone stays adjacent to S because we do not insert repeats inside RIDPORT. Thus for each u there exists at least one left-context of the required lengths with the port zone at S; symmetrically for R(v).

Lemma SG (Seam gadget for succinct adjacency and color inequality)
Statement. There is a fixed radius-1 bridge schema such that for any ordered pair of canonical vertex contexts (L(u), R(v)), if both S windows are colored, the concatenation wa S1 wb wc S2 wd admits a completion iff either D(u,v)=0 or (D(u,v)=1 and the two colors differ). If either side is not a canonical vertex context, colors are forbidden by the handshake; if a side is malformed but S was colored regardless, the bridge offers no completion (no error-escape in active mode).
Design details (radius-1)
- Activation: The color-at-S handshake (above) also puts the inner neighbors of S into a special BRIDGE-Start phase. Cout–out allows entering a BRIDGE corridor across wb ◦ wc only from this phase.
- Inputs to the run: The two B-bit port zones are immediately adjacent to S. The bridge corridor accesses these bits by simple “read heads” that move one step into wb or wc and copy the bit into the first row of a RUN tableau (implemented in the bridge). The circuit D is present in HEAD on both sides (since enc(D) is copied from Σ_in to Σ_out under HEAD), or, alternatively, we can duplicate enc(D) in the bridge header as constant local data—both are radius-1 local.
- Tableau: A fixed universal TM U is simulated row-by-row across the bridge to compute d := D(u,v) in poly(s) steps. Cout–out enforces per-row local transitions; malformed rows admit no accepting continuation in the active mode (no ERR allowed adjacent to BRIDGE states). After the last row, a dedicated cell adjacent to the S2 side outputs EDGE ∈ {0,1}.
- Local acceptance: Cout–out encodes the rule that across S1 and S2 and the adjacent EDGE cell:
  • If EDGE=0 (non-edge), all three color-equality pairs at S are allowed.
  • If EDGE=1 (edge), the two S outputs must be unequal; the three equal-color pairs are disallowed, blocking all completions in those cases.
- Robustness: All ERR_x error-chain symbols are globally available for inactive modes (e.g., malformed vertex blocks when S is ⊥), but in bridge-active mode (colors present at S) the BRIDGE corridor allows no ERR transitions. Thus a malformed attempt in active mode rejects rather than escaping to ERR.

Alphabet and radius bookkeeping
- Σ_out size: roles/phases O(1); color tokens + ⊥ (4); error alphabet O(1) (global); PORT addresses (B); probe-id states per j (O(B)); RUN work alphabet for U (constant). Total |Σ_out| = β can be chosen s^{c1} with c1 ≥ c0 large enough so β ≥ C·B for a fixed constant C (absorbing all constants).
- Radius-1: Every constraint is between a node and its predecessor: Cin–out ties PORT.RID to the input bit; Cout–out enumerates the only legal neighbor pairs for PROBE movement, RUN row steps, BRIDGE activation, and color/EDGE gates.

Soundness/completeness sketches (Succinct 3-Coloring → FFE(F1))
- Type separation: By Lemma TS, for each u there is at least one canonical left (resp. right) vertex type τ^L_u (resp. τ^R_u), and τ^L_u ≠ τ^L_{u′} for u≠u′. All non-vertex contexts are inactive (color-at-S cannot be extended), so f must map them to ⊥.
- Completeness: Given a proper 3-coloring χ: {0,1}^B → {R,G,B}, define f(τ^L_u) = χ(u) and f(τ^R_v) = χ(v), f(τ)=⊥ for others. For any pair (τ^L_u, τ^R_v), the bridge simulates D(u,v); if D=0, acceptance is unconditional; if D=1, the inequality holds by χ, so the bridge accepts. All other pairings are vacuous by gating.
- Soundness: If f satisfies (F1), define χ(u) = f(τ^L_u). For any (u,v) with D(u,v)=1, the pair (τ^L_u, τ^R_v) must pass the (F1) DP; by Lemma SG’s gate, that forces χ(u)≠χ(v). Hence χ is a proper 3-coloring. Note the “same-u consistency” issue is avoided by construction: only the canonical τ^L_u and τ^R_v can carry colors, so f is single-valued on u.

Neutralizing (F2)
- Add global ⊥-plumbing on repeats: for any w and z≥1, the repetition wz can be filled entirely with ⊥ consistent with Cout–out (and respecting the handshake that forbids colors unless a vertex block is present). Then (F2) is vacuous for all contexts, so the three-way classifier reduces to deciding (F1)—hence NEXPTIME-hard.

Toy sanity check (B=2)
- Let β≥8. Port zone has two PORT cells with Addr=1,2 and RID matching input bits (u_1,u_2). Q_1, Q_2 probes: under Q_1 the corridor moves to Addr=1 and accepts iff u_1=1; similarly for Q_2. The 4 left-types τ^L_{00}, τ^L_{01}, τ^L_{10}, τ^L_{11} differ on the two probe bits. For a small D encoding (e.g., 4-cycle), the BRIDGE tableau reads u,v and emits EDGE=1 on edges; local gate forbids equal colors only then. A brute-force DP on the combined path verifies that all (F1) instances accept iff colors define a proper 3-coloring.

Obstacles and how addressed
- Unique continuation under reserved probes: We explicitly disallow ERR/⊥ adjacencies when any Probe_j,* state appears; the only permitted successor is the deterministic path, ensuring E(Q_j) reflects u_j.
- Keeping the port zone adjacent to S after length normalization: We choose padding only in PAD, outside RIDPORT, so the port stays adjacent to S; we do not rely on pumping to preserve the internal structure of RIDPORT.
- Same-u consistency: Avoided by gating colors at S exclusively to canonical vertex contexts; alternative contexts cannot carry colors, so f cannot assign contradictory colors to the same u across multiple types.

Gaps or clarifications for output.md (minor)
- Clarify explicitly (already noted in Remarks) that types E_w(a) are computed with respect to the fixed interior input string of w. Our reductions rely on Cin–out copying input bits into PORT.RID.
- Optional: Note that while Corollary 4 uses Z ≤ ℓ^2, for a fixed context one can compute smaller Z from the per-side type DFA cycles; not required for our hardness but may tighten constants.

Next steps (auditable deliverables)
1) Write the local Cout–out transitions for the probe gadget: list states {Probe_j,Move/Test}, allowed pairs with PORT cells (Addr≠j ⇒ Move; Addr=j and RID=1 ⇒ acceptor; disallow ERR/⊥ near probes). Provide a finite table parametrized by j with size O(B) to confirm β budget.
2) Give the exact HEAD and RIDPORT layouts with Cin–out masks: specify that when Role=PORT, only two output symbols (RID=0/1) are allowed and must match the input bit; when Role=HEAD, output must match the input encoding of D.
3) Specify the BRIDGE tableau alphabet and the final EDGE cell’s interface to S: define the three forbidden adjacent pairs across S when EDGE=1 (RR, GG, BB) and allow all when EDGE=0; verify radius-1 locality.
4) Provide a fully worked B=2 instance (explicit symbols) and run the O(kβ^2) DP to validate both Type-Separation and Seam Gadget behavior; we can submit this as a regression test to the verifier.
5) Integrate the global ⊥-filler rules for repetitions and restate the corollary: on our instances, the classifier’s O(1) vs. Ω(log* n) vs. Θ(n) reduces to (F1), hence NEXPTIME-hard.

Why useful here
- The per-bit probe lemma squarely addresses the verifier’s major issue: we do not “program” per-type tables; instead we use uniform global rules and reserved probes whose acceptance depends on the interior u via Cin–out, yielding exponentially many types. The seam gadget aligns exactly with (F1)’s universal pairwise check for 3-coloring. Both gadgets are radius-1 and fit the β budget, and they can be verified independently by the DP on small instances.

## Round 0003 — 2025-08-28T12:27:11.729096Z

Status and focus
- Goal: finalize a clean, radius-1 reduction from Succinct 3-Coloring (S3Col) to Feasible-Function Existence (F1) in the β-normalized model, with (F2) neutralized by ⊥-filling, thereby yielding NEXPTIME-hardness of the 3-way classifier.
- This round: (i) fix the probe/type-separation gadget using a family of per-bit probes Q_j; (ii) specify canonical vertex contexts and gating so only those contexts can carry non-⊥ colors at S; (iii) specify a seam tableau that computes Edge(u,v) and Eq(u,v) and enforces acceptance iff (Edge=0 or colors differ) and (Eq=0 or colors equal), which also forces left/right copies of the same vertex to share the same color; (iv) give concrete DP-checkable formulations and bookkeeping; (v) list verifiable next deliverables.

Gaps in output.md (minor clarifications, no changes made)
- Types vs fixed inputs: The definition of E_w(a) notes interior inputs may be arbitrary or fixed by the instance; our hardness builds contexts by choosing suitable interior inputs (binary strings) realizing the canonical blocks. It would help to add a sentence to output.md explicitly stating: “When we refer to Type(w), interior inputs are fixed to those of w; the type depends on the chosen input word w.” This is already consistent with the DP and Section 4 of the reference.
- Optional: Corollary 4’s bound Z ≤ ℓ^2 is sufficient (tightening via lcm of periods is possible but unnecessary here).

Idea 1 — Per-bit probe family Q_j gives 2^B distinct vertex types
Concrete tracks and symbols (radius 1, β-normalized)
- Σ_in = {0,1}. Σ_out tracks (combined into one symbol):
  1) Role/phase: {HEAD, VERT, PORT, RUN, PAD, PROBE, ERR_k, …} × {phase mod c} (constant size).
  2) S-color: {RED, GRN, BLU, ⊥} available only on the two S nodes (enforced by roles around S).
  3) Port zone outputs that must copy Σ_in via Cin–out: an address track Addr ∈ {1,…,B} (encoded in binary or unary across cells) and a data track RIDbit ∈ {0,1} for the index u.
  4) Pointer/probe track with states {Start_j, Head_j, Ok_j, Dead_j} for j∈[B]; Head_j carries probe-id j along the pointer path; this induces O(B) states; permitted because β = poly(s) and B = s^{c0}.
  5) RUN work alphabet for a fixed U (constant-size), error-chain alphabet as in §3 of the reference (constant).
- Reserved boundary outputs: choose a common boundary-input pattern a⋆, and for each j∈[B] a dedicated 4-tuple Q_j on the boundary outputs that sets the PROBE role to Start_j at both boundary sides and fixes neighbors to allow only the probe pipeline (see below).

Probe pipeline (only legal continuation under Q_j)
- Cout–out lists only the following successor pairs when the left boundary outputs equal Q_j: Start_j (at the outermost position) must be followed by Head_j moving deterministically right, keeping the j-tagged Head_j; along Head_j, the role PORT is required (locally enforced) and the port zone must be present adjacent to S within a fixed offset. Head_j advances cell-by-cell until it stands on a PORT cell whose output Addr equals j (comparison is local: the j-tag in Head_j must match Addr). At that cell:
  • If RIDbit=1, a transition Head_j→Ok_j is allowed, after which a short, locally-checked accept sink attaches to filler/PAD; the boundary assignment Q_j is extendible.
  • If RIDbit=0, there is no legal successor (no error-escape is listed under PROBE), so no completion exists; the boundary assignment Q_j is non-extendible.
- No error-chain or alternative plumbing is enabled while the PROBE role is active; this guarantees uniqueness of the computation under Q_j and prevents spurious accepting paths.

Lemma TS (Type-separation via Q_j). For each u∈{0,1}^B there exists a canonical left-context L(u)=W_L(u) S F_R (constructed below) with a well-formed PORT zone of length Θ(B) adjacent to S on the right, whose RIDbit track (copied from Σ_in via Cin–out) spells u and whose Addr track enumerates addresses 1,…,B. For the fixed boundary-input assignment a⋆ and boundary-outputs Q_j, E_{L(u)}(a⋆)[Q_j]=u_j. Consequently, if u≠u′ then Type(L(u))≠Type(L(u′)).
Why useful: Gives ≥2^B distinct left context types injectively indexed by u. The same construction mirrored yields right context types R(v).
Proof sketch: Under Q_j the only legal extension (by Cout–out) is the deterministic PROBE pipeline; it reaches the unique PORT cell with Addr=j. Cin–out forces RIDbit outputs to equal the input bits of W_L(u); hence Ok_j exists iff u_j=1. Thus the extendibility bit for Q_j equals u_j. Since the Type records, for each fixed boundary input a⋆, the yes/no table over all boundary-outputs, and the family {Q_j} lies within those outputs, the truth tables differ for u≠u′, hence types differ. Uniformity: under Q_j there is no alternative continuation, so E_w(a⋆)[Q_j] depends only on u, not on other interior nondeterminism.

Idea 2 — Canonical vertex contexts and color gating
Canonical shapes
- Left: L(u) = W_L(u) S F_R. The block W_L(u) is HEAD · VERT · PORT · RUN with O(poly(s)) length, anchored within O(1) of S (fixed offset). The right side F_R is neutral filler (PAD) of length ℓ_pump−O(poly(s)).
- Right: R(v) = F_L S W_R(v), symmetric.
Color gating at S (radius 1)
- Only when the immediate neighbors of S display role tokens GateL (on the left side) or GateR (on the right side), which appear exclusively in well-formed W_L(·)/W_R(·) at the fixed offsets, do the S nodes permit non-⊥ S-color outputs. Otherwise, S-color must be ⊥ and any non-⊥ choice yields no continuation (local dead-end). This makes all non-canonical contexts inactive.
- The existence of contexts with |W_L(u)|∈{ℓ_pump,ℓ_pump+1} follows from pumping/replacement (Lemmas 11, 14–15 in the reference). We pick fixed offsets so that GateL/GateR alignment is independent of the global length choice; padding happens in the outer PAD region.
Result: Only the canonical L(u), R(v) types are active; all others must be assigned ⊥ by any feasible f.

Idea 3 — Seam tableau computing Edge(u,v) and Eq(u,v) and local acceptance
Bridge layout and computation
- On a bridge instance wa S1 wb wc S2 wd with left=L(u) and right=R(v), the concatenation wb∘wc (length ≥ℓ_pump−O(poly(s))) hosts a standard row-by-row simulation of a fixed U for poly(s) steps. U reads:
  1) the encoding of the circuit D from HEAD (copied from Σ_in via Cin–out inside both W_L, W_R),
  2) the B-bit RID port u adjacent to S1, the B-bit GID (or v) adjacent to S2.
- The tableau checks nearest-neighbor consistency (Cout–out row transitions), with conventional error-chains available only when RUN is malformed or HEAD/RID is malformed; but if S carries a non-⊥ color while a side is malformed, the seam dead-ends (no accept path), ensuring non-canonical types cannot use colors.
- U emits two 1-bit flags near S: Edge = D(u,v) and Eq = [u=v] (computed by a simple bitwise equality scan).
Local acceptance policy (enforced by constant-size radius-1 constraints around S)
- Accept iff both conditions hold simultaneously:
  (A) Edge=0 OR (S-color1 ≠ S-color2), and
  (B) Eq=0 OR (S-color1 = S-color2).
- Intuition: (A) enforces inequality on edges, vacuous on non-edges; (B) forces left/right copies of the same vertex to carry identical colors (Eq=1 ⇒ colors equal), which also makes all duplicate types for a given u consistent via pairing with the unique right-type R(u).
- If either side is inactive (color at S forbidden), a colored attempt dead-ends; with ⊥ at S, the seam always accepts (⊥-plumbing), making all non-canonical pairs trivial.

Why this aligns with (F1) and fixes prior concerns
- Pairwise constraint matches (F1): every ordered pair of contexts is checked; edges impose inequality; non-edges impose nothing; in addition Eq=1 imposes left/right consistency, removing the need for uniqueness of types per u.
- Determinism under probes prevents “cheating” via error-chains.

Neutralizing (F2)
- Add a global ⊥-filler: for any context (w1,S,w2) and any z≥1, allow wz_1, wz_2 to be entirely labeled with ⊥ via Cout–out, independent of boundary inputs/outputs and independent of the internal roles. This never overrides S nor GateL/GateR, and thus does not affect (F1). Consequently, (F2) is always true for any f on our instances; the classifier reduces to (F1)-feasibility.

Soundness/completeness (sketch with the new Eq gating)
- Completeness (3-colorable ⇒ feasible f): Given a proper 3-coloring χ:V→{R,G,B}, define f(Type(L(u))) = χ(u) and f(Type(R(v))) = χ(v); all inactive types map to ⊥. For any ordered pair (L(u),R(v)), U computes Edge and Eq. If Edge=1 then χ(u)≠χ(v) and (A) holds; if Edge=0 then (A) holds trivially. If Eq=1 (thus u=v), then χ(u)=χ(v) by definition of f on left/right copies and (B) holds; if Eq=0, (B) is vacuous. Thus all (F1) instances accept. (F2) is vacuous by ⊥-filling.
- Soundness (feasible f ⇒ 3-colorable): Define χ(u):=f(Type(L(u))) (well-defined because pairing (L(u),R(u)) forces equality via (B)). For any edge (u,v), pairing (L(u),R(v)) yields Edge=1, so (A) forces χ(u)≠χ(v). Hence χ is a proper 3-coloring.

DP-checkable toy instance (B=2)
- Set β≥8. Build L(00), L(01), L(10), L(11), and R(·) analogously. Reserve Q_1,Q_2. Verify:
  • E_{L(u)}(a⋆)[Q_1] = u_1, E_{L(u)}(a⋆)[Q_2] = u_2 (the DP fails/succeeds under the unique probe pipeline).
  • On a small D (e.g., a 4-cycle), the seam tableau sets Edge accordingly; local acceptance enforces inequality on edges; Eq enforces equality across (L(u),R(u)) pairs.
- The verifier can brute-force all ordered pairs of these contexts and check that (F1) holds iff a 3-coloring exists.

Alphabet and complexity bookkeeping
- Tracks: roles/phases O(1), colors+⊥ (4), error alphabet O(1), RUN alphabet O(1), probe/pointer states O(B), plus a constant variety of plumbing symbols. Choose β = s^{c1} with c1≥c0 so β≥Θ(B); the global tables Cin–out (2×β) and Cout–out (β×β) remain poly(β).
- Lengths: HEAD+PORT+RUN = poly(s) ≪ ℓ_pump = 2^{Θ(β^4)}; pumping/replacement embeds blocks adjacent to S within contexts of length ℓ_pump or ℓ_pump+1.
- Radius 1: every check (probe step, address match, bit read, row-to-row evolution, local acceptance at S) is nearest-neighbor.

Obstacles addressed and remaining
- Fixed single-probe issue resolved: we use a family {Q_j} and carry the j-id in Head_j; acceptance depends on u.
- Consistency across duplicate types: ensured by Eq gating across (L(u),R(u)). This propagates equality across all left/right duplicates via (F1).
- Error-chain leakage: explicitly disabled under PROBE; enabled only in malformed RUN/head regions not under probe or color activation.
- Remaining work: write explicit Cout–out pairs for pointer transitions and RUN rows (constant-size schemas); specify the exact offsets and phases that isolate GateL/GateR to canonical contexts; present a small B=2 instantiation with explicit tables that the verifier can DP-check.

Next concrete steps (auditable)
1) Write the pointer/probe transitions: the set of allowed (y_i,y_{i+1}) pairs for Start_j, Head_j, Ok_j, including the guard that Head_j may move only over PORT cells and must compare its j-tag to Addr.
2) Formalize Lemma TS: a fully self-contained proof in our r=1 model that E_{L(u)}(a⋆)[Q_j]=u_j (no alternative accepting continuation) and that u≠u′ ⇒ types differ. Include a precise statement of a⋆ and the reserved outputs Q_j.
3) Specify canonical L(u), R(v) layouts: exact offsets for HEAD, PORT, RUN relative to S; a small constant-phase scheme that ensures GateL/GateR appear only at those offsets; show padding preserves type (Lemmas 11,14–15).
4) Write the seam U-tableau alphabet and local rules; define where Edge and Eq flags appear; list the constant-size local acceptance checks at S implementing (A) and (B).
5) Provide a B=2 toy with explicit Cin–out,Cout–out snippets and run the O(kβ^2) DP to confirm: (i) probe acceptance patterns; (ii) seam behavior on all pairs; (iii) ⊥-filling for (F2).

Why this is progress
- We now have concrete, verifiable lemmas addressing the verifier’s critiques: a radius-1, globally uniform probe family that separates 2^B types; canonical gating to single out active contexts; and a seam that enforces both edge-inequality and same-vertex equality, removing the latent ambiguity across duplicates. Each component is amenable to the O(kβ^2) DP, and the size/radius constraints stay within the β-normalized model.



=== summary.md ===

## round-0001 — model summary — 2025-08-28T11:43:33.807133Z
Goal: show NEXPTIME-hardness of the 3-way LOCAL classification for β-normalized, r=1 LCLs on oriented paths by reducing Succinct-3SAT to Feasible-Function Existence (F1). The last round (prover-04) gives a concrete reduction P_C: radius-1 gadgets (HEAD · RID · GID · RUN) plus an existential witness-chain that, when S is colored, nondeterministically selects an index i and locally verifies Hot_RID[i] and the clause bit V^{(±)}[i] via a row-by-row U-simulation. Key bounds: |Types| ≤ ℓ_pump = 2^{Θ(β^4)}, finite Z ≤ ℓ_pump^2 for (F2), and extension-check DP in O(k β^2). Neutralizing (F2) with a ⊥-filler transfers F1-hardness to the three-way classification. Correctness (completeness/soundness) sketched; remaining formal work: explicit radius-1 adjacency tables, witness-chain formalization, and a separability lemma proving distinct RID/GID yield distinct context types. Verifier verdict: partial success.

## round-0002 — model summary — 2025-08-28T11:52:38.260124Z
This round formalizes the reduction from Succinct 3-Coloring to Feasible-Function Existence for (F1) on β-normalized, radius-1 LCLs on paths. Main contributions: a radius-1 boundary-probe family Q_j that reads the j-th bit of a vertex index u (so extendibility under Q_j equals u_j), yielding ≥2^B distinct vertex context types; canonical left/right context shapes L(u), R(v) realizable at lengths ℓ_pump or ℓ_pump+1 whose types are determined by u/v; and a seam gadget that runs a universal TM U in the bridge to evaluate D(u,v) and exposes an Edge bit so the local seam enforces acceptance iff D(u,v)=0 or (D(u,v)=1 and the two S-colors differ). Adding ⊥-plumbing makes (F2) vacuous, so the 3-way classification reduces to (F1)-feasibility (hence NEXPTIME-hard). The verifier returned “partial success”: the construction is conceptually complete but key local rule tables and small-radius verification details remain to be written. Citations: prover-04.out.json, output.md.

## round-0003 — model summary — 2025-08-28T12:31:40.291283Z
This round (prover-04) pins down three auditable, radius-1 gadgets for the S3Col → FFE(F1) reduction: (1) Lemma TS: a family of reserved per-bit boundary probes Q_j with pointer heads P_j deterministically walk a nearby PORT zone and test RidBit[j], so E_{L(u)}(a⋆)[Q_j]=u_j and there are ≥2^B distinct left (and symmetrically right) canonical types; probe-mode explicitly disables error-escape. (2) Lemma CG: an ACT handshake gates non-⊥ colors at the two S nodes so only canonical vertex contexts can be colored (others must be ⊥). (3) Lemma Seam: a nearest-neighbor bridge tableau simulates a universal TM to compute EDGE = D(u,v) and enforces locally that EDGE=1 ⇒ S-colors differ (EDGE=0 accepts unconditionally). Alphabet/radius bookkeeping (O(B) reserved symbols, β = poly(s)) and a global ⊥-filler to neutralize (F2) are given. Next deliverables are explicit Cin/Cout tables and a B=2 DP regression. One remaining point to clarify: explicit left/right color-consistency (Eq) enforcement.



=== notes.md ===
Working model and notation (radius 1, β-normalized)
- We study LCLs on globally oriented paths with fixed input alphabet Σ_in and output alphabet Σ_out of size β. The local legality is given by two global relations: Cin–out relating each input symbol to allowed output symbols at a node, and Cout–out relating allowed pairs of consecutive output symbols. The radius is 1.
- A path segment w has four boundary nodes (two on the left, two on the right). For a fixed assignment to the four boundary inputs, we define the extendibility bitvector over all β^4 assignments to the four boundary outputs indicating for which boundary-output assignments there exists a legal extension to the interior.
- The type Type(w) is the collection, over all 4-boundary input assignments, of these extendibility bitvectors. Two words share a type if they have identical extendibility behavior for all boundary input/output assignments. Let T be the finite set of all types realizable by some word.

Verified technical facts (recorded in output.md)
- Type bound: |T| ≤ |Σ_in|^4 · 2^{β^4}. Reason: a type is determined by four boundary input symbols and a Boolean function on the β^4 boundary output assignments.
- Composition lemma: There is a computable binary operation ⊛ on T such that Type(uv) = Type(u) ⊛ Type(v) for all words u, v. Intuition: to decide extendibility of uv under a boundary-output assignment, one needs only (i) the extendibility tables of u and v, and (ii) existentially quantify over the two internal boundary outputs to satisfy Cout–out at the join.
- Periodicity: For any fixed word w, the sequence τ_z := Type(w^z) is ultimately periodic with preperiod and period ≤ |T|. Thus the pair sequence (Type(w1^z), Type(w2^z)) is ultimately periodic with preperiod ≤ 2|T| and period ≤ |T|.
- Finite-Z for (F2): Given any context (w1, S, w2), whether the (F2) check passes for all z ≥ 1 depends only on finitely many pairs (Type(w1^z), Type(w2^z)); it suffices to check z up to Z ≤ |T|^2 (a non-tight but simple bound).
- DP for extension: For a fixed path with some outputs forced (e.g., on S), the existence of a global completion can be decided in O(k β^2) time for a length-k path by a layered dynamic program over output symbols.

Hardness direction we will pursue (pivot suggested by Prover 01)
- Source problem: Succinct 3-Coloring of a graph G on V={0,1}^B, given by a circuit D(u,v) (size s) deciding adjacency; NEXP-complete.
- Target LCL: Construct a β-normalized, r=1 instance P_D with Σ_out size β = poly(s). The plan:
  1) For each u, build at least one context type τ_u whose boundary behavior (detected via a reserved boundary-probe) certifies that the interior encodes the index u in a standard, radius-1-checkable block. The interior also stores a copy of D on an input track and a runzone for a fixed TM U.
  2) In a bridge between τ_u and τ_v, locally simulate U on input (D,u,v) across the seam for poly(s) steps to evaluate D(u,v); malformed simulations are locally refutable.
  3) Gate constraints: if D(u,v)=0 (non-edge) allow completion regardless of colors; if D(u,v)=1 enforce color inequality across S. All other pairings (not recognized as vertex–vertex) are trivial.
  4) Assigning a color to each τ_u by a feasible function f is then exactly a proper 3-coloring of G.
  5) Make (F2) vacuous by allowing repeated sides to be filled with a globally available ⊥-plumbing language.

Open technical items for hardness (to be formalized next)
- Boundary-probe/type-separation lemma: Exhibit a fixed boundary-output probe that, when used, triggers an interior index-check subroutine; show that for distinct indices u ≠ u′, the probe’s extendibility bit differs, hence τ_u ≠ τ_{u′}.
- Seam handshake and computation: Specify the constant-size interface by which the bridge accesses (via pointers) the interior encodings of u and v and runs the 1D tableau for U for poly(s) steps, with radius-1 local checks and robust error refutations.
- Alphabet/size bookkeeping: Keep Σ_out constant tracks (roles, colors, error, U’s work alphabet) constant, with β = poly(s) sufficient for all auxiliary symbols.
- Soundness/completeness proof for the reduction P_D: G is 3-colorable iff a feasible f exists for P_D (with (F2) neutralized).

Caveats and corrections logged
- Short seam codes cannot distinguish exponentially many indices; instead use constant-size pointers/handshakes plus interior blocks that store and validate indices.
- Do not attempt to “program arbitrary boundary truth tables per type” via Cout–out; all rules are global. Use boundary probes plus uniform interior checks to separate types.
- For 3SAT-based reductions, the (F1) universal quantifier clashes with clause-level existential quantification unless one adds complex nondeterministic gating. The succinct 3-coloring pivot avoids this.
Refined hardness plan via Succinct 3-Coloring: type separation and seam simulation (radius 1)

Parameters and normalization
- Given a succinct graph instance D of size s over V={0,1}^B with B=s^{c0}, choose β=s^{c1} with c1≥c0 so β≥B and the output alphabet Σ_out has size β. The LCL instance P_D has radius 1 and is β-normalized (Cin–out global, Cout–out nearest-neighbor global). The DP and type framework from output.md applies with |T|≤|Σ_in|^4·2^{β^4}.

Canonical vertex contexts and activity gating
- We will construct canonical context shapes L(u)=W_L(u) S F_R and R(v)=F_L S W_R(v) for each u,v∈{0,1}^B such that:
  1) W_L(u) (resp. W_R(v)) is a well-formed vertex block anchored O(1) from S; it exposes a port zone of length Θ(B) immediately adjacent to S holding the index bits.
  2) Only these canonical contexts permit color tokens at S (role gating). Any context that is not a canonical vertex context is inactive: any non-⊥ token at S dead-ends locally; ⊥ at S always extends via neutral plumbing.
  3) For each u (resp. v) the type Type(L(u)) (resp. Type(R(v))) depends only on u (resp. v) via a boundary-probe mechanism detailed below. Thus we obtain at least 2^B distinct left-types and 2^B distinct right-types.

Type separation via a family of boundary probes (two workable options)
- Option A (per-bit probes Q_j with address field): Reserve B distinct boundary-output 4-tuples {Q_j : j∈[B]}. In the port zone, include an address track Addr∈[B] and a data track RID∈{0,1}. Local rules enforce that under boundary outputs Q_j the only legal continuation is a deterministic pointer that walks from the boundary to the unique port cell with Addr=j and then accepts iff RID=1 at that cell; otherwise no continuation exists. For all non-reserved boundary outputs we allow generic ⊥-plumbing so they do not affect separation. Fix a boundary-input pattern a⋆. Then for each u we have E_{L(u)}(a⋆)[Q_j]=u_j. Consequently, u≠u′ implies Type(L(u))≠Type(L(u′)). This uses O(B) extra symbols (addresses/pointer states) and remains within β=poly(s).
- Option B (mask/parity probes with M≥B tests): Reserve M boundary-output 4-tuples {b_t : t∈[M]} with M≥B. Store in the input of W_L(u) a table of M masks M_t∈{0,1}^B (with the B×M matrix of full rank over GF(2)) and the RID block u. Under boundary outputs b_t, a deterministic pointer reads M_t and then the RID block and accumulates the inner product ⟨M_t,u⟩ mod 2 using a small “RUN” zone (row-by-row locally checked). Accept iff the parity is 1. Define Sig(u)=(⟨M_t,u⟩)_t∈{0,1}^M; Sig is injective because M≥B and the masks are independent. Fixing a boundary-input a⋆, E_{L(u)}(a⋆)[b_t]=Sig(u)_t, so types differ for distinct u. Again, the probe behavior is radius-1 and β=poly(s) suffices.
- In both options, under reserved probes the control is deterministic (no error-chain escape). Outside reserved probes, error-chains and ⊥-plumbing ensure malformed interiors do not constrain f.

Seam gadget for succinct adjacency and color inequality
- In an (F1) instance on L(u) seam R(v), the bridge wb∘wc hosts a row-by-row simulation of a fixed TM U that evaluates D(u,v) in poly(s) steps:
  1) The port zones adjacent to S on each side expose the B-bit strings u and v. A small handshake track opens a corridor through wb∘wc where U’s tableau is laid out.
  2) Cout–out enforces nearest-neighbor consistency between successive rows; malformed rows are locally refutable (no accepting continuation). The run emits a verdict bit EDGE∈{0,1} at a fixed place near S.
  3) Local acceptance: If EDGE=0 (non-edge), admit completion irrespective of colors at S; if EDGE=1 (edge), admit completion iff the two color tokens at the two S nodes differ. These are radius-1 checks.
- If either side is inactive (not a canonical vertex context), a ⊥-plumbing language allows completion irrespective of the other side and the colors; however, the role gating forbids colors at S for inactive types, so mapping inactive types to a color would violate (F1) on some pair.

Neutralizing (F2)
- Add a global ⊥-filler that, for any context (w_1,S,w_2) and any z≥1, allows filling w_1^z and w_2^z entirely with ⊥ symbols, consistent with any boundary outputs and inputs, without altering the two S positions or the vertex-role gating. Then (F2) holds for every f, reducing the 3-way classification on this family to (F1)-feasibility.

Why this matches our DP/type framework
- Types are defined with respect to fixed inputs; the reserved-probe acceptance depends only on the interior index u and the chosen boundary 4-tuple, so it is type-invariant. The DP in O(kβ^2) can verify both probe behavior and seam runs on small test instances (e.g., B=2), giving a concrete auditable path.

Key cautions to enforce in the local rules
- Reserved probes must have a unique legal continuation (deterministic pointer/run); no error-chain may provide an alternative accepting path.
- Color tokens at S must be gated by the vertex role; inactive contexts cannot place colors, ensuring f is only free on canonical vertex types and ⊥ elsewhere.
- The seam gadget must accept for non-edges regardless of colors and enforce inequality for edges; malformed simulations must not accept.

Minimal sanity check (B=2)
- Use Option A with Q_1,Q_2 and an Addr track {1,2} in the port zone. For u∈{00,01,10,11}, the vector (E_{L(u)}(a⋆)[Q_1], E_{L(u)}(a⋆)[Q_2]) equals u. The seam gadget with a small circuit D (e.g., a 4-cycle) enforces inequality exactly on edges, which can be brute-forced by the DP.
Consolidated plan and corrections for the S3Col → F1 reduction (radius 1, β-normalized)

Parameters and model
- Input: succinct graph on V={0,1}^B specified by circuit D of size s. Choose β=s^{c1} with c1≥c0 so β≥Θ(B) and there is symbol budget for O(B) auxiliary symbols. All constraints are radius 1 via Cin–out and Cout–out.

Canonical vertex blocks and activity
- Left canonical block W_L(u) adjacent to S exposes a port zone of length B with two subtracks: Addr∈{1,…,B} and RID∈{0,1}. Local rules enforce Addr increases by 1 left→right and Cin–out ties RID to Σ_in. The B-bit word u is RID[1..B]. Right canonical block W_R(v) is symmetric.
- Per-side color gating (corrected): S may carry a color token {R,G,B} on a side iff the adjacent interior begins with a well-formed canonical vertex header (per-side handshake). This decision is per-side and does not depend on the opposite side. If the header is absent or malformed, the only allowed S token on that side is ⊥.
- Seam activation: The seam gadget is “active” only when both sides are canonical (both per-side handshakes present). Mixed pairs (only one side canonical) are “semi-active” and must accept unconditionally (see below), so that f may color canonical types without violating F1 on mixed pairs.

Type separation via per-bit probes (Option A)
- Reserve B distinct boundary-output 4-tuples {Q_j}. Under boundary inputs a⋆ and outputs Q_j, Cout–out forces a deterministic probe mode starting at the boundary, carrying a tagged head Head_j that moves along a pre-laid corridor to the unique cell in the port zone with Addr=j. At that cell, continuation exists iff RID=1. While in probe mode, error/⊥ symbols are forbidden from appearing adjacent to probe states; outside reserved probes, standard error/⊥ plumbing is allowed.
- Claim (TS): For any canonical left vertex word L(u), E_{L(u)}(a⋆)[Q_j]=u_j. Hence u≠u′ ⇒ Type(L(u))≠Type(L(u′)). Symmetric on the right. This uses only radius-1 locality and O(B) symbol budget.

Seam tableau and acceptance
- Active seam (both sides canonical): The bridge wb∘wc hosts a row-by-row tableau of a fixed TM U computing EDGE:=D(u,v) and Eq:=[u=v] in poly(s) steps. The last row writes (EDGE,Eq,ForwardedColor(S1)) into the cell immediately to the right of S2. Local rules between S2 and this neighbor enforce simultaneously:
  (A) if EDGE=1 then Color(S2)≠ForwardedColor(S1) (inequality on edges), else vacuous; and
  (B) if Eq=1 then Color(S2)=ForwardedColor(S1) (same-vertex consistency), else vacuous.
  Additionally, a must-color rule is enforced only in this active-active case: both S sides must be non-⊥.
- Semi-active seam (mixed pair): If exactly one side is canonical, the colored side is allowed (by per-side gating), the opposite side must be ⊥, and the seam does not activate; the pair must accept unconditionally (neutral plumbing fills the interior). This prevents mixed pairs from constraining f.
- Inactive seam (neither side canonical): Both sides must be ⊥ and the pair accepts (neutral plumbing).

F2 neutralization
- A global ⊥-filler is available on repetitions w^z, z≥1, independent of boundary outputs and inputs, and does not interfere with per-side gating or the active seam. Thus (F2) becomes trivial.

Existence/length normalization (to be formalized)
- We assume (to be proven or replaced by an explicit construction) that for each u there exists at least one left (resp. right) canonical context of length ℓ∈{ℓ_pump,ℓ_pump+1} with the port zone adjacent to S. Padding occurs outside the port zone, so probes and seam interfaces are unaffected. This step currently rests on pumping/replacement lemmas not yet included in output.md; keep it here as an assumption until proven.

Budget and locality checklist
- Alphabet: O(1) for roles/phases, colors+⊥, error alphabet, tableau alphabet; O(B) for Addr; O(B) for probe heads and reserved boundary outputs. Choose β accordingly. All constraints are radius 1 and refer only to adjacent outputs (S↔S neighbor or S↔interior neighbor).

Audit points to pin down next
- Explicit tables for probe-mode transitions and the prohibition of ERR/⊥ near probe states.
- Exact per-side handshake symbols, and the three seam modes (inactive, semi-active, active) encoded locally.
- The seam’s final cell format and the constant-size forbidden/allowed adjacency list realizing (A) and (B) above.
- A B=2 explicit instance for DP validation.


=== output.md ===
Results validated for radius-1, β-normalized LCLs on oriented paths

Why these results matter
- The decision procedures for feasible-function existence (and hence the O(1)/Θ(log* n)/Θ(n) classification on paths) rely on two ingredients: (i) that path segments admit a finite set of “types” which compose under concatenation, and (ii) that extendibility of partially labeled paths can be checked efficiently. The theorems below formalize these facts for radius 1 and yield a finite bound for the bridging (F2) checks.

Definitions (radius 1)
- Fix finite alphabets Σ_in and Σ_out (|Σ_out| = β). Cin–out ⊆ Σ_in × Σ_out specifies allowed output symbols at a node given its input symbol. Cout–out ⊆ Σ_out × Σ_out specifies allowed pairs of consecutive output symbols along the oriented path. A labeling of outputs y_1…y_k over an input x_1…x_k is legal if (x_i, y_i) ∈ Cin–out for all i and (y_i, y_{i+1}) ∈ Cout–out for all i.
- For a word w of length k ≥ 2, let the four boundary positions be i=1,2 and i=k-1,k. For a fixed assignment a ∈ Σ_in^4 to the boundary inputs (x_1, x_2, x_{k-1}, x_k), define E_w(a) ⊆ Σ_out^4 to be the set of boundary-output assignments b = (y_1, y_2, y_{k-1}, y_k) for which there exists a legal output labeling y_1…y_k extending b, given the boundary inputs a (interior inputs may be arbitrary in Σ_in; if the model fixes interior inputs, the definition is with respect to those fixed inputs). The type of w, Type(w), is the map a ↦ E_w(a). Let T be the set of all types realized by some w.

Theorem 1 (Finite number of types and an explicit bound)
Let m := |Σ_in|. For radius 1 we have |T| ≤ m^4 · 2^{β^4}.
Proof. For each fixed boundary-input assignment a there are exactly β^4 possible boundary-output assignments; E_w(a) is an arbitrary subset of these, hence at most 2^{β^4} possibilities. There are m^4 possible a’s. The type is fully determined by the tuple (a, E_w(a))_{a∈Σ_in^4}. Thus the total number of distinct types is at most m^4 · 2^{β^4}.

Lemma 2 (Composition of types under concatenation)
There is a computable binary operation ⊛: T × T → T such that for all words u, v we have Type(uv) = Type(u) ⊛ Type(v).
Proof. Fix boundary inputs a on uv, i.e., inputs on positions 1,2 and at the last two positions of uv. For each boundary-outputs choice b on uv, extendibility is equivalent to the existence of output symbols p,q ∈ Σ_out at the shared boundary between u and v (the last two outputs of u = first two of v) such that:
- (i) (Type(u) under its corresponding boundary inputs) accepts the boundary outputs given by the left two outputs of b together with p,q; and
- (ii) (Type(v) under its corresponding boundary inputs) accepts p,q together with the right two outputs of b; and
- (iii) the two internal adjacencies across the u|v seam are allowed by Cout–out (these involve only (y_{|u|-1}, y_{|u|}) = (p_left, p_right) and (p_left, p_right) = (y_1, y_2) of v, but these are exactly the p,q we quantify over).
Because radius is 1, no other interior constraints couple u and v. Thus extendibility of uv under (a,b) can be decided solely from Type(u), Type(v), and Cout–out by existentially quantifying p,q. Defining ⊛ to implement this decision for all (a,b) yields Type(uv) = Type(u) ⊛ Type(v).

Lemma 3 (Ultimate periodicity of repeated concatenation)
Fix w and let τ := Type(w). Define the sequence σ_1, σ_2, … in T by σ_z := Type(w^z). Then σ_{z+1} = σ_z ⊛ τ for all z ≥ 1. Consequently, the sequence (σ_z) is ultimately periodic with preperiod and period at most |T|.
Proof. By Lemma 2, σ_{z+1} = Type(w^{z+1}) = Type(w^z w) = Type(w^z) ⊛ Type(w) = σ_z ⊛ τ. Since T is finite, the sequence must revisit a previous value within at most |T| steps, after which it evolves deterministically with fixed period ≤ |T|.

Corollary 4 (Finite bound for the bridging (F2) check)
Let ℓ := |T|. Fix a context (w_1, S, w_2) with |S| = 2 and a forced output assignment s ∈ Σ_out^2 on S. For each z ≥ 1, consider the path w_1^z S w_2^z with S fixed to s, and let P(z) be the predicate “there exists a legal completion of outputs on w_1^z and w_2^z consistent with s.” Then P(z) depends only on the pair (Type(w_1^z), Type(w_2^z)). Moreover, it suffices to check P(z) for 1 ≤ z ≤ Z with Z ≤ ℓ^2; if all these hold then P(z) holds for all z ≥ 1.
Proof. For fixed s, feasibility is determined by whether there exist outputs on the two boundary nodes adjacent to S on each side such that the two segments extend and Cout–out holds across the two adjacencies touching S; this depends only on Type(w_1^z) and Type(w_2^z). By Lemma 3, each of the two type sequences is ultimately periodic with preperiod and period ≤ ℓ. Hence the pair sequence (Type(w_1^z), Type(w_2^z)) takes values in a set of size ≤ ℓ^2 and is ultimately periodic. If P(z) holds for one full traversal of the distinct pairs (which occurs within the first ℓ^2 indices), it holds for all subsequent z.

Theorem 5 (DP for extension on a partially labeled path)
Given a path of length k with a fixed input string and some outputs preassigned on a subset of nodes, there is an O(k β^2) time algorithm that decides whether the outputs can be completed to a legal labeling.
Proof. Construct a layered graph with k layers, each layer’s vertices being the output symbols allowed at that node by Cin–out and any preassignment. Add a directed edge from y at layer i to y′ at layer i+1 iff (y, y′) ∈ Cout–out. There exists a legal completion iff there is a path from some vertex in layer 1 to some vertex in layer k. The graph has O(k β) vertices and O(k β^2) edges; reachability is decidable in O(k β^2).

Remarks
- The bounds above are not tight (e.g., the ℓ^2 bound in Corollary 4 can be improved using lcm of periods), but they suffice for verification in exponential time in β. They also isolate exactly where only the types matter (composition and periodicity), which is crucial for hardness reductions that aim to make (F2) vacuous and focus on (F1).


=== 1811.01672v2.pdf ===

--- Page 1 ---
The distributed complexity of locally
checkable problems on paths is
decidable
Alkida Balliu · alkida.balliu@aalto.ﬁ· Aalto University
Sebastian Brandt · brandts@ethz.ch · ETH Zurich
Yi-Jun Chang · cyijun@umich.edu · University of Michigan
Dennis Olivetti · dennis.olivetti@aalto.ﬁ· Aalto University
Mika¨el Rabie · mikael.rabie@irif.fr · Aalto University and IRIF, University Paris Diderot
Jukka Suomela · jukka.suomela@aalto.ﬁ· Aalto University
Abstract. Consider a computer network that consists of a path with n nodes. The
nodes are labeled with inputs from a constant-sized set, and the task is to ﬁnd output
labels from a constant-sized set subject to some local constraints—more formally, we
have an LCL (locally checkable labeling) problem. How many communication rounds
are needed (in the standard LOCAL model of computing) to solve this problem?
It is well known that the answer is always either O(1) rounds, or Θ(log∗n) rounds,
or Θ(n) rounds. In this work we show that this question is decidable (albeit PSPACE-
hard): we present an algorithm that, given any LCL problem deﬁned on a path,
outputs the distributed computational complexity of this problem and the corresponding
asymptotically optimal algorithm.
arXiv:1811.01672v2  [cs.DC]  18 Feb 2019

--- Page 2 ---
1
Introduction
To what extent is it possible to automate the design of algorithms and the study of computational
complexity? While algorithm synthesis problems are typically undecidable, there are areas of
theoretical computer science in which we can make use of computational techniques in algorithm
design—at least in principle, and sometimes also in practice. One such area is the theory of
distributed computing; see [3, 5, 6, 9, 11, 17, 19, 26] for examples of recent success stories. In this
work we bring yet another piece of good news:
Consider this setting: there is a computer network that consists of a path with n nodes, the
nodes are labeled with inputs from a constant-sized set, and the task is to ﬁnd output labels from
a constant-sized set subject to some local constraints. We show that for any given set of local
constraints, it is decidable to tell what is the asymptotically optimal number of communication
rounds needed to solve this problem (as a function of n, for the worst-case input).
Background: LCLs and the LOCAL Model.
We focus on what are known as LCL (locally
checkable labeling) problems [22] in the LOCAL model of distributed computing [20, 24]. We deﬁne
the setting formally in Section 2, but in essence we look at the following question:
• We are given an unknown input graph of maximum degree ∆= O(1); the nodes are labeled
with input labels from a constant-size set Σin, and the nodes also have unique identiﬁers from
a polynomially-sized set.
• The task is to label the nodes with output labels from a constant-size set Σout, subject to
some local constraints P; a labeling is globally feasible if it is locally feasible in all radius-r
neighborhoods for some r = O(1).
• Each node has to produce its own output label based on the information that it sees in its
own radius-T(n) neighborhoods for some function T.
Here the local constraints P deﬁne an LCL problem. The rule that the nodes apply to determine
their output labels is called a distributed algorithm in the LOCAL model, and function T(n) is the
running time of the algorithm—here T(n) determines how far a node has to see in order to choose
its own part of the solution, or equivalently, how many communication rounds are needed for each
node to gather the relevant information if we view the input graph as a communication network.
In this setting, the case of T(n) = Θ(n) is trivial, as all nodes can see the entire input. The
key question is to determine which problems P can be solved in sublinear time—here are some
examples:
• Vertex coloring with ∆+ 1 colors: can be solved in time O(log∗n) [8, 16] and this is tight
[20, 21].
• Vertex coloring with ∆colors, for ∆> 2: can be solved in polylogarithmic time [23] and
requires at least logarithmic time [7] for deterministic algorithms.
While the study of this setting was initiated already in the seminal work by Naor and Stockmeyer
in 1995 [22], our understanding of these questions has rapidly advanced in the past three years
[1, 2, 4, 6, 7, 12–15, 25]. The big surprises have been these:
1

--- Page 3 ---
• There are LCL problems with inﬁnitely many diﬀerent time complexities—for example, we
can construct LCL problems with a time complexity exactly Θ(nα) for any rational number
0 < α ≤1.
• Nevertheless, there are also wide gaps in the complexity landscape: for example, no LCL
problem has a (deterministic) computational complexity that is between ω(log∗n) and o(log n).
However, what is perhaps most relevant for us is the following observation: if we look at the case
of ∆= 2 (paths and cycles), then the time complexity of any LCL problem is either O(1), Θ(log∗n),
or Θ(n), and the same holds for both deterministic and randomized algorithms [5, 6, 22].
Decidability of LCL Time Complexities.
For a ﬁxed ∆, any LCL problem has a trivial ﬁnite
representation: simply enumerate all feasible radius-r local neighborhoods. Hence it makes sense to
ask whether, given an LCL problem, it is possible to determine its time complexity. The following
results are known by prior work:
• If the input graph is an unlabeled path or cycle, the time complexity is decidable [5, 22].
• If the input graph is a grid or toroidal grid, the time complexity is undecidable [22]. However,
there are also some good news: in unlabeled toroidal grids, the time complexity falls in one of
the classes O(1), Θ(log∗n), or Θ(n), it is trivial to tell if the time complexity is O(1), and it
is semi-decidable to tell if it is Θ(log∗n) [5].
• In the case of trees, there are inﬁnitely many diﬀerent time complexities, but there is a gap
between ω(log n) and no(1), and it is decidable to tell on which side of the gap a given problem
lies [6].
Somewhat surprisingly, the seemingly simple case of labeled paths or cycles has remained open all
the way since the 1995 paper by Naor and Stockmeyer [22], which deﬁned LCLs with inputs but
analyzed decidability questions only in the case of unlabeled graphs.
We initially expected that the question of paths with input labels is a mere technicality and the
interesting open questions are related to much broader graph families, such as rooted trees, trees,
and bounded-treewidth graphs. However, it turned out that the main obstacle for understanding
decidability in any such graph family seems to lie in the fact that the structure of the graph can be
used to encode arbitrary input labels, hence it is necessary to ﬁrst understand how the input labels
inﬂuence decidability—and it turns out that this makes all the diﬀerence in the case of paths.
In this work we show that the time complexity of a given LCL problem on labeled paths or
cycles is decidable. However, we also show that decidability is far from trivial: the problem is
PSPACE-hard, as LCL problems on labeled paths are expressive enough to capture linear bounded
automata (Turing machines with bounded tapes).
2
Model
The LOCAL Model.
The model of computation we consider in this work is the LOCAL model of
distributed computing [20, 24]. In the LOCAL model, each node of the input graph is considered as
a computational entity that can communicate with the neighboring nodes in order to solve some
given graph problem. Computation is divided into synchronous rounds, where in each round each
node ﬁrst sends messages of arbitrary size to its neighbors, then receives the messages sent by
its neighbors, and ﬁnally performs some local computation of arbitrary complexity. Each node is
equipped with a globally unique identiﬁer (ID) which is simply a bit string of length O(log n), where
2

--- Page 4 ---
n denotes the number of nodes of the input graph. In the beginning of the computation, each node
is aware of its own ID, the number of nodes and the maximum degree ∆of the input graph, and
potentially some additional problem-speciﬁc input. Each node has to decide at some point that it
terminates, upon which it returns a local output and does not take part in any further computation;
the problem is solved correctly if the local outputs of all nodes together constitute a global output
that satisﬁes the output constraints of the given problem.
Each node executes the same algorithm; the running time of the distributed algorithm is the
number of rounds until the last node terminates. It is well known that, due to the unbounded
message sizes, an algorithm with runtime T(n) can be equivalently described as a function from
the set of all possible radius-T(n) neighborhoods to the set of allowed outputs. In other words, we
can assume that in a T(n)-round algorithm, each node ﬁrst gathers the topology of and the input
labels contained in its radius-T(n) neighborhood, and then decides on its output based solely on
the collected information.
Locally Checkable Labelings.
The class of problems we consider is locally checkable labeling
(LCL) problems [22]. LCL problems are deﬁned on graphs of bounded degree, i.e., we will assume
that ∆= O(1). Formally, an LCL problem is given by a ﬁnite input label set Σin, a ﬁnite output
label set Σout, an integer r, and a ﬁnite set C of graphs where every node is labeled with a pair
(ℓin, ℓout) ∈Σin × Σout and one node is marked (as the center). Each node of the input graph
is assigned an input label from Σin before the computation begins, and the global output of a
distributed algorithm is correct if the radius-r neighborhood of each node v, including the input
labels given to the contained nodes and the output labels returned by the contained nodes, is
isomorphic to an element of C where v corresponds to the node marked as the center.
In the case of directed paths as our class of input graphs, we are interested in identifying the
simplest possible form of LCL problems. For this purpose, we deﬁne β-normalized LCLs; these are
problems for which the input is just binary, and the size of the set of output labels is β. Moreover, the
solution can be checked at each node v by just inspecting the input and output of v, and, separately,
the output of v and the output of its predecessor. More formally, a β-normalized LCL problem is
given by ﬁnite input and output label sets Σin, Σout satisfying |Σin| = 2, |Σout| = β, a ﬁnite set
Cin −out of pairs (ℓin, ℓout) ∈Σin × Σout and a ﬁnite set Cout −out of pairs (ℓout, ℓ′
out) ∈Σout × Σout.
The global output of a distributed algorithm for the β-normalized LCL problem is correct if the
following hold:
• For each node v, we have (Input(v), Output(v)) ∈Cin −out, where Input(v) denotes the input
label of v, and Output(v) the output label of v.
• For each node v that has a predecessor, we have (Output(v), Output(u)) ∈Cout −out, where u is
the predecessor of v, and Output(v), Output(u) are the output labels of v and u, respectively.
It is straightforward to check that a β-normalized LCL problem is indeed a special case of an LCL
problem where r = 1.
3
Hardness
In this section we study the hardness of determining the distributed complexity of LCLs on paths
and cycles with input labels. More precisely, we start by proving the existence of a family Π of
LCL problems for consistently globally oriented paths, such that, given an LCL problem in Π, it is
PSPACE-hard to decide if its distributed complexity is O(1) or Θ(n). Our main result shows the
following.
3

--- Page 5 ---
L
0
0
0
0
0
0
R
q0
L
0
0
0
0
0
0
R
q1
L
1
0
0
0
0
0
R
L
R
L
R
L
R
L
R
q1
L
R
q1
q1
q1
q1
q1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
0
0
1
1
1
1
1
1
1
1
1
1
1
1
1
1
L
R
qf
1
1
1
1
1
1
a
L
L
L
R
R
R
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
T
T
T
F
F
F
F
F
F
F
F
F
F
F
F
F
F
F
F
F
F
F
F
q0
q0
q0
q0
q0
q0
q0
q0
q1
q1
q1
q1
q1
q1
q1
q1
q1
q1
q1
q1
q1
q1
q1
q1
F
· · ·
Figure 1: Illustration of a correct encoding of the execution of an LBA on a path; black nodes act as separators
between the encoding of two consecutive steps of the LBA; in the example, the LBA executes a unary counter.
It is PSPACE-hard to distinguish whether a given LCL problem P with input labels can be
solved in O(1) time or needs Ω(n) time on globally oriented path graphs.
The high level idea of the proof of the above result is as follows. We would like to encode the
execution of Turing machines as LCLs on consistently oriented paths, and then deﬁne some LCL for
which the complexity depends on the running time of the machine. This is fairly easy on oriented
grids, for example, where we can use one dimension of the grid as a tape, and the other dimension
as time. One may try to do the same on paths, by projecting everything on a single dimension,
concatenating the tape state of each step. Unfortunately, the obtained encoding is not locally
checkable, since the length of the tape may be non-constant. Hence, in order to guarantee the local
checkability, we should consider Turing machines having a tape of size at most B, where B is a
constant with respect to the number of nodes in the path where we want to encode its execution.
For this purpose, we consider Linear Bounded Automata (LBA) [18, p. 225]. An LBA is a Turing
machine that has a tape of size upper bounded by some B. We show that, if B is constant with
respect to the number of nodes in the path, we can then encode the execution of an LBA MB as
an LCL for directed paths. Moreover, we show that by seeing this encoding as a two party game
between a prover and a disprover, we can encode the execution of MB using labels of constant size
that do not depend on B, even in the case in which the LCL checkability radius is 1. If the execution
of MB is not correctly encoded in the input of the LCL, then we can disprove its correctness using
output labels of size O(B). Moreover, we ensure that, if the execution of MB is correctly encoded
in the input of the LCL, it is not possible to produce a correct proof of non-correctness. Then, in
order to obtain an LCL with a distributed complexity that depends on the execution time of MB,
we encode some secret input at the ﬁrst node of the path. We require then that all nodes involved
in a correct encoding must produce the same secret as output.
Figure 1 shows an example of an LBA that executes a unary counter, and its encoding as input
to nodes on a path. In this instance, all nodes must produce the symbol a as output. Figure 2 shows
an example of the wrong input (the tape has been copied incorrectly between two consecutive steps
4

--- Page 6 ---
a
L
L
L
R
R
R
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
1
T
T
T
F
F
F
F
F
F
F
F
F
F
F
F
F
F
F
F
F
F
F
F
q0
q0
q0
q0
q0
q0
q0
q0
q1
q1
q1
q1
q1
q1
q1
q1
q1
q1
q1
q1
q1
q1
q1
q1
F
· · ·
a
a
a
E2
E
E
E
E
E
E
E
E
E
E
E
E
a
a
a
a
0
0
E2
E2
E2
E2
E2
E2
E2
E2
E2
0
0
0
0
0
0
0
0
0
1
2
3
4
5
6
7
8
9
Input
Output
Figure 2: Illustration of an incorrect encoding of the execution of an LBA on a path; in the example, the
tape of the LBA is wrongly copied (the inputs in red are diﬀerent, while they should be the same). The error
output E2 encodes the distance of B + 1 between the two nodes, and the input wrongly copied.
3
5
Input size: 8
1
1
1
1
0
0
1
1
0
1
1
1
1
1
1
0
0
0
(⌈log 8⌉+ 1) 1s
(⌈log 8⌉+ 1) 1s
3
5
· · ·
· · ·
· · ·
· · ·
Separator
0
Separator
Figure 3: Illustration of the normalization of an LCL.
of the LBA). In this case, nodes are allowed to produce a chain of errors. Diﬀerent types of errors
will be handled using diﬀerent types of error labels. In the example, all nodes that produce the
error chain, output E2, indicating an error of type 2. We will show that we need O(B) symbols to
handle all possible errors (including the case in which the input tape is too long, way more than B).
Also, it is necessary that all error chains that we allow as outputs must be locally checkable.
Another interesting problem is to identify, for an LCL that can be distributedly solved in constant
time, how big this constant can be. In particular, we ﬁrst focus on identifying the simplest possible
description of an LCL, and then, we provide a lower bound on the complexity of a constant time
LCL, as a function of the size of the LCL description. For this purpose, we consider β-normalized
LCLs, i.e., problems for which the input labeling is just binary and there are β possible output
labels. Also, the veriﬁer for these LCLs is the simplest possible: it can only check if the output of a
node is correct w.r.t. its input, and separately, if the output of a node is correct w.r.t. the output of
its predecessor. Therefore, we show how to convert an LCL to a β-normalized one by encoding the
input in binary (Figure 3 shows an example), and obtain the following result.
There are β-normalized LCLs that can be solved in constant time but the distributed time
complexity is 2Ω(β).
All results that we have been described so far apply to globally oriented paths. Nevertheless, we
show that ideas and techniques can be generalized to work on undirected path and cycles as well,
obtaining essentially the same results. Finally, we will show how to lift these results to trees without
input labels, proving the following result.
It is PSPACE-hard to distinguish whether a given LCL problem P without input labels can be
solved in O(1) time or needs Ω(n) time on trees with degree ∆= 3.
5

--- Page 7 ---
3.1
Linear Bounded Automata
A Linear Bounded Automata MB is a Turing Machine having a bounded tape of size at most B,
such that it is able to recognize the boundaries of the tape [18, p. 225]. More formally, we deﬁne an
LBA as a tuple of 5 elements M = (Q, q0, qf, Γ, δ), where
• Q is a ﬁnite set of states;
• q0 ∈Q is the initial state;
• qf ∈Q is the ﬁnal state;
• Γ is a ﬁnite set of tape alphabet symbols that contains integers 0, 1, and special symbols L
(left), and R (right);
• δ is the transition function, where δ: Q \ {qf} × Γ →Q × Γ × {−, ←, →}.
The tape of MB is initialized as follows:
• the ﬁrst cell is marked with the symbol L;
• the last cell is marked with the symbol R;
• all other cells contain an integer in {0, 1}.
An execution of an LBA is a sequence (stepi | i ∈{1, . . . , t}), where
• stepi = (statei, tapei, headi);
• statet = qf;
• δ(statei, tapei[headi]) = (statei+1, tapei+1[headi], ϵ), and headi+1 is
– headi −1 if ϵ is ←;
– headi if ϵ is −;
– headi + 1 if ϵ is →.
3.2
The LCL Problem
We deﬁne a family Π of LCLs, in which each problem ΠMB depends on the LBA MB. The general
idea is that the input of the LCL may encode the execution of an LBA MB. If it is the case, nodes
are required to solve a problem that requires a time proportional to the execution time of MB. On
the other hand, if it is not the case, nodes can produce an output that proves that this encoding is
wrong. In order to deﬁne valid LCLs, we consider the case where B = O(1), that is, the size of the
tape does not depend on the size of the distributed network.
3.2.1
Input Labels
We deﬁne the input labels of our LCL as follows:
• Start(φ), where φ ∈{a, b}, indicates a symbol that will be used as some kind of secret;
• Separator, a label that acts as a separator between two steps of MB;
• Tape(c, s, h) gives information about the tape and the state of MB, where the content c ∈
{0, 1, L, R}, the state s ∈Q, and the head h ∈{true, false};
• Empty, indicating an empty input.
Note that the size of the set of possible input labels does not depend on the size B of the tape.
6

--- Page 8 ---
3.2.2
Encoding an LBA on a Path
Suppose we have a consistent global orientation in the path P = (p0, p1, p2, . . . , pn−1). Let step =
 stepi = (statei, tapei, headi) | i ∈{1, . . . , t}

be the execution of the LBA MB starting from a tape
initialized with (L, 0, . . . , 0, R).
Deﬁnition 1. The input of the LCL is a good input if the ﬁrst node of the path has in input
Start(φ), where φ ∈{a, b}, and the rest of the path correctly encodes the execution of an LBA MB
initialized with (L, 0, . . . , 0, R) (see Figure 1). More precisely:
• Input(p0) = Start(φ);
• Input(p(i−1)(B+1)+1) = Separator for i ∈1, . . . , t;
• Input(p(i−1)(B+1)+1+j) = Tape(c, s, h) for i ∈1, . . . , t, j ∈{1, . . . , B}, where
– c = tapei[j];
– s = statei;
– h = true if headi = j, otherwise h = false;
• All other nodes have in input Empty.
3.2.3
Output Labels
The set of output labels is the following.
• Start(φ);
• Empty;
• Error: a generic error label;
• Error0(i) where 0 ≤i ≤B + 1: an error of type 0 indicating that the machine is not correctly
initialized;
• Error1(i), where 0 ≤i ≤B: an error of type 1 that we will use in the case where the size of
the tape is not correct, i.e., when the size of the tape is not B;
• Error2(x, i), where x ∈{0, 1, L, R} and 0 ≤i ≤B + 1: an error of type 2 used when the tape
of MB is wrongly copied;
• Error3: an error of type 3 is used in case nodes have inconsistent states;
• Error4(current state, tape content, i), where 0 ≤i ≤B + 2: an error of type 4 indicating that
the transition of MB is encoded incorrectly (this error captures also the case where the head
is missing);
• Error5(x) where x ∈{0, 1}: an error of type 5 used in the case when there is more than one
head.
3.2.4
LCL Constraints
The high level idea is the following. If the path encodes a good input, then nodes that are not
labeled Empty are required to output the input given to the ﬁrst node of the path (either a or b).
Otherwise, nodes can produce a locally checkable proof of an error (see Figure 2 for an example).
While nodes may output a or b even in the case in which the input is not a good input, nodes
must not be able to produce a proof error in the case in which the path encodes a good input. We
describe all these requirements as locally checkable constraints.
An output labeling for problem ΠMB is correct if the following conditions are satisﬁed for nodes
of the path P = (p0, . . . , pn−1). Note that, although nodes do not know their position on the path,
for the sake of simplicity we will denote with pi−1 the predecessor of pi, if it exists.
7

--- Page 9 ---
1. Each node v produces exactly one output label.
2. If Output(v) = Empty then Input(v) = Empty.
3. If v has no predecessors (i.e., v = p0) and Output(v) = Start(φ), then Input(v) = Start(φ).
4. If Output(pi−1) = a then Output(pi) ̸= b, and if Output(pi−1) = b then Output(pi) ̸= a.
5. If Output(pi) = Error0(j), then
• if j = 0 then the node has no predecessor;
• if j > 0 then Output(pi−1) = Error0(j −1).
6. If Output(pi) = Error1(j), then
• if j = 0, then Input(pi) = Separator;
• if j > 0 then Input(pi) ̸= Separator and Output(pi−1) = Error1(j −1).
7. If Output(pi) = Error2(x, j), then
• if j = 0, then Input(pi) = Tape(c, s, h) where h = false, c = x;
• if j = B + 1 then Input(pi) = Tape(c, s, h) where c ̸= x;
• if 0 < j < B + 1 then Output(pi−1) = Error2(x, j −1).
8. If Output(pi) = Error3, then Input(pi) = Tape(c, s, h), Input(pi−1) = Tape(c′, s′, h′), and s ̸= s′.
9. If Output(pi) = Error4(current state, tape content, j), let (transition state, new content, ϵ) =
δ(current state, tape content)
• if j = 0, then Input(pi) = Tape(c, s, h) where c = tape content, s = current state, h = true;
• if j = B and ϵ = ←, or j = B +1 and ϵ = −, or j = B +2 and ϵ = →(i.e., if node pi is an
“Error4 ﬁnal node”), then either current state is a ﬁnal state or Input(pi) = Tape(c, s, h)
where s ̸= transition state or h = false;
• otherwise, then Output(pi−1) = Error4(current state, tape content, j −1).
10. If Output(pi) = Error5(x)
• if Output(pi−1) ̸= Error5 then Input(pi) = Tape(c, s, h) where h = true and x = 0.
11. If Output(pi) = Error then one of the following condition holds:
• Input(pi) ̸= Start(φ) and pi has no predecessors;
• Input(pi) = Start(φ) and pi has a predecessor;
• Input(pi−1) or Output(pi−1) is Empty;
• Output(pi−1) = Error;
• Output(pi−1) = Error0(j), j > 0, and
– if j = 1 then Input(pi−1) ̸= Separator;
– if j ≥2 then either Input(pi−1) ̸= Tape, or Input(pi−1) = Tape(c, s, h) and:
∗if j = 2 either c ̸= L, or s ̸= q0 or h = false;
∗if 2 < j ≤B either c ̸= 0, or s ̸= q0 or h = true;
8

--- Page 10 ---
∗if j = B + 1, either c ̸= R, or s ̸= q0 or h = true;
• Input(pi) = Separator and Output(pi−1) = Error1(x) where x ̸= B;
• Input(pi) ̸= Separator and Output(pi−1) = Error1(B);
• Output(pi−1) = Error2(x, j) where j = B + 1;
• Output(pi−1) = Error3;
• pi−1 is an “Error4 ﬁnal node”;
• Output(pi−1) = Error5(x) and Input(pi−1) = Tape(c, s, h) where h = true and x = 1.
12. If Output(pi) is of type Errorx, then Output(pi−1) must not be of type Errory where y ̸= x.
The following property directly holds by deﬁnition of the constraints.
Property 1. Each node is able to locally check all constraints by just inspecting its own input and
output, and the ones of its predecessor (if it exists).
3.3
Upper Bound on the Complexity of the LCL
We need to consider two possible scenarios: either MB terminates within time T, or MB loops. In
the case in which MB loops, we show a simple O(n) algorithm that solves the LCL ΠMB. As we
know, any problem for which a solution exists can be solved in O(n) rounds in the LOCAL model by
gathering all the graph and solving the problem locally. There always exists a solution for problem
ΠMB if MB loops, in fact:
• If Input(p0) = Start(φ), then all nodes output φ, even if there are errors in the machine
encoding.
• Otherwise, if Input(p0) ̸= Start(φ), all nodes output Error.
It is easy to see that this output satisﬁes the LCL constraints described above.
Suppose that MB terminates. In this case, we show how to solve the LCL problem ΠMB in
constant time. More precisely, if MB terminates in T rounds, we show a distributed algorithm that
solves ΠMB in T ′ = 2+(B +1)T rounds. Each node v starts by gathering its T ′-radius neighborhood
Bv(T ′). Notice that, by deﬁnition, if the input is a good input, then for each node v that is taking
part in the encoding of the execution of MB (i.e., Input(v) ̸= Empty), Bv(T ′) contains p0. Hence, if
a node v does not see p0 after gathering its ball Bv(T ′), it means that the input is not a good input.
So, after gathering its T ′-radius ball, each node v does the following.
• If Input(v) = Empty, then Output(v) = Empty.
• If Bv(T ′) does not contain p0, or if Input(p0) ̸= Start(φ), then v outputs Error.
• If Bv(T ′) is a good input, then v outputs Start(φ).
The remaining case that we still need to handle is when Bv(T ′) contains p0, Input(p0) = Start(φ),
but Bv(T ′) does not look like a good input. We want nodes to produce a proof of an error in some
consistent way. Thus, we show that nodes can identify the ﬁrst error and produce a proof based on
that. First of all, notice that, since v sees the ﬁrst node in the path, v can compute its position i on
the path. Also, node v can identify who is the ﬁrst node u not satisfying the constraints of being a
good input. Let j be the position of u in the path, that is u = pj. Now we distinguish the following
cases based on Bu(B + 2) (the output of each node will be determined by the ﬁrst case encountered
in the following list).
9

--- Page 11 ---
1. If Input(pj) = Start(φ) and j ̸= 0, then, if i < j, Output(v) = Start(φ); otherwise Output(v) =
Error.
2. If j ≤B + 1, it means that either the initial state is encoded incorrectly, or the tape is not
initialized correctly, or the head is not initialized on the correct position. In this case, if i ≤j,
then Output(v) = Error0(i), otherwise Output(v) = Error.
3. If Input(pj−(B+1)) = Separator and Input(pj) ̸= Separator, then the length of the tape is too
long, and u expected to have in input Separator. Then, if i < j −(B +1), Output(v) = Start(φ);
if i > j then Output(v) = Error; otherwise, Output(v) = Error1(i −j + B + 1).
4. If Input(pj) = Separator and there exists a k such that 1 ≤j −k < B + 1 such that
Input(pk) = Separator, then the length of the tape is too short, and u did not expect to have a
separator. In this case, if i < k then Output(v) = Start(φ); if i ≥j then Output(v) = Error;
otherwise Output(v) = Error1(k −i).
5. If Input(pj−(B+1)) = Tape(c, s, h) where h = false, c = x, and Input(pj) = Tape(c′, s′, h′), where
c′ ̸= x, then the tape of MB has been copied incorrectly. In this case, if i < j −(B + 1), then
Output(v) = Start(φ); if i > j then Output(v) = Error; otherwise, Output(v) = Error2(x, i −j +
B + 1).
6. If Input(pj) = Tape(c, s, h) and Input(pj−1) = Separator and there exists a k < j + B such
that Input(pk) = Tape(c′, s′, h′) and that s ̸= s′, it means that nodes have inconsistent states.
Consider the minimum k satisfying the constraints. If i < k then Output(v) = Start(φ); if
i > k then Output(v) = Error; otherwise, Output(v) = Error3.
7. If none of the above is satisﬁed, it means that there exist a k satisfying j −k ≤B +2, such that
Input(pk) = Tape(c, s, h) and h = true. Let (transition state, new content, ϵ) = δ(s, c). It holds
that if ϵ is ←, −, or →, then j−k is respectively B, B+1, or B+2. If Input(pj) = Tape(c′, s′, h′),
where either h′ = false, or transition state ̸= s′, or s is a ﬁnal state, then there is some
error in the transition (this captures also the case where there is no head). If i < k, then
Output(v) = Start(φ); if i > j then Output(v) = Error; otherwise, Output(v) = Error4(s, c, k−i).
Notice that this case captures also the one where the head is missing.
8. If Input(pj) = Tape(c, s, h) where h = true, since all the above cases are not satisﬁed, it means
that there exists a k, such that Input(pk) = Tape(c′, s′, h′), h′ = true, |j −k| < B and all nodes
pmin(j,k), . . . , pmax(j,k) are labeled with some Tape. That is, there are at least two heads, one
on node pj and one on node pk. In this case, if i < min(j, k), then Output(v) = Start(φ); if
i > max(j, k) then Output(v) = Error; if i = min(j, k) then Output(v) = Error5(0), otherwise
Output(v) = Error5(1).
If the path encodes a good input, every node taking part in the encoding of the execution of MB
outputs Start(φ), and in this case it is easy to see that the output satisﬁes the LCL constraints.
Therefore, assume that the path does not correctly encode the execution of MB starting from
the correct tape content. First of all, notice that the algorithm handles all possible errors in the
machine encoding, that is, if the input is not good, at least one case of the list applies. Consider
all nodes v that do not have in input Empty, that is, all nodes taking part in the encoding of the
execution of MB. If node v sees the ﬁrst node p0, i.e., if the distance between p0 and v is at most
T ′ (notice that a good input has length T ′), then it is easy to see that the output satisﬁes the LCL
constraints. Some care is needed in the case where a node v outputs a generic error Error and v
does not see p0: we need to show that also in this case the output is valid, meaning that the LCL
10

--- Page 12 ---
constraints are satisﬁed. In this case, the distance between p0 and v is strictly greater than T ′, and
since the encoding of the execution of MB is not correct, then
• either the path (p0, . . . , v) does not correctly encode the execution of MB,
• or MB is not correctly initialized and it loops.
In the ﬁrst case, some node on the path between p0 and v will output some speciﬁc error Errorx where
x > 0, while in the second case initial nodes will output Error0. In both scenarios the constraints for
Error are satisﬁed. The complexity of the algorithm is O(B · T).
3.4
Lower Bound on the Complexity of the LCL
Let us deﬁne T ′′ as follows. If MB terminates in time T, then T ′′ = T ′ = 2 + (B + 1)T. If MB loops,
then T ′′ = n. We prove a lower bound on the complexity of ΠMB of Ω(T ′′) rounds, by showing that
Ω(T ′′) rounds are needed in the case where the input is a good input. In particular, we show that,
in a good input, for all nodes v such that Input(v) ̸= Empty, Output(v) must be Start(φ). The result
then comes from the fact that, for some nodes, it requires Ω(T ′′) rounds in order to see if φ = a or
φ = b.
First of all, we ignore nodes that have in input Empty since, in a good input, they are at distance
at least T ′′ + 1 from p0, the ﬁrst node of the path. Hence, assume that a node v not having Empty in
input does not output Start(φ). In this case, v can either output a generic error Error, or a speciﬁc
error Errorx. If all nodes output Error, the veriﬁer rejects on p0. If all nodes, starting from a node
pi where i > 0, output Error, and all nodes pi′ with i′ < i output Start(φ), then the veriﬁer rejects
on pi. Therefore, let us assume that there is at least a node that outputs a speciﬁc error Errorx. We
write succ(v) and dist(u, v) to denote respectively the successor of a node v in the path, and the
distance between two nodes u and v in the path.
• If x = 0, the veriﬁer accepts only if this error produces a chain that starts from p0 and
proceeds with increasing values. In order to be accepted, this chain must end at a node w′,
and succ(w′) must output Error. Then, succ(w′) must witness that w′ indeed has a local error
in the machine initialization, which is not possible in a good input.
• If x = 1, we could have two cases:
– there is a chain of increasing values that starts from a node w with Input(w) = Separator,
and ends on a node w′ such that dist(w, w′) < B, Input(succ(w′)) = Separator, and
Output(succ(w′)) = Error (the tape is too short);
– there is a chain of increasing values that starts from a node w with Input(w) = Separator,
and ends on a node w′ such that dist(w, w′) = B, Input(succ(w′)) ̸= Separator, and
Output(succ(w′)) = Error (the tape is too long).
Since, in a good input, the distance between two nodes having in input Separator is always
B + 1, the above scenarios are not possible.
• If x = 2, there must be a chain of length exactly B + 1, starting from a node w having
Input(w) = Tape(c, s, h), where c = x ∈{0, 1}, h = false, and ending on a node w′ such that
dist(w, w′) = B + 1, and Input(w′) = Tape(c′, s′, h′), where c′ ̸= x. In a good input, the tape
content of nodes w and w′ must be the same.
• If x = 3, it means that there must exist two neighbors having two diﬀerent states, and this
can not happen in a good input.
11

--- Page 13 ---
• If x = 4, there must be a chain that propagates the old state and old input, and the veriﬁer
accepts only if acknowledges that the transition has been wrongly encoded, which can not the
case in a good input.
• If x = 5, there must be a chain of length at least 2 not passing through nodes having in input
Separator, starting from a node w with Input(w) = Tape(c, s, h) where h = true, and ending
on a node w′ with Input(w′) = Tape(c′, s′, h′) where h′ = true. This is not possible on a good
input.
Therefore, since nodes can not output any kind of error, and since Empty is not a valid output for
the nodes encoding the LBA, then these nodes must output Start(φ), where the value of φ matches
the input of the ﬁrst node of the path. Hence, ΠMB requires Ω(T ′′).
3.5
Normalizing an LCL Problem
We now show how to β-normalize an LCL ΠMB and obtain a new LCL having roughly the same time
complexity. We deﬁne three diﬀerent veriﬁers depending on their view.
• A Vin,in −out,out veriﬁer running at node v, checks Input(v), Input(pred(v)), Output(v), and
Output((pred(v)).
• A Vin −out veriﬁer running at node v, checks Input(v) and Output(v).
• A Vout −out veriﬁer running at node v checks Output(v) and Output((pred(v)).
Lemma 2. Consider an LCL P with |ΣP
in| = α and |ΣP
out| = β that can be solved in time T and can
be locally checked with a Vin,in −out,out veriﬁer. It is possible to deﬁne an LCL P′ such that |ΣP′
in | = α
and |ΣP′
out| = α · β that can be solved in time T and can be locally checked with a Vin −out and a
Vout −out veriﬁer.
Proof. We deﬁne ΣP′
in = ΣP
in, and ΣP′
out = ΣP
out × ΣP
out. Let Output(v) = (in, out) ∈ΣP′
out. Let
Output(pred(v)) = (in′, out′) ∈ΣP′
out. The Vin −out veriﬁer checks that Input(v) = in. The Vout −out
veriﬁer acts the same as the Vin,in −out,out veriﬁer executed on ((in′, out′), (in, out)). The LCL problem
P′ can be solved with the following algorithm at each node v.
• Gather the ball Bv(T).
• Simulate the original algorithm on Bv(T); let out be the output of this simulation.
• Output (Input(v), out).
It is easy to check that this output is valid for the problem P′, and that it requires T rounds. Also,
note that it is not possible to solve P′ faster than T. In fact, in order to satisfy the Vin −out veriﬁer,
the input must be copied correctly; while in order to satisfy the Vout −out veriﬁer, we need to satisfy
the Vin,in −out,out veriﬁer executed giving the same input that it would have seen on P.
Lemma 3. Consider an LCL P with |ΣP
in| = α and |ΣP
out| = β that can be solved in time T and can
be locally checked with a Vin −out and a Vout −out veriﬁer. We can deﬁne a β′-normalized LCL P′
with β′ = |ΣP′
out| = 2γ · (|ΣP
out| + 3) that can be solved in time Θ(γ · T(n/γ)), where γ = 2⌈log α⌉+ 3.
Proof. In the following we will exploit the ability of an algorithm to work on identiﬁers that can
be polynomial in the size of the graph. In particular, we assume that if an algorithm works on an
instance with IDs in the range 1, . . . , r, then it works also on an instance with IDs in the range
1, . . . , γ · r. Then, we show how to deﬁne an LCL P′ such that:
• if the input instance encodes a virtual instance for the problem P, it is required to solve P on
the virtual instance;
12

--- Page 14 ---
• otherwise, it is required to prove that the encoding is wrong.
Let V′
in −out and V′
out −out be the veriﬁers of our β′-normalized LCL.
Encoding P in P′.
We start by deﬁning how to encode an instance of P of size n, as an
instance of P′ of size N = γ · n. We denote with p0, . . . , pn−1 and p′
0, . . . , p′
γ·n−1 respectively the
instance of P and the one of P′. Let a = ⌈log α⌉. For the sake of simplicity, let us rename nodes
p′
γi, . . . , p′
γ(i+1)−1, where 0 ≤i ≤n −1, as qi
0, . . . , qi
2a+2 (notice that 2a + 2 = γ −1). The ﬁrst a + 1
nodes, qi
0, . . . , qi
a, have input 1, while nodes qi
a+1 and qi
2a+2 have input 0. Each of the remaining a
nodes, qi
a+2, . . . , qi
2a+1, has in input one bit of the binary representation of Input(pi), in some ﬁxed
order (see Figure 3 for an illustration).
The V′
in −out Veriﬁer.
The set of output labels of P′ is ΣP′
out = 2γ × (Σout ∪{Er, E, El}). Let qi
j
be a node of the instance of P′ where 0 ≤i ≤n −1 and 0 ≤j ≤2a + 2. Let Input(qi
j) ∈{0, 1}, and
let Output(qi
j) = ((b0, . . . , b2a+2), out) ∈ΣP′
out. The V′
in −out veriﬁer running at qi
j checks that
• Input(qi
j) = b0, and
• if out ∈ΣP
out, then
– if all bits in b0, . . . , ba are 1s, checks that the original Vin −out veriﬁer accepts on
(x, out), where x is obtained by recovering the input pi for the original algorithm from
ba+2, . . . , b2a+1.
The V′
out −out Veriﬁer.
Let the output of pi
j be ((b0, . . . , b2a+2), out) ∈ΣP′
out and the output of
the predecessor of pi
j be ((b′
0, . . . , b′
2a+2), out′) ∈ΣP′
out The O-O veriﬁer ﬁrst checks that
• b0 = b′
1, b1 = b′
2, . . . , b2a+1 = b′
2a+2, and
• if out ∈ΣP
out and out′ ∈ΣP
out, then
– if at least one bit in b0, . . . , ba is 0 , then out = out′,
– if all bits in b0, . . . , ba are 1s, then check that the original Vout −out executed on (out′, out)
accepts.
Dealing with Errors.
We now add some constraints to handle the case in which out /∈
ΣP
out. Let the output of pi
j be ((b0, . . . , b2a+2), out) and the output of the predecessor of pi
j be
((b′
0, . . . , b′
2a+2), out′). The V′
in −out veriﬁer additionally checks that, if out = E, then the encoding is
not locally valid, that is,
• either
– there are two numbers x, y ≥0, x + y ≤a, such that b0, . . . , bx−1 and b2a+3−y, . . . , b2a+2
are all equal to 1, bx = 0, b2a+2−y = 0, and
– there is not a contiguous sequence of length a + 1 of all 1s in b0, . . . , b2a+2,
• or b0, . . . , ba are all 1s but either ba+1 ̸= 0 or b2a+2 ̸= 0.
The V′
out −out veriﬁer running on pi
j additionally checks that,
• if out = El, then pi
j must have a predecessor, and it must hold that out′ /∈{Er} ∪ΣP
out;
• if out ∈ΣP
out, if pi
j has a predecessor, then out′ must be diﬀerent from Er;
• if out = Er, then pi
j must have a successor.
13

--- Page 15 ---
Let N be the size of the graph. An algorithm solving P′ in (γ + 1) · T rounds does the following at
each node v′:
• Gather the ball Bv′((γ + 1) · T).
• If Bv′((γ + 1) · T) looks like a correct encoding of an input instance of P
– let u′ be the nearest left node having input 1 and other a successors, succ(1)u′, . . . , succ(a)u′,
having also input 1
– Compute the virtual instance for P (setting the IDs to be the same of the nodes satisfying
the above)
– Simulate the original algorithm on the virtual instance by setting n = N/γ, let out be
the output of u′
– Output ((Input(v′), Input(succ(1)v′), . . . , Input(succ(γ−1)v′), out)
• Otherwise,
– if there is a local error, output E
– if the nearest error is on the left, output El
– otherwise, output Er
It is easy to check that the output of the algorithm satisﬁes the constraints. In order to show a
lower bound for the new LCL, we now show that it is not possible to produce errors in a graph
that is a valid encoding. In fact, nodes can not cheat by wrongly outputting the input of the
neighbors, otherwise either the input-output veriﬁer notices inconsistencies on the ﬁrst bit, or the
output-output veriﬁer notices inconsistencies on the other bits. Then, on a valid encoding, no input
satisﬁes the constraints that allows to produce E as output. Finally, the constraints impose that a
chain of Er or El points to a node that is outputting E.
Note that, if the original LCL has complexity T, then the new LCL, on instances of size N = γ ·n,
has complexity Θ(γ(T(n))) = Θ(γ · T(N
γ )).
3.6
Hardness Results
Theorem 4. There are β-normalized LCLs that can be solved in constant time but the distributed
time complexity is 2Ω(β).
Proof. The complexity of ΠMB is Θ(B · T) if MB terminates in T steps.
|Σin| = O(1) and
|Σout| = Θ(B). We can convert it to an LCL where |Σin| = 2, |Σout| = Θ(B), and the complexity is
still Θ(B · T). There exist LBAs that terminate in 2Θ(B) steps (e.g. a binary counter). Thus, the
complexity of the obtained LCL is Θ(B · 2Θ(B)), that is 2Ω(B) = 2Ω(|Σout|) = 2Ω(β).
Theorem 5. It is PSPACE-hard to distinguish whether a given LCL problem P with input labels
can be solved in O(1) time or needs Ω(n) time on globally oriented path graphs.
Proof. It is PSPACE-hard to distinguish whether a given LBA terminates or loops (see e.g. [10]).
Note that the description of a β-normalized LCL has size O(β2). In order to decide if a β-normalized
version of a problem in Π requires O(1) or Ω(n) we need to decide if its associated LBA, running on
a tape of size B = Θ(β), terminates or loops, and this implies the theorem.
14

--- Page 16 ---
3.7
Extending the Results to Undirected Cycles
We show how to extend the above results, which apply to globally oriented paths, to the case where
the input graph is an undirected path or an undirected cycle. We ﬁrst focus on showing how to
adapt these results to undirected paths. Given a β-normalized LCL P deﬁned on directed paths,
we can deﬁne an LCL P′ in which the set of input labels is Σ′
in = {0, 1} × {0, 1, 2}, and the set of
output labels is Σ′
out = {0, 1, 2} × {1, . . . , β, E}. Let Vin −out and Vout −out be the veriﬁers of the
β-normalized LCL P, and let V′
in −out and V′
out −out be the veriﬁers of the LCL P′. The idea is that
we can use 3 symbols to give an orientation as input to the nodes, by giving 0 to the ﬁrst node, 1 to
the second, 2 to the third, 0 to the fourth, and so on. Nodes must copy their orientation number to
the output, and then, if the given orientation is consistent, nodes are required to solve the original
problem P. On the other hand, if the orientation is not consistent, nodes are allowed to output an
error E. Also, in order to avoid the need of error pointers, we allow nodes to treat the places where
the orientation is not consistent, as a place where the path ends.
This new LCL can be checked as follows. The V′
in −out veriﬁer takes in input the input and
the output of the current node (as before) and ﬁrst checks that the orientation has been copied
correctly, and then checks that the original Vin −out veriﬁer accepts. To verify the output, we allow
the V′
out −out veriﬁer to see slightly more than the original veriﬁer Vout −out. The V′
out −out veriﬁer
sees a triple containing the output of the node and the outputs of its neighbors. Note that the
veriﬁer does not know the orientation of the path (and the orientation of the triple), but it can
recover it from the output of the nodes (that contains a copy of the orientation given as input).
Then the V′
out −out veriﬁer checks that, if the node outputted E, the orientation is indeed wrong. If
the output is a value in 1, . . . , β, the veriﬁer V′
out −out runs the original Vout −out veriﬁer, since it
can compute which neighbor is the predecessor. It is easy to see that the complexity of P′ is the
same as the one of P.
The LCL description of P′, that is, the size of its input, its output, and its veriﬁer, is now O(β3),
therefore the hardness result still applies.
We now show how an LCL for paths can be converted to an LCL for cycles. The idea is the
following. On a cycle, we give an additional input to each node in {0, 1}. Nodes marked as 1 are
exempt to solve the problem and act as separators between the other nodes. That is, nodes are
required to solve the original problem on the subpaths that lie between nodes marked as 1. It may
be the case that no node has 1 as input. In this case we allow nodes to output a special error. If a
node decides to output this error, both its neighbors must output the same, that is, all nodes must
output the same. We impose the constraint that a node marked as 1 can not output this error. A
worst case instance would be the one in which one node is marked 1 and all other nodes are marked
0—this would represent a path with a length that is roughly equal to the one of the cycle. There
is one case that requires a bit of care: if all nodes are marked 0, but the original problem can be
solved in sublinear time, nodes could not be able to coordinate to produce the special error. For our
purpose, it is possible to check that, if we consider the problem ΠMB previously deﬁned in the case
in which MB terminates, in an instance in which nobody has a predecessor, nodes can eﬃciently
solve the problem by just outputting Error or Empty, depending on their input.
3.8
Encoding Input Labels as Trees
In this section we demonstrate a reduction from the LCL problem P with input labels on any graph
G to an LCL problem P⋆without input labels on the modiﬁed graph G⋆. The modiﬁed graph G⋆
is the result of attaching a rooted tree to each v ∈V (G) that encodes the input label of v for the
LCL problem P. The reduction allows us to extend the hardness proof to the case of LCL problems
15

--- Page 17 ---
without input labels.
Encoding.
Given a 2k-bit binary string S = (s1, . . . , s2k), deﬁne Enc(S) as the rooted tree
constructed as follows.
• Begin with the full binary tree which has 2k leaves, and the distance from the root to each
leaf is k.
• For each non-leaf node v, let u be any one of its two children, and subdivide the edge {v, u}
into two edges {v, w} and {w, u}, where w is a new node. The node w is designated as the
left child of v.
• Let U = (u1 . . . , u2k) be the leaves ordered by the in-order traversal.
• For each i ∈[2k], add two new nodes x and y as the children of ui. If si = 1, add two more
new nodes x′ and y′ and the two edges {x, x′} and {y, y′}.
The tree Enc(S) has maximum degree 3, and all nodes are within distance 2(k + 1) to the root.
Given a graph G such that each node v ∈V (G) is associated with an input label L(v) ∈Σin, deﬁne
G⋆as the graph resulting from the following operations on G. For each node v ∈V (G), attach the
rooted tree T = Enc(L(v)) to v by adding the edge {v, z}, where z is the root of T. Notice that
∆(G⋆) = max{3, ∆(G) + 1}.
Decoding.
Given a rooted tree T = Enc(S) for some S ∈{0, 1}2k, deﬁne Dec(T) = S. The
decoding can be done by the following procedure. Consider an in-order traversal of the tree such
that (i) for each node v such that exactly one of its children w has degree 2, treat w as the left child
of v, (ii) print ‘1’ if a node that has two children of degree 2 is encountered, (iii) print ‘0’ if a node
that has two children of degree 1 is encountered. Then the printed sequence is S.
The Modiﬁed LCL Problem P⋆.
Let P be an LCL problem with input labels. Suppose that
the radius of P is r, and the maximum degree is ∆. Set k = ⌈log log |Σin|⌉, and let each label in Σin
be represented by a distinct 2k-bit string. The modiﬁed LCL problem P⋆, which does not require
input label, is deﬁned by the following rules. The set of the output labels of P⋆is Σout, the same as
that of P. Let G⋆be a graph with maximum degree ≤∆+ 1.
• Deﬁne G1 = G⋆.
For each 2 ≤i ≤k + 2, deﬁne Gi as the graph induced by nodes in V (G⋆) −Si−1
j=1(Aj ∪Bj).
For each i ∈[k + 2], deﬁne Ai = {v ∈V (Gi)| degGi(v) = 1}.
For each i ∈[k + 1], deﬁne Bi = {v ∈V (Gi)| degGi(v) = 2 and ∃u ∈Ai s.t. {u, v} ∈E(Gi)}.
• Deﬁne Vlabel = Sk+2
j=1 Aj ∪Sk+1
j=1 Bj.
Deﬁne Vmain as the set of nodes in V (G⋆) \ Vlabel that have exactly one neighbor in Vlabel.
• For each v ∈Vmain, deﬁne L(v) as follows. Let u be the unique node in Vlabel adjacent to
v, and let T be the connected component induced by nodes in Vlabel that contains u. Set
L(v) = Dec(T) (with u being the root of T). If the decoding procedure Dec(T) fails, simply
set L(v) as the ﬁrst label in Σin.
• The output labeling, together with the input labeling deﬁned by the function L(·), forms a
legal labeling of the subgraph induced by the nodes in Vmain for P.
16

--- Page 18 ---
Notice that the connected components in Vlabel are the trees encoding input labels, and the subgraph
induced by the nodes in Vmain is G (as long as G does not contain isolated node). The function L(v)
recovers the input label of v for each v ∈V (G). Given that P has a valid labeling on all graphs
(resp., trees) of maximum degree ∆, the modiﬁed LCL problem P⋆also has a valid labeling on all
graphs (resp., trees) of maximum degree ∆+ 1.
Reducing the Radius.
The above deﬁnition of P⋆requires radius r + O(k), as a node v ∈Vmain
needs O(k) extra rounds to calculate L(u) for all u ∈Nr(v)∪Vmain. We present a simple modiﬁcation
that reduces the radius to only r + O(1) at the cost of expanding the number of output labels from
|Σout| to |Σout| + 22k < |Σout| + |Σin|2. The idea is to let nodes in Vlabel to use output labels to
pass the information stored at the leaves to the root based on local rules. Consider a connected
component T induced by nodes in Vlabel. The subgraph T is interpreted as a tree rooted at the
unique node in T that is adjacent to some node in Vmain.
Base Case: Let v ∈A2. If v is adjacent to two nodes in B1, the output label of v is 1; otherwise
the output label of v is 0.
Root / Degree-3 Nodes: Let 3 ≤i ≤k + 2, and let v ∈Ai. Then v has a unique neighbor
uleft ∈Bi+1 and a unique neighbor uright ∈Ai+1. Let Sleft be the output label of uleft, and let
Sright be the output label of uright. Then the output label of v is the binary string Sleft ◦Sright.
Degree-2 Nodes: Let 3 ≤i ≤k + 1, and let v ∈Bi. Then v has a unique neighbor u ∈Ai+1. The
output label of v is the same as the output label of u.
Thus, for each node v ∈Vmain, L(v) is simply the output label of the unique node u ∈Vlabel ∩N(v).
Theorem 6. For any LCL problem P on any graph G of maximum degree ∆that does not have
isolated nodes, the following two statements are equivalent.
• The labeling L: V (G) →Σout is a valid labeling of G for the problem P.
• There exists some labeling L′ of the nodes in Vlabel such that L and L′ together form a valid
labeling of G⋆for the problem P⋆.
Theorem 7. It is PSPACE-hard to distinguish whether a given LCL problem P without input labels
can be solved in O(1) time or needs Ω(n) time on trees with degree ∆= 3.
4
Decidability
In this section, we show that the two gaps ω(1)—o(log∗n) and ω(log∗n)—o(n) for LCL problems
with input labels on paths and cycles are decidable. More speciﬁcally, given a speciﬁcation of an
LCL problem P, there is an algorithm that outputs a description of an asymptotically optimal
deterministic LOCAL algorithm for P, as well as its time complexity.
We will prove the statements for the case of cycles, but the analogous results for cycles and paths
follows as a simple corollary, as we can encode constraints related to degree-1 nodes as constraints
related to nodes adjacent to a special input label. Furthermore, having a promise that the input is
a path does not change the time complexity of an LCL problem: if a problem can be solved in time
T = o(n) in labeled paths, the same algorithm will solve it also in time T = o(n) in labeled cycles.
The proof of Theorem 8 is in Section 4.2; the proof of Theorem 9 is in Section 4.5.
17

--- Page 19 ---
Theorem 8. For any LCL problem P on cycle graphs, its deterministic LOCAL complexity is either
Ω(n) or O(log∗n). Moreover, there is an algorithm that decides whether P has complexity Ω(n)
or O(log∗n) on cycle graphs; for the case the complexity is O(log∗n), the algorithm outputs a
description of an O(log∗n)-round deterministic LOCAL algorithm that solves P.
Theorem 9. For any LCL problem P on cycle graphs, its deterministic LOCAL complexity is either
Ω(log∗n) or O(1). Moreover, there is an algorithm that decides whether P has complexity Ω(log∗n)
or O(1) on cycle graphs; for the case the complexity is O(1), the algorithm outputs a description of
an O(1)-round deterministic LOCAL algorithm that solves P.
Graph Notation.
For convenience, in this section, a directed path P with input labels is
alternatively described as a string in Σk
in, where k > 0 is the number of nodes in P. Similarly,
an output labeling L of P is alternatively described as a string in Σk
out. In subsequent discussion,
we freely switch between the graph-theoretic notation and the string notation. Given an output
labeling L of P, we say that L is locally consistent at v if the input and output labeling assigned to
Nr(v) is acceptable for v. Note that Nr(v) refers to the radius-r neighborhood of v. Given two
integers a ≤b, the notation [a, b] represents the set of all integers {a, a + 1, . . . , b}. Given a string
w, denote wR as the reverse of w.
Overview.
Before we proceed, we brieﬂy discuss the high level idea of the proofs. The main tool
underlying the proofs is the “pumping lemma” which was developed in [6]. Intuitively, we classify
the set of all input-labeled paths into a ﬁnite number of equivalence classes satisfying the following
property. Let P be a subpath of G, and let P ′ be another path that is of the same equivalence
class as P. Given a complete legal labeling of G, if we let G′ be the result of replacing P with
P ′, then it is always possible to extend this partial labeling of G′ to a complete legal labeling by
appropriately labeling P ′. The pumping lemma guarantees that for any path P whose length is
at least the pumping constant ℓpump, and for any number x ≥ℓpump, there is another path P ′ of
length at least x and P ′ is of the same equivalence class as P.
Informally, in the proof of Theorem 8, we show that any LCL problem P solvable in o(n) rounds
can be solved in O(log∗n) rounds in the following canonical way based on a “feasible labeling
function” f. Intuitively, a labeling function f is feasible if for any given independent set I that is
suﬃciently well-spaced, we can apply f to assign the output labels to each v ∈I and its nearby
neighbors locally such that this partial labeling can always be extended to a complete legal labeling.
The ω(log∗n)—o(n) gap and the decidability result follows from these two claims.
• If there is an o(n)-round algorithm A that solves P, then a feasible function f exists. This
is proved by ﬁrst create an imaginary graph where some paths are extended using pumping
lemmas, and then apply a simulation of A on the imaginary graph.
• Whether a feasible function exists is decidable. Intuitively, this is due to the fact that the
number of equivalence classes is ﬁnite.
The proof of Theorem 9 is a little more complicated since the time budget is only O(1), so
we cannot even aﬀord to ﬁnd an MIS. To solve this issue, we decompose the cycle graph G into
paths with unrepetitive patterns and paths with repetitive patterns, in O(1) rounds. For paths
with unrepetitive patterns, we are able to compute a suﬃciently well-spaced MIS in O(1) rounds
by making use of the irregularity of the input patterns. Paths with repetitive patterns are similar
to the paths without input labels, and we will show that we can always label them by repetitive
output patterns, given that the underlying LCL problem is o(log∗n)-time solvable.
18

--- Page 20 ---
𝑠
𝑡
𝐷1
𝐷1
𝐷2
𝐷2
𝐷3
𝑠
𝑡
𝐷1
𝐷1
𝐷2
Figure 4: Illustration of the tripartition ξ(P) = (D1, D2, D3) with r = 3.
4.1
Pumping Lemmas for Paths
Let P = (s, . . . , t) be a directed path, where each node has an input label from Σin. The tripartition
of the nodes ξ(P) = (D1, D2, D3) is deﬁned as follows:
D1 = Nr−1(s) ∪Nr−1(t),
D2 =
 N2r−1(s) ∪N2r−1(t)

\ D1,
D3 = P \ (D1 ∪D2).
See Figure 4 for an illustration. More speciﬁcally, suppose P = (u1, . . . , uk), and let i ∈[1, k]. Then
we have:
• ui ∈D1 if and only if i ∈[1, r] ∪[k −r + 1, k].
• ui ∈D2 if and only if i ∈[r + 1, 2r] ∪[k −2r + 1, k −r].
• ui ∈D3 if and only if i /∈[1, 2r] ∪[k −2r + 1, k].
Let L: D1 ∪D2 →Σout assign output labels to D1 ∪D2. We say that L is extendible w.r.t. P if
there exists a complete labeling L⋄of P such that L⋄agrees with L on D1 ∪D2, and L⋄is locally
consistent at all nodes in D2 ∪D3.
An Equivalence Class.
We deﬁne an equivalence class ⋆∼for the directed paths (i.e., the set of
all non-empty strings in Σ∗
in), as follows.
Consider two directed paths P = (u1, . . . , ux) and P ′ = (v1, . . . , vy), and let ξ(P) = (D1, D2, D3)
and ξ(P ′) = (D′
1, D′
2, D′
3). Consider the following natural 1-to-1 correspondence φ: (D1 ∪D2) →
(D′
1 ∪D′
2) deﬁned as φ(ui) = vi and φ(ux−i+1) = vy−i+1 for each i ∈[1, 2r].
The 1-to-1
correspondence is well-deﬁned so long as (i) x = y or (ii) x ≥4r and y ≥4r. We have P
⋆∼P ′ if
and only if the following two statements are met:
• Isomorphism: The 1-to-1 correspondence φ is well-deﬁned, and for each ui ∈D1 ∪D2,
the input label of ui is identical to the input label of φ(ui).
• Extendibility: Let L be any assignment of output labels to nodes in D1 ∪D2, and let
L′ be the corresponding output labeling of D′
1 ∪D′
2 under φ. Then L is extendible w.r.t.
P if and only if L′ is extendible w.r.t. P ′.
Note that for the special case of x ≤4r, we have P
⋆∼P ′ if and only if P is identical to P ′.
Deﬁne Type(P) as the equivalence class of P w.r.t. ⋆∼. The following technical lemma is analogous
to [6, Lemma 1] in a specialized setting. We only use this lemma to prove the lemmas in Section 4.1.
19

--- Page 21 ---
Lemma 10. Let G be a path graph or a cycle graph where all nodes have input labels from Σin. Let
P be a directed subpath of G, and let P ′ be another directed path such that Type(P ′) = Type(P).
We write ξ(P) = (D1, D2, D3) and ξ(P ′) = (D′
1, D′
2, D′
3). Let L⋄be any complete labeling of G
such that L⋄is locally consistent at all nodes in D2 ∪D3. Let G′ = Replace(G, P, P ′) be the graph
resulting from replacing P with P ′ in G. Then there exists a complete labeling L′
⋄of G′ such that
the following two conditions are met.
1. For each v ∈(V (G) \ V (P))∪(D1∪D2) and its corresponding v′ ∈(V (G′) \ V (P ′))∪(D′
1∪D′
2),
we have L⋄(v) = L′
⋄(v′). Moreover, if v ∈(V (G) \ V (P)) ∪D1 and L⋄is locally consistent at
v, then L′
⋄is locally consistent at v′.
2. L′
⋄is locally consistent at all nodes in D′
2 ∪D′
3.
Proof. The labeling L′
⋄(v′) of G′ for each v′ ∈(V (G′) \ V (P ′)) ∪(D′
1 ∪D′
2) is chosen “naturally”
as follows.
For each v′ ∈V (G′) \ V (P ′), we set L′
⋄(v′) = L⋄(v) for its corresponding node
v ∈V (G)\V (P). For each v′ ∈D′
1∪D′
2, we set L′
⋄(v′) = L⋄(v) for its corresponding node v ∈D1∪D2
such that φ(v) = v′ in the deﬁnition of ⋆∼. At this point, it is clear that if v ∈(V (G) \ V (P)) ∪D1
has a locally consistent labeling under L⋄, then its corresponding node v′ ∈(V (G′) \ V (P ′)) ∪D′
1
also has a locally consistent labeling under L′
⋄, so Condition 1 holds.
Now, the labeling L′
⋄is only undeﬁned for nodes in D′
3. We show that we can complete the
labeling in such a way that is locally consistent at all nodes in D′
2 ∪D′
3. Denote L as L⋄restricted
to D1 ∪D2. Since L⋄is locally consistent at all nodes in P, the labeling L is extendible w.r.t. P.
Note that if we let L′ be L⋄restricted to D′
1 ∪D′
2, then according to the way we deﬁne L′
⋄, the two
labeling L′ and L are identical under the 1-to-1 correspondence φ speciﬁed in the deﬁnition of ⋆∼.
That is, for each v′ ∈D′
1 ∪D′
2, we have L′(v′) = L(v) for its corresponding node v ∈D1 ∪D2 such
that φ(v) = v′. Since P
⋆∼P ′, the labeling L′ must be extendible w.r.t. P ′. That is, there is a way
to assign L′
⋄(v′) for each v′ ∈D′
3 such that all nodes in D′
2 ∪D′
3 have locally consistent labelings
under L′
⋄, so Condition 2 holds.
One useful consequence of this lemma is that if we start with a path or a cycle G with a legal
labeling, after replacing its subpath P with another one P ′ having the same type as P, then it
is always possible to assign output labeling to P ′ to get a legal labeling without changing the
already-assigned output labels of nodes outside of P ′.
Lemma 11. Let G be a path graph or a cycle graph where all nodes have input labels from Σin. Let
P be a directed subpath of G, and let P ′ be another directed path such that Type(P ′) = Type(P). Let
L⋄be complete labeling of G that is locally consistent at all nodes in P. Let G′ = Replace(G, P, P ′)
be the graph resulting from replacing P with P ′ in G. Then there exists a legal labeling L′
⋄of G′
such that the following two conditions are met.
1. For each v ∈V (G) \ V (P) and its corresponding v′ ∈V (G′) \ V (P ′), we have L⋄(v) = L′
⋄(v′).
Moreover, if L⋄is locally consistent at v ∈V (G) \ V (P), then L′
⋄is locally consistent at v′.
2. L′
⋄is locally consistent at all nodes in P ′.
Proof. We write ξ(P ′) = (D′
1, D′
2, D′
3). Condition 1 in this lemma is implied by Condition 1 in
Lemma 10. To see that Condition 2 in this lemma holds, note that in this lemma we additionally
require that L⋄is locally consistent at all nodes in P. Therefore, Condition 1 of Lemma 10 implies
that L′
⋄is locally consistent at all nodes in D′
1. This observation, together with Condition 2 of
Lemma 10, implies that L′
⋄is locally consistent at all nodes in P ′.
20

--- Page 22 ---
The following lemma is analogous to [6, Theorem 4] in a specialized setting. We only use this
lemma in Section 4.1.
Lemma 12. Let P = (v1, . . . , vk), and let P ′ = (v1, . . . , vk−1). Let the input label of vk be α. Then
Type(P) is a function of α and Type(P ′).
Proof. We prove the following stronger statement. Let G be a directed path, and let H be a
directed subpath of G.
Suppose H′ is another directed path satisfying Type(H) = Type(H′).
Let G′ = Replace(G, H, H′) be the result of replacing H with H′ in G.
Then we claim that
Type(G) = Type(G′). The lemma is a corollary of this claim.
Consider the tripartitions ξ(H) = (B1, B2, B3), ξ(H′) = (B′
1, B′
2, B′
3), ξ(G) = (D1, D2, D3), and
ξ(G′) = (D′
1, D′
2, D′
3). We write B0 = V (G) \ V (H) and B′
0 = V (G′) \ V (H′).
Let φ⋆be the natural 1-to-1 correspondence from B0 ∪B1 ∪B2 to B′
0 ∪B′
1 ∪B′
2. Note that
D1 ∪D2 ⊆B0 ∪B1 ∪B2 and D′
1 ∪D′
2 ⊆B′
0 ∪B′
1 ∪B′
2. Also, the 1-to-1 correspondence between
D1 ∪D2 and D′
1 ∪D′
2 given by φ⋆is exactly the 1-to-1 correspondence φ speciﬁed in the requirement
of G ⋆∼G′.
Let L: (D1 ∪D2) →Σout and let L′ be the corresponding output labeling of D′
1 ∪D′
2, under
the 1-to-1 correspondence φ. To show that G ⋆∼G′, all we need to do is show that L is extendible
w.r.t. G if and only if L′ is extendible w.r.t. G′. Since we can also write G = Replace(G′, H′, H), it
suﬃces to show just one direction, i.e., if L is extendible then L′ is extendible.
Suppose L is extendible. Then there exists an output labeling L⋄of G such that (i) for each
v ∈D1 ∪D2, we have L⋄(v) = L(v), and (ii) L⋄is locally consistent at all nodes in D2 ∪D3. Since
D2 ∪D3 ⊇B2 ∪B3, we can apply Lemma 10, which shows that there exists a complete labeling
L′
⋄of G′ such that the two conditions in Lemma 10 are met. We argue that this implies that L′ is
extendible. We verify that (i) L′(v′) = L′
⋄(v′) for each v′ ∈D′
1 ∪D′
2, and (ii) L′
⋄is locally consistent
at all nodes in D′
2 ∪D′
3.
• Condition 1 of Lemma 10 guarantees that L⋄(v) = L′
⋄(φ⋆(v)) for each v ∈(V (G) \ V (H)) ∪
(B1 ∪B2) = B0 ∪B1 ∪B2 and its corresponding node φ⋆(v) ∈B′
0 ∪B′
1 ∪B′
2. Since D′
1 ∪D′
2 ⊆
B′
0 ∪B′
1 ∪B′
2, we have L′(v′) = L′
⋄(v′) for each v′ ∈D′
1 ∪D′
2.
• The fact that L⋄is locally consistent at all nodes in D2 ∪D3, together with Condition 1 in
Lemma 10, guarantees that L′
⋄is locally consistent at all nodes in (D′
2 ∪D′
3) \ B′
3. Condition 2
in Lemma 10 guarantees that L′
⋄is locally consistent at all nodes in B′
2 ∪B′
3. Therefore, L′
⋄is
locally consistent at all nodes in D′
2 ∪D′
3, as required.
The number of types can be upper bounded as follows.
Lemma 13. The number of equivalence classes of ⋆∼(i.e., types) is at most |Σin|4r2|Σout|4r.
Proof. Let P be a directed path, and let ξ(P) = (D1, D2, D3). Then Type(P) is determined by the
following information.
• The input labels in D1 ∪D2. Note that there are at most |Σin|4r possible input labeling of
D1 ∪D2.
• A length-x binary string indicating the extendibility of each possible output labeling of D1∪D2,
where x = |Σout|4r.
Therefore, the number of equivalence classes of ⋆∼is at most |Σin|4r2|Σout|4r.
21

--- Page 23 ---
Deﬁne ℓpump as the total number of types. Observe that Lemma 12 implies that Type(P) can be
computed by a ﬁnite automaton whose number of states is the total number of types, which is a
constant independent of P. Thus, we have the following two pumping lemmas which allow us to
extend the length of a given directed path P while preserving the type of P. The following two
lemmas follow from the standard pumping lemma for regular language.
Lemma 14. Let P ∈Σk
in with k ≥ℓpump.
Then P can be decomposed into three substrings
P = x ◦y ◦z such that (i) |xy| ≤ℓpump, (ii) |y| ≥1, and (iii) for each non-negative integer i,
Type(x ◦yi ◦z) = Type(P).
Lemma 15. For each w ∈Σ>0
in , there exist two positive integers a and b such that a + b ≤ℓpump,
and Type(wai+b) is invariant for each non-negative integer i.
4.2
The ω(log∗n)—o(n) Gap
In this section we show that the ω(log∗n)—o(n) gap is decidable. More speciﬁcally, we show that
an LCL problem P can be solved in O(log∗n) rounds if and only if there exists a feasible function,
which is deﬁned as follows.
Input: A directed path P = w1 ◦S ◦w2, where |w1| ∈[ℓpump, ℓpump + 1], |w2| ∈[ℓpump, ℓpump + 1],
and |S| = 2r. The decomposition P = w1 ◦S ◦w2 is considered part of the input.
Output: A string L ∈Σ2r
out that represents the output labeling of S.
Requirement: Any such function f is said to be feasible if the following requirement is met for
any paths S1, S2 and wa, wb, wc, wd such that |S1| = |S2| = 2r and {|wa|, |wb|, |wc|, |wd|} ⊆
[ℓpump, ℓpump + 1]. Let P = wa ◦S1 ◦wb ◦wc ◦S2 ◦wd, and consider the following assignment
of output labels to S1 ∪S2.
• Either label S1 by f(wa ◦S1 ◦wb) or label SR
1 by f(wR
b ◦SR
1 ◦wR
a ).
• Either label S2 by f(wc ◦S2 ◦wd) or label SR
2 by f(wR
d ◦SR
2 ◦wR
c ).
It is required that given such a partial labeling of P, the middle part wb ◦wc can be assigned
output labels in such a way that the labeling of (i) the last r nodes of S1, (ii) all nodes in
wb ◦wc, and (iii) the ﬁrst r nodes of S2 are locally consistent.
The following lemma is a straightforward consequence of the well-known O(log∗n)-round MIS
algorithm on cycles.
Lemma 16. Let G be a cycle graph of n nodes, and let s ≤k be two constant integers such that
s + k ≤n. Then in O(log∗n) rounds we can compute a decomposition V = A ∪B such that each
connected component of A has size s, and each connected component of B has size within [k, k + 1].
Proof. For any given constant integer 1 ≤L < n, we will show that in O(log∗n) time we can ﬁnd
an independent set I of G such that each connected component induced by V \ I has at least L
nodes and at most 2L nodes. Using this result with L = 2(s −1) + k(s + k + 1), it is straightforward
to obtain the desired decomposition V = A ∪B, as follows.
For each v ∈I, it arbitrarily chooses a size-s path Sv that contains v, and all nodes in Sv are
included to A. Now each connected component S′ induced by the remaining nodes is a path of
size at least L −2(s −1) ≥k(s + k + 1) and at most 2L. We will divide the path S′ into subpaths
R1, R2, . . . , Rt meeting the following conditions: (i) if i is odd, then the size of Ri is k or k + 1;
22

--- Page 24 ---
(ii) if i is even, then the size of Ri is s; (iii) t is odd. Hence we obtain the desired decomposition
V = A ∪B if we include the nodes in R1, R3, . . . to B and include the nodes in R2, R4, . . . to A. We
show that such a decomposition of S′ into subpaths R1, R2, . . . , Rt exists. Denote z as the size of
S′. We write z = α(s + k + 1) + β, where α > 0 and 0 ≤β < s + k + 1 are integers. Note that we
must have α ≥k and β ≤2k.
• For the case β ≥k, there is a decomposition R1, R2, . . . , Rt satisﬁes the following conditions:
(i) if i is odd, then the size of Ri is k + 1 when i < t or β when i = t; (ii) if i is even, then the
size of Ri is s; (iii) t = 2α + 1 is odd.
• For the case β < k, there is a decomposition R1, R2, . . . , Rt satisﬁes the following conditions:
(i) if i is odd, then the size of Ri is k when i ∈{1, 3, 5, . . . , 2(k−β)−1}∪{t} or k+1 otherwise;
(ii) if i is even, then the size of Ri is s; (iii) t = 2α + 1 is odd.
For the rest of the proof, we show that in O(log∗n) time we can ﬁnd the required independent
set I. We prove the lemma by an induction on L. The base case of L = 1 is identical to the MIS
problem. Now consider L > 1. By induction hypothesis, we ﬁnd an independent set I′ in O(log∗n)
time such that each connected component induced by V \ I′ has at least L′ nodes and at most 2L′
nodes, where L′ = ⌊L/2⌋. Let G′ be the graph resulting from contracting all nodes in V \ I′, and
we compute an MIS I′′ on this graph G′, which can be done in O(log∗n) rounds in the original
graph G. Note that each connected component S of V \ I′′ has size at least 2L′ + 1 ≥L and at most
3(2L′) + 2. If the size of S is higher than 2L, then we can add some nodes in S to the independent
set I′′ so that the component size of the remaining nodes in S is within [L, 2L].
Lemma 17. If a feasible function f exists, then there is an O(log∗n)-round deterministic LOCAL
algorithm for P on cycles.
Proof. Given that the number of nodes n is at least some large enough constant, in O(log∗n) rounds
we can compute a decomposition V = A ∪B such that each connected component of A has size 2r,
and each connected component of B has size within [2ℓpump, 2ℓpump + 1]. This can be done using
Lemma 16 with s = 2r and k = 2ℓpump. We further decompose each connected component P of
B into two paths P = P1 ◦P2 in such a way that the size of both P1 and P2 are within the range
[ℓpump, ℓpump + 1]. We write P to denote the set of all these paths.
Let S be a connected component of A, and let w1 and w2 be its two neighboring paths in P so
that (w1 ◦S ◦w2) is a subpath of the underlying graph G. The output labels of S are assigned either
by labeling S with f(w1 ◦S ◦w2) or by labeling SR with f(wR
2 ◦SR ◦wR
1 ). At this moment, all
components of A have been assigned output labels using f. By the feasibility of f, each connected
component of B is able to label itself output labels in such a way that the labeling of all nodes are
locally consistent.
Lemma 18. If there is an o(n)-round deterministic LOCAL algorithm A for P on cycles, then a
feasible function f exists.
Proof. Fix s to be some suﬃciently large number, and ﬁx n = 8(s + ℓpump) + 2(2r). We select s to
be large enough so that the runtime of A is smaller than 0.1s. For any given directed path w with
|w| ∈[ℓpump, ℓpump + 1], we ﬁx w+ as the result of applying the pumping lemma (Lemma 14) on w
so that the following two conditions are met: (i) |w+| ∈[s, s + ℓpump] and (ii) Type(w) = Type(w+).
23

--- Page 25 ---
Constructing a Feasible Function f by Simulating A.
The function f(w1 ◦S ◦w2) is
constructed by simulating a given o(n)-round deterministic LOCAL algorithm for P. The output
labeling given by f(w1 ◦S ◦w2) is exactly the result of simulating A on the path P = w+
1 ◦S ◦w+
2
while assuming the number of nodes of the underlying graph is n. Remember that the round
complexity of A is o(n) on n-node graphs. By setting s to be large enough, the runtime of A can be
made smaller than 0.1s. Thus, the calculation of f(w1 ◦S ◦w2) only depends on the IDs and the
input labels of (i) the last 0.1s nodes in w+
1 , (ii) all nodes in S, and (iii) the ﬁrst 0.1s nodes in w+
2 .
In the calculation of f(w1 ◦S ◦w2), the IDs of the nodes that participate in the simulation of A are
chosen arbitrarily so long as they are distinct.
Feasibility of f.
Now we verify that the function f constructed above is feasible. Consider any
choices of paths S1, S2 and wa, wb, wc, wd such that |S1| = |S2| = 2r and {|wa|, |wb|, |wc|, |wd|} ⊆
[ℓpump, ℓpump + 1]. Deﬁne P = wa ◦S1 ◦wb ◦wc ◦S2 ◦wd, and let G be the cycle graph formed by
connecting the two ends of the path P. To show that f is feasible, we need to consider the following
four ways of assigning output labels to S1 ∪S2.
1. Label S1 by f(wa ◦S1 ◦wb); label S2 by f(wc ◦S2 ◦wd).
2. Label S1 by f(wa ◦S1 ◦wb); label SR
2 by f(wR
d ◦SR
2 ◦wR
c ).
3. Label SR
1 by f(wR
b ◦SR
1 ◦wR
a ); label S2 by f(wc ◦S2 ◦wd).
4. Label SR
1 by f(wR
b ◦SR
1 ◦wR
a ); label SR
2 by f(wR
d ◦SR
2 ◦wR
c ).
For each of the above four partial labelings of P, we need to show that the middle part wb ◦wc
can still be assigned output labels in such a way that the labeling of (i) the last r nodes of S1, (ii)
all nodes in wb ◦wc, and (iii) the ﬁrst r nodes of S2 are locally consistent.
Proof of the First Case.
In what follows, we focus on the ﬁrst case, i.e., the partial labeling is
given by labeling S1 by f(wa ◦S1 ◦wb) and labeling S2 by f(wc ◦S2 ◦wd); the proof for the other
three cases are analogous. In this case, we deﬁne P ′ = w+
a ◦S1 ◦w+
b ◦w+
c ◦S2 ◦w+
d , and let G′ be
the cycle graph formed by connecting the two ends of P ′. Note that the number of nodes in G′ is at
most 8(s + ℓpump) + 2(2r) = n. All we need to do is to ﬁnd an output labeling L of G such that the
following conditions are satisﬁed.
(a) The output labels of S1 is given by f(wa ◦S1 ◦wb).
(b) The output labels of S2 is given by f(wc ◦S2 ◦wd).
(c) The labeling of (i) the last r nodes of S1, (ii) all nodes in wb ◦wc, and (iii) the ﬁrst r nodes of
S2 are locally consistent.
We ﬁrst generate an output labeling L′ of G′ by executing A on G′ under the following ID
assignment. The IDs of (i) the last 0.1s nodes in w+
a , (ii) all nodes in S1, and (iii) the ﬁrst 0.1s
nodes in w+
b are chosen as the ones used in the deﬁnition of f(wa ◦S1 ◦wb). Similarly, the IDs of (i)
the last 0.1s nodes in w+
c , (ii) all nodes in S2, and (iii) the ﬁrst 0.1s nodes in w+
d are chosen as the
ones used in the deﬁnition of f(wc ◦S2 ◦wd). The IDs of the rest of the nodes are chosen arbitrarily
so long as when we run A on G′, no node sees two nodes with the same ID. Due to the way we
deﬁne f, the output labeling L′ of the subpath S1 is exactly given by f(wa ◦S1 ◦wb), and the output
labeling L′ of S2 is exactly f(wc ◦S2 ◦wd). Due to the correctness of A, L′ is a legal labeling.
We transform the output labeling L′ of G′ to a desired output labeling L of G. Remember that
G is the result of replacing the four subpaths w+ of G′ by w, and we have Type(w+) = Type(w). In
view of Lemma 11, there is a legal labeling L of G such that all nodes in S1 and S2 are labeled the
same as in G′. Therefore, the labeling L satisﬁes the above three conditions (a), (b), and (c).
24

--- Page 26 ---
The Other Cases.
We brieﬂy discuss how we modify the proof to deal with the other three
cases. For example, consider the second case, where the partial labeling is given by labeling S1 by
f(wa ◦S1 ◦wb) and labeling SR
2 by f(wR
d ◦SR
2 ◦wR
c ). In this case, the path P ′ is deﬁned as
P ′ = w+
a ◦S1 ◦w+
b ◦
 (wR
c )+R ◦SR
2 ◦
 (wR
d )+R .
During the ID assignment of G′, the IDs of (i) the last 0.1s nodes in w+
c , (ii) all nodes in S2, and
(iii) the ﬁrst 0.1s nodes in w+
d are now chosen as the ones used in the deﬁnition of f(wR
d ◦SR
2 ◦wR
c ).
Using such an ID assignment, the output labeling L′ of SR
2 as the result of executing A on G′ will
be exactly the same as the output labeling given by f(wR
d ◦SR
2 ◦wR
c ). The rest of the proof is the
same.
Theorem 8 follows from the above two lemmas. The decidability result is due to the simple
observation that whether a feasible function exists is decidable.
4.3
Partitioning a Cycle
In the following sections, we prove the decidability result associated with the ω(1)—o(log∗n) gap.
In this proof, we also deﬁne a feasible function, prove its decidability, and show the existence given
an o(log∗n)-time algorithm. The main challenge here is that an MIS cannot be computed in O(1)
time. To solve this issue, we decompose a cycle into paths with unrepetitive patterns and paths
with repetitive patterns. For paths with unrepetitive patterns, we are able to compute a suﬃciently
well-spaced MIS in O(1) time by making use of the irregularity of the input patterns.
Section 4.3 considers an O(1)-round algorithm that partitions a cycle into some short paths
and some paths that have a repeated input pattern. Section 4.4 deﬁnes a feasible function whose
existence characterizes the O(1)-round solvable LCL problems. In Section 4.5, we prove Theorem 9.
Partitioning an Undirected Cycle into Directed Paths.
Let G be a cycle graph.
An
orientation of a node v is an assignment to one of its neighbor, this can be speciﬁed using port-
numbering. An orientation of the nodes in G is called ℓ-orientation if the following condition is met.
If |V (G)| ≤ℓ, then all nodes in G are oriented to the same direction. If |V (G)| > ℓ, then each node
v ∈V (G) belongs to a path P such that (i) all nodes in P are oriented to the same direction, and
(ii) the number of nodes in P is at least ℓ. In O(1) rounds we can compute an ℓ-orientation of G for
any constant ℓ.
Lemma 19 ([6]). Let G be a cycle graph. Let ℓbe a constant. There is a deterministic LOCAL
algorithm that computes an ℓ-orientation of G in O(1) rounds.
In this section, we will use a generalization of an ℓ-orientation that satisﬁes an additional
requirement that the input labels of each directed path P in the decomposition with |V (P)| > 2ℓwidth
(where 2ℓwidth is a threshold) must form a periodic string (whose period length is at most ℓpattern).
A string w ∈Σ∗
in is called primitive if w cannot be written as xi for some x ∈Σ∗
in and i ≥2. Let
G be a cycle graph or a path graph where each node v ∈V (G) has an input label from Σin. We
deﬁne an (ℓwidth, ℓcount, ℓpattern)-partition as a partition of G into a set of connected subgraphs P
meeting the following criteria. We assume |V (G)| > 2ℓwidth and ℓpattern ≥ℓwidth.
Direction and Minimum Length: For each P ∈P, the nodes in P are oriented to the same
direction, and |V (P)| ≥ℓwidth.
25

--- Page 27 ---
Short Paths: Deﬁne Pshort as the subset of P that contains paths having at most 2ℓwidth
nodes. For each directed path P = (v1, . . . , vk) ∈Pshort, each node vi in P knows its rank i.
Long Paths: Deﬁne Plong = P \ Pshort. Then the input labeling of the nodes in P is of the
form wk for some primitive string w ∈Σ∗
in such that |w| ≤ℓpattern and k ≥ℓcount. Moreover,
each node v in P knows the string w.
Note that P may contain a cycle. This is possible only when G is a cycle where the input
labeling is a repetition (at least ℓcount times) of a primitive string w ∈Σ∗
in of length at most ℓpattern.
In this case, we must have P = Plong = {G}. Otherwise, P contains only paths.
The goal of this section is to show that an (ℓwidth, ℓcount, ℓpattern)-partition can be found in O(1)
rounds. First of all, in Lemma 20 we demonstrate how we can break symmetry in O(1) rounds
given that the underlying graph is directed and the input labels does not form long periodic strings.
Let G be a path or a cycle. A set I ⊆V (G) is called an (α, β)-independent set if the following
conditions are met: (i) I is an independent set, and I does not contain either endpoint of G (if G is
a path), and (ii) each connected component induced by V \ I has at least α nodes and at most β
nodes, unless |V | ≤α, in which case we allow I = ∅. Note that ﬁnding an (α, β)-independent set
takes O(log∗n) rounds in general, but in Lemma 20 we show that by leveraging the “irregularity”
of input labels, we can do this in O(1) rounds on directed paths or cycles without periodic patterns.
Lemma 20. Let γ and ℓbe any two constants with ℓ≥γ. Let G be a directed cycle or a directed
path that does not contain any subpath of the form wx, with |w| ≤γ and |wx| ≥ℓ. There is a
deterministic LOCAL algorithm that computes an (γ, 2γ)-independent set I of G in O(1) rounds.
Proof. For the case G is a directed path P = (s, . . . , t), deﬁne V ′ as the set of nodes in G whose
distance to t is at least ℓ−1. For the case G is a directed cycle, deﬁne V ′ = V (G). In what follows,
we focus on ﬁnding an (γ, 2γ)-independent set I′ of the nodes in V ′. Extending the set I′ to produce
the desired independent set I can be done with extra O(1) rounds.
Recall that G is directed. Deﬁne the color of a node v ∈V ′ by the sequence of the ℓinput labels
of v and the ℓ−1 nodes following v in G. For each node v ∈V ′, there is no other node within
distance γ to v having the same color as v, since otherwise we can ﬁnd a subpath whose input labels
form a string wx, with |w| ≤γ and |wx| ≥ℓ. By applying the standard procedure that computes an
MIS from a coloring, within O(1) rounds a (γ, 2γ)-independent set I′ can be obtained.
Using Lemma 20, we ﬁrst show that an (ℓwidth, ℓcount, ℓpattern)-partition can be found in O(1)
rounds for the case G is directed. That is, all nodes in G are initially oriented to the same direction,
and we are allowed to re-orient the nodes.
Lemma 21. Let G be a directed cycle or a directed path where each node v ∈V (G) has an input label
from Σin, and |V (G)| > 2ℓwidth. Let ℓwidth, ℓcount, ℓpattern be three constants such that ℓpattern ≥ℓwidth.
There is a deterministic LOCAL algorithm that computes an (ℓwidth, ℓcount, ℓpattern)-partition in O(1)
rounds
Proof. Let (w1, w2, . . . , wk) be any ordering of the primitive strings in Σ∗
in of length at most ℓpattern.
First, construct a set of subgraphs Plong as follows. Initialize U = V (G) and Plong = ∅. For i = 1 to
k, execute the following procedure. Let Si be the set of maximal-size connected subgraphs formed by
nodes in U such that the input labels form the string wx
i with x ≥ℓcount + 2ℓwidth. Each node v ∈U
in O(1) rounds checks if v belongs to a subgraph in Si; if so, remove v from U. For each P ∈Si,
26

--- Page 28 ---
deﬁne P ′ as follows. If P is a cycle, then P ′ = P. If P is a path, then P ′ is the result of removing
all nodes that are within distance ℓwidth|wi| −1 to an endpoint in P. Note that each node v in P
knows whether v belongs to P ′. Deﬁne S′
i = {P ′|P ∈Si}, and then update Plong ←Plong ∪S′
i.
It is straightforward to verify that each path or cycle P ∈Plong satisﬁes the requirement in the
deﬁnition of (ℓwidth, ℓcount, ℓpattern)-partition. Deﬁne the set of subgraphs Pirreg as the connected
components of the nodes not in any subgraph in Plong. Deﬁne ℓ= (ℓpattern + 2ℓwidth) · ℓcount. By
our construction, the input labeling in each subgraph P ∈Pirreg does not contain any substring
wx, with 1 ≤|w| ≤ℓpattern and |wx| ≥ℓ. An (ℓpattern, 2ℓpattern)-independent set of each P ∈Pirreg
can be computed using Lemma 20 in O(1) rounds. Observe that each subgraph P ∈Pirreg has at
least ℓwidth nodes. Given an (ℓpattern, 2ℓpattern)-independent set of a subgraph P ∈Pirreg, in O(1)
rounds P can be partitioned into subpaths, each of which contains at least ℓpattern nodes and at
most 2ℓpattern nodes. This ﬁnishes the construction of an (ℓwidth, ℓcount, ℓpattern)-partition.
Combining Lemma 21 and Lemma 19, we are able to construct an (ℓwidth, ℓcount, ℓpattern)-partition
in O(1) rounds for undirected graphs.
Lemma 22. Let G be a cycle or a path where each node v ∈V (G) has an input label from Σin, and
|V (G)| > 2ℓwidth. Let ℓwidth, ℓcount, ℓpattern be three constants such that ℓpattern ≥ℓwidth. There is a
deterministic LOCAL algorithm that computes an (ℓwidth, ℓcount, ℓpattern)-partition in O(1) rounds
Proof. The algorithm is as follows. Compute an ℓ-orientation of G by Lemma 19 in O(1) rounds
with ℓ= 2ℓwidth + 1. For each maximal-length connected subgraph P where each constituent node
is oriented to the same direction, ﬁnd an (ℓwidth, ℓcount, ℓpattern)-partition of P in O(1) rounds by
Lemma 21.
4.4
Feasible Function
The goal of this section is to deﬁne a feasible function whose existence characterizes the O(1)-round
solvable LCL problems. With respect to an LCL problem P and a function f which takes a string
w ∈Σk
in with 1 ≤k ≤ℓpump as input, and returns a string f(w) ∈Σk
out, we deﬁne some partially or
completely labeled path graphs which are used in the deﬁnition of a feasible function.
Completely Labeled Graph Gw,z: Let w ∈Σ∗
in be any string of length at least 1 and at most
ℓpump. Let z be any non-negative integer. Deﬁne Gw,z = (Gw,z, L) as follows. The graph Gw,z
is a path of the form wr ◦wz ◦wr. The labeling L is a complete labeling of the form f(w)z+2r.
Deﬁne Mid(Gw,z) as the middle subpath wz of Gw,z.
Partially Labeled Graph Gw1,w2,S: Let w1, w2 ∈Σ∗
in be any two strings of length at least 1 and
at most ℓpump. Let S ∈Σ∗
in be any string (can be empty). Deﬁne Gw1,w2,S = (Gw1,w2,S, L) as
follows. The graph Gw1,w2,S is the path of the form wℓpump+2r
1
◦S ◦wℓpump+2r
2
. The labeling
L is a partial labeling of Gw1,w2,S which ﬁxes the output labels of the ﬁrst 2r|w1| and the
last 2r|w2| nodes by f(w1)2r and f(w2)2r, respectively. Deﬁne Mid(Gw1,w2,S) as the middle
subpath wℓpump+r
1
◦S ◦wℓpump+r
2
of Gw1,w2,S.
Feasible Function: We call f a feasible function if the following conditions are met: (i) For each
Gw,z = (Gw,z, L), the complete labeling L is locally consistent at all nodes in Mid(Gw,z). (ii)
Each partially labeled graph Gw1,w2,S admits a complete labeling L⋄that is locally consistent
at all nodes in Mid(Gw1,w2,S).
Lemma 23. Given an LCL problem P on cycle graphs. It is decidable whether there is a feasible
function.
27

--- Page 29 ---
Proof. Note that it is not immediate from its deﬁnition as to whether a feasible function exists is
decidable, since there appears to be inﬁnitely many graphs Gw,z and Gw1,w2,S needed to be examined.
However, the following simple observations show that it suﬃces to check only a constant number of
these graphs.
• If the complete labeling L of Gw,1 = (Gw,1, L) is locally consistent at all nodes in Mid(Gw,1),
then for all z ≥1, the complete labeling L of Gw,z = (Gw,z, L) is also locally consistent at all
nodes in Mid(Gw,z).
• If Gw1,w2,S admits a complete labeling L⋄that is locally consistent at all nodes in Mid(Gw1,w2,S),
then for each S′ such that Type(S) = Type(S′), the partially labeled graph Gw1,w2,S′ also
admits a complete labeling L⋄that is locally consistent at all nodes in Mid(Gw1,w2,S′). This is
due to Lemma 11.
Therefore, to decide whether a function f is feasible, we only need to check all possible Gw,z and
Gw1,w2,S. For each w we only need to consider the graph Gw,z with z = 1. For each w1 and w2, we
do not need to go over all S; we only need to consider (i) the empty string S = ∅, and (ii) for each
type τ, a string S ∈Σ∗
in such that Type(S) = τ. By Lemma 14, for each type τ, there exists P ∈Σx
in
with x ≤ℓpump such that Type(P) = τ. Therefore, a string S with Type(S) = τ can be found in
bounded amount of time; also note that the number of types is bounded; see Lemma 13.
For the rest of this section, we show that as long as the deterministic LOCAL complexity of
P is o(log∗n) on cycle graphs, there exists a feasible function f. In Lemma 24 we show how to
extract a function f from a given o(log∗n)-round deterministic LOCAL algorithm A, and then in
Lemma 25 we prove that such a function f is feasible. Intuitively, Lemma 24 shows that there exists
an ID-assignment such that when we run A on a subpath whose input labeling is a repetition of a
length-k pattern w, the output labeling is also a repetition of a length-k pattern w′. The function f
will be deﬁned as f(w) = w′.
Lemma 24. Let A be any deterministic LOCAL algorithm that solves P in t(n) = o(log∗n) rounds.
Then there is a number n′ and function f which takes a string w ∈Σk
in with 1 ≤k ≤ℓpump as input,
and returns a string f(w) ∈Σk
out meeting the following condition. For any P = wi ◦w2r+1 ◦wi such
that |wi| ≥t(n′) and 1 ≤|w| ≤ℓpump, there is an assignment of distinct Θ(log n′)-bit IDs to the
nodes in P such that the following is true. Simulating A on P while assuming that the total number
of nodes in the underlying graph is n′ yields the output labeling f(w)2r+1 for the middle subpath
w2r+1.
Proof. In this proof we assume that there is no such a number n′. Then we claim that using A it is
possible to obtain a deterministic LOCAL algorithm for MIS on an n-node directed cycle G without
input labeling, in O(t(n)) + O(1) = o(log∗n) rounds. This contradicts the well-known Ω(log∗n)
lower bound for MIS [20].
Let G be an n-node directed cycle without input labeling. The MIS algorithm on G is described
as follows. Let w ∈Σk
in with 1 ≤k ≤ℓpump be chosen such that for any function f, the string
f(w) ∈Σk
out does not satisfy the conditions stated in the lemma for the number n′ = nk. Deﬁne
G′ as the graph resulting from replacing each node v ∈V (G) with a path w. We can simulate the
imaginary graph G′ in the communication network G by letting each node v ∈V (G) simulate a
path w.
We execute the algorithm A on G′ while assuming that the total number of nodes is n′. The
execution takes t(n′) = O(t(n)) rounds. For each node v ∈V (G), deﬁne the color of v as the
sequence of the output labels of the path w2r simulated by the node v and the 2r −1 nodes following
28

--- Page 30 ---
v in the directed cycle G. This gives us a proper O(1)-coloring, since otherwise there must exist
a subpath P = w2r+1 of G′ such that the output labeling of P is of the form y2r+1 for some y,
contradicting our choice of w. Using the standard procedure of computing an MIS from a coloring,
with extra O(1) rounds, an MIS of G can be obtained.
Note that there is a subtle issue about how we set the IDs of nodes in V (G′). The following
method is guaranteed to output distinct IDs. Let v ∈V (G), and let u1, . . . , uk be the nodes in
V (G′) simulated by v. Then we may use ID(ui) = k · ID(v) + i.
Lemma 25. Suppose that the deterministic LOCAL complexity of P is o(log∗n) on cycle graphs.
Then there exists a feasible function f.
Proof. Let A be any deterministic LOCAL algorithm that solves P in t(n) = o(log∗n) rounds. Let
n′ and f be chosen to meet the conditions in Lemma 24 for A. The goal of the proof is to show
that f is a feasible function. According to the conditions speciﬁed in Lemma 24 for the function f,
we already know that the complete labeling L of each Gw,z = (Gw,z, L) is locally consistent at all
nodes in Mid(Gw,z). Therefore, all we need to do is the following. For each partially labeled graph
Gw1,w2,S, ﬁnd a complete labeling L⋄that is locally consistent at all nodes in Mid(Gw1,w2,S).
Given the three parameters w1, w2, and S, deﬁne G as the cycle resulting from linking the
two ends of the path wℓpump
1
◦w2r+1
1
◦wℓpump
1
◦S ◦wℓpump
2
◦w2r+1
2
◦wℓpump
2
. Deﬁne L as the partial
labeling of G which ﬁxes the output labeling of the two subpaths w2r+1
1
and w2r+1
2
by f(w1)2r+1
and f(w2)2r+1, respectively. We write P mid
1
and P mid
2
to denote the two subpaths w2r+1
1
and w2r+1
2
,
respectively.
In what follows, we show that the partially labeled graph G = (G, L) admits a legal labeling L⋄.
Since Gw1,w2,S is a subgraph of G = (G, L), such a legal labeling L⋄is also a complete labeling of
Gw1,w2,S that is locally consistent at all nodes in Mid(Gw1,w2,S).
For the rest of the proof, we show the existence of L⋄. This will be established by applying a
pumping lemma. Deﬁne the graph G′ as the result of the following operations on G.
• Replace the two subpaths wℓpump
1
by wx
1, where the number x is chosen such that x|w1| ≥
2t(n′) + r, and Type(wℓpump
1
) = Type(wx
1).
• Replace the two subpaths wℓpump
2
by wy
2, where the number y is chosen such that y|w2| ≥
2t(n′) + r, and Type(wℓpump
2
) = Type(wy
2).
The existence of the numbers x and y above is guaranteed by Lemma 15. The IDs of nodes in G′ are
assigned as follows. For i = 1, 2, select the IDs of the nodes in S
v∈P mid
i
Nt(n′)(v) in such a way that
the output labeling of P mid
i
resulting from executing A on G′ while assuming that the total number
of nodes is n′ is f(wi)2r+1. The existence of such an ID assignment is guaranteed by Lemma 24. For
all remaining nodes in G′, select their IDs in such a way that all nodes in Nr+t(n′)(v) receive distinct
IDs, for each v ∈V (G′). This ensures that the outcome of executing A on G′ while assuming that
the total number of nodes is n′ is a legal labeling.
Let L′
⋄be the legal labeling of G′ resulting from executing A with the above IDs while pretending
that the total number of nodes is n′. Note that L′
⋄must label P mid
1
and P mid
2
by f(w1)2r+1 and
f(w2)2r+1, respectively. A desired legal labeling L⋄of G can be obtained from the legal labeling L′
⋄of
G′ by applying Lemma 11, as we have Type(wℓpump
1
) = Type(wx
1) and Type(wℓpump
2
) = Type(wy
2).
4.5
The ω(1)—o(log∗n) Gap
In this section we prove that it is decidable whether a given LCL problem P has complexity Ω(log∗n)
or O(1) on cycle graphs.
29

--- Page 31 ---
Lemma 26. Let f be any feasible function. Let G be any cycle graph. Let P be any set of
disjoint subgraphs in G such that the input labeling of each P ∈P is of the form wx such that
x ≥2ℓpump + 2r, and w ∈Σk
in is a string with 1 ≤k ≤ℓpump. For each P ∈P, deﬁne the subgraph
P ′ as follows. If P is a cycle, deﬁne P ′ = P. If P is a path, write P = wℓpump ◦wi ◦wℓpump, and
deﬁne P ′ as the middle subpath wi. Let L be a partial labeling of G deﬁned as follows. For each
P = wx ∈P, ﬁx the output labels of each subpath w of P ′ by f(w). Then G = (G, L) admits a legal
labeling L⋄.
Proof. Deﬁne V1 as the set of all nodes such that v ∈V1 if v belongs to the middle subpath wj
of some path P = wℓpump ◦wr ◦wj ◦wr ◦wℓpump ∈P. By the deﬁnition of feasible function, L is
already locally consistent at all nodes in V1. Thus, all we need to do is to construct a complete
labeling L⋄of G = (G, L), and argue that L⋄is locally consistent at all nodes in V2 = V (G) \ V1.
There are two easy special cases. If P = ∅, then no output label of any node in G is ﬁxed, and
so G trivially admits a legal labeling. If P contains a cycle, then P = {G}, and hence L is already
a legal labeling as V1 = V (G).
In subsequent discussion, we restrict ourselves to the case that P is non-empty and contains only
paths. The output labeling L⋄is constructed as follows. Deﬁne Punlabeled as the maximal-length
subpaths of G that are not assigned any output labels by L. A path P ∈Punlabeled must be of the
form wℓpump
1
◦S ◦wℓpump
2
, where w1, w2 ∈Σ∗
in are two strings of length at least 1 and at most ℓpump,
and S ∈Σ∗
in can be any string (including the empty string). Given P ∈Punlabeled, we make the
following deﬁnitions.
• Deﬁne P + as the subpath of G that includes P and the r|w1| nodes preceding P, and the
r|w2| nodes following P in the graph G. Note that the set V2 is exactly the union of nodes in
P + for all P ∈Punlabeled.
• Deﬁne P ++ as the subpath of G that includes P and the 2r|w1| nodes preceding P, and the
2r|w2| nodes following P in the graph G. The path P ++ must be of the form wℓpump+2r
1
◦S ◦
wℓpump+2r
2
, and the labeling L already ﬁxes the output labels of the ﬁrst 2r|w1| and the last
2r|w2| nodes of P ++ by f(w1)2r and f(w2)2r, respectively.
Observe that the path P ++ = wℓpump+2r
1
◦S ◦wℓpump+2r
2
together with the labeling L is exactly the
partially labeled graph Gw1,w2,S. We assign the output labels to the nodes in P by the labeling
L⋄guaranteed in the deﬁnition of feasible function. It is ensured that the labeling of all nodes
within P + are locally consistent. By doing so for each P ∈Punlabeled, we obtain a desired complete
labeling that is locally consistent at all nodes in V2.
Lemma 27. Suppose that there is a feasible function f for the LCL problem P. Then there is an
O(1)-round deterministic LOCAL algorithm A on cycle graphs.
Proof. The ﬁrst step of the algorithm A is to compute an (ℓwidth, ℓcount, ℓpattern)-partition in O(1)
rounds by Lemma 22. We set ℓcount = 2ℓpump + 2r and ℓwidth = ℓpattern = ℓpump. We assume
|V (G)| > 2ℓwidth. Recall that an (ℓwidth, ℓcount, ℓpattern)-partition decomposes the cycle G into two
sets of disjoint subgraphs Pshort and Plong.
Deﬁne G′ as the graph resulting from applying the following operations on G.
For each
P ∈Pshort, replace the path P by the path P ∗= x ◦yi ◦z such that i = ℓcount, 1 ≤|y| ≤ℓpattern,
and the type of P ∗is the same as the type of P. The path P ∗is obtained via Lemma 14. Note that
each path P ∈Pshort has at least ℓwidth = ℓpump nodes and at most 2ℓwidth = 2ℓpump nodes. Deﬁne
P∗as the set of all P ∗such that P ∈Pshort. The graph G′ is simulated in the communication
graph G by electing a leader for each path P ∈Pshort to simulate P ∗.
30

--- Page 32 ---
𝑃∈𝒫short
𝑃′ = 𝑤𝑘∈𝒫long
𝑥
𝑦
𝑧
𝑃′ = 𝑤𝑘∈𝒫long
𝑥
𝑦𝑖
𝑧
𝐺
𝐺′
𝑃∗
𝑃′ = 𝑤𝑘∈𝒫long
𝑥
𝑦𝑖
𝑧𝑤ℓpump
𝑤ℓpump
𝑤𝑗
𝑃′ = 𝑤𝑘∈𝒫long
𝑥
𝑦𝑖
𝑧
𝑤ℓpump
𝑤ℓpump
𝑤𝑗
𝑃∈𝒫short
𝑃′ = 𝑤𝑘∈𝒫long
𝑥
𝑦
𝑧
(1)
(2)
(3)
(4)
𝑃∗
𝑃∗
Figure 5: Illustration of Lemma 27.
Calculate a partial labeling L′ of G′ using the feasible function f as follows. Recall ℓcount =
2ℓpump + 2r. For each P ∗= x ◦yℓpump ◦y2r ◦yℓpump ◦z ∈P∗, label the middle subpath y2r by the
function f. For each P = wℓpump ◦wi ◦wℓpump ∈Plong, label the middle subpath wi by f(w)i. Even
though a path P ∈Plong can have ω(1) nodes, this step can be done locally in O(1) rounds due to
the following property of (ℓwidth, ℓcount, ℓpattern)-partition. All nodes in a path P ∈Plong agree with
the same direction and know the primitive string w.
By Lemma 26, the remaining unlabeled nodes in G′ can be labeled to yield a legal labeling of
G′. This can be done in O(1) rounds since the connected components formed by unlabeled nodes
have at most O(1) nodes. Given any valid labeling of G′, a legal labeling of G can be obtained by
applying Lemma 11 in O(1) rounds. Remember that Type(P) = Type(P ∗) for each P ∈Pshort, and
G′ is exactly the result of replacing each P ∈Pshort by P ∗.
See Figure 5 for an illustration of Lemma 27: (1) applying a pumping lemma to extend each
path P ∈Pshort; (2) labeling the middle subpath y2r of P ∗= x ◦yℓpump ◦y2r ◦yℓpump ◦z ∈P∗and
the middle subpath wj of P ′ = wℓpump ◦wi ◦wℓpump ∈Plong by the function f; (3) the remaining
unlabeled nodes in G′ can be labeled to yield a legal labeling of G′ by Lemma 26; (4) since
Type(P) = Type(P ∗) for each P ∈Pshort, we can recover a legal labeling of G by re-labeling nodes
in each P ∈Pshort.
Combining Lemma 23, Lemma 25, and Lemma 27, we have proved Theorem 9. That is, for any
LCL problem P on cycle graphs, its deterministic LOCAL complexity is either Ω(log∗n) or O(1).
Moreover, there is an algorithm that decides whether P has complexity Ω(log∗n) or O(1) on cycle
graphs; for the case the complexity is O(1), the algorithm outputs a description of an O(1)-round
deterministic LOCAL algorithm that solves P.
Acknowledgments
Many thanks to Laurent Feuilloley, Juho Hirvonen, Janne H. Korhonen, Christoph Lenzen, Yannic
Maus, and Seth Pettie for discussions, and to anonymous reviewers for their helpful comments on
previous versions of this work. This work was supported in part by the Academy of Finland, Grant
285721.
31

--- Page 33 ---
References
[1] Alkida Balliu, Sebastian Brandt, Dennis Olivetti, and Jukka Suomela. Almost global problems
in the LOCAL model. In Proc. 32nd International Symposium on Distributed Computing (DISC
2018), Leibniz International Proceedings in Informatics (LIPIcs). Schloss DagstuhlLeibniz-
Zentrum f¨ur Informatik, 2018. doi:10.4230/LIPIcs.DISC.2018.9.
[2] Alkida Balliu, Juho Hirvonen, Janne H Korhonen, Tuomo Lempi¨ainen, Dennis Olivetti, and
Jukka Suomela. New classes of distributed time complexity. In Proc. 50th ACM Symposium on
Theory of Computing (STOC 2018), pages 1307–1318. ACM Press, 2018. doi:10.1145/3188745.
3188860.
[3] Roderick Bloem, Nicolas Braud-Santoni, and Swen Jacobs. Synthesis of Self-Stabilising and
Byzantine-Resilient Distributed Systems. In Proc. International Conference on Computer Aided
Veriﬁcation (CAV 2016), pages 157–176. Springer, 2016. doi:10.1007/978-3-319-41528-4 9.
[4] Sebastian Brandt, Orr Fischer, Juho Hirvonen, Barbara Keller, Tuomo Lempi¨ainen, Joel
Rybicki, Jukka Suomela, and Jara Uitto. A lower bound for the distributed Lov´asz local lemma.
In Proc. 48th ACM Symposium on Theory of Computing (STOC 2016), pages 479–488. ACM
Press, 2016. doi:10.1145/2897518.2897570.
[5] Sebastian Brandt, Juho Hirvonen, Janne H Korhonen, Tuomo Lempi¨ainen, Patric R J ¨Osterg˚ard,
Christopher Purcell, Joel Rybicki, Jukka Suomela, and Przemys law Uzna´nski. LCL problems
on grids. In Proc. 36th ACM Symposium on Principles of Distributed Computing (PODC 2017),
pages 101–110. ACM Press, 2017. doi:10.1145/3087801.3087833.
[6] Yi-Jun Chang and Seth Pettie. A Time Hierarchy Theorem for the LOCAL Model. In Proc.
58th IEEE Symposium on Foundations of Computer Science (FOCS 2017), pages 156–167.
IEEE, 2017. doi:10.1109/FOCS.2017.23.
[7] Yi-Jun Chang, Tsvi Kopelowitz, and Seth Pettie. An Exponential Separation between Ran-
domized and Deterministic Complexity in the LOCAL Model. In Proc. 57th IEEE Sym-
posium on Foundations of Computer Science (FOCS 2016), pages 615–624. IEEE, 2016.
doi:10.1109/FOCS.2016.72.
[8] Richard Cole and Uzi Vishkin. Deterministic coin tossing with applications to optimal parallel
list ranking. Information and Control, 70(1):32–53, 1986. doi:10.1016/S0019-9958(86)80023-7.
[9] Danny Dolev, Keijo Heljanko, Matti J¨arvisalo, Janne H Korhonen, Christoph Lenzen, Joel
Rybicki, Jukka Suomela, and Siert Wieringa.
Synchronous counting and computational
algorithm design. Journal of Computer and System Sciences, 82(2):310–332, 2016. doi:10.1016/j.
jcss.2015.09.002.
[10] Javier Esparza. Decidability and complexity of Petri net problems — An introduction. In
Lectures on Petri Nets I: Basic Models: Advances in Petri Nets, pages 374–428. Springer Berlin
Heidelberg, 1998. doi:10.1007/3-540-65306-6 20.
[11] Fathiyeh Faghih and Borzoo Bonakdarpour. SMT-Based Synthesis of Distributed Self-Stabilizing
Systems. ACM Transactions on Autonomous and Adaptive Systems, 10(3):1–26, 2015. doi:10.
1145/2767133.
32

--- Page 34 ---
[12] Manuela Fischer and Mohsen Ghaﬀari. Sublogarithmic Distributed Algorithms for Lov´asz Local
Lemma, and the Complexity Hierarchy. In Proc. 31st International Symposium on Distributed
Computing (DISC 2017), pages 18:1–18:16, 2017. doi:10.4230/LIPIcs.DISC.2017.18.
[13] Mohsen Ghaﬀari and Hsin-Hao Su. Distributed Degree Splitting, Edge Coloring, and Orien-
tations. In Proc. 28th ACM-SIAM Symposium on Discrete Algorithms (SODA 2017), pages
2505–2523. Society for Industrial and Applied Mathematics, 2017. doi:10.1137/1.9781611974782.166.
[14] Mohsen Ghaﬀari, David G Harris, and Fabian Kuhn. On Derandomizing Local Distributed
Algorithms. In Proc. 59th IEEE Symposium on Foundations of Computer Science (FOCS
2018), 2018. doi:10.1109/FOCS.2018.00069.
[15] Mohsen Ghaﬀari, Juho Hirvonen, Fabian Kuhn, and Yannic Maus. Improved Distributed
∆-Coloring. In Proc. 37th ACM Symposium on Principles of Distributed Computing (PODC
2018), pages 427–436. ACM, 2018. doi:10.1145/3212734.3212764.
[16] Andrew V. Goldberg, Serge A. Plotkin, and Gregory E. Shannon. Parallel Symmetry-Breaking in
Sparse Graphs. SIAM Journal on Discrete Mathematics, 1(4):434–446, 1988. doi:10.1137/0401044.
[17] Juho Hirvonen, Joel Rybicki, Stefan Schmid, and Jukka Suomela. Large cuts with local
algorithms on triangle-free graphs. Electronic Journal of Combinatorics, 24(4), 2017. URL
http://www.combinatorics.org/ojs/index.php/eljc/article/view/v24i4p21.
[18] John E Hopcroft and Jeﬀrey D Ullman. Introduction to Automata Theory, Languages and
Computation. Addison-Wesley, 1979.
[19] Alex Klinkhamer. On the Limits and Practice of Automatically Designing Self-Stabilization.
Doctoral thesis, Michigan Technological University, 2016. URL https://digitalcommons.mtu.
edu/etdr/90.
[20] Nathan Linial. Locality in Distributed Graph Algorithms. SIAM Journal on Computing, 21(1):
193–201, 1992. doi:10.1137/0221015.
[21] Moni Naor. A lower bound on probabilistic algorithms for distributive ring coloring. SIAM
Journal on Discrete Mathematics, 4(3):409–412, 1991. doi:10.1137/0404036.
[22] Moni Naor and Larry Stockmeyer. What Can be Computed Locally?
SIAM Journal on
Computing, 24(6):1259–1277, 1995. doi:10.1137/S0097539793254571.
[23] Alessandro Panconesi and Aravind Srinivasan. The local nature of ∆-coloring and its algorithmic
applications. Combinatorica, 15(2):255–280, 1995. doi:10.1007/BF01200759.
[24] David Peleg. Distributed Computing: A Locality-Sensitive Approach. Society for Industrial and
Applied Mathematics, 2000. doi:10.1137/1.9780898719772.
[25] Seth Pettie. Automatically Speeding Up LOCAL Graph Algorithms. In 7th Workshop on
Advances in Distributed Graph Algorithms (ADGA 2018), 2018. URL http://adga.hiit.ﬁ/2018/
Seth.pdf.
[26] Joel Rybicki and Jukka Suomela. Exact bounds for distributed graph colouring. In Proc.
22nd International Colloquium on Structural Information and Communication Complexity
(SIROCCO 2015), volume 9439 of Lecture Notes in Computer Science, pages 46–60. Springer,
2015. doi:10.1007/978-3-319-25258-2 4.
33


=== LCL_classification.pdf ===

--- Page 1 ---
Deciding Feasible-Function Existence for
β-Normalized, Radius-1 LCLs on Directed Paths is
in NEXPTIME
Abstract
We give a nondeterministic 2poly(β)-time algorithm that decides,
for a β-normalized, radius-1 LCL on globally oriented paths, whether
there exists a feasible function. This decides both gaps O(log∗n) vs.
Θ(n) (mid-consistency) and O(1) vs. Ω(log∗n) (bridging). Our proof
is self-contained modulo standard pumping/replacement facts for path
types; we restate the exact type bound, give a finite-checks lemma with
an explicit z-bound Z ≤ℓ2
pump, spell out the DP used by the verifier
(with boundary handling and tight O(kβ2) complexity), and prove
soundness/completeness. We use Section 4 and Lemmas 10–15, 11, 12,
as well as Theorems 8–9 from the reference.1
1
Model and Normalization (r=1)
We work on globally oriented paths. A β-normalized LCL is given by
Σin = {0, 1},
|Σout| = β,
Cin–out ⊆Σin × Σout,
Cout–out ⊆Σout × Σout,
and a labeling is legal iff (in(v), out(v)) ∈Cin–out for each node v and
(out(u), out(v)) ∈Cout–out for each directed edge u →v. The input size is
N = poly(β).
Types and pumping for r = 1.
For a path P = (u1, . . . , uk) with k ≥4,
define B1 = {u1, uk} and B2 = {u2, uk−1}. Two paths are type-equivalent if
1All background references (lemmas, constructions, and the two gap theorems) refer to
the uploaded PDF: The distributed complexity of locally checkable problems on paths is
decidable. See Section 4 (pp. 19–32), especially Lemmas 10–15 (types/pumping), Lemma 11
(replacement), Lemma 12 (type composition), and Theorems 8–9 (gap characterizations).
:contentReference[oaicite:1]index=1
1

--- Page 2 ---
(i) inputs on B1 ∪B2 match and (ii) the same boundary-output assignments
on B1 ∪B2 are extendible. Let Type(P) be the type. Counting: there are
24 choices for boundary inputs and a yes/no choice for each of β4 boundary-
output 4-tuples, so
M := |{Type(P)}| ≤24 · 2β4 = 2β4+4 = 2Θ(β4).
Set ℓpump := M. The DFA view of types and pumping/replacement lemmas
are in Section 4: Lemma 12 (type composition), Lemmas 10–11 (replacement),
and Lemmas 14–15 (pumping/periodicity).2
2
Contexts and Feasible Functions (no circularity)
Fix ℓpump. A context is any triple (w1, S, w2) with |w1|, |w2| ∈{ℓpump, ℓpump+1}
and S ∈Σ2
in. We identify contexts by the type of the concatenation w1Sw2.
Thus the set C of context types is a subset of the global type space, indepen-
dent of f.
Definition 1 (Feasible function). A map f : C →Σ2
out is feasible if:
• (F1) Mid-consistency. For any contexts waS1wb and wcS2wd, the
fixed outputs f(Type(waS1wb)) on S1 and f(Type(wcS2wd)) on S2
extend to a legal labeling of waS1 wbwc S2wd.
• (F2) Bridging. For any context (w1, S, w2) and all z ≥1, the fixed
outputs f(Type(w1Sw2)) on S extend to a legal labeling of wz
1Swz
2.
These are precisely the certificates that characterize the two gaps on cy-
cles/paths: (F1) ⇔O(log∗n) vs. Θ(n), and (F1)+(F2) ⇔O(1) vs. Ω(log∗n).3
3
Finite Checks for Bridging:
a clean periodic
bound
We now reduce the universal quantifier in (F2) to finitely many z.
Explicit statement of Lemma 15 and why it holds.
In the reference,
Lemma 15 states: for each nonempty word w ∈Σ+
in there exist integers
2See Lemmas 10–15 and Lemma 12,
Section 4 (pp. 20–23).
:contentRefer-
ence[oaicite:2]index=2
3See Theorems 8–9 (pp. 19–20, 27–32) for the constructions from feasible functions.
:contentReference[oaicite:3]index=3
2

--- Page 3 ---
a, b > 0 with a + b ≤ℓpump such that Type(wat+b) is independent of t ≥0.4
Why: consider the finite set of types T , |T | = ℓpump, and the self-map
Fw : T →T that composes by w. The sequence Ti := F i
w(T0) (here T0 is the
type of the empty prefix) has a repetition Tp = Tq with 1 ≤p < q ≤ℓpump;
setting a = q −p, b = p gives a + b = q ≤ℓpump and Tat+b constant for all
t ≥0. This is the standard orbit argument behind Lemma 15.
Lemma 1 (Finite z for bridging). Fix a context (w1, S, w2). There exist
parameters (ai, bi) for wi with ai+bi ≤ℓpump such that Type(wait+bi
i
) is t-
invariant. Hence the pair
 Type(wz
1), Type(wz
2)

takes at most a1a2 ≤ℓ2
pump
distinct values, and by type composition (Lemma 12) Type(wz
1Swz
2) also takes
at most ℓ2
pump values. Consequently, there exists Z ≤ℓ2
pump with
∀z ≥1 ∃z′ ∈{1, . . . , Z} : Type(wz
1Swz
2) = Type(wz′
1 Swz′
2 ).
Thus (F2) holds iff the partial outputs on S extend for all z ∈{1, . . . , Z}.
Proof. Apply Lemma 15 to each wi (periodicity), and use Lemma 12 (type
composition) to conclude that the type of wz
1Swz
2 is determined by the pair
of side types, whence the bound by pigeonhole. Extendibility depends only
on the resulting type and the fixed outputs on S (by the replacement lemma,
Lemma 11), so a single representative per type suffice.5
How we pick Z in practice.
We will use the worst-case bound Z = ℓ2
pump;
this keeps the algorithm simple and does not affect the asymptotic bound.
(Optional refinement: for a fixed context, compute the cycle structure of
Fw1 and Fw2 in the type DFA and set Z to the lcm of periods times the
max preperiod—still ≤ℓ2
pump—which can reduce constants while remaining
2poly(β) overall.)
4
Deterministic DP for extendibility (with precise
complexity)
All checks reduce to deciding if a partially labeled path admits a completion.
For r = 1:
4Lemma 15 (p. 23). :contentReference[oaicite:4]index=4
5Lemma 12 (type composition) and Lemma 11 (replacement) are in Section 4 (pp.
21–22, 20–21). :contentReference[oaicite:5]index=5
3

--- Page 4 ---
Layered automaton.
Given a path P = (v1, . . . , vk) and a set F of forced
positions with outputs oi ∈Σout, build k layers, one per position. Layer i
keeps the set
Li := {x ∈Σout : ( in(vi), x ) ∈Cin–out and if i ∈F, x = oi}.
Insert a directed edge x →y from layer i to i+1 iff (x, y) ∈Cout–out. There
is a legal completion iff the layered graph has a path from some state in layer
1 to some state in layer k.
Running time and memory.
Let k = |P|. Constructing layers and edges
takes O(k · |Cout–out|) time, which is O(kβ2) in the worst case, and O(kβ)
memory. Forced nodes reduce the number of states (they do not increase
complexity): the check is a standard reachability on this DAG, also in O(kβ2)
time.
5
Nondeterministic algorithm and correctness
Precomputation (deterministic, 2poly(β))
1. Enumerate all types T by exploring the boundary-extendibility DFA
(Lemma 12), set ℓpump = |T | ≤2Θ(β4).6
2. For each type t ∈T and each boundary assignment on B1 ∪B2, pre-
compute extendible? via DP on a fixed representative of type t (length
O(ℓpump)).
3. Compute the set C ⊆T of context types: those realized by some w1Sw2
with |wi| ∈{ℓpump, ℓpump+1} and |S| = 2. Note |C| ≤ℓpump.
Guess
Nondeterministically guess f(τ) ∈Σ2
out for every τ ∈C.
Verify (deterministic, 2poly(β))
(V1) Mid-consistency. For each ordered pair of contexts (waS1wb, wcS2wd), run the DP on
waS1 wbwc S2wd with the two 2-node windows S1, S2 forced to f; accept
only if the DP succeeds. Why no extra buffers: by definition of contexts,
6Type DFA and counting bound: Lemma 13 (p. 22) specialized to r=1 gives |T | ≤24·2β4.
:contentReference[oaicite:6]index=6
4

--- Page 5 ---
wb, wc each has length ℓpump or ℓpump+1, so the underlined bridge wbwc
is already a long buffer for the replacement lemmas.
(V2) Bridging. For each context (w1, S, w2) and each z = 1, . . . , Z with Z = ℓ2
pump from
Lemma 1, run the DP on wz
1Swz
2 with the two nodes of S forced to f.
(All seams internal to wz
1 and wz
2 are covered by this DP; no separate
”seam test” is needed.)
Theorem 1 (Soundness and completeness). If the verifier accepts some
guessed f, then f satisfies (F1) and (F2); conversely, if a feasible f exists,
some guess passes (V1)–(V2).
Proof sketch. (V1) is exactly (F1). For (F2), Lemma 1 shows it suffices to
check z ≤Z; (V2) performs those checks with a DP that validates all local
constraints, including seams created by repetition. Conversely, a feasible f
passes (V1) and by Lemma 1 also passes (V2) for all z ≤Z, hence for all
z.
Complexity and main theorem
Precomputation explores T and runs DPs on O(ℓpump)-length words, all in
2poly(β) time. Verification runs a polynomial number of DPs on strings of
length O(ℓ3
pump) (worst case, from z ≤ℓ2
pump and context width O(ℓpump)),
each in O(kβ2); altogether 2poly(β) = 2poly(N) time.
Theorem 2 (Main). Feasible-Function Existence for β-normalized,
radius-1 LCLs on directed paths is in NEXPTIME.
6
Connection to the two gaps
We use the standard implications:
• (F1) ⇒O(log∗n) and failure of (F1) ⇒Θ(n) (Theorem 8, with MIS-
based decomposition, Lemma 16).7
• (F1)+(F2) ⇒O(1) and failure of (F2) ⇒Ω(log∗n) (partition Lem-
mas 20–22 and fill-in Lemmas 26–27 culminating in Theorem 9).8
7Theorem 8 and Lemma 16 (pp. 19–20, 22–24). :contentReference[oaicite:7]index=7
8Lemmas 20–22 and Lemmas 26–27 with Theorem 9 (pp. 27–32).
:contentRefer-
ence[oaicite:8]index=8
5

--- Page 6 ---
7
Positioning and bounds (summary)
Known lower bound
PSPACE-hard to distinguish O(1) vs. Ω(n) on oriented paths (Sec. 3, Thm
This work (upper bound)
NEXPTIME for Feasible-Function Existence under poly(β) encoding.
Tightness
Open under this encoding (EXPTIME? PSPACE?).
See pp. 14–16 for hardness and β-normalized constant-time lower bounds.9
Notes
Non-circularity.
Context types are defined as a subset of global types
(those realized by w1Sw2 with |wi| ∈{ℓpump, ℓpump+1}), independently of f.
General r > 1 (remark).
All arguments lift to any fixed radius r: the
type space size becomes 2poly(βO(r)) (cf. Lemma 13), the DP has βO(r) states
per layer, and Lemma 1 still yields a finite Z from the same periodicity
argument.10
A
Optional algebraic view (boolean matrices with
the seam)
Let A ∈{0, 1}β×β be the adjacency of Cout–out: A[x, y] = 1 ⇐⇒(x, y) ∈
Cout–out. For a word w, define Cw ∈{0, 1}β×β by (Cw)ij = 1 iff there is a legal
labeling of w whose first/last outputs are i/j and nodewise (in(·), out(·)) ∈
Cin–out. Then boolean multiplication gives the exact composition law
Cxy = Cx A Cy,
hence
Cwz = Cw (ACw)z−1.
Proof: (i, k) ∈Cxy iff there exists j such that (i, j) ∈Cx, (j, k) ∈Cy, and
the seam output pair is legal, i.e. (j, ·) to (·, k) goes through an edge in
A—which is exactly the middle factor. This algebraic view is not needed for
the algorithm (the DP already checks seams), but it explains the role of the
seam explicitly.
9Hardness and β-normalized lower bounds: Theorems 4–5 (pp. 14–16). :contentRefer-
ence[oaicite:9]index=9
10Lemma 13 (p. 22) gives the general type bound. :contentReference[oaicite:10]index=10
6

--- Page 7 ---
B
NEXPTIME-hardness (explicit β-normalized radius-
1 model)
We prove that Feasible-Function Existence (mid-consistency (F1) only)
for β-normalized, radius-1 LCLs on globally oriented paths is NEXPTIME-
hard. Together with Theorem 2, this yields NEXPTIME-completeness. The
reduction is from Succinct-3SAT: a circuit C of size s defines, for each index
j ∈{0, 1}B, a 3-clause clause(j) over variables x1, . . . , x2B; the question is
whether the 2B-variable CNF ΦC is satisfiable.
What we use from the toolbox.
We rely on (i) the types/replacement/pumping
machinery (Lemmas 10–12, 14–15 in §4 of the reference), and (ii) the error-
chain technique to make malformed encodings harmless (as in §3 of the
reference).11
B.1
Target: FFE(F1) for β-normalized r=1
Recall our feasible-function existence problem FFE(F1): given Σin = {0, 1},
|Σout| = β, Cin–out ⊆Σin×Σout, Cout–out ⊆Σout×Σout, decide if there is a
map f : C →Σ2
out (on context types) satisfying mid-consistency (F1), cf. the
definition in the upper bound section.
B.2
Source and parameters
Let C be a succinct 3CNF generator of size s. Set
B = sc0,
β = sc1,
for large enough absolute constants c0 ≪c1 fixed below. We will build, in
poly(s) time, a β-normalized LCL PC = (Σin, Σout, Cin–out, Cout–out) such
that
ΦC is satisfiable
⇐⇒FFE(F1) holds for PC.
(1)
Since |Σout| = β = poly(s), the type space size ℓpump := |{Type(·)}| satisfies
ℓpump ≤2Θ(β4) = 2poly(s), and hence the contexts in C (those realized by
w1Sw2 with |wi| ∈{ℓpump, ℓpump+1}) cover exponentially many patterns,
which we will exploit.12
11Types, replacement, pumping: §4, Lemmas 10–15; error-chains and bounded-tape
execution checking: §3. :contentReference[oaicite:0]index=0
12Type bound and composition/replacement: §4, Lemma 13 (bound), Lemma 12 (compo-
sition), Lemma 11 (replacement), and Lemmas 14–15 (pumping/periodicity). :contentRef-
erence[oaicite:1]index=1
7

--- Page 8 ---
B.3
The block language and the verifiers
We describe Σout and the two verifiers in the β-normalized form.
The
construction follows the standard ”copy input and check a tableau by nearest-
neighbor rules” recipe, together with the error-chain gadget that guarantees
malformed inputs never constrain f.13
Alphabet Σout.
Each output symbol encodes a constant number of tracks:
(T1) a bit in which must copy the node’s input bit (enforced by Cin–out);
(T2) a role from a constant set {HEAD, RID, GID, RUN, PAD} and a constant-
size phase (synchronization);
(T3) three colors {RED, GRN, BLU} (used only at the 2-node window S);
(T4) a special plumbing symbol ⊥;
(T5) a bounded collection of error symbols (the error-chain alphabet) as in
§3;
(T6) (for RUN) the working alphabet for a fixed universal TM U running in
BO(1) time.
Thus |Σout| = β = poly(s).
The intended block.
A well-formed block (a regular language over Σout)
has the form
HEADC RID GID RUN PAD,
where:
• HEADC is a self-delimiting binary header that literally stores C on the
in track (copied to output by (T1)) and marks the start of a block.
• RID is a B-bit variable index region; GID is a B-bit clause index region.
• RUN is a row-by-row encoding of a tableau of the fixed machine U which,
given (C, RID, GID), runs for BO(1) steps and computes the three literals
13The radius-1 checking of a 1D flattening of a time poly(B) computation and the
error-chain idea are lifted verbatim from §3 (LBA encoding + locally checkable refutations).
:contentReference[oaicite:2]index=2
8

--- Page 9 ---
of clause(GID) and their signs, and writes three length-B one-hot vectors
V (+), V (−) and V (⊥) on dedicated subtracks:
V (+)[i] = 1 ⇐⇒xi occurs positively in clause(GID),
V (−)[i] = 1 ⇐⇒¬xi occurs,
and V (⊥) is always all zero (reserved for BLU).
• In variable blocks we also run U on (C, RID) to materialize a variable
one-hot vector HotRID ∈{0, 1}B with HotRID[i] = 1 iff i = RID.
The adjacency table Cout–out permits exactly nearest-neighbor pairs con-
sistent with (i) the grammar above (placement of regions, row separators,
phases), and (ii) single-step correctness of U’s transition across each row
seam; malformed pieces are locally refutable by emitting an error-chain (as
in §3), which we also allow in Cout–out and which always leads to a successful
completion.14
The window S and activation.
The two nodes of the window S (in
contexts w1Sw2) may be labeled at f’s discretion by one of the colors
{RED, GRN, BLU} or by ⊥. No other output is allowed at S. The out–out
grammar is arranged so that:
The choice ⊥at S is always extendible. A non-⊥color at S
is extendible only if somewhere inside w1 (resp. w2) there is a
well-formed block whose HEADC matches the fixed header for C,
and whose RID (resp. GID) and tableau are valid.
We say such contexts are active; all other contexts are inactive. Inactive
contexts are thus tautologically satisfied by setting f(·) = ⊥.
Bridge semantics (the ”clause satisfied by variable” test).
For an
active ordered pair (variable on the left, clause on the right), the bridge (F1)
instance waS1wbwcS2wd is allowed to complete iff
∃i ∈[B] with HotRID[i] = 1 and





V (+)[i] = 1
if f(Type(left)) = RED,
V (−)[i] = 1
if f(Type(left)) = GRN,
V (⊥)[i] = 1
if f(Type(left)) = BLU.
14Exactly as in §3: a fixed finite set of error types and local rules allow every malformed
tableau to be disproved by a short, locally checkable chain; on well-formed encodings such
chains cannot be produced. :contentReference[oaicite:3]index=3
9

--- Page 10 ---
This ”∃i” is checked by a standard radius-1 witness chain: upon a color
choice at S1 and S2, the out–out grammar enables a path that (i) guesses
an index i, (ii) walks to bit i inside the left block and requires HotRID[i] = 1,
and (iii) walks to bit i inside the right block and requires the corresponding
V (·)[i] = 1. If any subcheck fails, the chain gets stuck (no completion). This
is exactly the same local ”existential witness” mechanism as in the error-
chain gadget, so it is implementable with radius 1 and a constant alphabet
overhead.15
All other ordered pairs of context types are trivialized: either at least one
side is inactive (then ⊥suffices), or the role pairing is not (variable, clause),
in which case the grammar ignores the colors and accepts with ⊥buffers.
B.4
Existence of exponentially many active context types
Because ℓpump = 2poly(s) and our header+index+run occupy O(s) + O(B) +
BO(1) = poly(s) symbols, by the pumping lemmas there are context types
that (i) have a valid block with any desired RID ∈{0, 1}B on the left and
(ii) context types that have a valid block with any desired GID on the right.
Moreover, types that differ in RID (or in GID) are distinct because, by design,
extendibility from S under a color differs for some bridge depending on the
bit pattern (the witness chain succeeds or not). Hence there are 2B = 2poly(s)
distinct variable types {Vari} and 2B distinct clause types {Clj} present
in C.16
B.5
Correctness of the reduction
We prove (1).
Lemma 2 (Completeness). If ΦC is satisfiable, then there exists f : C →Σ2
out
satisfying (F1) for PC.
Proof. Fix a satisfying assignment α : {x1, . . . , x2B} →{0, 1}. Define f as
follows.
• For each variable type Vari, set f(Vari) = RED if α(xi) = 1 and
f(Vari) = GRN if α(xi) = 0 (either orientation of S may be chosen; the
grammar handles both).
15Witness chains (existential pointers to positions with local checking) are the same
combinatorics as the §3 error pointers; we reuse their radius-1 implementation. :contentRe-
ference[oaicite:4]index=4
16Realization and stability of these patterns inside wb or wc follow from type compo-
sition and replacement; lengths are padded using pumping (§4, Lemmas 11–12, 14–15).
:contentReference[oaicite:5]index=5
10

--- Page 11 ---
• For each clause type Clj, pick any true literal of clause(j) under α and
set f(Clj) to its color: RED for a positive literal, GRN for a negative
literal (use BLU only if desired as a dummy literal, with V (⊥) ≡0 never
satisfying witnesses).
• For all inactive types, set f(τ) = ⊥.
Consider any ordered pair of contexts in the (F1) quantification. If at least
one side is inactive or the roles are not (variable, clause), the bridge is
trivial by construction. If the pair is (Vari, Clj), then by the definition of
the RUN subtracks we have HotRID[i] = 1 inside Vari, and V (+)[i] = 1 (resp.
V (−)[i] = 1) if we chose RED (resp. GRN) at Clj and the picked literal is xi
(resp. ¬xi). Since f(Clj) is a true literal of clause(j), such a choice exists,
and the bridge DP succeeds via a witness chain at index i. Hence every (F1)
check passes.
Lemma 3 (Soundness). If there exists f satisfying (F1) for PC, then ΦC is
satisfiable.
Proof. From f, read an assignment α by
α(xi) =





1,
f(Vari) = RED,
0,
f(Vari) = GRN,
arbitrary,
f(Vari) = BLU (we may fix it to 0),
for all variable types Vari (if f(Vari) = ⊥, the type is inactive, impossible
by construction of Vari). Fix any clause index j. If f(Clj) = ⊥then Clj is
inactive, which contradicts the existence of the header+RUN in Clj; hence
f(Clj) ∈{RED, GRN, BLU}.
Consider the (F1) bridge for the ordered
pair (Vari, Clj) where i ranges over all variables that appear in clause(j).
The out–out grammar allows completion only if there exists an index i
with HotRID[i] = 1 in Vari and the corresponding V (+)[i] = 1 (for RED)
or V (−)[i] = 1 (for GRN) in Clj. Because (F1) must hold for every such
ordered pair, the choice f(Clj) must be compatible with at least one Vari
that actually occurs in clause(j); therefore the picked color is a true literal
under α. Since j was arbitrary, every clause has a true literal: α satisfies
ΦC.
Lemma 4 (Inactive contexts never constrain f). If a context lacks a well-
formed header+indices+valid RUN (on either side), then any output at S
except ⊥makes the (F1) bridge DP fail, while ⊥always extends. Thus such
contexts are irrelevant and do not affect the existence of f.
11

--- Page 12 ---
Proof. Both statements follow from the grammar: non-⊥at S activates
witness chains that must eventually check bits inside a block; in the absence
of a valid block the chain gets stuck and no completion exists. Conversely,
when S is ⊥, the out–out table contains a self-looping ⊥buffer language that
trivially completes the bridge (the same plumbing as in the upper-bound
DP). The error-chain rules guarantee that malformed fragments admit locally
checkable refutations and hence do not impose constraints.17
Theorem 3 (FFE(F1) is NEXPTIME-complete). For β-normalized, radius-
1 LCLs on globally oriented paths (explicit model), Feasible-Function
Existence is NEXPTIME-complete.
Proof. Membership is Theorem 2. For hardness, the reduction C 7→PC runs
in poly(s) time and produces |Σout| = β = poly(s) with adjacency tables of
size Θ(β2). By Lemmas 2–4, (1) holds. Hence FFE(F1) is NEXPTIME-
hard.
B.6
From (F1) to the full feasible-function (F1)+(F2)
To pass from mid-consistency to the full feasible-function existence (bridging
included), add a neutral symbol ⊥(already present) and allow, in Cout–out,
arbitrary ⊥-labelings on repetitions wz
1 and wz
2. Then (F2) is vacuous: for
every context (w1, S, w2) and every z ≥1, the partial labeling that fixes S
to f(Type(w1Sw2)) extends by filling wz
i with ⊥. Hence:
Corollary 1 (Classification hardness). Deciding the distributed class (O(1)
vs. O(log∗n) vs. Θ(n)) via feasible functions is NEXPTIME-hard in the
explicit β-normalized, radius-1 model.
B.7
Size and radius bookkeeping
All rules are radius 1. The only growth parameter is β = poly(s), which
controls the number of output symbols needed for (i) the fixed role/phase
tracks, (ii) the three color tokens {RED, GRN, BLU} and ⊥, (iii) the fi-
nite error alphabet, and (iv) the universal machine U work alphabet. The
header+indices+RUN occupy O(s) + O(B) + BO(1) = poly(s) positions,
17See §3 for the error-chain ”disprover” gadget accepted by the verifier, ensuring mal-
formed encodings always have completions, and §4 for the ”plumbing” view of the DP.
:contentReference[oaicite:6]index=6
12

--- Page 13 ---
whereas the pump length satisfies ℓpump = 2Θ(β4) = 2poly(s), which guaran-
tees that active contexts containing such blocks exist and are stable under
replacement/pumping.18
18All quantitative bounds (type count, replacement, pumping) follow from §4; the
error alphabet and local checking of bounded-time executions are from §3. :contentRefer-
ence[oaicite:7]index=7
13


=== round-0003/verifier.feedback.md ===
High-level assessment
- All four reports converge on a coherent strategy: (i) construct exponentially many vertex-context types via a uniform, radius-1 per-bit probe family {Q_j}; (ii) gate colors at S to canonical vertex blocks; (iii) implement a seam tableau that computes D(u,v) and enforces inequality on edges; (iv) neutralize (F2) by a global ⊥-plumbing. Prover 02 additionally proposes an Eq(u,v) gate to force consistency across left/right copies of the same vertex.

Strengths and correctness
- The per-bit probe idea is sound in our static LCL model: reserving O(B) boundary-output 4-tuples and O(B) probe-head states Head_j allows radius-1, globally uniform constraints that force a unique “probe mode” continuation, walking to the unique Addr=j cell and accepting iff RID[j]=1 (RID tied to Σ_in by Cin–out). This yields E_{L(u)}(a⋆)[Q_j]=u_j for a fixed boundary input a⋆, hence 2^B distinct left-types; symmetric on the right. Alphabet/radius bookkeeping is consistent (β=poly(s), β≥Ω(B)).
- The seam tableau concept is standard: a row-by-row 1D simulation across the bridge that reads enc(D), u, v and emits EDGE (and optionally Eq). Enforcing “EDGE=1 ⇒ colors differ” via radius-1 checks between S and its near neighbor is feasible, as is adding “Eq=1 ⇒ colors equal.” Disabling error-chains in active modes prevents spurious accepting completions.

Gaps, risks, and needed corrections
1) Color gating vs mixed pairs: Some text (esp. Prover 02) suggests that if one side is inactive and the other side is colored, the pair dead-ends. That would make any f that colors canonical types infeasible, because mixed (active, inactive) pairs are unavoidable in F1. The fix: allow color on a canonical side regardless of the opposite side; make the seam “active” only if both sides are canonical (both handshakes present). Mixed pairs must accept unconditionally (with the inactive side carrying ⊥ by gating), so f can color canonical types and map inactive types to ⊥ without violating F1.
2) Must-color policy: If both sides are canonical, we may enforce “must color” (both S nodes non-⊥) to prevent trivial satisfactions; but this must not leak to mixed pairs. Clarify this locality in the rules: “must-color” triggers only when both handshakes are present.
3) S-symbol control by f: Ensure the only component of the S output chosen by f is the color/⊥ token; any auxiliary phase/handshake bits at S must be fixed by local adjacency with the internal neighbors, not by f. Otherwise f would need to be context-aware.
4) Eq gating is a helpful addition (Prover 02): it forces consistency across duplicates by making (L(u),R(u)) acceptance contingent on color equality. This avoids having to prove uniqueness of the canonical type per u. Please incorporate Eq into the seam policy: accept iff (EDGE=0 or colors differ) and (Eq=0 or colors equal), with “must-color” only in active-active pairs.
5) Length normalization: Several proofs appeal to pumping/replacement lemmas to place W_L(u),W_R(v) adjacent to S at lengths ℓ_pump or ℓ_pump+1. We have not formalized these lemmas in output.md; until they are provided (or we give a direct construction), the existence of canonical contexts at the prescribed lengths remains an assumption. Move this to notes; do not claim it as proven.
6) Determinism under reserved probes: You must explicitly list that in probe mode (under Q_j) no ERR/⊥ or alternative plumbing pairs are allowed adjacent to probe states, and that Head_j can only move over a pre-laid corridor that necessarily reaches the port zone. Otherwise, hidden alternative completions could break E(a⋆)[Q_j]=u_j.
7) Seam wiring locality: State explicitly that EDGE/Eq live in the neighbor on the right of S2 (and/or the left of S1), and that the forbidden pairs are between S2 and this neighbor (e.g., forbid (EDGE=1, ForwardedColor=Color(S2)), require (Eq=1 ⇒ ForwardedColor=Color(S2))). Avoid using S–S pairs to carry EDGE/Eq information.
8) Budgeting: When using O(B) Addr values and O(B) probe states (and possibly O(B) boundary symbols Q_j), confirm the combined blow-up fits β with a concrete constant factor. All reports assert this; a short symbol count would remove doubt.

What is worthy to keep and what to postpone
- Keep: the TS probe lemma blueprint (Option A with address track), seam tableau with EDGE and Eq gating, and the refined color gating policy (colors allowed per-side; seam active only if both sides canonical; must-color only in active-active pairs). Alphabet and radius bookkeeping is consistent. These are solid directions.
- Postpone from output.md: any claimed theorem that depends on unspecified pumping/replacement lemmas, or on informal “dead-end”/“unique continuation” without enumerated local rules. Keep them in notes for now.

Concrete next steps (auditable deliverables)
1) Probe rules table (B-parameterized): enumerate the allowed Cout–out pairs for Start_j, Head_j, Test_j, Accept_j; the PORT zone adjacency enforcing Addr monotonicity; the Cin–out mask tying RID to Σ_in when Role=PORT; and the explicit rule that probe-mode forbids ERR/⊥.
2) S gating rules: define the per-side handshake tokens adjacent to S that (i) enable color at that S, (ii) do not depend on the opposite side, and (iii) trigger “active seam” only when both sides present handshakes. Add explicit pairs for mixed pairs to accept unconditionally.
3) Seam tableau snippet: specify the row alphabet and the final cell next to S2 that carries (EDGE,Eq,ForwardedColor(S1)). List the constant-size forbidden/allowed pairs between S2 and this neighbor.
4) B=2 instance: provide concrete Σ_out symbols and Cin–out,Cout–out entries so the O(kβ^2) DP can verify (i) E_{L(u)}(a⋆)[Q_1,Q_2]=(u_1,u_2), and (ii) seam acceptance rules for all 16 ordered pairs (L(u),R(v)).
5) Either add a self-contained pumping/replacement lemma to output.md (with proof) or rephrase the construction to directly build contexts of the two target lengths while preserving the local shape near S.


=== notes.md ===
Working model and notation (radius 1, β-normalized)
- We study LCLs on globally oriented paths with fixed input alphabet Σ_in and output alphabet Σ_out of size β. The local legality is given by two global relations: Cin–out relating each input symbol to allowed output symbols at a node, and Cout–out relating allowed pairs of consecutive output symbols. The radius is 1.
- A path segment w has four boundary nodes (two on the left, two on the right). For a fixed assignment to the four boundary inputs, we define the extendibility bitvector over all β^4 assignments to the four boundary outputs indicating for which boundary-output assignments there exists a legal extension to the interior.
- The type Type(w) is the collection, over all 4-boundary input assignments, of these extendibility bitvectors. Two words share a type if they have identical extendibility behavior for all boundary input/output assignments. Let T be the finite set of all types realizable by some word.

Verified technical facts (recorded in output.md)
- Type bound: |T| ≤ |Σ_in|^4 · 2^{β^4}. Reason: a type is determined by four boundary input symbols and a Boolean function on the β^4 boundary output assignments.
- Composition lemma: There is a computable binary operation ⊛ on T such that Type(uv) = Type(u) ⊛ Type(v) for all words u, v. Intuition: to decide extendibility of uv under a boundary-output assignment, one needs only (i) the extendibility tables of u and v, and (ii) existentially quantify over the two internal boundary outputs to satisfy Cout–out at the join.
- Periodicity: For any fixed word w, the sequence τ_z := Type(w^z) is ultimately periodic with preperiod and period ≤ |T|. Thus the pair sequence (Type(w1^z), Type(w2^z)) is ultimately periodic with preperiod ≤ 2|T| and period ≤ |T|.
- Finite-Z for (F2): Given any context (w1, S, w2), whether the (F2) check passes for all z ≥ 1 depends only on finitely many pairs (Type(w1^z), Type(w2^z)); it suffices to check z up to Z ≤ |T|^2 (a non-tight but simple bound).
- DP for extension: For a fixed path with some outputs forced (e.g., on S), the existence of a global completion can be decided in O(k β^2) time for a length-k path by a layered dynamic program over output symbols.

Hardness direction we will pursue (pivot suggested by Prover 01)
- Source problem: Succinct 3-Coloring of a graph G on V={0,1}^B, given by a circuit D(u,v) (size s) deciding adjacency; NEXP-complete.
- Target LCL: Construct a β-normalized, r=1 instance P_D with Σ_out size β = poly(s). The plan:
  1) For each u, build at least one context type τ_u whose boundary behavior (detected via a reserved boundary-probe) certifies that the interior encodes the index u in a standard, radius-1-checkable block. The interior also stores a copy of D on an input track and a runzone for a fixed TM U.
  2) In a bridge between τ_u and τ_v, locally simulate U on input (D,u,v) across the seam for poly(s) steps to evaluate D(u,v); malformed simulations are locally refutable.
  3) Gate constraints: if D(u,v)=0 (non-edge) allow completion regardless of colors; if D(u,v)=1 enforce color inequality across S. All other pairings (not recognized as vertex–vertex) are trivial.
  4) Assigning a color to each τ_u by a feasible function f is then exactly a proper 3-coloring of G.
  5) Make (F2) vacuous by allowing repeated sides to be filled with a globally available ⊥-plumbing language.

Open technical items for hardness (to be formalized next)
- Boundary-probe/type-separation lemma: Exhibit a fixed boundary-output probe that, when used, triggers an interior index-check subroutine; show that for distinct indices u ≠ u′, the probe’s extendibility bit differs, hence τ_u ≠ τ_{u′}.
- Seam handshake and computation: Specify the constant-size interface by which the bridge accesses (via pointers) the interior encodings of u and v and runs the 1D tableau for U for poly(s) steps, with radius-1 local checks and robust error refutations.
- Alphabet/size bookkeeping: Keep Σ_out constant tracks (roles, colors, error, U’s work alphabet) constant, with β = poly(s) sufficient for all auxiliary symbols.
- Soundness/completeness proof for the reduction P_D: G is 3-colorable iff a feasible f exists for P_D (with (F2) neutralized).

Caveats and corrections logged
- Short seam codes cannot distinguish exponentially many indices; instead use constant-size pointers/handshakes plus interior blocks that store and validate indices.
- Do not attempt to “program arbitrary boundary truth tables per type” via Cout–out; all rules are global. Use boundary probes plus uniform interior checks to separate types.
- For 3SAT-based reductions, the (F1) universal quantifier clashes with clause-level existential quantification unless one adds complex nondeterministic gating. The succinct 3-coloring pivot avoids this.
Refined hardness plan via Succinct 3-Coloring: type separation and seam simulation (radius 1)

Parameters and normalization
- Given a succinct graph instance D of size s over V={0,1}^B with B=s^{c0}, choose β=s^{c1} with c1≥c0 so β≥B and the output alphabet Σ_out has size β. The LCL instance P_D has radius 1 and is β-normalized (Cin–out global, Cout–out nearest-neighbor global). The DP and type framework from output.md applies with |T|≤|Σ_in|^4·2^{β^4}.

Canonical vertex contexts and activity gating
- We will construct canonical context shapes L(u)=W_L(u) S F_R and R(v)=F_L S W_R(v) for each u,v∈{0,1}^B such that:
  1) W_L(u) (resp. W_R(v)) is a well-formed vertex block anchored O(1) from S; it exposes a port zone of length Θ(B) immediately adjacent to S holding the index bits.
  2) Only these canonical contexts permit color tokens at S (role gating). Any context that is not a canonical vertex context is inactive: any non-⊥ token at S dead-ends locally; ⊥ at S always extends via neutral plumbing.
  3) For each u (resp. v) the type Type(L(u)) (resp. Type(R(v))) depends only on u (resp. v) via a boundary-probe mechanism detailed below. Thus we obtain at least 2^B distinct left-types and 2^B distinct right-types.

Type separation via a family of boundary probes (two workable options)
- Option A (per-bit probes Q_j with address field): Reserve B distinct boundary-output 4-tuples {Q_j : j∈[B]}. In the port zone, include an address track Addr∈[B] and a data track RID∈{0,1}. Local rules enforce that under boundary outputs Q_j the only legal continuation is a deterministic pointer that walks from the boundary to the unique port cell with Addr=j and then accepts iff RID=1 at that cell; otherwise no continuation exists. For all non-reserved boundary outputs we allow generic ⊥-plumbing so they do not affect separation. Fix a boundary-input pattern a⋆. Then for each u we have E_{L(u)}(a⋆)[Q_j]=u_j. Consequently, u≠u′ implies Type(L(u))≠Type(L(u′)). This uses O(B) extra symbols (addresses/pointer states) and remains within β=poly(s).
- Option B (mask/parity probes with M≥B tests): Reserve M boundary-output 4-tuples {b_t : t∈[M]} with M≥B. Store in the input of W_L(u) a table of M masks M_t∈{0,1}^B (with the B×M matrix of full rank over GF(2)) and the RID block u. Under boundary outputs b_t, a deterministic pointer reads M_t and then the RID block and accumulates the inner product ⟨M_t,u⟩ mod 2 using a small “RUN” zone (row-by-row locally checked). Accept iff the parity is 1. Define Sig(u)=(⟨M_t,u⟩)_t∈{0,1}^M; Sig is injective because M≥B and the masks are independent. Fixing a boundary-input a⋆, E_{L(u)}(a⋆)[b_t]=Sig(u)_t, so types differ for distinct u. Again, the probe behavior is radius-1 and β=poly(s) suffices.
- In both options, under reserved probes the control is deterministic (no error-chain escape). Outside reserved probes, error-chains and ⊥-plumbing ensure malformed interiors do not constrain f.

Seam gadget for succinct adjacency and color inequality
- In an (F1) instance on L(u) seam R(v), the bridge wb∘wc hosts a row-by-row simulation of a fixed TM U that evaluates D(u,v) in poly(s) steps:
  1) The port zones adjacent to S on each side expose the B-bit strings u and v. A small handshake track opens a corridor through wb∘wc where U’s tableau is laid out.
  2) Cout–out enforces nearest-neighbor consistency between successive rows; malformed rows are locally refutable (no accepting continuation). The run emits a verdict bit EDGE∈{0,1} at a fixed place near S.
  3) Local acceptance: If EDGE=0 (non-edge), admit completion irrespective of colors at S; if EDGE=1 (edge), admit completion iff the two color tokens at the two S nodes differ. These are radius-1 checks.
- If either side is inactive (not a canonical vertex context), a ⊥-plumbing language allows completion irrespective of the other side and the colors; however, the role gating forbids colors at S for inactive types, so mapping inactive types to a color would violate (F1) on some pair.

Neutralizing (F2)
- Add a global ⊥-filler that, for any context (w_1,S,w_2) and any z≥1, allows filling w_1^z and w_2^z entirely with ⊥ symbols, consistent with any boundary outputs and inputs, without altering the two S positions or the vertex-role gating. Then (F2) holds for every f, reducing the 3-way classification on this family to (F1)-feasibility.

Why this matches our DP/type framework
- Types are defined with respect to fixed inputs; the reserved-probe acceptance depends only on the interior index u and the chosen boundary 4-tuple, so it is type-invariant. The DP in O(kβ^2) can verify both probe behavior and seam runs on small test instances (e.g., B=2), giving a concrete auditable path.

Key cautions to enforce in the local rules
- Reserved probes must have a unique legal continuation (deterministic pointer/run); no error-chain may provide an alternative accepting path.
- Color tokens at S must be gated by the vertex role; inactive contexts cannot place colors, ensuring f is only free on canonical vertex types and ⊥ elsewhere.
- The seam gadget must accept for non-edges regardless of colors and enforce inequality for edges; malformed simulations must not accept.

Minimal sanity check (B=2)
- Use Option A with Q_1,Q_2 and an Addr track {1,2} in the port zone. For u∈{00,01,10,11}, the vector (E_{L(u)}(a⋆)[Q_1], E_{L(u)}(a⋆)[Q_2]) equals u. The seam gadget with a small circuit D (e.g., a 4-cycle) enforces inequality exactly on edges, which can be brute-forced by the DP.
Consolidated plan and corrections for the S3Col → F1 reduction (radius 1, β-normalized)

Parameters and model
- Input: succinct graph on V={0,1}^B specified by circuit D of size s. Choose β=s^{c1} with c1≥c0 so β≥Θ(B) and there is symbol budget for O(B) auxiliary symbols. All constraints are radius 1 via Cin–out and Cout–out.

Canonical vertex blocks and activity
- Left canonical block W_L(u) adjacent to S exposes a port zone of length B with two subtracks: Addr∈{1,…,B} and RID∈{0,1}. Local rules enforce Addr increases by 1 left→right and Cin–out ties RID to Σ_in. The B-bit word u is RID[1..B]. Right canonical block W_R(v) is symmetric.
- Per-side color gating (corrected): S may carry a color token {R,G,B} on a side iff the adjacent interior begins with a well-formed canonical vertex header (per-side handshake). This decision is per-side and does not depend on the opposite side. If the header is absent or malformed, the only allowed S token on that side is ⊥.
- Seam activation: The seam gadget is “active” only when both sides are canonical (both per-side handshakes present). Mixed pairs (only one side canonical) are “semi-active” and must accept unconditionally (see below), so that f may color canonical types without violating F1 on mixed pairs.

Type separation via per-bit probes (Option A)
- Reserve B distinct boundary-output 4-tuples {Q_j}. Under boundary inputs a⋆ and outputs Q_j, Cout–out forces a deterministic probe mode starting at the boundary, carrying a tagged head Head_j that moves along a pre-laid corridor to the unique cell in the port zone with Addr=j. At that cell, continuation exists iff RID=1. While in probe mode, error/⊥ symbols are forbidden from appearing adjacent to probe states; outside reserved probes, standard error/⊥ plumbing is allowed.
- Claim (TS): For any canonical left vertex word L(u), E_{L(u)}(a⋆)[Q_j]=u_j. Hence u≠u′ ⇒ Type(L(u))≠Type(L(u′)). Symmetric on the right. This uses only radius-1 locality and O(B) symbol budget.

Seam tableau and acceptance
- Active seam (both sides canonical): The bridge wb∘wc hosts a row-by-row tableau of a fixed TM U computing EDGE:=D(u,v) and Eq:=[u=v] in poly(s) steps. The last row writes (EDGE,Eq,ForwardedColor(S1)) into the cell immediately to the right of S2. Local rules between S2 and this neighbor enforce simultaneously:
  (A) if EDGE=1 then Color(S2)≠ForwardedColor(S1) (inequality on edges), else vacuous; and
  (B) if Eq=1 then Color(S2)=ForwardedColor(S1) (same-vertex consistency), else vacuous.
  Additionally, a must-color rule is enforced only in this active-active case: both S sides must be non-⊥.
- Semi-active seam (mixed pair): If exactly one side is canonical, the colored side is allowed (by per-side gating), the opposite side must be ⊥, and the seam does not activate; the pair must accept unconditionally (neutral plumbing fills the interior). This prevents mixed pairs from constraining f.
- Inactive seam (neither side canonical): Both sides must be ⊥ and the pair accepts (neutral plumbing).

F2 neutralization
- A global ⊥-filler is available on repetitions w^z, z≥1, independent of boundary outputs and inputs, and does not interfere with per-side gating or the active seam. Thus (F2) becomes trivial.

Existence/length normalization (to be formalized)
- We assume (to be proven or replaced by an explicit construction) that for each u there exists at least one left (resp. right) canonical context of length ℓ∈{ℓ_pump,ℓ_pump+1} with the port zone adjacent to S. Padding occurs outside the port zone, so probes and seam interfaces are unaffected. This step currently rests on pumping/replacement lemmas not yet included in output.md; keep it here as an assumption until proven.

Budget and locality checklist
- Alphabet: O(1) for roles/phases, colors+⊥, error alphabet, tableau alphabet; O(B) for Addr; O(B) for probe heads and reserved boundary outputs. Choose β accordingly. All constraints are radius 1 and refer only to adjacent outputs (S↔S neighbor or S↔interior neighbor).

Audit points to pin down next
- Explicit tables for probe-mode transitions and the prohibition of ERR/⊥ near probe states.
- Exact per-side handshake symbols, and the three seam modes (inactive, semi-active, active) encoded locally.
- The seam’s final cell format and the constant-size forbidden/allowed adjacency list realizing (A) and (B) above.
- A B=2 explicit instance for DP validation.


=== output.md ===
Results validated for radius-1, β-normalized LCLs on oriented paths

Why these results matter
- The decision procedures for feasible-function existence (and hence the O(1)/Θ(log* n)/Θ(n) classification on paths) rely on two ingredients: (i) that path segments admit a finite set of “types” which compose under concatenation, and (ii) that extendibility of partially labeled paths can be checked efficiently. The theorems below formalize these facts for radius 1 and yield a finite bound for the bridging (F2) checks.

Definitions (radius 1)
- Fix finite alphabets Σ_in and Σ_out (|Σ_out| = β). Cin–out ⊆ Σ_in × Σ_out specifies allowed output symbols at a node given its input symbol. Cout–out ⊆ Σ_out × Σ_out specifies allowed pairs of consecutive output symbols along the oriented path. A labeling of outputs y_1…y_k over an input x_1…x_k is legal if (x_i, y_i) ∈ Cin–out for all i and (y_i, y_{i+1}) ∈ Cout–out for all i.
- For a word w of length k ≥ 2, let the four boundary positions be i=1,2 and i=k-1,k. For a fixed assignment a ∈ Σ_in^4 to the boundary inputs (x_1, x_2, x_{k-1}, x_k), define E_w(a) ⊆ Σ_out^4 to be the set of boundary-output assignments b = (y_1, y_2, y_{k-1}, y_k) for which there exists a legal output labeling y_1…y_k extending b, given the boundary inputs a (interior inputs may be arbitrary in Σ_in; if the model fixes interior inputs, the definition is with respect to those fixed inputs). The type of w, Type(w), is the map a ↦ E_w(a). Let T be the set of all types realized by some w.

Theorem 1 (Finite number of types and an explicit bound)
Let m := |Σ_in|. For radius 1 we have |T| ≤ m^4 · 2^{β^4}.
Proof. For each fixed boundary-input assignment a there are exactly β^4 possible boundary-output assignments; E_w(a) is an arbitrary subset of these, hence at most 2^{β^4} possibilities. There are m^4 possible a’s. The type is fully determined by the tuple (a, E_w(a))_{a∈Σ_in^4}. Thus the total number of distinct types is at most m^4 · 2^{β^4}.

Lemma 2 (Composition of types under concatenation)
There is a computable binary operation ⊛: T × T → T such that for all words u, v we have Type(uv) = Type(u) ⊛ Type(v).
Proof. Fix boundary inputs a on uv, i.e., inputs on positions 1,2 and at the last two positions of uv. For each boundary-outputs choice b on uv, extendibility is equivalent to the existence of output symbols p,q ∈ Σ_out at the shared boundary between u and v (the last two outputs of u = first two of v) such that:
- (i) (Type(u) under its corresponding boundary inputs) accepts the boundary outputs given by the left two outputs of b together with p,q; and
- (ii) (Type(v) under its corresponding boundary inputs) accepts p,q together with the right two outputs of b; and
- (iii) the two internal adjacencies across the u|v seam are allowed by Cout–out (these involve only (y_{|u|-1}, y_{|u|}) = (p_left, p_right) and (p_left, p_right) = (y_1, y_2) of v, but these are exactly the p,q we quantify over).
Because radius is 1, no other interior constraints couple u and v. Thus extendibility of uv under (a,b) can be decided solely from Type(u), Type(v), and Cout–out by existentially quantifying p,q. Defining ⊛ to implement this decision for all (a,b) yields Type(uv) = Type(u) ⊛ Type(v).

Lemma 3 (Ultimate periodicity of repeated concatenation)
Fix w and let τ := Type(w). Define the sequence σ_1, σ_2, … in T by σ_z := Type(w^z). Then σ_{z+1} = σ_z ⊛ τ for all z ≥ 1. Consequently, the sequence (σ_z) is ultimately periodic with preperiod and period at most |T|.
Proof. By Lemma 2, σ_{z+1} = Type(w^{z+1}) = Type(w^z w) = Type(w^z) ⊛ Type(w) = σ_z ⊛ τ. Since T is finite, the sequence must revisit a previous value within at most |T| steps, after which it evolves deterministically with fixed period ≤ |T|.

Corollary 4 (Finite bound for the bridging (F2) check)
Let ℓ := |T|. Fix a context (w_1, S, w_2) with |S| = 2 and a forced output assignment s ∈ Σ_out^2 on S. For each z ≥ 1, consider the path w_1^z S w_2^z with S fixed to s, and let P(z) be the predicate “there exists a legal completion of outputs on w_1^z and w_2^z consistent with s.” Then P(z) depends only on the pair (Type(w_1^z), Type(w_2^z)). Moreover, it suffices to check P(z) for 1 ≤ z ≤ Z with Z ≤ ℓ^2; if all these hold then P(z) holds for all z ≥ 1.
Proof. For fixed s, feasibility is determined by whether there exist outputs on the two boundary nodes adjacent to S on each side such that the two segments extend and Cout–out holds across the two adjacencies touching S; this depends only on Type(w_1^z) and Type(w_2^z). By Lemma 3, each of the two type sequences is ultimately periodic with preperiod and period ≤ ℓ. Hence the pair sequence (Type(w_1^z), Type(w_2^z)) takes values in a set of size ≤ ℓ^2 and is ultimately periodic. If P(z) holds for one full traversal of the distinct pairs (which occurs within the first ℓ^2 indices), it holds for all subsequent z.

Theorem 5 (DP for extension on a partially labeled path)
Given a path of length k with a fixed input string and some outputs preassigned on a subset of nodes, there is an O(k β^2) time algorithm that decides whether the outputs can be completed to a legal labeling.
Proof. Construct a layered graph with k layers, each layer’s vertices being the output symbols allowed at that node by Cin–out and any preassignment. Add a directed edge from y at layer i to y′ at layer i+1 iff (y, y′) ∈ Cout–out. There exists a legal completion iff there is a path from some vertex in layer 1 to some vertex in layer k. The graph has O(k β) vertices and O(k β^2) edges; reachability is decidable in O(k β^2).

Remarks
- The bounds above are not tight (e.g., the ℓ^2 bound in Corollary 4 can be improved using lcm of periods), but they suffice for verification in exponential time in β. They also isolate exactly where only the types matter (composition and periodicity), which is crucial for hardness reductions that aim to make (F2) vacuous and focus on (F1).



Current round tag: Round 0004 — 2025-08-28T12:31:40.335720Z
Return ONLY valid JSON with a single field:
{ "progress_md": "<your progress notes for this round>" }

Read output.md. If you spot gaps, errors, or missing justifications in output.md, point them out clearly inside progress_md.
