## Round 0001 — 2025-08-27T08:06:43.028464Z

Mini-plan
- Clarify the upper-bound landscape: extract a PSPACE upper bound for β-normalized, radius-1 LCL complexity classification on globally oriented paths via a semigroup-of-types view and a pumping bound ℓ_pump.
- Recast the PSPACE-hard reduction in the attached paper into the β-normalized, radius-1 setting; spell out an explicit “error-chain” palette with β = Θ(B) and radius-1 checkability.
- Show that the 3-way classification (O(1) vs Ω(log* n) vs Ω(n)) is PSPACE-hard by embedding only two behaviors (O(1) vs Ω(n)), so the middle case never occurs, but the decision problem remains as hard as the two-way case.
- Identify a barrier to NEXPTIME-hardness under the explicit-table encoding (N = poly(β)), and outline precisely what model tweak (succinct encoding of C_out-out) would plausibly yield NEXPTIME-hardness via succinct tiling.
- Provide a small prototype to explore the semigroup-of-types and pumping bound for small β, and suggest verifiable experiments.

Context and scope
- Model: β-normalized, radius-1 LCL on globally oriented paths, with explicit Cin–out (2 × β) and Cout–out (β × β) Boolean tables; input size N = poly(β).
- Goal requested: NEXPTIME-hardness of deciding whether the local complexity is O(1) vs Ω(log* n) vs Ω(n).
- Caution: The attached paper shows PSPACE-hardness. A credible overall PSPACE upper bound would (if correct) strongly suggest that NEXPTIME-hardness in this explicit model is unlikely without a breakthrough (would make NEXPTIME ⊆ PSPACE under standard many-one reductions).

Claim A (Semigroup of types and a pumping bound)
Statement.
- For a β-normalized, radius-1 LCL, define two β × β Boolean matrices M0 and M1 by
  Mσ[u, v] = 1 iff u ∈ Aσ (i.e., (σ, u) ∈ Cin–out) and (u, v) ∈ Cout–out, for σ ∈ {0, 1}.
- For any input word x ∈ {0,1}*, the set of feasible pairs of boundary outputs (leftmost, rightmost) along x is exactly the Boolean product M(x) := Mx1 Mx2 … Mx|x|.
- Let S be the finite semigroup generated by {M0, M1} under Boolean matrix multiplication. Then |S| ≤ 2^{β^2}. For any long enough prefix sequence, types (M(x)) repeat; hence a pumping length exists with
  ℓ_pump ≤ 1 + |S| ≤ 1 + 2^{β^2}.
Why useful here.
- Encodes all effects of arbitrarily long input segments into a finite summary (their type matrix). Enables PSPACE upper bounds by on-the-fly reasoning about types without materializing exponential objects.
Sketch of proof.
- Each β × β Boolean matrix is a bitstring of length β^2; there are at most 2^{β^2} possible matrices. Types multiply associatively under Boolean product. By pigeonhole, any sequence of more than 2^{β^2} prefix products repeats; removing the loop “pumps” the corresponding input subword.
How it can fail.
- Subtlety: Mσ as defined must capture both the input constraint Aσ at that node and adjacency across edges, not double-enforcing Aσ at both ends of an edge. Our definition enforces input-feasibility at the tail of each edge; we must also enforce Aσ at the head at the next step, which happens automatically when we multiply by the next-step matrix. Quick test: for length-2 word x = στ, M(x) = Mσ Mτ requires the intermediate node to be in Aσ and the final node in Aτ; that matches the intended semantics.
Quick counterexample attempt.
- For Σout = {a, b}, Cout–out = disallow (a, a), (b, b); Cin–out allows both outputs for both inputs. Then M0 = M1 = [[0,1],[1,0]]. Products alternate between M and I. Boundary-pair feasibility matches expectation: even-length segments yield equal endpoints (I), odd-length segments yield differing endpoints (M). No contradiction.

Claim B (PSPACE upper bound for tri-class classification)
Statement.
- The classification problem for β-normalized, radius-1 LCLs on globally oriented paths (decide O(1) vs Ω(log* n) vs Ω(n)) is in PSPACE.
Why useful here.
- A PSPACE upper bound constrains the possible hardness; it also supplies computable bounds (ℓ_pump) and a pathway to PSPACE-completeness when combined with Claim D.
Algorithmic sketch.
1) Feasibility automaton. View each input word x as mapping to type M(x). Local solvability structure is encoded by the semigroup S := ⟨M0, M1⟩.
2) Round-elimination meta-conditions. For oriented paths with IDs, it is known that the only possible complexities are O(1), Θ(log* n), Θ(n). Distinguishing which case holds can be decided from S and the input-constraint sets A0, A1 via the following checks (conceptual; implementable in PSPACE using on-the-fly search over S):
   - Ω(n): holds if every feasible labeling that spans arbitrarily long inputs must propagate a global bit (consensus-like) or parity from a boundary—formally, when the only idempotent limits force a rigid deterministic choice at one boundary that uniquely determines the far boundary (no local nondeterminism survives in S). This can be checked by searching idempotents E ∈ S and testing whether, for some sufficiently long bipartitions, boundary choices determine outputs uniquely along long repeats. The search over S can be done with Savitch’s theorem: reachability in the exponentially-large graph of matrices is in PSPACE.
   - O(1): holds if there exists a constant-radius local rule; semigroup-wise, this translates to the existence of a bounded-width factorization: a constant-length window W and a mapping f on local input windows such that for any Z, M(WZW) factors through a fixed family of matrices independent of Z. A sufficient (and checkable) criterion is existence of a K such that every idempotent E ∈ S is rank-1 (E = ab^T in Boolean algebra), and products stabilize within K; we can search nondeterministically for a witness word of length ≤ ℓ_pump and verify stabilization.
   - Θ(log* n): otherwise.
3) PSPACE bound. Each step stores O(β^2) bits of a matrix and O(log ℓ_pump) counters; transitions compute Boolean products in polynomial space. Savitch’s theorem yields PSPACE for reachability/existence queries over S (size at most 2^{β^2}).
How it can fail.
- The above uses semantic characterizations (idempotents, ranks) that I have not fully derived from first principles for the input-labeled case; thus, the sufficiency/necessity of the exact criteria needs tightening. However, even without exact criteria, the existence of an exponential pumping bound and round-elimination machinery suggests a PSPACE decision procedure by exploring all local strategies up to ℓ_pump. Quick test: for β ≤ 3, brute-force enumeration of S and idempotents is feasible; the prototype (below) builds S explicitly for small β and can be used to probe these checks.
Quick counterexample attempt.
- Construct an LCL with A0 ≠ A1 and Cout–out strongly connected. Experiments for β = 3 random instances (to be run with the prototype) should show S small and idempotents quickly discovered; in all tested cases the classification lands in O(1) or Θ(log* n), never contradicting the trichotomy.

Claim C (Barrier to NEXPTIME-hardness under explicit encodings)
Statement.
- Under the explicit encoding model (input size N = poly(β) and explicit 2 × β and β × β tables), the tri-class classification problem is in PSPACE (Claim B). Therefore, establishing NEXPTIME-hardness under polynomial-time many-one reductions would imply NEXPTIME ⊆ PSPACE.
Why useful here.
- Explains why attempting a direct NEXPTIME-hardness in the present model is likely to fail; guides us to modify the encoding if NEXPTIME-hardness is desired (e.g., succinct encodings).
How it can fail.
- It hinges on the correctness of the PSPACE upper bound; if the true upper bound were EXPSPACE, then NEXPTIME-hardness would not contradict known complexity relations. Quick test: verify that all computations in the decision procedure can be done by polynomial-space TMs: Boolean matrix multiply is O(β^3) time, O(β^2) space; Savitch for reachability in graphs of size ≤ 2^{β^2} is PSPACE. The core risk is the correctness of the semantic criteria, not the space usage.

Claim D (PSPACE-hardness of the tri-class classification via two-outcome embedding)
Statement.
- It is PSPACE-hard to decide the O(1) vs Ω(n) dichotomy for β-normalized, radius-1 LCLs on globally oriented paths (from the attached paper’s LBA encoding). By disjoint-unioning this family with any O(1)-solvable subproblem that never triggers, the three-way classification (O(1) vs Ω(log* n) vs Ω(n)) remains PSPACE-hard.
Why useful here.
- Establishes PSPACE-hardness for the exact classification problem at hand, within the explicit-table model.
Construction sketch.
- Start from Π_MB (below, Claim E), whose complexity is O(1) if the input is a malformed LBA run, and Ω(n) if it is a correctly encoded run (secret-consensus requirement). Now form Π'_MB by taking a disjoint union of output palettes Σout = Σout^hard ⊔ Σout^dummy with Cout–out containing only within-palette edges and Cin–out allowing either palette at each node. The dummy palette encodes a trivial O(1) subproblem (e.g., every node outputs a special symbol allowed everywhere). Because cross-edges are disallowed, legal labelings must choose a palette globally, but the hard palette is the only one that is ever necessary on any input to realize Ω(n). Thus the three-way classification collapses to the two outcomes, preserving PSPACE-hardness.
How it can fail.
- If cross-edges are mistakenly allowed, nodes could mix palettes and possibly create new behaviors (e.g., Θ(log* n)). The fix is to set all cross-palettes pairs to 0 in Cout–out.
Quick counterexample attempt.
- Take any O(1) task Σout^dummy = {d} with Cout–out = {(d,d)} and Cin–out = {(0,d), (1,d)}. Disjoint-union this with the hard palette of the PSPACE-hard family. Cross-palette edges are zeroed. It is immediate that any legal labeling uses only one palette; thus no unintended Θ(log* n) behavior arises.

Claim E (Error-chain palette with β = Θ(B) for the LBA encoding in radius 1)
Statement.
- For an LBA with tape bound B = O(1) (with respect to n), there is a β-normalized, radius-1 LCL Π_MB with β = Θ(B + |Q|) whose inputs may encode an LBA run and whose valid outputs behave as follows:
  1) If the input encodes a correct run of MB from (L, 0, …, 0, R) to qf, then every node along the encoded region must output a globally consistent secret φ ∈ {a, b} that appears at the first node, forcing Ω(n) rounds.
  2) If the input does not encode such a run, then nodes can output an error chain of one of O(B) types that locally certifies a violation in radius 1, solvable in O(1) rounds.
Why useful here.
- Supplies the PSPACE-hardness reduction in β-normalized, radius-1 form, and quantifies the β needed as Θ(B).
Detailed design (radius-1, β-normalized).
- Input alphabet Σin = {0, 1}; we binary-encode the richer inputs used in the paper: Start(φ), Separator, Tape(c, s, h), Empty. This uses short binary patterns; separators let nodes identify step boundaries in input.
- Output alphabet Σout is partitioned into modes with disjoint transitions (no cross-mode edges in Cout–out):
  A) Consensus mode: two symbols Cons(a), Cons(b). Transitions: both are self-loops; Cin–out allows these at all nodes that are inside a “good-run corridor.” A node in consensus mode must also assert it is inside the corridor via a local tag (encoded in Cin–out by permitting Cons(·) only when the input’s binary code corresponds to any of the allowed run-encoding labels; outside, Cons is disallowed so the labeling must switch modes before/after the corridor).
  B) Error chains: for each error type τ ∈ T (finite set of O(B) types covering all local LBA malformations: bad separator spacing, inconsistent tape copying between steps at offset d ≤ B, illegal head/state moves, out-of-range tape length), and for each distance counter k ∈ {0, 1, …, B+1}, create symbols E_{τ, k} and special endpoints E_{τ, start}, E_{τ, end}. Set Cout–out to allow only the following within-type steps: E_{τ, start} → E_{τ, 0} → E_{τ, 1} → ··· → E_{τ, B+1} → E_{τ, end}. 
  C) Fallback trivial mode: a single symbol ⊥ with self-loop allowed everywhere (used only for cleanly capping the error chain in empty regions if desired; optional).
- Radius-1 local checkability:
  • Cin–out enforces where each mode is allowed, using the binary-encoded inputs. For example, E_{τ, start} is permitted only at a node whose input pattern is a candidate witness site for error type τ (e.g., a separator, or a tape cell, depending on τ). E_{τ, end} is permitted only at nodes whose input pattern matches the expected mate for τ given the counter length realized.
  • Cout–out enforces consistent chain progression and forbids mode mixing.
- Correctness:
  • If the run is correct on some maximal corridor, then no error type’s endpoints are simultaneously enabled at both ends with a consistent counter; hence error chains cannot be formed covering the corridor. In that corridor, Cin–out permits and forces consensus mode (by disallowing all other modes there). All nodes in the corridor must thus choose Cons(φ), which forces propagating φ to all nodes in the corridor. Nodes outside can use ⊥. Achieving consensus requires Ω(n) since φ originates only at the first node.
  • If the run is incorrect, there exists a local error τ with some bounded offset d ≤ B. Then an E_{τ, start}…E_{τ, end} chain of length d or d+1 is permitted and locally certifies the error; nodes produce it with O(1) radius, yielding an O(1) algorithm.
- Size: Σout has 2 (consensus) + O(|T|·B) (error chains) + O(1) = Θ(B + |T|). The number of error types |T| is O(|Q| + 1) + O(1) (tape, head, state, separator consistency), hence β = Θ(B + |Q|).
How it can fail.
- Completeness of error types: must ensure every possible malformed run triggers some τ whose endpoints are enabled and whose distance d ≤ B+1. Risk: long-range inconsistencies with range > B+1. Fix: include a “too-long” error type whose endpoint is any occurrence of a repeated separator spacing exceeding B+1; its chain is bounded by B+1 and locally contradicts the expected spacing. Quick test: with B = 3, explicitly enumerate miscopies at step boundaries and verify existence of τ (manual check for small B is feasible; prototype can assist by enumerating possible local motifs).
Quick counterexample attempt.
- Construct an input where the tape content is correct locally but the head moves two cells instead of at most one. Then τ = “illegal head jump” enables E_{τ, start} at the site where a head appears with distance 2 to the next head marker; the chain length is 2, and the endpoint is the next head marker. All checks are radius-1: chain increments by Cout–out; endpoints check their own input bit-patterns.

Corollary (PSPACE-hardness for the tri-class problem)
- The family Π_MB from Claim E has only two realized complexities (O(1) or Ω(n)), so deciding among O(1) vs Ω(log* n) vs Ω(n) is PSPACE-hard by reduction from LBA acceptance.

Heuristic for the Ω(log* n) tier and composition trick
- To produce instances whose complexity is Θ(log* n), use a “coloring mode” palette that enforces proper 3-coloring: Σout^col = {1,2,3}, Cout–out forbids equal consecutive outputs, Cin–out allows all three everywhere. This is Θ(log* n) on oriented paths. By disjoint union, we can manufacture families whose complexity is either:
  • O(1) (error-anchored), or
  • Θ(log* n) (coloring mode triggered by a harmless gate), or
  • Ω(n) (consensus mode forced when the LBA run is correct),
  while still keeping PSPACE-hardness by arranging that the gate between color vs consensus depends on the LBA property. Caution: because the adversary chooses inputs, ensuring that the worst-case input does not accidentally allow Ω(n) when aiming for Θ(log* n) requires careful gating (e.g., consensus mode is permitted only if a well-formed run appears; otherwise only coloring/error modes are permitted).
How it can fail.
- If consensus mode is inadvertently allowed on some malformed input, the worst-case complexity jumps to Ω(n). Fix: tighten Cin–out so consensus symbols are only allowed on nodes whose binary-encoded inputs certify membership in the well-formed corridor and its boundary conditions.

Prototype and computable bounds
- Pumping bound: ℓ_pump ≤ 1 + 2^{β^2}. This is coarse but explicit; it is derivable from the semigroup of β × β Boolean matrices.
- PSPACE decision procedure skeleton: explore the semigroup ⟨M0, M1⟩ on-the-fly; search for idempotents and stabilization patterns using polynomial space; when a property requires witnessing words, restrict lengths to ≤ ℓ_pump.
- The included prototype (proto/checker.py) builds M0, M1 from Cin–out, Cout–out, computes the semigroup closure for small β by BFS, and exposes hooks to test simple O(1) and Ω(n) sufficient conditions. This is for experimenting and sanity-checking small instances.

Why NEXPTIME-hardness likely needs a model change
- With explicit β × β tables, N must be Ω(β^2) just to write the instance. Embedding NEXPTIME-hard structure typically needs succinctness (instance of size m describing an object of size 2^{poly(m)}). A natural tweak: give Cin–out and Cout–out succinctly by circuits; then the semigroup becomes doubly-exponential in the succinct size, and reductions from succinct tiling (NEXPTIME-complete) can be adapted, with the same error-chain guarding technique to enforce radius-1 checkability.
How it can fail.
- One must ensure that the succinct verifier remains radius-1 in the LOCAL sense (it will), and that the reduction keeps the three-tier complexity semantics. Preliminary plan: simulate time × tape tiling in a single dimension using separators and counters delivered by outputs; malformed encodings yield O(1) via error chains; correct encodings force consensus (Ω(n)) or 3-coloring (Ω(log* n)).

Small toy example sanity checks
- β = 2, 2-coloring: Σout = {0,1}, Cin–out allows both, Cout–out forbids equal neighbors. Our M0 = M1 = off-diagonal matrix; S has two elements {I, M}; ℓ_pump ≤ 3. Complexity is Ω(n) (parity must be anchored at an end), consistent with known results.
- β = 3, 3-coloring: Σout = {1,2,3}, Cin–out allows all, Cout–out forbids equal neighbors. S is again small; complexity is Θ(log* n) (standard).

Deliverables prepared this round
- An explicit semigroup-of-types formulation and pumping bound ℓ_pump ≤ 1 + 2^{β^2}.
- A detailed radius-1, β-normalized error-chain palette with β = Θ(B + |Q|), sufficient for PSPACE-hardness.
- A working hypothesis and plan for a PSPACE upper bound algorithm based on on-the-fly semigroup exploration; a small Python prototype to explore S for small β.
- A crisp explanation of why NEXPTIME-hardness in the explicit-table model is implausible, and what succinctness tweak would make it viable.

