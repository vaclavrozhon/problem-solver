% outputs.tex
\documentclass[11pt]{article}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{fullpage}
\usepackage{microtype}
\usepackage{enumitem}

\newcommand{\sigin}{\Sigma_{\mathrm{in}}}
\newcommand{\sigout}{\Sigma_{\mathrm{out}}}
\newcommand{\Aset}{\mathcal{A}}
\newcommand{\Erel}{\mathcal{E}}
\newcommand{\Ext}{\mathrm{Ext}}
\newcommand{\rep}{\mathrm{rep}}
\newcommand{\len}{\lvert\cdot\rvert}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\theoremstyle{plain}
\newtheorem{lemma}[definition]{Lemma}
\newtheorem{theorem}[definition]{Theorem}
\newtheorem{proposition}[definition]{Proposition}
\newtheorem{corollary}[definition]{Corollary}
\theoremstyle{remark}
\newtheorem{remark}[definition]{Remark}

\title{r=1: precise append-one-bit DP, congruence and concatenation lemmas, and a small counterexample}
\author{(formalization of corrections from notes)}
\date{}

\begin{document}
\maketitle

\begin{abstract}
This note records precise, fully rigorous statements and proofs for the following items that were identified as corrections in the informal notes: (1) the exact append-one-bit dynamic-programming recurrence for the radius-$1$ summaries ("r=1"), including the full boundary indexing and the base cases for short segments (length $k<4$); and the congruence lemma stating that equality of types is preserved under appending a bit; (2) a clean concatenation lemma for Ext-tables (the summary objects used for $r=1$), with proof; (3) a succinct counterexample showing that composing binary relations derived from summaries via an existential intermediate color can be unsound; (4) a revised description of the Stage-1 verifier (and the corresponding Stage-2 checks) that uses concatenation at the Ext-table level rather than composing the two-element relations; and (5) a short complexity remark: we keep claims at the coarse NEXPTIME level unless a deterministic solver is supplied.
\end{abstract}

\section{Preliminaries and notation}

Fix finite alphabets
\[\sigin = \{0,1\},\qquad \sigout\]
and a binary relation (adjacency) \(\Erel\subseteq\sigout\times\sigout\). For each input bit $a\in\sigin$ let $A_a\subseteq\sigout$ be the set of output symbols allowed at a node whose input bit equals $a$ (we allow the natural special case $A_0=A_1=\sigout$). We use $\beta:=|\sigout|$.

A (finite) input segment (bitstring) is $t=t_1t_2\cdots t_k\in\sigin^{k}$ with $k\ge 1$; write $|t|=k$. An \emph{output coloring} of $t$ is a tuple $c=(c_1,\dots,c_k)\in\sigout^{k}$ satisfying the local constraints
\[c_i\in A_{t_i}\quad(1\le i\le k),\qquad\text{and}\qquad (c_i,c_{i+1})\in\Erel\quad(1\le i<k).
\]

For radius $r=1$ we record a summary ("Ext-table") for a segment by the colors that can appear on the two leftmost and two rightmost positions of the segment. The mapping from a full coloring $c$ to its boundary quadruple depends on the segment length $k$ because for short segments some of the positions coincide; we formalize this below.

\begin{definition}[boundary quadruple B_k(c)]\label{def:boundary}
Let $t$ have length $k\ge1$ and let $c=(c_1,\dots,c_k)$ be a coloring of $t$.
Define the boundary quadruple $B_k(c)=(x_1,x_2,x_3,x_4)\in\sigout^4$ by
\begin{align*}
B_k(c) &= (c_1,c_1,c_1,c_1) &&\text{if }k=1,\\
B_k(c) &= (c_1,c_2,c_1,c_2) &&\text{if }k=2,\\
B_k(c) &= (c_1,c_2,c_2,c_3) &&\text{if }k=3,\\
B_k(c) &= (c_1,c_2,c_{k-1},c_k) &&\text{if }k\ge 4.
\end{align*}
(Thus the quadruple reads ``leftmost, second-from-left, second-from-right, rightmost'', with obvious coincidences when $k<4$.)
\end{definition}

\begin{definition}[Ext-table]
For a bitstring $t$ of length $k\ge1$ define
\[\Ext_t\;:=\;\{\;B_k(c)\;:\;c\text{ is an output coloring of }t\;\}\;\subseteq\;\sigout^4.
\]
\end{definition}

Intuitively $\Ext_t$ records exactly which assignments to the four boundary positions are extendible to a full coloring of the interior of $t$; for long segments ($k\ge4$) the four positions are distinct.

We will also use, for any set $S\subseteq\sigout^4$, the projections
\begin{align*}
\mathrm{L}(S) &:= \{(x_1,x_2)\;:\;\exists x_3,x_4,\; (x_1,x_2,x_3,x_4)\in S\},\\
\mathrm{R}(S) &:= \{(x_3,x_4)\;:\;\exists x_1,x_2,\; (x_1,x_2,x_3,x_4)\in S\}.
\end{align*}
For a segment $t$ we abbreviate $\mathrm{R}(\Ext_t)$ by $R_t$ when convenient; this is the set of rightmost pairs that can occur for $t$.

\section{Append-one-bit recurrence and the r=1 congruence lemma}

We first give the elementary base cases for short segments and then the general recurrence for appending a single input bit (the "append-one-bit" DP step). After that we state and prove the congruence lemma (equality of types is preserved by appending a bit).

\subsection{Base cases ($k<4$)}

Let $t$ be a bitstring of length $k\in\{1,2,3\}$. By Definition~\ref{def:boundary} the set $\Ext_t$ has an explicit characterization in terms of small tuples:

\begin{itemize}[leftmargin=*]
\item (\emph{Length 1}) If $t=(a)$ then
\[\Ext_t=\{(x,x,x,x)\in\sigout^4:\; x\in A_a\}.\]
\item (\emph{Length 2}) If $t=(a_1,a_2)$ then
\[\Ext_t=\{(x_1,x_2,x_1,x_2)\in\sigout^4:\; x_1\in A_{a_1},\; x_2\in A_{a_2},\; (x_1,x_2)\in\Erel\}.
\]
\item (\emph{Length 3}) If $t=(a_1,a_2,a_3)$ then
\[\Ext_t=\{(x_1,x_2,x_2,x_3)\in\sigout^4:\; x_i\in A_{a_i}\ (i=1,2,3),\; (x_1,x_2)\in\Erel,\; (x_2,x_3)\in\Erel\}.
\]
\end{itemize}

These are immediate from the definition of $B_k(c)$ and from the local adjacency constraints that define a legal coloring.

\subsection{Append-one-bit recurrence (general case $|t|\ge3$)}

Let $t$ be a bitstring of length $k\ge 3$ and let $a\in\sigin$ be a single input bit. Put $t' := t\cdot a$ (appending $a$ on the right). Then $t'$ has length $k+1\ge 4$, so a candidate boundary quadruple for $t'$ is of the form $(x_1,x_2,x_3,x_4)$ with the usual interpretation.

\begin{proposition}[append-one-bit recurrence for $k\ge3$]\label{prop:append}
With the notation above, for every $(x_1,x_2,x_3,x_4)\in\sigout^4$ we have
\begin{equation}\label{eq:append-recurrence}
(x_1,x_2,x_3,x_4)\in\Ext_{t'}\quad\Longleftrightarrow\quad x_4\in A_a\;\text{ and }\; (x_3,x_4)\in\Erel\;\text{ and }\;\exists z\in\sigout:\ (x_1,x_2,z,x_3)\in\Ext_t.
\end{equation}
Consequently, given $\Ext_t$ (as a boolean table indexed by $\sigout^4$) one can compute $\Ext_{t'}$ by iterating over all $\beta^4$ candidate quadruples and testing existence of $z$, yielding a naive running time $O(\beta^5)$ for this single append step.
\end{proposition}

\begin{proof}
(=>) Suppose $(x_1,x_2,x_3,x_4)\in\Ext_{t'}$. By definition there exists a coloring $c_1,\dots,c_{k+1}$ of $t'$ such that $B_{k+1}(c)= (x_1,x_2,x_3,x_4)$. Since $k+1\ge 4$ the positions in $B_{k+1}$ are the true positions $1,2,k,k+1$, hence $c_1=x_1$, $c_2=x_2$, $c_k=x_3$, $c_{k+1}=x_4$. From the coloring constraints we get $c_{k+1}\in A_a$ and $(c_k,c_{k+1})=(x_3,x_4)\in\Erel$. Removing the last node yields a coloring $c_1,\dots,c_k$ of $t$, and letting $z:=c_{k-1}$ we have $(x_1,x_2,z,x_3)\in\Ext_t$. This proves the left-to-right implication.

(<=) Conversely suppose $x_4\in A_a$, $(x_3,x_4)\in\Erel$, and there exists $z\in\sigout$ with $(x_1,x_2,z,x_3)\in\Ext_t$. By definition of $\Ext_t$ there exists a coloring $c_1,\dots,c_k$ of $t$ with $c_1=x_1,c_2=x_2,c_{k-1}=z,c_k=x_3$. Appending the color $c_{k+1}:=x_4$ yields a coloring $c_1,\dots,c_{k+1}$ of $t'$ (by $x_4\in A_a$ and $(x_3,x_4)\in\Erel$), and the boundary quadruple of this coloring is $(x_1,x_2,x_3,x_4)$ because $k+1\ge 4$. Hence $(x_1,x_2,x_3,x_4)\in\Ext_{t'}$.

The asymptotic cost statement is immediate from the recurrence: evaluating the right-hand side of (\ref{eq:append-recurrence}) for every $\beta^4$-many quadruples costs $O(\beta)$ to check the existential over $z$ in the naive implementation, hence $O(\beta^5)$ time per append.
\end{proof}

\subsection{Append-one-bit: the $k<4$ cases}

When $|t|<4$ the quadruples in $\Ext_t$ encode coinciding positions, therefore the recurrence in Proposition~\ref{prop:append} must be replaced by the appropriate base-case to get a correct algorithm that builds up from length~1. We spell these out as constructive update rules that compute $\Ext_{t'}$ from $\Ext_t$ when $|t|=1,2,3$.

Let $t$ have length $k\in\{1,2,3\}$ and let $t'=t\cdot a$.

\begin{itemize}[leftmargin=*]
\item If $k=1$ then $t=(b)$ for some $b\in\sigin$. Using the characterization above we have
\[\Ext_t=\{(x,x,x,x):x\in A_b\}.
\]
Hence $t'$ has length 2 and
\[(x_1,x_2,x_3,x_4)\in\Ext_{t'}\iff x_1=x_3,\; x_2=x_4,\; x_1\in A_b,\; x_2\in A_a,\; (x_1,x_2)\in\Erel.
\]
(Operationally: enumerate $x_1,x_2$ with $(x_1,x_2)\in\Erel$, check $x_1\in A_b$ and $x_2\in A_a$, and add the quadruple $(x_1,x_2,x_1,x_2)$.)

\item If $k=2$ then $t=(b_1,b_2)$, and $\Ext_t$ consists of tuples $(x_1,x_2,x_1,x_2)$ with adjacency $ (x_1,x_2)\in\Erel$ and membership $x_i\in A_{b_i}$. The appened string $t'$ has length $3$, and
\[(x_1,x_2,x_3,x_4)\in\Ext_{t'}\iff x_3=x_2,\; x_1\in A_{b_1},\; x_2\in A_{b_2}\cap A_a,\; (x_1,x_2)\in\Erel,\; (x_2,x_4)\in\Erel.
\]
(Equivalently, set $c_1=x_1,c_2=x_2,c_3=x_4$ and check the two edges and membership.)

\item If $k=3$ then $t=(b_1,b_2,b_3)$ and $\Ext_t$ has tuples of the form $(x_1,x_2,x_2,x_3)$ satisfying the two edges $(x_1,x_2)$ and $(x_2,x_3)$. Appending $a$ produces length $4$, and the characterization is
\[(x_1,x_2,x_3,x_4)\in\Ext_{t'}\iff x_1\in A_{b_1},\; x_2\in A_{b_2},\; x_3\in A_{b_3},\; x_4\in A_a,\; (x_1,x_2)\in\Erel,\; (x_2,x_3)\in\Erel,\; (x_3,x_4)\in\Erel.
\]
\end{itemize}

These formulas are the only special cases one needs when implementing a forward DP that starts from single-bit segments and builds up by repeated appends: for $k\ge3$ use Proposition~\ref{prop:append}, and for $k\in\{1,2,3\}$ use the explicit checks above.

\subsection{Congruence lemma (r=1)}

We now state and prove the congruence property that was needed in the notes: if two segments have identical Ext-tables then appending the same input bit to both yields identical Ext-tables again.

\begin{lemma}[r=1 congruence lemma]\label{lem:congruence}
Let $P,Q$ be two bitstrings and suppose $\Ext_P=\Ext_Q$. Then for every bit $a\in\sigin$ we have
\[\Ext_{P\cdot a}=\Ext_{Q\cdot a}.\]
In particular, equality of the $r=1$ summaries (Ext-tables) is preserved by appending a single input bit.
\end{lemma}

\begin{proof}
The proof is a simple case analysis using the append-one-bit rules.

If $|P|\ge 3$ then the formula in Proposition~\ref{prop:append} expresses membership in $\Ext_{P\cdot a}$ purely in terms of membership in $\Ext_P$, the sets $A_a$, and the adjacency relation $\Erel$; the same formula holds for $Q$ because $|Q|$ must be equal to $|P|$ whenever $\Ext_P=\Ext_Q$ (indeed the pattern of coincidences in quadruples for short lengths is visible in the table itself). Thus the right-hand side of (\ref{eq:append-recurrence}) is identical for $P$ and $Q$, which yields $\Ext_{P\cdot a}=\Ext_{Q\cdot a}$.

If $|P|<3$ then both $P$ and $Q$ must have the same length (because their Ext-tables record the equality patterns of the coordinates: e.g. membership of tuples of the form $(x,x,x,x)$ witnesses $k=1$, etc.). In each of the finite cases $k=1,2,3$ the explicit base-case update rules given above determine $\Ext_{\cdot a}$ from $\Ext_{\cdot}$ using only membership tests that depend on $\Ext_P$ and the fixed parameters $A_a,\Erel$. Since $\Ext_P=\Ext_Q$ the resulting computations yield the same set. This finishes the proof.
\end{proof}

\section{Concatenation lemma for Ext-tables}

Concatenation is the other fundamental operation we need. We give a clean statement that directly tells how to compute $\Ext_{P\cdot Q}$ from $\Ext_P$ and $\Ext_Q$ (no intermediate projection to binary relations is needed or used). The statement is valid for all lengths $|P|,|Q|\ge 1$; the proof is a straightforward gluing argument.

\begin{lemma}[concatenation lemma for Ext-tables]\label{lem:concat}
Let $P$ and $Q$ be bitstrings of lengths $m, n\ge1$, respectively, and let $B:=P\cdot Q$ be their concatenation (length $m+n$). Then for any $(o_1,o_2,o_3',o_4')\in\sigout^4$ we have
\begin{multline}\label{eq:concat}
(o_1,o_2,o_3',o_4')\in\Ext_B\\\iff\exists\;x_3,x_4,x_1',x_2'\in\sigout\;:\; (o_1,o_2,x_3,x_4)\in\Ext_P,\; (x_1',x_2',o_3',o_4')\in\Ext_Q,\;\text{and }(x_4,x_1')\in\Erel.
\end{multline}
In words: a boundary quadruple appears for the concatenation exactly when there exist matching interior boundary pairs for the left and right factors whose seam colors are adjacent.
\end{lemma}

\begin{proof}
(=>) Suppose $(o_1,o_2,o_3',o_4')\in\Ext_B$. Then by definition there exists a coloring $c_1,\dots,c_{m+n}$ of $B$ whose boundary quadruple (according to Definition~\ref{def:boundary} with length $m+n$) equals $(o_1,o_2,o_3',o_4')$. Restrict the coloring to the left factor $P$ to obtain $c_1,\dots,c_m$, and to the right factor $Q$ (with renumbering) to obtain $c_{m+1},\dots,c_{m+n}$. Let
\[x_3:=c_{\max(1,m-1)},\quad x_4:=c_m,\quad x_1':=c_{m+1},\quad x_2':=c_{\min(m+2,m+n)}
\]
(so that the four symbols $x_3,x_4,x_1',x_2'$ are precisely the two rightmost symbols of $P$ and the two leftmost symbols of $Q$, with the appropriate coincidences for short factors). By construction $(o_1,o_2,x_3,x_4)\in\Ext_P$ and $(x_1',x_2',o_3',o_4')\in\Ext_Q$. Finally the adjacency across the seam is $(x_4,x_1')=(c_m,c_{m+1})\in\Erel$ because the coloring of $B$ satisfied all adjacent-edge constraints. This proves the forward implication.

(<=) Conversely, assume there exist $x_3,x_4,x_1',x_2'$ as in the right-hand side of (\ref{eq:concat}). By $(o_1,o_2,x_3,x_4)\in\Ext_P$ there exists a coloring $p_1,\dots,p_m$ of $P$ whose left/right boundary pattern matches $(o_1,o_2,x_3,x_4)$. Likewise from $(x_1',x_2',o_3',o_4')\in\Ext_Q$ there exists a coloring $q_1,\dots,q_n$ of $Q$ whose left/right boundary pattern matches $(x_1',x_2',o_3',o_4')$. The assumed seam adjacency $(x_4,x_1')\in\Erel$ guarantees that the two colorings can be glued along the seam edge between positions $m$ and $m+1$: define a coloring of $B$ by
\[c_i := p_i\ (1\le i\le m),\qquad c_{m+j} := q_j\ (1\le j\le n).
\]
The adjacency conditions inside $P$ and inside $Q$ are satisfied by $p$ and $q$; the single new adjacency to check is $(c_m,c_{m+1})=(x_4,x_1')$, which holds by hypothesis. Therefore $c_1,\dots,c_{m+n}$ is a legal coloring of $B$ whose boundary quadruple equals $(o_1,o_2,o_3',o_4')$, whence $(o_1,o_2,o_3',o_4')\in\Ext_B$. This completes the proof of the equivalence.
\end{proof}

\begin{remark}
Note that the existential quantification ranges only over four symbols from $\sigout$; a naive implementation of (\ref{eq:concat}) would therefore take time $O(\beta^8)$ to produce the full $\Ext_B$ table by trying all $(o_1,o_2,o_3',o_4')$ and all witnesses $x_3,x_4,x_1',x_2'$. In practice one can do significantly better (e.g. by iterating witnesses $x_4,x_1'$ first and using precomputed adjacency lists) but the point for correctness is that concatenation is computable entirely from the two operand Ext-tables and the adjacency $\Erel$.
\end{remark}

\section{Why composing $R_t$ via an existential intermediate color is unsound (a short counterexample)}

It is tempting to try to speed up concatenation by passing to the binary projection $R_t=\mathrm{R}(\Ext_t)$ (the rightmost pair) and to define the right-projection of a concatenation by composing these binary relations via an existential intermediate color $m\in\sigout$, i.e.
\[R_{P\cdot Q}?=\{(u,w):\exists m\in\sigout,\; (u,m)\in R_P\;\text{and}\;(m,w)\in R_Q\}.
\]
We give a brief counterexample showing this is unsound in general: the right-projection of the concatenation can be strictly smaller than the projection obtained by composing the $R$-relations in the above way.

\begin{proposition}[counterexample]\label{prop:counter}
Let $\sigout=\{a,b,c\}$, $A_0=A_1=\sigout$, and let the adjacency relation be
\[\Erel=\{(a,b),(b,c)\}.
\]
Let $P$ and $Q$ both be the two-bit segment $\mathtt{00}$ (length~2). Then
\begin{itemize}
\item $R_P$ contains the pair $(a,b)$ (witnessing the extension $a\!\mapsto b$ on the two nodes of $P$), and $R_Q$ contains the pair $(b,c)$.
\item Hence the existential composition yields the pair $(a,c)$ via the intermediate color $m=b$.
\item However $(a,c)\notin R_{P\cdot Q}$, i.e. there is no extension of the length-4 segment $P\cdot Q$ whose rightmost coordinate is $c$ while the leftmost coordinate is $a$; consequently the composition above is unsound.
\end{itemize}
\end{proposition}

\begin{proof}
For $P=\mathtt{00}$ (two bits) a legal coloring is a pair $(x_1,x_2)\in\sigout^2$ with $(x_1,x_2)\in\Erel$. Thus $\Ext_P$ contains tuples of the form $(x_1,x_2,x_1,x_2)$ exactly when $(x_1,x_2)\in\Erel$. In particular $(a,b,a,b)\in\Ext_P$, so $R_P$ contains the rightmost pair $(a,b)$. Similarly $(b,c,b,c)\in\Ext_Q$ so $R_Q$ contains $(b,c)$.

The existential composition of $R_P$ and $R_Q$ therefore contains $(a,c)$ because there exists $m=b$ with $(a,b)\in R_P$ and $(b,c)\in R_Q$.

But consider the concatenation $B:=P\cdot Q$, which has length $4$. A coloring of $B$ is a tuple $(y_1,y_2,y_3,y_4)$ with $(y_1,y_2),(y_2,y_3),(y_3,y_4)\in\Erel$. If $y_1=a$ then the only possibility for $y_2$ is $b$ (because the only outgoing edge from $a$ is to $b$). Then $y_3$ must be $c$ (because the only outgoing edge from $b$ is to $c$). But there is no outgoing edge from $c$ in $\Erel$, so there is no symbol $y_4$ with $(y_3,y_4)=(c,y_4)\in\Erel$. Consequently there is no coloring of $B$ with $y_1=a$ and $y_4=c$; hence $(a,c)$ does not occur as the rightmost pair in any entry of $\Ext_B$. That is, $(a,c)\notin R_{P\cdot Q}$, completing the counterexample.
\end{proof}

This simple example illustrates that projecting summaries (here to $R_t$) and then composing those projections by existentially quantifying over a single intermediate color may produce spurious pairs: the existential witness $m$ might be realized in different global extensions of the two factors that are incompatible at the seam. The correct (sound) operation is concatenation at the Ext-table level (Lemma~\ref{lem:concat}) which enforces seam adjacency while keeping the two-sided context.

\section{Rewriting the verifier specification: use concatenation, not $R$-composition}

Below we give a concise, explicit rewrite of the Stage-1 verifier specification (and the corresponding Stage-2 checks) so that every place that previously composed $R$-relations via an existential intermediate color is replaced by a concatenation of Ext-tables followed by a projection to $R$ if needed.

The description below is intentionally modular and abstract (it operates on the certificate objects the prover supplies). It is stated so that it is immediately implementable using the formulas in Lemma~\ref{lem:concat} and Proposition~\ref{prop:append}.

\subsection*{Inputs to the verifier}

The verifier receives (from the prover/certificate) the following finite objects:
\begin{itemize}[leftmargin=*]
\item A finite set $\mathcal{R}$ of representative bitstrings (the claimed representatives of the finitely many types used by the proof). Each $\rho\in\mathcal{R}$ is a bitstring in $\sigin^*$.
\item For each representative $\rho\in\mathcal{R}$ a table $\Ext^{\mathrm{cert}}_{\rho}\subseteq\sigout^4$ claimed to equal the true $\Ext_{\rho}$.
\item A finite set of claims (rules) of the form "the concatenation of representatives $\rho_b,\rho_c$ has representative $\rho_{bc}$"; for each such claim the certificate may also furnish (or one can derive) the asserted relation $R^{\mathrm{cert}}_{\rho_{bc}}:=\mathrm{R}(\Ext^{\mathrm{cert}}_{\rho_{bc}})$ if that is part of the witnessed invariant in the original scheme.
\end{itemize}

The verifier's job is to check that the supplied Ext-tables are self-consistent and closed under the operations (append, concatenation) required by the scheme. It performs the following checks.

\subsection*{Stage-1 verifier (using concatenation)}\label{sec:stage1}

For every asserted concatenation claim $(\rho_b,\rho_c,\rho_{bc})$ do the following checks:

\begin{enumerate}[leftmargin=*]
\item Let $P:=\rho_b$ and $Q:=\rho_c$, and compute the candidate concatenation table
\[\Ext^{\mathrm{comp}}_{P\cdot Q} := \{\; (o_1,o_2,o_3',o_4')\in\sigout^4:\;\exists x_3,x_4,x_1',x_2'\in\sigout\ \text{s.t.}\ (o_1,o_2,x_3,x_4)\in\Ext^{\mathrm{cert}}_{P},\ (x_1',x_2',o_3',o_4')\in\Ext^{\mathrm{cert}}_{Q},\ (x_4,x_1')\in\Erel\;\}.
\]
(Use the formula of Lemma~\ref{lem:concat}.)

\item Compute the projected right relation
\[R^{\mathrm{comp}}_{P\cdot Q} := \mathrm{R}(\Ext^{\mathrm{comp}}_{P\cdot Q}).\]

\item Verify that the certificate's claimed representative $\rho_{bc}$ satisfies
\[R^{\mathrm{cert}}_{\rho_{bc}} = R^{\mathrm{comp}}_{P\cdot Q}\qquad\text{and}\qquad \Ext^{\mathrm{cert}}_{\rho_{bc}} = \Ext^{\mathrm{comp}}_{P\cdot Q}\] if the certificate supplies $\Ext^{\mathrm{cert}}_{\rho_{bc}}$ explicitly. (At minimum the verifier must check that the representative's stored relation/table agrees with the one computed by concatenation; checking equality of the full Ext-tables is sound and recommended.)
\end{enumerate}

Remarks:
\begin{itemize}[leftmargin=*]
\item The crucial change compared to the earlier, unsound specification is that the verifier \emph{does not} compute $R^{\mathrm{comp}}_{P\cdot Q}$ simply as $\{(u,w):\exists m,\,(u,m)\in R^{\mathrm{cert}}_P\land(m,w)\in R^{\mathrm{cert}}_Q\}$. Instead the verifier constructs the full $\Ext$-table by concatenation and only then projects to $R$.
\item If the certificate does not explicitly supply $\Ext^{\mathrm{cert}}_{\rho_{bc}}$ but does claim the representative $\rho_{bc}$, the verifier may still compute $\Ext^{\mathrm{comp}}_{P\cdot Q}$ and check that $R^{\mathrm{comp}}_{P\cdot Q}$ equals the stored $R^{\mathrm{cert}}_{\rho_{bc}}$. This is sufficient to guarantee that the claimed representative behaves correctly as far as the right projection is concerned.
\end{itemize}

\subsection*{Adjustments in Stage-2 checks}

Any Stage-2 check that previously reasoned about the compatibility of two representatives by composing their $R$-relations must be replaced by the corresponding check that computes the concatenation Ext-table and then performs the required membership or projection tests on $\Ext^{\mathrm{comp}}_{P\cdot Q}$. Concretely, whenever the verifier earlier intended to test
\[\exists m\in\sigout:\ (u,m)\in R_P\land(m,w)\in R_Q
\]
it should instead test (by computing $\Ext^{\mathrm{comp}}_{P\cdot Q}$) whether there exists a quadruple in $\Ext^{\mathrm{comp}}_{P\cdot Q}$ whose left projection matches the left context (as required) and whose right projection produces the desired $(u,w)$ outcome; equivalently, test membership in $R^{\mathrm{comp}}_{P\cdot Q}$.

This substitution is sound by Lemma~\ref{lem:concat} and avoids the spurious pairs that may be produced by existentially composing $R$-relations alone (see Proposition~\ref{prop:counter}).

\section{Complexity remark}

We refrain from attempting a tighter complexity analysis in this note. The elementary operations on Ext-tables that we used above have the following simple size bounds:
\begin{itemize}[leftmargin=*]
\item Each $\Ext_t$ is a subset of $\sigout^4$ and hence can be represented in size $O(\beta^4)$. The projections $R_t$ and $L_t$ have size $O(\beta^2)$.
\item The naive append-one-bit step (Proposition~\ref{prop:append}) takes $O(\beta^5)$ time in the worst case per append when implemented by brute-force enumeration of all quadruples and the existential witness.
\item The naive concatenation step (Lemma~\ref{lem:concat}) can be implemented by checking all $\beta^4$ candidate output quadruples and, for each, all $\beta^4$ possible witnesses $x_3,x_4,x_1',x_2'$, hence $O(\beta^8)$ time in the worst-case with a fully naive method; modest algorithmic improvements reduce this significantly in practice (for instance by iterating seam colors $x_4,x_1'$ first and using lookups), but we do not rely on such micro-optimizations here.
\end{itemize}

Because the verifier is supplied with a (potentially exponentially large) nondeterministic certificate of representatives and Ext-tables, and because checking the correctness of the certificate requires the potentially expensive concatenation operations above, the natural coarse-grained upper bound to assert without further assumptions is NEXPTIME: a nondeterministic verifier can guess the certificate and then perform the table computations and equality checks in time exponential in the size of the original problem description. If, however, a deterministic (polynomial-time, or otherwise bounded-time) solver for the small constraint checks is provided as an oracle, the complexity claims can be made correspondingly stronger; in this note we intentionally keep the complexity statement at the NEXPTIME level since no such deterministic subroutine is assumed.

\section{Conclusion}

We summarized and proved the corrected append-one-bit recurrence (including the full $k<4$ base cases), proved the r=1 congruence lemma, gave a clean concatenation lemma for Ext-tables, displayed a simple counterexample showing that composing $R$-relations via an existential intermediate color is unsound, and rewrote the Stage-1 verifier specification (and the Stage-2 checks) so that concatenation at the Ext-table level is used in place of the unsound $R$-composition. The small explicit counterexample (Section~\ref{prop:counter}) demonstrates why the change is necessary in any implementation or formal verification of the scheme.

\medskip

\noindent\textbf{Acknowledgements.} This document formalizes and expands the corrections recorded in the informal notes supplied with the task.

\end{document}
