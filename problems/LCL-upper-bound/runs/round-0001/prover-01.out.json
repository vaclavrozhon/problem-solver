{
  "progress_md": "## Round 0001 \u2014 2025-08-27T10:32:01.431305Z\n\nMini-plan\n- Specialize the feasible-function framework of the paper to radius-1, \u03b2-normalized LCLs on globally oriented paths, and isolate a finite-state summary (types) that is exponential but not doubly exponential in \u03b2.\n- Show we can deterministically compute all reachable types and a successor function \u03b4(Type, bit) in time 2^{poly(\u03b2)} by dynamic programming on boundary-extendibility tables.\n- Define, for each type t, a macro relation R_t \u2286 \u03a3_out \u00d7 \u03a3_out that summarizes \u201cwhat boundary output labels can be bridged across a block of type t\u201d.\n- Give a NEXPTIME (indeed EXPTIME) decision procedure for the \u03c9(log* n)\u2014o(n) gap by nondeterministically guessing a small table F on contexts of the form (leftType, 2-bit S, rightType) and verifying extendibility using the R_t relations.\n- Give a NEXPTIME decision procedure for the \u03c9(1)\u2014o(log* n) gap by nondeterministically guessing boundary quadruples per type (first/second/second-last/last outputs) and verifying the wrap-around and bridging conditions via R_t and local checks.\n- Validate with toy examples and note failure modes; identify concrete next steps to formalize the type-update computation and the verification routines.\n\nContext and notation (radius 1, \u03b2-normalized)\n- Inputs: \u03a3_in = {0,1}. Outputs: \u03a3_out with |\u03a3_out| = \u03b2. Legality: (in, out) \u2208 C_in\u2013out and (out, out\u2032) \u2208 C_out\u2013out on each directed edge.\n- Let E \u2286 \u03a3_out \u00d7 \u03a3_out denote the directed edge relation from C_out\u2013out. Let A_0, A_1 \u2286 \u03a3_out denote allowed outputs per input bit (rows of C_in\u2013out).\n- For a (long) input block P (string over {0,1}), write its type Type(P) as in the paper: r = 1 \u21d2 D1 are the two endpoints; D2 are their immediate neighbors; extendibility is captured by which assignments of output labels to the four boundary nodes D1 \u222a D2 can be extended to a full legal labeling on the interior D3.\n\nClaim 1 (Type-count bound specialized to r = 1)\nStatement. The number of distinct types (equivalence classes \u22c6\u223c) is at most \u2113_pump \u2264 16 \u00b7 2^{\u03b2^4}.\nWhy useful here. This bounds the state space of our finite abstraction by a single-exponential function of \u03b2, enabling 2^{poly(\u03b2)} algorithms.\nSketch. For r = 1, D1 \u222a D2 contains 4 boundary nodes. There are 2^4 choices of boundary input bits. For each, the extendibility predicate is a Boolean function over assignments of 4 boundary output labels, i.e., a subset of \u03a3_out^4, hence at most 2^{\u03b2^4} possibilities. Multiplying gives \u2264 16 \u00b7 2^{\u03b2^4}.\nHow it can fail. If radius r > 1 were needed, the exponent would grow as \u03b2^{4r}, but still single-exponential for constant r. No failure for r=1.\nQuick test. With \u03b2=2, bound is 16\u00b72^{16} \u2248 1M types (a rough upper bound); fine for theoretical complexity, impractical to enumerate in practice but enough for 2^{poly(\u03b2)} complexity.\n\nClaim 2 (Deterministically computing all reachable types and \u03b4 in 2^{poly(\u03b2)} time)\nStatement. We can compute the set T of all types reachable from length-\u22644 words under appending bits, together with a deterministic successor function \u03b4: T \u00d7 {0,1} \u2192 T, in deterministic time 2^{poly(\u03b2)}.\nWhy useful here. Avoids enumerating 2^{\u2113_pump} strings. Once T and \u03b4 are known, all further checks quantify only over T (singly exponential), not over words (doubly exponential).\nConstruction and verification.\n- Represent a type t \u2208 T by (Lbits, Rbits, Ext_t), where Lbits, Rbits \u2208 {0,1}^2 are the 2-bit prefix/suffix of any representative, and Ext_t \u2286 \u03a3_out^4 is the set of boundary 4-tuples (o_L1, o_L2, o_R2, o_R1) that are extendible to a full legal labeling inside.\n- Initialization. Enumerate all input strings P of length k \u2208 {1,2,3,4} (\u2264 16 of them). For each, compute Ext_{Type(P)} exactly by dynamic programming on the tiny interior: enumerate all 4-tuples of boundary outputs consistent with C_in\u2013out on boundary nodes and E on boundary edges; check extendibility of the (empty or short) interior by brute force (cost \u03b2^{O(4)} per P). Insert the resulting canonical type into a dictionary keyed by (Lbits, Rbits, Ext_t).\n- Update (\u03b4). Given t = (Lbits, Rbits, Ext_t) and a \u2208 {0,1}, we can compute t\u2032 = \u03b4(t, a) as follows: t\u2032 has Lbits\u2032 = first two bits of (Lbits concatenated if current length<2 else unchanged), Rbits\u2032 = updated last-two-bits after appending a, and Ext_{t\u2032} is obtained by a constant-size \u201cboundary-augmentation\u201d DP: a boundary 4-tuple (o_L1, o_L2, o_R2\u2032, o_R1\u2032) is in Ext_{t\u2032} iff there exist o_R2, o_R1 and an output label o_new for the appended node such that\n  (i) (o_L1, o_L2, o_R2, o_R1) \u2208 Ext_t,\n  (ii) membership constraints at the new last node: o_new \u2208 A_a,\n  (iii) E-edges: (o_R1, o_new) \u2208 E, and then set o_R2\u2032=o_new (the new second-last), o_R1\u2032 = ?\n  Careful: after appending one node, the new last two boundary outputs are (old last, new), so interpret indexes accordingly. Full derivation requires casework for short representatives (k < 4), but all cases are constant and handled locally.\n- BFS enumeration. Starting from the set of types derived for k \u2264 4, add \u03b4(t,0) and \u03b4(t,1) for each discovered t until closure. Each \u03b4-computation runs in \u03b2^{O(4)} time (constant-factor DP over \u03a3_out^4). The number of types discovered is \u2264 \u2113_pump. Thus total time \u2264 \u2113_pump \u00b7 poly(\u03b2) = 2^{poly(\u03b2)}.\nHow it can fail. The update must be consistent for small-k degeneracies (k < 4) where D1\u222aD2 overlaps; if mishandled, one might compute inconsistent Ext sets. We mitigate by bootstrapping directly from exact computation for k \u2264 4 and carefully distinguishing cases in the update.\nQuick test. For a trivial LCL where E is complete and A_0=A_1=\u03a3_out, Ext_t=\u03a3_out^4 for all t. Then \u03b4 creates only 16 distinct types (Lbits,Rbits, full Ext). BFS closes after O(1) expansions\u2014consistent and fast.\n\nClaim 3 (Macro bridging relation R_t)\nStatement. For each type t, we can compute a relation R_t \u2286 \u03a3_out \u00d7 \u03a3_out such that (x, y) \u2208 R_t iff there exists a legal labeling of some block P of type t that bridges the outer boundary labels x \u2192 y, in the sense: there exist boundary outputs (o_L1,o_L2,o_R2,o_R1) \u2208 Ext_t with E-edges (x, o_L1) and (o_R1, y).\nWhy useful here. R_t summarizes the net effect of an unlabeled block of type t on the neighboring outside outputs. It collapses an entire block to a \u03b2\u00d7\u03b2 boolean matrix for later composition checks.\nComputation. For each t and each (x,y) \u2208 \u03a3_out^2, test whether \u2203 (o_L1,o_L2,o_R2,o_R1) \u2208 Ext_t such that (x, o_L1) \u2208 E and (o_R1, y) \u2208 E. This costs O(\u03b2^4) per (x,y), hence O(\u03b2^6) per t.\nHow it can fail. If we misinterpret boundary directions (left/right), the composition in later checks breaks. We fix orientation globally: x is the output immediately before the block on the left, y is the output immediately after the block on the right.\nQuick test. If E has a self-loop at c and c \u2208 A_0\u2229A_1 at all boundary nodes, then (c,c) \u2208 R_t for all t, since boundary tuple (c,c,c,c) is valid: sanity check.\n\nClaim 4 (NEXPTIME decision for \u03c9(log* n)\u2014o(n): existence of a context-local f on 2-node windows)\nStatement. There is a nondeterministic algorithm running in time 2^{poly(\u03b2)} that decides whether a feasible function f (in the sense of Section 4.2 of the paper) exists; equivalently, whether the LCL has deterministic LOCAL complexity o(n) instead of \u03a9(n).\nWhy useful here. This separates \u03a9(n) from o(n) in NEXPTIME, as requested.\nDefinition (specialized). For r=1, f takes as input a triple (t_L, S, t_R) where t_L, t_R \u2208 T are types of the left/right contexts, and S \u2208 {0,1}^2 is the 2-bit middle window; f outputs L_S \u2208 \u03a3_out^2 for S, with (i) (S[1], L_S[1]) \u2208 C_in\u2013out, (S[2], L_S[2]) \u2208 C_in\u2013out, and (ii) (L_S[1], L_S[2]) \u2208 E.\nVerification condition (extendibility). For all quadruples (t_a, t_b, t_c, t_d) \u2208 T^4, there exist orientation choices for S1,S2 (i.e., optionally reverse them; this toggles which side of L_S we use as boundary) such that, writing s1_last as the output of the last node of S1 under f and s2_first as the output of the first node of S2 under f, we have\n  \u2203 m \u2208 \u03a3_out: (s1_last, m) \u2208 R_{t_b} and (m, s2_first) \u2208 R_{t_c}.\nAlgorithm.\n1) Deterministically compute T, \u03b4, and all R_t (Claim 2 and 3) in 2^{poly(\u03b2)} time.\n2) Nondeterministically guess a table F: T \u00d7 {0,1}^2 \u00d7 T \u2192 \u03a3_out^2 assigning outputs to the 2-node window for every context. Enforce local per-node legality and (L_S[1],L_S[2]) \u2208 E.\n3) Deterministically verify the extendibility condition above for all |T|^4 quadruples (trying the 4 orientation choices for S1,S2 and scanning m \u2208 \u03a3_out).\nComplexity. |T| \u2264 \u2113_pump \u2264 16\u00b72^{\u03b2^4}. Step 3 costs O(|T|^4 \u00b7 \u03b2), hence 2^{poly(\u03b2)}. The guess size |F| is |T|^2\u00b74 entries, each an ordered pair in \u03a3_out^2: total certificate size 2^{poly(\u03b2)}.\nCorrectness sketch. This is the paper\u2019s feasible-function notion specialized to r=1; replace arbitrary words by their types (Lemma 10/11), and label only the 2-node windows. The R_t composition exactly captures the existence of fillings for the unlabeled blocks w_b and w_c between S1 and S2. If such F exists, the o(n) construction of Section 4.2 yields an O(log* n)-round algorithm; if not, the problem has complexity \u03a9(n).\nHow it can fail. Two pitfalls: (i) Orientation/reversal: when we choose to label S1 or SR_1 we must use the appropriate context (swap t_a and t_b, and reverse the 2-bit S; our check enumerates both options). (ii) Using types: one must ensure the type-invariance lemma (Lemma 10/11) applies; here it does, since we only rely on boundary extendibility.\nQuick test. Consider an LCL where A_0 \u2229 A_1 = \u2205 and E disallows any edge between outputs allowed by 0 and those by 1. Then R_t is empty whenever the block contains both 0 and 1 near its boundary, and no F can satisfy the bridging, so we correctly conclude \u03a9(n).\n\nClaim 5 (NEXPTIME decision for \u03c9(1)\u2014o(log* n): existence of wrap-around boundary quadruples per type)\nStatement. There is a nondeterministic algorithm running in time 2^{poly(\u03b2)} that decides whether the LCL has complexity O(1) vs \u03a9(log* n), assuming it is o(n) (i.e., Claim 4\u2019s test passed).\nWhy useful here. This separates the two sublinear regimes in NEXPTIME, completing the trichotomy decision.\nWitness to guess.\n- For each type t \u2208 T, guess a boundary quadruple Q_t = (L1_t, L2_t, R2_t, R1_t) \u2208 \u03a3_out^4 intended to be the outputs on the first two and last two nodes of any block labeled by the constant-time scheme (cf. Section 4.4 of the paper).\n- Reuse the table F from Claim 4 (or guess a fresh f for 2-node windows; both lead to 2^{poly(\u03b2)} guesses).\nChecks.\n(i) Local and wrap-around validity per type. For each t with boundary input bits (\u21131,\u21132) at the left and (r2,r1) at the right, enforce\n  - L1_t \u2208 A_{\u21131}, L2_t \u2208 A_{\u21132}, R2_t \u2208 A_{r2}, R1_t \u2208 A_{r1};\n  - (L1_t, L2_t) \u2208 E, (R2_t, R1_t) \u2208 E;\n  - (L1_t, L2_t, R2_t, R1_t) \u2208 Ext_t (so the interior is fillable);\n  - wrap-around across repetitions: (R1_t, L1_t) \u2208 E.\n(ii) Bridging via 2-node windows. For all pairs (t_b, t_c) \u2208 T^2 and for all S \u2208 {00,01,10,11}, there exist 2-node outputs L_S (these can be taken from F(t_b, S, t_c) if we reuse F) satisfying per-node legality and (L_S[1], L_S[2]) \u2208 E, such that\n  \u2203 m \u2208 \u03a3_out: (R1_{t_b}, m) \u2208 R_{t_b} and (m, L1_{t_c}) \u2208 R_{t_c}, with the boundaries of S chosen appropriately (last of S feeds into t_b, first of S feeds from t_c). Equivalently, there exists a labeling of S whose last/first outputs connect to the block boundary outputs via R_{t_b} and R_{t_c}.\nComplexity. The number of checks is O(|T| + |T|^2\u00b74) = 2^{poly(\u03b2)}. Each check costs poly(\u03b2). Guess size is O(|T|\u00b7log \u03b2^4) plus the 2-node window table as in Claim 4.\nCorrectness sketch. This mirrors Section 4.4\u20134.5: the quadruple Q_t guarantees we can tile long periodic parts by repeating the chosen boundary scheme (wrap-around holds), and the 2-node windows with F stitch the remaining short/irregular parts. The R_t matrices certify fillability of the unlabeled blocks adjacent to the 2-node windows. If such witnesses exist, the O(1)-round construction follows; otherwise \u03a9(log* n).\nHow it can fail. Subtlety: for very short representatives (length < 4), Ext_t must be computed accurately so that (L1_t, L2_t, R2_t, R1_t) \u2208 Ext_t truly guarantees interior extendibility. This is covered by the initialization in Claim 2.\nQuick test. Suppose E has a self-loop at c and c \u2208 A_0 \u2229 A_1. Pick Q_t = (c,c,c,c) for all t and L_S = (c,c) for all S. Then all constraints pass, classifying the problem as O(1), which is correct (output c everywhere).\n\nToy examples\n- Example A (No constant-time solution, \u03a9(n)). Let \u03b2=2, \u03a3_out={a,b}, A_0={a}, A_1={b}, and E = {(a,b), (b,a)} (alternating). Then any legal labeling forces alternation matching the input\u2019s parity; stitching arbitrary 2-node windows across arbitrary blocks fails because R_t is empty for many contexts. Claim 4 rejects F, giving \u03a9(n).\n- Example B (Constant-time trivial). Let A_0 = A_1 = \u03a3_out and E complete. Then O(1) holds with Q_t=(a,a,a,a) and L_S=(a,a) (for any fixed a). Claims 4 and 5 accept.\n\nWhy the naive algorithm is doubly exponential and how we avoid it\n- Naively, checking feasibility would range over all words w with |w| \u2264 \u2113_pump; since \u2113_pump itself is exponential in \u03b2, the total number of words is doubly exponential in \u03b2. The paper\u2019s decidability argument (\u201cfeasible function exists\u201d) is based on types but, if implemented by enumerating domain strings of f, becomes 2^{2^{poly(\u03b2)}}.\n- Our approach collapses all universal quantification over words to universal quantification over types, whose number is \u2113_pump \u2264 2^{poly(\u03b2)}. All witnesses (F, boundary quadruples) are tables indexed by types (and the 4 possible 2-bit S), of size 2^{poly(\u03b2)}. All checks boil down to iterating over |T|^{O(1)} combinations and scanning \u03b2-sized alphabets\u2014total time 2^{poly(\u03b2)}.\n- Moreover, computing T and \u03b4 deterministically by DP on boundary-extendibility tables avoids guessing exponentially many representatives.\n\nComplexity summary (in terms of input size N = poly(\u03b2))\n- Compute T, \u03b4, Ext_t, and R_t: time 2^{poly(\u03b2)} = 2^{poly(N)}.\n- Stage 1 (\u03a9(n) vs o(n)): nondeterministically guess F of size 2^{poly(N)} and verify in time 2^{poly(N)}.\n- Stage 2 (O(1) vs \u03a9(log* n)): nondeterministically guess Q_t (and optionally reuse F) of size 2^{poly(N)} and verify in time 2^{poly(N)}.\nHence: a NEXPTIME (indeed EXPTIME) trichotomy decision procedure for \u03b2-normalized, radius-1 LCLs on globally oriented paths.\n\nLimits and open technical points (to be finalized)\n- Type update (\u03b4) for short representatives. We outlined casework; formalizing the exact DP for k \u2208 {1,2,3} is needed to ensure correctness at the base.\n- Reversal handling. When allowing reversed 2-node windows, we must consistently use the reversed type t^R (swap L/R bits and reverse boundary order). Precomputing t \u21a6 t^R is straightforward from Ext_t.\n- Proof detail that the chosen Q_t and F suffice to reconstruct the O(1) algorithm exactly as in the paper\u2019s Section 4.5. Our checks mirror their feasible-function definition; we will write the full reduction argument for completeness.\n\nNext concrete steps\n- Formalize the dynamic programming that computes Ext_{t\u2032} from Ext_t and a new bit a (cleanly handling all small-k cases), and write a proof of its correctness (specialized Lemma 12 made algorithmic).\n- Implement the computation of T, \u03b4 and R_t (pseudo-code sketch), and quantify exact polynomial exponents in \u03b2 for time/memory.\n- Write the precise verification routines for Stage 1 and Stage 2, including the reversal operator on types and on the 2-node window table F.\n- Exercise the routines on a few canonical LCLs (e.g., 2-coloring over oriented paths, trivial constant labeling, parity constraints) to sanity-check the checks.\n",
  "new_files": [],
  "requests_for_more_materials": [],
  "next_actions_for_prover": [
    "Write the detailed DP recurrence to compute Ext_{t\u2032} from Ext_t when appending a bit a \u2208 {0,1}, with explicit handling of k \u2208 {1,2,3} and proof that it matches the definition of Type(P) (algorithmic form of Lemma 12).",
    "Define and prove properties of the reversal operator on types: how to compute t^R from t, and how Ext_t transforms under reversal; verify R_{t^R} is the transpose of R_t in the appropriate sense.",
    "Specify and prove the correctness of the Stage 1 verification: show that the existence of F satisfying the R_t-based bridging condition is equivalent to the paper\u2019s feasible function (Section 4.2) for r=1, thus characterizing o(n) vs \u03a9(n).",
    "Specify and prove the correctness of the Stage 2 verification: show that existence of (Q_t) and window labels (reusing F) implies an O(1)-round algorithm via the paper\u2019s partitioning, and conversely that O(1) implies such witnesses exist.",
    "Draft pseudo-code for the overall NEXPTIME (deterministic 2^{poly(\u03b2)} plus nondeterministic guesses) procedure and analyze its bit-complexity in terms of N = poly(\u03b2).",
    "Construct and check two toy instances end-to-end: (i) E complete (trivial O(1)), (ii) alternating constraint with A_0={a}, A_1={b}, E={(a,b),(b,a)} (expect \u03a9(n))."
  ]
}