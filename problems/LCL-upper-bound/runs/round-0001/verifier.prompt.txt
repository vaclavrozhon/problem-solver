--- SYSTEM ---
You are a strict mathematical verifier & research manager.

Tasks:
1) Audit correctness & rigor. Identify leaps, gaps, unjustified claims, likely false statements; produce the simplest counterexample or the minimal missing lemma.
2) Triage value. Separate genuine progress from noise.
3) Guide next steps. Suggest the next experiments/lemmas that most raise confidence.

Include a 3-row table:
| Claim (short) | Status [OK/Unclear/Broken] | Why |

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique for the prover (≥150 words)",
  "summary_md": "2–10 bullets for the human: what works, what fails, next steps",
  "verdict": "promising|uncertain|unlikely",
  "blocking_issues": []
}

--- USER ---
You receive multiple prover reports. Evaluate correctness, value, and pick promising directions. Optionally update notes and decide whether to call the writer.

Prover reports (JSON):
[{"prover_id": "01", "progress_md": "## Round 0001 \u2014 2025-08-27T10:32:01.431305Z\n\nMini-plan\n- Specialize the feasible-function framework of the paper to radius-1, \u03b2-normalized LCLs on globally oriented paths, and isolate a finite-state summary (types) that is exponential but not doubly exponential in \u03b2.\n- Show we can deterministically compute all reachable types and a successor function \u03b4(Type, bit) in time 2^{poly(\u03b2)} by dynamic programming on boundary-extendibility tables.\n- Define, for each type t, a macro relation R_t \u2286 \u03a3_out \u00d7 \u03a3_out that summarizes \u201cwhat boundary output labels can be bridged across a block of type t\u201d.\n- Give a NEXPTIME (indeed EXPTIME) decision procedure for the \u03c9(log* n)\u2014o(n) gap by nondeterministically guessing a small table F on contexts of the form (leftType, 2-bit S, rightType) and verifying extendibility using the R_t relations.\n- Give a NEXPTIME decision procedure for the \u03c9(1)\u2014o(log* n) gap by nondeterministically guessing boundary quadruples per type (first/second/second-last/last outputs) and verifying the wrap-around and bridging conditions via R_t and local checks.\n- Validate with toy examples and note failure modes; identify concrete next steps to formalize the type-update computation and the verification routines.\n\nContext and notation (radius 1, \u03b2-normalized)\n- Inputs: \u03a3_in = {0,1}. Outputs: \u03a3_out with |\u03a3_out| = \u03b2. Legality: (in, out) \u2208 C_in\u2013out and (out, out\u2032) \u2208 C_out\u2013out on each directed edge.\n- Let E \u2286 \u03a3_out \u00d7 \u03a3_out denote the directed edge relation from C_out\u2013out. Let A_0, A_1 \u2286 \u03a3_out denote allowed outputs per input bit (rows of C_in\u2013out).\n- For a (long) input block P (string over {0,1}), write its type Type(P) as in the paper: r = 1 \u21d2 D1 are the two endpoints; D2 are their immediate neighbors; extendibility is captured by which assignments of output labels to the four boundary nodes D1 \u222a D2 can be extended to a full legal labeling on the interior D3.\n\nClaim 1 (Type-count bound specialized to r = 1)\nStatement. The number of distinct types (equivalence classes \u22c6\u223c) is at most \u2113_pump \u2264 16 \u00b7 2^{\u03b2^4}.\nWhy useful here. This bounds the state space of our finite abstraction by a single-exponential function of \u03b2, enabling 2^{poly(\u03b2)} algorithms.\nSketch. For r = 1, D1 \u222a D2 contains 4 boundary nodes. There are 2^4 choices of boundary input bits. For each, the extendibility predicate is a Boolean function over assignments of 4 boundary output labels, i.e., a subset of \u03a3_out^4, hence at most 2^{\u03b2^4} possibilities. Multiplying gives \u2264 16 \u00b7 2^{\u03b2^4}.\nHow it can fail. If radius r > 1 were needed, the exponent would grow as \u03b2^{4r}, but still single-exponential for constant r. No failure for r=1.\nQuick test. With \u03b2=2, bound is 16\u00b72^{16} \u2248 1M types (a rough upper bound); fine for theoretical complexity, impractical to enumerate in practice but enough for 2^{poly(\u03b2)} complexity.\n\nClaim 2 (Deterministically computing all reachable types and \u03b4 in 2^{poly(\u03b2)} time)\nStatement. We can compute the set T of all types reachable from length-\u22644 words under appending bits, together with a deterministic successor function \u03b4: T \u00d7 {0,1} \u2192 T, in deterministic time 2^{poly(\u03b2)}.\nWhy useful here. Avoids enumerating 2^{\u2113_pump} strings. Once T and \u03b4 are known, all further checks quantify only over T (singly exponential), not over words (doubly exponential).\nConstruction and verification.\n- Represent a type t \u2208 T by (Lbits, Rbits, Ext_t), where Lbits, Rbits \u2208 {0,1}^2 are the 2-bit prefix/suffix of any representative, and Ext_t \u2286 \u03a3_out^4 is the set of boundary 4-tuples (o_L1, o_L2, o_R2, o_R1) that are extendible to a full legal labeling inside.\n- Initialization. Enumerate all input strings P of length k \u2208 {1,2,3,4} (\u2264 16 of them). For each, compute Ext_{Type(P)} exactly by dynamic programming on the tiny interior: enumerate all 4-tuples of boundary outputs consistent with C_in\u2013out on boundary nodes and E on boundary edges; check extendibility of the (empty or short) interior by brute force (cost \u03b2^{O(4)} per P). Insert the resulting canonical type into a dictionary keyed by (Lbits, Rbits, Ext_t).\n- Update (\u03b4). Given t = (Lbits, Rbits, Ext_t) and a \u2208 {0,1}, we can compute t\u2032 = \u03b4(t, a) as follows: t\u2032 has Lbits\u2032 = first two bits of (Lbits concatenated if current length<2 else unchanged), Rbits\u2032 = updated last-two-bits after appending a, and Ext_{t\u2032} is obtained by a constant-size \u201cboundary-augmentation\u201d DP: a boundary 4-tuple (o_L1, o_L2, o_R2\u2032, o_R1\u2032) is in Ext_{t\u2032} iff there exist o_R2, o_R1 and an output label o_new for the appended node such that\n  (i) (o_L1, o_L2, o_R2, o_R1) \u2208 Ext_t,\n  (ii) membership constraints at the new last node: o_new \u2208 A_a,\n  (iii) E-edges: (o_R1, o_new) \u2208 E, and then set o_R2\u2032=o_new (the new second-last), o_R1\u2032 = ?\n  Careful: after appending one node, the new last two boundary outputs are (old last, new), so interpret indexes accordingly. Full derivation requires casework for short representatives (k < 4), but all cases are constant and handled locally.\n- BFS enumeration. Starting from the set of types derived for k \u2264 4, add \u03b4(t,0) and \u03b4(t,1) for each discovered t until closure. Each \u03b4-computation runs in \u03b2^{O(4)} time (constant-factor DP over \u03a3_out^4). The number of types discovered is \u2264 \u2113_pump. Thus total time \u2264 \u2113_pump \u00b7 poly(\u03b2) = 2^{poly(\u03b2)}.\nHow it can fail. The update must be consistent for small-k degeneracies (k < 4) where D1\u222aD2 overlaps; if mishandled, one might compute inconsistent Ext sets. We mitigate by bootstrapping directly from exact computation for k \u2264 4 and carefully distinguishing cases in the update.\nQuick test. For a trivial LCL where E is complete and A_0=A_1=\u03a3_out, Ext_t=\u03a3_out^4 for all t. Then \u03b4 creates only 16 distinct types (Lbits,Rbits, full Ext). BFS closes after O(1) expansions\u2014consistent and fast.\n\nClaim 3 (Macro bridging relation R_t)\nStatement. For each type t, we can compute a relation R_t \u2286 \u03a3_out \u00d7 \u03a3_out such that (x, y) \u2208 R_t iff there exists a legal labeling of some block P of type t that bridges the outer boundary labels x \u2192 y, in the sense: there exist boundary outputs (o_L1,o_L2,o_R2,o_R1) \u2208 Ext_t with E-edges (x, o_L1) and (o_R1, y).\nWhy useful here. R_t summarizes the net effect of an unlabeled block of type t on the neighboring outside outputs. It collapses an entire block to a \u03b2\u00d7\u03b2 boolean matrix for later composition checks.\nComputation. For each t and each (x,y) \u2208 \u03a3_out^2, test whether \u2203 (o_L1,o_L2,o_R2,o_R1) \u2208 Ext_t such that (x, o_L1) \u2208 E and (o_R1, y) \u2208 E. This costs O(\u03b2^4) per (x,y), hence O(\u03b2^6) per t.\nHow it can fail. If we misinterpret boundary directions (left/right), the composition in later checks breaks. We fix orientation globally: x is the output immediately before the block on the left, y is the output immediately after the block on the right.\nQuick test. If E has a self-loop at c and c \u2208 A_0\u2229A_1 at all boundary nodes, then (c,c) \u2208 R_t for all t, since boundary tuple (c,c,c,c) is valid: sanity check.\n\nClaim 4 (NEXPTIME decision for \u03c9(log* n)\u2014o(n): existence of a context-local f on 2-node windows)\nStatement. There is a nondeterministic algorithm running in time 2^{poly(\u03b2)} that decides whether a feasible function f (in the sense of Section 4.2 of the paper) exists; equivalently, whether the LCL has deterministic LOCAL complexity o(n) instead of \u03a9(n).\nWhy useful here. This separates \u03a9(n) from o(n) in NEXPTIME, as requested.\nDefinition (specialized). For r=1, f takes as input a triple (t_L, S, t_R) where t_L, t_R \u2208 T are types of the left/right contexts, and S \u2208 {0,1}^2 is the 2-bit middle window; f outputs L_S \u2208 \u03a3_out^2 for S, with (i) (S[1], L_S[1]) \u2208 C_in\u2013out, (S[2], L_S[2]) \u2208 C_in\u2013out, and (ii) (L_S[1], L_S[2]) \u2208 E.\nVerification condition (extendibility). For all quadruples (t_a, t_b, t_c, t_d) \u2208 T^4, there exist orientation choices for S1,S2 (i.e., optionally reverse them; this toggles which side of L_S we use as boundary) such that, writing s1_last as the output of the last node of S1 under f and s2_first as the output of the first node of S2 under f, we have\n  \u2203 m \u2208 \u03a3_out: (s1_last, m) \u2208 R_{t_b} and (m, s2_first) \u2208 R_{t_c}.\nAlgorithm.\n1) Deterministically compute T, \u03b4, and all R_t (Claim 2 and 3) in 2^{poly(\u03b2)} time.\n2) Nondeterministically guess a table F: T \u00d7 {0,1}^2 \u00d7 T \u2192 \u03a3_out^2 assigning outputs to the 2-node window for every context. Enforce local per-node legality and (L_S[1],L_S[2]) \u2208 E.\n3) Deterministically verify the extendibility condition above for all |T|^4 quadruples (trying the 4 orientation choices for S1,S2 and scanning m \u2208 \u03a3_out).\nComplexity. |T| \u2264 \u2113_pump \u2264 16\u00b72^{\u03b2^4}. Step 3 costs O(|T|^4 \u00b7 \u03b2), hence 2^{poly(\u03b2)}. The guess size |F| is |T|^2\u00b74 entries, each an ordered pair in \u03a3_out^2: total certificate size 2^{poly(\u03b2)}.\nCorrectness sketch. This is the paper\u2019s feasible-function notion specialized to r=1; replace arbitrary words by their types (Lemma 10/11), and label only the 2-node windows. The R_t composition exactly captures the existence of fillings for the unlabeled blocks w_b and w_c between S1 and S2. If such F exists, the o(n) construction of Section 4.2 yields an O(log* n)-round algorithm; if not, the problem has complexity \u03a9(n).\nHow it can fail. Two pitfalls: (i) Orientation/reversal: when we choose to label S1 or SR_1 we must use the appropriate context (swap t_a and t_b, and reverse the 2-bit S; our check enumerates both options). (ii) Using types: one must ensure the type-invariance lemma (Lemma 10/11) applies; here it does, since we only rely on boundary extendibility.\nQuick test. Consider an LCL where A_0 \u2229 A_1 = \u2205 and E disallows any edge between outputs allowed by 0 and those by 1. Then R_t is empty whenever the block contains both 0 and 1 near its boundary, and no F can satisfy the bridging, so we correctly conclude \u03a9(n).\n\nClaim 5 (NEXPTIME decision for \u03c9(1)\u2014o(log* n): existence of wrap-around boundary quadruples per type)\nStatement. There is a nondeterministic algorithm running in time 2^{poly(\u03b2)} that decides whether the LCL has complexity O(1) vs \u03a9(log* n), assuming it is o(n) (i.e., Claim 4\u2019s test passed).\nWhy useful here. This separates the two sublinear regimes in NEXPTIME, completing the trichotomy decision.\nWitness to guess.\n- For each type t \u2208 T, guess a boundary quadruple Q_t = (L1_t, L2_t, R2_t, R1_t) \u2208 \u03a3_out^4 intended to be the outputs on the first two and last two nodes of any block labeled by the constant-time scheme (cf. Section 4.4 of the paper).\n- Reuse the table F from Claim 4 (or guess a fresh f for 2-node windows; both lead to 2^{poly(\u03b2)} guesses).\nChecks.\n(i) Local and wrap-around validity per type. For each t with boundary input bits (\u21131,\u21132) at the left and (r2,r1) at the right, enforce\n  - L1_t \u2208 A_{\u21131}, L2_t \u2208 A_{\u21132}, R2_t \u2208 A_{r2}, R1_t \u2208 A_{r1};\n  - (L1_t, L2_t) \u2208 E, (R2_t, R1_t) \u2208 E;\n  - (L1_t, L2_t, R2_t, R1_t) \u2208 Ext_t (so the interior is fillable);\n  - wrap-around across repetitions: (R1_t, L1_t) \u2208 E.\n(ii) Bridging via 2-node windows. For all pairs (t_b, t_c) \u2208 T^2 and for all S \u2208 {00,01,10,11}, there exist 2-node outputs L_S (these can be taken from F(t_b, S, t_c) if we reuse F) satisfying per-node legality and (L_S[1], L_S[2]) \u2208 E, such that\n  \u2203 m \u2208 \u03a3_out: (R1_{t_b}, m) \u2208 R_{t_b} and (m, L1_{t_c}) \u2208 R_{t_c}, with the boundaries of S chosen appropriately (last of S feeds into t_b, first of S feeds from t_c). Equivalently, there exists a labeling of S whose last/first outputs connect to the block boundary outputs via R_{t_b} and R_{t_c}.\nComplexity. The number of checks is O(|T| + |T|^2\u00b74) = 2^{poly(\u03b2)}. Each check costs poly(\u03b2). Guess size is O(|T|\u00b7log \u03b2^4) plus the 2-node window table as in Claim 4.\nCorrectness sketch. This mirrors Section 4.4\u20134.5: the quadruple Q_t guarantees we can tile long periodic parts by repeating the chosen boundary scheme (wrap-around holds), and the 2-node windows with F stitch the remaining short/irregular parts. The R_t matrices certify fillability of the unlabeled blocks adjacent to the 2-node windows. If such witnesses exist, the O(1)-round construction follows; otherwise \u03a9(log* n).\nHow it can fail. Subtlety: for very short representatives (length < 4), Ext_t must be computed accurately so that (L1_t, L2_t, R2_t, R1_t) \u2208 Ext_t truly guarantees interior extendibility. This is covered by the initialization in Claim 2.\nQuick test. Suppose E has a self-loop at c and c \u2208 A_0 \u2229 A_1. Pick Q_t = (c,c,c,c) for all t and L_S = (c,c) for all S. Then all constraints pass, classifying the problem as O(1), which is correct (output c everywhere).\n\nToy examples\n- Example A (No constant-time solution, \u03a9(n)). Let \u03b2=2, \u03a3_out={a,b}, A_0={a}, A_1={b}, and E = {(a,b), (b,a)} (alternating). Then any legal labeling forces alternation matching the input\u2019s parity; stitching arbitrary 2-node windows across arbitrary blocks fails because R_t is empty for many contexts. Claim 4 rejects F, giving \u03a9(n).\n- Example B (Constant-time trivial). Let A_0 = A_1 = \u03a3_out and E complete. Then O(1) holds with Q_t=(a,a,a,a) and L_S=(a,a) (for any fixed a). Claims 4 and 5 accept.\n\nWhy the naive algorithm is doubly exponential and how we avoid it\n- Naively, checking feasibility would range over all words w with |w| \u2264 \u2113_pump; since \u2113_pump itself is exponential in \u03b2, the total number of words is doubly exponential in \u03b2. The paper\u2019s decidability argument (\u201cfeasible function exists\u201d) is based on types but, if implemented by enumerating domain strings of f, becomes 2^{2^{poly(\u03b2)}}.\n- Our approach collapses all universal quantification over words to universal quantification over types, whose number is \u2113_pump \u2264 2^{poly(\u03b2)}. All witnesses (F, boundary quadruples) are tables indexed by types (and the 4 possible 2-bit S), of size 2^{poly(\u03b2)}. All checks boil down to iterating over |T|^{O(1)} combinations and scanning \u03b2-sized alphabets\u2014total time 2^{poly(\u03b2)}.\n- Moreover, computing T and \u03b4 deterministically by DP on boundary-extendibility tables avoids guessing exponentially many representatives.\n\nComplexity summary (in terms of input size N = poly(\u03b2))\n- Compute T, \u03b4, Ext_t, and R_t: time 2^{poly(\u03b2)} = 2^{poly(N)}.\n- Stage 1 (\u03a9(n) vs o(n)): nondeterministically guess F of size 2^{poly(N)} and verify in time 2^{poly(N)}.\n- Stage 2 (O(1) vs \u03a9(log* n)): nondeterministically guess Q_t (and optionally reuse F) of size 2^{poly(N)} and verify in time 2^{poly(N)}.\nHence: a NEXPTIME (indeed EXPTIME) trichotomy decision procedure for \u03b2-normalized, radius-1 LCLs on globally oriented paths.\n\nLimits and open technical points (to be finalized)\n- Type update (\u03b4) for short representatives. We outlined casework; formalizing the exact DP for k \u2208 {1,2,3} is needed to ensure correctness at the base.\n- Reversal handling. When allowing reversed 2-node windows, we must consistently use the reversed type t^R (swap L/R bits and reverse boundary order). Precomputing t \u21a6 t^R is straightforward from Ext_t.\n- Proof detail that the chosen Q_t and F suffice to reconstruct the O(1) algorithm exactly as in the paper\u2019s Section 4.5. Our checks mirror their feasible-function definition; we will write the full reduction argument for completeness.\n\nNext concrete steps\n- Formalize the dynamic programming that computes Ext_{t\u2032} from Ext_t and a new bit a (cleanly handling all small-k cases), and write a proof of its correctness (specialized Lemma 12 made algorithmic).\n- Implement the computation of T, \u03b4 and R_t (pseudo-code sketch), and quantify exact polynomial exponents in \u03b2 for time/memory.\n- Write the precise verification routines for Stage 1 and Stage 2, including the reversal operator on types and on the 2-node window table F.\n- Exercise the routines on a few canonical LCLs (e.g., 2-coloring over oriented paths, trivial constant labeling, parity constraints) to sanity-check the checks.\n", "new_files": [], "requests_for_more_materials": [], "next_actions_for_prover": ["Write the detailed DP recurrence to compute Ext_{t\u2032} from Ext_t when appending a bit a \u2208 {0,1}, with explicit handling of k \u2208 {1,2,3} and proof that it matches the definition of Type(P) (algorithmic form of Lemma 12).", "Define and prove properties of the reversal operator on types: how to compute t^R from t, and how Ext_t transforms under reversal; verify R_{t^R} is the transpose of R_t in the appropriate sense.", "Specify and prove the correctness of the Stage 1 verification: show that the existence of F satisfying the R_t-based bridging condition is equivalent to the paper\u2019s feasible function (Section 4.2) for r=1, thus characterizing o(n) vs \u03a9(n).", "Specify and prove the correctness of the Stage 2 verification: show that existence of (Q_t) and window labels (reusing F) implies an O(1)-round algorithm via the paper\u2019s partitioning, and conversely that O(1) implies such witnesses exist.", "Draft pseudo-code for the overall NEXPTIME (deterministic 2^{poly(\u03b2)} plus nondeterministic guesses) procedure and analyze its bit-complexity in terms of N = poly(\u03b2).", "Construct and check two toy instances end-to-end: (i) E complete (trivial O(1)), (ii) alternating constraint with A_0={a}, A_1={b}, E={(a,b),(b,a)} (expect \u03a9(n))."]}, {"prover_id": "02", "progress_md": "## Round 0001 \u2014 2025-08-27T10:32:01.431496Z\n\nMini-plan\n- Formalize an exponential-size, finite state abstraction (\"types\") tailored to radius-1, \u03b2-normalized LCLs on globally oriented paths; give an explicit constructive algorithm to enumerate types in time 2^{poly(N)}.\n- Recast the paper\u2019s \u201cfeasible function\u201d definitions purely in terms of these types, so that the witness size is 2^{poly(N)} and feasibility checking is deterministic 2^{poly(N)}.\n- Design a nondeterministic exponential-time (NEXPTIME) procedure to distinguish \u03a9(n) vs o(n) by guessing a type-indexed feasible function f and verifying its universal constraints by dynamic-programming/composition over types.\n- Sketch an NEXPTIME procedure to distinguish O(1) vs \u03a9(log* n) by guessing a succinct witness of constant-time solvability and checking it via the same type machinery. Identify and minimize what must be guessed to keep the certificate within 2^{poly(N)}.\n- Stress-test key steps on toy instances (tiny \u03b2) and list potential failure modes (e.g., size blow-ups, missing symmetry cases) with quick checks.\n\nContext recap and normalization\n- Input: \u03b2-normalized radius-1 LCL on globally oriented paths, encoded by two Boolean tables: C_in\u2013out \u2286 {0,1} \u00d7 \u03a3_out and C_out\u2013out \u2286 \u03a3_out \u00d7 \u03a3_out. Encoding size N = \u0398(\u03b2^2) (dominant term \u03b2\u00d7\u03b2 out\u2013out table plus 2\u00d7\u03b2 in\u2013out rows). Goal: decide local complexity class \u2208 {O(1), \u0398(log* n), \u0398(n)}.\n- Known (Balliu et al.): on labeled paths/cycles, deterministic complexity is in {O(1), \u0398(log* n), \u0398(n)}; decidability shown via \u201ctypes\u201d/pumping and feasible functions, but naive runtime can be doubly exponential in \u03b2 by ranging over strings of length \u2113_pump (itself exponential in \u03b2).\n- Our aim: reorganize everything at the level of types (finite-state summaries), never at the level of strings of length \u2113_pump; then guessing the witness (a mapping on types) takes 2^{poly(N)} bits/time; verifying universally quantified constraints over all contexts reduces to 2^{poly(N)} checks, each doable in poly(\u03b2)\u00b7|T| time. This yields NEXPTIME overall.\n\nCore technical object: type summaries for radius 1\n- Radius r = 1. For any input-labeled directed path P, define D1 = {first, last node} and D2 = {second, second-last}. Define a summary Summ(P) consisting of:\n  - Boundary inputs b_in(P) = (i1, i2, i3, i4) \u2208 {0,1}^4 for the nodes in D1 \u222a D2, in order (leftmost to rightmost).\n  - A relation R_P \u2286 \u03a3_out^4 over boundary outputs (o1,o2,o3,o4), which holds iff \u201cthere exists a complete output labeling on the interior (D3) s.t. all nodes in D2\u222aD3 are locally consistent, and all edges internal to P touching D2 are locally consistent.\u201d This is exactly the paper\u2019s extendibility notion with boundary fixed on D1\u222aD2.\n- Two paths have the same type iff their (b_in, R) are identical. The number of possible types is \u2264 2^{|\u03a3_out|^{4}} \u00b7 |\u03a3_in|^{4} = 2^{\u03b2^4} \u00b7 16. This matches Lemma 13 (with r=1). Importantly, types form a finite set T of size \u03c4 \u2264 16\u00b72^{\u03b2^4} = 2^{poly(N)}.\n- Composition primitives (needed later):\n  1) Appending one input bit \u03b1 \u2208 {0,1}. If Summ(P) = (i1,i2,i3,i4, R) and P\u2019 = P\u00b7\u03b1, then Summ(P\u2019) = (i1,i2,i4,\u03b1, R\u2019) where for any boundary outputs (o1\u2019,o2\u2019,o3\u2019,o4\u2019), we have (o1\u2019,o2\u2019,o3\u2019,o4\u2019) \u2208 R\u2019 iff \u2203y \u2208 \u03a3_out s.t. (o1\u2019,o2\u2019,o3\u2019,y) \u2208 R, (y,o4\u2019) \u2208 C_out\u2013out, and (\u03b1,o4\u2019) \u2208 C_in\u2013out. This is computable by iterating over \u03b2^5 possibilities, hence poly(\u03b2) time per boundary quadruple; R\u2019 has size \u03b2^4 entries.\n  2) Concatenation B = P\u00b7Q. If Summ(P)=(i1,i2,i3,i4,R_P), Summ(Q)=(j1,j2,j3,j4,R_Q), and the actual concatenation has those boundary inputs (which hold by construction when P and Q are actual representatives we will compute), then Summ(B) carries boundary inputs (i1,i2,j3,j4) and relation R_B consists of all (o1,o2,o3\u2019,o4\u2019) for which \u2203(x3,x4,x1\u2019,x2\u2019) with (o1,o2,x3,x4)\u2208R_P, (x1\u2019,x2\u2019,o3\u2019,o4\u2019)\u2208R_Q, and (x4,x1\u2019) \u2208 C_out\u2013out (check only the single joint edge; all other local conditions are already encoded in R_P and R_Q). This can be computed in time roughly O(\u03b2^8) naively, still poly(\u03b2) for fixed \u03b2.\n\nAlgorithmic building of types in exp time (deterministic)\nClaim A (constructibility): We can enumerate all reachable type summaries T and their transitions (append 0/1) in deterministic time 2^{poly(N)}.\n- Construction: Initialize S with the 16 types of length-4 strings w \u2208 {0,1}^4 by direct evaluation of Summ(w). For each s \u2208 S and \u03b1 \u2208 {0,1}, compute s\u2019 = \u03b4(s,\u03b1) using Appending-1-bit primitive; if s\u2019 new, add to S; iterate to fixpoint. This is a standard DFA closure over inputs {0,1} in state space of size \u2264 \u03c4.\n- Costs: There are \u2264 \u03c4 states, each yields \u2264 2 successors; each \u03b4 computation requires O(\u03b2^5)\u00b7\u03b2^4 = poly(\u03b2)\u00b7\u03b2^4 boolean assignments processing to fill R\u2019 (\u03b2^4 table). Overall time and memory \u2264 \u03c4\u00b7poly(\u03b2)\u00b7\u03b2^4 = 2^{poly(N)}. Hence EXPTIME (deterministic). We will use this construction as a preprocessing step; it avoids handling strings of length \u2113_pump explicitly.\n- Why useful here: Everything we must check later depends only on types and their relations; this preprocessing gives us a finite, explicit universe T with computable composition.\n- How it can fail: Subtlety around paths of length < 4. We avoided it by seeding S with all length-4 strings and then only appending (growing) strings; definitions of Summ for length 4 are exact (D3 empty). Quick test: For \u03b2=2, compute all 16 initial summaries and one \u03b4 step; check counts stay \u2264 \u03c4 bound and relations are computed as specified.\n\nDeciding \u03a9(n) vs o(n): NEXPTIME via type-indexed feasible function f\nBackground: Paper\u2019s Lemma 17\u201318: o(n) iff there exists a feasible function f that locally pre-labels certain 2-node separators S (here |S|=2 since r=1) so that the remaining parts can always be extended.\nOur type-level specialization (globally oriented paths: no reversal needed):\n- Domain of f: triples (tL, s_in, tR) where tL, tR \u2208 T and s_in \u2208 {0,1}^2 is the input pattern on the 2-node separator S. Range: a 2-tuple of outputs in \u03a3_out^2 prescribing the outputs on the two nodes of S.\n- Size of domain: |T|^2 \u00b7 4 = 2^{poly(N)}. So f can be stored in 2^{poly(N)} bits.\n- Universal feasibility condition to verify for a guessed f:\n  For all t_a, t_b, t_c, t_d \u2208 T and s1, s2 \u2208 {0,1}^2, consider the input-labeled path\n    P = rep(t_a) \u00b7 S1 \u00b7 rep(t_b) \u00b7 rep(t_c) \u00b7 S2 \u00b7 rep(t_d),\n  where rep(t) is any fixed representative string realizing type t (we pick those during preprocessing when we first discover t). Let the outputs on S1 and S2 be f(t_a, s1, t_b) and f(t_c, s2, t_d) respectively. Then we require that there exists an output assignment for the middle block B = rep(t_b) \u00b7 rep(t_c) such that:\n  (i) both S1 nodes are locally consistent (C_in\u2013out and the single crossing edge to B),\n  (ii) all nodes of B are locally consistent,\n  (iii) both S2 nodes are locally consistent (C_in\u2013out and the crossing edge from B).\n- How to check exist(B): compute Summ(B) by concatenating Summ(rep(t_b)) and Summ(rep(t_c)) via the concatenation primitive. Let \u03b1L be the rightmost output of S1 (the second component of f(t_a,s1,t_b)), and \u03b1R the leftmost output of S2 (the first component of f(t_c,s2,t_d)). Then exist(B) holds iff there exist outputs (o1,o2,o3,o4) on B\u2019s D1\u222aD2 such that (o1,o2,o3,o4)\u2208R_B, (\u03b1L,o1)\u2208C_out\u2013out, (o4,\u03b1R)\u2208C_out\u2013out, and (input-consistency of the 2 nodes of S1 and S2) holds. This is a finite search over \u03b2^4 tuples (o1..o4), i.e., poly(\u03b2).\n- NEXPTIME procedure (stage 1):\n  1) Deterministically build T and, for each t\u2208T, a representative rep(t), plus Summ(rep(t)).\n  2) Nondeterministically guess f: T\u00d7{0,1}^2\u00d7T \u2192 \u03a3_out^2. Guessing costs |T|^2\u00b74\u00b72log\u03b2 bits.\n  3) Deterministically verify the universal feasibility condition across all |T|^4\u00b716 cases (composition per case in time poly(\u03b2) and looking up precomputed summaries). If all pass, conclude o(n); else \u03a9(n).\n- Complexity: Step (1) runs in 2^{poly(N)} time deterministically. Step (2) guessing uses \u2264 2^{poly(N)} bits/time. Step (3) runs in |T|^4\u00b7poly(\u03b2) \u2264 2^{poly(N)} time. Hence nondeterministic 2^{poly(N)} overall. This achieves NEXPTIME for separating \u03a9(n) vs o(n).\n- How it can fail: We used a representative rep(t_b)\u00b7rep(t_c) for B, but the feasible-function property quantifies over all strings of those types. This is safe by Lemma 10/11: extendibility on D2\u222aD3 is preserved when replacing a subpath with another of the same type, for any boundary assignment on D1\u222aD2. Our check existentially quantifies over B\u2019s boundary outputs (and only constrains the crossing edges to S1/S2), exactly the setting where type replacement is sound.\n- Quick toy check: \u03b2=2, choose trivial constraints that allow any (in,out) and any (out,out). Then T collapses to a tiny set, and any f passes; algorithm outputs o(n) (indeed the problem is solvable in 0 rounds). If we force a \u201cglobal bit copy to all nodes\u201d constraint (as in the PSPACE-hard encoding, but with tiny B), the check should fail for any f, yielding \u03a9(n).\n\nDeciding O(1) vs \u03a9(log* n): toward a type-succinct constant-time witness\nWe need a 2^{poly(N)}-size witness for O(1) (avoid listing a full periodic output string for every length-\u2264\u2113_pump w).\nKey observation from the O(1) framework (Section 4.4\u20134.5 of the paper):\n- The O(1) algorithm only uses boundary behavior of the repetitive patterns: it pre-labels 2-node separators inside \u201crepetitive\u201d blocks and uses type pumping to argue about extendibility. Concretely, when verifying that the pattern w can be tiled, what matters is the existence of consistent boundary outputs for copies of rep(t), not the entire output string.\n- We can therefore witness O(1) by giving, for each type t\u2208T, a small boundary interface consisting of four outputs:\n  \u2022 pref2(t) \u2208 \u03a3_out^2 for the first two nodes of rep(t), and\n  \u2022 suff2(t) \u2208 \u03a3_out^2 for the last two nodes of rep(t),\n  such that (a) the boundary quadruple (pref2(t), suff2(t)) is in R_{rep(t)}, and (b) the \u201cjoin\u201d edge (suff2(t)[2], pref2(t)[1]) lies in C_out\u2013out so two adjacent copies can be glued. This captures the periodic tiling constraint without spelling the whole interior.\n- This is sufficient for the two obligations in the paper\u2019s feasible function for O(1):\n  (i) Tiling consistency: For each t, existence of (pref2,suff2) in R_{rep(t)} with (suff2[2],pref2[1]) allowed ensures that arbitrarily many copies of rep(t) can be locally labeled so that all nodes in the interior copies are locally consistent. We do not need to fix the interior outputs; Summ(rep(t)) witnesses their existence.\n  (ii) Bridging through any S: For t1,t2 and any middle S (represented by some tS), we look only at the last 2 outputs of the block to the left and first 2 outputs of the block to the right. Those are suff2(t1) and pref2(t2). The existence of a consistent labeling of S is exactly: pick Summ(rep(tS)) and check whether \u2203(o1,o2,o3,o4)\u2208R_{rep(tS)} with (suff2(t1)[2], o1)\u2208C_out\u2013out and (o4,pref2(t2)[1])\u2208C_out\u2013out. This is the same pattern as in the o(n) verifier.\n- NEXPTIME procedure (stage 2):\n  1) Reuse T and Summ(rep(t)).\n  2) Nondeterministically guess, for each t \u2208 T, two 2-tuples pref2(t), suff2(t) \u2208 \u03a3_out^2. Certificate size: |T|\u00b74\u00b7log\u03b2 = 2^{poly(N)} bits.\n  3) Deterministically verify:\n     (a) For all t: (pref2(t)[1], pref2(t)[2], suff2(t)[1], suff2(t)[2]) \u2208 R_{rep(t)} and (suff2(t)[2], pref2(t)[1]) \u2208 C_out\u2013out.\n     (b) For all t1,t2 and for all tS \u2208 T \u222a {empty} (we handle S=\u2205 by a direct edge check): compute R_{rep(tS)} and check \u2203(o1,o2,o3,o4)\u2208R_{rep(tS)} with (suff2(t1)[2], o1) and (o4, pref2(t2)[1]) in C_out\u2013out. (As in the paper, only representatives of each type need to be tested.)\n  4) If all pass, output O(1); else \u03a9(log* n).\n- Correctness intuition: This compresses the paper\u2019s function g (which labeled entire w) to only its boundary interface. Existence of interior labelings is furnished by the type summaries R and concatenation checking; the O(1) construction in Lemma 27 never needs to commit to specific interior outputs ahead of time, only to consistent boundary interfaces. The MIS-free decomposition of cycles into repetitive segments is emulated here by universal checks over types tS capturing all patterns of S.\n- Complexity: Step (2) guessing takes 2^{poly(N)} bits/time. Step (3) checks |T| + |T|^2\u00b7|T| = |T|^3 = 2^{poly(N)} cases, each a poly(\u03b2) lookup, so 2^{poly(N)} time. Thus the O(1) vs \u03a9(log* n) decision is in NEXPTIME.\n- How it can fail: We rely on the boundary-only witness (pref2,suff2) being sufficient for tiling; if C_out\u2013out had longer-range dependencies, this would fail, but our LCL is radius-1, so only immediate neighbors matter. Quick test: with C_out\u2013out equal to equality of outputs (proper 1D \u201cmatching\u201d), pref2/suff2 must match at the join, and R_{rep(t)} enforces internal equalities; the checker\u2019s conditions reduce to expected constraints and accept exactly the O(1) cases.\n\nPutting it all together: full NEXPTIME classification\n- Preprocessing (deterministic EXPTIME): enumerate T, representatives rep(t), and Summ(rep(t)).\n- Stage 2 (NEXPTIME): Guess boundary interfaces (pref2,suff2) per type and verify O(1) via the conditions above. If pass, answer O(1).\n- Stage 1 (NEXPTIME): Otherwise, guess feasible f on type triples and verify; if pass, answer \u0398(log* n); else answer \u0398(n).\n- Overall: nondeterministic 2^{poly(N)} time and space. Witness sizes are capped at 2^{poly(N)}.\n\nSanity checks and small examples\n- Example 1 (trivial always-accepting LCL): C_in\u2013out \u2261 \u03a3_out for both inputs; C_out\u2013out \u2261 \u03a3_out\u00d7\u03a3_out. Then the precomputed R_{rep(t)} are full \u03a3_out^4 for all t. Guess pref2,suff2 arbitrarily, all checks pass; we output O(1). \n- Example 2 (force global agreement on a secret): C_in\u2013out allows any output, C_out\u2013out forces the whole path to output the same color c (i.e., adjacency allowed only when equal). Our checker fails O(1) because bridging through an S with mismatched c cannot be met uniformly; then it fails log* via the feasible-f check since the middle block cannot enforce equality across adversarially chosen separators without long-range coordination; we output \u0398(n).\n- Example 3 (proper 2-coloring independent of inputs): C_in\u2013out allows both colors irrespective of input; C_out\u2013out forbids equal adjacent outputs. Our checker will fail O(1) (no boundary pair can be glued periodically because (last,first) must alternate), but succeed for log*: a feasible f exists assigning alternating labels on separators; output \u0398(log* n).\n\nWhy the improvement over the naive \u201cdoubly exponential\u201d approach\n- The naive approach ranges over strings w of length \u2113_pump (which is \u2248 |T| \u2248 2^{poly(N)}), causing double-exponential enumeration (2^{\u2113_pump}) to define/verify feasible functions.\n- Our approach works purely at the type level. The number of types is \u03c4 \u2264 2^{poly(N)}, and all witnesses (pref2/suff2 per type; or f on type triples) are of size polynomial in \u03c4, thus 2^{poly(N)}. All universal verifications iterate over O(\u03c4^k) combinations and use polynomial-time (in \u03b2) composition/DP, yielding nondeterministic 2^{poly(N)} time overall.\n\nDependencies on path vs cycle and reversals\n- We explicitly target globally oriented paths; no reversal options are needed in the feasible-f definition (simplifies verification). The same machinery supports cycles by adding the reversal choice as in the paper, at a constant multiplicative factor.\n\nPotential refinements and open items\n- Tighten composition: We can speed up concatenation by precomputing 3D tensors to reduce O(\u03b2^8) to O(\u03b2^6) per composition via semiring convolution; not essential for complexity class.\n- Proof polishing for O(1) stage: We sketched sufficiency of boundary interfaces; to make it watertight, formalize that every use of repeated blocks in Lemma 27 only needs (i) existence of internal completions consistent with fixed 2-node boundary, and (ii) a valid join edge between adjacent copies. Both are exactly our checks.\n- Memory model: The algorithm stores \u03c4 many \u03b2^4-bit tables (R relations). This is 2^{poly(N)} space; acceptable for complexity theory, but huge in practice. Possible compression: store only sets of allowed pairs for each marginal (e.g., precompute allowed (o2,o3) pairs) to exploit sparsity in C_out\u2013out.\n\n", "new_files": [], "requests_for_more_materials": ["If available, a formal statement (or proof sketch) that for radius-1 LCLs the boundary-only interface (first-two/last-two outputs per type) suffices as a witness for O(1), i.e., that the interior need not be fixed to certify feasibility in Section 4.4\u2019s sense. I can formalize it, but a reference would speed up.", "Any constraints on \u03b2 (e.g., small \u03b2 cases where degeneracies occur) or special subclasses of C_out\u2013out worth handling separately to simplify composition (e.g., symmetric or functional relations).", "Clarification: do we need to treat the cycle case in this task, or strictly globally oriented paths? I\u2019ve designed for paths; adding reversals is straightforward if needed."], "next_actions_for_prover": ["Write the formal composition lemmas and their proofs tailored to r=1 (append-one-bit and concatenate types), with explicit correctness (why they preserve/reflect extendibility) and complexity bounds.", "Fully formalize the O(1) boundary-interface witness (pref2/suff2 per type): show equivalence to the feasible-function definition in Section 4.4 (with r=1), including the S=\u2205 corner case and handling of short paths.", "Specify the algorithm in pseudocode with explicit time/space bounds in terms of N = \u0398(\u03b2^2), and make the nondeterministic choices and verification loops precise.", "Test the framework on two nontrivial synthetic LCLs (e.g., parity-checking on inputs with a consistency edge constraint; and a \u201ccopy input to output\u201d with forbidden transitions) to confirm both stages behave as expected."]}]

Current notes.md:


Current outputs.tex (if any):

