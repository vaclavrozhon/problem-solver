{
  "progress_md": "## Round 0002 \u2014 2025-08-27T11:52:16.707614Z\n\nMini-plan\n- Fix the r=1 append-one-bit DP (\u03b4) with precise boundary indexing, including all short-length base cases; prove the r=1 congruence lemma (Type(P)=Type(Q) \u21d2 Type(Pa)=Type(Qa)).\n- State and prove a clean concatenation lemma for Ext-tables; record and explain a minimal counterexample to show R-composition via \u2203m is unsound.\n- Give explicit pseudo-code for deterministic enumeration of all reachable types and \u03b4 transitions; include complexity bounds and memory footprint.\n- Rewrite the NEXPTIME verifiers to use Ext-level concatenation (not R-composition) in both stages: (i) \u03a9(n) vs o(n) via feasible-function f on type triples; (ii) O(1) vs \u03a9(log* n) via per-type boundary interfaces; bound witness sizes.\n- Stress-test with tiny \u03b2 examples; list failure modes and quick checks.\n\nContext alignment with verifier feedback\n- Addressed: (1) \u03b4 must be derived from an exact append-one-bit recurrence with correct boundary indices; (2) composition of binary right-projections R_t via an existential middle color is unsound; we now only use Ext-level concatenation then (optionally) project.\n\nClaim 1 \u2014 r=1 append-one-bit DP (\u03b4) with short-length base cases\nStatement.\n- For a segment t of length k, the Ext-table Ext_t \u2286 \u03a3_out^4 records boundary quadruples (L1,L2,R2,R1) that are extendible. The boundary map B_k(c) (from a full output c on t) is:\n  \u2022 k=1: (c1,c1,c1,c1)\n  \u2022 k=2: (c1,c2,c1,c2)\n  \u2022 k=3: (c1,c2,c2,c3)\n  \u2022 k\u22654: (c1,c2,ck\u22121,ck)\n- Base cases (explicit computation of Ext_t for k=1,2,3) follow immediately from C_in\u2013out and C_out\u2013out (enumerate allowed tuples consistent with single-edge constraints).\n- Append-one-bit (general case k\u22653): writing t\u2032=t\u00b7a for a\u2208{0,1}, for any (x1,x2,x3,x4)\u2208\u03a3_out^4,\n  (x1,x2,x3,x4)\u2208Ext_{t\u2032} iff [x4\u2208A_a, (x3,x4)\u2208E, and \u2203z s.t. (x1,x2,z,x3)\u2208Ext_t].\nWhy useful here.\n- This yields a correct \u03b4 update and an O(\u03b2^5) routine to compute Ext_{t\u00b7a} from Ext_t.\nHow it can fail.\n- Misindexing the new right-two: must be (old last, new). Using (new, ?) corrupts Ext_{t\u2032} for k\u22654. Base-case degeneracies (k<4) must be handled explicitly; otherwise \u03b4 may be ill-defined.\nQuick test.\n- \u03b2=2, E complete, A_0=A_1=\u03a3_out: Ext_t=\u03a3_out^4 for all t; \u03b4 preserves fullness. For \u03b2=2, E={(0,1)}, A_0=A_1=\u03a3_out: start from k=1 base, append twice; verify that Ext_{of length 3} contains exactly tuples with (x1,x2)=(0,1), (x2,x3)=(0,1).\n\nClaim 2 \u2014 r=1 congruence: equality of Ext preserved by append\nStatement.\n- If Ext_P = Ext_Q then for every a\u2208{0,1}, Ext_{P\u00b7a} = Ext_{Q\u00b7a}.\nWhy useful here.\n- This shows \u03b4 is well-defined on type classes (summaries): Type(P)=Type(Q) implies Type(Pa)=Type(Qa), enabling DFA exploration over types.\nHow it can fail.\n- If base cases k\u2208{1,2,3} are not incorporated into the update, two segments with equal Ext might be treated differently by an incorrect append rule.\nQuick test.\n- Construct P,Q of length 3 with identical Ext (e.g., under E complete). Append a=0; both yield identical Ext_{\u00b7a}; then prune E to break some adjacencies and recompute to observe preserved equality.\n\nClaim 3 \u2014 Concatenation lemma for Ext (and why R-composition via \u2203m is unsound)\nStatement.\n- For bitstrings P,Q and B=P\u00b7Q: (o1,o2,o3\u2032,o4\u2032)\u2208Ext_B iff \u2203 x3,x4,x1\u2032,x2\u2032 such that (o1,o2,x3,x4)\u2208Ext_P, (x1\u2032,x2\u2032,o3\u2032,o4\u2032)\u2208Ext_Q, and (x4,x1\u2032)\u2208E.\nWhy useful here.\n- This gives a correct computable rule to derive the summary of concatenations solely from the two operand summaries and E; it is the backbone of our verifiers.\nHow it can fail.\n- If one only composes right-projections R_P, R_Q via \u2203m [(u,m)\u2208R_P \u2227 (m,w)\u2208R_Q], one can admit pairs (u,w) that cannot be realized across the seam edge.\nQuick counterexample.\n- \u03a3_out={a,b,c}, A_0=A_1=\u03a3_out, E={a\u2192b, b\u2192c}. Let P=Q=\u201800\u2019 (length-2). Then (a,b)\u2208R_P, (b,c)\u2208R_Q, so \u2203m=b yields (a,c) by naive composition. But no coloring of P\u00b7Q starts at a and ends at c (c has no outgoing edge), so (a,c)\u2209R_{P\u00b7Q}. Hence R-composition via \u2203m is unsound; we must use Ext-concatenation.\n\nClaim 4 \u2014 Deterministic enumeration of types and \u03b4 in single exponential time\nStatement.\n- Represent a type by its Ext-table (\u03b2^4 bits) and the boundary inputs (4 bits). Deterministically enumerate all reachable types via BFS on append transitions using Claim 1.\nPseudo-code.\n- Seed S with all length-1,2,3,4 bitstrings (\u22642+4+8+16=30) and compute Ext exactly.\n- While queue nonempty: pop t\u2208S, for a\u2208{0,1}, compute Ext_{t\u00b7a} via base cases (if |t|<3) or Claim 1 (if |t|\u22653); canonicalize (store boundary inputs and Ext_table); if new, add to S.\n- Optionally store a fixed representative bitstring rep(\u03c4) for each discovered type \u03c4 when first encountered, and record \u03b4(\u03c4,a).\nComplexity.\n- |Types| \u2264 16\u00b72^{\u03b2^4} (r=1 bound). Each append costs O(\u03b2^5) to fill \u03b2^4 entries. Total deterministic time and space \u2264 2^{poly(N)}.\nWhy useful here.\n- Provides the finite universe T, \u03b4, and reps used by the NEXPTIME verifiers; no word-level (doubly-exponential) enumeration needed.\nHow it can fail.\n- Equality testing of types must compare the full Ext-table and boundary-input bits; hashing collisions or partial comparisons can merge distinct types. Another pitfall: mishandling k<4 base cases.\nQuick test.\n- Trivial LCL with E complete, A_0=A_1=\u03a3_out: BFS closes quickly with only boundary-input distinction; \u03b4 just permutes those 16 classes.\n\nClaim 5 \u2014 NEXPTIME (\u03a9(n) vs o(n)) with corrected verification\nWitness.\n- f: T \u00d7 {0,1}^2 \u00d7 T \u2192 \u03a3_out^2 (assign outputs to a 2-node separator S given left and right types).\nVerification (for all t_a,t_b,t_c,t_d \u2208 T and s1,s2 \u2208 {0,1}^2):\n- Let B = rep(t_b)\u00b7rep(t_c). Compute Ext_B from Ext_{rep(t_b)} and Ext_{rep(t_c)} via concatenation (Claim 3).\n- Let \u03b1_L be the second output of f(t_a,s1,t_b); let \u03b1_R be the first output of f(t_c,s2,t_d). Check if \u2203 (o1,o2,o3,o4) \u2208 Ext_B with (\u03b1_L,o1)\u2208E, (o4,\u03b1_R)\u2208E, and per-node C_in\u2013out holds on s1,s2 and edge inside each S.\nDecision.\n- If a guessed f passes all checks, classify as o(n); else \u03a9(n).\nWhy useful here.\n- Corrected universal check avoids the unsound \u2203m composition and is purely type-level, yielding a NEXPTIME separation.\nHow it can fail.\n- Using only one representative per type is safe only if type replacement is valid. Lemma 10/11 (paper) ensures extendibility is type-invariant for boundary assignments on D1\u222aD2, which our Ext encoding captures.\nQuick test.\n- E complete, A_0=A_1=\u03a3_out: any f passes; output o(n). For E forcing equality (global constant), the check fails universally; output \u03a9(n).\n\nClaim 6 \u2014 NEXPTIME (O(1) vs \u03a9(log* n)) via boundary interfaces with corrected checks\nWitness.\n- For each t\u2208T, guess pref2(t), suff2(t) \u2208 \u03a3_out^2 (first two, last two outputs) and reuse/guess f as in Claim 5.\nChecks.\n- Per-type local consistency: (pref2,suff2) \u2208 Ext_{rep(t)}; joinability: (suff2(t)[2], pref2(t)[1]) \u2208 E.\n- Bridging: For all t1,t2 and all separator types \u03c4_S \u2208 T \u222a {empty}:\n  \u2022 Compute Ext_{rep(\u03c4_S)}; check \u2203 (o1,o2,o3,o4) \u2208 Ext_{rep(\u03c4_S)} with (suff2(t1)[2], o1)\u2208E and (o4, pref2(t2)[1])\u2208E (and also nodes of S satisfy C_in\u2013out). This replaces any prior R-composition.\nDecision.\n- If all pass, classify as O(1); else \u03a9(log* n).\nWhy useful here.\n- Compresses the constant-time witness to 2-node boundary interfaces and stitches blocks using Ext-level concatenation; matches Section 4.4\u20134.5 structure without enumerating long words.\nHow it can fail.\n- If some LCL requires specifying interior outputs beyond boundary feasibility (radius>1), the witness is insufficient. Here r=1; local constraints only inspect neighbors, so boundary feasibility plus seam checks suffice.\nQuick test.\n- E equality: pick any c; set pref2=suff2=(c,c) for all t. All checks pass \u21d2 O(1). For proper 2-coloring (E forbids equal adjacent): no per-type wrap-around (last-to-first) can be (x,y) with (y,x)\u2208E for a single block repeated; O(1) fails but log* passes via f.\n\nAlgorithmic summaries and complexity\n- Preprocessing: compute T, \u03b4, rep(t), and Ext_{rep(t)} for all t \u2208 T in deterministic 2^{poly(N)} time/space.\n- Stage 1 (\u03a9(n) vs o(n)): nondeterministically guess f (size |T|^2\u00b74 entries), verify universally using concatenations \u2192 NEXPTIME.\n- Stage 2 (O(1) vs \u03a9(log* n)): nondeterministically guess pref2/suff2 per type (size |T|), verify per-type and bridging constraints via Ext-tables \u2192 NEXPTIME.\n- All universal iterations scale like |T|^{O(1)}=2^{poly(N)}; each Ext concatenation or append is poly(\u03b2)\u00b7\u03b2^{O(4)}; overall NEXPTIME.\n\nPseudocode sketch \u2014 compute Ext_{P\u00b7Q} from Ext_P, Ext_Q (Claim 3)\n- Input: bit tables extP[x1][x2][x3][x4], extQ[y1][y2][y3][y4], adjacency E[u][v].\n- Initialize extB all false.\n- For all o1,o2,o3,o4 in \u03a3_out:\n  \u2022 found \u2190 false\n  \u2022 For all x3,x4,x1p,x2p in \u03a3_out:\n    \u2013 if extP[o1][o2][x3][x4] and extQ[x1p][x2p][o3][o4] and E[x4][x1p]: found \u2190 true; break\n  \u2022 if found: extB[o1][o2][o3][o4] \u2190 true\n- Return extB.\n\nSanity and toy checks\n- \u03b4 sanity: \u03b2=2, E complete. Running append 3 times from k=1 must produce Ext equal to \u03a3_out^4 for k\u22654; run-time shape invariant.\n- Concatenation sanity: Use counterexample E={a\u2192b, b\u2192c}. Compute extB via Claim 3; verify that (a,c)\u2209R_{B} although present in R_P\u2218R_Q.\n- Stage-1 sanity: trivial LCL (all allowed) \u21d2 accept with any f; equality LCL (all outputs equal) \u21d2 reject any f.\n- Stage-2 sanity: equality LCL \u21d2 accept with pref2=suff2=(c,c) for fixed c; proper 2-coloring \u21d2 reject O(1) but accept log*.\n\nWhat changed vs previous round\n- Fixed \u03b4 with exact boundary indices and base cases; proved congruence.\n- Replaced all uses of R-composition via \u2203m by Ext-level concatenation; added explicit counterexample showing necessity.\n- Provided explicit deterministic type-enumeration routine and clarified certificate verification steps and their complexity.\n",
  "requests_for_more_materials": [],
  "next_actions_for_prover": [
    "Formalize and write a short proof that type replacement using Ext (our summaries) implies the exact Lemma 10/11 properties used by the verifiers; keep it radius-1 and oriented-path specific.",
    "Specify the exact canonicalization for types (boundary-input bits + Ext-table), including a compact hashing for equality checks, and quantify the exact constants in the 2^{poly(N)} bound.",
    "Implement (or further pseudo-code) the deterministic BFS to enumerate T and \u03b4 with careful handling of k<4 base cases; include unit tests for tiny \u03b2 with known E, A_0, A_1.",
    "Refactor Stage-1 and Stage-2 verification pseudo-code to call a single Ext-concatenation routine; add the reversal operator on types and summaries if we later extend to cycles.",
    "Write the rigorous argument that the boundary-interface witness (pref2/suff2) suffices for O(1) when r=1, following Section 4.4\u20134.5 of the paper but in our Ext notation; explicitly tie each step to an Ext or concatenation check.",
    "Construct a small library of adversarial toy LCLs (equality, proper 2-coloring, no-edges E, the 3-symbol chain example) and run through all checks by hand to catch any remaining indexing pitfalls."
  ]
}