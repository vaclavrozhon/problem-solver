--- SYSTEM ---
You are a research **summarizer**. Summarize this *last round only* for a human log.

Include:
- 3–7 bullet **Highlights** (facts learned, reductions, counterexamples, partial bounds).
- 1–3 **Open questions / TODOs** for the next round.
- 1–3 **Citations to files** you relied on (e.g. round files or papers by name).

**Return strictly JSON**:
{
  "summary_md": "Readable summary of the round (≤200 words)",
  "highlights": [],
  "next_questions": []
}

--- USER ---
=== prover-01.out.json (progress_md) ===
## Round 0002 — 2025-08-27T11:52:16.707614Z

Mini-plan
- Fix the r=1 append-one-bit DP (δ) with precise boundary indexing, including all short-length base cases; prove the r=1 congruence lemma (Type(P)=Type(Q) ⇒ Type(Pa)=Type(Qa)).
- State and prove a clean concatenation lemma for Ext-tables; record and explain a minimal counterexample to show R-composition via ∃m is unsound.
- Give explicit pseudo-code for deterministic enumeration of all reachable types and δ transitions; include complexity bounds and memory footprint.
- Rewrite the NEXPTIME verifiers to use Ext-level concatenation (not R-composition) in both stages: (i) Ω(n) vs o(n) via feasible-function f on type triples; (ii) O(1) vs Ω(log* n) via per-type boundary interfaces; bound witness sizes.
- Stress-test with tiny β examples; list failure modes and quick checks.

Context alignment with verifier feedback
- Addressed: (1) δ must be derived from an exact append-one-bit recurrence with correct boundary indices; (2) composition of binary right-projections R_t via an existential middle color is unsound; we now only use Ext-level concatenation then (optionally) project.

Claim 1 — r=1 append-one-bit DP (δ) with short-length base cases
Statement.
- For a segment t of length k, the Ext-table Ext_t ⊆ Σ_out^4 records boundary quadruples (L1,L2,R2,R1) that are extendible. The boundary map B_k(c) (from a full output c on t) is:
  • k=1: (c1,c1,c1,c1)
  • k=2: (c1,c2,c1,c2)
  • k=3: (c1,c2,c2,c3)
  • k≥4: (c1,c2,ck−1,ck)
- Base cases (explicit computation of Ext_t for k=1,2,3) follow immediately from C_in–out and C_out–out (enumerate allowed tuples consistent with single-edge constraints).
- Append-one-bit (general case k≥3): writing t′=t·a for a∈{0,1}, for any (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4)∈Ext_{t′} iff [x4∈A_a, (x3,x4)∈E, and ∃z s.t. (x1,x2,z,x3)∈Ext_t].
Why useful here.
- This yields a correct δ update and an O(β^5) routine to compute Ext_{t·a} from Ext_t.
How it can fail.
- Misindexing the new right-two: must be (old last, new). Using (new, ?) corrupts Ext_{t′} for k≥4. Base-case degeneracies (k<4) must be handled explicitly; otherwise δ may be ill-defined.
Quick test.
- β=2, E complete, A_0=A_1=Σ_out: Ext_t=Σ_out^4 for all t; δ preserves fullness. For β=2, E={(0,1)}, A_0=A_1=Σ_out: start from k=1 base, append twice; verify that Ext_{of length 3} contains exactly tuples with (x1,x2)=(0,1), (x2,x3)=(0,1).

Claim 2 — r=1 congruence: equality of Ext preserved by append
Statement.
- If Ext_P = Ext_Q then for every a∈{0,1}, Ext_{P·a} = Ext_{Q·a}.
Why useful here.
- This shows δ is well-defined on type classes (summaries): Type(P)=Type(Q) implies Type(Pa)=Type(Qa), enabling DFA exploration over types.
How it can fail.
- If base cases k∈{1,2,3} are not incorporated into the update, two segments with equal Ext might be treated differently by an incorrect append rule.
Quick test.
- Construct P,Q of length 3 with identical Ext (e.g., under E complete). Append a=0; both yield identical Ext_{·a}; then prune E to break some adjacencies and recompute to observe preserved equality.

Claim 3 — Concatenation lemma for Ext (and why R-composition via ∃m is unsound)
Statement.
- For bitstrings P,Q and B=P·Q: (o1,o2,o3′,o4′)∈Ext_B iff ∃ x3,x4,x1′,x2′ such that (o1,o2,x3,x4)∈Ext_P, (x1′,x2′,o3′,o4′)∈Ext_Q, and (x4,x1′)∈E.
Why useful here.
- This gives a correct computable rule to derive the summary of concatenations solely from the two operand summaries and E; it is the backbone of our verifiers.
How it can fail.
- If one only composes right-projections R_P, R_Q via ∃m [(u,m)∈R_P ∧ (m,w)∈R_Q], one can admit pairs (u,w) that cannot be realized across the seam edge.
Quick counterexample.
- Σ_out={a,b,c}, A_0=A_1=Σ_out, E={a→b, b→c}. Let P=Q=‘00’ (length-2). Then (a,b)∈R_P, (b,c)∈R_Q, so ∃m=b yields (a,c) by naive composition. But no coloring of P·Q starts at a and ends at c (c has no outgoing edge), so (a,c)∉R_{P·Q}. Hence R-composition via ∃m is unsound; we must use Ext-concatenation.

Claim 4 — Deterministic enumeration of types and δ in single exponential time
Statement.
- Represent a type by its Ext-table (β^4 bits) and the boundary inputs (4 bits). Deterministically enumerate all reachable types via BFS on append transitions using Claim 1.
Pseudo-code.
- Seed S with all length-1,2,3,4 bitstrings (≤2+4+8+16=30) and compute Ext exactly.
- While queue nonempty: pop t∈S, for a∈{0,1}, compute Ext_{t·a} via base cases (if |t|<3) or Claim 1 (if |t|≥3); canonicalize (store boundary inputs and Ext_table); if new, add to S.
- Optionally store a fixed representative bitstring rep(τ) for each discovered type τ when first encountered, and record δ(τ,a).
Complexity.
- |Types| ≤ 16·2^{β^4} (r=1 bound). Each append costs O(β^5) to fill β^4 entries. Total deterministic time and space ≤ 2^{poly(N)}.
Why useful here.
- Provides the finite universe T, δ, and reps used by the NEXPTIME verifiers; no word-level (doubly-exponential) enumeration needed.
How it can fail.
- Equality testing of types must compare the full Ext-table and boundary-input bits; hashing collisions or partial comparisons can merge distinct types. Another pitfall: mishandling k<4 base cases.
Quick test.
- Trivial LCL with E complete, A_0=A_1=Σ_out: BFS closes quickly with only boundary-input distinction; δ just permutes those 16 classes.

Claim 5 — NEXPTIME (Ω(n) vs o(n)) with corrected verification
Witness.
- f: T × {0,1}^2 × T → Σ_out^2 (assign outputs to a 2-node separator S given left and right types).
Verification (for all t_a,t_b,t_c,t_d ∈ T and s1,s2 ∈ {0,1}^2):
- Let B = rep(t_b)·rep(t_c). Compute Ext_B from Ext_{rep(t_b)} and Ext_{rep(t_c)} via concatenation (Claim 3).
- Let α_L be the second output of f(t_a,s1,t_b); let α_R be the first output of f(t_c,s2,t_d). Check if ∃ (o1,o2,o3,o4) ∈ Ext_B with (α_L,o1)∈E, (o4,α_R)∈E, and per-node C_in–out holds on s1,s2 and edge inside each S.
Decision.
- If a guessed f passes all checks, classify as o(n); else Ω(n).
Why useful here.
- Corrected universal check avoids the unsound ∃m composition and is purely type-level, yielding a NEXPTIME separation.
How it can fail.
- Using only one representative per type is safe only if type replacement is valid. Lemma 10/11 (paper) ensures extendibility is type-invariant for boundary assignments on D1∪D2, which our Ext encoding captures.
Quick test.
- E complete, A_0=A_1=Σ_out: any f passes; output o(n). For E forcing equality (global constant), the check fails universally; output Ω(n).

Claim 6 — NEXPTIME (O(1) vs Ω(log* n)) via boundary interfaces with corrected checks
Witness.
- For each t∈T, guess pref2(t), suff2(t) ∈ Σ_out^2 (first two, last two outputs) and reuse/guess f as in Claim 5.
Checks.
- Per-type local consistency: (pref2,suff2) ∈ Ext_{rep(t)}; joinability: (suff2(t)[2], pref2(t)[1]) ∈ E.
- Bridging: For all t1,t2 and all separator types τ_S ∈ T ∪ {empty}:
  • Compute Ext_{rep(τ_S)}; check ∃ (o1,o2,o3,o4) ∈ Ext_{rep(τ_S)} with (suff2(t1)[2], o1)∈E and (o4, pref2(t2)[1])∈E (and also nodes of S satisfy C_in–out). This replaces any prior R-composition.
Decision.
- If all pass, classify as O(1); else Ω(log* n).
Why useful here.
- Compresses the constant-time witness to 2-node boundary interfaces and stitches blocks using Ext-level concatenation; matches Section 4.4–4.5 structure without enumerating long words.
How it can fail.
- If some LCL requires specifying interior outputs beyond boundary feasibility (radius>1), the witness is insufficient. Here r=1; local constraints only inspect neighbors, so boundary feasibility plus seam checks suffice.
Quick test.
- E equality: pick any c; set pref2=suff2=(c,c) for all t. All checks pass ⇒ O(1). For proper 2-coloring (E forbids equal adjacent): no per-type wrap-around (last-to-first) can be (x,y) with (y,x)∈E for a single block repeated; O(1) fails but log* passes via f.

Algorithmic summaries and complexity
- Preprocessing: compute T, δ, rep(t), and Ext_{rep(t)} for all t ∈ T in deterministic 2^{poly(N)} time/space.
- Stage 1 (Ω(n) vs o(n)): nondeterministically guess f (size |T|^2·4 entries), verify universally using concatenations → NEXPTIME.
- Stage 2 (O(1) vs Ω(log* n)): nondeterministically guess pref2/suff2 per type (size |T|), verify per-type and bridging constraints via Ext-tables → NEXPTIME.
- All universal iterations scale like |T|^{O(1)}=2^{poly(N)}; each Ext concatenation or append is poly(β)·β^{O(4)}; overall NEXPTIME.

Pseudocode sketch — compute Ext_{P·Q} from Ext_P, Ext_Q (Claim 3)
- Input: bit tables extP[x1][x2][x3][x4], extQ[y1][y2][y3][y4], adjacency E[u][v].
- Initialize extB all false.
- For all o1,o2,o3,o4 in Σ_out:
  • found ← false
  • For all x3,x4,x1p,x2p in Σ_out:
    – if extP[o1][o2][x3][x4] and extQ[x1p][x2p][o3][o4] and E[x4][x1p]: found ← true; break
  • if found: extB[o1][o2][o3][o4] ← true
- Return extB.

Sanity and toy checks
- δ sanity: β=2, E complete. Running append 3 times from k=1 must produce Ext equal to Σ_out^4 for k≥4; run-time shape invariant.
- Concatenation sanity: Use counterexample E={a→b, b→c}. Compute extB via Claim 3; verify that (a,c)∉R_{B} although present in R_P∘R_Q.
- Stage-1 sanity: trivial LCL (all allowed) ⇒ accept with any f; equality LCL (all outputs equal) ⇒ reject any f.
- Stage-2 sanity: equality LCL ⇒ accept with pref2=suff2=(c,c) for fixed c; proper 2-coloring ⇒ reject O(1) but accept log*.

What changed vs previous round
- Fixed δ with exact boundary indices and base cases; proved congruence.
- Replaced all uses of R-composition via ∃m by Ext-level concatenation; added explicit counterexample showing necessity.
- Provided explicit deterministic type-enumeration routine and clarified certificate verification steps and their complexity.


=== prover-02.out.json (progress_md) ===
## Round 0002 — 2025-08-27T11:52:16.710497Z

Mini-plan
- Repair and formalize the r=1 type DP: exact append-one-bit recurrence (including k<4 base cases), congruence (Type preserved under append), and concatenation at Ext-level.
- Replace all uses of R-composition via an intermediate output with explicit concatenation of Ext-tables; record a minimal counterexample showing why R-composition is unsound.
- Specify deterministic enumeration of all reachable types in exp time: state representation, δ update, reversal operator, and complexity bounds.
- Restate Stage-1 (Ω(n) vs o(n)) and Stage-2 (O(1) vs Ω(log* n)) NEXPTIME verifiers using only Ext-level concatenation; add precise verification conditions and pitfalls.
- Stress-test with toy LCLs (complete E, equality E, alternation E; mixed A_0/A_1) and sanity checks for base cases and reversal.

Context repairs from verifier feedback
- The δ update (append-one-bit) must be defined at the Ext-table level with correct boundary indexing; special care for k<4. I give exact formulas and a congruence lemma.
- Composition via R_t with an existential intermediate color m is unsound; replace by Ext-level concatenation (and only then project to R if needed). I provide a concrete 3-color counterexample and a corrected concatenation lemma.

1) r=1 summaries (Ext-tables) and exact DP
Notation: Σ_in={0,1}, Σ_out of size β, adjacency E⊆Σ_out×Σ_out, and per-input memberships A_0,A_1⊆Σ_out from C_in–out.
- For an input segment t of length k≥1, Ext_t ⊆ Σ_out^4 comprises the boundary quadruples (leftmost, second-from-left, second-from-right, rightmost) of all legal output colorings. For k<4 some positions coincide; we fix the boundary mapping:
  • k=1: B_1(c)=(c1,c1,c1,c1)
  • k=2: B_2(c)=(c1,c2,c1,c2)
  • k=3: B_3(c)=(c1,c2,c2,c3)
  • k≥4: B_k(c)=(c1,c2,c_{k-1},c_k)

Claim 1 (Append-one-bit recurrence; k≥3)
Statement. Let t be length k≥3 and a∈{0,1}. For every (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4)∈Ext_{t·a} ⇔ [x4∈A_a ∧ E(x3,x4) ∧ ∃z∈Σ_out: (x1,x2,z,x3)∈Ext_t].
Why useful here. It makes δ(Type,a) computable directly from Ext_t in O(β^5) time per append, avoiding string-level enumeration.
How it can fail. Misindexing x3 vs the old second-last and x4 vs the new last; or forgetting the k<4 cases, causing incorrect bases.
Quick test. Take β=2, A_0=A_1=Σ_out, E complete. Then Ext_t=Σ_out^4 for all t, and the RHS evaluates to true for all quadruples, so Ext_{t·a}=Σ_out^4, consistent.

Claim 2 (Base cases: k=1,2,3 updates)
Statement. Let t have length k∈{1,2,3}, a∈{0,1}.
- k=1, t=(b): (x1,x2,x3,x4)∈Ext_{t·a} iff x1=x3, x2=x4, x1∈A_b, x2∈A_a, and E(x1,x2).
- k=2, t=(b1,b2): (x1,x2,x3,x4)∈Ext_{t·a} iff x3=x2, x1∈A_{b1}, x2∈A_{b2}∩A_a, E(x1,x2), E(x2,x4).
- k=3, t=(b1,b2,b3): (x1,x2,x3,x4)∈Ext_{t·a} iff x1∈A_{b1}, x2∈A_{b2}, x3∈A_{b3}, x4∈A_a, and E(x1,x2), E(x2,x3), E(x3,x4).
Why useful here. These are the only special cases needed when seeding the DP from strings of length ≤3.
How it can fail. Forgetting that entries in Ext_t encode coordinate equalities when k<4; checking wrong membership set (e.g., using A_{b3} on x4).
Quick test. Let β=2, E={(a,a)} (self-loops at a only), A_b={a} for all b. For any t, Ext_t contains only quadruples with all entries a in the appropriate equality pattern. Each base-case update preserves this invariant.

Claim 3 (Congruence under append for r=1)
Statement. If Ext_P=Ext_Q then for every a∈{0,1} we have Ext_{P·a}=Ext_{Q·a}.
Why useful here. It justifies that δ on types is well-defined: the new Ext depends only on the old Ext and the appended bit.
Sketch proof. For k≥3 use Claim 1; for k<3 the base-case rules refer only to Ext_P (which determines k), A, and E; identical Ext tables imply identical updates.
How it can fail. If one accidentally lets δ depend on the concrete string beyond Ext (e.g., on interior inputs), congruence breaks; our recurrence avoids this.
Quick test. For β=3, pick random A,E; generate random P,Q of the same length with Ext_P=Ext_Q by construction (e.g., both trivial), and check Ext_{·a} equality by brute force on tiny β to sanity-check.

2) Concatenation and why R-composition is unsound
Claim 4 (Concatenation at Ext-level)
Statement. For any strings P,Q and B=P·Q, (o1,o2,o3′,o4′)∈Ext_B iff ∃x3,x4,x1′,x2′ s.t. (o1,o2,x3,x4)∈Ext_P, (x1′,x2′,o3′,o4′)∈Ext_Q, and E(x4,x1′).
Why useful here. All verifiers must use this to combine contexts; it is the sound way to merge summaries.
How it can fail. Omitting the seam edge E(x4,x1′) admits spurious quadruples.
Quick test. E complete ⇒ Ext_B is exactly the relational composition of Ext_P and Ext_Q over the shared inner pairs; the formula collapses to intuitive behavior; verified by brute force for tiny β.

Claim 5 (R-composition unsound; counterexample)
Statement. Let Σ_out={a,b,c}, A_0=A_1=Σ_out, E={a→b, b→c}. With P=Q=“00”:
- R_P contains (a,b); R_Q contains (b,c).
- Existentially composing R’s yields (a,c).
- But (a,c)∉R_{P·Q} because no 4-node coloring has both y1=a and y4=c.
Why useful here. It pinpoints the bug in the earlier verifier; we must build Ext_{P·Q} then (if desired) project to R.
How it can fail. If one believes ∃m composition is okay, this example breaks it; thus we must adhere to Ext-level concatenation.
Quick test. Manually enumerated above.

3) Deterministic enumeration of all reachable types (explicit algorithm)
Representation. A type is a pair (b_in, Ext) where b_in=(i1,i2,i3,i4)∈{0,1}^4 are the boundary inputs (first two and last two bits) and Ext⊆Σ_out^4 is the boundary-extendibility table. Two strings with identical pairs are the same type.

Claim 6 (Enumeration by closure under append)
Statement. We can deterministically enumerate the set T of all reachable types and the successor function δ: T×{0,1}→T in time 2^{poly(N)} where N=poly(β) is the encoding size.
Construction.
- Seed S with all strings of length k∈{1,2,3} (at most 2^3=8 strings) and also k=4 (2^4=16 strings) to avoid short-length corner cases. For each seed string s compute its (b_in(s), Ext_s) by brute force over Σ_out^k; insert into a dictionary keyed by (b_in, Ext).
- While queue nonempty: pop type τ=(b_in,Ext) with an associated length k (store k≥1 as metadata to apply base rules when k<3). For each a∈{0,1}:
  • Compute Ext′ from Ext and a using: base-case update if k<3; Claim 1 if k≥3.
  • Update the boundary inputs b_in′ by shifting right: new right pair is (old last input bit, a); left pair unchanged.
  • Let k′=k+1. If (b_in′,Ext′) unseen, insert new type with metadata k′ and enqueue.
- For δ, record the mapping from τ to τ′ for each a as transitions.
Complexity. |T|≤16·2^{β^4}; each append costs O(β^5) time to fill Ext′ (β^4 entries × ∃z over β). Total ≤ |T|·2·O(β^5)=2^{poly(N)} time/space.
Why useful here. This provides the finite state space and transitions we need for the verifiers without ranging over long strings.
How it can fail. If we forget to carry k for base cases, the first few transitions are wrong; also, b_in must be updated correctly or concatenation contexts may be mismatched later.
Quick test. With E complete and A_0=A_1=Σ_out, the construction stabilizes at the 16 possibilities of b_in with Ext≡Σ_out^4; δ maps each b_in to updating only the right two bits. BFS closes quickly as expected.

Claim 7 (Reversal operator on types)
Statement. Given τ=(b_in=(i1,i2,i3,i4), Ext), define Rev(τ)=(b_in^R=(i4,i3,i2,i1), Ext^R) where Ext^R={ (y1,y2,y3,y4): (y4,y3,y2,y1)∈Ext }.
Why useful here. Stage-1 feasibility allows labeling either S or its reverse; we need Rev to swap contexts cleanly.
How it can fail. Neglecting that the two-node boundary reverses as (R1,R2,L2,L1) at output level causes miswired checks.
Quick test. For symmetric E (undirected) and symmetric A, Ext=Ext^R for all τ; verify Rev(Rev(τ))=τ.

4) NEXPTIME verifiers (repaired): Ω(n) vs o(n)
We use types only through their Ext tables and boundary inputs; concatenations are performed with Claim 4.

Witness to guess. A table f: T×{0,1}^2×T → Σ_out^2, mapping (t_L, s_in, t_R) to the output pair on a 2-node separator S with input bits s_in (ordered left-to-right). Constraint: for all entries, f respects per-node membership (A) and E on the edge inside S.

Verification (for all quadruples t_a,t_b,t_c,t_d and s1,s2∈{0,1}^2):
1) Build Ext_B = Concat(Ext_{t_b}, Ext_{t_c}) via Claim 4. Also consider the four orientation choices for S1,S2 (original or reversed contexts). Let α_L be the right output on S1 (second component of f(t_a,s1,t_b) or of f^R depending on the chosen orientation), and α_R be the left output on S2 (first component accordingly).
2) Check ∃(o1,o2,o3,o4)∈Ext_B such that E(α_L,o1) and E(o4,α_R). Per-node A-constraints for S1,S2 are enforced directly on f when the witness is guessed.
If all checks pass, accept o(n) (hence Θ(log* n)); otherwise, conclude Ω(n).

Why useful here. This is exactly the feasible-function condition specialized to r=1 but implemented at the Ext-level. It avoids the unsound R-composition.
How it can fail. Two pitfalls:
- Forgetting orientation: must try both labeling S and labeling SR in the four combinations.
- Using only R-projections instead of Ext_B can admit spurious pairs (Claim 5 counterexample).
Quick test. (i) Trivial LCL: E complete, A unrestricted. Any f passes; we classify o(n). (ii) Secret-equality LCL (E equality only): any f that assigns same output on S works; checks pass ⇒ O(1) (indeed correct). (iii) Proper 2-coloring (E forbids equal): O(1) fails; this witness f exists but Stage-2 test will reject, leaving Θ(log* n), as expected on cycles.

5) NEXPTIME verifiers (repaired): O(1) vs Ω(log* n)
Witness to guess. For each t∈T, two 2-tuples: pref2(t)=(L1,L2), suff2(t)=(R2,R1) in Σ_out^2. Intuition: fixed boundary outputs for first two and last two positions of the block that (a) can be extended internally; (b) tile across repeated copies; (c) bridge via any feasible separator type.

Verification:
(a) Per-type tiling feasibility:
- Membership: L1∈A_{i1}, L2∈A_{i2}, R2∈A_{i3}, R1∈A_{i4}, where (i1,i2,i3,i4)=b_in(t).
- Edge checks: E(L1,L2), E(R2,R1), and wrap-around E(R1,L1) (so repeats of t can be tiled).
- Extendibility: (L1,L2,R2,R1)∈Ext_t.
(b) Bridging across any middle type t_S (including the empty middle):
- Compute Ext_bridge = Ext_{t_S} (empty S handled by directly checking E-edges).
- Let α_L:=suff2(t_left)[2] (the last output of the left block), α_R:=pref2(t_right)[1] (the first output of the right block).
- Require ∃(o1,o2,o3,o4)∈Ext_bridge with E(α_L,o1) and E(o4,α_R).
If all pass, accept O(1); else classify Ω(log* n).

Why useful here. Mirrors Section 4.4–4.5: constant-time solvability hinges on the ability to precommit to boundary interfaces that tile and bridge. All existential interior assignments are captured by Ext.
How it can fail. The chosen interface may be too restrictive; the check is universal over t_S, so witnesses must be carefully guessed. Another pitfall: forgetting E(R1,L1) (wrap-around) leads to falsely accepting non-tilable patterns.
Quick test. (i) E equality only, A unrestricted: choose c∈Σ_out and set all entries of pref2,suff2 to c. All checks pass ⇒ O(1). (ii) Proper 2-coloring: impossible to satisfy E(R1,L1) and E(L1,L2) with a period-1 interface consistently; checks fail ⇒ Ω(log* n), matching known results.

6) Complexity summary (conservative)
- Precompute T and δ: at most |T|≤16·2^{β^4} types; each append in O(β^5); total 2^{poly(N)} time/space.
- Concatenation: naive O(β^8) per pair. Precomputing Ext_{b⊙c} for all pairs (b,c)∈T^2 takes |T|^2·O(β^8)=2^{poly(N)} time.
- Stage-1 verification: iterate over |T|^4·4 orientation choices with O(1) lookups on precomputed Ext_{b⊙c}; total 2^{poly(N)}.
- Stage-2 verification: checks over |T| + |T|^2·(|T|+1) cases; each uses a constant number of Ext lookups; total 2^{poly(N)}.
Thus: a nondeterministic exponential-time (NEXPTIME) trichotomy decision.

7) Additional small examples and checks
- Mixed A_0,A_1. Let A_0={a}, A_1={b}, E={(a,b),(b,b)}. Intuitively, the rightmost outputs are forced by the input pattern; long-range coordination can’t help. Stage-1 likely rejects any f (seam constraints fail for adversarial separators), yielding Ω(n). Quick brute-force on tiny β confirms Ext shrinkage near seams.
- Reversal sanity. For any τ, Ext_{Rev(τ)} matches reversed Ext; concatenation with Rev(τ) is consistent: Concat(Ext_P,Ext_Q)^R = Concat(Ext_{Q}^R,Ext_{P}^R). Verified algebraically using Claim 4.

What remains open for polish
- A clean, fully self-contained proof that the boundary-interface witness (pref2,suff2) per type matches exactly the feasible-function definition in Section 4.4; I sketched the equivalence but will transcribe a full reduction argument.
- Micro-optimizations for concatenation (e.g., iterating seam colors first) are not needed for complexity, but I will outline a faster O(β^6) routine to keep constants reasonable.



=== Verifier (summary_md) ===
- What works
  - Ext-level concatenation lemma and algorithm are correct and essential; the R-composition counterexample is valid and nails the earlier bug.
  - Append-one-bit recurrence for k≥3 is correct; complexity bounds and type-space cap are reasonable.
  - Orientation/reversal operator is correctly defined and will help with symmetric checks.
- What fails or is risky
  - Base-case k=2→3 update is misstated (requires x4∈A_a; must not require x2∈A_a). Fix in prose, code, and TeX.
  - Congruence was stated too strongly (Ext equality). Make it a type-level lemma with an explicit k_flag.
  - BFS canonicalization must include k_flag; otherwise early δ transitions can be wrong.
- Next steps
  - Patch k=2 rule everywhere; add unit tests that isolate this case.
  - Redefine Type as (b_in, Ext, k_flag∈{1,2,3,≥4}); restate congruence and redo proofs accordingly.
  - Update enumeration pseudocode to key by the full Type; verify that once k_flag=≥4 it remains ≥4 thereafter.
  - Refactor verifiers to use a single Concat(Ext,Ext) routine; spell out orientation handling and the empty-middle case.
  - Build a toy-LCL test suite (self-loops, equality-only, proper 2-coloring, 3-symbol chain) to regression-test base cases and concatenation.

=== Verifier (verdict) ===
promising

=== Writer (status) ===
success

