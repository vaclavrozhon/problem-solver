--- SYSTEM ---
You are a strict mathematical verifier & research manager.

Tasks:
1) Audit correctness & rigor. Identify leaps, gaps, unjustified claims, likely false statements; produce the simplest counterexample or the minimal missing lemma.
2) Triage value. Separate genuine progress from noise.
3) Guide next steps. Suggest the next experiments/lemmas that most raise confidence.

Include a 3-row table:
| Claim (short) | Status [OK/Unclear/Broken] | Why |

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique for the prover (≥150 words)",
  "summary_md": "2–10 bullets for the human: what works, what fails, next steps",
  "verdict": "promising|uncertain|unlikely",
  "blocking_issues": []
}

--- USER ---
You receive multiple prover reports. Evaluate correctness, value, and pick promising directions. Optionally update notes and decide whether to call the writer.

Prover reports (JSON):
[{"prover_id": "01", "progress_md": "## Round 0002 \u2014 2025-08-27T11:52:16.707614Z\n\nMini-plan\n- Fix the r=1 append-one-bit DP (\u03b4) with precise boundary indexing, including all short-length base cases; prove the r=1 congruence lemma (Type(P)=Type(Q) \u21d2 Type(Pa)=Type(Qa)).\n- State and prove a clean concatenation lemma for Ext-tables; record and explain a minimal counterexample to show R-composition via \u2203m is unsound.\n- Give explicit pseudo-code for deterministic enumeration of all reachable types and \u03b4 transitions; include complexity bounds and memory footprint.\n- Rewrite the NEXPTIME verifiers to use Ext-level concatenation (not R-composition) in both stages: (i) \u03a9(n) vs o(n) via feasible-function f on type triples; (ii) O(1) vs \u03a9(log* n) via per-type boundary interfaces; bound witness sizes.\n- Stress-test with tiny \u03b2 examples; list failure modes and quick checks.\n\nContext alignment with verifier feedback\n- Addressed: (1) \u03b4 must be derived from an exact append-one-bit recurrence with correct boundary indices; (2) composition of binary right-projections R_t via an existential middle color is unsound; we now only use Ext-level concatenation then (optionally) project.\n\nClaim 1 \u2014 r=1 append-one-bit DP (\u03b4) with short-length base cases\nStatement.\n- For a segment t of length k, the Ext-table Ext_t \u2286 \u03a3_out^4 records boundary quadruples (L1,L2,R2,R1) that are extendible. The boundary map B_k(c) (from a full output c on t) is:\n  \u2022 k=1: (c1,c1,c1,c1)\n  \u2022 k=2: (c1,c2,c1,c2)\n  \u2022 k=3: (c1,c2,c2,c3)\n  \u2022 k\u22654: (c1,c2,ck\u22121,ck)\n- Base cases (explicit computation of Ext_t for k=1,2,3) follow immediately from C_in\u2013out and C_out\u2013out (enumerate allowed tuples consistent with single-edge constraints).\n- Append-one-bit (general case k\u22653): writing t\u2032=t\u00b7a for a\u2208{0,1}, for any (x1,x2,x3,x4)\u2208\u03a3_out^4,\n  (x1,x2,x3,x4)\u2208Ext_{t\u2032} iff [x4\u2208A_a, (x3,x4)\u2208E, and \u2203z s.t. (x1,x2,z,x3)\u2208Ext_t].\nWhy useful here.\n- This yields a correct \u03b4 update and an O(\u03b2^5) routine to compute Ext_{t\u00b7a} from Ext_t.\nHow it can fail.\n- Misindexing the new right-two: must be (old last, new). Using (new, ?) corrupts Ext_{t\u2032} for k\u22654. Base-case degeneracies (k<4) must be handled explicitly; otherwise \u03b4 may be ill-defined.\nQuick test.\n- \u03b2=2, E complete, A_0=A_1=\u03a3_out: Ext_t=\u03a3_out^4 for all t; \u03b4 preserves fullness. For \u03b2=2, E={(0,1)}, A_0=A_1=\u03a3_out: start from k=1 base, append twice; verify that Ext_{of length 3} contains exactly tuples with (x1,x2)=(0,1), (x2,x3)=(0,1).\n\nClaim 2 \u2014 r=1 congruence: equality of Ext preserved by append\nStatement.\n- If Ext_P = Ext_Q then for every a\u2208{0,1}, Ext_{P\u00b7a} = Ext_{Q\u00b7a}.\nWhy useful here.\n- This shows \u03b4 is well-defined on type classes (summaries): Type(P)=Type(Q) implies Type(Pa)=Type(Qa), enabling DFA exploration over types.\nHow it can fail.\n- If base cases k\u2208{1,2,3} are not incorporated into the update, two segments with equal Ext might be treated differently by an incorrect append rule.\nQuick test.\n- Construct P,Q of length 3 with identical Ext (e.g., under E complete). Append a=0; both yield identical Ext_{\u00b7a}; then prune E to break some adjacencies and recompute to observe preserved equality.\n\nClaim 3 \u2014 Concatenation lemma for Ext (and why R-composition via \u2203m is unsound)\nStatement.\n- For bitstrings P,Q and B=P\u00b7Q: (o1,o2,o3\u2032,o4\u2032)\u2208Ext_B iff \u2203 x3,x4,x1\u2032,x2\u2032 such that (o1,o2,x3,x4)\u2208Ext_P, (x1\u2032,x2\u2032,o3\u2032,o4\u2032)\u2208Ext_Q, and (x4,x1\u2032)\u2208E.\nWhy useful here.\n- This gives a correct computable rule to derive the summary of concatenations solely from the two operand summaries and E; it is the backbone of our verifiers.\nHow it can fail.\n- If one only composes right-projections R_P, R_Q via \u2203m [(u,m)\u2208R_P \u2227 (m,w)\u2208R_Q], one can admit pairs (u,w) that cannot be realized across the seam edge.\nQuick counterexample.\n- \u03a3_out={a,b,c}, A_0=A_1=\u03a3_out, E={a\u2192b, b\u2192c}. Let P=Q=\u201800\u2019 (length-2). Then (a,b)\u2208R_P, (b,c)\u2208R_Q, so \u2203m=b yields (a,c) by naive composition. But no coloring of P\u00b7Q starts at a and ends at c (c has no outgoing edge), so (a,c)\u2209R_{P\u00b7Q}. Hence R-composition via \u2203m is unsound; we must use Ext-concatenation.\n\nClaim 4 \u2014 Deterministic enumeration of types and \u03b4 in single exponential time\nStatement.\n- Represent a type by its Ext-table (\u03b2^4 bits) and the boundary inputs (4 bits). Deterministically enumerate all reachable types via BFS on append transitions using Claim 1.\nPseudo-code.\n- Seed S with all length-1,2,3,4 bitstrings (\u22642+4+8+16=30) and compute Ext exactly.\n- While queue nonempty: pop t\u2208S, for a\u2208{0,1}, compute Ext_{t\u00b7a} via base cases (if |t|<3) or Claim 1 (if |t|\u22653); canonicalize (store boundary inputs and Ext_table); if new, add to S.\n- Optionally store a fixed representative bitstring rep(\u03c4) for each discovered type \u03c4 when first encountered, and record \u03b4(\u03c4,a).\nComplexity.\n- |Types| \u2264 16\u00b72^{\u03b2^4} (r=1 bound). Each append costs O(\u03b2^5) to fill \u03b2^4 entries. Total deterministic time and space \u2264 2^{poly(N)}.\nWhy useful here.\n- Provides the finite universe T, \u03b4, and reps used by the NEXPTIME verifiers; no word-level (doubly-exponential) enumeration needed.\nHow it can fail.\n- Equality testing of types must compare the full Ext-table and boundary-input bits; hashing collisions or partial comparisons can merge distinct types. Another pitfall: mishandling k<4 base cases.\nQuick test.\n- Trivial LCL with E complete, A_0=A_1=\u03a3_out: BFS closes quickly with only boundary-input distinction; \u03b4 just permutes those 16 classes.\n\nClaim 5 \u2014 NEXPTIME (\u03a9(n) vs o(n)) with corrected verification\nWitness.\n- f: T \u00d7 {0,1}^2 \u00d7 T \u2192 \u03a3_out^2 (assign outputs to a 2-node separator S given left and right types).\nVerification (for all t_a,t_b,t_c,t_d \u2208 T and s1,s2 \u2208 {0,1}^2):\n- Let B = rep(t_b)\u00b7rep(t_c). Compute Ext_B from Ext_{rep(t_b)} and Ext_{rep(t_c)} via concatenation (Claim 3).\n- Let \u03b1_L be the second output of f(t_a,s1,t_b); let \u03b1_R be the first output of f(t_c,s2,t_d). Check if \u2203 (o1,o2,o3,o4) \u2208 Ext_B with (\u03b1_L,o1)\u2208E, (o4,\u03b1_R)\u2208E, and per-node C_in\u2013out holds on s1,s2 and edge inside each S.\nDecision.\n- If a guessed f passes all checks, classify as o(n); else \u03a9(n).\nWhy useful here.\n- Corrected universal check avoids the unsound \u2203m composition and is purely type-level, yielding a NEXPTIME separation.\nHow it can fail.\n- Using only one representative per type is safe only if type replacement is valid. Lemma 10/11 (paper) ensures extendibility is type-invariant for boundary assignments on D1\u222aD2, which our Ext encoding captures.\nQuick test.\n- E complete, A_0=A_1=\u03a3_out: any f passes; output o(n). For E forcing equality (global constant), the check fails universally; output \u03a9(n).\n\nClaim 6 \u2014 NEXPTIME (O(1) vs \u03a9(log* n)) via boundary interfaces with corrected checks\nWitness.\n- For each t\u2208T, guess pref2(t), suff2(t) \u2208 \u03a3_out^2 (first two, last two outputs) and reuse/guess f as in Claim 5.\nChecks.\n- Per-type local consistency: (pref2,suff2) \u2208 Ext_{rep(t)}; joinability: (suff2(t)[2], pref2(t)[1]) \u2208 E.\n- Bridging: For all t1,t2 and all separator types \u03c4_S \u2208 T \u222a {empty}:\n  \u2022 Compute Ext_{rep(\u03c4_S)}; check \u2203 (o1,o2,o3,o4) \u2208 Ext_{rep(\u03c4_S)} with (suff2(t1)[2], o1)\u2208E and (o4, pref2(t2)[1])\u2208E (and also nodes of S satisfy C_in\u2013out). This replaces any prior R-composition.\nDecision.\n- If all pass, classify as O(1); else \u03a9(log* n).\nWhy useful here.\n- Compresses the constant-time witness to 2-node boundary interfaces and stitches blocks using Ext-level concatenation; matches Section 4.4\u20134.5 structure without enumerating long words.\nHow it can fail.\n- If some LCL requires specifying interior outputs beyond boundary feasibility (radius>1), the witness is insufficient. Here r=1; local constraints only inspect neighbors, so boundary feasibility plus seam checks suffice.\nQuick test.\n- E equality: pick any c; set pref2=suff2=(c,c) for all t. All checks pass \u21d2 O(1). For proper 2-coloring (E forbids equal adjacent): no per-type wrap-around (last-to-first) can be (x,y) with (y,x)\u2208E for a single block repeated; O(1) fails but log* passes via f.\n\nAlgorithmic summaries and complexity\n- Preprocessing: compute T, \u03b4, rep(t), and Ext_{rep(t)} for all t \u2208 T in deterministic 2^{poly(N)} time/space.\n- Stage 1 (\u03a9(n) vs o(n)): nondeterministically guess f (size |T|^2\u00b74 entries), verify universally using concatenations \u2192 NEXPTIME.\n- Stage 2 (O(1) vs \u03a9(log* n)): nondeterministically guess pref2/suff2 per type (size |T|), verify per-type and bridging constraints via Ext-tables \u2192 NEXPTIME.\n- All universal iterations scale like |T|^{O(1)}=2^{poly(N)}; each Ext concatenation or append is poly(\u03b2)\u00b7\u03b2^{O(4)}; overall NEXPTIME.\n\nPseudocode sketch \u2014 compute Ext_{P\u00b7Q} from Ext_P, Ext_Q (Claim 3)\n- Input: bit tables extP[x1][x2][x3][x4], extQ[y1][y2][y3][y4], adjacency E[u][v].\n- Initialize extB all false.\n- For all o1,o2,o3,o4 in \u03a3_out:\n  \u2022 found \u2190 false\n  \u2022 For all x3,x4,x1p,x2p in \u03a3_out:\n    \u2013 if extP[o1][o2][x3][x4] and extQ[x1p][x2p][o3][o4] and E[x4][x1p]: found \u2190 true; break\n  \u2022 if found: extB[o1][o2][o3][o4] \u2190 true\n- Return extB.\n\nSanity and toy checks\n- \u03b4 sanity: \u03b2=2, E complete. Running append 3 times from k=1 must produce Ext equal to \u03a3_out^4 for k\u22654; run-time shape invariant.\n- Concatenation sanity: Use counterexample E={a\u2192b, b\u2192c}. Compute extB via Claim 3; verify that (a,c)\u2209R_{B} although present in R_P\u2218R_Q.\n- Stage-1 sanity: trivial LCL (all allowed) \u21d2 accept with any f; equality LCL (all outputs equal) \u21d2 reject any f.\n- Stage-2 sanity: equality LCL \u21d2 accept with pref2=suff2=(c,c) for fixed c; proper 2-coloring \u21d2 reject O(1) but accept log*.\n\nWhat changed vs previous round\n- Fixed \u03b4 with exact boundary indices and base cases; proved congruence.\n- Replaced all uses of R-composition via \u2203m by Ext-level concatenation; added explicit counterexample showing necessity.\n- Provided explicit deterministic type-enumeration routine and clarified certificate verification steps and their complexity.\n", "requests_for_more_materials": [], "next_actions_for_prover": ["Formalize and write a short proof that type replacement using Ext (our summaries) implies the exact Lemma 10/11 properties used by the verifiers; keep it radius-1 and oriented-path specific.", "Specify the exact canonicalization for types (boundary-input bits + Ext-table), including a compact hashing for equality checks, and quantify the exact constants in the 2^{poly(N)} bound.", "Implement (or further pseudo-code) the deterministic BFS to enumerate T and \u03b4 with careful handling of k<4 base cases; include unit tests for tiny \u03b2 with known E, A_0, A_1.", "Refactor Stage-1 and Stage-2 verification pseudo-code to call a single Ext-concatenation routine; add the reversal operator on types and summaries if we later extend to cycles.", "Write the rigorous argument that the boundary-interface witness (pref2/suff2) suffices for O(1) when r=1, following Section 4.4\u20134.5 of the paper but in our Ext notation; explicitly tie each step to an Ext or concatenation check.", "Construct a small library of adversarial toy LCLs (equality, proper 2-coloring, no-edges E, the 3-symbol chain example) and run through all checks by hand to catch any remaining indexing pitfalls."]}, {"prover_id": "02", "progress_md": "## Round 0002 \u2014 2025-08-27T11:52:16.710497Z\n\nMini-plan\n- Repair and formalize the r=1 type DP: exact append-one-bit recurrence (including k<4 base cases), congruence (Type preserved under append), and concatenation at Ext-level.\n- Replace all uses of R-composition via an intermediate output with explicit concatenation of Ext-tables; record a minimal counterexample showing why R-composition is unsound.\n- Specify deterministic enumeration of all reachable types in exp time: state representation, \u03b4 update, reversal operator, and complexity bounds.\n- Restate Stage-1 (\u03a9(n) vs o(n)) and Stage-2 (O(1) vs \u03a9(log* n)) NEXPTIME verifiers using only Ext-level concatenation; add precise verification conditions and pitfalls.\n- Stress-test with toy LCLs (complete E, equality E, alternation E; mixed A_0/A_1) and sanity checks for base cases and reversal.\n\nContext repairs from verifier feedback\n- The \u03b4 update (append-one-bit) must be defined at the Ext-table level with correct boundary indexing; special care for k<4. I give exact formulas and a congruence lemma.\n- Composition via R_t with an existential intermediate color m is unsound; replace by Ext-level concatenation (and only then project to R if needed). I provide a concrete 3-color counterexample and a corrected concatenation lemma.\n\n1) r=1 summaries (Ext-tables) and exact DP\nNotation: \u03a3_in={0,1}, \u03a3_out of size \u03b2, adjacency E\u2286\u03a3_out\u00d7\u03a3_out, and per-input memberships A_0,A_1\u2286\u03a3_out from C_in\u2013out.\n- For an input segment t of length k\u22651, Ext_t \u2286 \u03a3_out^4 comprises the boundary quadruples (leftmost, second-from-left, second-from-right, rightmost) of all legal output colorings. For k<4 some positions coincide; we fix the boundary mapping:\n  \u2022 k=1: B_1(c)=(c1,c1,c1,c1)\n  \u2022 k=2: B_2(c)=(c1,c2,c1,c2)\n  \u2022 k=3: B_3(c)=(c1,c2,c2,c3)\n  \u2022 k\u22654: B_k(c)=(c1,c2,c_{k-1},c_k)\n\nClaim 1 (Append-one-bit recurrence; k\u22653)\nStatement. Let t be length k\u22653 and a\u2208{0,1}. For every (x1,x2,x3,x4)\u2208\u03a3_out^4,\n  (x1,x2,x3,x4)\u2208Ext_{t\u00b7a} \u21d4 [x4\u2208A_a \u2227 E(x3,x4) \u2227 \u2203z\u2208\u03a3_out: (x1,x2,z,x3)\u2208Ext_t].\nWhy useful here. It makes \u03b4(Type,a) computable directly from Ext_t in O(\u03b2^5) time per append, avoiding string-level enumeration.\nHow it can fail. Misindexing x3 vs the old second-last and x4 vs the new last; or forgetting the k<4 cases, causing incorrect bases.\nQuick test. Take \u03b2=2, A_0=A_1=\u03a3_out, E complete. Then Ext_t=\u03a3_out^4 for all t, and the RHS evaluates to true for all quadruples, so Ext_{t\u00b7a}=\u03a3_out^4, consistent.\n\nClaim 2 (Base cases: k=1,2,3 updates)\nStatement. Let t have length k\u2208{1,2,3}, a\u2208{0,1}.\n- k=1, t=(b): (x1,x2,x3,x4)\u2208Ext_{t\u00b7a} iff x1=x3, x2=x4, x1\u2208A_b, x2\u2208A_a, and E(x1,x2).\n- k=2, t=(b1,b2): (x1,x2,x3,x4)\u2208Ext_{t\u00b7a} iff x3=x2, x1\u2208A_{b1}, x2\u2208A_{b2}\u2229A_a, E(x1,x2), E(x2,x4).\n- k=3, t=(b1,b2,b3): (x1,x2,x3,x4)\u2208Ext_{t\u00b7a} iff x1\u2208A_{b1}, x2\u2208A_{b2}, x3\u2208A_{b3}, x4\u2208A_a, and E(x1,x2), E(x2,x3), E(x3,x4).\nWhy useful here. These are the only special cases needed when seeding the DP from strings of length \u22643.\nHow it can fail. Forgetting that entries in Ext_t encode coordinate equalities when k<4; checking wrong membership set (e.g., using A_{b3} on x4).\nQuick test. Let \u03b2=2, E={(a,a)} (self-loops at a only), A_b={a} for all b. For any t, Ext_t contains only quadruples with all entries a in the appropriate equality pattern. Each base-case update preserves this invariant.\n\nClaim 3 (Congruence under append for r=1)\nStatement. If Ext_P=Ext_Q then for every a\u2208{0,1} we have Ext_{P\u00b7a}=Ext_{Q\u00b7a}.\nWhy useful here. It justifies that \u03b4 on types is well-defined: the new Ext depends only on the old Ext and the appended bit.\nSketch proof. For k\u22653 use Claim 1; for k<3 the base-case rules refer only to Ext_P (which determines k), A, and E; identical Ext tables imply identical updates.\nHow it can fail. If one accidentally lets \u03b4 depend on the concrete string beyond Ext (e.g., on interior inputs), congruence breaks; our recurrence avoids this.\nQuick test. For \u03b2=3, pick random A,E; generate random P,Q of the same length with Ext_P=Ext_Q by construction (e.g., both trivial), and check Ext_{\u00b7a} equality by brute force on tiny \u03b2 to sanity-check.\n\n2) Concatenation and why R-composition is unsound\nClaim 4 (Concatenation at Ext-level)\nStatement. For any strings P,Q and B=P\u00b7Q, (o1,o2,o3\u2032,o4\u2032)\u2208Ext_B iff \u2203x3,x4,x1\u2032,x2\u2032 s.t. (o1,o2,x3,x4)\u2208Ext_P, (x1\u2032,x2\u2032,o3\u2032,o4\u2032)\u2208Ext_Q, and E(x4,x1\u2032).\nWhy useful here. All verifiers must use this to combine contexts; it is the sound way to merge summaries.\nHow it can fail. Omitting the seam edge E(x4,x1\u2032) admits spurious quadruples.\nQuick test. E complete \u21d2 Ext_B is exactly the relational composition of Ext_P and Ext_Q over the shared inner pairs; the formula collapses to intuitive behavior; verified by brute force for tiny \u03b2.\n\nClaim 5 (R-composition unsound; counterexample)\nStatement. Let \u03a3_out={a,b,c}, A_0=A_1=\u03a3_out, E={a\u2192b, b\u2192c}. With P=Q=\u201c00\u201d:\n- R_P contains (a,b); R_Q contains (b,c).\n- Existentially composing R\u2019s yields (a,c).\n- But (a,c)\u2209R_{P\u00b7Q} because no 4-node coloring has both y1=a and y4=c.\nWhy useful here. It pinpoints the bug in the earlier verifier; we must build Ext_{P\u00b7Q} then (if desired) project to R.\nHow it can fail. If one believes \u2203m composition is okay, this example breaks it; thus we must adhere to Ext-level concatenation.\nQuick test. Manually enumerated above.\n\n3) Deterministic enumeration of all reachable types (explicit algorithm)\nRepresentation. A type is a pair (b_in, Ext) where b_in=(i1,i2,i3,i4)\u2208{0,1}^4 are the boundary inputs (first two and last two bits) and Ext\u2286\u03a3_out^4 is the boundary-extendibility table. Two strings with identical pairs are the same type.\n\nClaim 6 (Enumeration by closure under append)\nStatement. We can deterministically enumerate the set T of all reachable types and the successor function \u03b4: T\u00d7{0,1}\u2192T in time 2^{poly(N)} where N=poly(\u03b2) is the encoding size.\nConstruction.\n- Seed S with all strings of length k\u2208{1,2,3} (at most 2^3=8 strings) and also k=4 (2^4=16 strings) to avoid short-length corner cases. For each seed string s compute its (b_in(s), Ext_s) by brute force over \u03a3_out^k; insert into a dictionary keyed by (b_in, Ext).\n- While queue nonempty: pop type \u03c4=(b_in,Ext) with an associated length k (store k\u22651 as metadata to apply base rules when k<3). For each a\u2208{0,1}:\n  \u2022 Compute Ext\u2032 from Ext and a using: base-case update if k<3; Claim 1 if k\u22653.\n  \u2022 Update the boundary inputs b_in\u2032 by shifting right: new right pair is (old last input bit, a); left pair unchanged.\n  \u2022 Let k\u2032=k+1. If (b_in\u2032,Ext\u2032) unseen, insert new type with metadata k\u2032 and enqueue.\n- For \u03b4, record the mapping from \u03c4 to \u03c4\u2032 for each a as transitions.\nComplexity. |T|\u226416\u00b72^{\u03b2^4}; each append costs O(\u03b2^5) time to fill Ext\u2032 (\u03b2^4 entries \u00d7 \u2203z over \u03b2). Total \u2264 |T|\u00b72\u00b7O(\u03b2^5)=2^{poly(N)} time/space.\nWhy useful here. This provides the finite state space and transitions we need for the verifiers without ranging over long strings.\nHow it can fail. If we forget to carry k for base cases, the first few transitions are wrong; also, b_in must be updated correctly or concatenation contexts may be mismatched later.\nQuick test. With E complete and A_0=A_1=\u03a3_out, the construction stabilizes at the 16 possibilities of b_in with Ext\u2261\u03a3_out^4; \u03b4 maps each b_in to updating only the right two bits. BFS closes quickly as expected.\n\nClaim 7 (Reversal operator on types)\nStatement. Given \u03c4=(b_in=(i1,i2,i3,i4), Ext), define Rev(\u03c4)=(b_in^R=(i4,i3,i2,i1), Ext^R) where Ext^R={ (y1,y2,y3,y4): (y4,y3,y2,y1)\u2208Ext }.\nWhy useful here. Stage-1 feasibility allows labeling either S or its reverse; we need Rev to swap contexts cleanly.\nHow it can fail. Neglecting that the two-node boundary reverses as (R1,R2,L2,L1) at output level causes miswired checks.\nQuick test. For symmetric E (undirected) and symmetric A, Ext=Ext^R for all \u03c4; verify Rev(Rev(\u03c4))=\u03c4.\n\n4) NEXPTIME verifiers (repaired): \u03a9(n) vs o(n)\nWe use types only through their Ext tables and boundary inputs; concatenations are performed with Claim 4.\n\nWitness to guess. A table f: T\u00d7{0,1}^2\u00d7T \u2192 \u03a3_out^2, mapping (t_L, s_in, t_R) to the output pair on a 2-node separator S with input bits s_in (ordered left-to-right). Constraint: for all entries, f respects per-node membership (A) and E on the edge inside S.\n\nVerification (for all quadruples t_a,t_b,t_c,t_d and s1,s2\u2208{0,1}^2):\n1) Build Ext_B = Concat(Ext_{t_b}, Ext_{t_c}) via Claim 4. Also consider the four orientation choices for S1,S2 (original or reversed contexts). Let \u03b1_L be the right output on S1 (second component of f(t_a,s1,t_b) or of f^R depending on the chosen orientation), and \u03b1_R be the left output on S2 (first component accordingly).\n2) Check \u2203(o1,o2,o3,o4)\u2208Ext_B such that E(\u03b1_L,o1) and E(o4,\u03b1_R). Per-node A-constraints for S1,S2 are enforced directly on f when the witness is guessed.\nIf all checks pass, accept o(n) (hence \u0398(log* n)); otherwise, conclude \u03a9(n).\n\nWhy useful here. This is exactly the feasible-function condition specialized to r=1 but implemented at the Ext-level. It avoids the unsound R-composition.\nHow it can fail. Two pitfalls:\n- Forgetting orientation: must try both labeling S and labeling SR in the four combinations.\n- Using only R-projections instead of Ext_B can admit spurious pairs (Claim 5 counterexample).\nQuick test. (i) Trivial LCL: E complete, A unrestricted. Any f passes; we classify o(n). (ii) Secret-equality LCL (E equality only): any f that assigns same output on S works; checks pass \u21d2 O(1) (indeed correct). (iii) Proper 2-coloring (E forbids equal): O(1) fails; this witness f exists but Stage-2 test will reject, leaving \u0398(log* n), as expected on cycles.\n\n5) NEXPTIME verifiers (repaired): O(1) vs \u03a9(log* n)\nWitness to guess. For each t\u2208T, two 2-tuples: pref2(t)=(L1,L2), suff2(t)=(R2,R1) in \u03a3_out^2. Intuition: fixed boundary outputs for first two and last two positions of the block that (a) can be extended internally; (b) tile across repeated copies; (c) bridge via any feasible separator type.\n\nVerification:\n(a) Per-type tiling feasibility:\n- Membership: L1\u2208A_{i1}, L2\u2208A_{i2}, R2\u2208A_{i3}, R1\u2208A_{i4}, where (i1,i2,i3,i4)=b_in(t).\n- Edge checks: E(L1,L2), E(R2,R1), and wrap-around E(R1,L1) (so repeats of t can be tiled).\n- Extendibility: (L1,L2,R2,R1)\u2208Ext_t.\n(b) Bridging across any middle type t_S (including the empty middle):\n- Compute Ext_bridge = Ext_{t_S} (empty S handled by directly checking E-edges).\n- Let \u03b1_L:=suff2(t_left)[2] (the last output of the left block), \u03b1_R:=pref2(t_right)[1] (the first output of the right block).\n- Require \u2203(o1,o2,o3,o4)\u2208Ext_bridge with E(\u03b1_L,o1) and E(o4,\u03b1_R).\nIf all pass, accept O(1); else classify \u03a9(log* n).\n\nWhy useful here. Mirrors Section 4.4\u20134.5: constant-time solvability hinges on the ability to precommit to boundary interfaces that tile and bridge. All existential interior assignments are captured by Ext.\nHow it can fail. The chosen interface may be too restrictive; the check is universal over t_S, so witnesses must be carefully guessed. Another pitfall: forgetting E(R1,L1) (wrap-around) leads to falsely accepting non-tilable patterns.\nQuick test. (i) E equality only, A unrestricted: choose c\u2208\u03a3_out and set all entries of pref2,suff2 to c. All checks pass \u21d2 O(1). (ii) Proper 2-coloring: impossible to satisfy E(R1,L1) and E(L1,L2) with a period-1 interface consistently; checks fail \u21d2 \u03a9(log* n), matching known results.\n\n6) Complexity summary (conservative)\n- Precompute T and \u03b4: at most |T|\u226416\u00b72^{\u03b2^4} types; each append in O(\u03b2^5); total 2^{poly(N)} time/space.\n- Concatenation: naive O(\u03b2^8) per pair. Precomputing Ext_{b\u2299c} for all pairs (b,c)\u2208T^2 takes |T|^2\u00b7O(\u03b2^8)=2^{poly(N)} time.\n- Stage-1 verification: iterate over |T|^4\u00b74 orientation choices with O(1) lookups on precomputed Ext_{b\u2299c}; total 2^{poly(N)}.\n- Stage-2 verification: checks over |T| + |T|^2\u00b7(|T|+1) cases; each uses a constant number of Ext lookups; total 2^{poly(N)}.\nThus: a nondeterministic exponential-time (NEXPTIME) trichotomy decision.\n\n7) Additional small examples and checks\n- Mixed A_0,A_1. Let A_0={a}, A_1={b}, E={(a,b),(b,b)}. Intuitively, the rightmost outputs are forced by the input pattern; long-range coordination can\u2019t help. Stage-1 likely rejects any f (seam constraints fail for adversarial separators), yielding \u03a9(n). Quick brute-force on tiny \u03b2 confirms Ext shrinkage near seams.\n- Reversal sanity. For any \u03c4, Ext_{Rev(\u03c4)} matches reversed Ext; concatenation with Rev(\u03c4) is consistent: Concat(Ext_P,Ext_Q)^R = Concat(Ext_{Q}^R,Ext_{P}^R). Verified algebraically using Claim 4.\n\nWhat remains open for polish\n- A clean, fully self-contained proof that the boundary-interface witness (pref2,suff2) per type matches exactly the feasible-function definition in Section 4.4; I sketched the equivalence but will transcribe a full reduction argument.\n- Micro-optimizations for concatenation (e.g., iterating seam colors first) are not needed for complexity, but I will outline a faster O(\u03b2^6) routine to keep constants reasonable.\n\n", "requests_for_more_materials": [], "next_actions_for_prover": ["Write the formal proof (step-by-step) of the r=1 congruence lemma (Claim 3) including the k<4 base cases, to have a standalone correctness reference for \u03b4.", "Specify the exact type representation used in code: (b_in, Ext, k_flag) with k_flag\u2208{1,2,3,\u22654}, and give precise pseudocode for the BFS enumeration and \u03b4 computation.", "Formalize and prove the reversal operator correctness (Rev) and its interaction with concatenation: Concat(P,Q)^R = Concat(Q^R,P^R).", "Refactor Stage-1 and Stage-2 verifier descriptions into precise algorithms with inputs/outputs and assert they run in 2^{poly(N)} time; include explicit handling of the empty middle S in Stage-2.", "Prove rigorously that the boundary-interface witness (pref2,suff2) suffices for O(1) (i.e., from any feasible function f, build such an interface; from such an interface, reconstruct the Section 4.5 algorithm).", "Prepare a small battery of automated tests on toy LCLs (\u03b2\u22643) to exercise base-case updates, append recurrence, concatenation, reversal, and both verifiers; include the R-composition counterexample as a regression test.", "If time permits, design a precomputation of Ext_{b\u2299c} for all (b,c) that reduces the naive O(\u03b2^8) to O(\u03b2^6) using sparse adjacency and marginal indices; document the data structures."]}]

Current notes.md:
Corrections and key lemmas to record

1) Correct append-one-bit recurrence (r=1)
Given a type t with Ext_t ⊆ Σ_out^4 over boundary (L1,L2,R2,R1) and an appended input bit a, the new type t′ has boundary (L1′,L2′,R2′,R1′) = (L1,L2, old R1, new), i.e., R2′ = R1 and R1′ is the label of the appended node. Formally, for each candidate quadruple (x1,x2,x3,x4) ∈ Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [x4 ∈ A_a and E(x3,x4) and ∃ z ∈ Σ_out: (x1,x2,z,x3) ∈ Ext_t].
This yields an O(β^5) DP to fill Ext_{t′} by scanning all (x1,x2,x3,x4) and checking ∃z.

Congruence lemma (needed): If Type(P)=Type(Q), then for all a ∈ {0,1}, Type(Pa)=Type(Qa). Proof sketch: The predicate “there exists an interior completion consistent with boundary assignments” over D1∪D2 is preserved under appending one node by the above DP rule, which depends only on Ext_t and a.

2) Concatenation of summaries (r=1)
If Summ(P) has Ext_P and Summ(Q) has Ext_Q, then the concatenation B=P·Q has boundary (P.left endpoint, P.left neighbor, Q.right neighbor, Q.right endpoint) and
  (o1,o2,o3′,o4′) ∈ Ext_B ⇔ ∃ x3,x4,x1′,x2′ ∈ Σ_out: (o1,o2,x3,x4) ∈ Ext_P, (x1′,x2′,o3′,o4′) ∈ Ext_Q, and E(x4,x1′).
Then R_B can be derived from Ext_B as usual.

3) Counterexample to R-composition via ∃m
Let Σ_out={a,b,c}, A_0=A_1=Σ_out. Let E={a→b, b→c} only. Suppose t_b admits a boundary tuple with right endpoint a, and t_c admits a boundary tuple with left endpoint c (interiors arbitrary but extendible). Then choose m=b. We have (x,m) ∈ R_{t_b} for any x with a valid left edge, and (m,y) ∈ R_{t_c} for suitable y. But the concatenation t_b·t_c requires the seam edge a→c, which is forbidden. Hence ∃m composition of R_t is not sound; use Ext-level concatenation and R_B instead.

Current outputs.tex (if any):
% outputs.tex
\documentclass[11pt]{article}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{fullpage}
\usepackage{microtype}
\usepackage{enumitem}

\newcommand{\sigin}{\Sigma_{\mathrm{in}}}
\newcommand{\sigout}{\Sigma_{\mathrm{out}}}
\newcommand{\Aset}{\mathcal{A}}
\newcommand{\Erel}{\mathcal{E}}
\newcommand{\Ext}{\mathrm{Ext}}
\newcommand{\rep}{\mathrm{rep}}
\newcommand{\len}{\lvert\cdot\rvert}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\theoremstyle{plain}
\newtheorem{lemma}[definition]{Lemma}
\newtheorem{theorem}[definition]{Theorem}
\newtheorem{proposition}[definition]{Proposition}
\newtheorem{corollary}[definition]{Corollary}
\theoremstyle{remark}
\newtheorem{remark}[definition]{Remark}

\title{r=1: precise append-one-bit DP, congruence and concatenation lemmas, and a small counterexample}
\author{(formalization of corrections from notes)}
\date{}

\begin{document}
\maketitle

\begin{abstract}
This note records precise, fully rigorous statements and proofs for the following items that were identified as corrections in the informal notes: (1) the exact append-one-bit dynamic-programming recurrence for the radius-$1$ summaries ("r=1"), including the full boundary indexing and the base cases for short segments (length $k<4$); and the congruence lemma stating that equality of types is preserved under appending a bit; (2) a clean concatenation lemma for Ext-tables (the summary objects used for $r=1$), with proof; (3) a succinct counterexample showing that composing binary relations derived from summaries via an existential intermediate color can be unsound; (4) a revised description of the Stage-1 verifier (and the corresponding Stage-2 checks) that uses concatenation at the Ext-table level rather than composing the two-element relations; and (5) a short complexity remark: we keep claims at the coarse NEXPTIME level unless a deterministic solver is supplied.
\end{abstract}

\section{Preliminaries and notation}

Fix finite alphabets
\[\sigin = \{0,1\},\qquad \sigout\]
and a binary relation (adjacency) \(\Erel\subseteq\sigout\times\sigout\). For each input bit $a\in\sigin$ let $A_a\subseteq\sigout$ be the set of output symbols allowed at a node whose input bit equals $a$ (we allow the natural special case $A_0=A_1=\sigout$). We use $\beta:=|\sigout|$.

A (finite) input segment (bitstring) is $t=t_1t_2\cdots t_k\in\sigin^{k}$ with $k\ge 1$; write $|t|=k$. An \emph{output coloring} of $t$ is a tuple $c=(c_1,\dots,c_k)\in\sigout^{k}$ satisfying the local constraints
\[c_i\in A_{t_i}\quad(1\le i\le k),\qquad\text{and}\qquad (c_i,c_{i+1})\in\Erel\quad(1\le i<k).
\]

For radius $r=1$ we record a summary ("Ext-table") for a segment by the colors that can appear on the two leftmost and two rightmost positions of the segment. The mapping from a full coloring $c$ to its boundary quadruple depends on the segment length $k$ because for short segments some of the positions coincide; we formalize this below.

\begin{definition}[boundary quadruple B_k(c)]\label{def:boundary}
Let $t$ have length $k\ge1$ and let $c=(c_1,\dots,c_k)$ be a coloring of $t$.
Define the boundary quadruple $B_k(c)=(x_1,x_2,x_3,x_4)\in\sigout^4$ by
\begin{align*}
B_k(c) &= (c_1,c_1,c_1,c_1) &&\text{if }k=1,\\
B_k(c) &= (c_1,c_2,c_1,c_2) &&\text{if }k=2,\\
B_k(c) &= (c_1,c_2,c_2,c_3) &&\text{if }k=3,\\
B_k(c) &= (c_1,c_2,c_{k-1},c_k) &&\text{if }k\ge 4.
\end{align*}
(Thus the quadruple reads ``leftmost, second-from-left, second-from-right, rightmost'', with obvious coincidences when $k<4$.)
\end{definition}

\begin{definition}[Ext-table]
For a bitstring $t$ of length $k\ge1$ define
\[\Ext_t\;:=\;\{\;B_k(c)\;:\;c\text{ is an output coloring of }t\;\}\;\subseteq\;\sigout^4.
\]
\end{definition}

Intuitively $\Ext_t$ records exactly which assignments to the four boundary positions are extendible to a full coloring of the interior of $t$; for long segments ($k\ge4$) the four positions are distinct.

We will also use, for any set $S\subseteq\sigout^4$, the projections
\begin{align*}
\mathrm{L}(S) &:= \{(x_1,x_2)\;:\;\exists x_3,x_4,\; (x_1,x_2,x_3,x_4)\in S\},\\
\mathrm{R}(S) &:= \{(x_3,x_4)\;:\;\exists x_1,x_2,\; (x_1,x_2,x_3,x_4)\in S\}.
\end{align*}
For a segment $t$ we abbreviate $\mathrm{R}(\Ext_t)$ by $R_t$ when convenient; this is the set of rightmost pairs that can occur for $t$.

\section{Append-one-bit recurrence and the r=1 congruence lemma}

We first give the elementary base cases for short segments and then the general recurrence for appending a single input bit (the "append-one-bit" DP step). After that we state and prove the congruence lemma (equality of types is preserved by appending a bit).

\subsection{Base cases ($k<4$)}

Let $t$ be a bitstring of length $k\in\{1,2,3\}$. By Definition~\ref{def:boundary} the set $\Ext_t$ has an explicit characterization in terms of small tuples:

\begin{itemize}[leftmargin=*]
\item (\emph{Length 1}) If $t=(a)$ then
\[\Ext_t=\{(x,x,x,x)\in\sigout^4:\; x\in A_a\}.\]
\item (\emph{Length 2}) If $t=(a_1,a_2)$ then
\[\Ext_t=\{(x_1,x_2,x_1,x_2)\in\sigout^4:\; x_1\in A_{a_1},\; x_2\in A_{a_2},\; (x_1,x_2)\in\Erel\}.
\]
\item (\emph{Length 3}) If $t=(a_1,a_2,a_3)$ then
\[\Ext_t=\{(x_1,x_2,x_2,x_3)\in\sigout^4:\; x_i\in A_{a_i}\ (i=1,2,3),\; (x_1,x_2)\in\Erel,\; (x_2,x_3)\in\Erel\}.
\]
\end{itemize}

These are immediate from the definition of $B_k(c)$ and from the local adjacency constraints that define a legal coloring.

\subsection{Append-one-bit recurrence (general case $|t|\ge3$)}

Let $t$ be a bitstring of length $k\ge 3$ and let $a\in\sigin$ be a single input bit. Put $t' := t\cdot a$ (appending $a$ on the right). Then $t'$ has length $k+1\ge 4$, so a candidate boundary quadruple for $t'$ is of the form $(x_1,x_2,x_3,x_4)$ with the usual interpretation.

\begin{proposition}[append-one-bit recurrence for $k\ge3$]\label{prop:append}
With the notation above, for every $(x_1,x_2,x_3,x_4)\in\sigout^4$ we have
\begin{equation}\label{eq:append-recurrence}
(x_1,x_2,x_3,x_4)\in\Ext_{t'}\quad\Longleftrightarrow\quad x_4\in A_a\;\text{ and }\; (x_3,x_4)\in\Erel\;\text{ and }\;\exists z\in\sigout:\ (x_1,x_2,z,x_3)\in\Ext_t.
\end{equation}
Consequently, given $\Ext_t$ (as a boolean table indexed by $\sigout^4$) one can compute $\Ext_{t'}$ by iterating over all $\beta^4$ candidate quadruples and testing existence of $z$, yielding a naive running time $O(\beta^5)$ for this single append step.
\end{proposition}

\begin{proof}
(=>) Suppose $(x_1,x_2,x_3,x_4)\in\Ext_{t'}$. By definition there exists a coloring $c_1,\dots,c_{k+1}$ of $t'$ such that $B_{k+1}(c)= (x_1,x_2,x_3,x_4)$. Since $k+1\ge 4$ the positions in $B_{k+1}$ are the true positions $1,2,k,k+1$, hence $c_1=x_1$, $c_2=x_2$, $c_k=x_3$, $c_{k+1}=x_4$. From the coloring constraints we get $c_{k+1}\in A_a$ and $(c_k,c_{k+1})=(x_3,x_4)\in\Erel$. Removing the last node yields a coloring $c_1,\dots,c_k$ of $t$, and letting $z:=c_{k-1}$ we have $(x_1,x_2,z,x_3)\in\Ext_t$. This proves the left-to-right implication.

(<=) Conversely suppose $x_4\in A_a$, $(x_3,x_4)\in\Erel$, and there exists $z\in\sigout$ with $(x_1,x_2,z,x_3)\in\Ext_t$. By definition of $\Ext_t$ there exists a coloring $c_1,\dots,c_k$ of $t$ with $c_1=x_1,c_2=x_2,c_{k-1}=z,c_k=x_3$. Appending the color $c_{k+1}:=x_4$ yields a coloring $c_1,\dots,c_{k+1}$ of $t'$ (by $x_4\in A_a$ and $(x_3,x_4)\in\Erel$), and the boundary quadruple of this coloring is $(x_1,x_2,x_3,x_4)$ because $k+1\ge 4$. Hence $(x_1,x_2,x_3,x_4)\in\Ext_{t'}$.

The asymptotic cost statement is immediate from the recurrence: evaluating the right-hand side of (\ref{eq:append-recurrence}) for every $\beta^4$-many quadruples costs $O(\beta)$ to check the existential over $z$ in the naive implementation, hence $O(\beta^5)$ time per append.
\end{proof}

\subsection{Append-one-bit: the $k<4$ cases}

When $|t|<4$ the quadruples in $\Ext_t$ encode coinciding positions, therefore the recurrence in Proposition~\ref{prop:append} must be replaced by the appropriate base-case to get a correct algorithm that builds up from length~1. We spell these out as constructive update rules that compute $\Ext_{t'}$ from $\Ext_t$ when $|t|=1,2,3$.

Let $t$ have length $k\in\{1,2,3\}$ and let $t'=t\cdot a$.

\begin{itemize}[leftmargin=*]
\item If $k=1$ then $t=(b)$ for some $b\in\sigin$. Using the characterization above we have
\[\Ext_t=\{(x,x,x,x):x\in A_b\}.
\]
Hence $t'$ has length 2 and
\[(x_1,x_2,x_3,x_4)\in\Ext_{t'}\iff x_1=x_3,\; x_2=x_4,\; x_1\in A_b,\; x_2\in A_a,\; (x_1,x_2)\in\Erel.
\]
(Operationally: enumerate $x_1,x_2$ with $(x_1,x_2)\in\Erel$, check $x_1\in A_b$ and $x_2\in A_a$, and add the quadruple $(x_1,x_2,x_1,x_2)$.)

\item If $k=2$ then $t=(b_1,b_2)$, and $\Ext_t$ consists of tuples $(x_1,x_2,x_1,x_2)$ with adjacency $ (x_1,x_2)\in\Erel$ and membership $x_i\in A_{b_i}$. The appened string $t'$ has length $3$, and
\[(x_1,x_2,x_3,x_4)\in\Ext_{t'}\iff x_3=x_2,\; x_1\in A_{b_1},\; x_2\in A_{b_2}\cap A_a,\; (x_1,x_2)\in\Erel,\; (x_2,x_4)\in\Erel.
\]
(Equivalently, set $c_1=x_1,c_2=x_2,c_3=x_4$ and check the two edges and membership.)

\item If $k=3$ then $t=(b_1,b_2,b_3)$ and $\Ext_t$ has tuples of the form $(x_1,x_2,x_2,x_3)$ satisfying the two edges $(x_1,x_2)$ and $(x_2,x_3)$. Appending $a$ produces length $4$, and the characterization is
\[(x_1,x_2,x_3,x_4)\in\Ext_{t'}\iff x_1\in A_{b_1},\; x_2\in A_{b_2},\; x_3\in A_{b_3},\; x_4\in A_a,\; (x_1,x_2)\in\Erel,\; (x_2,x_3)\in\Erel,\; (x_3,x_4)\in\Erel.
\]
\end{itemize}

These formulas are the only special cases one needs when implementing a forward DP that starts from single-bit segments and builds up by repeated appends: for $k\ge3$ use Proposition~\ref{prop:append}, and for $k\in\{1,2,3\}$ use the explicit checks above.

\subsection{Congruence lemma (r=1)}

We now state and prove the congruence property that was needed in the notes: if two segments have identical Ext-tables then appending the same input bit to both yields identical Ext-tables again.

\begin{lemma}[r=1 congruence lemma]\label{lem:congruence}
Let $P,Q$ be two bitstrings and suppose $\Ext_P=\Ext_Q$. Then for every bit $a\in\sigin$ we have
\[\Ext_{P\cdot a}=\Ext_{Q\cdot a}.\]
In particular, equality of the $r=1$ summaries (Ext-tables) is preserved by appending a single input bit.
\end{lemma}

\begin{proof}
The proof is a simple case analysis using the append-one-bit rules.

If $|P|\ge 3$ then the formula in Proposition~\ref{prop:append} expresses membership in $\Ext_{P\cdot a}$ purely in terms of membership in $\Ext_P$, the sets $A_a$, and the adjacency relation $\Erel$; the same formula holds for $Q$ because $|Q|$ must be equal to $|P|$ whenever $\Ext_P=\Ext_Q$ (indeed the pattern of coincidences in quadruples for short lengths is visible in the table itself). Thus the right-hand side of (\ref{eq:append-recurrence}) is identical for $P$ and $Q$, which yields $\Ext_{P\cdot a}=\Ext_{Q\cdot a}$.

If $|P|<3$ then both $P$ and $Q$ must have the same length (because their Ext-tables record the equality patterns of the coordinates: e.g. membership of tuples of the form $(x,x,x,x)$ witnesses $k=1$, etc.). In each of the finite cases $k=1,2,3$ the explicit base-case update rules given above determine $\Ext_{\cdot a}$ from $\Ext_{\cdot}$ using only membership tests that depend on $\Ext_P$ and the fixed parameters $A_a,\Erel$. Since $\Ext_P=\Ext_Q$ the resulting computations yield the same set. This finishes the proof.
\end{proof}

\section{Concatenation lemma for Ext-tables}

Concatenation is the other fundamental operation we need. We give a clean statement that directly tells how to compute $\Ext_{P\cdot Q}$ from $\Ext_P$ and $\Ext_Q$ (no intermediate projection to binary relations is needed or used). The statement is valid for all lengths $|P|,|Q|\ge 1$; the proof is a straightforward gluing argument.

\begin{lemma}[concatenation lemma for Ext-tables]\label{lem:concat}
Let $P$ and $Q$ be bitstrings of lengths $m, n\ge1$, respectively, and let $B:=P\cdot Q$ be their concatenation (length $m+n$). Then for any $(o_1,o_2,o_3',o_4')\in\sigout^4$ we have
\begin{multline}\label{eq:concat}
(o_1,o_2,o_3',o_4')\in\Ext_B\\\iff\exists\;x_3,x_4,x_1',x_2'\in\sigout\;:\; (o_1,o_2,x_3,x_4)\in\Ext_P,\; (x_1',x_2',o_3',o_4')\in\Ext_Q,\;\text{and }(x_4,x_1')\in\Erel.
\end{multline}
In words: a boundary quadruple appears for the concatenation exactly when there exist matching interior boundary pairs for the left and right factors whose seam colors are adjacent.
\end{lemma}

\begin{proof}
(=>) Suppose $(o_1,o_2,o_3',o_4')\in\Ext_B$. Then by definition there exists a coloring $c_1,\dots,c_{m+n}$ of $B$ whose boundary quadruple (according to Definition~\ref{def:boundary} with length $m+n$) equals $(o_1,o_2,o_3',o_4')$. Restrict the coloring to the left factor $P$ to obtain $c_1,\dots,c_m$, and to the right factor $Q$ (with renumbering) to obtain $c_{m+1},\dots,c_{m+n}$. Let
\[x_3:=c_{\max(1,m-1)},\quad x_4:=c_m,\quad x_1':=c_{m+1},\quad x_2':=c_{\min(m+2,m+n)}
\]
(so that the four symbols $x_3,x_4,x_1',x_2'$ are precisely the two rightmost symbols of $P$ and the two leftmost symbols of $Q$, with the appropriate coincidences for short factors). By construction $(o_1,o_2,x_3,x_4)\in\Ext_P$ and $(x_1',x_2',o_3',o_4')\in\Ext_Q$. Finally the adjacency across the seam is $(x_4,x_1')=(c_m,c_{m+1})\in\Erel$ because the coloring of $B$ satisfied all adjacent-edge constraints. This proves the forward implication.

(<=) Conversely, assume there exist $x_3,x_4,x_1',x_2'$ as in the right-hand side of (\ref{eq:concat}). By $(o_1,o_2,x_3,x_4)\in\Ext_P$ there exists a coloring $p_1,\dots,p_m$ of $P$ whose left/right boundary pattern matches $(o_1,o_2,x_3,x_4)$. Likewise from $(x_1',x_2',o_3',o_4')\in\Ext_Q$ there exists a coloring $q_1,\dots,q_n$ of $Q$ whose left/right boundary pattern matches $(x_1',x_2',o_3',o_4')$. The assumed seam adjacency $(x_4,x_1')\in\Erel$ guarantees that the two colorings can be glued along the seam edge between positions $m$ and $m+1$: define a coloring of $B$ by
\[c_i := p_i\ (1\le i\le m),\qquad c_{m+j} := q_j\ (1\le j\le n).
\]
The adjacency conditions inside $P$ and inside $Q$ are satisfied by $p$ and $q$; the single new adjacency to check is $(c_m,c_{m+1})=(x_4,x_1')$, which holds by hypothesis. Therefore $c_1,\dots,c_{m+n}$ is a legal coloring of $B$ whose boundary quadruple equals $(o_1,o_2,o_3',o_4')$, whence $(o_1,o_2,o_3',o_4')\in\Ext_B$. This completes the proof of the equivalence.
\end{proof}

\begin{remark}
Note that the existential quantification ranges only over four symbols from $\sigout$; a naive implementation of (\ref{eq:concat}) would therefore take time $O(\beta^8)$ to produce the full $\Ext_B$ table by trying all $(o_1,o_2,o_3',o_4')$ and all witnesses $x_3,x_4,x_1',x_2'$. In practice one can do significantly better (e.g. by iterating witnesses $x_4,x_1'$ first and using precomputed adjacency lists) but the point for correctness is that concatenation is computable entirely from the two operand Ext-tables and the adjacency $\Erel$.
\end{remark}

\section{Why composing $R_t$ via an existential intermediate color is unsound (a short counterexample)}

It is tempting to try to speed up concatenation by passing to the binary projection $R_t=\mathrm{R}(\Ext_t)$ (the rightmost pair) and to define the right-projection of a concatenation by composing these binary relations via an existential intermediate color $m\in\sigout$, i.e.
\[R_{P\cdot Q}?=\{(u,w):\exists m\in\sigout,\; (u,m)\in R_P\;\text{and}\;(m,w)\in R_Q\}.
\]
We give a brief counterexample showing this is unsound in general: the right-projection of the concatenation can be strictly smaller than the projection obtained by composing the $R$-relations in the above way.

\begin{proposition}[counterexample]\label{prop:counter}
Let $\sigout=\{a,b,c\}$, $A_0=A_1=\sigout$, and let the adjacency relation be
\[\Erel=\{(a,b),(b,c)\}.
\]
Let $P$ and $Q$ both be the two-bit segment $\mathtt{00}$ (length~2). Then
\begin{itemize}
\item $R_P$ contains the pair $(a,b)$ (witnessing the extension $a\!\mapsto b$ on the two nodes of $P$), and $R_Q$ contains the pair $(b,c)$.
\item Hence the existential composition yields the pair $(a,c)$ via the intermediate color $m=b$.
\item However $(a,c)\notin R_{P\cdot Q}$, i.e. there is no extension of the length-4 segment $P\cdot Q$ whose rightmost coordinate is $c$ while the leftmost coordinate is $a$; consequently the composition above is unsound.
\end{itemize}
\end{proposition}

\begin{proof}
For $P=\mathtt{00}$ (two bits) a legal coloring is a pair $(x_1,x_2)\in\sigout^2$ with $(x_1,x_2)\in\Erel$. Thus $\Ext_P$ contains tuples of the form $(x_1,x_2,x_1,x_2)$ exactly when $(x_1,x_2)\in\Erel$. In particular $(a,b,a,b)\in\Ext_P$, so $R_P$ contains the rightmost pair $(a,b)$. Similarly $(b,c,b,c)\in\Ext_Q$ so $R_Q$ contains $(b,c)$.

The existential composition of $R_P$ and $R_Q$ therefore contains $(a,c)$ because there exists $m=b$ with $(a,b)\in R_P$ and $(b,c)\in R_Q$.

But consider the concatenation $B:=P\cdot Q$, which has length $4$. A coloring of $B$ is a tuple $(y_1,y_2,y_3,y_4)$ with $(y_1,y_2),(y_2,y_3),(y_3,y_4)\in\Erel$. If $y_1=a$ then the only possibility for $y_2$ is $b$ (because the only outgoing edge from $a$ is to $b$). Then $y_3$ must be $c$ (because the only outgoing edge from $b$ is to $c$). But there is no outgoing edge from $c$ in $\Erel$, so there is no symbol $y_4$ with $(y_3,y_4)=(c,y_4)\in\Erel$. Consequently there is no coloring of $B$ with $y_1=a$ and $y_4=c$; hence $(a,c)$ does not occur as the rightmost pair in any entry of $\Ext_B$. That is, $(a,c)\notin R_{P\cdot Q}$, completing the counterexample.
\end{proof}

This simple example illustrates that projecting summaries (here to $R_t$) and then composing those projections by existentially quantifying over a single intermediate color may produce spurious pairs: the existential witness $m$ might be realized in different global extensions of the two factors that are incompatible at the seam. The correct (sound) operation is concatenation at the Ext-table level (Lemma~\ref{lem:concat}) which enforces seam adjacency while keeping the two-sided context.

\section{Rewriting the verifier specification: use concatenation, not $R$-composition}

Below we give a concise, explicit rewrite of the Stage-1 verifier specification (and the corresponding Stage-2 checks) so that every place that previously composed $R$-relations via an existential intermediate color is replaced by a concatenation of Ext-tables followed by a projection to $R$ if needed.

The description below is intentionally modular and abstract (it operates on the certificate objects the prover supplies). It is stated so that it is immediately implementable using the formulas in Lemma~\ref{lem:concat} and Proposition~\ref{prop:append}.

\subsection*{Inputs to the verifier}

The verifier receives (from the prover/certificate) the following finite objects:
\begin{itemize}[leftmargin=*]
\item A finite set $\mathcal{R}$ of representative bitstrings (the claimed representatives of the finitely many types used by the proof). Each $\rho\in\mathcal{R}$ is a bitstring in $\sigin^*$.
\item For each representative $\rho\in\mathcal{R}$ a table $\Ext^{\mathrm{cert}}_{\rho}\subseteq\sigout^4$ claimed to equal the true $\Ext_{\rho}$.
\item A finite set of claims (rules) of the form "the concatenation of representatives $\rho_b,\rho_c$ has representative $\rho_{bc}$"; for each such claim the certificate may also furnish (or one can derive) the asserted relation $R^{\mathrm{cert}}_{\rho_{bc}}:=\mathrm{R}(\Ext^{\mathrm{cert}}_{\rho_{bc}})$ if that is part of the witnessed invariant in the original scheme.
\end{itemize}

The verifier's job is to check that the supplied Ext-tables are self-consistent and closed under the operations (append, concatenation) required by the scheme. It performs the following checks.

\subsection*{Stage-1 verifier (using concatenation)}\label{sec:stage1}

For every asserted concatenation claim $(\rho_b,\rho_c,\rho_{bc})$ do the following checks:

\begin{enumerate}[leftmargin=*]
\item Let $P:=\rho_b$ and $Q:=\rho_c$, and compute the candidate concatenation table
\[\Ext^{\mathrm{comp}}_{P\cdot Q} := \{\; (o_1,o_2,o_3',o_4')\in\sigout^4:\;\exists x_3,x_4,x_1',x_2'\in\sigout\ \text{s.t.}\ (o_1,o_2,x_3,x_4)\in\Ext^{\mathrm{cert}}_{P},\ (x_1',x_2',o_3',o_4')\in\Ext^{\mathrm{cert}}_{Q},\ (x_4,x_1')\in\Erel\;\}.
\]
(Use the formula of Lemma~\ref{lem:concat}.)

\item Compute the projected right relation
\[R^{\mathrm{comp}}_{P\cdot Q} := \mathrm{R}(\Ext^{\mathrm{comp}}_{P\cdot Q}).\]

\item Verify that the certificate's claimed representative $\rho_{bc}$ satisfies
\[R^{\mathrm{cert}}_{\rho_{bc}} = R^{\mathrm{comp}}_{P\cdot Q}\qquad\text{and}\qquad \Ext^{\mathrm{cert}}_{\rho_{bc}} = \Ext^{\mathrm{comp}}_{P\cdot Q}\] if the certificate supplies $\Ext^{\mathrm{cert}}_{\rho_{bc}}$ explicitly. (At minimum the verifier must check that the representative's stored relation/table agrees with the one computed by concatenation; checking equality of the full Ext-tables is sound and recommended.)
\end{enumerate}

Remarks:
\begin{itemize}[leftmargin=*]
\item The crucial change compared to the earlier, unsound specification is that the verifier \emph{does not} compute $R^{\mathrm{comp}}_{P\cdot Q}$ simply as $\{(u,w):\exists m,\,(u,m)\in R^{\mathrm{cert}}_P\land(m,w)\in R^{\mathrm{cert}}_Q\}$. Instead the verifier constructs the full $\Ext$-table by concatenation and only then projects to $R$.
\item If the certificate does not explicitly supply $\Ext^{\mathrm{cert}}_{\rho_{bc}}$ but does claim the representative $\rho_{bc}$, the verifier may still compute $\Ext^{\mathrm{comp}}_{P\cdot Q}$ and check that $R^{\mathrm{comp}}_{P\cdot Q}$ equals the stored $R^{\mathrm{cert}}_{\rho_{bc}}$. This is sufficient to guarantee that the claimed representative behaves correctly as far as the right projection is concerned.
\end{itemize}

\subsection*{Adjustments in Stage-2 checks}

Any Stage-2 check that previously reasoned about the compatibility of two representatives by composing their $R$-relations must be replaced by the corresponding check that computes the concatenation Ext-table and then performs the required membership or projection tests on $\Ext^{\mathrm{comp}}_{P\cdot Q}$. Concretely, whenever the verifier earlier intended to test
\[\exists m\in\sigout:\ (u,m)\in R_P\land(m,w)\in R_Q
\]
it should instead test (by computing $\Ext^{\mathrm{comp}}_{P\cdot Q}$) whether there exists a quadruple in $\Ext^{\mathrm{comp}}_{P\cdot Q}$ whose left projection matches the left context (as required) and whose right projection produces the desired $(u,w)$ outcome; equivalently, test membership in $R^{\mathrm{comp}}_{P\cdot Q}$.

This substitution is sound by Lemma~\ref{lem:concat} and avoids the spurious pairs that may be produced by existentially composing $R$-relations alone (see Proposition~\ref{prop:counter}).

\section{Complexity remark}

We refrain from attempting a tighter complexity analysis in this note. The elementary operations on Ext-tables that we used above have the following simple size bounds:
\begin{itemize}[leftmargin=*]
\item Each $\Ext_t$ is a subset of $\sigout^4$ and hence can be represented in size $O(\beta^4)$. The projections $R_t$ and $L_t$ have size $O(\beta^2)$.
\item The naive append-one-bit step (Proposition~\ref{prop:append}) takes $O(\beta^5)$ time in the worst case per append when implemented by brute-force enumeration of all quadruples and the existential witness.
\item The naive concatenation step (Lemma~\ref{lem:concat}) can be implemented by checking all $\beta^4$ candidate output quadruples and, for each, all $\beta^4$ possible witnesses $x_3,x_4,x_1',x_2'$, hence $O(\beta^8)$ time in the worst-case with a fully naive method; modest algorithmic improvements reduce this significantly in practice (for instance by iterating seam colors $x_4,x_1'$ first and using lookups), but we do not rely on such micro-optimizations here.
\end{itemize}

Because the verifier is supplied with a (potentially exponentially large) nondeterministic certificate of representatives and Ext-tables, and because checking the correctness of the certificate requires the potentially expensive concatenation operations above, the natural coarse-grained upper bound to assert without further assumptions is NEXPTIME: a nondeterministic verifier can guess the certificate and then perform the table computations and equality checks in time exponential in the size of the original problem description. If, however, a deterministic (polynomial-time, or otherwise bounded-time) solver for the small constraint checks is provided as an oracle, the complexity claims can be made correspondingly stronger; in this note we intentionally keep the complexity statement at the NEXPTIME level since no such deterministic subroutine is assumed.

\section{Conclusion}

We summarized and proved the corrected append-one-bit recurrence (including the full $k<4$ base cases), proved the r=1 congruence lemma, gave a clean concatenation lemma for Ext-tables, displayed a simple counterexample showing that composing $R$-relations via an existential intermediate color is unsound, and rewrote the Stage-1 verifier specification (and the Stage-2 checks) so that concatenation at the Ext-table level is used in place of the unsound $R$-composition. The small explicit counterexample (Section~\ref{prop:counter}) demonstrates why the change is necessary in any implementation or formal verification of the scheme.

\medskip

\noindent\textbf{Acknowledgements.} This document formalizes and expands the corrections recorded in the informal notes supplied with the task.

\end{document}

