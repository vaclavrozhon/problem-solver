- What works
  - Ext-level concatenation lemma and algorithm are correct and essential; the R-composition counterexample is valid and nails the earlier bug.
  - Append-one-bit recurrence for k≥3 is correct; complexity bounds and type-space cap are reasonable.
  - Orientation/reversal operator is correctly defined and will help with symmetric checks.
- What fails or is risky
  - Base-case k=2→3 update is misstated (requires x4∈A_a; must not require x2∈A_a). Fix in prose, code, and TeX.
  - Congruence was stated too strongly (Ext equality). Make it a type-level lemma with an explicit k_flag.
  - BFS canonicalization must include k_flag; otherwise early δ transitions can be wrong.
- Next steps
  - Patch k=2 rule everywhere; add unit tests that isolate this case.
  - Redefine Type as (b_in, Ext, k_flag∈{1,2,3,≥4}); restate congruence and redo proofs accordingly.
  - Update enumeration pseudocode to key by the full Type; verify that once k_flag=≥4 it remains ≥4 thereafter.
  - Refactor verifiers to use a single Concat(Ext,Ext) routine; spell out orientation handling and the empty-middle case.
  - Build a toy-LCL test suite (self-loops, equality-only, proper 2-coloring, 3-symbol chain) to regression-test base cases and concatenation.
