{
  "progress_md": "Ideas \u2014 fill the remaining gaps and make the verifier fully type-level and auditable\n- Gap 1 (in outputs.pdf): Stage-1 (\u03a9(n) vs o(n)) is only sketched as a \u201cverifier specification\u201d for Ext closure/concatenation, but the core \u201cfeasible-function existence\u201d check that separates o(n) from \u03a9(n) is not formalized. Action: state a precise type-level feasible-function test using Ext-concatenation (no R-composition), prove soundness/completeness to the paper\u2019s feasible function, and give explicit complexity bounds.\n- Gap 2: Stage-2 (O(1) vs \u03a9(log* n)) appears only in a short \u201cadjustments\u201d paragraph. Action: formalize the boundary-interface witness per type, specify the universal checks using Ext, show it implies an O(1)-round construction (mirroring Lemmas 26\u201327 of the paper), and that failure implies \u03a9(log* n).\n- Optimization: record a faster concatenation subroutine (from O(\u03b2^8) down to O(\u03b2^6)) by rearranging the 4-way existential join and precomputing seam-indexed slices. Not needed for NEXPTIME, but improves constants and clarifies feasibility.\n\nPreliminaries to reuse\n- Ext-tables, k-flag, append-one-bit DP, and Ext-level concatenation (Lemma 3.1 in outputs.pdf) are OK and will be our only composition primitive. The counterexample shows R-composition is unsound; we never use it directly.\n- Deterministic enumeration of Types: use Type(t)=(Ext_t, k_flag(t)) or Type(t)=(bin(t), Ext_t, k_flag(t)) as in outputs.pdf. For our purposes, Ext+k_flag suffices for \u03b4 and concatenation; bin(t) is harmless redundancy. BFS from k=1 using the base cases and Proposition 2.1 yields T and \u03b4 in 2^{poly(N)} time.\n\nStage-1 (\u03a9(n) vs o(n)) \u2014 feasible function at the type level\nDefinition (feasible f specialized to r=1, oriented paths).\n- Precompute T and, for each \u03c4\u2208T, its Ext_\u03c4. For two types \u03c4,\u03c3 define Ext_{\u03c4\u2299\u03c3} via Ext-level concatenation (outputs.pdf Lemma 3.1 applied to Ext_\u03c4 and Ext_\u03c3).\n- A feasible function is a table f: T \u00d7 {0,1}^2 \u00d7 T \u2192 \u03a3_out^2 such that for all triples (\u03c4_L, s\u2208{0,1}^2, \u03c4_R):\n  (i) Node constraints on S (length-2 window): if f(\u03c4_L,s,\u03c4_R)=(\u03b11,\u03b12), then \u03b1i \u2208 A_{s[i]} and E(\u03b11,\u03b12) holds.\n  (ii) Universal extendibility across two separators: for all \u03c4_a,\u03c4_b,\u03c4_c,\u03c4_d \u2208 T and s1,s2 \u2208 {0,1}^2, letting\n      \u03b1_L := second component of f(\u03c4_a,s1,\u03c4_b) and \u03b1_R := first component of f(\u03c4_c,s2,\u03c4_d),\n      we require \u2203 (o1,o2,o3,o4) \u2208 Ext_{\u03c4_b \u2299 \u03c4_c} with E(\u03b1_L,o1) and E(o4,\u03b1_R).\nAlgorithm (NEXPTIME verification).\n- Deterministically compute T and all Ext_\u03c4 and Ext_{\u03c4\u2299\u03c3} (or compute Ext_{\u03c4\u2299\u03c3} on demand and cache).\n- Nondeterministically guess f. Verify (i) for all entries, and verify (ii) for all |T|^4 \u00b7 4 cases by membership in Ext_{\u03c4_b \u2299 \u03c4_c} and two E checks.\nCorrectness (why this matches the paper\u2019s feasible function):\n- \u201cOnly if\u201d: If an o(n)-round algorithm exists, the paper\u2019s Lemma 18 produces a feasible f on windows of length 2 using pumped contexts of length in [\u2113_pump,\u2113_pump+1]. Replacing concrete words by types is valid: Ext_{w_b \u2299 w_c} depends only on Type(w_b),Type(w_c) via Lemma 3.1 and Lemma 11; hence the type-level condition is necessary.\n- \u201cIf\u201d: Given f as above, the paper\u2019s Lemma 17 construction goes through verbatim, because every time the proof needs to fill the middle B, the existence check is exactly the Ext_{\u03c4_b \u2299 \u03c4_c} membership with the seam constraints E(\u03b1_L,\u00b7) and E(\u00b7,\u03b1_R). Thus a type-level f implies o(n) (indeed O(log* n)). (No reversal is needed on globally oriented paths.)\nComplexity: |T| \u2264 2^{poly(N)}, each Ext-table has size \u03b2^4, Ext_{\u03c4\u2299\u03c3} computable in \u03b2^{O(1)} time; universal verification costs 2^{poly(N)}. The guess has size 2^{poly(N)}.\n\nStage-2 (O(1) vs \u03a9(log* n)) \u2014 per-type boundary interface witness\nWitness per type \u03c4\u2208T: a quadruple Q_\u03c4=(L1_\u03c4,L2_\u03c4,R2_\u03c4,R1_\u03c4) intended to be the first two and last two outputs of any long block of type \u03c4.\nChecks.\n(a) Per-type local feasibility and tiling:\n  - (L1_\u03c4,L2_\u03c4,R2_\u03c4,R1_\u03c4) \u2208 Ext_\u03c4; E(L1_\u03c4,L2_\u03c4) and E(R2_\u03c4,R1_\u03c4) (redundant if Ext_\u03c4 computed from legal colorings, but we keep it explicit); wrap-around E(R1_\u03c4,L1_\u03c4) to tile \u03c4 by copies.\n(b) Bridging across any middle type \u03c4_S (including S empty):\n  - For all \u03c4_left,\u03c4_right \u2208 T and all \u03c4_S \u2208 T, require \u2203 (o1,o2,o3,o4) \u2208 Ext_{\u03c4_S} with E(R1_{\u03c4_left}, o1) and E(o4, L1_{\u03c4_right}).\n  - For S empty (no middle): just check E(R1_{\u03c4_left}, L1_{\u03c4_right}).\nDecision: if the checks pass, classify O(1); else, if Stage-1 feasible f exists, classify \u0398(log* n); otherwise \u0398(n).\nCorrectness sketch.\n- \u201cO(1) if witness exists\u201d: Use the partition framework of Section 4.3 of the paper (Lemmas 21\u201322) directly on the globally oriented path (orientation is already given); choose constants \u2113_width=\u2113_pattern=\u2113_pump and \u2113_count=2\u2113_pump+2r. On each long repetitive path P with primitive pattern having type \u03c4, tile P by copies of \u03c4 using E(R1_\u03c4,L1_\u03c4); this ensures all interior nodes are locally consistent by Ext_\u03c4. The remaining short separators S have types \u03c4_S and can be filled by (b) since Ext_{\u03c4_S} guarantees existence of a completion consistent with the boundary colors. This is the path-analogue of Lemmas 26\u201327, with Ext replacing word enumeration; all uses of extendibility are discharged by Ext-membership.\n- \u201c\u03a9(log* n) if witness fails but Stage-1 feasible f exists\u201d: This matches the sublinear-but-not-constant regime as in the paper.\n- \u201c\u03a9(n) if Stage-1 fails\u201d: No feasible f \u21d2 o(n) impossible (paper\u2019s Theorem 8). Our type-level test is equivalent by the argument under Stage-1.\nComplexity: guessing Q_\u03c4 for all \u03c4 is 2^{poly(N)} bits; the universal checks over T\u00d7T\u00d7(T\u222a{\u2205}) use only a constant number of Ext lookups and E-checks per triple, so 2^{poly(N)} time.\n\nFaster concatenation (optional speed-up; same asymptotics)\nObservation: Ext_{B} membership for (o1,o2,o3\u2032,o4\u2032) reduces to the existence of seam colors x4,x1\u2032 with E(x4,x1\u2032) and of inner witnesses x3,x2\u2032 such that (o1,o2,x3,x4)\u2208Ext_P and (x1\u2032,x2\u2032,o3\u2032,o4\u2032)\u2208Ext_Q. Precompute, per \u03c4, the two 3D slices\n  Left_\u03c4[o1,o2,x4] := \u2203x3 (o1,o2,x3,x4)\u2208Ext_\u03c4,\n  Right_\u03c4[x1\u2032,o3\u2032,o4\u2032] := \u2203x2\u2032 (x1\u2032,x2\u2032,o3\u2032,o4\u2032)\u2208Ext_\u03c4.\nThen (o1,o2,o3\u2032,o4\u2032)\u2208Ext_{\u03c4\u2299\u03c3} iff \u2203x4,x1\u2032 with Left_\u03c4[o1,o2,x4] \u2227 E(x4,x1\u2032) \u2227 Right_\u03c3[x1\u2032,o3\u2032,o4\u2032]. This computes all of Ext_{\u03c4\u2299\u03c3} in O(\u03b2^6) time after O(\u03b2^4) precomputation per type for the 3D slices.\n\nExamples/sanity checks\n- Trivial LCL: A_0=A_1=\u03a3_out, E complete. Ext_\u03c4=\u03a3_out^4 for all \u03c4. Stage-2 witness exists immediately with any constant color c \u21d2 O(1). Stage-1 also passes.\n- Equality LCL: A_0=A_1=\u03a3_out, E={(x,x)}. Stage-2 succeeds with Q_\u03c4=(c,c,c,c) \u2200\u03c4; O(1). Stage-1 is also fine.\n- Proper 2-coloring: A_0=A_1={a,b}, E forbids equal neighbors. No Q_\u03c4 can satisfy both E(L1_\u03c4,L2_\u03c4) and wrap E(R1_\u03c4,L1_\u03c4) with a period-1 boundary that works across all \u03c4_S, so Stage-2 fails; Stage-1 feasible f exists (alternation across separators), yielding \u0398(log* n).\n- Hard/linear case (e.g., mixed A_0,A_1 with incompatible E across seams): Stage-1 fails \u21d2 \u03a9(n).\n\nNotes on endpoints and orientation\n- Globally oriented paths do not require reversal cases (unlike undirected cycles). Our checks are oriented left-to-right. Endpoints need no special seam constraints: the local constraints on the first/last nodes are just membership in A_{input}, and all our fillings ensure E-constraints along existing edges; there is no predecessor edge for the first node nor successor edge for the last.\n\nExplicit gaps in outputs.pdf and fixes proposed here\n- Stage-1 currently verifies concatenation consistency of a guessed representative family but does not specify the feasible-function test that separates o(n) vs \u03a9(n). The feasible f definition and universal check above fill this gap and stay fully at the Ext level.\n- Stage-2 appears only as a brief \u201cadjustments\u201d paragraph; here we provide a concrete per-type boundary-interface witness with complete universal checks and show it implies an O(1) construction, aligning with Lemmas 26\u201327.\n- Minor: bin(t) in Type is not needed for \u03b4/concatenation; Ext+k_flag suffices. Keeping bin(t) is harmless but superfluous.\n\nNext steps\n1) Add to outputs.md: (i) a precise statement and proof that the type-level feasible-function check is equivalent to the paper\u2019s (Stage-1), using Lemma 11 and Ext concatenation; (ii) the Stage-2 boundary-interface witness statement and the O(1) construction proof for oriented paths.\n2) Include the O(\u03b2^6) concatenation routine and state the total verification time with precomputation of Left_\u03c4 and Right_\u03c4 slices.\n3) Provide a tiny regression suite (\u03b2=2,3) to exercise base cases k=1,2,3 and concatenation, catching the earlier k=2 glitch.\n4) Optional: deterministically precompute T and Ext_\u03c4 to remove the need for the certificate-supplied representatives in outputs.pdf; this makes the overall procedure \u201cguess f/Q then verify\u201d rather than \u201cguess T,Ext as well,\u201d strengthening the NEXPTIME upper bound claim.\n"
}