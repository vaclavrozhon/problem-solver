--- SYSTEM ---
You are a research **summarizer**. Summarize this *last round only* for a human log.

Include:
- 3–7 bullet **Highlights** (facts learned, reductions, counterexamples, partial bounds).
- 1–3 **Open questions / TODOs** for the next round.
- 1–3 **Citations to files** you relied on (e.g. round files or papers by name).

**Return strictly JSON**:
{
  "summary_md": "Readable summary of the round (≤200 words)",
  "highlights": [],
  "next_questions": []
}

--- USER ---
=== prover-01.out.json (progress_md) ===
Ideas — fill the remaining gaps and make the verifier fully type-level and auditable
- Gap 1 (in outputs.pdf): Stage-1 (Ω(n) vs o(n)) is only sketched as a “verifier specification” for Ext closure/concatenation, but the core “feasible-function existence” check that separates o(n) from Ω(n) is not formalized. Action: state a precise type-level feasible-function test using Ext-concatenation (no R-composition), prove soundness/completeness to the paper’s feasible function, and give explicit complexity bounds.
- Gap 2: Stage-2 (O(1) vs Ω(log* n)) appears only in a short “adjustments” paragraph. Action: formalize the boundary-interface witness per type, specify the universal checks using Ext, show it implies an O(1)-round construction (mirroring Lemmas 26–27 of the paper), and that failure implies Ω(log* n).
- Optimization: record a faster concatenation subroutine (from O(β^8) down to O(β^6)) by rearranging the 4-way existential join and precomputing seam-indexed slices. Not needed for NEXPTIME, but improves constants and clarifies feasibility.

Preliminaries to reuse
- Ext-tables, k-flag, append-one-bit DP, and Ext-level concatenation (Lemma 3.1 in outputs.pdf) are OK and will be our only composition primitive. The counterexample shows R-composition is unsound; we never use it directly.
- Deterministic enumeration of Types: use Type(t)=(Ext_t, k_flag(t)) or Type(t)=(bin(t), Ext_t, k_flag(t)) as in outputs.pdf. For our purposes, Ext+k_flag suffices for δ and concatenation; bin(t) is harmless redundancy. BFS from k=1 using the base cases and Proposition 2.1 yields T and δ in 2^{poly(N)} time.

Stage-1 (Ω(n) vs o(n)) — feasible function at the type level
Definition (feasible f specialized to r=1, oriented paths).
- Precompute T and, for each τ∈T, its Ext_τ. For two types τ,σ define Ext_{τ⊙σ} via Ext-level concatenation (outputs.pdf Lemma 3.1 applied to Ext_τ and Ext_σ).
- A feasible function is a table f: T × {0,1}^2 × T → Σ_out^2 such that for all triples (τ_L, s∈{0,1}^2, τ_R):
  (i) Node constraints on S (length-2 window): if f(τ_L,s,τ_R)=(α1,α2), then αi ∈ A_{s[i]} and E(α1,α2) holds.
  (ii) Universal extendibility across two separators: for all τ_a,τ_b,τ_c,τ_d ∈ T and s1,s2 ∈ {0,1}^2, letting
      α_L := second component of f(τ_a,s1,τ_b) and α_R := first component of f(τ_c,s2,τ_d),
      we require ∃ (o1,o2,o3,o4) ∈ Ext_{τ_b ⊙ τ_c} with E(α_L,o1) and E(o4,α_R).
Algorithm (NEXPTIME verification).
- Deterministically compute T and all Ext_τ and Ext_{τ⊙σ} (or compute Ext_{τ⊙σ} on demand and cache).
- Nondeterministically guess f. Verify (i) for all entries, and verify (ii) for all |T|^4 · 4 cases by membership in Ext_{τ_b ⊙ τ_c} and two E checks.
Correctness (why this matches the paper’s feasible function):
- “Only if”: If an o(n)-round algorithm exists, the paper’s Lemma 18 produces a feasible f on windows of length 2 using pumped contexts of length in [ℓ_pump,ℓ_pump+1]. Replacing concrete words by types is valid: Ext_{w_b ⊙ w_c} depends only on Type(w_b),Type(w_c) via Lemma 3.1 and Lemma 11; hence the type-level condition is necessary.
- “If”: Given f as above, the paper’s Lemma 17 construction goes through verbatim, because every time the proof needs to fill the middle B, the existence check is exactly the Ext_{τ_b ⊙ τ_c} membership with the seam constraints E(α_L,·) and E(·,α_R). Thus a type-level f implies o(n) (indeed O(log* n)). (No reversal is needed on globally oriented paths.)
Complexity: |T| ≤ 2^{poly(N)}, each Ext-table has size β^4, Ext_{τ⊙σ} computable in β^{O(1)} time; universal verification costs 2^{poly(N)}. The guess has size 2^{poly(N)}.

Stage-2 (O(1) vs Ω(log* n)) — per-type boundary interface witness
Witness per type τ∈T: a quadruple Q_τ=(L1_τ,L2_τ,R2_τ,R1_τ) intended to be the first two and last two outputs of any long block of type τ.
Checks.
(a) Per-type local feasibility and tiling:
  - (L1_τ,L2_τ,R2_τ,R1_τ) ∈ Ext_τ; E(L1_τ,L2_τ) and E(R2_τ,R1_τ) (redundant if Ext_τ computed from legal colorings, but we keep it explicit); wrap-around E(R1_τ,L1_τ) to tile τ by copies.
(b) Bridging across any middle type τ_S (including S empty):
  - For all τ_left,τ_right ∈ T and all τ_S ∈ T, require ∃ (o1,o2,o3,o4) ∈ Ext_{τ_S} with E(R1_{τ_left}, o1) and E(o4, L1_{τ_right}).
  - For S empty (no middle): just check E(R1_{τ_left}, L1_{τ_right}).
Decision: if the checks pass, classify O(1); else, if Stage-1 feasible f exists, classify Θ(log* n); otherwise Θ(n).
Correctness sketch.
- “O(1) if witness exists”: Use the partition framework of Section 4.3 of the paper (Lemmas 21–22) directly on the globally oriented path (orientation is already given); choose constants ℓ_width=ℓ_pattern=ℓ_pump and ℓ_count=2ℓ_pump+2r. On each long repetitive path P with primitive pattern having type τ, tile P by copies of τ using E(R1_τ,L1_τ); this ensures all interior nodes are locally consistent by Ext_τ. The remaining short separators S have types τ_S and can be filled by (b) since Ext_{τ_S} guarantees existence of a completion consistent with the boundary colors. This is the path-analogue of Lemmas 26–27, with Ext replacing word enumeration; all uses of extendibility are discharged by Ext-membership.
- “Ω(log* n) if witness fails but Stage-1 feasible f exists”: This matches the sublinear-but-not-constant regime as in the paper.
- “Ω(n) if Stage-1 fails”: No feasible f ⇒ o(n) impossible (paper’s Theorem 8). Our type-level test is equivalent by the argument under Stage-1.
Complexity: guessing Q_τ for all τ is 2^{poly(N)} bits; the universal checks over T×T×(T∪{∅}) use only a constant number of Ext lookups and E-checks per triple, so 2^{poly(N)} time.

Faster concatenation (optional speed-up; same asymptotics)
Observation: Ext_{B} membership for (o1,o2,o3′,o4′) reduces to the existence of seam colors x4,x1′ with E(x4,x1′) and of inner witnesses x3,x2′ such that (o1,o2,x3,x4)∈Ext_P and (x1′,x2′,o3′,o4′)∈Ext_Q. Precompute, per τ, the two 3D slices
  Left_τ[o1,o2,x4] := ∃x3 (o1,o2,x3,x4)∈Ext_τ,
  Right_τ[x1′,o3′,o4′] := ∃x2′ (x1′,x2′,o3′,o4′)∈Ext_τ.
Then (o1,o2,o3′,o4′)∈Ext_{τ⊙σ} iff ∃x4,x1′ with Left_τ[o1,o2,x4] ∧ E(x4,x1′) ∧ Right_σ[x1′,o3′,o4′]. This computes all of Ext_{τ⊙σ} in O(β^6) time after O(β^4) precomputation per type for the 3D slices.

Examples/sanity checks
- Trivial LCL: A_0=A_1=Σ_out, E complete. Ext_τ=Σ_out^4 for all τ. Stage-2 witness exists immediately with any constant color c ⇒ O(1). Stage-1 also passes.
- Equality LCL: A_0=A_1=Σ_out, E={(x,x)}. Stage-2 succeeds with Q_τ=(c,c,c,c) ∀τ; O(1). Stage-1 is also fine.
- Proper 2-coloring: A_0=A_1={a,b}, E forbids equal neighbors. No Q_τ can satisfy both E(L1_τ,L2_τ) and wrap E(R1_τ,L1_τ) with a period-1 boundary that works across all τ_S, so Stage-2 fails; Stage-1 feasible f exists (alternation across separators), yielding Θ(log* n).
- Hard/linear case (e.g., mixed A_0,A_1 with incompatible E across seams): Stage-1 fails ⇒ Ω(n).

Notes on endpoints and orientation
- Globally oriented paths do not require reversal cases (unlike undirected cycles). Our checks are oriented left-to-right. Endpoints need no special seam constraints: the local constraints on the first/last nodes are just membership in A_{input}, and all our fillings ensure E-constraints along existing edges; there is no predecessor edge for the first node nor successor edge for the last.

Explicit gaps in outputs.pdf and fixes proposed here
- Stage-1 currently verifies concatenation consistency of a guessed representative family but does not specify the feasible-function test that separates o(n) vs Ω(n). The feasible f definition and universal check above fill this gap and stay fully at the Ext level.
- Stage-2 appears only as a brief “adjustments” paragraph; here we provide a concrete per-type boundary-interface witness with complete universal checks and show it implies an O(1) construction, aligning with Lemmas 26–27.
- Minor: bin(t) in Type is not needed for δ/concatenation; Ext+k_flag suffices. Keeping bin(t) is harmless but superfluous.

Next steps
1) Add to outputs.md: (i) a precise statement and proof that the type-level feasible-function check is equivalent to the paper’s (Stage-1), using Lemma 11 and Ext concatenation; (ii) the Stage-2 boundary-interface witness statement and the O(1) construction proof for oriented paths.
2) Include the O(β^6) concatenation routine and state the total verification time with precomputation of Left_τ and Right_τ slices.
3) Provide a tiny regression suite (β=2,3) to exercise base cases k=1,2,3 and concatenation, catching the earlier k=2 glitch.
4) Optional: deterministically precompute T and Ext_τ to remove the need for the certificate-supplied representatives in outputs.pdf; this makes the overall procedure “guess f/Q then verify” rather than “guess T,Ext as well,” strengthening the NEXPTIME upper bound claim.


=== Verifier (summary_md) ===

=== Verifier (verdict) ===
uncertain

