{
  "progress_md": "Status and audit of outputs.md (Round 0004)\n\n- What is solid: outputs.md now contains the core r=1 primitives with complete proofs: (i) append-one-bit recurrence for k_flag \u2265 4; (ii) the key concatenation lemma at the Ext level; (iii) the congruence lemma (Type preserved under append); (iv) an explicit counterexample showing R-composition via \u2203m is unsound; (v) an O(\u03b2^6) concatenation routine via 3D slices.\n- Gaps to fill: (A) Base-case update k=1\u21922 is missing (only k=2\u21923 is written), yet it is needed to seed \u03b4; (B) Deterministic enumeration of types T and the \u03b4-transition correctness/complexity bounds are not yet in outputs.md; (C) Stage-1 trichotomy step (\u03a9(n) vs o(n)): definition of the type-level feasible function f, the precise universal verification condition using Ext_{\u03c4\u2299\u03c3}, and the equivalence proof (o(n) iff f exists) are absent; (D) Stage-2 trichotomy step (O(1) vs \u03a9(log* n)): the per-type boundary interface witness Q_\u03c4, its verification conditions, and a constant-round construction are not yet recorded; (E) The standard type-count upper bound |T| \u2264 16\u00b72^{\u03b2^4} for r=1 is missing; (F) A reversal operator Rev(\u03c4) (needed if any check uses reversed windows) is not stated here (though not strictly necessary on globally oriented paths).\n\nAdditions proposed for outputs.md\n\n1) Base case k=1\u21922 (explicit rule)\nFor t=(b) and t\u2032=t\u00b7a, for any (x1,x2,x3,x4)\u2208\u03a3_out^4,\n  (x1,x2,x3,x4)\u2208Ext_{t\u2032} \u21d4 [x1=x3, x2=x4, x1\u2208A_b, x2\u2208A_a, E(x1,x2)].\nWhy: This complements the already stated k=2\u21923 update; together with Lemma 1 (k_flag\u22654) the three base cases (k=1,2,3) make the append DP fully constructive from scratch.\n\n2) Type-count bound and \u03b4 well-defined, with deterministic enumeration (DP over Ext)\nLemma (Type-count for r=1). The number of distinct types (Ext,k_flag) is at most 16\u00b72^{\u03b2^4}.\nSketch. D1\u222aD2 has four boundary nodes, with 2^4 choices of boundary input bits implicitly encoded in Ext_t; extendibility over \u03a3_out^4 yields \u2264 2^{\u03b2^4} possibilities. Thus |T| \u2264 16\u00b72^{\u03b2^4}.\nProposition (\u03b4 well-defined and BFS enumeration). Key the dictionary by Type=(Ext,k_flag). From seeds |t|\u2208{1,2,3,4}, update by: k_flag<4 use the explicit base cases (k=1\u21922, k=2\u21923), k_flag\u22654 use Lemma 1. By the congruence lemma, if Type(P)=Type(Q) then Type(P\u00b7a)=Type(Q\u00b7a); hence \u03b4 depends only on Type and a. BFS closure over a\u2208{0,1} halts after \u2264|T| insertions. Complexity: each append costs O(\u03b2^5); total deterministic time/space 2^{poly(\u03b2)}.\n\n3) Reversal operator (for completeness)\nDefinition. Rev maps \u03c4=(Ext_\u03c4,k_flag) to \u03c4^R=(Ext_\u03c4^R,k_flag) with Ext_\u03c4^R := { (y1,y2,y3,y4): (y4,y3,y2,y1)\u2208Ext_\u03c4 }. Then Rev(Rev(\u03c4))=\u03c4. If needed, Ext_{Rev(\u03c4)\u2299Rev(\u03c3)} = (Ext_{\u03c3\u2299\u03c4})^R.\n\n4) Precise Stage-1 (\u03a9(n) vs o(n)) at the type level\nDefinition (feasible function, oriented r=1). Let T be the enumerated types. A table f: T\u00d7{0,1}^2\u00d7T\u2192\u03a3_out^2 is feasible if for all triples (\u03c4_L,s,\u03c4_R):\n- Local window legality: if f(\u03c4_L,s,\u03c4_R)=(\u03b11,\u03b12), then \u03b1i\u2208A_{s[i]} for i=1,2 and E(\u03b11,\u03b12).\n- Universal extendibility across two separators: for all \u03c4_a,\u03c4_b,\u03c4_c,\u03c4_d\u2208T and s1,s2\u2208{0,1}^2, letting \u03b1_L := second component of f(\u03c4_a,s1,\u03c4_b) and \u03b1_R := first component of f(\u03c4_c,s2,\u03c4_d), we require\n  \u2203(o1,o2,o3,o4)\u2208Ext_{\u03c4_b\u2299\u03c4_c} s.t. E(\u03b1_L,o1) and E(o4,\u03b1_R).\nIndexing note. Our Ext quadruples are ordered (L1,L2,R2,R1). Thus o1 is the leftmost output of the middle block (adjacent to \u03b1_L), and o4 is the rightmost output of the middle block (adjacent to \u03b1_R); the seam checks E(\u03b1_L,o1), E(o4,\u03b1_R) are the correct edges.\nTheorem (equivalence). The LCL has deterministic complexity o(n) on globally oriented paths iff a feasible f exists.\n- Only if. Let A be an o(n)-round algorithm. Fix \u2113_pump=|T|. For any w with |w|\u2208[1,\u2113_pump], pump to w^+ of length \u0398(s) (s\u226bruntime) preserving Type, assign IDs so that A\u2019s view on the 2r-window depends only on (\u03c4_L,s,\u03c4_R), and define f(\u03c4_L,s,\u03c4_R) as A\u2019s output on the window. Validity of the universal check follows since Ext_{\u03c4_b\u2299\u03c4_c} depends only on Types (by Lemma 2 and concatenation), and A labels the middle consistently across any two separators.\n- If. Given feasible f, decompose the path into two separators and a middle (adversarial) block; fill both separators using f, and fill the middle using the existential witness in Ext_{\u03c4_b\u2299\u03c4_c}. This yields an O(log* n)-round algorithm via the standard MIS-based sparse placement of separators (as in the paper\u2019s Lemma 16), specialized to oriented paths.\nNEXPTIME verification. Deterministically precompute T, and Ext_{\u03c4\u2299\u03c3} by Proposition 5; guess f (size |T|^2\u00b74 entries), and verify all constraints in time 2^{poly(\u03b2)}.\n\n5) Precise Stage-2 (O(1) vs \u03a9(log* n)) with a constant-round construction\nWitness. For each \u03c4\u2208T with k_flag\u22654, pick Q_\u03c4=(L1_\u03c4,L2_\u03c4,R2_\u03c4,R1_\u03c4)\u2208Ext_\u03c4.\nChecks.\n(a) Tiling feasibility (per \u03c4): E(L1_\u03c4,L2_\u03c4), E(R2_\u03c4,R1_\u03c4), and wrap-around E(R1_\u03c4,L1_\u03c4). (Membership in Ext_\u03c4 ensures the boundary outputs are consistent with the interior inputs; explicit E checks are kept for clarity.)\n(b) Middle bridging (universal): for all \u03c4_left, \u03c4_S, \u03c4_right \u2208 T, require either\n  - if k_flag(\u03c4_S)\u22651: \u2203(o1,o2,o3,o4)\u2208Ext_{\u03c4_S} with E(R1_{\u03c4_left},o1) and E(o4,L1_{\u03c4_right}); or\n  - if S is empty: E(R1_{\u03c4_left},L1_{\u03c4_right}).\nTheorem (constant-time labeling from {Q_\u03c4}). There exists an O(1)-round deterministic labeling algorithm on oriented paths if such {Q_\u03c4} pass (a)\u2013(b).\nConstruction (constant-radius). Choose constants \u2113_width=\u2113_pattern=\u2113_pump and \u2113_count=2\u2113_pump+2. Compute in O(1) rounds an (\u2113_width,\u2113_count,\u2113_pattern)-partition (the directed-path version of Lemma 22 holds in O(1)): \n- Long periodic blocks P have Type \u03c4 with k_flag\u22654 and a primitive input pattern of period \u2264\u2113_pump repeated \u2265\u2113_count. Label P by tiling copies whose boundary output is Q_\u03c4: interior feasibility follows from Q_\u03c4\u2208Ext_\u03c4; seam E(R1_\u03c4,L1_\u03c4) ensures joins.\n- Separator blocks S (short or aperiodic; any k_flag) are filled by the existential witness in Ext_{\u03c4_S} so that the left seam matches the R1 of the preceding long block and the right seam matches the L1 of the following long block (condition (b)). End segments at path endpoints need no extra seam check.\nLegality: All node memberships and edge constraints hold by Ext-membership inside blocks plus explicit seam E checks. Runtime is O(1) as the partition and local fillings use only constant radii.\nNEXPTIME verification. Guess {Q_\u03c4} for \u03c4 with k_flag\u22654 and check (a)\u2013(b) universally using Ext tables; time 2^{poly(\u03b2)}.\n\n6) S=\u2205 case in Stage-1 and Stage-2\nOptionally define Ext_{\u2205} via the seam-edge constraint: (o1,o2,o3,o4)\u2208Ext_{\u2205} iff o2=o1 and o3=o4 and E(o2,o3); then both stages unify \u201cempty middle\u201d into a single Ext lookup.\n\n7) Small sanity checks and regression items\n- k=1\u21922 base: \u03b2=2, E complete, A_0=A_1=\u03a3_out: Ext_{(b)} = {(x,x,x,x): x\u2208\u03a3_out}; appending a gives Ext_{(b,a)}={(x,y,x,y): x\u2208A_b, y\u2208A_a, E(x,y)} as expected.\n- Ext concatenation vs R-composition: retain the 3-color a\u2192b\u2192c counterexample; confirm that (a,c)\u2209R_{P\u00b7Q} although (a,b)\u2208R_P and (b,c)\u2208R_Q.\n- Reversal: for symmetric E and A, Ext=Ext^R; verify Rev(Rev(\u03c4))=\u03c4 and Ext_{Rev(\u03c4)\u2299Rev(\u03c3)}=(Ext_{\u03c3\u2299\u03c4})^R.\n\n8) Complexity recap (toward the target NEXPTIME algorithm)\n- Precompute T by BFS over append: \u226416\u00b72^{\u03b2^4} types; O(\u03b2^5) per transition; time/space 2^{poly(\u03b2)}.\n- Precompute Left_\u03c4, Right_\u03c4 per \u03c4 in O(\u03b2^4) and Ext_{\u03c4\u2299\u03c3} in O(\u03b2^6) per pair (or on-demand with caching).\n- Stage-1: guess f of size O(|T|^2) entries; verify O(|T|^4\u00b74) universal constraints with O(1) Ext lookups each \u2192 2^{poly(\u03b2)} time.\n- Stage-2: guess {Q_\u03c4} for \u03c4 with k_flag\u22654; verify O(|T| + |T|^3) constraints via Ext \u2192 2^{poly(\u03b2)} time.\n\nAction items for outputs.md\n- Add the k=1\u21922 base rule and the Type-count and \u03b4-enumeration proposition with explicit complexity.\n- Insert the Stage-1 feasible-function definition, the precise Ext-based universal check (with indexing note), and the equivalence theorem (both directions) specialized to oriented paths.\n- Insert the Stage-2 witness definition and the constant-round construction and proof sketch, restricted to k_flag\u22654 types for witnesses and treating short types as separators.\n- Optionally add Rev(\u00b7) to complete the algebra of types and help prevent indexing mistakes in future extensions.\n\nPotential pitfalls and how we address them\n- Off-by-one at seams: we explicitly match \u03b1_L to the leftmost element o1 of Ext_{\u03c4_b\u2299\u03c4_c}, and \u03b1_R to the rightmost element o4; we state this to avoid ambiguity.\n- Reliance on boundary inputs: our use of Ext_t eliminates any need to carry the boundary input bits in Type, since Ext encodes node memberships implicitly. The congruence and concatenation lemmas ensure that replacement by same-Type contexts is sound.\n- Short-type witnesses: we restrict Q_\u03c4 to k_flag\u22654 and treat k_flag<4 cases as separators in the universal bridging checks.\n\nNext steps\n- Promote the items in Sections 1\u20135 into outputs.md with full statements and brief proofs (the equivalence theorem can mirror the paper\u2019s Lemmas 17\u201318 but stated purely with Ext and Types; constants \u2113_pump, \u2113_count should be fixed in the statements).\n- Provide a short appendix with the O(\u03b2^6) concatenation implementation details (Left/Right slices) and a small API sketch for type enumeration and Ext operations, to make the verifier code straightforward.\n- Prepare a tiny regression suite (\u03b2\u2208{2,3}) to test base cases and concatenation, catching the k=2 update glitch and seam indexing.\n"
}