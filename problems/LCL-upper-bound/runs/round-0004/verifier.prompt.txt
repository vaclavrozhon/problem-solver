--- SYSTEM ---
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (summary so far)
- outputs.md (rigorously proven results so far)

Guidelines:
- notes.md: should be a readable running log of interesting work. Prefer appending. Replace only if old notes are clearly misleading. Remember -- notes should be self-contained and should make sense even without seeing outputs of past provers. 
- outputs.md: should be concise and rigorous. Keep only proven theorems with clear proofs. If a statement is flawed and you cannot fix it, remove it from outputs.md and instead add it to notes.md with explanation.
- Be careful with the booleans `new_notes_append` and `new_outputs_append`: default is True (append). Use False only when deliberately rewriting everything.

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (≥200 words). Include concrete next-step suggestions. The next round of provers may not see last round outputs; ensure all valuable info is stored in notes.",
  "new_notes_md": "Markdown (KaTeX allowed). Usually appended to notes.",
  "new_notes_append": "True|False",
  "new_outputs_md": "Markdown (KaTeX allowed). Usually appended to outputs.",
  "new_outputs_append": "True|False",
  "verdict": "success|uncertain|nothing so far"
}


--- USER ---
You receive multiple prover reports. Evaluate correctness, value, and pick promising directions. Update notes.md (append/replace) with useful ideas and update output.md (append/replace) ONLY with rigorously verified results.

Prover reports (JSON):
[{"prover_id": "01", "progress_md": "Status and audit of outputs.md (Round 0004)\n\n- What is solid: outputs.md now contains the core r=1 primitives with complete proofs: (i) append-one-bit recurrence for k_flag \u2265 4; (ii) the key concatenation lemma at the Ext level; (iii) the congruence lemma (Type preserved under append); (iv) an explicit counterexample showing R-composition via \u2203m is unsound; (v) an O(\u03b2^6) concatenation routine via 3D slices.\n- Gaps to fill: (A) Base-case update k=1\u21922 is missing (only k=2\u21923 is written), yet it is needed to seed \u03b4; (B) Deterministic enumeration of types T and the \u03b4-transition correctness/complexity bounds are not yet in outputs.md; (C) Stage-1 trichotomy step (\u03a9(n) vs o(n)): definition of the type-level feasible function f, the precise universal verification condition using Ext_{\u03c4\u2299\u03c3}, and the equivalence proof (o(n) iff f exists) are absent; (D) Stage-2 trichotomy step (O(1) vs \u03a9(log* n)): the per-type boundary interface witness Q_\u03c4, its verification conditions, and a constant-round construction are not yet recorded; (E) The standard type-count upper bound |T| \u2264 16\u00b72^{\u03b2^4} for r=1 is missing; (F) A reversal operator Rev(\u03c4) (needed if any check uses reversed windows) is not stated here (though not strictly necessary on globally oriented paths).\n\nAdditions proposed for outputs.md\n\n1) Base case k=1\u21922 (explicit rule)\nFor t=(b) and t\u2032=t\u00b7a, for any (x1,x2,x3,x4)\u2208\u03a3_out^4,\n  (x1,x2,x3,x4)\u2208Ext_{t\u2032} \u21d4 [x1=x3, x2=x4, x1\u2208A_b, x2\u2208A_a, E(x1,x2)].\nWhy: This complements the already stated k=2\u21923 update; together with Lemma 1 (k_flag\u22654) the three base cases (k=1,2,3) make the append DP fully constructive from scratch.\n\n2) Type-count bound and \u03b4 well-defined, with deterministic enumeration (DP over Ext)\nLemma (Type-count for r=1). The number of distinct types (Ext,k_flag) is at most 16\u00b72^{\u03b2^4}.\nSketch. D1\u222aD2 has four boundary nodes, with 2^4 choices of boundary input bits implicitly encoded in Ext_t; extendibility over \u03a3_out^4 yields \u2264 2^{\u03b2^4} possibilities. Thus |T| \u2264 16\u00b72^{\u03b2^4}.\nProposition (\u03b4 well-defined and BFS enumeration). Key the dictionary by Type=(Ext,k_flag). From seeds |t|\u2208{1,2,3,4}, update by: k_flag<4 use the explicit base cases (k=1\u21922, k=2\u21923), k_flag\u22654 use Lemma 1. By the congruence lemma, if Type(P)=Type(Q) then Type(P\u00b7a)=Type(Q\u00b7a); hence \u03b4 depends only on Type and a. BFS closure over a\u2208{0,1} halts after \u2264|T| insertions. Complexity: each append costs O(\u03b2^5); total deterministic time/space 2^{poly(\u03b2)}.\n\n3) Reversal operator (for completeness)\nDefinition. Rev maps \u03c4=(Ext_\u03c4,k_flag) to \u03c4^R=(Ext_\u03c4^R,k_flag) with Ext_\u03c4^R := { (y1,y2,y3,y4): (y4,y3,y2,y1)\u2208Ext_\u03c4 }. Then Rev(Rev(\u03c4))=\u03c4. If needed, Ext_{Rev(\u03c4)\u2299Rev(\u03c3)} = (Ext_{\u03c3\u2299\u03c4})^R.\n\n4) Precise Stage-1 (\u03a9(n) vs o(n)) at the type level\nDefinition (feasible function, oriented r=1). Let T be the enumerated types. A table f: T\u00d7{0,1}^2\u00d7T\u2192\u03a3_out^2 is feasible if for all triples (\u03c4_L,s,\u03c4_R):\n- Local window legality: if f(\u03c4_L,s,\u03c4_R)=(\u03b11,\u03b12), then \u03b1i\u2208A_{s[i]} for i=1,2 and E(\u03b11,\u03b12).\n- Universal extendibility across two separators: for all \u03c4_a,\u03c4_b,\u03c4_c,\u03c4_d\u2208T and s1,s2\u2208{0,1}^2, letting \u03b1_L := second component of f(\u03c4_a,s1,\u03c4_b) and \u03b1_R := first component of f(\u03c4_c,s2,\u03c4_d), we require\n  \u2203(o1,o2,o3,o4)\u2208Ext_{\u03c4_b\u2299\u03c4_c} s.t. E(\u03b1_L,o1) and E(o4,\u03b1_R).\nIndexing note. Our Ext quadruples are ordered (L1,L2,R2,R1). Thus o1 is the leftmost output of the middle block (adjacent to \u03b1_L), and o4 is the rightmost output of the middle block (adjacent to \u03b1_R); the seam checks E(\u03b1_L,o1), E(o4,\u03b1_R) are the correct edges.\nTheorem (equivalence). The LCL has deterministic complexity o(n) on globally oriented paths iff a feasible f exists.\n- Only if. Let A be an o(n)-round algorithm. Fix \u2113_pump=|T|. For any w with |w|\u2208[1,\u2113_pump], pump to w^+ of length \u0398(s) (s\u226bruntime) preserving Type, assign IDs so that A\u2019s view on the 2r-window depends only on (\u03c4_L,s,\u03c4_R), and define f(\u03c4_L,s,\u03c4_R) as A\u2019s output on the window. Validity of the universal check follows since Ext_{\u03c4_b\u2299\u03c4_c} depends only on Types (by Lemma 2 and concatenation), and A labels the middle consistently across any two separators.\n- If. Given feasible f, decompose the path into two separators and a middle (adversarial) block; fill both separators using f, and fill the middle using the existential witness in Ext_{\u03c4_b\u2299\u03c4_c}. This yields an O(log* n)-round algorithm via the standard MIS-based sparse placement of separators (as in the paper\u2019s Lemma 16), specialized to oriented paths.\nNEXPTIME verification. Deterministically precompute T, and Ext_{\u03c4\u2299\u03c3} by Proposition 5; guess f (size |T|^2\u00b74 entries), and verify all constraints in time 2^{poly(\u03b2)}.\n\n5) Precise Stage-2 (O(1) vs \u03a9(log* n)) with a constant-round construction\nWitness. For each \u03c4\u2208T with k_flag\u22654, pick Q_\u03c4=(L1_\u03c4,L2_\u03c4,R2_\u03c4,R1_\u03c4)\u2208Ext_\u03c4.\nChecks.\n(a) Tiling feasibility (per \u03c4): E(L1_\u03c4,L2_\u03c4), E(R2_\u03c4,R1_\u03c4), and wrap-around E(R1_\u03c4,L1_\u03c4). (Membership in Ext_\u03c4 ensures the boundary outputs are consistent with the interior inputs; explicit E checks are kept for clarity.)\n(b) Middle bridging (universal): for all \u03c4_left, \u03c4_S, \u03c4_right \u2208 T, require either\n  - if k_flag(\u03c4_S)\u22651: \u2203(o1,o2,o3,o4)\u2208Ext_{\u03c4_S} with E(R1_{\u03c4_left},o1) and E(o4,L1_{\u03c4_right}); or\n  - if S is empty: E(R1_{\u03c4_left},L1_{\u03c4_right}).\nTheorem (constant-time labeling from {Q_\u03c4}). There exists an O(1)-round deterministic labeling algorithm on oriented paths if such {Q_\u03c4} pass (a)\u2013(b).\nConstruction (constant-radius). Choose constants \u2113_width=\u2113_pattern=\u2113_pump and \u2113_count=2\u2113_pump+2. Compute in O(1) rounds an (\u2113_width,\u2113_count,\u2113_pattern)-partition (the directed-path version of Lemma 22 holds in O(1)): \n- Long periodic blocks P have Type \u03c4 with k_flag\u22654 and a primitive input pattern of period \u2264\u2113_pump repeated \u2265\u2113_count. Label P by tiling copies whose boundary output is Q_\u03c4: interior feasibility follows from Q_\u03c4\u2208Ext_\u03c4; seam E(R1_\u03c4,L1_\u03c4) ensures joins.\n- Separator blocks S (short or aperiodic; any k_flag) are filled by the existential witness in Ext_{\u03c4_S} so that the left seam matches the R1 of the preceding long block and the right seam matches the L1 of the following long block (condition (b)). End segments at path endpoints need no extra seam check.\nLegality: All node memberships and edge constraints hold by Ext-membership inside blocks plus explicit seam E checks. Runtime is O(1) as the partition and local fillings use only constant radii.\nNEXPTIME verification. Guess {Q_\u03c4} for \u03c4 with k_flag\u22654 and check (a)\u2013(b) universally using Ext tables; time 2^{poly(\u03b2)}.\n\n6) S=\u2205 case in Stage-1 and Stage-2\nOptionally define Ext_{\u2205} via the seam-edge constraint: (o1,o2,o3,o4)\u2208Ext_{\u2205} iff o2=o1 and o3=o4 and E(o2,o3); then both stages unify \u201cempty middle\u201d into a single Ext lookup.\n\n7) Small sanity checks and regression items\n- k=1\u21922 base: \u03b2=2, E complete, A_0=A_1=\u03a3_out: Ext_{(b)} = {(x,x,x,x): x\u2208\u03a3_out}; appending a gives Ext_{(b,a)}={(x,y,x,y): x\u2208A_b, y\u2208A_a, E(x,y)} as expected.\n- Ext concatenation vs R-composition: retain the 3-color a\u2192b\u2192c counterexample; confirm that (a,c)\u2209R_{P\u00b7Q} although (a,b)\u2208R_P and (b,c)\u2208R_Q.\n- Reversal: for symmetric E and A, Ext=Ext^R; verify Rev(Rev(\u03c4))=\u03c4 and Ext_{Rev(\u03c4)\u2299Rev(\u03c3)}=(Ext_{\u03c3\u2299\u03c4})^R.\n\n8) Complexity recap (toward the target NEXPTIME algorithm)\n- Precompute T by BFS over append: \u226416\u00b72^{\u03b2^4} types; O(\u03b2^5) per transition; time/space 2^{poly(\u03b2)}.\n- Precompute Left_\u03c4, Right_\u03c4 per \u03c4 in O(\u03b2^4) and Ext_{\u03c4\u2299\u03c3} in O(\u03b2^6) per pair (or on-demand with caching).\n- Stage-1: guess f of size O(|T|^2) entries; verify O(|T|^4\u00b74) universal constraints with O(1) Ext lookups each \u2192 2^{poly(\u03b2)} time.\n- Stage-2: guess {Q_\u03c4} for \u03c4 with k_flag\u22654; verify O(|T| + |T|^3) constraints via Ext \u2192 2^{poly(\u03b2)} time.\n\nAction items for outputs.md\n- Add the k=1\u21922 base rule and the Type-count and \u03b4-enumeration proposition with explicit complexity.\n- Insert the Stage-1 feasible-function definition, the precise Ext-based universal check (with indexing note), and the equivalence theorem (both directions) specialized to oriented paths.\n- Insert the Stage-2 witness definition and the constant-round construction and proof sketch, restricted to k_flag\u22654 types for witnesses and treating short types as separators.\n- Optionally add Rev(\u00b7) to complete the algebra of types and help prevent indexing mistakes in future extensions.\n\nPotential pitfalls and how we address them\n- Off-by-one at seams: we explicitly match \u03b1_L to the leftmost element o1 of Ext_{\u03c4_b\u2299\u03c4_c}, and \u03b1_R to the rightmost element o4; we state this to avoid ambiguity.\n- Reliance on boundary inputs: our use of Ext_t eliminates any need to carry the boundary input bits in Type, since Ext encodes node memberships implicitly. The congruence and concatenation lemmas ensure that replacement by same-Type contexts is sound.\n- Short-type witnesses: we restrict Q_\u03c4 to k_flag\u22654 and treat k_flag<4 cases as separators in the universal bridging checks.\n\nNext steps\n- Promote the items in Sections 1\u20135 into outputs.md with full statements and brief proofs (the equivalence theorem can mirror the paper\u2019s Lemmas 17\u201318 but stated purely with Ext and Types; constants \u2113_pump, \u2113_count should be fixed in the statements).\n- Provide a short appendix with the O(\u03b2^6) concatenation implementation details (Left/Right slices) and a small API sketch for type enumeration and Ext operations, to make the verifier code straightforward.\n- Prepare a tiny regression suite (\u03b2\u2208{2,3}) to test base cases and concatenation, catching the k=2 update glitch and seam indexing.\n"}]

Current notes.md:
Corrections and key lemmas to record

1) Correct append-one-bit recurrence (r=1)
Given a type t with Ext_t ⊆ Σ_out^4 over boundary (L1,L2,R2,R1) and an appended input bit a, the new type t′ has boundary (L1′,L2′,R2′,R1′) = (L1,L2, old R1, new), i.e., R2′ = R1 and R1′ is the label of the appended node. Formally, for each candidate quadruple (x1,x2,x3,x4) ∈ Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [x4 ∈ A_a and E(x3,x4) and ∃ z ∈ Σ_out: (x1,x2,z,x3) ∈ Ext_t].
This yields an O(β^5) DP to fill Ext_{t′} by scanning all (x1,x2,x3,x4) and checking ∃z.

Congruence lemma (needed): If Type(P)=Type(Q), then for all a ∈ {0,1}, Type(Pa)=Type(Qa). Proof sketch: The predicate “there exists an interior completion consistent with boundary assignments” over D1∪D2 is preserved under appending one node by the above DP rule, which depends only on Ext_t and a.

2) Concatenation of summaries (r=1)
If Summ(P) has Ext_P and Summ(Q) has Ext_Q, then the concatenation B=P·Q has boundary (P.left endpoint, P.left neighbor, Q.right neighbor, Q.right endpoint) and
  (o1,o2,o3′,o4′) ∈ Ext_B ⇔ ∃ x3,x4,x1′,x2′ ∈ Σ_out: (o1,o2,x3,x4) ∈ Ext_P, (x1′,x2′,o3′,o4′) ∈ Ext_Q, and E(x4,x1′).
Then R_B can be derived from Ext_B as usual.

3) Counterexample to R-composition via ∃m
Let Σ_out={a,b,c}, A_0=A_1=Σ_out. Let E={a→b, b→c} only. Suppose t_b admits a boundary tuple with right endpoint a, and t_c admits a boundary tuple with left endpoint c (interiors arbitrary but extendible). Then choose m=b. We have (x,m) ∈ R_{t_b} for any x with a valid left edge, and (m,y) ∈ R_{t_c} for suitable y. But the concatenation t_b·t_c requires the seam edge a→c, which is forbidden. Hence ∃m composition of R_t is not sound; use Ext-level concatenation and R_B instead.
Additions and fixes (r=1)

A) Correct k=2→3 base-case update
Let t=(b1,b2) and t′=t·a (length 3). Then
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [x3=x2, x1∈A_{b1}, x2∈A_{b2}, x4∈A_a, E(x1,x2), E(x2,x4)].
This replaces any prior statement that involved x2∈A_a.

B) Type representation and congruence
Define Type(t) := (b_in(t), Ext_t, k_flag(t)), where k_flag ∈ {1,2,3,≥4} indicates whether boundary coordinates coincide due to short length. Then the congruence lemma holds in the form:
  If Type(P)=Type(Q), then for all a∈{0,1}, Type(Pa)=Type(Qa).
Proof: case split on k_flag using the explicit base-case rules for k_flag∈{1,2,3} and the general append recurrence for k_flag=≥4.
Remark: Ext equality alone does not determine |t| (e.g., with E self-loops and A_0=A_1, Ext_{len 2} = Ext_{len 4}). Hence the k_flag is necessary for a length-agnostic update routine.

C) Enumeration fix
In the BFS over types, key the dictionary by the full Type(t), including k_flag. After the first transition to k_flag=≥4, all descendants remain in k_flag=≥4 and subsequent δ updates are length-agnostic.
Additions: Stage-1 and Stage-2 specifications at the Ext level (r=1, oriented paths)

Notation. Σ_out has size β. For an input word t with bits b_in(t) ∈ {0,1}^{|t|}, let Ext_t ⊆ Σ_out^4 denote the set of boundary quadruples (L1,L2,R2,R1) = (o[1],o[2],o[|t|-1],o[|t|]) that admit an interior completion o consistent with node constraints o[i]∈A_{b_in(t)[i]} and edge constraints (o[i],o[i+1])∈E. Types are Type(t)=(Ext_t, k_flag(t)), where k_flag∈{1,2,3,≥4} encodes short-length degeneracies. Concatenation of types τ⊙σ is defined by the Ext-level concatenation rule (see outputs.md) and k_flag update.

Stage-1 (Ω(n) vs o(n)): type-level feasible function
- Universe: the finite set of types T obtained by BFS from k=1 under the append-one-bit updates (keyed by (Ext,k_flag)). For τ,σ∈T, the Ext of τ⊙σ is defined by Ext-level concatenation.
- Definition (feasible f). A function f: T × {0,1}^2 × T → Σ_out^2 mapping (τ_L, s, τ_R) to (α1,α2) is feasible if:
  (i) Node/window constraints: αi ∈ A_{s[i]} for i=1,2 and (α1,α2) ∈ E (i.e., E(α1,α2) holds).
  (ii) Universal extendibility across two separators: for all τ_a,τ_b,τ_c,τ_d∈T and s1,s2∈{0,1}^2, letting α_L := second component of f(τ_a,s1,τ_b) and α_R := first component of f(τ_c,s2,τ_d), we require
      ∃ (o1,o2,o3,o4) ∈ Ext_{τ_b ⊙ τ_c} with E(α_L,o1) and E(o4,α_R).
  Comment: The quantification over τ_a and τ_d is stronger than necessary but safe; a weaker version quantifies only over τ_b,τ_c and s1,s2. Indexing uses our convention (L1,L2,R2,R1); thus o1 and o4 are the first and last outputs of the middle block of type τ_b⊙τ_c.
- NEXPTIME check: deterministically enumerate T and all Ext_{τ} and on-demand Ext_{τ⊙σ}; nondeterministically guess f; verify (i) and (ii) exhaustively. Complexity is 2^{poly(N)} in the problem description size N.
- Status: We still owe a self-contained proof that “o(n) algorithm exists iff a feasible f exists” at the Ext level (the intended replacement of the paper’s feasible-function lemma). This will rely only on our Ext-append and Ext-concat lemmas and a standard pumping argument specialized to r=1.

Stage-2 (O(1) vs Ω(log* n)): per-type boundary-interface witness
- For each τ∈T with k_flag(τ)≥4, guess Q_τ=(L1_τ,L2_τ,R2_τ,R1_τ) with Q_τ ∈ Ext_τ. Enforce:
  (a) Local consistency and tiling: E(L1_τ,L2_τ), E(R2_τ,R1_τ), and wrap E(R1_τ,L1_τ). Intuition: long blocks of type τ can be tiled by copies using the same boundary outputs.
  (b) Bridging across any middle type (including empty): for all τ_left,τ_S,τ_right ∈ T, require either
      - if τ_S has k_flag≥1: ∃ (o1,o2,o3,o4) ∈ Ext_{τ_S} with E(R1_{τ_left},o1) and E(o4,L1_{τ_right}); or
      - if τ_S is empty: E(R1_{τ_left},L1_{τ_right}).
- Decision logic: if witnesses {Q_τ} exist and pass (a)–(b), classify O(1). Else, if a Stage-1 feasible f exists, classify Θ(log* n). Otherwise, classify Θ(n).
- Status: We still owe a concrete constant-radius construction on oriented paths from {Q_τ} (e.g., a partition/tiling routine parametrized by fixed radii ℓ_width, ℓ_pattern, ℓ_count) and a proof that the produced labeling is legal. Short types (k_flag<4) are treated as separators τ_S in (b).

Faster concatenation (proven and moved to outputs.md)
- Precompute for each τ the 3D slices: Left_τ[o1,o2,x4] := ∃x3 (o1,o2,x3,x4)∈Ext_τ, and Right_τ[x1′,o3′,o4′] := ∃x2′ (x1′,x2′,o3′,o4′)∈Ext_τ.
- Then (o1,o2,o3′,o4′)∈Ext_{τ⊙σ} iff ∃x4,x1′: Left_τ[o1,o2,x4] ∧ E(x4,x1′) ∧ Right_σ[x1′,o3′,o4′]. This allows computing Ext_{τ⊙σ} in O(β^6) time after O(β^4) precomputation per type.

Sanity checks (kept as examples)
- Trivial LCL (A_0=A_1=Σ_out, E complete): Ext_τ=Σ_out^4 for all τ; Stage-2 witness exists trivially ⇒ O(1).
- Equality LCL (E={(x,x)}): take Q_τ=(c,c,c,c) ⇒ O(1).
- Proper 2-coloring: Stage-2 fails; Stage-1 feasible f should exist ⇒ Θ(log* n).
- Linear cases with incompatible seams: Stage-1 fails ⇒ Ω(n).


Current output.md (if any):
Setup and definitions (r=1, globally oriented paths)
- Let Σ_out be a finite output alphabet of size β. Let A_0,A_1 ⊆ Σ_out be the allowed outputs at nodes with input bit 0 or 1, respectively. Let E ⊆ Σ_out × Σ_out be the allowed directed edge relation (u→v allowed iff (u,v)∈E). For an input word t ∈ {0,1}^k with k≥1, a labeling o ∈ Σ_out^k is legal if o[i]∈A_{t[i]} for all i, and (o[i],o[i+1])∈E for all 1≤i<k.
- For k≥4, define Ext_t ⊆ Σ_out^4 as the set of boundary quadruples (L1,L2,R2,R1) that extend to a legal labeling o with L1=o[1], L2=o[2], R2=o[k−1], R1=o[k]. For k≤3, Ext_t is defined with the same 4-tuple container but with the obvious coordinate equalities imposed by overlaps (tracked by k_flag ∈ {1,2,3,≥4}). The Type of t is Type(t) := (Ext_t, k_flag(t)).

Lemma 1 (Append-one-bit recurrence; k_flag≥4 case).
Let t be an input word with k_flag(t)≥4, and let t′ := t·a be t with one bit a ∈ {0,1} appended on the right. Then for all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x4 ∈ A_a and E(x3,x4) and ∃z∈Σ_out: (x1,x2,z,x3) ∈ Ext_t ].
Proof. (⇒) From (x1,x2,x3,x4)∈Ext_{t′} there is a legal labeling o′ on t′ with o′[1]=x1, o′[2]=x2, o′[k]=x3, o′[k+1]=x4. Node/edge constraints give x4∈A_a and E(x3,x4). Let z := o′[k−1]; then the restriction o := o′[1..k] is a legal labeling of t with boundary (x1,x2,z,x3), so (x1,x2,z,x3)∈Ext_t. (⇐) Conversely, given z with (x1,x2,z,x3)∈Ext_t, pick a witnessing legal labeling o on t. Extend by setting o′[1..k]=o and o′[k+1]=x4. If x4∈A_a and E(x3,x4), then o′ is legal on t′ and has boundary (x1,x2,x3,x4), so (x1,x2,x3,x4)∈Ext_{t′}. □

Base-case update (k=2→3).
Let t=(b1,b2) and t′=t·a. Then for all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x3=x2, x1∈A_{b1}, x2∈A_{b2}, x4∈A_a, E(x1,x2), E(x2,x4) ].
This follows by unfolding the definition when positions 2 and 3 coincide in the boundary coordinates.

Lemma 2 (Ext-level concatenation; k_flag≥4).
Let P and Q be input words with k_flag(P), k_flag(Q) ≥4, and let B := P·Q (concatenation). Then for all (o1,o2,o3′,o4′)∈Σ_out^4,
  (o1,o2,o3′,o4′) ∈ Ext_B ⇔ ∃ x3,x4,x1′,x2′ ∈ Σ_out such that
    (o1,o2,x3,x4) ∈ Ext_P, (x1′,x2′,o3′,o4′) ∈ Ext_Q, and E(x4,x1′).
Proof. (⇒) Given a legal labeling on B with boundary (o1,o2,o3′,o4′), define x3:=o[|P|−1], x4:=o[|P|], x1′:=o[|P|+1], x2′:=o[|P|+2]. Restrictions to P and Q witness the two Ext-memberships, and E(x4,x1′) is the edge across the seam. (⇐) Given witnesses, combine the legal labelings on P and Q and the seam constraint E(x4,x1′) to obtain a legal labeling on B with the required boundary. □

Proposition 3 (Type congruence under appending one bit).
If Type(P)=Type(Q), then for all a∈{0,1}, Type(P·a)=Type(Q·a). In particular, Ext_{P·a}=Ext_{Q·a} and k_flag updates identically.
Proof. For k_flag≥4, Lemma 1 shows Ext_{(·)·a} depends only on Ext_{(·)} and a. Thus Ext_{P·a}=Ext_{Q·a}. The k_flag transition is determined solely by k_flag and the append operation, hence identical for P and Q. Short-length cases follow by the explicit base-case rules. □

Proposition 4 (Unsoundness of existential R-composition).
There exists an instance (Σ_out,A_0,A_1,E) and types t_b,t_c such that there is m∈Σ_out with (x,m) ∈ R_{t_b} and (m,y) ∈ R_{t_c} for some x,y, yet (x,y) ∉ R_{t_b·t_c}. Hence the rule “(∃m) R_{P·Q}(x,y) ⇐ R_P(x,m) ∧ R_Q(m,y)” is not valid in general.
Proof. Take Σ_out={a,b,c}, A_0=A_1=Σ_out, and E={(a,b),(b,c)} only. Let t_b be any type that admits a legal labeling with rightmost output a (left side arbitrary), so (x,a)∈R_{t_b} for any feasible x. Let t_c admit a legal labeling with leftmost output c (right side arbitrary), so (c,y)∈R_{t_c} for a suitable y. Choose m=b; then (x,m)∈R_{t_b} and (m,y)∈R_{t_c}. However, in the concatenation t_b·t_c, the seam would require E(a,c), which is false. Thus (x,y)∉R_{t_b·t_c}. □

Proposition 5 (Optimized computation of Ext for concatenation in O(β^6)).
For any types τ,σ with k_flag(τ),k_flag(σ)≥4, define the 3D slices
  Left_τ[o1,o2,x4] := ∃x3 (o1,o2,x3,x4)∈Ext_τ, and
  Right_σ[x1′,o3′,o4′] := ∃x2′ (x1′,x2′,o3′,o4′)∈Ext_σ.
Then for all (o1,o2,o3′,o4′),
  (o1,o2,o3′,o4′) ∈ Ext_{τ⊙σ} ⇔ ∃x4,x1′: Left_τ[o1,o2,x4] ∧ E(x4,x1′) ∧ Right_σ[x1′,o3′,o4′].
Moreover, after precomputing Left_τ and Right_σ for all τ,σ in O(β^4) time per type, Ext_{τ⊙σ} can be computed in O(β^6) time by scanning all (o1,o2,o3′,o4′)∈Σ_out^4 and testing the existential condition over (x4,x1′)∈Σ_out^2.
Proof. The equivalence is immediate from Lemma 2 by eliminating the existential witnesses x3 and x2′ into the definitions of Left_τ and Right_σ. Complexity: each 3D table has O(β^3) entries and can be filled in O(β) time per entry (by checking ∃ over one coordinate), giving O(β^4). Computing Ext_{τ⊙σ} requires O(β^4) target entries and an O(β^2) search over (x4,x1′) per entry, hence O(β^6). □

