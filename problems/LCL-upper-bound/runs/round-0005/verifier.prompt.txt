--- SYSTEM ---
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (summary so far)
- output.md (rigorously proven results so far)

Guidelines:
- notes.md: should be a readable running log of interesting work. Prefer appending. Replace only if old notes are clearly misleading. Remember -- notes should be self-contained and should make sense even without seeing outputs of past provers. 
- output.md: should be concise and rigorous. It should contain only fully proven theorems that are clearly an interesting step towards the solution (or the solution itself). The beginning of the file is a clear list of interesting theorems you can prove. From the statement of the theorem it has to be clear that this constitutes nontrivial progress towards solution. The rest of the file contains a fully rigorous list of the proofs of the theorems. Keep only proven theorems with clear proofs. If a statement is flawed and you cannot fix it, remove it from output.md and instead add it to notes.md with explanation.
- Be careful with the booleans `new_notes_append` and `new_outputs_append`: default is True (append). Use False only when deliberately rewriting everything.

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (≥200 words). Include concrete next-step suggestions. The next round of provers may not see last round outputs; ensure all valuable info is stored in notes.",
  "new_notes_md": "Markdown (KaTeX allowed). Usually appended to notes.",
  "new_notes_append": "True|False",
  "new_outputs_md": "Markdown (KaTeX allowed). Usually appended to output.md.",
  "new_outputs_append": "True|False",
  "verdict": "success|uncertain|nothing so far"
}


--- USER ---
You receive multiple prover reports. Evaluate correctness, value, and pick promising directions. Update notes.md (append/replace) with useful ideas and update output.md (append/replace) ONLY with rigorously verified results.

Prover reports (JSON):
[{"prover_id": "01", "progress_md": "Status check and gaps in output.md\n- Present: rigorous r=1 primitives: Ext-tables, k_flag, append-one-bit DP (including k=1\u21922, 2\u21923, 3\u21924), congruence under append, Ext-level concatenation (for k_flag\u22654), an O(\u03b2^6) concatenation routine, a counterexample to R-composition, \u03b4 well-defined and BFS enumeration, Type-count bound |T| \u2264 4\u00b72^{\u03b2^4}, and a reversal operator.\n- Missing: (A) A pumping bound \u2113_pump and the associated type-level pumping lemmas (they are implicitly used but not stated). (B) Stage-1 trichotomy step: a precise type-level feasible-function theorem (o(n) iff a feasible f exists) specialized to oriented paths using only Ext. (C) Stage-2 trichotomy step: a constant-round construction from per-type boundary interfaces Q_\u03c4 with complete, oriented-path-specific partition argument. (D) Associativity of Ext-level concatenation (useful for sanity checks and caching). (E) Clarification that Stage-1/2 quantification ranges over long types T_long := {\u03c4 : k_flag(\u03c4)=\u22654}, which matches the pumping-based constructions.\n\nAdditions proposed (statements, why useful, proof sketches)\n\n1) Type-level pumping (define \u2113_pump and two pumping lemmas)\n- Definition. Let T be the set of reachable types computed by Proposition 9, and \u03b4: T\u00d7{0,1}\u2192T the append successor. Define \u2113_pump := |T|. Let run(s) be the \u03b4-trajectory when reading s left-to-right from an initial length-1 seed type.\n- Lemma P1 (prefix pumping). For any input string w with |w| \u2265 \u2113_pump, there exist a decomposition w = x y z with 1 \u2264 |y| \u2264 \u2113_pump and |x y| \u2264 \u2113_pump such that for all i \u2265 0, Type(x y^i z) is constant (independent of i). Why useful: Enables length normalization of contexts to [\u2113_pump, \u2113_pump+1] and underpins the o(n)\u21d2feasible f construction.\n  Proof sketch. Along the first \u2113_pump states of the \u03b4-run there is a repetition by pigeonhole, say after positions i<j\u2264\u2113_pump with the same type. Let y := w[i+1..j], and x,z be the corresponding prefix/suffix. Since \u03b4 is a DFA on Types (Proposition 9) and congruence holds (Proposition 3), repeating y preserves the final Type.\n- Lemma P2 (periodic pumping). For any nonempty u there exist a,b with a+b \u2264 \u2113_pump such that Type(u^{a+bi}) is invariant for all i\u22650. Why useful: Allows injecting arbitrarily long repeated contexts of the same Type (used to space out separators in the two-stage constructions). Proof sketch. Run \u03b4 on u,u^2,\u2026; within \u2113_pump+1 steps two Types repeat, say after exponents a and a+b; then \u03b4-closure yields Type(u^{a+bi}) fixed.\n\n2) Ext-level concatenation for all k_flags\n- Lemma C (general concatenation). For any P,Q (no restriction on k_flag) and B=P\u00b7Q, for all (o1,o2,o3\u2032,o4\u2032),\n  (o1,o2,o3\u2032,o4\u2032)\u2208Ext_B iff \u2203 x3,x4,x1\u2032,x2\u2032: (o1,o2,x3,x4)\u2208Ext_P, (x1\u2032,x2\u2032,o3\u2032,o4\u2032)\u2208Ext_Q, and E(x4,x1\u2032).\n  Why useful: Allows concatenation in verifiers even if a few short types appear (e.g., when S is short), and simplifies uniform API. Proof sketch. Identical to Lemma 2; coordinate equalities when k_flag<4 are harmless because the boundary map B_k is definitional.\n- Lemma A (associativity). For any P,Q,R, Ext_{(P\u00b7Q)\u00b7R} = Ext_{P\u00b7(Q\u00b7R)}. Why useful: sanity check and enables memoization policies independent of parenthesization. Proof sketch. Expand both sides with Lemma C: both characterize the set of boundary quadruples admitting witnesses (x3,x4,x1\u2032,x2\u2032) at the first seam and (y3,y4,y1\u2032,y2\u2032) at the second seam with E-seam constraints; the conjunctions are equivalent by rebracketing witnesses.\n\n3) Stage-1 (\u03a9(n) vs o(n)) \u2014 feasible f theorem at the type level\n- Definition (domain restriction to long types). Let T_long := {\u03c4\u2208T : k_flag(\u03c4)=\u22654}. Define f: T_long \u00d7 {0,1}^2 \u00d7 T_long \u2192 \u03a3_out^2. For each (\u03c4_L,s,\u03c4_R), f(\u00b7)=(\u03b11,\u03b12) must satisfy \u03b1i\u2208A_{s[i]} and E(\u03b11,\u03b12).\n- Verification condition (Ext-based). For all \u03c4_b,\u03c4_c\u2208T_long and s1,s2\u2208{0,1}^2 and all \u03c4_a,\u03c4_d\u2208T_long (these only affect \u03b1_L,\u03b1_R), let \u03b1_L := second output of f(\u03c4_a,s1,\u03c4_b) and \u03b1_R := first output of f(\u03c4_c,s2,\u03c4_d). Require \u2203(o1,o2,o3,o4)\u2208Ext_{\u03c4_b \u2299 \u03c4_c} with E(\u03b1_L,o1) and E(o4,\u03b1_R). Here \u2299 is Ext-concatenation on long types.\n- Theorem S1 (equivalence). An r=1, \u03b2-normalized LCL on globally oriented paths has deterministic complexity o(n) iff a feasible f as above exists. Why useful: This cleanly separates \u03a9(n) from o(n) and is implementable in NEXPTIME using only T_long and Ext.\n  Proof sketch (\u21d2). Given an o(n)-round algorithm A, fix n large and choose s\u226bT(n) so that A\u2019s runtime on n-node instances is <0.1s. For any w\u2208{0,1}^{1..\u2113_pump}, choose w^+ with Type(w^+)=Type(w) and |w^+|\u2208[s,s+\u2113_pump] (Lemma P1). For any tuple (\u03c4_L,s,\u03c4_R) with long \u03c4_L,\u03c4_R, pick representatives w_L^+,w_R^+ realizing \u03c4_L,\u03c4_R and define f(\u03c4_L,s,\u03c4_R) as A\u2019s output on the 2-node window S when run on the pumped path w_L^+ \u00b7 S \u00b7 w_R^+ with arbitrary distinct IDs consistent inside the 0.1s halos. To verify feasibility, consider any adjacent separators (S1 next to \u03c4_b) and (S2 next to \u03c4_c). Build a cycle G\u2032 by concatenating w_a^+, S1, w_b^+, w_c^+, S2, w_d^+, and run A; legality implies the existence of a labeling of the middle w_b^+\u00b7w_c^+ consistent with \u03b1_L,\u03b1_R. By Lemma 11 and Lemma C, the boundary witness lives in Ext_{\u03c4_b\u2299\u03c4_c}, yielding the required (o1,o2,o3,o4). (\u21d0). Given f, place separators in O(log* n) rounds with spacing K\u2273\u2113_pump using a standard MIS on the directed path. Label each separator\u2019s 2 nodes by f(\u00b7), producing boundary colors \u03b1_L,\u03b1_R on either side of each middle block. For a middle block with long type \u03c4_b\u2299\u03c4_c, the Ext-witness in Ext_{\u03c4_b\u2299\u03c4_c} provides a legal completion consistent with the seams. This yields an O(log* n) algorithm. The construction does not need reversals on globally oriented paths.\n- NEXPTIME verification. Deterministically compute T_long and Ext_{\u03c4\u2299\u03c3} for all \u03c4,\u03c3\u2208T_long (Proposition 5). Nondeterministically guess f; verify all constraints by membership tests in Ext_{\u03c4\u2299\u03c3} and E. The number of checks is |T_long|^4\u00b74; total time 2^{poly(\u03b2)}.\n\n4) Stage-2 (O(1) vs \u03a9(log* n)) \u2014 per-type boundary interfaces and constant-round construction\n- Witness. For each \u03c4\u2208T_long, guess Q_\u03c4=(L1_\u03c4,L2_\u03c4,R2_\u03c4,R1_\u03c4)\u2208Ext_\u03c4.\n- Checks.\n  (a) Tiling per \u03c4: E(L1_\u03c4,L2_\u03c4), E(R2_\u03c4,R1_\u03c4), and wrap E(R1_\u03c4,L1_\u03c4) (so copies of \u03c4 can be tiled). Already implied by Ext_\u03c4 computed from legal colorings, but we keep the explicit checks.\n  (b) Universal bridging: For all \u03c4_left,\u03c4_S,\u03c4_right with \u03c4_left,\u03c4_right\u2208T_long and \u03c4_S arbitrary (short or long), require \u2203(o1,o2,o3,o4)\u2208Ext_{\u03c4_S} with E(R1_{\u03c4_left},o1) and E(o4,L1_{\u03c4_right}). For \u03c4_S empty, this reduces to E(R1_{\u03c4_left},L1_{\u03c4_right}). Use Lemma C to allow short \u03c4_S.\n- Theorem S2 (construction). If such {Q_\u03c4} exist, there is an O(1)-round deterministic algorithm on globally oriented paths. Why useful: Cleanly separates O(1) from \u0398(log* n) and yields a verifiable certificate of constant-time solvability.\n  Proof sketch. In O(1) rounds, compute a partition into \u201clong periodic\u201d and \u201cshort/irregular\u201d subpaths with parameters (\u2113_width,\u2113_count,\u2113_pattern) := (\u2113_pump,2\u2113_pump+2,\u2113_pump); for oriented paths, a specialization of Lemma 22 suffices (orientation is given). On each long periodic block P with primitive pattern of length \u2264\u2113_pump and length \u2265\u2113_count, its type \u03c4 is long; tile P by repeats of \u03c4 using E(R1_\u03c4,L1_\u03c4); interior legality follows from Q_\u03c4\u2208Ext_\u03c4. Each short/irregular separator S (any k_flag) is filled using the existential witness from Ext_{\u03c4_S} to attach to the adjacent long blocks\u2019 boundary colors, by (b). Endpoints require no special handling on oriented paths. Runtime is O(1) as all decisions take radius O(\u2113_pump).\n- NEXPTIME verification. Guess {Q_\u03c4} over T_long. Compute Ext tables once. Verify (a) per \u03c4 and (b) for all triples (\u03c4_left,\u03c4_S,\u03c4_right), using Ext_{\u03c4_S} and E. Number of checks is |T_long| + |T_long|^2\u00b7|T| = 2^{poly(\u03b2)}; each check is polynomial in \u03b2.\n\n5) Implementation-level refinements for verifiers\n- Restricting to long types. Both Stage-1 and Stage-2 certificates and universal checks can safely limit \u03c4 ranging over T_long on the left/right contexts. Middle \u03c4_S in Stage-2 may be any type; Lemma C covers short \u03c4_S.\n- Precomputation plan. Compute T (BFS), split T_long and T_short. Precompute Left_\u03c4 and Right_\u03c4 for \u03c4\u2208T (for Stage-2 we need short \u03c4 too). Materialize Ext_{\u03c4\u2299\u03c3} for \u03c4,\u03c3\u2208T_long using Proposition 5. Cache membership queries for Ext_{\u03c4_S} via hash/table lookups.\n\n6) Extra sanity: small lemmas and examples\n- Lemma M (nonemptiness monotonicity under concatenation). If Ext_P and Ext_Q are nonempty and there exists at least one seam pair (x4,x1\u2032) with E(x4,x1\u2032), then Ext_{P\u00b7Q} is nonempty. Why useful: quick diagnostics when pruning infeasible candidates. Proof sketch. Choose any quadruples realizing x4 and x1\u2032; then Lemma C yields a witness.\n- Example (proper 2-coloring on oriented paths). \u03a3_out={a,b}, A_0=A_1={a,b}, E forbids equal neighbors. Stage-1 admits feasible f (log* algorithm exists); Stage-2 fails (cannot have wrap E(R1_\u03c4,L1_\u03c4) for a single \u03c4), so the verifier classifies \u0398(log* n).\n- Example (constant label). If \u2203c with (c,c)\u2208E and c\u2208A_0\u2229A_1, set f constant and Q_\u03c4=(c,c,c,c); both stages accept (O(1)).\n\nComplexity recap (unchanged asymptotically)\n- Precomputation: |T| \u2264 4\u00b72^{\u03b2^4}. BFS and Ext tables in 2^{poly(\u03b2)} time/space.\n- Stage-1: guess f over T_long\u00d7{0,1}^2\u00d7T_long; verify O(|T_long|^4) constraints using Ext_{\u00b7\u2299\u00b7} in O(1) each \u2192 2^{poly(\u03b2)}.\n- Stage-2: guess Q_\u03c4 over T_long; verify per-type tiling and |T_long|^2\u00b7|T| bridging constraints \u2192 2^{poly(\u03b2)}.\n\nObstacles and pitfalls addressed\n- Short types in concatenation: handled by Lemma C; Stage-1 still quantifies only over long contexts (as in the pumping-based definition).\n- Seam indexing: clarified that seams meet o1 on the left and o4 on the right under the (L1,L2,R2,R1) convention.\n- MIS/orientation: On globally oriented paths, no reversal and the standard O(log* n) MIS suffices for Stage-1\u2019s construction; Stage-2 uses a constant-radius partition specialized to oriented paths (orientation is already globally consistent).\n\nNext concrete steps\n- Integrate Lemmas P1, P2, C, A, M and the theorems S1, S2 into output.md with concise proofs (as above). Explicitly define \u2113_pump := |T| and note it is computable in 2^{poly(\u03b2)}.\n- Amend Stage-1/2 verifier specs in outputs to quantify over T_long for the left/right contexts and to use Ext_{\u03c4_S} for arbitrary \u03c4_S in Stage-2 bridging.\n- Provide a short appendix with the MIS-based O(log* n) separator placement and the constant-radius partition for oriented paths (parameters and radii explicitly spelled out).\n- Add a tiny regression suite (\u03b2\u2208{2,3}) to test: (i) pumping decomposition found via \u03b4; (ii) associativity of Ext-concatenation on random instances; (iii) Stage-1 acceptance on trivial/all-allowed LCL; (iv) Stage-2 rejection on proper 2-coloring.\n"}]

Current notes.md:
Corrections and key lemmas to record

1) Correct append-one-bit recurrence (r=1)
Given a type t with Ext_t ⊆ Σ_out^4 over boundary (L1,L2,R2,R1) and an appended input bit a, the new type t′ has boundary (L1′,L2′,R2′,R1′) = (L1,L2, old R1, new), i.e., R2′ = R1 and R1′ is the label of the appended node. Formally, for each candidate quadruple (x1,x2,x3,x4) ∈ Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [x4 ∈ A_a and E(x3,x4) and ∃ z ∈ Σ_out: (x1,x2,z,x3) ∈ Ext_t].
This yields an O(β^5) DP to fill Ext_{t′} by scanning all (x1,x2,x3,x4) and checking ∃z.

Congruence lemma (needed): If Type(P)=Type(Q), then for all a ∈ {0,1}, Type(Pa)=Type(Qa). Proof sketch: The predicate “there exists an interior completion consistent with boundary assignments” over D1∪D2 is preserved under appending one node by the above DP rule, which depends only on Ext_t and a.

2) Concatenation of summaries (r=1)
If Summ(P) has Ext_P and Summ(Q) has Ext_Q, then the concatenation B=P·Q has boundary (P.left endpoint, P.left neighbor, Q.right neighbor, Q.right endpoint) and
  (o1,o2,o3′,o4′) ∈ Ext_B ⇔ ∃ x3,x4,x1′,x2′ ∈ Σ_out: (o1,o2,x3,x4) ∈ Ext_P, (x1′,x2′,o3′,o4′) ∈ Ext_Q, and E(x4,x1′).
Then R_B can be derived from Ext_B as usual.

3) Counterexample to R-composition via ∃m
Let Σ_out={a,b,c}, A_0=A_1=Σ_out. Let E={a→b, b→c} only. Suppose t_b admits a boundary tuple with right endpoint a, and t_c admits a boundary tuple with left endpoint c (interiors arbitrary but extendible). Then choose m=b. We have (x,m) ∈ R_{t_b} for any x with a valid left edge, and (m,y) ∈ R_{t_c} for suitable y. But the concatenation t_b·t_c requires the seam edge a→c, which is forbidden. Hence ∃m composition of R_t is not sound; use Ext-level concatenation and R_B instead.
Additions and fixes (r=1)

A) Correct k=2→3 base-case update
Let t=(b1,b2) and t′=t·a (length 3). Then
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [x3=x2, x1∈A_{b1}, x2∈A_{b2}, x4∈A_a, E(x1,x2), E(x2,x4)].
This replaces any prior statement that involved x2∈A_a.

B) Type representation and congruence
Define Type(t) := (b_in(t), Ext_t, k_flag(t)), where k_flag ∈ {1,2,3,≥4} indicates whether boundary coordinates coincide due to short length. Then the congruence lemma holds in the form:
  If Type(P)=Type(Q), then for all a∈{0,1}, Type(Pa)=Type(Qa).
Proof: case split on k_flag using the explicit base-case rules for k_flag∈{1,2,3} and the general append recurrence for k_flag=≥4.
Remark: Ext equality alone does not determine |t| (e.g., with E self-loops and A_0=A_1, Ext_{len 2} = Ext_{len 4}). Hence the k_flag is necessary for a length-agnostic update routine.

C) Enumeration fix
In the BFS over types, key the dictionary by the full Type(t), including k_flag. After the first transition to k_flag=≥4, all descendants remain in k_flag=≥4 and subsequent δ updates are length-agnostic.
Additions: Stage-1 and Stage-2 specifications at the Ext level (r=1, oriented paths)

Notation. Σ_out has size β. For an input word t with bits b_in(t) ∈ {0,1}^{|t|}, let Ext_t ⊆ Σ_out^4 denote the set of boundary quadruples (L1,L2,R2,R1) = (o[1],o[2],o[|t|-1],o[|t|]) that admit an interior completion o consistent with node constraints o[i]∈A_{b_in(t)[i]} and edge constraints (o[i],o[i+1])∈E. Types are Type(t)=(Ext_t, k_flag(t)), where k_flag∈{1,2,3,≥4} encodes short-length degeneracies. Concatenation of types τ⊙σ is defined by the Ext-level concatenation rule (see outputs.md) and k_flag update.

Stage-1 (Ω(n) vs o(n)): type-level feasible function
- Universe: the finite set of types T obtained by BFS from k=1 under the append-one-bit updates (keyed by (Ext,k_flag)). For τ,σ∈T, the Ext of τ⊙σ is defined by Ext-level concatenation.
- Definition (feasible f). A function f: T × {0,1}^2 × T → Σ_out^2 mapping (τ_L, s, τ_R) to (α1,α2) is feasible if:
  (i) Node/window constraints: αi ∈ A_{s[i]} for i=1,2 and (α1,α2) ∈ E (i.e., E(α1,α2) holds).
  (ii) Universal extendibility across two separators: for all τ_a,τ_b,τ_c,τ_d∈T and s1,s2∈{0,1}^2, letting α_L := second component of f(τ_a,s1,τ_b) and α_R := first component of f(τ_c,s2,τ_d), we require
      ∃ (o1,o2,o3,o4) ∈ Ext_{τ_b ⊙ τ_c} with E(α_L,o1) and E(o4,α_R).
  Comment: The quantification over τ_a and τ_d is stronger than necessary but safe; a weaker version quantifies only over τ_b,τ_c and s1,s2. Indexing uses our convention (L1,L2,R2,R1); thus o1 and o4 are the first and last outputs of the middle block of type τ_b⊙τ_c.
- NEXPTIME check: deterministically enumerate T and all Ext_{τ} and on-demand Ext_{τ⊙σ}; nondeterministically guess f; verify (i) and (ii) exhaustively. Complexity is 2^{poly(N)} in the problem description size N.
- Status: We still owe a self-contained proof that “o(n) algorithm exists iff a feasible f exists” at the Ext level (the intended replacement of the paper’s feasible-function lemma). This will rely only on our Ext-append and Ext-concat lemmas and a standard pumping argument specialized to r=1.

Stage-2 (O(1) vs Ω(log* n)): per-type boundary-interface witness
- For each τ∈T with k_flag(τ)≥4, guess Q_τ=(L1_τ,L2_τ,R2_τ,R1_τ) with Q_τ ∈ Ext_τ. Enforce:
  (a) Local consistency and tiling: E(L1_τ,L2_τ), E(R2_τ,R1_τ), and wrap E(R1_τ,L1_τ). Intuition: long blocks of type τ can be tiled by copies using the same boundary outputs.
  (b) Bridging across any middle type (including empty): for all τ_left,τ_S,τ_right ∈ T, require either
      - if τ_S has k_flag≥1: ∃ (o1,o2,o3,o4) ∈ Ext_{τ_S} with E(R1_{τ_left},o1) and E(o4,L1_{τ_right}); or
      - if τ_S is empty: E(R1_{τ_left},L1_{τ_right}).
- Decision logic: if witnesses {Q_τ} exist and pass (a)–(b), classify O(1). Else, if a Stage-1 feasible f exists, classify Θ(log* n). Otherwise, classify Θ(n).
- Status: We still owe a concrete constant-radius construction on oriented paths from {Q_τ} (e.g., a partition/tiling routine parametrized by fixed radii ℓ_width, ℓ_pattern, ℓ_count) and a proof that the produced labeling is legal. Short types (k_flag<4) are treated as separators τ_S in (b).

Faster concatenation (proven and moved to outputs.md)
- Precompute for each τ the 3D slices: Left_τ[o1,o2,x4] := ∃x3 (o1,o2,x3,x4)∈Ext_τ, and Right_τ[x1′,o3′,o4′] := ∃x2′ (x1′,x2′,o3′,o4′)∈Ext_τ.
- Then (o1,o2,o3′,o4′)∈Ext_{τ⊙σ} iff ∃x4,x1′: Left_τ[o1,o2,x4] ∧ E(x4,x1′) ∧ Right_σ[x1′,o3′,o4′]. This allows computing Ext_{τ⊙σ} in O(β^6) time after O(β^4) precomputation per type.

Sanity checks (kept as examples)
- Trivial LCL (A_0=A_1=Σ_out, E complete): Ext_τ=Σ_out^4 for all τ; Stage-2 witness exists trivially ⇒ O(1).
- Equality LCL (E={(x,x)}): take Q_τ=(c,c,c,c) ⇒ O(1).
- Proper 2-coloring: Stage-2 fails; Stage-1 feasible f should exist ⇒ Θ(log* n).
- Linear cases with incompatible seams: Stage-1 fails ⇒ Ω(n).
Updates and clarifications (r=1, oriented paths)

1) Base-case updates finalized
- k=1→2 is special and cannot be derived from the general append recurrence without over-constraining x1=x2; we record an explicit rule in outputs.md.
- k=3→4 is also added explicitly (although it follows from the same recurrence if stated for k≥2). This ensures δ can move from short types to k_flag≥4 deterministically.

2) Type-count bound corrected
Type(t) consists of (Ext_t, k_flag(t)) only; boundary input bits are not part of Type. Hence the number of types satisfies
  |T| ≤ 4 · 2^{β^4}.
The earlier 16 · 2^{β^4} bound mixed in boundary input bits unnecessarily.

3) δ well-defined and BFS enumeration
- Seeds: k=1 types for b∈{0,1} (Ext_{(b)} = {(x,x,x,x): x∈A_b}).
- Transitions: use base-cases for k<4 (1→2, 2→3, 3→4) and Lemma 1 for k≥4. By congruence, δ(Type, a) depends only on (Ext, k_flag) and a.
- Termination and complexity: at most |T| ≤ 4·2^{β^4} insertions; each append is O(β^5) in the k≥4 regime (base-cases are ≤ O(β^4)); total time/space 2^{poly(β)}.

4) Reversal operator (optional but helpful)
Define Rev(τ) = (Ext_τ^R, k_flag(τ)) with Ext_τ^R := { (y1,y2,y3,y4) : (y4,y3,y2,y1) ∈ Ext_τ }. Then Rev(Rev(τ))=τ and Ext_{Rev(τ) ⊙ Rev(σ)} = (Ext_{σ ⊙ τ})^R.

5) Stage-1 and Stage-2 (status)
- Stage-1 (Ω(n) vs o(n)): the feasible function f: T × {0,1}^2 × T → Σ_out^2 with the universal Ext-based check (seams E(α_L, o1), E(o4, α_R), using the (L1,L2,R2,R1) ordering) is the right formal object. We still need a fully self-contained proof of the equivalence “o(n) iff such f exists”.
- Stage-2 (O(1) vs Ω(log* n)): the per-type witness Q_τ∈Ext_τ for k_flag≥4 with tiling and universal bridging checks is plausible. A complete constant-radius construction on oriented paths remains to be written and verified.

6) Sanity and regression items
- β=2 trivial LCLs and equality LCL check the base-cases and concatenation routines.
- Reconfirm the 3-color counterexample for R-composition via ∃m.
- Maintain an indexing reminder: Ext quadruples are ordered (L1,L2,R2,R1); in seam checks across a middle block of type τ_b⊙τ_c, the left seam meets o1 and the right seam meets o4.


Current output.md (if any):
Setup and definitions (r=1, globally oriented paths)
- Let Σ_out be a finite output alphabet of size β. Let A_0,A_1 ⊆ Σ_out be the allowed outputs at nodes with input bit 0 or 1, respectively. Let E ⊆ Σ_out × Σ_out be the allowed directed edge relation (u→v allowed iff (u,v)∈E). For an input word t ∈ {0,1}^k with k≥1, a labeling o ∈ Σ_out^k is legal if o[i]∈A_{t[i]} for all i, and (o[i],o[i+1])∈E for all 1≤i<k.
- For k≥4, define Ext_t ⊆ Σ_out^4 as the set of boundary quadruples (L1,L2,R2,R1) that extend to a legal labeling o with L1=o[1], L2=o[2], R2=o[k−1], R1=o[k]. For k≤3, Ext_t is defined with the same 4-tuple container but with the obvious coordinate equalities imposed by overlaps (tracked by k_flag ∈ {1,2,3,≥4}). The Type of t is Type(t) := (Ext_t, k_flag(t)).

Lemma 1 (Append-one-bit recurrence; k_flag≥4 case).
Let t be an input word with k_flag(t)≥4, and let t′ := t·a be t with one bit a ∈ {0,1} appended on the right. Then for all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x4 ∈ A_a and E(x3,x4) and ∃z∈Σ_out: (x1,x2,z,x3) ∈ Ext_t ].
Proof. (⇒) From (x1,x2,x3,x4)∈Ext_{t′} there is a legal labeling o′ on t′ with o′[1]=x1, o′[2]=x2, o′[k]=x3, o′[k+1]=x4. Node/edge constraints give x4∈A_a and E(x3,x4). Let z := o′[k−1]; then the restriction o := o′[1..k] is a legal labeling of t with boundary (x1,x2,z,x3), so (x1,x2,z,x3)∈Ext_t. (⇐) Conversely, given z with (x1,x2,z,x3)∈Ext_t, pick a witnessing legal labeling o on t. Extend by setting o′[1..k]=o and o′[k+1]=x4. If x4∈A_a and E(x3,x4), then o′ is legal on t′ and has boundary (x1,x2,x3,x4), so (x1,x2,x3,x4)∈Ext_{t′}. □

Base-case update (k=2→3).
Let t=(b1,b2) and t′=t·a. Then for all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x3=x2, x1∈A_{b1}, x2∈A_{b2}, x4∈A_a, E(x1,x2), E(x2,x4) ].
This follows by unfolding the definition when positions 2 and 3 coincide in the boundary coordinates.

Lemma 2 (Ext-level concatenation; k_flag≥4).
Let P and Q be input words with k_flag(P), k_flag(Q) ≥4, and let B := P·Q (concatenation). Then for all (o1,o2,o3′,o4′)∈Σ_out^4,
  (o1,o2,o3′,o4′) ∈ Ext_B ⇔ ∃ x3,x4,x1′,x2′ ∈ Σ_out such that
    (o1,o2,x3,x4) ∈ Ext_P, (x1′,x2′,o3′,o4′) ∈ Ext_Q, and E(x4,x1′).
Proof. (⇒) Given a legal labeling on B with boundary (o1,o2,o3′,o4′), define x3:=o[|P|−1], x4:=o[|P|], x1′:=o[|P|+1], x2′:=o[|P|+2]. Restrictions to P and Q witness the two Ext-memberships, and E(x4,x1′) is the edge across the seam. (⇐) Given witnesses, combine the legal labelings on P and Q and the seam constraint E(x4,x1′) to obtain a legal labeling on B with the required boundary. □

Proposition 3 (Type congruence under appending one bit).
If Type(P)=Type(Q), then for all a∈{0,1}, Type(P·a)=Type(Q·a). In particular, Ext_{P·a}=Ext_{Q·a} and k_flag updates identically.
Proof. For k_flag≥4, Lemma 1 shows Ext_{(·)·a} depends only on Ext_{(·)} and a. Thus Ext_{P·a}=Ext_{Q·a}. The k_flag transition is determined solely by k_flag and the append operation, hence identical for P and Q. Short-length cases follow by the explicit base-case rules. □

Proposition 4 (Unsoundness of existential R-composition).
There exists an instance (Σ_out,A_0,A_1,E) and types t_b,t_c such that there is m∈Σ_out with (x,m) ∈ R_{t_b} and (m,y) ∈ R_{t_c} for some x,y, yet (x,y) ∉ R_{t_b·t_c}. Hence the rule “(∃m) R_{P·Q}(x,y) ⇐ R_P(x,m) ∧ R_Q(m,y)” is not valid in general.
Proof. Take Σ_out={a,b,c}, A_0=A_1=Σ_out, and E={(a,b),(b,c)} only. Let t_b be any type that admits a legal labeling with rightmost output a (left side arbitrary), so (x,a)∈R_{t_b} for any feasible x. Let t_c admit a legal labeling with leftmost output c (right side arbitrary), so (c,y)∈R_{t_c} for a suitable y. Choose m=b; then (x,m)∈R_{t_b} and (m,y)∈R_{t_c}. However, in the concatenation t_b·t_c, the seam would require E(a,c), which is false. Thus (x,y)∉R_{t_b·t_c}. □

Proposition 5 (Optimized computation of Ext for concatenation in O(β^6)).
For any types τ,σ with k_flag(τ),k_flag(σ)≥4, define the 3D slices
  Left_τ[o1,o2,x4] := ∃x3 (o1,o2,x3,x4)∈Ext_τ, and
  Right_σ[x1′,o3′,o4′] := ∃x2′ (x1′,x2′,o3′,o4′)∈Ext_σ.
Then for all (o1,o2,o3′,o4′),
  (o1,o2,o3′,o4′) ∈ Ext_{τ⊙σ} ⇔ ∃x4,x1′: Left_τ[o1,o2,x4] ∧ E(x4,x1′) ∧ Right_σ[x1′,o3′,o4′].
Moreover, after precomputing Left_τ and Right_σ for all τ,σ in O(β^4) time per type, Ext_{τ⊙σ} can be computed in O(β^6) time by scanning all (o1,o2,o3′,o4′)∈Σ_out^4 and testing the existential condition over (x4,x1′)∈Σ_out^2.
Proof. The equivalence is immediate from Lemma 2 by eliminating the existential witnesses x3 and x2′ into the definitions of Left_τ and Right_σ. Complexity: each 3D table has O(β^3) entries and can be filled in O(β) time per entry (by checking ∃ over one coordinate), giving O(β^4). Computing Ext_{τ⊙σ} requires O(β^4) target entries and an O(β^2) search over (x4,x1′) per entry, hence O(β^6). □
Proposition 6 (Base-case update; k=1→2).
Let t=(b) be a length-1 input and t′:=t·a the length-2 input obtained by appending a∈{0,1}. For all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x1 = x3, x2 = x4, x1 ∈ A_b, x2 ∈ A_a, and E(x1,x2) ].
Proof. A legal labeling on t′ has outputs (o1,o2) with o1∈A_b, o2∈A_a and E(o1,o2); its boundary tuple is (o1,o2,o1,o2), giving the stated equalities and constraints. The converse is immediate. □

Proposition 7 (Base-case update; k=3→4).
Let t=(b1,b2,b3) be a length-3 input and t′:=t·a the length-4 input obtained by appending a∈{0,1}. For all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x1∈A_{b1}, x2∈A_{b2}, x3∈A_{b3}, x4∈A_a, and E(x1,x2), E(x2,x3), E(x3,x4) ].
Proof. Unfold the definition: Ext_{t′} collects exactly the boundary tuples of legal labelings on the 4-node path with the given input bits, which are precisely those satisfying the listed node and edge constraints. □

Lemma 8 (Type-count bound).
With Type(t):=(Ext_t, k_flag(t)) and Ext_t⊆Σ_out^4, the number of distinct types obeys
  |T| ≤ 4 · 2^{β^4}.
Proof. For each of the four values of k_flag∈{1,2,3,≥4}, Ext_t can be any subset of Σ_out^4 (subject to feasibility), so the total number of pairs (Ext, k_flag) is at most 4·2^{|Σ_out^4|} = 4·2^{β^4}. □

Proposition 9 (δ well-defined; deterministic BFS enumeration in 2^{poly(β)} time/space).
Let δ map a type τ and an appended bit a∈{0,1} to the type of the one-bit extension. Define δ by:
- If k_flag(τ)=1 and input bit inside τ is b (implicitly recoverable as A_b = { x : (x,x,x,x) ∈ Ext_τ }), compute Ext of the 2-node type by Proposition 6.
- If k_flag(τ)=2, use the explicit k=2→3 update (already in outputs.md).
- If k_flag(τ)=3, use Proposition 7.
- If k_flag(τ)≥4, use Lemma 1.
Then δ(τ,a) depends only on τ and a (by Proposition 3), not on the particular representative. A deterministic BFS that starts from all length-1 seeds (t=(0) and t=(1)), repeatedly applies δ(·,0) and δ(·,1), and interns types by equality of (Ext, k_flag), halts after at most |T| insertions and enumerates all reachable types. Each transition costs O(β^5) in the k_flag≥4 regime (base-cases are ≤O(β^4)). Since |T| ≤ 4·2^{β^4}, the total time and space are 2^{poly(β)}. □

Lemma 10 (Reversal operator; basic properties).
Define, for any type τ=(Ext_τ,k_flag(τ)), the reversed type Rev(τ):=(Ext_τ^R, k_flag(τ)), where
  Ext_τ^R := { (y1,y2,y3,y4) ∈ Σ_out^4 : (y4,y3,y2,y1) ∈ Ext_τ }.
Then Rev(Rev(τ))=τ. Moreover, for any types τ,σ with k_flag≥4,
  Ext_{Rev(τ) ⊙ Rev(σ)} = (Ext_{σ ⊙ τ})^R.
Proof. The involution Rev(Rev(τ))=τ is immediate from the definition. For concatenation, note that reversing P·Q swaps the order and reverses boundary coordinates. Applying Lemma 2 to σ⊙τ and then reversing both sides yields the stated identity. □

