{
  "progress_md": "Round 0006 \u2014 audit, small lemmas, optimizations, and checks\n\nSummary of what is already solid in output.md\n- Core r=1 machinery is in place: (i) base cases k=1\u21922, 2\u21923, 3\u21924 and the general append-one-bit recurrence; (ii) congruence under append (without carrying the leftmost input bit); (iii) concatenation for k_flag\u22654 and, more importantly, for all k_flag; (iv) associativity; (v) a clean NEXPTIME preprocessing (enumerate Types via \u03b4) and Stage-1 trichotomy (o(n) iff a feasible f exists) with both directions proved; (vi) pumping lemmas with \u2113_pump := |T|; (vii) a counterexample to R-composition; (viii) an O(\u03b2^6) concatenation routine.\n\nGaps and minor clarifications spotted in output.md\n- \u03b4 base case for k_flag=1 (Proposition 9): it currently says \u201cinput bit inside \u03c4 is b (implicitly recoverable as A_b = {x : (x,x,x,x) \u2208 Ext_\u03c4})\u201d. The proof does not need the bit b, only the set S_\u03c4 := {x : (x,x,x,x) \u2208 Ext_\u03c4}. Suggest stating the k=1\u21922 update directly in terms of S_\u03c4 rather than referring to a recovered b. This also cleanly covers the degenerate case A_0 = A_1 where b is not uniquely identifiable but S_\u03c4 still determines the update.\n- End segments in the Stage-1 (\u21d0) construction: the proof handles \u201cmiddle blocks\u201d between two separators. Paths have endpoints; these produce one-sided blocks adjoining a single separator. A short lemma (provided below) showing how to fill endpoints from Ext without the right/left seam removes any doubt.\n- Optional but helpful: document a faster append-one-bit update (O(\u03b2^4) instead of O(\u03b2^5)) via 3D slices, analogous to the O(\u03b2^6) concatenation optimization.\n- Quantifier economy in Stage-1 verification: the universal check can be reformulated to range over the sets of attainable \u03b1_L, \u03b1_R values induced by f, eliminating explicit quantification over \u03c4_a, \u03c4_d (details below). While worst-case complexity is not asymptotically improved, the reformulation reduces constant factors and clarifies intent.\n\nLemma A \u2014 \u03b4 base case k_flag=1 can be stated without \u201crecovering b\u201d\nStatement.\n- Let \u03c4 be a Type with k_flag(\u03c4)=1 and Ext_\u03c4 given. Define S_\u03c4 := {x \u2208 \u03a3_out : (x,x,x,x) \u2208 Ext_\u03c4}. For any appended bit a, Ext_{\u03b4(\u03c4,a)} consists exactly of the tuples (x1,x2,x3,x4) with x1=x3, x2=x4, x1\u2208S_\u03c4, x2\u2208A_a and E(x1,x2).\nWhy useful here.\n- Removes the (unneeded) reference to the internal input bit and works uniformly even when A_0=A_1.\nSketch proof.\n- Immediate from Proposition 6 by observing that Ext_{(b)} encodes A_b as S_\u03c4.\n\nLemma B \u2014 Endpoint completion in Stage-1 (\u21d0)\nStatement.\n- In the Stage-1 construction with separators spaced by K=\u2113_pump+4, the remaining end segments (from a path endpoint to the nearest separator) admit a legal completion consistent with the separator\u2019s seam color. Concretely, suppose the right endpoint of a block has seam color \u03b1_R (first output of the separator just to its right). Let P be the (one-sided) left block. There exists a labeling of P whose rightmost color o4 and last-but-one o3 yield a quadruple (o1,o2,o3,o4)\u2208Ext_P with E(o4, \u03b1_R). A symmetric claim holds for right blocks with a left seam \u03b1_L.\nWhy useful here.\n- Closes the small gap in the Stage-1 (\u21d0) proof for finite directed paths.\nSketch proof.\n- If the block length \u2264 2K\u22122, the Type of P is long. Consider Ext_P and the set End(P):={o4 : \u2203(o1,o2,o3,o4)\u2208Ext_P}. Since A,E guarantee at least one legal labeling on any finite input segment encountered during \u03b4-enumeration, Ext_P\u2260\u2205. If there exists o4\u2208End(P) with E(o4, \u03b1_R), any witnessing quadruple completes the block. If no such o4 exists, then Ext_{P\u00b7Q} would be empty for any right context Q starting with \u03b1_R, contradicting that the actual global instance is solvable (the separator labeling is chosen from a feasible f). This contradiction formalizes by taking Q to be the actual right context used in the construction and invoking Lemma 11.\n\nLemma C \u2014 Quantifier minimization for the feasible-function check\nStatement.\n- Given a guessed f: T_long\u00d7{0,1}^2\u00d7T_long\u2192\u03a3_out^2, define for each \u03c4_b and s\u2208{0,1}^2:\n  OutR2(\u03c4_b,s) := { second(f(\u03c4_a,s,\u03c4_b)) : \u03c4_a \u2208 T_long };\n  and for each \u03c4_c and s\u2032: OutL1(\u03c4_c,s\u2032) := { first(f(\u03c4_c,s\u2032,\u03c4_d)) : \u03c4_d \u2208 T_long }.\n- The universal extendibility clause in Theorem 15 is equivalent to: for all \u03c4_b,\u03c4_c and s1,s2, and for all \u03b1_L \u2208 OutR2(\u03c4_b,s1), \u03b1_R \u2208 OutL1(\u03c4_c,s2), there exists (o1,o2,o3,o4) \u2208 Ext_{\u03c4_b\u2299\u03c4_c} with E(\u03b1_L,o1), E(o4,\u03b1_R).\nWhy useful here.\n- Eliminates explicit quantification over \u03c4_a, \u03c4_d in verification, reducing the number of cases and clarifying that only the sets of attainable seam colors matter.\nSketch proof.\n- \u201cOnly if\u201d is tautological: \u03b1_L, \u03b1_R in the original clause range over exactly these sets. \u201cIf\u201d follows by instantiating \u03b1_L, \u03b1_R with the values arising from some \u03c4_a, \u03c4_d.\nImplementation tip.\n- After guessing f, precompute the sets OutR2 and OutL1 (sizes \u2264|\u03a3_out| each) and reduce the verification loops accordingly.\n\nOptimization \u2014 O(\u03b2^4) append update via slices\nObservation.\n- For k_flag\u22654, (x1,x2,x3,x4) \u2208 Ext_{t\u00b7a} iff x4\u2208A_a \u2227 E(x3,x4) \u2227 Left3_t[x1,x2,x3], where Left3_t[x1,x2,x3] := \u2203z (x1,x2,z,x3)\u2208Ext_t.\nRoutine.\n- Precompute Left3_t (a \u03b2\u00d7\u03b2\u00d7\u03b2 boolean tensor) in O(\u03b2^4) time. Then fill Ext_{t\u00b7a} by scanning all (x1,x2,x3) and for each, iterate neighbors x4 with E(x3,x4) and x4\u2208A_a, setting Ext_{t\u00b7a}[x1,x2,x3,x4]\u2190true. This costs O(\u03b2^4 + \u03b2^3\u00b7\u0394), where \u0394 is the max out-degree in E (\u0394\u2264\u03b2), i.e., O(\u03b2^4) in dense worst-case.\nWhy useful here.\n- Brings append down from O(\u03b2^5) to O(\u03b2^4), improving the preprocessing constants while preserving single-exponential bounds overall.\n\nImplementation detail \u2014 Precompute seam-feasibility matrices W_{b\u2299c}\nStatement.\n- For each pair (\u03c4_b, \u03c4_c), define a \u03b2\u00d7\u03b2 boolean matrix W_{b\u2299c}[\u03b1_L][\u03b1_R] that is true iff \u2203(o1,o2,o3,o4)\u2208Ext_{\u03c4_b\u2299\u03c4_c} with E(\u03b1_L,o1) and E(o4,\u03b1_R). Using the Left/Right 3D slices for \u03c4_b\u2299\u03c4_c, W can be computed in O(\u03b2^4\u00b7\u0394^2) or faster with sparse E.\nWhy useful here.\n- Stage-1 verification reduces to testing W_{b\u2299c}[\u03b1_L][\u03b1_R] for \u03b1_L\u2208OutR2(\u03c4_b,s1), \u03b1_R\u2208OutL1(\u03c4_c,s2). This removes any per-case scanning over tuples in Ext during verification (all heavy work moved to preprocessing).\n\nSanity checks and small examples\n- Equality LCL (E={(x,x)}; A_0=A_1=\u03a3_out). Types collapse quickly; Ext_t contains only quadruples with equal coordinates per k_flag. Stage-1: OutR2=OutL1=\u03a3_out; concatenation Ext_{\u03c4_b\u2299\u03c4_c} permits any \u03b1 with E(\u03b1,\u03b1), so any f that outputs equal pairs is feasible. End segments are trivial by Lemma B.\n- Proper 2-coloring (\u03a3_out={a,b}, A_0=A_1=\u03a3_out, E forbids equal). Stage-1: feasible f exists (standard \u0398(log* n)); verification with W_{b\u2299c} succeeds for an appropriate f (alternating outputs), but the Stage-2 certificate is impossible (as noted earlier).\n- Degenerate A_0=A_1: \u03b4 base-case k=1 works with S_\u03c4 (Lemma A); seeds (0) and (1) merge to the same Type, which is intended.\n\nObstacles and caveats\n- Lemma B\u2019s endpoint argument uses the fact that a feasible f exists (we are in the (\u21d0) direction); the nonemptiness of End(P)\u2229E^{-1}(\u03b1_R) is thus reduced to the existence of a global legal labeling and Lemma 11. This logical dependency should be stated explicitly when integrating Lemma B.\n- Quantifier minimization (Lemma C) does not asymptotically improve worst-case verification time, but it separates concerns and simplifies implementation.\n\nConcrete next steps (actionable)\n1) Amend Proposition 9 to remove references to the internal bit b for k_flag=1 and use S_\u03c4 explicitly; mention this in the k=1\u21922 update description.\n2) Add Lemma B to output.md to explicitly cover endpoint completion in the Stage-1 (\u21d0) proof; a short paragraph suffices.\n3) Add the O(\u03b2^4) append optimization as a proposition parallel to Proposition 5 (concatenation optimization) for completeness.\n4) Optionally incorporate Lemma C\u2019s reformulation into the Stage-1 verification corollary, and mention the W_{b\u2299c} precomputation trick.\n5) Continue toward Stage-2: either supply the constant-radius partition lemma for oriented paths (with parameters and a self-contained proof) or redesign the constant-time certificate to avoid periodicity. Until then, keep Stage-2 out of output.md.\n\nAppend-only regression checklist\n- For random \u03a3_out up to size 3, verify: (i) O(\u03b2^4) append matches the O(\u03b2^5) brute force; (ii) Ext-concatenation associativity; (iii) W_{b\u2299c} agrees with direct scanning of Ext_{\u03c4_b\u2299\u03c4_c}; (iv) Stage-1 acceptance on equality LCL and rejection on instances known to be \u03a9(n).\n"
}