--- SYSTEM ---
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (summary so far)
- output.md (rigorously proven results so far)

Guidelines:
- notes.md: should be a readable running log of interesting work. Prefer appending. Replace only if old notes are clearly misleading. Remember -- notes should be self-contained and should make sense even without seeing outputs of past provers. 
- output.md: should be concise and rigorous. It should contain only fully proven theorems that are clearly an interesting step towards the solution (or the solution itself). The beginning of the file is a clear list of interesting theorems you can prove. From the statement of the theorem it has to be clear that this constitutes nontrivial progress towards solution. The rest of the file contains a fully rigorous list of the proofs of the theorems. Keep only proven theorems with clear proofs. If a statement is flawed and you cannot fix it, remove it from output.md and instead add it to notes.md with explanation.
- Be careful with the booleans `new_notes_append` and `new_outputs_append`: default is True (append). Use False only when deliberately rewriting everything.

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (≥200 words). Include concrete next-step suggestions. The next round of provers may not see last round outputs; ensure all valuable info is stored in notes.",
  "new_notes_md": "Markdown (KaTeX allowed). Usually appended to notes.",
  "new_notes_append": "True|False",
  "new_outputs_md": "Markdown (KaTeX allowed). Usually appended to output.md.",
  "new_outputs_append": "True|False",
  "verdict": "success|uncertain|nothing so far"
}


--- USER ---
You receive multiple prover reports. Evaluate correctness, value, and pick promising directions. Update notes.md (append/replace) with useful ideas and update output.md (append/replace) ONLY with rigorously verified results.

Prover reports (JSON):
[{"prover_id": "01", "progress_md": "Round 0006 \u2014 audit, small lemmas, optimizations, and checks\n\nSummary of what is already solid in output.md\n- Core r=1 machinery is in place: (i) base cases k=1\u21922, 2\u21923, 3\u21924 and the general append-one-bit recurrence; (ii) congruence under append (without carrying the leftmost input bit); (iii) concatenation for k_flag\u22654 and, more importantly, for all k_flag; (iv) associativity; (v) a clean NEXPTIME preprocessing (enumerate Types via \u03b4) and Stage-1 trichotomy (o(n) iff a feasible f exists) with both directions proved; (vi) pumping lemmas with \u2113_pump := |T|; (vii) a counterexample to R-composition; (viii) an O(\u03b2^6) concatenation routine.\n\nGaps and minor clarifications spotted in output.md\n- \u03b4 base case for k_flag=1 (Proposition 9): it currently says \u201cinput bit inside \u03c4 is b (implicitly recoverable as A_b = {x : (x,x,x,x) \u2208 Ext_\u03c4})\u201d. The proof does not need the bit b, only the set S_\u03c4 := {x : (x,x,x,x) \u2208 Ext_\u03c4}. Suggest stating the k=1\u21922 update directly in terms of S_\u03c4 rather than referring to a recovered b. This also cleanly covers the degenerate case A_0 = A_1 where b is not uniquely identifiable but S_\u03c4 still determines the update.\n- End segments in the Stage-1 (\u21d0) construction: the proof handles \u201cmiddle blocks\u201d between two separators. Paths have endpoints; these produce one-sided blocks adjoining a single separator. A short lemma (provided below) showing how to fill endpoints from Ext without the right/left seam removes any doubt.\n- Optional but helpful: document a faster append-one-bit update (O(\u03b2^4) instead of O(\u03b2^5)) via 3D slices, analogous to the O(\u03b2^6) concatenation optimization.\n- Quantifier economy in Stage-1 verification: the universal check can be reformulated to range over the sets of attainable \u03b1_L, \u03b1_R values induced by f, eliminating explicit quantification over \u03c4_a, \u03c4_d (details below). While worst-case complexity is not asymptotically improved, the reformulation reduces constant factors and clarifies intent.\n\nLemma A \u2014 \u03b4 base case k_flag=1 can be stated without \u201crecovering b\u201d\nStatement.\n- Let \u03c4 be a Type with k_flag(\u03c4)=1 and Ext_\u03c4 given. Define S_\u03c4 := {x \u2208 \u03a3_out : (x,x,x,x) \u2208 Ext_\u03c4}. For any appended bit a, Ext_{\u03b4(\u03c4,a)} consists exactly of the tuples (x1,x2,x3,x4) with x1=x3, x2=x4, x1\u2208S_\u03c4, x2\u2208A_a and E(x1,x2).\nWhy useful here.\n- Removes the (unneeded) reference to the internal input bit and works uniformly even when A_0=A_1.\nSketch proof.\n- Immediate from Proposition 6 by observing that Ext_{(b)} encodes A_b as S_\u03c4.\n\nLemma B \u2014 Endpoint completion in Stage-1 (\u21d0)\nStatement.\n- In the Stage-1 construction with separators spaced by K=\u2113_pump+4, the remaining end segments (from a path endpoint to the nearest separator) admit a legal completion consistent with the separator\u2019s seam color. Concretely, suppose the right endpoint of a block has seam color \u03b1_R (first output of the separator just to its right). Let P be the (one-sided) left block. There exists a labeling of P whose rightmost color o4 and last-but-one o3 yield a quadruple (o1,o2,o3,o4)\u2208Ext_P with E(o4, \u03b1_R). A symmetric claim holds for right blocks with a left seam \u03b1_L.\nWhy useful here.\n- Closes the small gap in the Stage-1 (\u21d0) proof for finite directed paths.\nSketch proof.\n- If the block length \u2264 2K\u22122, the Type of P is long. Consider Ext_P and the set End(P):={o4 : \u2203(o1,o2,o3,o4)\u2208Ext_P}. Since A,E guarantee at least one legal labeling on any finite input segment encountered during \u03b4-enumeration, Ext_P\u2260\u2205. If there exists o4\u2208End(P) with E(o4, \u03b1_R), any witnessing quadruple completes the block. If no such o4 exists, then Ext_{P\u00b7Q} would be empty for any right context Q starting with \u03b1_R, contradicting that the actual global instance is solvable (the separator labeling is chosen from a feasible f). This contradiction formalizes by taking Q to be the actual right context used in the construction and invoking Lemma 11.\n\nLemma C \u2014 Quantifier minimization for the feasible-function check\nStatement.\n- Given a guessed f: T_long\u00d7{0,1}^2\u00d7T_long\u2192\u03a3_out^2, define for each \u03c4_b and s\u2208{0,1}^2:\n  OutR2(\u03c4_b,s) := { second(f(\u03c4_a,s,\u03c4_b)) : \u03c4_a \u2208 T_long };\n  and for each \u03c4_c and s\u2032: OutL1(\u03c4_c,s\u2032) := { first(f(\u03c4_c,s\u2032,\u03c4_d)) : \u03c4_d \u2208 T_long }.\n- The universal extendibility clause in Theorem 15 is equivalent to: for all \u03c4_b,\u03c4_c and s1,s2, and for all \u03b1_L \u2208 OutR2(\u03c4_b,s1), \u03b1_R \u2208 OutL1(\u03c4_c,s2), there exists (o1,o2,o3,o4) \u2208 Ext_{\u03c4_b\u2299\u03c4_c} with E(\u03b1_L,o1), E(o4,\u03b1_R).\nWhy useful here.\n- Eliminates explicit quantification over \u03c4_a, \u03c4_d in verification, reducing the number of cases and clarifying that only the sets of attainable seam colors matter.\nSketch proof.\n- \u201cOnly if\u201d is tautological: \u03b1_L, \u03b1_R in the original clause range over exactly these sets. \u201cIf\u201d follows by instantiating \u03b1_L, \u03b1_R with the values arising from some \u03c4_a, \u03c4_d.\nImplementation tip.\n- After guessing f, precompute the sets OutR2 and OutL1 (sizes \u2264|\u03a3_out| each) and reduce the verification loops accordingly.\n\nOptimization \u2014 O(\u03b2^4) append update via slices\nObservation.\n- For k_flag\u22654, (x1,x2,x3,x4) \u2208 Ext_{t\u00b7a} iff x4\u2208A_a \u2227 E(x3,x4) \u2227 Left3_t[x1,x2,x3], where Left3_t[x1,x2,x3] := \u2203z (x1,x2,z,x3)\u2208Ext_t.\nRoutine.\n- Precompute Left3_t (a \u03b2\u00d7\u03b2\u00d7\u03b2 boolean tensor) in O(\u03b2^4) time. Then fill Ext_{t\u00b7a} by scanning all (x1,x2,x3) and for each, iterate neighbors x4 with E(x3,x4) and x4\u2208A_a, setting Ext_{t\u00b7a}[x1,x2,x3,x4]\u2190true. This costs O(\u03b2^4 + \u03b2^3\u00b7\u0394), where \u0394 is the max out-degree in E (\u0394\u2264\u03b2), i.e., O(\u03b2^4) in dense worst-case.\nWhy useful here.\n- Brings append down from O(\u03b2^5) to O(\u03b2^4), improving the preprocessing constants while preserving single-exponential bounds overall.\n\nImplementation detail \u2014 Precompute seam-feasibility matrices W_{b\u2299c}\nStatement.\n- For each pair (\u03c4_b, \u03c4_c), define a \u03b2\u00d7\u03b2 boolean matrix W_{b\u2299c}[\u03b1_L][\u03b1_R] that is true iff \u2203(o1,o2,o3,o4)\u2208Ext_{\u03c4_b\u2299\u03c4_c} with E(\u03b1_L,o1) and E(o4,\u03b1_R). Using the Left/Right 3D slices for \u03c4_b\u2299\u03c4_c, W can be computed in O(\u03b2^4\u00b7\u0394^2) or faster with sparse E.\nWhy useful here.\n- Stage-1 verification reduces to testing W_{b\u2299c}[\u03b1_L][\u03b1_R] for \u03b1_L\u2208OutR2(\u03c4_b,s1), \u03b1_R\u2208OutL1(\u03c4_c,s2). This removes any per-case scanning over tuples in Ext during verification (all heavy work moved to preprocessing).\n\nSanity checks and small examples\n- Equality LCL (E={(x,x)}; A_0=A_1=\u03a3_out). Types collapse quickly; Ext_t contains only quadruples with equal coordinates per k_flag. Stage-1: OutR2=OutL1=\u03a3_out; concatenation Ext_{\u03c4_b\u2299\u03c4_c} permits any \u03b1 with E(\u03b1,\u03b1), so any f that outputs equal pairs is feasible. End segments are trivial by Lemma B.\n- Proper 2-coloring (\u03a3_out={a,b}, A_0=A_1=\u03a3_out, E forbids equal). Stage-1: feasible f exists (standard \u0398(log* n)); verification with W_{b\u2299c} succeeds for an appropriate f (alternating outputs), but the Stage-2 certificate is impossible (as noted earlier).\n- Degenerate A_0=A_1: \u03b4 base-case k=1 works with S_\u03c4 (Lemma A); seeds (0) and (1) merge to the same Type, which is intended.\n\nObstacles and caveats\n- Lemma B\u2019s endpoint argument uses the fact that a feasible f exists (we are in the (\u21d0) direction); the nonemptiness of End(P)\u2229E^{-1}(\u03b1_R) is thus reduced to the existence of a global legal labeling and Lemma 11. This logical dependency should be stated explicitly when integrating Lemma B.\n- Quantifier minimization (Lemma C) does not asymptotically improve worst-case verification time, but it separates concerns and simplifies implementation.\n\nConcrete next steps (actionable)\n1) Amend Proposition 9 to remove references to the internal bit b for k_flag=1 and use S_\u03c4 explicitly; mention this in the k=1\u21922 update description.\n2) Add Lemma B to output.md to explicitly cover endpoint completion in the Stage-1 (\u21d0) proof; a short paragraph suffices.\n3) Add the O(\u03b2^4) append optimization as a proposition parallel to Proposition 5 (concatenation optimization) for completeness.\n4) Optionally incorporate Lemma C\u2019s reformulation into the Stage-1 verification corollary, and mention the W_{b\u2299c} precomputation trick.\n5) Continue toward Stage-2: either supply the constant-radius partition lemma for oriented paths (with parameters and a self-contained proof) or redesign the constant-time certificate to avoid periodicity. Until then, keep Stage-2 out of output.md.\n\nAppend-only regression checklist\n- For random \u03a3_out up to size 3, verify: (i) O(\u03b2^4) append matches the O(\u03b2^5) brute force; (ii) Ext-concatenation associativity; (iii) W_{b\u2299c} agrees with direct scanning of Ext_{\u03c4_b\u2299\u03c4_c}; (iv) Stage-1 acceptance on equality LCL and rejection on instances known to be \u03a9(n).\n"}]

Current notes.md:
Corrections and key lemmas to record

1) Correct append-one-bit recurrence (r=1)
Given a type t with Ext_t ⊆ Σ_out^4 over boundary (L1,L2,R2,R1) and an appended input bit a, the new type t′ has boundary (L1′,L2′,R2′,R1′) = (L1,L2, old R1, new), i.e., R2′ = R1 and R1′ is the label of the appended node. Formally, for each candidate quadruple (x1,x2,x3,x4) ∈ Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [x4 ∈ A_a and E(x3,x4) and ∃ z ∈ Σ_out: (x1,x2,z,x3) ∈ Ext_t].
This yields an O(β^5) DP to fill Ext_{t′} by scanning all (x1,x2,x3,x4) and checking ∃z.

Congruence lemma (needed): If Type(P)=Type(Q), then for all a ∈ {0,1}, Type(Pa)=Type(Qa). Proof sketch: The predicate “there exists an interior completion consistent with boundary assignments” over D1∪D2 is preserved under appending one node by the above DP rule, which depends only on Ext_t and a.

2) Concatenation of summaries (r=1)
If Summ(P) has Ext_P and Summ(Q) has Ext_Q, then the concatenation B=P·Q has boundary (P.left endpoint, P.left neighbor, Q.right neighbor, Q.right endpoint) and
  (o1,o2,o3′,o4′) ∈ Ext_B ⇔ ∃ x3,x4,x1′,x2′ ∈ Σ_out: (o1,o2,x3,x4) ∈ Ext_P, (x1′,x2′,o3′,o4′) ∈ Ext_Q, and E(x4,x1′).
Then R_B can be derived from Ext_B as usual.

3) Counterexample to R-composition via ∃m
Let Σ_out={a,b,c}, A_0=A_1=Σ_out. Let E={a→b, b→c} only. Suppose t_b admits a boundary tuple with right endpoint a, and t_c admits a boundary tuple with left endpoint c (interiors arbitrary but extendible). Then choose m=b. We have (x,m) ∈ R_{t_b} for any x with a valid left edge, and (m,y) ∈ R_{t_c} for suitable y. But the concatenation t_b·t_c requires the seam edge a→c, which is forbidden. Hence ∃m composition of R_t is not sound; use Ext-level concatenation and R_B instead.
Additions and fixes (r=1)

A) Correct k=2→3 base-case update
Let t=(b1,b2) and t′=t·a (length 3). Then
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [x3=x2, x1∈A_{b1}, x2∈A_{b2}, x4∈A_a, E(x1,x2), E(x2,x4)].
This replaces any prior statement that involved x2∈A_a.

B) Type representation and congruence
Define Type(t) := (b_in(t), Ext_t, k_flag(t)), where k_flag ∈ {1,2,3,≥4} indicates whether boundary coordinates coincide due to short length. Then the congruence lemma holds in the form:
  If Type(P)=Type(Q), then for all a∈{0,1}, Type(Pa)=Type(Qa).
Proof: case split on k_flag using the explicit base-case rules for k_flag∈{1,2,3} and the general append recurrence for k_flag=≥4.
Remark: Ext equality alone does not determine |t| (e.g., with E self-loops and A_0=A_1, Ext_{len 2} = Ext_{len 4}). Hence the k_flag is necessary for a length-agnostic update routine.

C) Enumeration fix
In the BFS over types, key the dictionary by the full Type(t), including k_flag. After the first transition to k_flag=≥4, all descendants remain in k_flag=≥4 and subsequent δ updates are length-agnostic.
Additions: Stage-1 and Stage-2 specifications at the Ext level (r=1, oriented paths)

Notation. Σ_out has size β. For an input word t with bits b_in(t) ∈ {0,1}^{|t|}, let Ext_t ⊆ Σ_out^4 denote the set of boundary quadruples (L1,L2,R2,R1) = (o[1],o[2],o[|t|-1],o[|t|]) that admit an interior completion o consistent with node constraints o[i]∈A_{b_in(t)[i]} and edge constraints (o[i],o[i+1])∈E. Types are Type(t)=(Ext_t, k_flag(t)), where k_flag∈{1,2,3,≥4} encodes short-length degeneracies. Concatenation of types τ⊙σ is defined by the Ext-level concatenation rule (see outputs.md) and k_flag update.

Stage-1 (Ω(n) vs o(n)): type-level feasible function
- Universe: the finite set of types T obtained by BFS from k=1 under the append-one-bit updates (keyed by (Ext,k_flag)). For τ,σ∈T, the Ext of τ⊙σ is defined by Ext-level concatenation.
- Definition (feasible f). A function f: T × {0,1}^2 × T → Σ_out^2 mapping (τ_L, s, τ_R) to (α1,α2) is feasible if:
  (i) Node/window constraints: αi ∈ A_{s[i]} for i=1,2 and (α1,α2) ∈ E (i.e., E(α1,α2) holds).
  (ii) Universal extendibility across two separators: for all τ_a,τ_b,τ_c,τ_d∈T and s1,s2∈{0,1}^2, letting α_L := second component of f(τ_a,s1,τ_b) and α_R := first component of f(τ_c,s2,τ_d), we require
      ∃ (o1,o2,o3,o4) ∈ Ext_{τ_b ⊙ τ_c} with E(α_L,o1) and E(o4,α_R).
  Comment: The quantification over τ_a and τ_d is stronger than necessary but safe; a weaker version quantifies only over τ_b,τ_c and s1,s2. Indexing uses our convention (L1,L2,R2,R1); thus o1 and o4 are the first and last outputs of the middle block of type τ_b⊙τ_c.
- NEXPTIME check: deterministically enumerate T and all Ext_{τ} and on-demand Ext_{τ⊙σ}; nondeterministically guess f; verify (i) and (ii) exhaustively. Complexity is 2^{poly(N)} in the problem description size N.
- Status: We still owe a self-contained proof that “o(n) algorithm exists iff a feasible f exists” at the Ext level (the intended replacement of the paper’s feasible-function lemma). This will rely only on our Ext-append and Ext-concat lemmas and a standard pumping argument specialized to r=1.

Stage-2 (O(1) vs Ω(log* n)): per-type boundary-interface witness
- For each τ∈T with k_flag(τ)≥4, guess Q_τ=(L1_τ,L2_τ,R2_τ,R1_τ) with Q_τ ∈ Ext_τ. Enforce:
  (a) Local consistency and tiling: E(L1_τ,L2_τ), E(R2_τ,R1_τ), and wrap E(R1_τ,L1_τ). Intuition: long blocks of type τ can be tiled by copies using the same boundary outputs.
  (b) Bridging across any middle type (including empty): for all τ_left,τ_S,τ_right ∈ T, require either
      - if τ_S has k_flag≥1: ∃ (o1,o2,o3,o4) ∈ Ext_{τ_S} with E(R1_{τ_left},o1) and E(o4,L1_{τ_right}); or
      - if τ_S is empty: E(R1_{τ_left},L1_{τ_right}).
- Decision logic: if witnesses {Q_τ} exist and pass (a)–(b), classify O(1). Else, if a Stage-1 feasible f exists, classify Θ(log* n). Otherwise, classify Θ(n).
- Status: We still owe a concrete constant-radius construction on oriented paths from {Q_τ} (e.g., a partition/tiling routine parametrized by fixed radii ℓ_width, ℓ_pattern, ℓ_count) and a proof that the produced labeling is legal. Short types (k_flag<4) are treated as separators τ_S in (b).

Faster concatenation (proven and moved to outputs.md)
- Precompute for each τ the 3D slices: Left_τ[o1,o2,x4] := ∃x3 (o1,o2,x3,x4)∈Ext_τ, and Right_τ[x1′,o3′,o4′] := ∃x2′ (x1′,x2′,o3′,o4′)∈Ext_τ.
- Then (o1,o2,o3′,o4′)∈Ext_{τ⊙σ} iff ∃x4,x1′: Left_τ[o1,o2,x4] ∧ E(x4,x1′) ∧ Right_σ[x1′,o3′,o4′]. This allows computing Ext_{τ⊙σ} in O(β^6) time after O(β^4) precomputation per type.

Sanity checks (kept as examples)
- Trivial LCL (A_0=A_1=Σ_out, E complete): Ext_τ=Σ_out^4 for all τ; Stage-2 witness exists trivially ⇒ O(1).
- Equality LCL (E={(x,x)}): take Q_τ=(c,c,c,c) ⇒ O(1).
- Proper 2-coloring: Stage-2 fails; Stage-1 feasible f should exist ⇒ Θ(log* n).
- Linear cases with incompatible seams: Stage-1 fails ⇒ Ω(n).
Updates and clarifications (r=1, oriented paths)

1) Base-case updates finalized
- k=1→2 is special and cannot be derived from the general append recurrence without over-constraining x1=x2; we record an explicit rule in outputs.md.
- k=3→4 is also added explicitly (although it follows from the same recurrence if stated for k≥2). This ensures δ can move from short types to k_flag≥4 deterministically.

2) Type-count bound corrected
Type(t) consists of (Ext_t, k_flag(t)) only; boundary input bits are not part of Type. Hence the number of types satisfies
  |T| ≤ 4 · 2^{β^4}.
The earlier 16 · 2^{β^4} bound mixed in boundary input bits unnecessarily.

3) δ well-defined and BFS enumeration
- Seeds: k=1 types for b∈{0,1} (Ext_{(b)} = {(x,x,x,x): x∈A_b}).
- Transitions: use base-cases for k<4 (1→2, 2→3, 3→4) and Lemma 1 for k≥4. By congruence, δ(Type, a) depends only on (Ext, k_flag) and a.
- Termination and complexity: at most |T| ≤ 4·2^{β^4} insertions; each append is O(β^5) in the k≥4 regime (base-cases are ≤ O(β^4)); total time/space 2^{poly(β)}.

4) Reversal operator (optional but helpful)
Define Rev(τ) = (Ext_τ^R, k_flag(τ)) with Ext_τ^R := { (y1,y2,y3,y4) : (y4,y3,y2,y1) ∈ Ext_τ }. Then Rev(Rev(τ))=τ and Ext_{Rev(τ) ⊙ Rev(σ)} = (Ext_{σ ⊙ τ})^R.

5) Stage-1 and Stage-2 (status)
- Stage-1 (Ω(n) vs o(n)): the feasible function f: T × {0,1}^2 × T → Σ_out^2 with the universal Ext-based check (seams E(α_L, o1), E(o4, α_R), using the (L1,L2,R2,R1) ordering) is the right formal object. We still need a fully self-contained proof of the equivalence “o(n) iff such f exists”.
- Stage-2 (O(1) vs Ω(log* n)): the per-type witness Q_τ∈Ext_τ for k_flag≥4 with tiling and universal bridging checks is plausible. A complete constant-radius construction on oriented paths remains to be written and verified.

6) Sanity and regression items
- β=2 trivial LCLs and equality LCL check the base-cases and concatenation routines.
- Reconfirm the 3-color counterexample for R-composition via ∃m.
- Maintain an indexing reminder: Ext quadruples are ordered (L1,L2,R2,R1); in seam checks across a middle block of type τ_b⊙τ_c, the left seam meets o1 and the right seam meets o4.
New additions (r=1, oriented paths): pumping, general concatenation, and Stage-1 equivalence

- Pumping bound and lemmas. Let T be the set of reachable types (Proposition 9) and δ: T×{0,1}→T the append transition. Define
  ℓ_pump := |T|.
  Lemma (prefix pumping). For any input w with |w| ≥ ℓ_pump there exist x,y,z with 1 ≤ |y| ≤ ℓ_pump and |xy| ≤ ℓ_pump such that Type(x y^i z) is independent of i ≥ 0.
  Lemma (periodic pumping). For any nonempty u there exist a,b with a+b ≤ ℓ_pump such that Type(u^{a+bi}) is invariant for all i ≥ 0.
  Both follow from the pigeonhole principle applied to the δ-run over Types.

- Ext-level concatenation for all k_flags and associativity. The general concatenation rule (Ext_{P·Q} witnessed by Ext_P and Ext_Q with a seam constraint E(x4,x1′)) holds verbatim for all lengths because Ext for short words already lives in Σ_out^4 with coordinate equalities enforced by k_flag. Associativity of Ext-concatenation follows semantically (concatenation of words is associative) or by rebracketing seam witnesses.

- Stage-1 (Ω(n) vs o(n)). Restrict left/right context Types to T_long := {τ∈T : k_flag(τ)≥4}. Define a feasible f: T_long×{0,1}^2×T_long→Σ_out^2 that (i) satisfies node/edge constraints on the 2-node separator and (ii) for all τ_b,τ_c∈T_long and s1,s2, and for all τ_a,τ_d∈T_long (affecting only α_L,α_R), there exists (o1,o2,o3,o4)∈Ext_{τ_b⊙τ_c} with E(α_L,o1) and E(o4,α_R), where α_L is the second output of f(τ_a,s1,τ_b) and α_R is the first output of f(τ_c,s2,τ_d). Theorem (added to output.md): an r=1, oriented-path LCL has deterministic complexity o(n) iff such a feasible f exists. Proof outline recorded in output.md: (⇒) extract f from an o(n) algorithm via pumping and a cycle-gadget; (⇐) place separators by an MIS on the K-th power of the path with K≳ℓ_pump and solve each O(K)-long block locally using the guaranteed Ext-witness; total time O(log* n).

- Stage-2 (O(1) vs Θ(log* n)). The per-type interface Q_τ∈Ext_τ (for τ∈T_long) with tiling and universal bridging checks remains a plausible certificate. However, the constant-radius partition of an arbitrary input path into “long periodic” and “short/irregular” subpaths is not yet proven in this writeup. Do not claim S2 in output.md until a self-contained partition lemma (parameters and proof) is supplied or the construction is reworked to avoid this dependency.

- Minor lemma. Nonemptiness monotonicity under concatenation: if Ext_P and Ext_Q are nonempty and there exists at least one seam pair (x4,x1′) with E(x4,x1′), then Ext_{P·Q}≠∅. This is an immediate corollary of the general concatenation rule.

Implementation notes

- Quantify over T_long for left/right contexts in Stage-1; middle types in Stage-2 can be arbitrary (short included), handled by the general concatenation lemma.
- Precompute T by BFS (Prop. 9), split T_long vs short, cache Left_τ and Right_τ for all τ, and build Ext_{τ⊙σ} for τ,σ∈T_long (Prop. 5). ℓ_pump=|T| is computable in 2^{poly(β)}.
- Separator placement for Stage-1: in O(log* n), compute an MIS on the K-th power of the directed path for K=ℓ_pump+4; distances between consecutive separators are ≤2K, ensuring each middle block is O(K)-long and solvable in O(1) rounds by exhaustive local choice of an Ext-witness–consistent interior labeling.

Open item for Stage-2

- Provide a self-contained constant-radius partition lemma on oriented paths or redesign the Stage-2 constant-round construction to avoid reliance on periodicity. Until then, keep S2 as a notes-only plan.


Current output.md (if any):
Setup and definitions (r=1, globally oriented paths)
- Let Σ_out be a finite output alphabet of size β. Let A_0,A_1 ⊆ Σ_out be the allowed outputs at nodes with input bit 0 or 1, respectively. Let E ⊆ Σ_out × Σ_out be the allowed directed edge relation (u→v allowed iff (u,v)∈E). For an input word t ∈ {0,1}^k with k≥1, a labeling o ∈ Σ_out^k is legal if o[i]∈A_{t[i]} for all i, and (o[i],o[i+1])∈E for all 1≤i<k.
- For k≥4, define Ext_t ⊆ Σ_out^4 as the set of boundary quadruples (L1,L2,R2,R1) that extend to a legal labeling o with L1=o[1], L2=o[2], R2=o[k−1], R1=o[k]. For k≤3, Ext_t is defined with the same 4-tuple container but with the obvious coordinate equalities imposed by overlaps (tracked by k_flag ∈ {1,2,3,≥4}). The Type of t is Type(t) := (Ext_t, k_flag(t)).

Lemma 1 (Append-one-bit recurrence; k_flag≥4 case).
Let t be an input word with k_flag(t)≥4, and let t′ := t·a be t with one bit a ∈ {0,1} appended on the right. Then for all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x4 ∈ A_a and E(x3,x4) and ∃z∈Σ_out: (x1,x2,z,x3) ∈ Ext_t ].
Proof. (⇒) From (x1,x2,x3,x4)∈Ext_{t′} there is a legal labeling o′ on t′ with o′[1]=x1, o′[2]=x2, o′[k]=x3, o′[k+1]=x4. Node/edge constraints give x4∈A_a and E(x3,x4). Let z := o′[k−1]; then the restriction o := o′[1..k] is a legal labeling of t with boundary (x1,x2,z,x3), so (x1,x2,z,x3)∈Ext_t. (⇐) Conversely, given z with (x1,x2,z,x3)∈Ext_t, pick a witnessing legal labeling o on t. Extend by setting o′[1..k]=o and o′[k+1]=x4. If x4∈A_a and E(x3,x4), then o′ is legal on t′ and has boundary (x1,x2,x3,x4), so (x1,x2,x3,x4)∈Ext_{t′}. □

Base-case update (k=2→3).
Let t=(b1,b2) and t′=t·a. Then for all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x3=x2, x1∈A_{b1}, x2∈A_{b2}, x4∈A_a, E(x1,x2), E(x2,x4) ].
This follows by unfolding the definition when positions 2 and 3 coincide in the boundary coordinates.

Lemma 2 (Ext-level concatenation; k_flag≥4).
Let P and Q be input words with k_flag(P), k_flag(Q) ≥4, and let B := P·Q (concatenation). Then for all (o1,o2,o3′,o4′)∈Σ_out^4,
  (o1,o2,o3′,o4′) ∈ Ext_B ⇔ ∃ x3,x4,x1′,x2′ ∈ Σ_out such that
    (o1,o2,x3,x4) ∈ Ext_P, (x1′,x2′,o3′,o4′) ∈ Ext_Q, and E(x4,x1′).
Proof. (⇒) Given a legal labeling on B with boundary (o1,o2,o3′,o4′), define x3:=o[|P|−1], x4:=o[|P|], x1′:=o[|P|+1], x2′:=o[|P|+2]. Restrictions to P and Q witness the two Ext-memberships, and E(x4,x1′) is the edge across the seam. (⇐) Given witnesses, combine the legal labelings on P and Q and the seam constraint E(x4,x1′) to obtain a legal labeling on B with the required boundary. □

Proposition 3 (Type congruence under appending one bit).
If Type(P)=Type(Q), then for all a∈{0,1}, Type(P·a)=Type(Q·a). In particular, Ext_{P·a}=Ext_{Q·a} and k_flag updates identically.
Proof. For k_flag≥4, Lemma 1 shows Ext_{(·)·a} depends only on Ext_{(·)} and a. Thus Ext_{P·a}=Ext_{Q·a}. The k_flag transition is determined solely by k_flag and the append operation, hence identical for P and Q. Short-length cases follow by the explicit base-case rules. □

Proposition 4 (Unsoundness of existential R-composition).
There exists an instance (Σ_out,A_0,A_1,E) and types t_b,t_c such that there is m∈Σ_out with (x,m) ∈ R_{t_b} and (m,y) ∈ R_{t_c} for some x,y, yet (x,y) ∉ R_{t_b·t_c}. Hence the rule “(∃m) R_{P·Q}(x,y) ⇐ R_P(x,m) ∧ R_Q(m,y)” is not valid in general.
Proof. Take Σ_out={a,b,c}, A_0=A_1=Σ_out, and E={(a,b),(b,c)} only. Let t_b be any type that admits a legal labeling with rightmost output a (left side arbitrary), so (x,a)∈R_{t_b} for any feasible x. Let t_c admit a legal labeling with leftmost output c (right side arbitrary), so (c,y)∈R_{t_c} for a suitable y. Choose m=b; then (x,m)∈R_{t_b} and (m,y)∈R_{t_c}. However, in the concatenation t_b·t_c, the seam would require E(a,c), which is false. Thus (x,y)∉R_{t_b·t_c}. □

Proposition 5 (Optimized computation of Ext for concatenation in O(β^6)).
For any types τ,σ with k_flag(τ),k_flag(σ)≥4, define the 3D slices
  Left_τ[o1,o2,x4] := ∃x3 (o1,o2,x3,x4)∈Ext_τ, and
  Right_σ[x1′,o3′,o4′] := ∃x2′ (x1′,x2′,o3′,o4′)∈Ext_σ.
Then for all (o1,o2,o3′,o4′),
  (o1,o2,o3′,o4′) ∈ Ext_{τ⊙σ} ⇔ ∃x4,x1′: Left_τ[o1,o2,x4] ∧ E(x4,x1′) ∧ Right_σ[x1′,o3′,o4′].
Moreover, after precomputing Left_τ and Right_σ for all τ,σ in O(β^4) time per type, Ext_{τ⊙σ} can be computed in O(β^6) time by scanning all (o1,o2,o3′,o4′)∈Σ_out^4 and testing the existential condition over (x4,x1′)∈Σ_out^2.
Proof. The equivalence is immediate from Lemma 2 by eliminating the existential witnesses x3 and x2′ into the definitions of Left_τ and Right_σ. Complexity: each 3D table has O(β^3) entries and can be filled in O(β) time per entry (by checking ∃ over one coordinate), giving O(β^4). Computing Ext_{τ⊙σ} requires O(β^4) target entries and an O(β^2) search over (x4,x1′) per entry, hence O(β^6). □
Proposition 6 (Base-case update; k=1→2).
Let t=(b) be a length-1 input and t′:=t·a the length-2 input obtained by appending a∈{0,1}. For all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x1 = x3, x2 = x4, x1 ∈ A_b, x2 ∈ A_a, and E(x1,x2) ].
Proof. A legal labeling on t′ has outputs (o1,o2) with o1∈A_b, o2∈A_a and E(o1,o2); its boundary tuple is (o1,o2,o1,o2), giving the stated equalities and constraints. The converse is immediate. □

Proposition 7 (Base-case update; k=3→4).
Let t=(b1,b2,b3) be a length-3 input and t′:=t·a the length-4 input obtained by appending a∈{0,1}. For all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x1∈A_{b1}, x2∈A_{b2}, x3∈A_{b3}, x4∈A_a, and E(x1,x2), E(x2,x3), E(x3,x4) ].
Proof. Unfold the definition: Ext_{t′} collects exactly the boundary tuples of legal labelings on the 4-node path with the given input bits, which are precisely those satisfying the listed node and edge constraints. □

Lemma 8 (Type-count bound).
With Type(t):=(Ext_t, k_flag(t)) and Ext_t⊆Σ_out^4, the number of distinct types obeys
  |T| ≤ 4 · 2^{β^4}.
Proof. For each of the four values of k_flag∈{1,2,3,≥4}, Ext_t can be any subset of Σ_out^4 (subject to feasibility), so the total number of pairs (Ext, k_flag) is at most 4·2^{|Σ_out^4|} = 4·2^{β^4}. □

Proposition 9 (δ well-defined; deterministic BFS enumeration in 2^{poly(β)} time/space).
Let δ map a type τ and an appended bit a∈{0,1} to the type of the one-bit extension. Define δ by:
- If k_flag(τ)=1 and input bit inside τ is b (implicitly recoverable as A_b = { x : (x,x,x,x) ∈ Ext_τ }), compute Ext of the 2-node type by Proposition 6.
- If k_flag(τ)=2, use the explicit k=2→3 update (already in outputs.md).
- If k_flag(τ)=3, use Proposition 7.
- If k_flag(τ)≥4, use Lemma 1.
Then δ(τ,a) depends only on τ and a (by Proposition 3), not on the particular representative. A deterministic BFS that starts from all length-1 seeds (t=(0) and t=(1)), repeatedly applies δ(·,0) and δ(·,1), and interns types by equality of (Ext, k_flag), halts after at most |T| insertions and enumerates all reachable types. Each transition costs O(β^5) in the k_flag≥4 regime (base-cases are ≤O(β^4)). Since |T| ≤ 4·2^{β^4}, the total time and space are 2^{poly(β)}. □

Lemma 10 (Reversal operator; basic properties).
Define, for any type τ=(Ext_τ,k_flag(τ)), the reversed type Rev(τ):=(Ext_τ^R, k_flag(τ)), where
  Ext_τ^R := { (y1,y2,y3,y4) ∈ Σ_out^4 : (y4,y3,y2,y1) ∈ Ext_τ }.
Then Rev(Rev(τ))=τ. Moreover, for any types τ,σ with k_flag≥4,
  Ext_{Rev(τ) ⊙ Rev(σ)} = (Ext_{σ ⊙ τ})^R.
Proof. The involution Rev(Rev(τ))=τ is immediate from the definition. For concatenation, note that reversing P·Q swaps the order and reverses boundary coordinates. Applying Lemma 2 to σ⊙τ and then reversing both sides yields the stated identity. □
Definition (Long types and pumping bound).
- T_long := { τ ∈ T : k_flag(τ) ≥ 4 }.
- Define ℓ_pump := |T|, where T is the set of reachable Types enumerated by Proposition 9.

Lemma 11 (Ext-level concatenation; all k_flag).
For any input words P,Q (no restriction on length) and B := P·Q, for all (o1,o2,o3′,o4′) ∈ Σ_out^4,
  (o1,o2,o3′,o4′) ∈ Ext_B ⇔ ∃ x3,x4,x1′,x2′ ∈ Σ_out:
    (o1,o2,x3,x4) ∈ Ext_P, (x1′,x2′,o3′,o4′) ∈ Ext_Q, and E(x4,x1′).
Proof. Identical to Lemma 2. For short P or Q, Ext still lives in Σ_out^4 with coordinate equalities enforced by k_flag, hence the same witness-based argument applies. □

Proposition 12 (Associativity of Ext-concatenation).
For any input words P,Q,R, Ext_{(P·Q)·R} = Ext_{P·(Q·R)} as subsets of Σ_out^4.
Proof. Semantically, Ext_B is the set of boundary quadruples realized by legal labelings of the word B; since string concatenation is associative, both sides refer to the same word and hence the same Ext set. Alternatively, apply Lemma 11 twice to each side: both characterizations assert the existence of seam witnesses (x4,x1′) at the first seam and (y4,y1″) at the second seam with E(x4,x1′) and E(y4,y1″), together with legal labelings on P,Q,R; rebracketing the witnesses shows equivalence. □

Lemma 13 (Prefix pumping).
Let ℓ_pump := |T|. For any input string w with |w| ≥ ℓ_pump there exist a decomposition w = x y z with 1 ≤ |y| ≤ ℓ_pump and |x y| ≤ ℓ_pump such that Type(x y^i z) is independent of i ≥ 0.
Proof. Read w left-to-right from an initial length-1 seed Type under the deterministic transition δ (Prop. 9), obtaining a sequence of |w|+1 visited Types. Among the first ℓ_pump+1 states, some state repeats at positions i < j ≤ ℓ_pump by pigeonhole. Let x := w[1..i], y := w[i+1..j], z := w[j+1..|w|]. Since δ is deterministic on Types (Prop. 3), for every i′ ≥ 0 the state after x y^{i′} is the same as after x; thus the final state after x y^{i′} z is independent of i′. The length bounds on y and x y follow from j ≤ ℓ_pump. □

Lemma 14 (Periodic pumping).
For any nonempty string u there exist integers a,b with a+b ≤ ℓ_pump such that Type(u^{a+bi}) is invariant for all i ≥ 0.
Proof. Consider the sequence S_j := Type(u^j) for j = 0,1,2,…. Among the first ℓ_pump+1 states, a repeat occurs at 0 ≤ a < a+b ≤ ℓ_pump. Determinism of δ implies S_{a+bi} = S_a for all i ≥ 0. □

Definition (Feasible function over long types).
A function f: T_long × {0,1}^2 × T_long → Σ_out^2 is feasible if for every (τ_L, s, τ_R) it outputs (α1,α2) with αi ∈ A_{s[i]} and E(α1,α2), and moreover the following universal extendibility holds: for all τ_a,τ_b,τ_c,τ_d ∈ T_long and s1,s2 ∈ {0,1}^2, letting α_L := second component of f(τ_a,s1,τ_b) and α_R := first component of f(τ_c,s2,τ_d), there exists (o1,o2,o3,o4) ∈ Ext_{τ_b ⊙ τ_c} with E(α_L,o1) and E(o4,α_R).

Theorem 15 (Stage-1: o(n) iff a feasible f exists).
For r=1 LCLs on globally oriented paths (as set up above), the deterministic distributed complexity is o(n) iff there exists a feasible f as defined above.
Proof.
(⇒) Suppose there is a deterministic algorithm A running in T(n) = o(n) rounds. Fix ℓ_pump = |T| and choose an integer s so large that for all sufficiently large n, T(n) < s/10. For any τ ∈ T_long, pick a representative word w_τ of length ≤ ℓ_pump with Type(w_τ)=τ. By Lemma 13, inflate w_τ to w_τ^+ with Type(w_τ^+)=τ and |w_τ^+| ∈ [s, s+ℓ_pump]. Define f as follows. For any (τ_L, s, τ_R), consider the path instance w_{τ_L}^+ · S · w_{τ_R}^+, where S is a 2-node window with input bits s. Assign unique IDs, with a fixed canonical ID pattern within distance < s/10 around S; complete the IDs arbitrarily outside. Run A; define f(τ_L,s,τ_R) to be the two outputs on the nodes of S. This is well-defined because within their T(n) < s/10 neighborhoods, the nodes of S see the same (canonical) inputs and IDs regardless of how w_{τ_L}^+, w_{τ_R}^+ are chosen within the allowed range.
To verify the extendibility condition, take arbitrary τ_a,τ_b,τ_c,τ_d ∈ T_long and s1,s2. Form the cycle G′ by concatenating w_{τ_a}^+, S1, w_{τ_b}^+, w_{τ_c}^+, S2, w_{τ_d}^+, where S1,S2 are 2-node separators with input bits s1,s2, respectively. Use the same canonical ID patterns inside distance < s/10 of S1 and S2 as in the definition of f; complete IDs arbitrarily elsewhere. Run A on G′. By construction, the outputs on S1 and S2 are as given by f; since A produces a legal labeling on G′, the block in the middle, w_{τ_b}^+ · w_{τ_c}^+, admits a legal labeling consistent with those seam outputs. By Lemma 11, this yields (o1,o2,o3,o4) ∈ Ext_{τ_b ⊙ τ_c} with E(α_L,o1) and E(o4,α_R), as required.
(⇐) Suppose a feasible f exists. Let K := ℓ_pump + 4. In O(log* n) rounds, compute a maximal independent set in the K-th power of the directed path; this selects “separators” at mutual distance at least K and ensures that every node is within distance ≤ K−1 of some separator. Consider the induced partition of the path into alternating separators (2 nodes each) and middle blocks; each middle block has length at most 2K−2 and at least K−2, hence its Type is long. Each separator can gather its local left/right contexts up to distance K to determine τ_L,τ_R ∈ T_long, and then outputs f(τ_L, s, τ_R) on its two nodes (s are the local input bits of the separator). The two boundary colors adjacent to each middle block are thus α_L (second output of its left separator) and α_R (first output of its right separator). By feasibility of f, there exists (o1,o2,o3,o4) ∈ Ext_{τ_b ⊙ τ_c} with E(α_L,o1) and E(o4,α_R), where τ_b,τ_c are the Types of the left and right context halves of the block. Because the block length is ≤ 2K−2 = O(1), the nodes inside the block can, in O(K)=O(1) rounds, collect the entire block input and the two seam outputs and deterministically choose a legal interior labeling consistent with that witness (e.g., the lexicographically smallest). This produces a globally legal labeling. Total round complexity is O(log* n) (separator placement dominates), with constants depending only on the instance but not on n. □

Corollary 16 (NEXPTIME verification of Stage-1).
We can decide the existence of a feasible f in nondeterministic time 2^{poly(β)}: deterministically enumerate T (Prop. 9), compute Ext_τ for τ∈T and Ext_{τ⊙σ} for τ,σ∈T_long (Prop. 5 and Lemma 11), nondeterministically guess f on T_long×{0,1}^2×T_long and verify the node/edge constraints and the universal extendibility condition by table lookups in Ext and E. The number of checks is O(|T_long|^4), with |T| ≤ 4·2^{β^4}.

Proposition 17 (Nonemptiness monotonicity under concatenation).
If Ext_P ≠ ∅ and Ext_Q ≠ ∅ and there exist x4,x1′ with E(x4,x1′), then Ext_{P·Q} ≠ ∅.
Proof. Choose any (o1,o2,x3,x4) ∈ Ext_P and (x1′,x2′,o3′,o4′) ∈ Ext_Q; Lemma 11 and E(x4,x1′) imply (o1,o2,o3′,o4′) ∈ Ext_{P·Q}. □
