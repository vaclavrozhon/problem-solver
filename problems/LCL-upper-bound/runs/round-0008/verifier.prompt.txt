--- SYSTEM ---
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (summary so far)
- output.md (rigorously proven results so far)

Guidelines:
- notes.md: should be a readable running log of interesting work. Prefer appending. Replace only if old notes are clearly misleading. Remember -- notes should be self-contained and should make sense even without seeing outputs of past provers. 
- output.md:  Think twice before you add something to this file. Everything here should be rigorous, almost publication-ready. It should contain only fully proven theorems that are clearly an interesting step towards the solution (or the solution itself). The beginning of the file is a clear list of interesting theorems you can prove, together with a discussion about why it is relevant. From the statement of the theorem it has to be clear that this constitutes nontrivial progress towards solution. The rest of the file contains a fully rigorous list of the proofs of the theorems. Keep only proven theorems with clear proofs. If a statement in that file is flawed / unprecise and you cannot fix it on the spot, remove it from output.md and instead add it to notes.md with explanation.
- Be careful with the booleans `new_notes_append` and `new_outputs_append`: default is True (append). Use False only when deliberately rewriting everything.

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (≥200 words). Include concrete next-step suggestions. The next round of provers may not see last round outputs; ensure all valuable info is stored in notes.",
  "new_notes_md": "Markdown (KaTeX allowed). Usually appended to notes.",
  "new_notes_append": "True|False",
  "new_outputs_md": "Markdown (KaTeX allowed). Usually appended to output.md.",
  "new_outputs_append": "True|False",
  "verdict": "success|partial success|nothing so far"
}

**Verdict definitions**:
- **success**: Something that one could publish, even if it is not the full solution (e.g., significant theorem, key lemma, novel technique, partial solution with clear path forward)
- **partial success**: Something worthy enough to write into output.md (e.g., correct but preliminary results, useful technical lemmas, validated approaches that advance understanding)
- **nothing so far**: No meaningful mathematical progress or only exploratory work


--- USER ---
You receive multiple prover reports. Evaluate correctness, value, and pick promising directions. Update notes.md (append/replace) with useful ideas and update output.md (append/replace) ONLY with rigorously verified results.

Prover reports (JSON):
[{"prover_id": "01", "progress_md": "Round 0008 \u2014 endpoints for Stage-1 on paths, missing base case k=2\u21923, and a clean endpoint-aware feasible-function theorem\n\nSummary of gaps spotted in output.md\n- Missing base case k=2\u21923. The current output.md has Proposition 6 (k=1\u21922) and Proposition 7 (k=3\u21924), but does not state the k=2\u21923 update explicitly. This base rule is used by \u03b4 and is necessary for deterministic enumeration from length 1.\n- Stage-1 equivalence is still marked as \u201cpending endpoint treatment.\u201d The text has a clean Out-set feasible-function definition and the pumping/concatenation tools, but the (\u21d0) direction on paths needs endpoint handling. This is the main blocker to claiming the \u03c9(n) vs o(n) trichotomy on globally oriented paths.\n- Minor duplication: concatenation is stated once for k_flag\u22654 (Lemma 2) and later for all k_flag (Lemma 11). It is harmless, but a single \u201call k_flag\u201d statement would suffice.\n\nProposed additions (self-contained, Ext-level, auditable) to close the Stage-1 endpoint gap\n\nDefinitions (endpoint projections and seam matrices)\n- RightColors(\u03c4) := { y \u2208 \u03a3_out : \u2203 x1,x2,x3 with (x1,x2,x3,y) \u2208 Ext_\u03c4 }.\n- LeftColors(\u03c4) := { x \u2208 \u03a3_out : \u2203 x2,x3,x4 with (x,x2,x3,x4) \u2208 Ext_\u03c4 }.\n- Endpoint seam-compatibility matrices:\n  - V_left[\u03c4][\u03b1] is true iff \u2203 y \u2208 RightColors(\u03c4) with E(y, \u03b1).\n  - V_right[\u03b1][\u03c4] is true iff \u2203 x \u2208 LeftColors(\u03c4) with E(\u03b1, x).\nWhy useful here. These capture exactly the one-sided feasibility needed to glue an endpoint block to its unique adjacent separator by a single E-edge. They can be computed in time 2^{poly(\u03b2)} after Ext tables, and they reduce all endpoint checks to constant-time lookups.\n\nLemma E1 (endpoint equivalences)\n- For any type \u03c4 and any color \u03b1, there exists a legal labeling of a left end-block P of type \u03c4 that matches E at the seam to a separator whose first output is \u03b1 iff V_left[\u03c4][\u03b1] is true.\n- Dually, there exists a legal labeling of a right end-block P of type \u03c4 that matches E at the seam from a separator whose second output is \u03b1 iff V_right[\u03b1][\u03c4] is true.\nSketch proof. The rightmost coordinate of Ext_\u03c4 lists all possible o4; the existence of an o4 with E(o4, \u03b1) is precisely V_left[\u03c4][\u03b1]. For the right end, the leftmost coordinate lists all possible o1; the existence of x with E(\u03b1, x) is V_right[\u03b1][\u03c4]. In both directions, Ext-membership provides the interior completion.\nWhy useful here. This is the missing local criterion to fill one-sided blocks in the Stage-1 construction on finite paths.\n\nEndpoint-aware Stage-1 witness for paths\n- Mid-separator feasible function (as in output.md). f_mid: T_long \u00d7 {0,1}^2 \u00d7 T_long \u2192 \u03a3_out^2 with the Out-set universal check via Ext_{\u03c4_b \u2299 \u03c4_c}.\n- Endpoint witnesses:\n  - g_L: T \u00d7 {0,1}^2 \u2192 \u03a3_out^2 assigns the 2-node output on the unique separator adjacent to the left endpoint; for each (\u03c4_end, s), let g_L(\u03c4_end, s) = (\u03b21, \u03b22).\n  - g_R: {0,1}^2 \u00d7 T \u2192 \u03a3_out^2 assigns the 2-node output on the unique separator adjacent to the right endpoint; for each (s, \u03c4_end), let g_R(s, \u03c4_end) = (\u03b21, \u03b22).\nConstraints for g_L,g_R:\n  - Node/window legality: \u03b2i \u2208 A_{s[i]} (i=1,2) and E(\u03b21, \u03b22).\n  - One-sided seam feasibility: V_left[\u03c4_end][\u03b21] = true for g_L, and V_right[\u03b22][\u03c4_end] = true for g_R.\nWhy useful here. These capture exactly the conditions needed to legally glue an endpoint block to its neighbor separator using only Ext-tables (no global simulation).\n\nTheorem P-S1 (Stage-1 on globally oriented paths)\nLet P be a \u03b2-normalized radius-1 LCL on globally oriented paths. The following are equivalent:\n1) P has deterministic LOCAL complexity o(n) on paths.\n2) There exist witnesses (f_mid, g_L, g_R) satisfying: f_mid is feasible (Out-set form in output.md) and g_L,g_R satisfy the above constraints with V_left,V_right.\nMoreover, the existence of such witnesses is verifiable in nondeterministic time 2^{poly(\u03b2)}.\n\nProof outline and how it fits the current framework\n- (\u21d2) Given an o(n) algorithm A, extract f_mid as in output.md (Lemma 18 style) using pumping and concatenation. For g_L and g_R, place a single separator S next to an arbitrary end block of type \u03c4_end, embed the configuration in a large pumped path to the left/right, simulate A for o(n) rounds, and define g_L(\u03c4_end, s) (resp. g_R) as the 2-node output on S. Local legality of A guarantees the node/window constraints, and seam legality implies the corresponding endpoint matrix entry (Lemma E1). All constructions depend only on Types by pumping; hence well-defined.\n- (\u21d0) Given (f_mid, g_L, g_R), compute in O(log* n) rounds an MIS on the K-th power of the directed path with K := \u2113_pump + 4. As in output.md, label every internal separator with f_mid and fill each middle block via the Ext-witness in Ext_{\u03c4_b \u2299 \u03c4_c}. For the left end block P_end with its unique neighbor separator S, let g_L(\u03c4_end, s) = (\u03b21, \u03b22). By V_left[\u03c4_end][\u03b21], choose (o1,o2,o3,o4) \u2208 Ext_{\u03c4_end} with E(o4, \u03b21) and fill P_end accordingly; similarly the right end via g_R and V_right. All node and edge constraints hold by Ext membership and seam E-tests. Runtime is O(log* n); endpoints add no overhead.\n- NEXPTIME verification. Deterministically enumerate T, T_long, Ext tables, and precompute V_left,V_right and the seam-feasibility matrices W_{b\u2299c} (already in output.md). Nondeterministically guess f_mid, g_L, g_R and verify: (i) node/window constraints for all entries; (ii) the Out-set universal checks for f_mid using W_{b\u2299c}; (iii) one-sided checks for g_L,g_R using V_left,V_right. Total time 2^{poly(\u03b2)}.\nWhy useful here. This removes the \u201cpending endpoint treatment\u201d remark and completes the o(n) vs \u03a9(n) decision for globally oriented paths at the type/Ext level.\n\nExplicit k=2\u21923 base-case to insert\nProposition (Base-case update; k=2\u21923). Let t = (b1, b2), t\u2032 := t\u00b7a. For all (x1, x2, x3, x4) \u2208 \u03a3_out^4,\n(x1,x2,x3,x4) \u2208 Ext_{t\u2032} \u21d4 [ x3 = x2, x1 \u2208 A_{b1}, x2 \u2208 A_{b2}, x4 \u2208 A_a, E(x1,x2), E(x2,x4) ].\nWhy useful here. Needed by \u03b4 to lift k_flag from 2 to 3 and to make the append DP fully constructive from seeds.\n\nComplexity notes (consistent with output.md)\n- Precompute T via \u03b4 in 2^{poly(\u03b2)}; compute Ext_\u03c4 for all \u03c4 and Ext_{\u03c4_b \u2299 \u03c4_c} (for \u03c4_b,\u03c4_c \u2208 T_long) using the O(\u03b2^6) routine; precompute W_{b\u2299c} and V_left,V_right in \u03b2^{O(1)} per pair.\n- Certificate size: f_mid has |T_long|^2\u00b74 entries; g_L has |T|\u00b74, g_R has |T|\u00b74 entries. Verification consists of constant-time table lookups per case; total time 2^{poly(\u03b2)}.\n\nSanity checks (toy instances)\n- Equality LCL (E={(c,c)}, A_0=A_1={c}). RightColors(\u03c4)=LeftColors(\u03c4)={c} for all \u03c4; choose f_mid(\u00b7)=(c,c), g_L=g_R=(c,c). All matrices trivial; accepts.\n- Proper 2-coloring (\u03a3_out={a,b}, E forbids equal). A standard f_mid exists (alternating), and V_left,V_right are always true since RightColors=LeftColors={a,b}. Stage-1 accepts. (Stage-2 will correctly reject constant-time.)\n- Linear-hard case: If for some \u03c4_end, RightColors(\u03c4_end) has no E-neighbor in a color forced as \u03b21 by any g_L, then V_left fails and the verifier rejects, certifying \u03a9(n).\n\nAction items for outputs.md\n- Add the k=2\u21923 base rule explicitly (as above), beside k=1\u21922 and k=3\u21924.\n- Add RightColors/LeftColors and the endpoint matrices V_left,V_right with a short correctness lemma (Lemma E1).\n- Add the endpoint-aware Stage-1 theorem (Theorem P-S1) with the construction/verification outline; reference existing Lemmas 11\u201314 and Prop. 21 for the internal (two-sided) parts.\n- Optional editorial: merge Lemma 2 and Lemma 11 into a single \u201call k_flag\u201d concatenation lemma, or keep both but note that Lemma 11 subsumes Lemma 2.\n\nNotes toward Stage-2 (constant vs log* n)\n- The paper\u2019s (\u2113_width, \u2113_count, \u2113_pattern)-partition (Lemma 22) is already reproduced for cycles and applies to oriented paths with a simpler orientation primitive. Integrating the per-type boundary-interface witness Q_\u03c4 and bridging checks from earlier rounds should now be feasible. I will prepare a path-specialized statement and proof next, using the existing Ext machinery and associativity.\n\nWhy these steps are incremental and testable\n- All additions reduce to precomputable projections or matrices over already-defined Ext tables; no new global gadgets are used.\n- The endpoint matrices enable immediate unit tests: compute V_left,V_right on random tiny instances and compare against brute-force searches over Ext.\n- The endpoint-aware theorem uses the same MIS-based spacing (already standard and cited) and reuses W_{b\u2299c}; only constant-size endpoint lookups are added.\n"}, {"prover_id": "02", "progress_md": "Round 0008 \u2014 Path endpoints for Stage\u20111, Stage\u20112 certificate formalization for oriented paths, and audit items\n\nSummary\n- I propose a complete, endpoint-aware Stage\u20111 characterization for globally oriented paths that is verifiable in NEXPTIME and closes the gap currently marked as \u201cpending endpoint treatment\u201d in output.md. The witness consists of (i) a two-sided feasible function f_mid on long types, plus (ii) one-sided endpoint witnesses g_L and g_R certified via precomputed endpoint seam-compatibility matrices derived from Ext.\n- I also propose a precise Stage\u20112 (O(1) vs \u03a9(log* n)) certificate specialized to globally oriented paths, with a constant-time construction proof that reuses the paper\u2019s (\u2113_width,\u2113_count,\u2113_pattern)-partition framework, now expressed wholly in Ext/type terms. This fills the other major missing piece.\n- I point out several small gaps/cleanups in output.md (notably the missing k=2\u21923 base case and a minor duplication) and list concise steps to integrate the new lemmas and theorems.\n\nAudit of output.md: gaps and cleanups\n- Missing base case k=2\u21923. Proposition 6 (k=1\u21922) and Proposition 7 (k=3\u21924) are present, but the explicit k=2\u21923 update is absent. This is needed to seed \u03b4 transitions from length 2.\n  \u2022 Correct rule to add: for t=(b1,b2), t\u2032=t\u00b7a,\n    (x1,x2,x3,x4)\u2208Ext_{t\u2032} iff [x3=x2, x1\u2208A_{b1}, x2\u2208A_{b2}, x4\u2208A_a, E(x1,x2), E(x2,x4)].\n- Stage\u20111 equivalence on paths is marked \u201cpending endpoint treatment.\u201d Below I supply a self-contained endpoint-aware witness, a verification routine, and an equivalence theorem using only Ext and Types.\n- Redundancy: Lemma 2 (Ext concatenation for k_flag\u22654) and Lemma 11 (for all k_flag) both appear. Lemma 11 subsumes Lemma 2; we can keep both but it is clearer to refer uniformly to Lemma 11.\n- Stage\u20112 (O(1) vs \u03a9(log* n)) is not yet included. I give a precise per-type boundary-interface witness and an O(1) labeling construction for oriented paths, with checks entirely in Ext.\n\nPreliminaries to add (endpoint projections)\n- Define for any type \u03c4:\n  \u2022 RightColors(\u03c4) := { y \u2208 \u03a3_out : \u2203x1,x2,x3 s.t. (x1,x2,x3,y) \u2208 Ext_\u03c4 }.\n  \u2022 LeftColors(\u03c4)  := { x \u2208 \u03a3_out : \u2203x2,x3,y s.t. (x,x2,x3,y) \u2208 Ext_\u03c4 }.\n  These are just projections of Ext_\u03c4; computable in O(\u03b2^4) per \u03c4.\n- Define endpoint seam-compatibility (precompute once):\n  \u2022 V_left[\u03c4][\u03b11] = true iff \u2203y\u2208RightColors(\u03c4) with E(y,\u03b11).\n  \u2022 V_right[\u03b12][\u03c4] = true iff \u2203x\u2208LeftColors(\u03c4) with E(\u03b12,x).\n  These witness that an end block of type \u03c4 can be attached to the first (resp. last) node of the adjacent 2-node separator colored \u03b11 (resp. \u03b12).\n\nStage\u20111 (\u03a9(n) vs o(n)) on globally oriented paths \u2014 endpoint-aware witness and equivalence\nWitness objects to guess and verify\n- Long types: T_long := {\u03c4 : k_flag(\u03c4)\u22654}. Precompute T and split.\n- Mid-separator feasible function f_mid: T_long \u00d7 {0,1}^2 \u00d7 T_long \u2192 \u03a3_out^2.\n  \u2022 Local legality: if f_mid(\u03c4_L, s, \u03c4_R)=(\u03b11,\u03b12), require \u03b1i\u2208A_{s[i]} and E(\u03b11,\u03b12).\n  \u2022 Universal extendibility across two separators: For all \u03c4_b,\u03c4_c\u2208T_long, s1,s2\u2208{0,1}^2 and for all \u03b1_L \u2208 OutR2(\u03c4_b,s1), \u03b1_R \u2208 OutL1(\u03c4_c,s2), require \u2203(o1,o2,o3,o4)\u2208Ext_{\u03c4_b\u2299\u03c4_c} with E(\u03b1_L,o1) and E(o4,\u03b1_R). Here\n    OutR2(\u03c4_b,s):={second(f_mid(\u03c4_a,s,\u03c4_b)): \u03c4_a\u2208T_long},\n    OutL1(\u03c4_c,s):={first(f_mid(\u03c4_c,s,\u03c4_d)): \u03c4_d\u2208T_long}.\n  \u2022 Verification reduction: precompute W_{b\u2299c}[\u03b1_L][\u03b1_R] as in Prop. 21; then check W_{b\u2299c}[\u03b1_L][\u03b1_R]=true for all required \u03b1_L, \u03b1_R.\n- Endpoint witnesses: g_L : T \u00d7 {0,1}^2 \u2192 \u03a3_out^2 and g_R : {0,1}^2 \u00d7 T \u2192 \u03a3_out^2.\n  \u2022 Local legality: if g_L(\u03c4_end,s)=(\u03b21,\u03b22) then \u03b2i\u2208A_{s[i]} and E(\u03b21,\u03b22). Symmetric for g_R.\n  \u2022 One-sided feasibility: V_left[\u03c4_end][\u03b21]=true for g_L, and V_right[\u03b22][\u03c4_end]=true for g_R.\n\nTheorem S1-path (equivalence; oriented paths).\nAn r=1, \u03b2-normalized LCL on globally oriented paths has deterministic complexity o(n) iff there exist witnesses (f_mid, g_L, g_R) satisfying the above checks. Moreover, existence is verifiable in nondeterministic time 2^{poly(\u03b2)}.\nSketch proof (\u21d2): Given an o(n)-round algorithm A, define f_mid exactly as in the cycle case by pumping the two long contexts on either side of a 2-node separator; feasibility uses Ext_{\u03c4_b\u2299\u03c4_c} (Lemma 11) and pumping (Lemmas 13\u201314). Define g_L(\u03c4_end,s), g_R(s,\u03c4_end) by simulating A on a path that consists of a long pumped left (resp. right) context, then the endpoint block of type \u03c4_end, then a 2-node separator S with input s, then a long pumped right (resp. left) context; pick IDs so that A\u2019s runtime halo is well inside the pumped parts. Local legality is by correctness of A; one-sided feasibility follows because the seam edge between the endpoint block and S is satisfied in the simulation, hence V_left/V_right holds by projection to Ext.\nSketch proof (\u21d0): From (f_mid, g_L, g_R), construct in O(log* n) a labeling as follows. In O(log* n) rounds, compute an MIS on the K-th power of the oriented path (K:=\u2113_pump+4); separators are the selected MIS nodes augmented to 2-node blocks with inputs s, spaced in [K,2K]. For each interior pair of separators (S1, S2) with adjacent long types \u03c4_b, \u03c4_c on their sides, color S1 and S2 by f_mid, and complete the middle using the witness in Ext_{\u03c4_b\u2299\u03c4_c}. For endpoint segments, color the unique separator S by g_L or g_R and complete the adjoining block using V_left or V_right and Ext of the endpoint type. All checks and fillings are local and constant-radius; runtime O(log* n) comes from MIS.\nNEXPTIME verification: Deterministically compute T, T_long, Ext and W_{b\u2299c}, V_left, V_right in 2^{poly(\u03b2)} time. Nondeterministically guess f_mid, g_L, g_R and verify the finite set of constraints via table lookups; total time 2^{poly(\u03b2)}.\n\nStage\u20112 (O(1) vs \u03a9(log* n)) on globally oriented paths \u2014 per-type boundary interface\nWitness per long type \u03c4\u2208T_long: Q_\u03c4=(L1_\u03c4,L2_\u03c4,R2_\u03c4,R1_\u03c4)\u2208Ext_\u03c4.\nChecks\n- Per-type tiling:\n  \u2022 E(L1_\u03c4,L2_\u03c4), E(R2_\u03c4,R1_\u03c4) (redundant but explicit), and wrap E(R1_\u03c4,L1_\u03c4).\n- Universal bridging across any middle type \u03c4_S (short or long):\n  \u2022 For all \u03c4_left, \u03c4_S, \u03c4_right with \u03c4_left,\u03c4_right\u2208T_long: \u2203(o1,o2,o3,o4)\u2208Ext_{\u03c4_S} with E(R1_{\u03c4_left},o1) and E(o4,L1_{\u03c4_right}). For S empty, this reduces to E(R1_{\u03c4_left},L1_{\u03c4_right}).\nTheorem S2-path (constant-time construction).\nIf {Q_\u03c4} satisfy the above, there is an O(1)-round deterministic algorithm on oriented paths.\nSketch construction: In O(1) rounds compute an (\u2113_width,\u2113_count,\u2113_pattern)-partition (as in the paper\u2019s Lemma 22; here orientation is globally given). Choose parameters \u2113_width=\u2113_pattern=\u2113_pump and \u2113_count=2\u2113_pump+2. Long paths are periodic with primitive period length \u2264\u2113_pump, repeated \u2265\u2113_count. Each long path P has a long type \u03c4; tile P by repeats of \u03c4 using E(R1_\u03c4,L1_\u03c4); interior legality holds since Q_\u03c4\u2208Ext_\u03c4. Each short/irregular separator S (any \u03c4_S) is filled using its Ext witness to match the boundary colors of adjacent long blocks (bridging condition). Endpoints need no special treatment beyond bridging to the nearest long block. All decisions are constant-radius.\nNEXPTIME verification: Guess {Q_\u03c4} over T_long; verify tiling and bridging universally with Ext lookups; total time 2^{poly(\u03b2)}.\n\nComplexity refinements and preprocessing\n- Append optimization (already Proposition 19): O(\u03b2^4) per append after Left3 slices.\n- Concatenation optimization (Proposition 5): O(\u03b2^6) per pair via Left/Right 3D slices.\n- Seam feasibility matrices W_{b\u2299c} (Proposition 21): speed up Stage\u20111 verification.\n- Endpoint matrices V_left, V_right: O(|T|\u00b7\u03b2\u00b7\u0394) preprocessing; used by g_L/g_R verification.\n\nSanity checks on examples\n- Equality LCL: choose c\u2208A_0\u2229A_1 with E(c,c); f_mid constant (c,c); g_L, g_R constant (c,c); any Q_\u03c4=(c,c,c,c); both stages accept \u21d2 O(1).\n- Proper 2-coloring: Stage\u20111 witnesses exist (\u0398(log* n)); Stage\u20112 fails due to wrap E(R1_\u03c4,L1_\u03c4) and universal bridging impossibility with a period\u20111 interface; classification \u0398(log* n).\n- Linear case: if no feasible (f_mid,g_L,g_R) exists, Stage\u20111 rejects \u21d2 \u03a9(n).\n\nActionable insertions for output.md\n1) Add Proposition (Base-case update; k=2\u21923) exactly as stated in the audit.\n2) Add definitions of RightColors, LeftColors, V_left, V_right, and a short proposition on their computation/complexity.\n3) Add the endpoint-aware Stage\u20111 theorem S1-path: statement, witness definitions (f_mid, g_L, g_R), quantifier-minimized verification using W_{b\u2299c}, and both directions of the equivalence (with brief, oriented-path-specific proofs relying on Lemmas 11, 13\u201314).\n4) Add Stage\u20112 theorem S2-path: the per-type boundary interface witness Q_\u03c4, universal checks, and the O(1) labeling construction using the (\u2113_width,\u2113_count,\u2113_pattern)-partition on oriented paths (cite the paper\u2019s lemma if not reproved in full; parameters explicit).\n5) Note that Lemma 11 subsumes Lemma 2 and refer to Lemma 11 uniformly for concatenation; optionally keep Lemma 2 as a corollary for readability.\n\nWhy these fill the gaps\n- Stage\u20111 now covers finite paths with endpoints rigorously, removing the caveat. All conditions are expressed with Ext plus precomputed matrices, so the verification remains single-exponential. The construction uses only standard Kth\u2011power MIS.\n- Stage\u20112 shifts entirely to per-type interfaces and Ext bridging, matching the paper\u2019s constant-time regime but specialized to globally oriented paths. The verification is again single-exponential; the algorithm is explicit and constant\u2011round.\n\nNext steps\n- Integrate the new statements into output.md with concise proofs. Keep the MIS step description and (\u2113_width,\u2113_count,\u2113_pattern)-partition paraphrased from the paper but specialized to oriented paths.\n- Add a small regression suite for \u03b2\u2208{2,3}: (i) verify k=2\u21923 update; (ii) validate V_left/V_right vs direct Ext; (iii) test W_{b\u2299c} correctness; (iv) confirm Stage\u20111 acceptance on equality LCL, Stage\u20112 rejection on 2\u2011coloring.\n"}]

Current notes.md:
Corrections and key lemmas to record

1) Correct append-one-bit recurrence (r=1)
Given a type t with Ext_t ⊆ Σ_out^4 over boundary (L1,L2,R2,R1) and an appended input bit a, the new type t′ has boundary (L1′,L2′,R2′,R1′) = (L1,L2, old R1, new), i.e., R2′ = R1 and R1′ is the label of the appended node. Formally, for each candidate quadruple (x1,x2,x3,x4) ∈ Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [x4 ∈ A_a and E(x3,x4) and ∃ z ∈ Σ_out: (x1,x2,z,x3) ∈ Ext_t].
This yields an O(β^5) DP to fill Ext_{t′} by scanning all (x1,x2,x3,x4) and checking ∃z.

Congruence lemma (needed): If Type(P)=Type(Q), then for all a ∈ {0,1}, Type(Pa)=Type(Qa). Proof sketch: The predicate “there exists an interior completion consistent with boundary assignments” over D1∪D2 is preserved under appending one node by the above DP rule, which depends only on Ext_t and a.

2) Concatenation of summaries (r=1)
If Summ(P) has Ext_P and Summ(Q) has Ext_Q, then the concatenation B=P·Q has boundary (P.left endpoint, P.left neighbor, Q.right neighbor, Q.right endpoint) and
  (o1,o2,o3′,o4′) ∈ Ext_B ⇔ ∃ x3,x4,x1′,x2′ ∈ Σ_out: (o1,o2,x3,x4) ∈ Ext_P, (x1′,x2′,o3′,o4′) ∈ Ext_Q, and E(x4,x1′).
Then R_B can be derived from Ext_B as usual.

3) Counterexample to R-composition via ∃m
Let Σ_out={a,b,c}, A_0=A_1=Σ_out. Let E={a→b, b→c} only. Suppose t_b admits a boundary tuple with right endpoint a, and t_c admits a boundary tuple with left endpoint c (interiors arbitrary but extendible). Then choose m=b. We have (x,m) ∈ R_{t_b} for any x with a valid left edge, and (m,y) ∈ R_{t_c} for suitable y. But the concatenation t_b·t_c requires the seam edge a→c, which is forbidden. Hence ∃m composition of R_t is not sound; use Ext-level concatenation and R_B instead.
Additions and fixes (r=1)

A) Correct k=2→3 base-case update
Let t=(b1,b2) and t′=t·a (length 3). Then
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [x3=x2, x1∈A_{b1}, x2∈A_{b2}, x4∈A_a, E(x1,x2), E(x2,x4)].
This replaces any prior statement that involved x2∈A_a.

B) Type representation and congruence
Define Type(t) := (b_in(t), Ext_t, k_flag(t)), where k_flag ∈ {1,2,3,≥4} indicates whether boundary coordinates coincide due to short length. Then the congruence lemma holds in the form:
  If Type(P)=Type(Q), then for all a∈{0,1}, Type(Pa)=Type(Qa).
Proof: case split on k_flag using the explicit base-case rules for k_flag∈{1,2,3} and the general append recurrence for k_flag=≥4.
Remark: Ext equality alone does not determine |t| (e.g., with E self-loops and A_0=A_1, Ext_{len 2} = Ext_{len 4}). Hence the k_flag is necessary for a length-agnostic update routine.

C) Enumeration fix
In the BFS over types, key the dictionary by the full Type(t), including k_flag. After the first transition to k_flag=≥4, all descendants remain in k_flag=≥4 and subsequent δ updates are length-agnostic.
Additions: Stage-1 and Stage-2 specifications at the Ext level (r=1, oriented paths)

Notation. Σ_out has size β. For an input word t with bits b_in(t) ∈ {0,1}^{|t|}, let Ext_t ⊆ Σ_out^4 denote the set of boundary quadruples (L1,L2,R2,R1) = (o[1],o[2],o[|t|-1],o[|t|]) that admit an interior completion o consistent with node constraints o[i]∈A_{b_in(t)[i]} and edge constraints (o[i],o[i+1])∈E. Types are Type(t)=(Ext_t, k_flag(t)), where k_flag∈{1,2,3,≥4} encodes short-length degeneracies. Concatenation of types τ⊙σ is defined by the Ext-level concatenation rule (see outputs.md) and k_flag update.

Stage-1 (Ω(n) vs o(n)): type-level feasible function
- Universe: the finite set of types T obtained by BFS from k=1 under the append-one-bit updates (keyed by (Ext,k_flag)). For τ,σ∈T, the Ext of τ⊙σ is defined by Ext-level concatenation.
- Definition (feasible f). A function f: T × {0,1}^2 × T → Σ_out^2 mapping (τ_L, s, τ_R) to (α1,α2) is feasible if:
  (i) Node/window constraints: αi ∈ A_{s[i]} for i=1,2 and (α1,α2) ∈ E (i.e., E(α1,α2) holds).
  (ii) Universal extendibility across two separators: for all τ_a,τ_b,τ_c,τ_d∈T and s1,s2∈{0,1}^2, letting α_L := second component of f(τ_a,s1,τ_b) and α_R := first component of f(τ_c,s2,τ_d), we require
      ∃ (o1,o2,o3,o4) ∈ Ext_{τ_b ⊙ τ_c} with E(α_L,o1) and E(o4,α_R).
  Comment: The quantification over τ_a and τ_d is stronger than necessary but safe; a weaker version quantifies only over τ_b,τ_c and s1,s2. Indexing uses our convention (L1,L2,R2,R1); thus o1 and o4 are the first and last outputs of the middle block of type τ_b⊙τ_c.
- NEXPTIME check: deterministically enumerate T and all Ext_{τ} and on-demand Ext_{τ⊙σ}; nondeterministically guess f; verify (i) and (ii) exhaustively. Complexity is 2^{poly(N)} in the problem description size N.
- Status: We still owe a self-contained proof that “o(n) algorithm exists iff a feasible f exists” at the Ext level (the intended replacement of the paper’s feasible-function lemma). This will rely only on our Ext-append and Ext-concat lemmas and a standard pumping argument specialized to r=1.

Stage-2 (O(1) vs Ω(log* n)): per-type boundary-interface witness
- For each τ∈T with k_flag(τ)≥4, guess Q_τ=(L1_τ,L2_τ,R2_τ,R1_τ) with Q_τ ∈ Ext_τ. Enforce:
  (a) Local consistency and tiling: E(L1_τ,L2_τ), E(R2_τ,R1_τ), and wrap E(R1_τ,L1_τ). Intuition: long blocks of type τ can be tiled by copies using the same boundary outputs.
  (b) Bridging across any middle type (including empty): for all τ_left,τ_S,τ_right ∈ T, require either
      - if τ_S has k_flag≥1: ∃ (o1,o2,o3,o4) ∈ Ext_{τ_S} with E(R1_{τ_left},o1) and E(o4,L1_{τ_right}); or
      - if τ_S is empty: E(R1_{τ_left},L1_{τ_right}).
- Decision logic: if witnesses {Q_τ} exist and pass (a)–(b), classify O(1). Else, if a Stage-1 feasible f exists, classify Θ(log* n). Otherwise, classify Θ(n).
- Status: We still owe a concrete constant-radius construction on oriented paths from {Q_τ} (e.g., a partition/tiling routine parametrized by fixed radii ℓ_width, ℓ_pattern, ℓ_count) and a proof that the produced labeling is legal. Short types (k_flag<4) are treated as separators τ_S in (b).

Faster concatenation (proven and moved to outputs.md)
- Precompute for each τ the 3D slices: Left_τ[o1,o2,x4] := ∃x3 (o1,o2,x3,x4)∈Ext_τ, and Right_τ[x1′,o3′,o4′] := ∃x2′ (x1′,x2′,o3′,o4′)∈Ext_τ.
- Then (o1,o2,o3′,o4′)∈Ext_{τ⊙σ} iff ∃x4,x1′: Left_τ[o1,o2,x4] ∧ E(x4,x1′) ∧ Right_σ[x1′,o3′,o4′]. This allows computing Ext_{τ⊙σ} in O(β^6) time after O(β^4) precomputation per type.

Sanity checks (kept as examples)
- Trivial LCL (A_0=A_1=Σ_out, E complete): Ext_τ=Σ_out^4 for all τ; Stage-2 witness exists trivially ⇒ O(1).
- Equality LCL (E={(x,x)}): take Q_τ=(c,c,c,c) ⇒ O(1).
- Proper 2-coloring: Stage-2 fails; Stage-1 feasible f should exist ⇒ Θ(log* n).
- Linear cases with incompatible seams: Stage-1 fails ⇒ Ω(n).
Updates and clarifications (r=1, oriented paths)

1) Base-case updates finalized
- k=1→2 is special and cannot be derived from the general append recurrence without over-constraining x1=x2; we record an explicit rule in outputs.md.
- k=3→4 is also added explicitly (although it follows from the same recurrence if stated for k≥2). This ensures δ can move from short types to k_flag≥4 deterministically.

2) Type-count bound corrected
Type(t) consists of (Ext_t, k_flag(t)) only; boundary input bits are not part of Type. Hence the number of types satisfies
  |T| ≤ 4 · 2^{β^4}.
The earlier 16 · 2^{β^4} bound mixed in boundary input bits unnecessarily.

3) δ well-defined and BFS enumeration
- Seeds: k=1 types for b∈{0,1} (Ext_{(b)} = {(x,x,x,x): x∈A_b}).
- Transitions: use base-cases for k<4 (1→2, 2→3, 3→4) and Lemma 1 for k≥4. By congruence, δ(Type, a) depends only on (Ext, k_flag) and a.
- Termination and complexity: at most |T| ≤ 4·2^{β^4} insertions; each append is O(β^5) in the k≥4 regime (base-cases are ≤ O(β^4)); total time/space 2^{poly(β)}.

4) Reversal operator (optional but helpful)
Define Rev(τ) = (Ext_τ^R, k_flag(τ)) with Ext_τ^R := { (y1,y2,y3,y4) : (y4,y3,y2,y1) ∈ Ext_τ }. Then Rev(Rev(τ))=τ and Ext_{Rev(τ) ⊙ Rev(σ)} = (Ext_{σ ⊙ τ})^R.

5) Stage-1 and Stage-2 (status)
- Stage-1 (Ω(n) vs o(n)): the feasible function f: T × {0,1}^2 × T → Σ_out^2 with the universal Ext-based check (seams E(α_L, o1), E(o4, α_R), using the (L1,L2,R2,R1) ordering) is the right formal object. We still need a fully self-contained proof of the equivalence “o(n) iff such f exists”.
- Stage-2 (O(1) vs Ω(log* n)): the per-type witness Q_τ∈Ext_τ for k_flag≥4 with tiling and universal bridging checks is plausible. A complete constant-radius construction on oriented paths remains to be written and verified.

6) Sanity and regression items
- β=2 trivial LCLs and equality LCL check the base-cases and concatenation routines.
- Reconfirm the 3-color counterexample for R-composition via ∃m.
- Maintain an indexing reminder: Ext quadruples are ordered (L1,L2,R2,R1); in seam checks across a middle block of type τ_b⊙τ_c, the left seam meets o1 and the right seam meets o4.
New additions (r=1, oriented paths): pumping, general concatenation, and Stage-1 equivalence

- Pumping bound and lemmas. Let T be the set of reachable types (Proposition 9) and δ: T×{0,1}→T the append transition. Define
  ℓ_pump := |T|.
  Lemma (prefix pumping). For any input w with |w| ≥ ℓ_pump there exist x,y,z with 1 ≤ |y| ≤ ℓ_pump and |xy| ≤ ℓ_pump such that Type(x y^i z) is independent of i ≥ 0.
  Lemma (periodic pumping). For any nonempty u there exist a,b with a+b ≤ ℓ_pump such that Type(u^{a+bi}) is invariant for all i ≥ 0.
  Both follow from the pigeonhole principle applied to the δ-run over Types.

- Ext-level concatenation for all k_flags and associativity. The general concatenation rule (Ext_{P·Q} witnessed by Ext_P and Ext_Q with a seam constraint E(x4,x1′)) holds verbatim for all lengths because Ext for short words already lives in Σ_out^4 with coordinate equalities enforced by k_flag. Associativity of Ext-concatenation follows semantically (concatenation of words is associative) or by rebracketing seam witnesses.

- Stage-1 (Ω(n) vs o(n)). Restrict left/right context Types to T_long := {τ∈T : k_flag(τ)≥4}. Define a feasible f: T_long×{0,1}^2×T_long→Σ_out^2 that (i) satisfies node/edge constraints on the 2-node separator and (ii) for all τ_b,τ_c∈T_long and s1,s2, and for all τ_a,τ_d∈T_long (affecting only α_L,α_R), there exists (o1,o2,o3,o4)∈Ext_{τ_b⊙τ_c} with E(α_L,o1) and E(o4,α_R), where α_L is the second output of f(τ_a,s1,τ_b) and α_R is the first output of f(τ_c,s2,τ_d). Theorem (added to output.md): an r=1, oriented-path LCL has deterministic complexity o(n) iff such a feasible f exists. Proof outline recorded in output.md: (⇒) extract f from an o(n) algorithm via pumping and a cycle-gadget; (⇐) place separators by an MIS on the K-th power of the path with K≳ℓ_pump and solve each O(K)-long block locally using the guaranteed Ext-witness; total time O(log* n).

- Stage-2 (O(1) vs Θ(log* n)). The per-type interface Q_τ∈Ext_τ (for τ∈T_long) with tiling and universal bridging checks remains a plausible certificate. However, the constant-radius partition of an arbitrary input path into “long periodic” and “short/irregular” subpaths is not yet proven in this writeup. Do not claim S2 in output.md until a self-contained partition lemma (parameters and proof) is supplied or the construction is reworked to avoid this dependency.

- Minor lemma. Nonemptiness monotonicity under concatenation: if Ext_P and Ext_Q are nonempty and there exists at least one seam pair (x4,x1′) with E(x4,x1′), then Ext_{P·Q}≠∅. This is an immediate corollary of the general concatenation rule.

Implementation notes

- Quantify over T_long for left/right contexts in Stage-1; middle types in Stage-2 can be arbitrary (short included), handled by the general concatenation lemma.
- Precompute T by BFS (Prop. 9), split T_long vs short, cache Left_τ and Right_τ for all τ, and build Ext_{τ⊙σ} for τ,σ∈T_long (Prop. 5). ℓ_pump=|T| is computable in 2^{poly(β)}.
- Separator placement for Stage-1: in O(log* n), compute an MIS on the K-th power of the directed path for K=ℓ_pump+4; distances between consecutive separators are ≤2K, ensuring each middle block is O(K)-long and solvable in O(1) rounds by exhaustive local choice of an Ext-witness–consistent interior labeling.

Open item for Stage-2

- Provide a self-contained constant-radius partition lemma on oriented paths or redesign the Stage-2 constant-round construction to avoid reliance on periodicity. Until then, keep S2 as a notes-only plan.
Endpoint handling in Stage-1 (r=1) and refinements

- Endpoint gap (to-do). The current Stage-1 (⇐) algorithm partitions the path using a K-th power MIS with K := ℓ_pump+4 and then fills each middle block between two separators using a feasible function f. This leaves one-sided end segments (from a path endpoint to the nearest separator). The proof sketch in output.md did not treat these explicitly and incorrectly asserted that every separator has long-type contexts on both sides. A separate lemma is needed to guarantee that the seam color chosen at an endpoint-adjacent separator is compatible with the end segment’s Ext set. Alternatively, redesign the partition so that every nontrivial block lies strictly between two separators, eliminating one-sided cases. Until one of these is proven, the o(n)⇔feasible-f equivalence remains open here.

- Clean k=1→2 update (no “recover b”). For a type τ with k_flag(τ)=1, let S_τ := { x ∈ Σ_out : (x,x,x,x) ∈ Ext_τ }. Then appending a bit a yields Ext_{τ·a} consisting exactly of tuples (x1,x2,x3,x4) with x1=x3, x2=x4, x1∈S_τ, x2∈A_a, and E(x1,x2). This removes the need to speak about an internal bit b and works also when A_0=A_1.

- Optimized append in O(β^4). For k_flag≥4, define Left3_t[x1,x2,x3]:=∃z (x1,x2,z,x3)∈Ext_t. Then (x1,x2,x3,x4)∈Ext_{t·a} iff Left3_t[x1,x2,x3] ∧ E(x3,x4) ∧ x4∈A_a. Precompute Left3_t in O(β^4) time and fill Ext_{t·a} in O(β^4) time (dense worst-case).

- Out-set formulation of feasibility. Given a guessed f: T_long×{0,1}^2×T_long→Σ_out^2, define
  OutR2(τ_b,s) := { second(f(τ_a,s,τ_b)) : τ_a ∈ T_long },
  OutL1(τ_c,s) := { first(f(τ_c,s,τ_d)) : τ_d ∈ T_long }.
The universal extendibility clause is equivalent to: for all τ_b,τ_c,s1,s2 and α_L∈OutR2(τ_b,s1), α_R∈OutL1(τ_c,s2), ∃(o1,o2,o3,o4)∈Ext_{τ_b⊙τ_c} with E(α_L,o1) and E(o4,α_R). This isolates the relevant seam colors and simplifies verification.

- Seam-feasibility matrices. For faster verification and construction, precompute for each pair (τ_b,τ_c) the β×β boolean matrix W_{b⊙c}[α_L][α_R] that records whether there exists (o1,o2,o3,o4) ∈ Ext_{τ_b⊙τ_c} with E(α_L,o1) and E(o4,α_R). Then the universal extendibility checks reduce to table lookups W_{b⊙c}[α_L][α_R].

- Regression checklist.
  1) Verify optimized append equals brute-force append on random small Σ_out (β≤3).
  2) Verify associativity of Ext-concatenation on random triples of types.
  3) Verify W_{b⊙c} by direct Ext scans.
  4) Sanity: equality LCL and proper 2-coloring behave as expected.


Current output.md (if any):
Setup and definitions (r=1, globally oriented paths)
- Let Σ_out be a finite output alphabet of size β. Let A_0,A_1 ⊆ Σ_out be the allowed outputs at nodes with input bit 0 or 1, respectively. Let E ⊆ Σ_out × Σ_out be the allowed directed edge relation (u→v allowed iff (u,v)∈E). For an input word t ∈ {0,1}^k with k≥1, a labeling o ∈ Σ_out^k is legal if o[i]∈A_{t[i]} for all i, and (o[i],o[i+1])∈E for all 1≤i<k.
- For k≥4, define Ext_t ⊆ Σ_out^4 as the set of boundary quadruples (L1,L2,R2,R1) that extend to a legal labeling o with L1=o[1], L2=o[2], R2=o[k−1], R1=o[k]. For k≤3, Ext_t is defined with the same 4-tuple container but with the obvious coordinate equalities imposed by overlaps (tracked by k_flag ∈ {1,2,3,≥4}). The Type of t is Type(t) := (Ext_t, k_flag(t)).

Lemma 1 (Append-one-bit recurrence; k_flag≥4 case).
Let t be an input word with k_flag(t)≥4, and let t′ := t·a be t with one bit a ∈ {0,1} appended on the right. Then for all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x4 ∈ A_a and E(x3,x4) and ∃z∈Σ_out: (x1,x2,z,x3) ∈ Ext_t ].
Proof. Standard restriction/extension argument on legal labelings. □

Proposition 6 (Base-case update; k=1→2).
Let t=(b) be a length-1 input and t′:=t·a the length-2 input obtained by appending a∈{0,1}. For all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x1 = x3, x2 = x4, x1 ∈ A_b, x2 ∈ A_a, and E(x1,x2) ].
Proof. Immediate from the definition. □

Proposition 7 (Base-case update; k=3→4).
Let t=(b1,b2,b3) be a length-3 input and t′:=t·a the length-4 input obtained by appending a∈{0,1}. For all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x1∈A_{b1}, x2∈A_{b2}, x3∈A_{b3}, x4∈A_a, and E(x1,x2), E(x2,x3), E(x3,x4) ].
Proof. Unfold the definition on the 4-node path. □

Lemma 2 (Ext-level concatenation; k_flag≥4).
Let P and Q be input words with k_flag(P), k_flag(Q) ≥4, and let B := P·Q. Then for all (o1,o2,o3′,o4′)∈Σ_out^4,
  (o1,o2,o3′,o4′) ∈ Ext_B ⇔ ∃ x3,x4,x1′,x2′ ∈ Σ_out such that
    (o1,o2,x3,x4) ∈ Ext_P, (x1′,x2′,o3′,o4′) ∈ Ext_Q, and E(x4,x1′).
Proof. Combine witnesses across the seam, or restrict a legal labeling of B. □

Proposition 3 (Type congruence under appending one bit).
If Type(P)=Type(Q), then for all a∈{0,1}, Type(P·a)=Type(Q·a). In particular, Ext_{P·a}=Ext_{Q·a} and k_flag updates identically.
Proof. For k_flag≥4, Lemma 1 shows Ext_{(·)·a} depends only on Ext_{(·)} and a. Short cases follow by the explicit base-case rules. □

Proposition 4 (Unsoundness of existential R-composition).
There exists an instance (Σ_out,A_0,A_1,E) and types t_b,t_c such that there is m∈Σ_out with (x,m) ∈ R_{t_b} and (m,y) ∈ R_{t_c} for some x,y, yet (x,y) ∉ R_{t_b·t_c}. Hence the rule “(∃m) R_{P·Q}(x,y) ⇐ R_P(x,m) ∧ R_Q(m,y)” is not valid in general.
Proof. Use Σ_out={a,b,c}, A_0=A_1=Σ_out, E={(a,b),(b,c)}; choose t_b with rightmost a and t_c with leftmost c; pick m=b. The seam would require E(a,c), which fails. □

Proposition 5 (Optimized computation of Ext for concatenation in O(β^6)).
For any types τ,σ with k_flag(τ),k_flag(σ)≥4, define the 3D slices
  Left_τ[o1,o2,x4] := ∃x3 (o1,o2,x3,x4)∈Ext_τ, and
  Right_σ[x1′,o3′,o4′] := ∃x2′ (x1′,x2′,o3′,o4′)∈Ext_σ.
Then for all (o1,o2,o3′,o4′),
  (o1,o2,o3′,o4′) ∈ Ext_{τ⊙σ} ⇔ ∃x4,x1′: Left_τ[o1,o2,x4] ∧ E(x4,x1′) ∧ Right_σ[x1′,o3′,o4′].
Moreover, after precomputing Left_τ and Right_σ for all τ,σ in O(β^4) time per type, Ext_{τ⊙σ} can be computed in O(β^6) time.
Proof. Eliminate x3,x2′ by definitions; count entries. □

Proposition 6A (k_flag=1 append update without recovering the bit).
Let τ be a type with k_flag(τ)=1 and define S_τ := { x ∈ Σ_out : (x,x,x,x) ∈ Ext_τ }. For a∈{0,1}, let τ′ := δ(τ,a). Then for all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{τ′} ⇔ [ x1=x3, x2=x4, x1∈S_τ, x2∈A_a, and E(x1,x2) ].
Proof. Any legal 2-node labeling has boundary (o1,o2,o1,o2) with o1∈S_τ, o2∈A_a and E(o1,o2). Conversely, any tuple satisfying the listed constraints is realized by a legal labeling on the 2-node input. □

Lemma 8 (Type-count bound).
With Type(t):=(Ext_t, k_flag(t)) and Ext_t⊆Σ_out^4, the number of distinct types obeys |T| ≤ 4 · 2^{β^4}.
Proof. For each k_flag value, Ext can be any subset of Σ_out^4; sum over k_flag. □

Proposition 9 (δ well-defined; deterministic BFS enumeration in 2^{poly(β)} time/space).
Let δ map a type τ and an appended bit a∈{0,1} to the type of the one-bit extension. Define δ by:
- If k_flag(τ)=1, compute Ext of the 2-node type by Proposition 6A using S_τ.
- If k_flag(τ)=2, use the explicit k=2→3 update.
- If k_flag(τ)=3, use Proposition 7.
- If k_flag(τ)≥4, use Lemma 1.
Then δ(τ,a) depends only on τ and a (by Proposition 3). A deterministic BFS that starts from the length-1 seeds (t=(0) and t=(1)), repeatedly applies δ(·,0) and δ(·,1), and interns types by equality of (Ext, k_flag), halts after at most |T| insertions and enumerates all reachable types. Each transition costs O(β^5) in the k_flag≥4 regime (base-cases are ≤O(β^4)). Since |T| ≤ 4·2^{β^4}, the total time and space are 2^{poly(β)}. □

Lemma 10 (Reversal operator; basic properties).
Define, for any type τ=(Ext_τ,k_flag(τ)), the reversed type Rev(τ):=(Ext_τ^R, k_flag(τ)), where Ext_τ^R := { (y1,y2,y3,y4) : (y4,y3,y2,y1) ∈ Ext_τ }. Then Rev(Rev(τ))=τ and, for k_flag≥4, Ext_{Rev(τ) ⊙ Rev(σ)} = (Ext_{σ ⊙ τ})^R.
Proof. Direct from definitions and Lemma 2. □

Definition (Long types and pumping bound).
- T_long := { τ ∈ T : k_flag(τ) ≥ 4 }.
- Define ℓ_pump := |T|, where T is the set of reachable Types enumerated by Proposition 9.

Lemma 11 (Ext-level concatenation; all k_flag).
For any input words P,Q (no restriction on length) and B := P·Q, for all (o1,o2,o3′,o4′) ∈ Σ_out^4,
  (o1,o2,o3′,o4′) ∈ Ext_B ⇔ ∃ x3,x4,x1′,x2′ ∈ Σ_out:
    (o1,o2,x3,x4) ∈ Ext_P, (x1′,x2′,o3′,o4′) ∈ Ext_Q, and E(x4,x1′).
Proof. As in Lemma 2; k_flag imposes only coordinate equalities. □

Proposition 12 (Associativity of Ext-concatenation).
For any input words P,Q,R, Ext_{(P·Q)·R} = Ext_{P·(Q·R)} as subsets of Σ_out^4.
Proof. Either semantically (concatenation of words) or by rebracketing witnesses from Lemma 11. □

Lemma 13 (Prefix pumping).
Let ℓ_pump := |T|. For any input string w with |w| ≥ ℓ_pump there exist a decomposition w = x y z with 1 ≤ |y| ≤ ℓ_pump and |x y| ≤ ℓ_pump such that Type(x y^i z) is independent of i ≥ 0.
Proof. Pigeonhole on the first ℓ_pump+1 states of the δ-run. □

Lemma 14 (Periodic pumping).
For any nonempty string u there exist integers a,b with a+b ≤ ℓ_pump such that Type(u^{a+bi}) is invariant for all i ≥ 0.
Proof. Pigeonhole on the sequence Type(u^j), j≥0, and determinism of δ. □

Definition (Feasible function; Out-set form).
A function f: T_long × {0,1}^2 × T_long → Σ_out^2 is feasible if for every (τ_L, s, τ_R) it outputs (α1,α2) with αi ∈ A_{s[i]} and E(α1,α2), and moreover the following universal extendibility holds: for all τ_b,τ_c∈T_long and s1,s2 ∈ {0,1}^2, and for all α_L ∈ OutR2(τ_b,s1), α_R ∈ OutL1(τ_c,s2), there exists (o1,o2,o3,o4) ∈ Ext_{τ_b ⊙ τ_c} with E(α_L,o1) and E(o4,α_R), where
  OutR2(τ_b,s) := { second(f(τ_a,s,τ_b)) : τ_a ∈ T_long },
  OutL1(τ_c,s) := { first(f(τ_c,s,τ_d)) : τ_d ∈ T_long }.

Lemma 20 (Quantifier minimization equivalence).
Let f be any function T_long×{0,1}^2×T_long→Σ_out^2 obeying node/window constraints. The universal extendibility clause stated here is equivalent to the clause “for all τ_a,τ_b,τ_c,τ_d and s1,s2, letting α_L := second(f(τ_a,s1,τ_b)) and α_R := first(f(τ_c,s2,τ_d)), there exists (o1,o2,o3,o4)∈Ext_{τ_b⊙τ_c} with E(α_L,o1), E(o4,α_R)).”
Proof. “Only if”: the α_L,α_R in the original clause range over OutR2,OutL1. “If”: for given τ_b,τ_c,s1,s2 and α_L∈OutR2, α_R∈OutL1, pick τ_a,τ_d witnessing membership and apply the original clause. □

Proposition 19 (Optimized append in O(β^4) time for k_flag≥4).
For t with k_flag≥4 and a∈{0,1}, define Left3_t[x1,x2,x3] := ∃z (x1,x2,z,x3)∈Ext_t. One can compute Left3_t in O(β^4) time. Then fill Ext_{t·a} by scanning all (x1,x2,x3) with Left3_t[x1,x2,x3]=true and, for each, iterating over x4 with E(x3,x4) and x4∈A_a, setting Ext_{t·a}[x1,x2,x3,x4]←true. The total time is O(β^4) in the dense worst-case.
Proof. Correctness follows from Lemma 1. Complexity: Left3_t has β^3 entries, each tested in O(β); the fill step is O(β^3Δ) with Δ≤β. □

Proposition 21 (Seam-feasibility matrices for τ_b ⊙ τ_c).
For τ_b,τ_c, define W_{b⊙c}[α_L][α_R] (a β×β boolean matrix) to be true iff ∃(o1,o2,o3,o4)∈Ext_{τ_b⊙τ_c} with E(α_L,o1) and E(o4,α_R). Using precomputed 3D slices or Ext_{τ_b⊙τ_c}, W_{b⊙c} can be computed in O(β^4Δ^2) time (or better with sparse E), and then universal extendibility checks reduce to testing W_{b⊙c}[α_L][α_R].
Proof. Expand the definition via Lemma 11, eliminate internal witnesses by slices, and count operations. □

Proposition 17 (Nonemptiness monotonicity under concatenation).
If Ext_P ≠ ∅ and Ext_Q ≠ ∅ and there exist x4,x1′ with E(x4,x1′), then Ext_{P·Q} ≠ ∅.
Proof. Choose any (o1,o2,x3,x4) ∈ Ext_P and (x1′,x2′,o3′,o4′) ∈ Ext_Q; Lemma 11 and E(x4,x1′) imply (o1,o2,o3′,o4′) ∈ Ext_{P·Q}. □

Remark (Stage-1 equivalence pending endpoint treatment).
The o(n)⇔feasible-f equivalence claimed earlier is temporarily removed pending a rigorous treatment of endpoint segments in the (⇐) direction (see notes). All supporting mechanics above remain valid and will be reused once the endpoint lemma/partition fix is in place.

