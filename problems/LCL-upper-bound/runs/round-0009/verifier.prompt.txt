--- SYSTEM ---
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (summary so far)
- output.md (rigorously proven results so far)

Guidelines:
- notes.md: should be a readable running log of interesting work. Prefer appending. Replace only if old notes are clearly misleading. Remember -- notes should be self-contained and should make sense even without seeing outputs of past provers. 
- output.md:  Think twice before you add something to this file. Everything here should be rigorous, almost publication-ready. It should contain only fully proven theorems that are clearly an interesting step towards the solution (or the solution itself). The beginning of the file is a clear list of interesting theorems you can prove, together with a discussion about why it is relevant. From the statement of the theorem it has to be clear that this constitutes nontrivial progress towards solution. The rest of the file contains a fully rigorous list of the proofs of the theorems. Keep only proven theorems with clear proofs. If a statement in that file is flawed / unprecise and you cannot fix it on the spot, remove it from output.md and instead add it to notes.md with explanation.
- Be careful with the booleans `new_notes_append` and `new_outputs_append`: default is True (append). Use False only when deliberately rewriting everything.

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (≥200 words). Include concrete next-step suggestions. The next round of provers may not see last round outputs; ensure all valuable info is stored in notes.",
  "new_notes_md": "Markdown (KaTeX allowed). Usually appended to notes.",
  "new_notes_append": "True|False",
  "new_outputs_md": "Markdown (KaTeX allowed). Usually appended to output.md.",
  "new_outputs_append": "True|False",
  "verdict": "success|partial success|nothing so far"
}

**Verdict definitions**:
- **success**: Something that one could publish, even if it is not the full solution (e.g., significant theorem, key lemma, novel technique, partial solution with clear path forward)
- **partial success**: Something worthy enough to write into output.md (e.g., correct but preliminary results, useful technical lemmas, validated approaches that advance understanding)
- **nothing so far**: No meaningful mathematical progress or only exploratory work


--- USER ---
You receive multiple prover reports. Evaluate correctness, value, and pick promising directions. Update notes.md (append/replace) with useful ideas and update output.md (append/replace) ONLY with rigorously verified results.

Prover reports (JSON):
[{"prover_id": "01", "progress_md": "Round 0009 \u2014 Endpoint-correct Stage-1 for paths, audits, and verifiable fixes\n\nStatus and quick audit of output.md\n- What is solid: r=1 primitives (append DP with k-flag, corrected base cases k=1\u21922, 3\u21924; concatenation; associativity; congruence), type enumeration and |T| bound; pumping lemmas; Out-set version of feasible f over T_long; optimized append O(\u03b2^4); seam-feasibility matrices W; endpoint projections RightColors/LeftColors and endpoint seam matrices V_left,V_right with Lemma E1.\n- Main gap (explicitly acknowledged): Stage-1 equivalence on oriented paths is \u201cpending endpoint treatment.\u201d As written, there is no coupling between the endpoint-adjacent separator\u2019s open seam color and the Out-sets of the interior feasible function; this can admit false positives.\n- Minor editorial/numbering issues to flag: (i) There are two different \u201cProposition 6\u201d items (base k=1\u21922 and k_flag=1 update as 6A) and also \u201cProposition 6B\u201d (k=2\u21923), which is confusing; consider renumbering. (ii) Both Lemma 2 (k_flag\u22654) and Lemma 11 (all k_flag) state concatenation; Lemma 11 subsumes Lemma 2\u2014either keep both with a note or refer to Lemma 11 uniformly. (iii) Proposition 9 still quotes O(\u03b2^5) per append in the long regime; Proposition 19 improves this to O(\u03b2^4), so the preprocessing bound can be tightened accordingly.\n\nProblem and minimal counterexample (why the current endpoint certificate is insufficient)\n- Obstruction template: Fix a long type \u03c4_b and an input s such that OutR2(\u03c4_b,s) = {\u03b1}. Suppose W_{b\u2299c}[\u03b1][\u00b7] admits all right seams induced by f on the next separator. If an endpoint witness g_L(\u03c4_end,s) outputs (\u03b21,\u03b22) with \u03b22 \u2260 \u03b1 but V_left[\u03c4_end][\u03b21]=true, the current checks pass but the fill of the block between this separator and the next separator (colored by f) may fail, as there may be no (o1,o2,o3,o4) \u2208 Ext_{\u03c4_b \u2299 \u03c4_c} with E(\u03b22,o1). Hence the endpoint separator must be aligned with the interior Out-sets.\n\nClaim (corrected endpoint-aware Stage-1 certificate for oriented paths)\n- Augmented endpoint witnesses aligned to Out-sets:\n  \u2022 g_L: T \u00d7 {0,1}^2 \u00d7 T_long \u2192 \u03a3_out^2. For g_L(\u03c4_end,s,\u03c4_b)=(\u03b21,\u03b22) require: (i) \u03b2i\u2208A_{s[i]} and E(\u03b21,\u03b22); (ii) V_left[\u03c4_end][\u03b21]=true; (iii) \u03b22 \u2208 OutR2(\u03c4_b,s).\n  \u2022 g_R: T_long \u00d7 {0,1}^2 \u00d7 T \u2192 \u03a3_out^2. For g_R(\u03c4_c,s,\u03c4_end)=(\u03b21,\u03b22) require: (i) \u03b2i\u2208A_{s[i]} and E(\u03b21,\u03b22); (ii) V_right[\u03b22][\u03c4_end]=true; (iii) \u03b21 \u2208 OutL1(\u03c4_c,s).\n- Feasible mid-separator function f_mid: as in output.md (Out-set form over T_long), with universal extendibility checked via W_{b\u2299c}.\n- Theorem S1-path (equivalence; oriented paths). An r=1, \u03b2-normalized LCL on globally oriented paths has deterministic complexity o(n) iff there exist (f_mid,g_L,g_R) satisfying the above. Verification is in nondeterministic 2^{poly(\u03b2)} time.\n\nProof sketch (auditable pieces)\n- (\u21d2) Existence. Given an o(n)-round algorithm A:\n  \u2022 f_mid: As in output.md (cycle gadget + pumping). Well-definedness uses that we pump to length in [s,s+\u2113_pump] and choose IDs inside the <0.1s halos.\n  \u2022 g_L: For any (\u03c4_end,s,\u03c4_b), form a path consisting of a long pumped block of type \u03c4_b to the right, the 2-node separator S with input s, and a left endpoint block of type \u03c4_end; pad far outside S so A\u2019s runtime halo is contained. Set g_L(\u03c4_end,s,\u03c4_b) to A\u2019s 2-node output on S. Then: (i) node/window legality holds by correctness of A; (ii) V_left holds because the seam into \u03c4_end is satisfied in A\u2019s run; (iii) alignment \u03b22\u2208OutR2(\u03c4_b,s) holds by construction since S\u2019s right output was produced in a context of type \u03c4_b, i.e., it is one of the attained second outputs for \u03c4_b under f_mid with input s. Define g_R symmetrically.\n- (\u21d0) Construction of an O(log* n) algorithm.\n  \u2022 Place separators by an MIS on the K-th power of the directed path in O(log* n) rounds with K := \u2113_pump+4. Standard properties ensure that the distance between neighboring separators is in [K,2K], and that the long contexts abutting each interior side are T_long.\n  \u2022 Label interior separators by f_mid (using local s and adjacent long types \u03c4_b,\u03c4_c). Use the precomputed matrix W_{b\u2299c} to fill each interior middle block between two separators by choosing a witness in Ext_{\u03c4_b\u2299\u03c4_c} consistent with the seams.\n  \u2022 Endpoints: Let S_left be the unique separator adjacent to the left end. Compute \u03c4_end (type of the left end-block) and \u03c4_b (long type on S_left\u2019s right). Color S_left by g_L(\u03c4_end,s,\u03c4_b). By V_left there is (o1,o2,o3,o4)\u2208Ext_{\u03c4_end} with E(o4,\u03b21), so we fill the endpoint block. For the block between S_left and the nearest interior separator S2, by (iii) the outward seam color \u03b22 is in OutR2(\u03c4_b,s), while the left seam color from S2 lies in OutL1(\u03c4_c,s2). Hence W_{b\u2299c}[\u03b22][\u03b1_R] is true and the block is fillable via Ext_{\u03c4_b\u2299\u03c4_c}. Do the right end symmetrically with g_R. Runtime is O(log* n); all fillings are constant-radius lookups in precomputed tables.\n\nNEXPTIME verification details\n- Precompute deterministically in 2^{poly(\u03b2)} time:\n  \u2022 T, T_long via BFS (Prop. 9) and Ext_\u03c4 for \u03c4\u2208T; use Prop. 19 to implement k_flag\u22654 appends in O(\u03b2^4).\n  \u2022 Ext_{\u03c4_b\u2299\u03c4_c} for \u03c4_b,\u03c4_c\u2208T_long via Prop. 5, and W_{b\u2299c}.\n  \u2022 V_left, V_right from endpoint projections (as in output.md).\n  \u2022 OutR2(\u03c4_b,s), OutL1(\u03c4_c,s) sets from f_mid.\n- Guess f_mid, g_L, g_R. Verify:\n  \u2022 For all entries: node legality and E on the 2-node window.\n  \u2022 f_mid universal extendibility via W_{b\u2299c} (Out-set form; Lemma 20).\n  \u2022 g_L: V_left[\u03c4_end][\u03b21]=true and \u03b22 \u2208 OutR2(\u03c4_b,s). g_R: V_right[\u03b22][\u03c4_end]=true and \u03b21 \u2208 OutL1(\u03c4_c,s).\n- All checks are constant-time table lookups; total number of cases is |T_long|^2\u00b74 for f_mid and (|T|\u00b7|T_long|)\u00b74 for each endpoint map; overall time 2^{poly(\u03b2)}.\n\nSmall example illustrating necessity of alignment\n- Let \u03a3_out={a,b}, A_0=A_1=\u03a3_out, and E contains only edges a\u2192a and b\u2192b. Suppose a feasible f_mid exists that always outputs (a,a), hence OutR2(\u03c4_b,s)={a}. Choose \u03c4_end with RightColors(\u03c4_end)={a,b}. If g_L(\u03c4_end,s) outputs (b,a), V_left holds (since E(b,b) and b\u2208RightColors(\u03c4_end)) but \u03b22=a\u2026 OK here it matches. Now flip: define f_mid that always outputs (b,b), so OutR2={b}, but g_L outputs (a,a). V_left still holds if a\u2208RightColors(\u03c4_end), yet \u03b22=a\u2209OutR2. There is no guarantee that the endpoint\u2013interior block can be completed respecting the next separator colored according to f_mid. This shows (iii) is required.\n\nAdditional small lemmas/propositions to add (self-contained)\n- Endpoint\u2013interior bridging lemma. Given \u03c4_b,\u03c4_c\u2208T_long, inputs s1,s2, and endpoint-adjacent separator colors \u03b1_L,\u03b1_R with \u03b1_L\u2208OutR2(\u03c4_b,s1), \u03b1_R\u2208OutL1(\u03c4_c,s2), there exists a completion of the intervening block consistent with both seams iff W_{b\u2299c}[\u03b1_L][\u03b1_R]=true. Proof: by definition of W_{b\u2299c}; direction \u201conly if\u201d follows by restricting any legal completion; \u201cif\u201d follows by taking the witnessing (o1,o2,o3,o4)\u2208Ext_{\u03c4_b\u2299\u03c4_c}.\n- Preprocessing remark (tightening Prop. 9). Using Prop. 19, the k_flag\u22654 append step is O(\u03b2^4), so the BFS enumeration can cite O(\u03b2^4) per transition in the long regime; short base-case transitions remain O(\u03b2^4).\n\nImplementation notes and counts\n- OutR2/OutL1 sets have size \u2264\u03b2; precompute once per (\u03c4, s). For faster Stage-1 checks, one can precompute for each (\u03c4_b,\u03c4_c,s1,s2) the \u03b2\u00d7\u03b2 mask W_{b\u2299c} and then just iterate over \u03b1_L in OutR2(\u03c4_b,s1) and \u03b1_R in OutL1(\u03c4_c,s2).\n- Endpoints: the verification size of g_L is |T|\u00b7|T_long|\u00b74 entries; g_R symmetric. Sparse E can reduce preprocessing time for W and V matrices.\n\nExplicit gaps to address in output.md\n- Integrate the corrected Stage-1 path theorem (S1-path) with (f_mid,g_L,g_R) as above, and add the (\u21d2) and (\u21d0) proofs specialized to globally oriented paths.\n- Add the endpoint\u2013interior bridging lemma stated above; it is just an unpacking of W_{b\u2299c} and will clarify the fill of the first interior block.\n- Tighten Prop. 9\u2019s complexity to use Prop. 19 (O(\u03b2^4) per long append).\n- Note that Lemma 11 subsumes Lemma 2; consider merging references.\n- Clean up numbering: avoid multiple \u201cProposition 6/6A/6B\u201d.\n\nNext steps\n- Promote S1-path into output.md with full statement and auditable proofs, together with the augmented endpoint witnesses. Update the classification logic: if Stage-1 fails, classify \u03a9(n); if Stage-1 holds but Stage-2 certificate fails, classify \u0398(log* n); if Stage-2 holds, classify O(1).\n- Prepare unit tests: (i) synthetic instances where OutR2 is singleton and g_L is misaligned; the augmented certificate must reject; (ii) equality LCL (accept both stages); (iii) proper 2-coloring (accept Stage-1, reject Stage-2).\n- Return to Stage-2: port the (\u2113_width,\u2113_count,\u2113_pattern)-partition to oriented paths with explicit parameters and a short self-contained proof, then finalize the per-type boundary interface certificate Q_\u03c4.\n"}, {"prover_id": "02", "progress_md": "Round 0009 \u2014 Endpoint-coupled Stage\u20111 for paths; certificate fix, proofs, and verifiable checks\n\nStatus and audit of output.md\n- Good: r=1 machinery is solid and comprehensive: append DP with k-flag cases (k=1\u21922, k=2\u21923, k=3\u21924), congruence, general Ext-concatenation (all k_flag) and associativity, \u03b4-enumeration with |T| \u2264 4\u00b72^{\u03b2^4}, optimized append (O(\u03b2^4)), optimized concatenation (O(\u03b2^6)), pumping lemmas, W_{b\u2299c} feasibility matrices, and endpoint projections RightColors/LeftColors with V_left/V_right + Lemma E1.\n- Gap: Stage-1 (o(n) vs \u03a9(n)) is marked \u201cpending endpoint treatment\u201d. The current notes already identify that we must couple the endpoint-adjacent separators with the interior feasible function via OutR2/OutL1; output.md does not yet contain the corrected endpoint-aware certificate and equivalence theorem.\n- Minor: We can note under Proposition 9 that k_flag\u22654 transitions can use Proposition 19 to reduce per-append cost from O(\u03b2^5) to O(\u03b2^4).\n\nIdea \u2014 Corrected Stage\u20111 path certificate with endpoint coupling\n- Motivation (why necessary). Without coupling, g_L/g_R can choose seam colors that are legal at the endpoint (V_left/V_right true) but fall outside the Out-sets produced by f_mid, so the first interior block (between the endpoint-adjacent separator and the next interior separator) may be unfillable even though interior checks pass. This was the \u201cminimal obstruction\u201d pointed out in the feedback.\n- Definitions (objects and sets already available):\n  \u2022 T_long := {\u03c4 : k_flag(\u03c4)\u22654}.\n  \u2022 OutR2(\u03c4_b,s) := { second(f(\u03c4_a,s,\u03c4_b)) : \u03c4_a\u2208T_long }.\n  \u2022 OutL1(\u03c4_c,s) := { first(f(\u03c4_c,s,\u03c4_d)) : \u03c4_d\u2208T_long }.\n  \u2022 W_{b\u2299c}[\u03b1_L][\u03b1_R] records the existence of an Ext-witness across \u03c4_b\u2299\u03c4_c consistent with seam colors \u03b1_L, \u03b1_R.\n  \u2022 V_left, V_right as in output.md (endpoint seam feasibility).\n- Certificate (to add):\n  1) f_mid: T_long\u00d7{0,1}^2\u00d7T_long\u2192\u03a3_out^2, feasible in the Out-set sense (already defined) and verified via W_{b\u2299c}.\n  2) g_L: T\u00d7{0,1}^2\u00d7T_long\u2192\u03a3_out^2; for g_L(\u03c4_end,s,\u03c4_b)=(\u03b21,\u03b22) require:\n     (i) node legality \u03b2i\u2208A_{s[i]} and E(\u03b21,\u03b22);\n     (ii) endpoint seam feasibility V_left[\u03c4_end][\u03b21]=true;\n     (iii) interior alignment \u03b22\u2208OutR2(\u03c4_b,s).\n  3) g_R: T_long\u00d7{0,1}^2\u00d7T\u2192\u03a3_out^2; for g_R(\u03c4_c,s,\u03c4_end)=(\u03b21,\u03b22) require:\n     (i) node legality and E(\u03b21,\u03b22);\n     (ii) endpoint seam feasibility V_right[\u03b22][\u03c4_end]=true;\n     (iii) interior alignment \u03b21\u2208OutL1(\u03c4_c,s).\n  Remarks.\n  - The third argument in g_L/g_R couples endpoint separators to the adjacent long type on the interior side. This ensures the open seam color toward the interior is drawn from the same Out-set used by f_mid, so the W_{b\u2299c} universal checks cover the first interior block as well.\n\nTheorem S1-path (Endpoint-coupled equivalence; to insert)\n- Statement. For a \u03b2-normalized r=1 LCL on globally oriented paths, the following are equivalent:\n  (A) There is a deterministic LOCAL algorithm with runtime o(n).\n  (B) There exist witnesses (f_mid,g_L,g_R) satisfying: f_mid is feasible in the Out-set sense, g_L,g_R satisfy (i)\u2013(iii) above.\n  Moreover, existence of such witnesses is verifiable in nondeterministic time 2^{poly(\u03b2)}.\n- Proof sketch (\u21d2):\n  \u2022 As in Lemma 18 (already in outputs.pdf/paper), choose s\u226bT(n), pump any short context w to w^+ with |w^+|\u2208[s,s+\u2113_pump]. Extract f_mid(\u00b7) by simulating the o(n)-algorithm A on w_L^+\u00b7S\u00b7w_R^+ and reading the 2-node outputs on S, implying Out-set feasibility via W_{b\u2299c}.\n  \u2022 For g_L(\u03c4_end,s,\u03c4_b): embed (left end-block of type \u03c4_end) + separator S with input s + a long pumped block of type \u03c4_b on the right into a large path padded beyond the runtime halo, run A, and set g_L to the 2-node output on S. Local correctness implies (i); the seam into the endpoint implies (ii); the presence of \u03c4_b on the right forces the second output to lie in OutR2(\u03c4_b,s), i.e., (iii). Similarly define g_R with \u03c4_c on the left.\n- Proof sketch (\u21d0):\n  \u2022 Place 2-node separators in O(log* n) by an MIS on the K-th power (K:=\u2113_pump+4), so distances between successive separators are in [K,2K], except for one-sided end segments.\n  \u2022 Interior: label each interior separator by f_mid and complete the middle block between any two interior separators using W_{b\u2299c} and Ext_{\u03c4_b\u2299\u03c4_c}.\n  \u2022 Ends: label the left (resp. right) endpoint-adjacent separator using g_L(\u03c4_end,s,\u03c4_b) (resp. g_R(\u03c4_c,s,\u03c4_end)), where \u03c4_b,\u03c4_c are the long types on the interior sides. Then:\n    \u2013 Fill the endpoint block via Lemma E1 using V_left/V_right (local seam feasibility).\n    \u2013 Fill the intervening block between the endpoint separator and the nearest interior separator via W_{b\u2299c}, with \u03b1_L=second(g_L) (in OutR2 by (iii)) and \u03b1_R=first(f_mid on the interior separator) (in OutL1 by construction), so the prechecked W_{b\u2299c}[\u03b1_L][\u03b1_R] entry guarantees a witness in Ext_{\u03c4_b\u2299\u03c4_c}.\n  \u2022 All checks are local; the MIS step dominates time: O(log* n).\n- NEXPTIME verification. Deterministically compute T and T_long; precompute Ext_\u03c4 and Ext_{\u03c4_b\u2299\u03c4_c}, W_{b\u2299c}, OutR2/OutL1 sets from f_mid; V_left,V_right from Ext tables. Nondeterministically guess f_mid, g_L, g_R. Verify:\n  \u2022 f_mid node legality and the universal Out-set checks via W_{b\u2299c}.\n  \u2022 For all (\u03c4_end,s,\u03c4_b): g_L node legality; V_left[\u03c4_end][\u03b21]; \u03b22\u2208OutR2(\u03c4_b,s).\n  \u2022 For all (\u03c4_c,s,\u03c4_end): g_R node legality; V_right[\u03b22][\u03c4_end]; \u03b21\u2208OutL1(\u03c4_c,s).\n  Each is a table lookup; total time 2^{poly(\u03b2)}.\n\nToy counterexample (why alignment is essential; optional to include)\n- Template. Choose \u03c4_b with OutR2(\u03c4_b,s)={\u03b1} and a \u03c4_c with some OutL1-set; suppose W_{b\u2299c}[\u03b1][\u00b7] admits fills. Let g_L output (\u03b21,\u03b22) with \u03b22\u2260\u03b1 but V_left[\u03c4_end][\u03b21] true. Then the first interior block fails to fill because W_{b\u2299c}[\u03b22][\u03b1_R] can be false for all \u03b1_R. Hence the uncoupled endpoint certificate can produce false positives.\n- This simple construction can be instantiated by adapting the 3-color a\u2192b\u2192c gadget used earlier (Proposition 4), with compatible A/E and Types.\n\nImplementation refinements (verifier-side)\n- Precomputations (single-exponential):\n  \u2022 T by BFS; Ext_\u03c4 for \u03c4\u2208T; Left3_t to speed appends (Proposition 19); Ext_{\u03c4_b\u2299\u03c4_c} for \u03c4_b,\u03c4_c\u2208T_long via Proposition 5.\n  \u2022 W_{b\u2299c}; V_left, V_right.\n  \u2022 For a guessed f_mid, compute OutR2(\u03c4_b,s) and OutL1(\u03c4_c,s) (max size \u03b2 each); for speed, precompute their bitsets.\n- Optional matrices: for endpoints, precompute L_allow[\u03c4_end]:={\u03b1 | V_left[\u03c4_end][\u03b1]} and R_allow[\u03c4_end]:={\u03b1 | V_right[\u03b1][\u03c4_end]} to reduce g_L/g_R checks to set membership plus E/A.\n- Complexity note (to amend Proposition 9). For k_flag\u22654 transitions during \u03b4-enumeration, the O(\u03b2^4) append (Proposition 19) reduces total preprocessing constants; asymptotics remain 2^{poly(\u03b2)}.\n\nSmall auxiliary lemmas (easy to add, testable)\n- Endpoint allowable-color sets are exactly the E-neighbors of endpoint projections (already implicit):\n  \u2022 L_allow(\u03c4) = N_E(RightColors(\u03c4)) and R_allow(\u03c4) = N_E^{-1}(LeftColors(\u03c4)). This is Lemma E1 reformulated as set identities.\n- RightColors/LeftColors under append (computational aid). For \u03c4\u2032=\u03c4\u00b7a with k_flag(\u03c4)\u22654,\n  \u2022 RightColors(\u03c4\u2032) = { y \u2208 A_a : \u2203(x1,x2,x3) with Left3_\u03c4[x1,x2,x3] and E(x3,y) }.\n  \u2022 LeftColors(\u03c4\u00b7a) = LeftColors(\u03c4). These follow directly from Lemma 1 and the definition of Left3_\u03c4.\n  Use: fast updates of V_left/V_right if recomputed incrementally.\n\nExamples and sanity\n- Equality LCL (E={(c,c)}, c\u2208A_0\u2229A_1). Choose f_mid(\u00b7)=(c,c). OutR2/OutL1 are {c}. Let g_L=g_R=(c,c). V_left/V_right trivially true; W_{b\u2299c}[c][c]\u2248true. Classified O(1) by Stage-2; Stage-1 accepts.\n- Proper 2-coloring: With \u03a3_out={a,b} and E forbidding equal neighbors, an f_mid exists; OutR2/OutL1={a,b}; pick endpoint g_L/g_R alternating; Stage-1 accepts; Stage-2 later rejects (\u0398(log* n)).\n\nConcrete next steps (edits to output.md)\n1) Add \u201cTheorem S1-path (endpoint-coupled equivalence)\u201d with the witnesses and proofs (both directions) as above.\n2) Define g_L, g_R with third argument and spell out the three verification clauses; reference V_left/V_right, OutR2/OutL1, W_{b\u2299c}.\n3) Under Proposition 9, note that Proposition 19 yields O(\u03b2^4) per-append for k_flag\u22654.\n4) Optionally include the toy counterexample to document why the endpoint coupling is necessary.\n5) Leave Stage-2 (constant-time) for paths out of output.md until we integrate a self-contained partition lemma (the paper\u2019s Lemma 22 can be specialized to oriented paths; drafting this is queued for next round).\n\nRegression checklist (to add to notes/tests)\n- Validate endpoint-coupled certificate:\n  \u2022 Construct a random small \u03b2 instance; enumerate T, T_long; nondeterministically synthesize f_mid; derive OutR2/OutL1; then attempt to synthesize g_L/g_R and verify constraints.\n  \u2022 Show that dropping (iii) can create false positives (use the minimal obstruction template).\n- Re-run: optimized append vs brute-force append on \u03b2\u22643; Ext-concatenation associativity; W_{b\u2299c} correctness vs direct Ext scans.\n\nPotential pitfalls addressed\n- Seam and indexing: we adhere to (L1,L2,R2,R1); the left seam meets o1 in Ext_{\u03c4_b\u2299\u03c4_c}, the right seam meets o4. Endpoint seam checks use \u03b21=first(g_L) at the left seam and \u03b22=second(g_R) at the right seam.\n- Edge cases (small n): if MIS yields 0 or 1 separators, handle with constant-radius fallback (brute-force local completion using Ext tables) \u2014 this does not affect asymptotic classification.\n"}]

Current notes.md:
Corrections and key lemmas to record

1) Correct append-one-bit recurrence (r=1)
Given a type t with Ext_t ⊆ Σ_out^4 over boundary (L1,L2,R2,R1) and an appended input bit a, the new type t′ has boundary (L1′,L2′,R2′,R1′) = (L1,L2, old R1, new), i.e., R2′ = R1 and R1′ is the label of the appended node. Formally, for each candidate quadruple (x1,x2,x3,x4) ∈ Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [x4 ∈ A_a and E(x3,x4) and ∃ z ∈ Σ_out: (x1,x2,z,x3) ∈ Ext_t].
This yields an O(β^5) DP to fill Ext_{t′} by scanning all (x1,x2,x3,x4) and checking ∃z.

Congruence lemma (needed): If Type(P)=Type(Q), then for all a ∈ {0,1}, Type(Pa)=Type(Qa). Proof sketch: The predicate “there exists an interior completion consistent with boundary assignments” over D1∪D2 is preserved under appending one node by the above DP rule, which depends only on Ext_t and a.

2) Concatenation of summaries (r=1)
If Summ(P) has Ext_P and Summ(Q) has Ext_Q, then the concatenation B=P·Q has boundary (P.left endpoint, P.left neighbor, Q.right neighbor, Q.right endpoint) and
  (o1,o2,o3′,o4′) ∈ Ext_B ⇔ ∃ x3,x4,x1′,x2′ ∈ Σ_out: (o1,o2,x3,x4) ∈ Ext_P, (x1′,x2′,o3′,o4′) ∈ Ext_Q, and E(x4,x1′).
Then R_B can be derived from Ext_B as usual.

3) Counterexample to R-composition via ∃m
Let Σ_out={a,b,c}, A_0=A_1=Σ_out. Let E={a→b, b→c} only. Suppose t_b admits a boundary tuple with right endpoint a, and t_c admits a boundary tuple with left endpoint c (interiors arbitrary but extendible). Then choose m=b. We have (x,m) ∈ R_{t_b} for any x with a valid left edge, and (m,y) ∈ R_{t_c} for suitable y. But the concatenation t_b·t_c requires the seam edge a→c, which is forbidden. Hence ∃m composition of R_t is not sound; use Ext-level concatenation and R_B instead.
Additions and fixes (r=1)

A) Correct k=2→3 base-case update
Let t=(b1,b2) and t′=t·a (length 3). Then
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [x3=x2, x1∈A_{b1}, x2∈A_{b2}, x4∈A_a, E(x1,x2), E(x2,x4)].
This replaces any prior statement that involved x2∈A_a.

B) Type representation and congruence
Define Type(t) := (b_in(t), Ext_t, k_flag(t)), where k_flag ∈ {1,2,3,≥4} indicates whether boundary coordinates coincide due to short length. Then the congruence lemma holds in the form:
  If Type(P)=Type(Q), then for all a∈{0,1}, Type(Pa)=Type(Qa).
Proof: case split on k_flag using the explicit base-case rules for k_flag∈{1,2,3} and the general append recurrence for k_flag=≥4.
Remark: Ext equality alone does not determine |t| (e.g., with E self-loops and A_0=A_1, Ext_{len 2} = Ext_{len 4}). Hence the k_flag is necessary for a length-agnostic update routine.

C) Enumeration fix
In the BFS over types, key the dictionary by the full Type(t), including k_flag. After the first transition to k_flag=≥4, all descendants remain in k_flag=≥4 and subsequent δ updates are length-agnostic.
Additions: Stage-1 and Stage-2 specifications at the Ext level (r=1, oriented paths)

Notation. Σ_out has size β. For an input word t with bits b_in(t) ∈ {0,1}^{|t|}, let Ext_t ⊆ Σ_out^4 denote the set of boundary quadruples (L1,L2,R2,R1) = (o[1],o[2],o[|t|-1],o[|t|]) that admit an interior completion o consistent with node constraints o[i]∈A_{b_in(t)[i]} and edge constraints (o[i],o[i+1])∈E. Types are Type(t)=(Ext_t, k_flag(t)), where k_flag∈{1,2,3,≥4} encodes short-length degeneracies. Concatenation of types τ⊙σ is defined by the Ext-level concatenation rule (see outputs.md) and k_flag update.

Stage-1 (Ω(n) vs o(n)): type-level feasible function
- Universe: the finite set of types T obtained by BFS from k=1 under the append-one-bit updates (keyed by (Ext,k_flag)). For τ,σ∈T, the Ext of τ⊙σ is defined by Ext-level concatenation.
- Definition (feasible f). A function f: T × {0,1}^2 × T → Σ_out^2 mapping (τ_L, s, τ_R) to (α1,α2) is feasible if:
  (i) Node/window constraints: αi ∈ A_{s[i]} for i=1,2 and (α1,α2) ∈ E (i.e., E(α1,α2) holds).
  (ii) Universal extendibility across two separators: for all τ_a,τ_b,τ_c,τ_d∈T and s1,s2∈{0,1}^2, letting α_L := second component of f(τ_a,s1,τ_b) and α_R := first component of f(τ_c,s2,τ_d), we require
      ∃ (o1,o2,o3,o4) ∈ Ext_{τ_b ⊙ τ_c} with E(α_L,o1) and E(o4,α_R).
  Comment: The quantification over τ_a and τ_d is stronger than necessary but safe; a weaker version quantifies only over τ_b,τ_c and s1,s2. Indexing uses our convention (L1,L2,R2,R1); thus o1 and o4 are the first and last outputs of the middle block of type τ_b⊙τ_c.
- NEXPTIME check: deterministically enumerate T and all Ext_{τ} and on-demand Ext_{τ⊙σ}; nondeterministically guess f; verify (i) and (ii) exhaustively. Complexity is 2^{poly(N)} in the problem description size N.
- Status: We still owe a self-contained proof that “o(n) algorithm exists iff a feasible f exists” at the Ext level (the intended replacement of the paper’s feasible-function lemma). This will rely only on our Ext-append and Ext-concat lemmas and a standard pumping argument specialized to r=1.

Stage-2 (O(1) vs Ω(log* n)): per-type boundary-interface witness
- For each τ∈T with k_flag(τ)≥4, guess Q_τ=(L1_τ,L2_τ,R2_τ,R1_τ) with Q_τ ∈ Ext_τ. Enforce:
  (a) Local consistency and tiling: E(L1_τ,L2_τ), E(R2_τ,R1_τ), and wrap E(R1_τ,L1_τ). Intuition: long blocks of type τ can be tiled by copies using the same boundary outputs.
  (b) Bridging across any middle type (including empty): for all τ_left,τ_S,τ_right ∈ T, require either
      - if τ_S has k_flag≥1: ∃ (o1,o2,o3,o4) ∈ Ext_{τ_S} with E(R1_{τ_left},o1) and E(o4,L1_{τ_right}); or
      - if τ_S is empty: E(R1_{τ_left},L1_{τ_right}).
- Decision logic: if witnesses {Q_τ} exist and pass (a)–(b), classify O(1). Else, if a Stage-1 feasible f exists, classify Θ(log* n). Otherwise, classify Θ(n).
- Status: We still owe a concrete constant-radius construction on oriented paths from {Q_τ} (e.g., a partition/tiling routine parametrized by fixed radii ℓ_width, ℓ_pattern, ℓ_count) and a proof that the produced labeling is legal. Short types (k_flag<4) are treated as separators τ_S in (b).

Faster concatenation (proven and moved to outputs.md)
- Precompute for each τ the 3D slices: Left_τ[o1,o2,x4] := ∃x3 (o1,o2,x3,x4)∈Ext_τ, and Right_τ[x1′,o3′,o4′] := ∃x2′ (x1′,x2′,o3′,o4′)∈Ext_τ.
- Then (o1,o2,o3′,o4′)∈Ext_{τ⊙σ} iff ∃x4,x1′: Left_τ[o1,o2,x4] ∧ E(x4,x1′) ∧ Right_σ[x1′,o3′,o4′]. This allows computing Ext_{τ⊙σ} in O(β^6) time after O(β^4) precomputation per type.

Sanity checks (kept as examples)
- Trivial LCL (A_0=A_1=Σ_out, E complete): Ext_τ=Σ_out^4 for all τ; Stage-2 witness exists trivially ⇒ O(1).
- Equality LCL (E={(x,x)}): take Q_τ=(c,c,c,c) ⇒ O(1).
- Proper 2-coloring: Stage-2 fails; Stage-1 feasible f should exist ⇒ Θ(log* n).
- Linear cases with incompatible seams: Stage-1 fails ⇒ Ω(n).
Updates and clarifications (r=1, oriented paths)

1) Base-case updates finalized
- k=1→2 is special and cannot be derived from the general append recurrence without over-constraining x1=x2; we record an explicit rule in outputs.md.
- k=3→4 is also added explicitly (although it follows from the same recurrence if stated for k≥2). This ensures δ can move from short types to k_flag≥4 deterministically.

2) Type-count bound corrected
Type(t) consists of (Ext_t, k_flag(t)) only; boundary input bits are not part of Type. Hence the number of types satisfies
  |T| ≤ 4 · 2^{β^4}.
The earlier 16 · 2^{β^4} bound mixed in boundary input bits unnecessarily.

3) δ well-defined and BFS enumeration
- Seeds: k=1 types for b∈{0,1} (Ext_{(b)} = {(x,x,x,x): x∈A_b}).
- Transitions: use base-cases for k<4 (1→2, 2→3, 3→4) and Lemma 1 for k≥4. By congruence, δ(Type, a) depends only on (Ext, k_flag) and a.
- Termination and complexity: at most |T| ≤ 4·2^{β^4} insertions; each append is O(β^5) in the k≥4 regime (base-cases are ≤ O(β^4)); total time/space 2^{poly(β)}.

4) Reversal operator (optional but helpful)
Define Rev(τ) = (Ext_τ^R, k_flag(τ)) with Ext_τ^R := { (y1,y2,y3,y4) : (y4,y3,y2,y1) ∈ Ext_τ }. Then Rev(Rev(τ))=τ and Ext_{Rev(τ) ⊙ Rev(σ)} = (Ext_{σ ⊙ τ})^R.

5) Stage-1 and Stage-2 (status)
- Stage-1 (Ω(n) vs o(n)): the feasible function f: T × {0,1}^2 × T → Σ_out^2 with the universal Ext-based check (seams E(α_L, o1), E(o4, α_R), using the (L1,L2,R2,R1) ordering) is the right formal object. We still need a fully self-contained proof of the equivalence “o(n) iff such f exists”.
- Stage-2 (O(1) vs Ω(log* n)): the per-type witness Q_τ∈Ext_τ for k_flag≥4 with tiling and universal bridging checks is plausible. A complete constant-radius construction on oriented paths remains to be written and verified.

6) Sanity and regression items
- β=2 trivial LCLs and equality LCL check the base-cases and concatenation routines.
- Reconfirm the 3-color counterexample for R-composition via ∃m.
- Maintain an indexing reminder: Ext quadruples are ordered (L1,L2,R2,R1); in seam checks across a middle block of type τ_b⊙τ_c, the left seam meets o1 and the right seam meets o4.
New additions (r=1, oriented paths): pumping, general concatenation, and Stage-1 equivalence

- Pumping bound and lemmas. Let T be the set of reachable types (Proposition 9) and δ: T×{0,1}→T the append transition. Define
  ℓ_pump := |T|.
  Lemma (prefix pumping). For any input w with |w| ≥ ℓ_pump there exist x,y,z with 1 ≤ |y| ≤ ℓ_pump and |xy| ≤ ℓ_pump such that Type(x y^i z) is independent of i ≥ 0.
  Lemma (periodic pumping). For any nonempty u there exist a,b with a+b ≤ ℓ_pump such that Type(u^{a+bi}) is invariant for all i ≥ 0.
  Both follow from the pigeonhole principle applied to the δ-run over Types.

- Ext-level concatenation for all k_flags and associativity. The general concatenation rule (Ext_{P·Q} witnessed by Ext_P and Ext_Q with a seam constraint E(x4,x1′)) holds verbatim for all lengths because Ext for short words already lives in Σ_out^4 with coordinate equalities enforced by k_flag. Associativity of Ext-concatenation follows semantically (concatenation of words is associative) or by rebracketing seam witnesses.

- Stage-1 (Ω(n) vs o(n)). Restrict left/right context Types to T_long := {τ∈T : k_flag(τ)≥4}. Define a feasible f: T_long×{0,1}^2×T_long→Σ_out^2 that (i) satisfies node/edge constraints on the 2-node separator and (ii) for all τ_b,τ_c∈T_long and s1,s2, and for all τ_a,τ_d∈T_long (affecting only α_L,α_R), there exists (o1,o2,o3,o4)∈Ext_{τ_b⊙τ_c} with E(α_L,o1) and E(o4,α_R), where α_L is the second output of f(τ_a,s1,τ_b) and α_R is the first output of f(τ_c,s2,τ_d). Theorem (added to output.md): an r=1, oriented-path LCL has deterministic complexity o(n) iff such a feasible f exists. Proof outline recorded in output.md: (⇒) extract f from an o(n) algorithm via pumping and a cycle-gadget; (⇐) place separators by an MIS on the K-th power of the path with K≳ℓ_pump and solve each O(K)-long block locally using the guaranteed Ext-witness; total time O(log* n).

- Stage-2 (O(1) vs Θ(log* n)). The per-type interface Q_τ∈Ext_τ (for τ∈T_long) with tiling and universal bridging checks remains a plausible certificate. However, the constant-radius partition of an arbitrary input path into “long periodic” and “short/irregular” subpaths is not yet proven in this writeup. Do not claim S2 in output.md until a self-contained partition lemma (parameters and proof) is supplied or the construction is reworked to avoid this dependency.

- Minor lemma. Nonemptiness monotonicity under concatenation: if Ext_P and Ext_Q are nonempty and there exists at least one seam pair (x4,x1′) with E(x4,x1′), then Ext_{P·Q}≠∅. This is an immediate corollary of the general concatenation rule.

Implementation notes

- Quantify over T_long for left/right contexts in Stage-1; middle types in Stage-2 can be arbitrary (short included), handled by the general concatenation lemma.
- Precompute T by BFS (Prop. 9), split T_long vs short, cache Left_τ and Right_τ for all τ, and build Ext_{τ⊙σ} for τ,σ∈T_long (Prop. 5). ℓ_pump=|T| is computable in 2^{poly(β)}.
- Separator placement for Stage-1: in O(log* n), compute an MIS on the K-th power of the directed path for K=ℓ_pump+4; distances between consecutive separators are ≤2K, ensuring each middle block is O(K)-long and solvable in O(1) rounds by exhaustive local choice of an Ext-witness–consistent interior labeling.

Open item for Stage-2

- Provide a self-contained constant-radius partition lemma on oriented paths or redesign the Stage-2 constant-round construction to avoid reliance on periodicity. Until then, keep S2 as a notes-only plan.
Endpoint handling in Stage-1 (r=1) and refinements

- Endpoint gap (to-do). The current Stage-1 (⇐) algorithm partitions the path using a K-th power MIS with K := ℓ_pump+4 and then fills each middle block between two separators using a feasible function f. This leaves one-sided end segments (from a path endpoint to the nearest separator). The proof sketch in output.md did not treat these explicitly and incorrectly asserted that every separator has long-type contexts on both sides. A separate lemma is needed to guarantee that the seam color chosen at an endpoint-adjacent separator is compatible with the end segment’s Ext set. Alternatively, redesign the partition so that every nontrivial block lies strictly between two separators, eliminating one-sided cases. Until one of these is proven, the o(n)⇔feasible-f equivalence remains open here.

- Clean k=1→2 update (no “recover b”). For a type τ with k_flag(τ)=1, let S_τ := { x ∈ Σ_out : (x,x,x,x) ∈ Ext_τ }. Then appending a bit a yields Ext_{τ·a} consisting exactly of tuples (x1,x2,x3,x4) with x1=x3, x2=x4, x1∈S_τ, x2∈A_a, and E(x1,x2). This removes the need to speak about an internal bit b and works also when A_0=A_1.

- Optimized append in O(β^4). For k_flag≥4, define Left3_t[x1,x2,x3]:=∃z (x1,x2,z,x3)∈Ext_t. Then (x1,x2,x3,x4)∈Ext_{t·a} iff Left3_t[x1,x2,x3] ∧ E(x3,x4) ∧ x4∈A_a. Precompute Left3_t in O(β^4) time and fill Ext_{t·a} in O(β^4) time (dense worst-case).

- Out-set formulation of feasibility. Given a guessed f: T_long×{0,1}^2×T_long→Σ_out^2, define
  OutR2(τ_b,s) := { second(f(τ_a,s,τ_b)) : τ_a ∈ T_long },
  OutL1(τ_c,s) := { first(f(τ_c,s,τ_d)) : τ_d ∈ T_long }.
The universal extendibility clause is equivalent to: for all τ_b,τ_c,s1,s2 and α_L∈OutR2(τ_b,s1), α_R∈OutL1(τ_c,s2), ∃(o1,o2,o3,o4)∈Ext_{τ_b⊙τ_c} with E(α_L,o1) and E(o4,α_R). This isolates the relevant seam colors and simplifies verification.

- Seam-feasibility matrices. For faster verification and construction, precompute for each pair (τ_b,τ_c) the β×β boolean matrix W_{b⊙c}[α_L][α_R] that records whether there exists (o1,o2,o3,o4) ∈ Ext_{τ_b⊙τ_c} with E(α_L,o1) and E(o4,α_R). Then the universal extendibility checks reduce to table lookups W_{b⊙c}[α_L][α_R].

- Regression checklist.
  1) Verify optimized append equals brute-force append on random small Σ_out (β≤3).
  2) Verify associativity of Ext-concatenation on random triples of types.
  3) Verify W_{b⊙c} by direct Ext scans.
  4) Sanity: equality LCL and proper 2-coloring behave as expected.
Endpoint seam projections and matrices (r=1, oriented paths)

- For any type τ, define:
  RightColors(τ) := { y ∈ Σ_out : ∃ x1,x2,x3 with (x1,x2,x3,y) ∈ Ext_τ }.
  LeftColors(τ)  := { x ∈ Σ_out : ∃ x2,x3,y with (x,x2,x3,y) ∈ Ext_τ }.
  These are just the projections of Ext_τ to coordinates R1 and L1.

- Define endpoint seam-compatibility matrices from Ext alone:
  V_left[τ][α]  := (∃ y ∈ RightColors(τ) with E(y, α)).
  V_right[α][τ] := (∃ x ∈ LeftColors(τ) with E(α, x)).

Lemma E1 (endpoint feasibility via Ext). Fix any type τ and α ∈ Σ_out.
- There exists a legal labeling of a left end-block of type τ and the adjacent separator’s first node α iff V_left[τ][α] is true.
- There exists a legal labeling of a right end-block of type τ and the adjacent separator’s second node α iff V_right[α][τ] is true.
Proof. If (x1,x2,x3,y)∈Ext_τ and E(y,α), then the end-block interior is witnessed by Ext_τ and the seam edge by E(y,α). Conversely, any legal instance provides such y. The right case is symmetric.

Endpoint gap in Stage-1 (diagnosis and fix). Our current Stage-1 construction labels interior separators using a feasible f and fills the block between them via Ext_{τ_b ⊙ τ_c} using W_{b⊙c}. For paths, the first/last interior block is bounded on one side by an endpoint-adjacent separator. If that separator is colored by an independent g_L/g_R, the right (resp. left) seam color entering the first (resp. last) interior block may lie outside the OutR2/OutL1 sets induced by f. Then the pre-verified W_{b⊙c} guarantees do not apply, and the fill of that block can fail, even if V_left/V_right holds. Hence additional coupling is required.

Corrected Stage-1 certificate for paths (proposal). Keep T_long and f as in the Out-set formulation. Replace the 2-argument endpoint maps by 3-argument ones that are aligned with the Out-sets of the adjacent long type:
- g_L: T × {0,1}^2 × T_long → Σ_out^2. For g_L(τ_end, s, τ_b)=(β1,β2) require:
  (i) node/window legality at the separator: βi ∈ A_{s[i]} and E(β1,β2);
  (ii) one-sided feasibility toward the endpoint: V_left[τ_end][β1]=true;
  (iii) alignment with interior Out-set: β2 ∈ OutR2(τ_b, s).
- g_R: T_long × {0,1}^2 × T → Σ_out^2. For g_R(τ_c, s, τ_end)=(β1,β2) require:
  (i) node/window legality and E(β1,β2);
  (ii) one-sided feasibility toward the endpoint: V_right[β2][τ_end]=true;
  (iii) alignment with interior Out-set: β1 ∈ OutL1(τ_c, s).

With these constraints, the MIS-based O(log* n) construction proceeds as before:
- Label every interior separator by f; label the endpoint-adjacent separators using g_L/g_R (using the computed adjacent long types τ_b, τ_c on their interior sides). Fill end-blocks using Lemma E1.
- For the blocks between an endpoint-adjacent separator and its nearest interior separator, use the same W_{b⊙c} check as for interior blocks, with α_L := second(g_L(…)) or α_R := first(g_R(…)). By (iii), α_L ∈ OutR2(τ_b,·) and α_R ∈ OutL1(τ_c,·), so the precomputed W_{b⊙c} guarantees existence of a witness in Ext_{τ_b ⊙ τ_c}.

Necessity (⇒) sketch under the corrected certificate. Given an o(n)-round algorithm A:
- Extract f from A as in the cycle case (pumping + concatenation).
- For each (τ_end, s, τ_b), build a path consisting of a long pumped block of type τ_b to the right, the separator with input s, and an endpoint block of type τ_end on the left (plus pumped padding as needed outside the radius of A). Let g_L(τ_end,s,τ_b) be A’s output on the separator. Pumping ensures well-definedness and (iii). The V_left constraint follows because the seam into the endpoint segment is satisfied by A. Symmetrically define g_R.

Verification remains in 2^{poly(β)}: T, T_long, Ext, W_{b⊙c}, V_left, V_right, OutR2/OutL1 are all precomputable. The guessed tables f, g_L, g_R are checked entrywise.

Action items.
- Integrate Lemma E1 and the V_left/V_right definitions into outputs.
- Replace the current endpoint witness proposal by the 3-argument version and update both directions of the Stage-1 path theorem accordingly.
- Keep Stage-2 items in notes until a self-contained partition lemma for oriented paths is written.


Current output.md (if any):
Setup and definitions (r=1, globally oriented paths)
- Let Σ_out be a finite output alphabet of size β. Let A_0,A_1 ⊆ Σ_out be the allowed outputs at nodes with input bit 0 or 1, respectively. Let E ⊆ Σ_out × Σ_out be the allowed directed edge relation (u→v allowed iff (u,v)∈E). For an input word t ∈ {0,1}^k with k≥1, a labeling o ∈ Σ_out^k is legal if o[i]∈A_{t[i]} for all i, and (o[i],o[i+1])∈E for all 1≤i<k.
- For k≥4, define Ext_t ⊆ Σ_out^4 as the set of boundary quadruples (L1,L2,R2,R1) that extend to a legal labeling o with L1=o[1], L2=o[2], R2=o[k−1], R1=o[k]. For k≤3, Ext_t is defined with the same 4-tuple container but with the obvious coordinate equalities imposed by overlaps (tracked by k_flag ∈ {1,2,3,≥4}). The Type of t is Type(t) := (Ext_t, k_flag(t)).

Lemma 1 (Append-one-bit recurrence; k_flag≥4 case).
Let t be an input word with k_flag(t)≥4, and let t′ := t·a be t with one bit a ∈ {0,1} appended on the right. Then for all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x4 ∈ A_a and E(x3,x4) and ∃z∈Σ_out: (x1,x2,z,x3) ∈ Ext_t ].
Proof. Standard restriction/extension argument on legal labelings. □

Proposition 6 (Base-case update; k=1→2).
Let t=(b) be a length-1 input and t′:=t·a the length-2 input obtained by appending a∈{0,1}. For all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x1 = x3, x2 = x4, x1 ∈ A_b, x2 ∈ A_a, and E(x1,x2) ].
Proof. Immediate from the definition. □

Proposition 7 (Base-case update; k=3→4).
Let t=(b1,b2,b3) be a length-3 input and t′:=t·a the length-4 input obtained by appending a∈{0,1}. For all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x1∈A_{b1}, x2∈A_{b2}, x3∈A_{b3}, x4∈A_a, and E(x1,x2), E(x2,x3), E(x3,x4) ].
Proof. Unfold the definition on the 4-node path. □

Lemma 2 (Ext-level concatenation; k_flag≥4).
Let P and Q be input words with k_flag(P), k_flag(Q) ≥4, and let B := P·Q. Then for all (o1,o2,o3′,o4′)∈Σ_out^4,
  (o1,o2,o3′,o4′) ∈ Ext_B ⇔ ∃ x3,x4,x1′,x2′ ∈ Σ_out such that
    (o1,o2,x3,x4) ∈ Ext_P, (x1′,x2′,o3′,o4′) ∈ Ext_Q, and E(x4,x1′).
Proof. Combine witnesses across the seam, or restrict a legal labeling of B. □

Proposition 3 (Type congruence under appending one bit).
If Type(P)=Type(Q), then for all a∈{0,1}, Type(P·a)=Type(Q·a). In particular, Ext_{P·a}=Ext_{Q·a} and k_flag updates identically.
Proof. For k_flag≥4, Lemma 1 shows Ext_{(·)·a} depends only on Ext_{(·)} and a. Short cases follow by the explicit base-case rules. □

Proposition 4 (Unsoundness of existential R-composition).
There exists an instance (Σ_out,A_0,A_1,E) and types t_b,t_c such that there is m∈Σ_out with (x,m) ∈ R_{t_b} and (m,y) ∈ R_{t_c} for some x,y, yet (x,y) ∉ R_{t_b·t_c}. Hence the rule “(∃m) R_{P·Q}(x,y) ⇐ R_P(x,m) ∧ R_Q(m,y)” is not valid in general.
Proof. Use Σ_out={a,b,c}, A_0=A_1=Σ_out, E={(a,b),(b,c)}; choose t_b with rightmost a and t_c with leftmost c; pick m=b. The seam would require E(a,c), which fails. □

Proposition 5 (Optimized computation of Ext for concatenation in O(β^6)).
For any types τ,σ with k_flag(τ),k_flag(σ)≥4, define the 3D slices
  Left_τ[o1,o2,x4] := ∃x3 (o1,o2,x3,x4)∈Ext_τ, and
  Right_σ[x1′,o3′,o4′] := ∃x2′ (x1′,x2′,o3′,o4′)∈Ext_σ.
Then for all (o1,o2,o3′,o4′),
  (o1,o2,o3′,o4′) ∈ Ext_{τ⊙σ} ⇔ ∃x4,x1′: Left_τ[o1,o2,x4] ∧ E(x4,x1′) ∧ Right_σ[x1′,o3′,o4′].
Moreover, after precomputing Left_τ and Right_σ for all τ,σ in O(β^4) time per type, Ext_{τ⊙σ} can be computed in O(β^6) time.
Proof. Eliminate x3,x2′ by definitions; count entries. □

Proposition 6A (k_flag=1 append update without recovering the bit).
Let τ be a type with k_flag(τ)=1 and define S_τ := { x ∈ Σ_out : (x,x,x,x) ∈ Ext_τ }. For a∈{0,1}, let τ′ := δ(τ,a). Then for all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{τ′} ⇔ [ x1=x3, x2=x4, x1∈S_τ, x2∈A_a, and E(x1,x2) ].
Proof. Any legal 2-node labeling has boundary (o1,o2,o1,o2) with o1∈S_τ, o2∈A_a and E(o1,o2). Conversely, any tuple satisfying the listed constraints is realized by a legal labeling on the 2-node input. □

Lemma 8 (Type-count bound).
With Type(t):=(Ext_t, k_flag(t)) and Ext_t⊆Σ_out^4, the number of distinct types obeys |T| ≤ 4 · 2^{β^4}.
Proof. For each k_flag value, Ext can be any subset of Σ_out^4; sum over k_flag. □

Proposition 9 (δ well-defined; deterministic BFS enumeration in 2^{poly(β)} time/space).
Let δ map a type τ and an appended bit a∈{0,1} to the type of the one-bit extension. Define δ by:
- If k_flag(τ)=1, compute Ext of the 2-node type by Proposition 6A using S_τ.
- If k_flag(τ)=2, use the explicit k=2→3 update.
- If k_flag(τ)=3, use Proposition 7.
- If k_flag(τ)≥4, use Lemma 1.
Then δ(τ,a) depends only on τ and a (by Proposition 3). A deterministic BFS that starts from the length-1 seeds (t=(0) and t=(1)), repeatedly applies δ(·,0) and δ(·,1), and interns types by equality of (Ext, k_flag), halts after at most |T| insertions and enumerates all reachable types. Each transition costs O(β^5) in the k_flag≥4 regime (base-cases are ≤O(β^4)). Since |T| ≤ 4·2^{β^4}, the total time and space are 2^{poly(β)}. □

Lemma 10 (Reversal operator; basic properties).
Define, for any type τ=(Ext_τ,k_flag(τ)), the reversed type Rev(τ):=(Ext_τ^R, k_flag(τ)), where Ext_τ^R := { (y1,y2,y3,y4) : (y4,y3,y2,y1) ∈ Ext_τ }. Then Rev(Rev(τ))=τ and, for k_flag≥4, Ext_{Rev(τ) ⊙ Rev(σ)} = (Ext_{σ ⊙ τ})^R.
Proof. Direct from definitions and Lemma 2. □

Definition (Long types and pumping bound).
- T_long := { τ ∈ T : k_flag(τ) ≥ 4 }.
- Define ℓ_pump := |T|, where T is the set of reachable Types enumerated by Proposition 9.

Lemma 11 (Ext-level concatenation; all k_flag).
For any input words P,Q (no restriction on length) and B := P·Q, for all (o1,o2,o3′,o4′) ∈ Σ_out^4,
  (o1,o2,o3′,o4′) ∈ Ext_B ⇔ ∃ x3,x4,x1′,x2′ ∈ Σ_out:
    (o1,o2,x3,x4) ∈ Ext_P, (x1′,x2′,o3′,o4′) ∈ Ext_Q, and E(x4,x1′).
Proof. As in Lemma 2; k_flag imposes only coordinate equalities. □

Proposition 12 (Associativity of Ext-concatenation).
For any input words P,Q,R, Ext_{(P·Q)·R} = Ext_{P·(Q·R)} as subsets of Σ_out^4.
Proof. Either semantically (concatenation of words) or by rebracketing witnesses from Lemma 11. □

Lemma 13 (Prefix pumping).
Let ℓ_pump := |T|. For any input string w with |w| ≥ ℓ_pump there exist a decomposition w = x y z with 1 ≤ |y| ≤ ℓ_pump and |x y| ≤ ℓ_pump such that Type(x y^i z) is independent of i ≥ 0.
Proof. Pigeonhole on the first ℓ_pump+1 states of the δ-run. □

Lemma 14 (Periodic pumping).
For any nonempty string u there exist integers a,b with a+b ≤ ℓ_pump such that Type(u^{a+bi}) is invariant for all i ≥ 0.
Proof. Pigeonhole on the sequence Type(u^j), j≥0, and determinism of δ. □

Definition (Feasible function; Out-set form).
A function f: T_long × {0,1}^2 × T_long → Σ_out^2 is feasible if for every (τ_L, s, τ_R) it outputs (α1,α2) with αi ∈ A_{s[i]} and E(α1,α2), and moreover the following universal extendibility holds: for all τ_b,τ_c∈T_long and s1,s2 ∈ {0,1}^2, and for all α_L ∈ OutR2(τ_b,s1), α_R ∈ OutL1(τ_c,s2), there exists (o1,o2,o3,o4) ∈ Ext_{τ_b ⊙ τ_c} with E(α_L,o1) and E(o4,α_R), where
  OutR2(τ_b,s) := { second(f(τ_a,s,τ_b)) : τ_a ∈ T_long },
  OutL1(τ_c,s) := { first(f(τ_c,s,τ_d)) : τ_d ∈ T_long }.

Lemma 20 (Quantifier minimization equivalence).
Let f be any function T_long×{0,1}^2×T_long→Σ_out^2 obeying node/window constraints. The universal extendibility clause stated here is equivalent to the clause “for all τ_a,τ_b,τ_c,τ_d and s1,s2, letting α_L := second(f(τ_a,s1,τ_b)) and α_R := first(f(τ_c,s2,τ_d)), there exists (o1,o2,o3,o4)∈Ext_{τ_b⊙τ_c} with E(α_L,o1), E(o4,α_R)).”
Proof. “Only if”: the α_L,α_R in the original clause range over OutR2,OutL1. “If”: for given τ_b,τ_c,s1,s2 and α_L∈OutR2, α_R∈OutL1, pick τ_a,τ_d witnessing membership and apply the original clause. □

Proposition 19 (Optimized append in O(β^4) time for k_flag≥4).
For t with k_flag≥4 and a∈{0,1}, define Left3_t[x1,x2,x3] := ∃z (x1,x2,z,x3)∈Ext_t. One can compute Left3_t in O(β^4) time. Then fill Ext_{t·a} by scanning all (x1,x2,x3) with Left3_t[x1,x2,x3]=true and, for each, iterating over x4 with E(x3,x4) and x4∈A_a, setting Ext_{t·a}[x1,x2,x3,x4]←true. The total time is O(β^4) in the dense worst-case.
Proof. Correctness follows from Lemma 1. Complexity: Left3_t has β^3 entries, each tested in O(β); the fill step is O(β^3Δ) with Δ≤β. □

Proposition 21 (Seam-feasibility matrices for τ_b ⊙ τ_c).
For τ_b,τ_c, define W_{b⊙c}[α_L][α_R] (a β×β boolean matrix) to be true iff ∃(o1,o2,o3,o4)∈Ext_{τ_b⊙τ_c} with E(α_L,o1) and E(o4,α_R). Using precomputed 3D slices or Ext_{τ_b⊙τ_c}, W_{b⊙c} can be computed in O(β^4Δ^2) time (or better with sparse E), and then universal extendibility checks reduce to testing W_{b⊙c}[α_L][α_R].
Proof. Expand the definition via Lemma 11, eliminate internal witnesses by slices, and count operations. □

Proposition 17 (Nonemptiness monotonicity under concatenation).
If Ext_P ≠ ∅ and Ext_Q ≠ ∅ and there exist x4,x1′ with E(x4,x1′), then Ext_{P·Q} ≠ ∅.
Proof. Choose any (o1,o2,x3,x4) ∈ Ext_P and (x1′,x2′,o3′,o4′) ∈ Ext_Q; Lemma 11 and E(x4,x1′) imply (o1,o2,o3′,o4′) ∈ Ext_{P·Q}. □

Remark (Stage-1 equivalence pending endpoint treatment).
The o(n)⇔feasible-f equivalence claimed earlier is temporarily removed pending a rigorous treatment of endpoint segments in the (⇐) direction (see notes). All supporting mechanics above remain valid and will be reused once the endpoint lemma/partition fix is in place.
Proposition 6B (Base-case update; k=2→3).
Let t=(b1,b2) be a length-2 input and t′:=t·a the length-3 input obtained by appending a∈{0,1}. For all (x1,x2,x3,x4) ∈ Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x3 = x2, x1 ∈ A_{b1}, x2 ∈ A_{b2}, x4 ∈ A_a, E(x1,x2), and E(x2,x4) ].
Proof. Any legal labeling on three nodes has boundary (o1,o2,o2,o3), with o1∈A_{b1}, o2∈A_{b2}, o3∈A_a and E(o1,o2), E(o2,o3). Conversely, any tuple satisfying these constraints is realized by such a labeling. □

Definitions (endpoint projections and seam matrices).
For any type τ, define the projections of Ext_τ to the endpoint coordinates:
- RightColors(τ) := { y ∈ Σ_out : ∃ x1,x2,x3 with (x1,x2,x3,y) ∈ Ext_τ }.
- LeftColors(τ)  := { x ∈ Σ_out : ∃ x2,x3,y with (x,x2,x3,y) ∈ Ext_τ }.
Define the endpoint seam-compatibility matrices by
- V_left[τ][α]  := true ⇔ ∃ y ∈ RightColors(τ) with E(y, α), and
- V_right[α][τ] := true ⇔ ∃ x ∈ LeftColors(τ) with E(α, x).

Lemma E1 (endpoint feasibility via Ext).
Let τ be any type and α ∈ Σ_out.
(i) There exists a legal labeling of a left end-block of type τ together with an adjacent separator whose first output is α if and only if V_left[τ][α] is true.
(ii) There exists a legal labeling of a right end-block of type τ together with an adjacent separator whose second output is α if and only if V_right[α][τ] is true.
Proof. (i) If V_left[τ][α] holds, pick y ∈ RightColors(τ) with E(y,α) and any (x1,x2,x3,y)∈Ext_τ; Ext-membership provides the interior, and E(y,α) the seam. Conversely, any legal instance gives y as the last output on the end block, whence (x1,x2,x3,y)∈Ext_τ and E(y,α). (ii) is symmetric. □

Remark (on endpoints and Stage-1 for paths).
The matrices V_left and V_right give necessary and sufficient local conditions to glue an endpoint block to its unique adjacent separator. In the full o(n) vs Ω(n) classification on oriented paths, one must also ensure that the separator next to an endpoint is compatible with the nearest interior separator across the intervening block. This requires coupling the endpoint separator’s “open” seam color with the Out-sets produced by the feasible function on interior separators; see notes for a corrected certificate and construction. The o(n)⇔feasible-f equivalence remains pending this endpoint–interior bridging step.

