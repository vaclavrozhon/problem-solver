{
  "progress_md": "Round 0010 \u2014 audits after integrating S1\u2011path; minor fixes, endpoint extraction hygiene, and incremental lemmas for endpoint projections\n\nAudit of output.md (gaps, small bugs, and numbering)\n- Numbering consistency. There are now four \u201cProposition 6/6A/6B/7\u201d base rules: 6 (k=1\u21922), 6A (k_flag=1 append), 6B (k=2\u21923), 7 (k=3\u21924). This is fine logically but confusing; consider renumbering or grouping the three base updates together (k=1\u21922, 2\u21923, 3\u21924) and listing the k_flag=1 append normalization as a lemma.\n- Proposition 9 complexity text still says O(\u03b2^5) per long append, while a later correction notes O(\u03b2^4) via Proposition 19. Please reconcile in the body of Prop. 9 (replace O(\u03b2^5) with O(\u03b2^4) for k_flag\u22654) so the main statement matches the correction.\n- S1\u2011path (\u21d2) endpoint extraction: the proof says \u201crun A on w_{\u03c4_end} \u00b7 S(s) \u00b7 w_{\u03c4_b} with padding beyond distance R on both sides\u201d. Here \u03c4_end ranges over T (short and long), but w_\u03c4 is only defined for \u03c4\u2208T_long in the pumping construction. Also, for an endpoint there is no left padding beyond the path boundary. This is easily fixed by: (i) replacing w_{\u03c4_end} with \u201can arbitrary path P_end realizing Type \u03c4_end\u201d (short allowed), and (ii) only padding on the right by choosing w_{\u03c4_b} long enough so the R\u2011neighborhood around S is contained in w_{\u03c4_b} on its right side; on the left side the endpoint may lie inside the halo, which is intended. The extraction remains valid and captures the true endpoint behavior.\n- Minor duplication: Lemma 2 (k_flag\u22654 concatenation) is subsumed by Lemma 11 (all k_flags). A note that Lemma 11 subsumes Lemma 2 would avoid potential confusion.\n\nEndpoint mechanics \u2014 incremental, checkable additions\n1) Fast incremental updates for endpoint projections under append (k_flag\u22654)\n- Statement. For \u03c4 with k_flag(\u03c4)\u22654 and \u03c4\u2032=\u03c4\u00b7a,\n  \u2022 LeftColors(\u03c4\u2032) = LeftColors(\u03c4).\n  \u2022 RightColors(\u03c4\u2032) = { y \u2208 A_a : \u2203 x1,x2,x3 with Left3_\u03c4[x1,x2,x3]=true and E(x3,y) }.\n- Why useful. Lets the verifier update V_left/V_right incrementally during \u03b4\u2011BFS using the already\u2011precomputed Left3_\u03c4, avoiding recomputing projections from scratch (O(\u03b2^3) instead of scanning all \u03b2^4 quadruples).\n- Proof sketch. LeftColors projects the first coordinate, which is unaffected by appending a new node at the right. RightColors of \u03c4\u2032 consists of those y that can appear as new R1; by Lemma 1, (x1,x2,x3,y)\u2208Ext_{\u03c4\u2032} iff Left3_\u03c4[x1,x2,x3] and E(x3,y) and y\u2208A_a.\n\n2) Endpoint allow sets as E\u2011neighborhoods (explicit identities)\n- Identities. L_allow(\u03c4) := {\u03b1 : V_left[\u03c4][\u03b1]} = N_E(RightColors(\u03c4)), and R_allow(\u03c4) := {\u03b1 : V_right[\u03b1][\u03c4]} = N_E^{-1}(LeftColors(\u03c4)).\n- Why useful. Makes explicit that V_left/V_right are just one\u2011step E\u2011blowups of the endpoint projections; convenient for unit tests and caching.\n- Proof. By the definitions of V_left/V_right and LeftColors/RightColors.\n\n3) Early infeasibility filters for Stage\u20111 verification (constant\u2011time table checks)\n- Filter F1 (interior Out\u2011sets nonempty). If there exist \u03c4_b,s with OutR2(\u03c4_b,s)=\u2205 or \u03c4_c,s with OutL1(\u03c4_c,s)=\u2205, then no feasible f_mid can exist \u2014 reject.\n- Filter F2 (endpoint alignment reachability). For any \u03c4_end,\u03c4_b,s, if L_allow(\u03c4_end)=\u2205 or OutR2(\u03c4_b,s)=\u2205, then any g_L(\u03c4_end,s,\u03c4_b) is impossible. Symmetric for g_R.\n- Why useful. Fast rejections before scanning W_{b\u2299c} matrices; reduces witness search space.\n- Justification. Trivial from definitions of Out\u2011sets and V_left/V_right.\n\n4) Endpoint extraction hygiene for S1\u2011path (\u21d2) \u2014 revised, auditable phrasing\n- Current line: \u201crun A on w_{\u03c4_end} \u00b7 S(s) \u00b7 w_{\u03c4_b} \u2026 with padding on both sides.\u201d\n- Revised statement (suggested edit). For each (\u03c4_end\u2208T, s, \u03c4_b\u2208T_long): pick any finite path P_end with Type(P_end)=\u03c4_end; pick w_{\u03c4_b} long (as in the f_mid construction) so that the radius\u2011R halo of S lies entirely inside w_{\u03c4_b} on the right. Run A on the finite path P := P_end \u00b7 S(s) \u00b7 w_{\u03c4_b} (no left padding beyond the endpoint). Define g_L(\u03c4_end,s,\u03c4_b) as the output on S. Local correctness implies (i) node/edge legality. Since the seam edge from P_end into S is respected, V_left[\u03c4_end][\u03b21] holds (ii). Because the right context is of Type \u03c4_b and the halo on that side is entirely inside w_{\u03c4_b}, the second output belongs to OutR2(\u03c4_b,s) (iii). Symmetric for g_R.\n- Why this matters. It removes reliance on w_{\u03c4_end} (undefined if \u03c4_end is short) and avoids padding past the endpoint.\n\nConcrete, testable lemmas to consider adding\n- Lemma E3 (Bridging equivalence, restated as set inclusion). For \u03c4_b,\u03c4_c and inputs s1,s2, define the seam\u2011reachable pair set\n  R\u0302_{b\u2299c}(s1,s2) := { (\u03b1_L,\u03b1_R) : W_{b\u2299c}[\u03b1_L][\u03b1_R]=true }.\n  Then feasibility of f_mid is equivalent to the pairwise inclusions\n  OutR2(\u03c4_b,s1) \u00d7 OutL1(\u03c4_c,s2) \u2286 R\u0302_{b\u2299c}(s1,s2) for all \u03c4_b,\u03c4_c,s1,s2.\n  Proof: Unpack Lemma 20 and Prop. 21.\n- Lemma E4 (Endpoint\u2013interior block fill, explicit construction). Given g_L(\u03c4_end,s,\u03c4_b)=(\u03b21,\u03b22) satisfying (i)\u2013(iii) and an interior separator S2 with color pair (\u03b11,\u03b12)=f_mid(\u03c4_c,s2,\u03c4_d), the intervening block between the endpoint separator and S2 admits a completion. Construction: pick (o1,o2,o3,o4) from Ext_{\u03c4_b\u2299\u03c4_c} witnessing W_{b\u2299c}[\u03b22][\u03b11], then fill by Ext_{\u03c4_b\u2299\u03c4_c}; correctness follows from Lemma E2.\n\nSmall example to document the need for endpoint alignment (suggested to add as a remark)\n- Let \u03a3_out={a,b}, A_0=A_1=\u03a3_out, E={(a,a),(b,b)}. Suppose f_mid always outputs (b,b), thus OutR2={b}. Take \u03c4_end with RightColors(\u03c4_end)={a}. If one chose g_L(\u03c4_end,s,\u03c4_b)=(a,a) based only on V_left (true) but ignored alignment (\u03b22\u2208OutR2), the adjacent interior block would require W_{b\u2299c}[a][\u00b7], which can be false, and the construction would fail. The alignment clause (iii) prevents this.\n\nImplementation notes (verifier/solver side)\n- Precompute Left3_\u03c4 during \u03b4\u2011BFS and use the identities in item 1) to maintain RightColors(\u00b7), LeftColors(\u00b7), thus V_left/V_right, in O(\u03b2^3) per long append.\n- For endpoint maps, precompute bit\u2011sets L_allow(\u03c4) and R_allow(\u03c4) once; checking g_L/g_R then reduces to:\n  \u2022 membership in A_{s[i]} and E on the 2\u2011node window (constant time),\n  \u2022 \u03b21 \u2208 L_allow(\u03c4_end) or \u03b22 \u2208 R_allow(\u03c4_end),\n  \u2022 \u03b22 \u2208 OutR2(\u03c4_b,s) or \u03b21 \u2208 OutL1(\u03c4_c,s).\n- Speed hint: during f_mid verification, build per\u2011pair masks M_{b\u2299c}(s1,s2) := {\u03b1_L}\u00d7{\u03b1_R} for \u03b1_L\u2208OutR2(\u03c4_b,s1), \u03b1_R\u2208OutL1(\u03c4_c,s2), and check that M_{b\u2299c}(s1,s2) \u2286 R\u0302_{b\u2299c}(s1,s2); if not, report the first violating pair, making counterexamples easy to extract.\n\nNext steps toward full trichotomy (O(1) vs \u0398(log* n) vs \u0398(n))\n- Stage\u20112 on oriented paths. Bring in a path\u2011specialized version of the (\u2113_width,\u2113_count,\u2113_pattern)\u2011partition (paper\u2019s Lemma 22) with explicit constants compatible with \u2113_pump; then formalize the per\u2011type tiling witness Q_\u03c4 and the constant\u2011round construction. The checks already sketched in earlier rounds (tiling within \u03c4, universal bridging across \u03c4_S via Ext) should carry over verbatim with our Ext/W machinery.\n- MIS on K\u2011th power (for completeness). Add a brief lemma that on globally oriented paths one can compute an MIS of the K\u2011th power in O(log* n), and that consecutive MIS nodes are at distance in [K,2K]; cite folklore or include a 3\u2011line proof via Cole\u2013Vishkin coloring and greedy thinning. This makes the spacing claim in S1\u2011path fully self\u2011contained.\n- Regression tests. Extend the harness to check:\n  \u2022 Incremental RightColors/LeftColors updates vs direct projection of Ext after append.\n  \u2022 S1 verification equivalence in Lemma E3 form (set inclusion) using precomputed R\u0302_{b\u2299c}.\n  \u2022 Endpoint misalignment: synthesize instances violating (iii) and confirm rejection.\n  \u2022 Prop. 9 runtime constants: confirm O(\u03b2^4) append for k_flag\u22654 against O(\u03b2^5) brute force on \u03b2\u2208{2,3}.\n\nWhy these are incremental and auditable\n- Each lemma is a one\u2011line identity following mechanically from already\u2011defined objects (Ext and its slices). They admit direct unit tests on small \u03b2.\n- The endpoint extraction hygiene is a textual correction with unchanged logic; it prevents an uninstantiated symbol (w_{\u03c4_end}) and avoids padding past the endpoint while preserving the argument.\n- The feasibility filters F1/F2 are immediate consequences of definitions, implementable as constant\u2011time table emptiness checks.\n\nOpen items (to track)\n- Decide whether to keep both Lemma 2 and Lemma 11; if both retained, add an explicit \u201cLemma 11 subsumes Lemma 2\u201d note.\n- Normalize base\u2011case numbering to avoid 6/6A/6B confusion.\n- Integrate the MIS\u2011on\u2011Kth\u2011power statement and the Stage\u20112 partition lemma specialized to oriented paths to complete the constant\u2011time classification.\n"
}