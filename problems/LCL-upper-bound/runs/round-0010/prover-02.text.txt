{"progress_md":"Round 0010 — audits after integrating S1‑path; minor fixes, endpoint extraction hygiene, and incremental lemmas for endpoint projections\n\nAudit of output.md (gaps, small bugs, and numbering)\n- Numbering consistency. There are now four “Proposition 6/6A/6B/7” base rules: 6 (k=1→2), 6A (k_flag=1 append), 6B (k=2→3), 7 (k=3→4). This is fine logically but confusing; consider renumbering or grouping the three base updates together (k=1→2, 2→3, 3→4) and listing the k_flag=1 append normalization as a lemma.\n- Proposition 9 complexity text still says O(β^5) per long append, while a later correction notes O(β^4) via Proposition 19. Please reconcile in the body of Prop. 9 (replace O(β^5) with O(β^4) for k_flag≥4) so the main statement matches the correction.\n- S1‑path (⇒) endpoint extraction: the proof says “run A on w_{τ_end} · S(s) · w_{τ_b} with padding beyond distance R on both sides”. Here τ_end ranges over T (short and long), but w_τ is only defined for τ∈T_long in the pumping construction. Also, for an endpoint there is no left padding beyond the path boundary. This is easily fixed by: (i) replacing w_{τ_end} with “an arbitrary path P_end realizing Type τ_end” (short allowed), and (ii) only padding on the right by choosing w_{τ_b} long enough so the R‑neighborhood around S is contained in w_{τ_b} on its right side; on the left side the endpoint may lie inside the halo, which is intended. The extraction remains valid and captures the true endpoint behavior.\n- Minor duplication: Lemma 2 (k_flag≥4 concatenation) is subsumed by Lemma 11 (all k_flags). A note that Lemma 11 subsumes Lemma 2 would avoid potential confusion.\n\nEndpoint mechanics — incremental, checkable additions\n1) Fast incremental updates for endpoint projections under append (k_flag≥4)\n- Statement. For τ with k_flag(τ)≥4 and τ′=τ·a,\n  • LeftColors(τ′) = LeftColors(τ).\n  • RightColors(τ′) = { y ∈ A_a : ∃ x1,x2,x3 with Left3_τ[x1,x2,x3]=true and E(x3,y) }.\n- Why useful. Lets the verifier update V_left/V_right incrementally during δ‑BFS using the already‑precomputed Left3_τ, avoiding recomputing projections from scratch (O(β^3) instead of scanning all β^4 quadruples).\n- Proof sketch. LeftColors projects the first coordinate, which is unaffected by appending a new node at the right. RightColors of τ′ consists of those y that can appear as new R1; by Lemma 1, (x1,x2,x3,y)∈Ext_{τ′} iff Left3_τ[x1,x2,x3] and E(x3,y) and y∈A_a.\n\n2) Endpoint allow sets as E‑neighborhoods (explicit identities)\n- Identities. L_allow(τ) := {α : V_left[τ][α]} = N_E(RightColors(τ)), and R_allow(τ) := {α : V_right[α][τ]} = N_E^{-1}(LeftColors(τ)).\n- Why useful. Makes explicit that V_left/V_right are just one‑step E‑blowups of the endpoint projections; convenient for unit tests and caching.\n- Proof. By the definitions of V_left/V_right and LeftColors/RightColors.\n\n3) Early infeasibility filters for Stage‑1 verification (constant‑time table checks)\n- Filter F1 (interior Out‑sets nonempty). If there exist τ_b,s with OutR2(τ_b,s)=∅ or τ_c,s with OutL1(τ_c,s)=∅, then no feasible f_mid can exist — reject.\n- Filter F2 (endpoint alignment reachability). For any τ_end,τ_b,s, if L_allow(τ_end)=∅ or OutR2(τ_b,s)=∅, then any g_L(τ_end,s,τ_b) is impossible. Symmetric for g_R.\n- Why useful. Fast rejections before scanning W_{b⊙c} matrices; reduces witness search space.\n- Justification. Trivial from definitions of Out‑sets and V_left/V_right.\n\n4) Endpoint extraction hygiene for S1‑path (⇒) — revised, auditable phrasing\n- Current line: “run A on w_{τ_end} · S(s) · w_{τ_b} … with padding on both sides.”\n- Revised statement (suggested edit). For each (τ_end∈T, s, τ_b∈T_long): pick any finite path P_end with Type(P_end)=τ_end; pick w_{τ_b} long (as in the f_mid construction) so that the radius‑R halo of S lies entirely inside w_{τ_b} on the right. Run A on the finite path P := P_end · S(s) · w_{τ_b} (no left padding beyond the endpoint). Define g_L(τ_end,s,τ_b) as the output on S. Local correctness implies (i) node/edge legality. Since the seam edge from P_end into S is respected, V_left[τ_end][β1] holds (ii). Because the right context is of Type τ_b and the halo on that side is entirely inside w_{τ_b}, the second output belongs to OutR2(τ_b,s) (iii). Symmetric for g_R.\n- Why this matters. It removes reliance on w_{τ_end} (undefined if τ_end is short) and avoids padding past the endpoint.\n\nConcrete, testable lemmas to consider adding\n- Lemma E3 (Bridging equivalence, restated as set inclusion). For τ_b,τ_c and inputs s1,s2, define the seam‑reachable pair set\n  R̂_{b⊙c}(s1,s2) := { (α_L,α_R) : W_{b⊙c}[α_L][α_R]=true }.\n  Then feasibility of f_mid is equivalent to the pairwise inclusions\n  OutR2(τ_b,s1) × OutL1(τ_c,s2) ⊆ R̂_{b⊙c}(s1,s2) for all τ_b,τ_c,s1,s2.\n  Proof: Unpack Lemma 20 and Prop. 21.\n- Lemma E4 (Endpoint–interior block fill, explicit construction). Given g_L(τ_end,s,τ_b)=(β1,β2) satisfying (i)–(iii) and an interior separator S2 with color pair (α1,α2)=f_mid(τ_c,s2,τ_d), the intervening block between the endpoint separator and S2 admits a completion. Construction: pick (o1,o2,o3,o4) from Ext_{τ_b⊙τ_c} witnessing W_{b⊙c}[β2][α1], then fill by Ext_{τ_b⊙τ_c}; correctness follows from Lemma E2.\n\nSmall example to document the need for endpoint alignment (suggested to add as a remark)\n- Let Σ_out={a,b}, A_0=A_1=Σ_out, E={(a,a),(b,b)}. Suppose f_mid always outputs (b,b), thus OutR2={b}. Take τ_end with RightColors(τ_end)={a}. If one chose g_L(τ_end,s,τ_b)=(a,a) based only on V_left (true) but ignored alignment (β2∈OutR2), the adjacent interior block would require W_{b⊙c}[a][·], which can be false, and the construction would fail. The alignment clause (iii) prevents this.\n\nImplementation notes (verifier/solver side)\n- Precompute Left3_τ during δ‑BFS and use the identities in item 1) to maintain RightColors(·), LeftColors(·), thus V_left/V_right, in O(β^3) per long append.\n- For endpoint maps, precompute bit‑sets L_allow(τ) and R_allow(τ) once; checking g_L/g_R then reduces to:\n  • membership in A_{s[i]} and E on the 2‑node window (constant time),\n  • β1 ∈ L_allow(τ_end) or β2 ∈ R_allow(τ_end),\n  • β2 ∈ OutR2(τ_b,s) or β1 ∈ OutL1(τ_c,s).\n- Speed hint: during f_mid verification, build per‑pair masks M_{b⊙c}(s1,s2) := {α_L}×{α_R} for α_L∈OutR2(τ_b,s1), α_R∈OutL1(τ_c,s2), and check that M_{b⊙c}(s1,s2) ⊆ R̂_{b⊙c}(s1,s2); if not, report the first violating pair, making counterexamples easy to extract.\n\nNext steps toward full trichotomy (O(1) vs Θ(log* n) vs Θ(n))\n- Stage‑2 on oriented paths. Bring in a path‑specialized version of the (ℓ_width,ℓ_count,ℓ_pattern)‑partition (paper’s Lemma 22) with explicit constants compatible with ℓ_pump; then formalize the per‑type tiling witness Q_τ and the constant‑round construction. The checks already sketched in earlier rounds (tiling within τ, universal bridging across τ_S via Ext) should carry over verbatim with our Ext/W machinery.\n- MIS on K‑th power (for completeness). Add a brief lemma that on globally oriented paths one can compute an MIS of the K‑th power in O(log* n), and that consecutive MIS nodes are at distance in [K,2K]; cite folklore or include a 3‑line proof via Cole–Vishkin coloring and greedy thinning. This makes the spacing claim in S1‑path fully self‑contained.\n- Regression tests. Extend the harness to check:\n  • Incremental RightColors/LeftColors updates vs direct projection of Ext after append.\n  • S1 verification equivalence in Lemma E3 form (set inclusion) using precomputed R̂_{b⊙c}.\n  • Endpoint misalignment: synthesize instances violating (iii) and confirm rejection.\n  • Prop. 9 runtime constants: confirm O(β^4) append for k_flag≥4 against O(β^5) brute force on β∈{2,3}.\n\nWhy these are incremental and auditable\n- Each lemma is a one‑line identity following mechanically from already‑defined objects (Ext and its slices). They admit direct unit tests on small β.\n- The endpoint extraction hygiene is a textual correction with unchanged logic; it prevents an uninstantiated symbol (w_{τ_end}) and avoids padding past the endpoint while preserving the argument.\n- The feasibility filters F1/F2 are immediate consequences of definitions, implementable as constant‑time table emptiness checks.\n\nOpen items (to track)\n- Decide whether to keep both Lemma 2 and Lemma 11; if both retained, add an explicit “Lemma 11 subsumes Lemma 2” note.\n- Normalize base‑case numbering to avoid 6/6A/6B confusion.\n- Integrate the MIS‑on‑Kth‑power statement and the Stage‑2 partition lemma specialized to oriented paths to complete the constant‑time classification.\n"}