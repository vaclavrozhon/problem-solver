--- SYSTEM ---
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (summary so far)
- output.md (rigorously proven results so far)

Guidelines:
- notes.md: should be a readable running log of interesting work. Prefer appending. Replace only if old notes are clearly misleading. Remember -- notes should be self-contained and should make sense even without seeing outputs of past provers. 
- output.md:  Think twice before you add something to this file. Everything here should be rigorous, almost publication-ready. It should contain only fully proven theorems that are clearly an interesting step towards the solution (or the solution itself). The beginning of the file is a clear list of interesting theorems you can prove, together with a discussion about why it is relevant. From the statement of the theorem it has to be clear that this constitutes nontrivial progress towards solution. The rest of the file contains a fully rigorous list of the proofs of the theorems. Keep only proven theorems with clear proofs. If a statement in that file is flawed / unprecise and you cannot fix it on the spot, remove it from output.md and instead add it to notes.md with explanation.
- Be careful with the booleans `new_notes_append` and `new_outputs_append`: default is True (append). Use False only when deliberately rewriting everything.

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (≥200 words). Include concrete next-step suggestions. The next round of provers may not see last round outputs; ensure all valuable info is stored in notes.",
  "new_notes_md": "Markdown (KaTeX allowed). Usually appended to notes.",
  "new_notes_append": "True|False",
  "new_outputs_md": "Markdown (KaTeX allowed). Usually appended to output.md.",
  "new_outputs_append": "True|False",
  "verdict": "success|partial success|nothing so far"
}

**Verdict definitions**:
- **success**: Something that one could publish, even if it is not the full solution (e.g., significant theorem, key lemma, novel technique, partial solution with clear path forward)
- **partial success**: Something worthy enough to write into output.md (e.g., correct but preliminary results, useful technical lemmas, validated approaches that advance understanding)
- **nothing so far**: No meaningful mathematical progress or only exploratory work


--- USER ---
You receive multiple prover reports. Evaluate correctness, value, and pick promising directions. Update notes.md (append/replace) with useful ideas and update output.md (append/replace) ONLY with rigorously verified results.

Prover reports (JSON):
[{"prover_id": "01", "progress_md": "Round 0010 \u2014 audit of output.md, endpoint-cleanup notes, and a concrete Stage\u20112 plan for oriented paths (O(1) vs \u0398(log* n))\n\nAudit of output.md (gaps, inconsistencies, and easy fixes)\n- Duplicate/contradictory remarks on Stage\u20111: There is still a \u201cRemark (Stage\u20111 equivalence pending endpoint treatment)\u201d before Lemma E2, but Theorem S1\u2011path later resolves endpoint issues. This is now inconsistent. Suggested fix: remove or rewrite the earlier remark to forward\u2011reference Theorem S1\u2011path.\n- Numbering collisions and duplication:\n  \u2022 Proposition 6, 6A, 6B all exist; 6 and 6B both are base cases (k=1\u21922 and k=2\u21923) and 6A is another base case (k_flag=1 variant). Consider renumbering to 6 (k=1\u21922), 7 (k=2\u21923), 8 (k=3\u21924), or add clear \u201c(Base cases)\u201d headers to avoid confusion.\n  \u2022 Concatenation appears as Lemma 2 (k_flag\u22654) and Lemma 11 (all k_flag). Lemma 11 strictly subsumes Lemma 2; a short note stating \u201cLemma 11 subsumes Lemma 2\u201d would prevent confusion.\n- Transition\u2011cost mismatch: Proposition 9 still states \u201cEach transition costs O(\u03b2^5) in the k_flag\u22654 regime,\u201d while a later \u201cCorrection to Proposition 9\u201d paragraph records the improved O(\u03b2^4) bound (via Proposition 19). These must be aligned; keep the O(\u03b2^4) bound in the definitive statement of Proposition 9.\n- Small\u2011n fallback in Theorem S1\u2011path (\u21d0): It says \u201c0 or 1 separators handled by brute\u2011force completion using Ext tables in constant radius.\u201d This is plausible, but a one\u2011line lemma would clarify that any path of length < K can be labeled (or rejected) by a constant\u2011time rule derived from Ext (finite lookup radius K). This would parallel Lemma E2\u2019s style, ensuring no gap at tiny n.\n- Orientation/convention reminder: Theorem S1\u2011path relies on the global convention (L1,L2,R2,R1); all seam references are consistent with earlier definitions. No action, but a short \u201cIndexing reminder\u201d near Definition of OutR2/OutL1 would help readers.\n\nEndpoint coupling in Stage\u20111 \u2014 sanity check on the new content\n- The strengthened endpoint witnesses g_L(\u03c4_end,s,\u03c4_b), g_R(\u03c4_c,s,\u03c4_end), with (iii) \u03b22\u2208OutR2(\u03c4_b,s), \u03b21\u2208OutL1(\u03c4_c,s), are now integrated and correctly cover the first/last interior block via W_{b\u2299c}. This closes the earlier gap.\n- Preprocessing coverage is complete: T and T_long (Prop. 9), Ext (Lemmas 1, 11), W (Prop. 21), V_left/V_right (Lemma E1), and OutR2/OutL1 are all defined. The NEXPTIME verification clause is sound.\n\nStage\u20112 on globally oriented paths (O(1) vs \u0398(log* n)) \u2014 proposed path\u2011specific certificate and theorem\nRationale. To complete the trichotomy with a single\u2011exponential (in \u03b2) nondeterministic verifier, it is convenient to mirror the paper\u2019s Section 4.4 feasible\u2011function framework, specialized to oriented paths. This avoids having to synthesize interior outputs from bare boundary quadruples and leverages the (\u2113_width,\u2113_count,\u2113_pattern) partition (Section 4.3 in the paper) in O(1) rounds.\n\nDefinitions (path specialization; reusing the paper\u2019s Gw,z and Gw1,w2,S)\n- Fix r=1 and \u2113_pump=|T| from Prop. 9. For any 1\u2264|w|\u2264\u2113_pump and z\u22650, Gw,z is the path wr \u00b7 wz \u00b7 wr with complete output labeling f0(w)^{z+2r} (here f0 is a Stage\u20112 function; see below). Mid(Gw,z): the central wz.\n- For any w1,w2 with 1\u2264|wi|\u2264\u2113_pump and any S (possibly empty), Gw1,w2,S is the path w1^{\u2113_pump+2r} \u00b7 S \u00b7 w2^{\u2113_pump+2r} with a partial labeling that fixes the first 2r|w1| outputs to f0(w1)^{2r} and the last 2r|w2| outputs to f0(w2)^{2r}. Mid(Gw1,w2,S): w1^{\u2113_pump+r} \u00b7 S \u00b7 w2^{\u2113_pump+r}.\n- Stage\u20112 feasible function for paths. A map f0: {w \u2208 \u03a3_in^k : 1\u2264k\u2264\u2113_pump} \u2192 \u03a3_out^k is path\u2011feasible if:\n  (F1) For each w, the complete labeling f0(w) is locally legal, and for Gw,1 the labeling is locally consistent on Mid(Gw,1). (Equivalently, Gw,z is locally consistent on its mid for all z\u22651.)\n  (F2) For each Gw1,w2,S, there exists a completion L\u22c4 that is locally consistent on Mid(Gw1,w2,S).\nRemark. This is the path analogue of the cycle notion used in the attached paper (Lemmas 23\u201327), with the same quantitative parameters (\u2113_pump) and \u201cmid\u2011block extendibility\u201d semantics; the only change is that we do not wrap ends.\n\nTheorem S2\u2011path (O(1) vs \u0398(log* n) on oriented paths; verifiable in NEXPTIME)\n- Statement. An r=1 \u03b2\u2011normalized LCL on globally oriented paths has deterministic LOCAL complexity O(1) iff there exists a path\u2011feasible function f0. Otherwise, if Theorem S1\u2011path holds but no f0 exists, the complexity is \u0398(log* n).\n- (\u21d2) Given an O(1)\u2011round algorithm A, extract f0 as in the paper\u2019s Lemma 24: for each 1\u2264|w|\u2264\u2113_pump, simulate A on wi \u00b7 w^{2r+1} \u00b7 wi with distinct IDs confined to a constant halo; define f0(w) as A\u2019s outputs on w (one period). Local legality implies (F1), and by the same mid\u2011block simulation trick, (F2) holds for all Gw1,w2,S (replace the two long contexts by pumped canonical representatives so that the constant runtime halos are disjoint). This is the path version of Lemmas 24\u201325.\n- (\u21d0) Given f0, compute in O(1) rounds an (\u2113_width,\u2113_count,\u2113_pattern)\u2011partition tailored to oriented paths (paper\u2019s Lemma 22; orientation is given, so Lemma 19\u2019s orientation step is unnecessary): short paths of length \u22642\u2113_width get explicit ranks; long paths P are repetitions wk with primitive w, |w|\u2264\u2113_pattern and k\u2265\u2113_count, and each node knows w. Label as follows:\n  \u2022 For each long P with period w, label the central window of length 2r in every period occurrence by f0(w) (anchored and repeated), thereby fixing a 2r\u2011spaced set of \u201cmid blocks\u201d across P.\n  \u2022 The remaining subpaths between these mid blocks (and any adjacent short/irregular segments) have total length O(\u2113_width+\u2113_pattern)=O(1). For each such S with adjacent periodic contexts represented by w1 and w2, apply (F2) to Gw1,w2,S to complete S locally. (Ends of the path are treated similarly, with one side lacking a further context; in that case the partially labeled path is a prefix/suffix of Gw1,w2,S and is handled within the same constant\u2011radius templates.)\n  \u2022 All fillings are constant\u2011radius choices from precomputed tables indexed by (w1,S,w2), exactly as in the cycle proof.\n  Hence a deterministic O(1) algorithm exists.\n- NEXPTIME verification. As in Lemma 23, checking path\u2011feasibility of f0 reduces to finitely many Gw,1 (one z=1 per w) and finitely many Gw1,w2,S, where S ranges over a representative per Type \u03c4 (Lemmas 11 and 14 guarantee a choice with |S|\u2264\u2113_pump), plus S=\u2205. With T enumerated (Prop. 9) and Ext computed (Props. 5, 19), all checks are boolean table lookups; total time 2^{poly(\u03b2)}.\n\nEndpoint handling in Stage\u20112\n- Unlike Stage\u20111, Stage\u20112\u2019s construction does not require special endpoint witnesses: every short/irregular segment, including the two end segments, falls under the Gw1,w2,S completion rule with one or both contexts being (constant\u2011size) pumped fragments. No extra V_left/V_right matrices are needed; the end segments are simply instances of S.\n\nRelation to the earlier Q_\u03c4 approach\n- The boundary\u2011quadruple certificate Q_\u03c4 (with bridging across arbitrary \u03c4_S) is intuitively sufficient but requires embedding a per\u2011type interior filler to produce node outputs in O(1). The f0\u2011based approach avoids this extra layer and follows the attached paper\u2019s decidable formulation; both are single\u2011exponential in \u03b2. We suggest integrating S2\u2011path using f0 for clarity and alignment with the literature.\n\nMini\u2011lemmas to consider adding (short, testable)\n- Tiny\u2011path completion lemma. Any path of length < K := \u2113_pump+4 is solvable or rejectable in constant radius by enumerating all candidates in Ext for its Type. This justifies the small\u2011n fallback in S1\u2011path and S2\u2011path.\n- Orientation\u2011specialized (\u2113_width,\u2113_count,\u2113_pattern) partition. State the oriented\u2011path version (derivable from the paper\u2019s Lemma 22 without re\u2011orienting) with explicit parameters \u2113_width=\u2113_pattern=\u2113_pump and \u2113_count=2\u2113_pump+2.\n\nSanity checks and examples for S2\u2011path\n- Equality LCL (E={(c,c)}, A_0=A_1={c}). Take f0(w)\u2261c^{|w|}. Gw,1 and all Gw1,w2,S mid\u2011blocks are trivially consistent. Classified O(1) (agrees with S1\u2011path acceptance).\n- Proper 2\u2011coloring on oriented paths. f0 cannot satisfy (F1) across Gw,1 (mid\u2011block requires a consistent 2r window under period\u20111), so S2\u2011path rejects; S1\u2011path accepts with f_mid, hence \u0398(log* n).\n\nActionable next steps for output.md\n1) Add S2\u2011path (Stage\u20112 theorem for oriented paths) using the f0 certificate: definitions of Gw,z and Gw1,w2,S, the feasibility conditions (F1)\u2013(F2), the two directions of the equivalence, and the NEXPTIME verification argument.\n2) Insert the oriented\u2011path (\u2113_width,\u2113_count,\u2113_pattern) partition statement with parameters and a short proof sketch (pointing to the paper\u2019s Lemmas 20\u201322, noting global orientation simplifies the orientation step).\n3) Clean up numbering and the lingering Stage\u20111 remark; align Prop. 9\u2019s transition cost to O(\u03b2^4) where referenced.\n4) Optionally add the tiny\u2011path completion lemma to justify the small\u2011n fallback.\n\nWhy this is incremental and auditable\n- All added checks for S2\u2011path reduce to Ext\u2011table membership (finite, precomputable) and pumping lemmas already in output.md; the structure matches the paper\u2019s decidable formulation (Lemma 23). The verifier modifications (table sizes, enumeration scopes, and complexity bounds) remain within 2^{poly(\u03b2)}.\n- The proposed edits are localized: no changes to S1\u2011path content, just removal of an obsolete remark and consistency fixes, plus the new S2\u2011path section with explicit definitions and a proof outline tied to existing lemmas.\n"}, {"prover_id": "02", "progress_md": "Round 0010 \u2014 audits after integrating S1\u2011path; minor fixes, endpoint extraction hygiene, and incremental lemmas for endpoint projections\n\nAudit of output.md (gaps, small bugs, and numbering)\n- Numbering consistency. There are now four \u201cProposition 6/6A/6B/7\u201d base rules: 6 (k=1\u21922), 6A (k_flag=1 append), 6B (k=2\u21923), 7 (k=3\u21924). This is fine logically but confusing; consider renumbering or grouping the three base updates together (k=1\u21922, 2\u21923, 3\u21924) and listing the k_flag=1 append normalization as a lemma.\n- Proposition 9 complexity text still says O(\u03b2^5) per long append, while a later correction notes O(\u03b2^4) via Proposition 19. Please reconcile in the body of Prop. 9 (replace O(\u03b2^5) with O(\u03b2^4) for k_flag\u22654) so the main statement matches the correction.\n- S1\u2011path (\u21d2) endpoint extraction: the proof says \u201crun A on w_{\u03c4_end} \u00b7 S(s) \u00b7 w_{\u03c4_b} with padding beyond distance R on both sides\u201d. Here \u03c4_end ranges over T (short and long), but w_\u03c4 is only defined for \u03c4\u2208T_long in the pumping construction. Also, for an endpoint there is no left padding beyond the path boundary. This is easily fixed by: (i) replacing w_{\u03c4_end} with \u201can arbitrary path P_end realizing Type \u03c4_end\u201d (short allowed), and (ii) only padding on the right by choosing w_{\u03c4_b} long enough so the R\u2011neighborhood around S is contained in w_{\u03c4_b} on its right side; on the left side the endpoint may lie inside the halo, which is intended. The extraction remains valid and captures the true endpoint behavior.\n- Minor duplication: Lemma 2 (k_flag\u22654 concatenation) is subsumed by Lemma 11 (all k_flags). A note that Lemma 11 subsumes Lemma 2 would avoid potential confusion.\n\nEndpoint mechanics \u2014 incremental, checkable additions\n1) Fast incremental updates for endpoint projections under append (k_flag\u22654)\n- Statement. For \u03c4 with k_flag(\u03c4)\u22654 and \u03c4\u2032=\u03c4\u00b7a,\n  \u2022 LeftColors(\u03c4\u2032) = LeftColors(\u03c4).\n  \u2022 RightColors(\u03c4\u2032) = { y \u2208 A_a : \u2203 x1,x2,x3 with Left3_\u03c4[x1,x2,x3]=true and E(x3,y) }.\n- Why useful. Lets the verifier update V_left/V_right incrementally during \u03b4\u2011BFS using the already\u2011precomputed Left3_\u03c4, avoiding recomputing projections from scratch (O(\u03b2^3) instead of scanning all \u03b2^4 quadruples).\n- Proof sketch. LeftColors projects the first coordinate, which is unaffected by appending a new node at the right. RightColors of \u03c4\u2032 consists of those y that can appear as new R1; by Lemma 1, (x1,x2,x3,y)\u2208Ext_{\u03c4\u2032} iff Left3_\u03c4[x1,x2,x3] and E(x3,y) and y\u2208A_a.\n\n2) Endpoint allow sets as E\u2011neighborhoods (explicit identities)\n- Identities. L_allow(\u03c4) := {\u03b1 : V_left[\u03c4][\u03b1]} = N_E(RightColors(\u03c4)), and R_allow(\u03c4) := {\u03b1 : V_right[\u03b1][\u03c4]} = N_E^{-1}(LeftColors(\u03c4)).\n- Why useful. Makes explicit that V_left/V_right are just one\u2011step E\u2011blowups of the endpoint projections; convenient for unit tests and caching.\n- Proof. By the definitions of V_left/V_right and LeftColors/RightColors.\n\n3) Early infeasibility filters for Stage\u20111 verification (constant\u2011time table checks)\n- Filter F1 (interior Out\u2011sets nonempty). If there exist \u03c4_b,s with OutR2(\u03c4_b,s)=\u2205 or \u03c4_c,s with OutL1(\u03c4_c,s)=\u2205, then no feasible f_mid can exist \u2014 reject.\n- Filter F2 (endpoint alignment reachability). For any \u03c4_end,\u03c4_b,s, if L_allow(\u03c4_end)=\u2205 or OutR2(\u03c4_b,s)=\u2205, then any g_L(\u03c4_end,s,\u03c4_b) is impossible. Symmetric for g_R.\n- Why useful. Fast rejections before scanning W_{b\u2299c} matrices; reduces witness search space.\n- Justification. Trivial from definitions of Out\u2011sets and V_left/V_right.\n\n4) Endpoint extraction hygiene for S1\u2011path (\u21d2) \u2014 revised, auditable phrasing\n- Current line: \u201crun A on w_{\u03c4_end} \u00b7 S(s) \u00b7 w_{\u03c4_b} \u2026 with padding on both sides.\u201d\n- Revised statement (suggested edit). For each (\u03c4_end\u2208T, s, \u03c4_b\u2208T_long): pick any finite path P_end with Type(P_end)=\u03c4_end; pick w_{\u03c4_b} long (as in the f_mid construction) so that the radius\u2011R halo of S lies entirely inside w_{\u03c4_b} on the right. Run A on the finite path P := P_end \u00b7 S(s) \u00b7 w_{\u03c4_b} (no left padding beyond the endpoint). Define g_L(\u03c4_end,s,\u03c4_b) as the output on S. Local correctness implies (i) node/edge legality. Since the seam edge from P_end into S is respected, V_left[\u03c4_end][\u03b21] holds (ii). Because the right context is of Type \u03c4_b and the halo on that side is entirely inside w_{\u03c4_b}, the second output belongs to OutR2(\u03c4_b,s) (iii). Symmetric for g_R.\n- Why this matters. It removes reliance on w_{\u03c4_end} (undefined if \u03c4_end is short) and avoids padding past the endpoint.\n\nConcrete, testable lemmas to consider adding\n- Lemma E3 (Bridging equivalence, restated as set inclusion). For \u03c4_b,\u03c4_c and inputs s1,s2, define the seam\u2011reachable pair set\n  R\u0302_{b\u2299c}(s1,s2) := { (\u03b1_L,\u03b1_R) : W_{b\u2299c}[\u03b1_L][\u03b1_R]=true }.\n  Then feasibility of f_mid is equivalent to the pairwise inclusions\n  OutR2(\u03c4_b,s1) \u00d7 OutL1(\u03c4_c,s2) \u2286 R\u0302_{b\u2299c}(s1,s2) for all \u03c4_b,\u03c4_c,s1,s2.\n  Proof: Unpack Lemma 20 and Prop. 21.\n- Lemma E4 (Endpoint\u2013interior block fill, explicit construction). Given g_L(\u03c4_end,s,\u03c4_b)=(\u03b21,\u03b22) satisfying (i)\u2013(iii) and an interior separator S2 with color pair (\u03b11,\u03b12)=f_mid(\u03c4_c,s2,\u03c4_d), the intervening block between the endpoint separator and S2 admits a completion. Construction: pick (o1,o2,o3,o4) from Ext_{\u03c4_b\u2299\u03c4_c} witnessing W_{b\u2299c}[\u03b22][\u03b11], then fill by Ext_{\u03c4_b\u2299\u03c4_c}; correctness follows from Lemma E2.\n\nSmall example to document the need for endpoint alignment (suggested to add as a remark)\n- Let \u03a3_out={a,b}, A_0=A_1=\u03a3_out, E={(a,a),(b,b)}. Suppose f_mid always outputs (b,b), thus OutR2={b}. Take \u03c4_end with RightColors(\u03c4_end)={a}. If one chose g_L(\u03c4_end,s,\u03c4_b)=(a,a) based only on V_left (true) but ignored alignment (\u03b22\u2208OutR2), the adjacent interior block would require W_{b\u2299c}[a][\u00b7], which can be false, and the construction would fail. The alignment clause (iii) prevents this.\n\nImplementation notes (verifier/solver side)\n- Precompute Left3_\u03c4 during \u03b4\u2011BFS and use the identities in item 1) to maintain RightColors(\u00b7), LeftColors(\u00b7), thus V_left/V_right, in O(\u03b2^3) per long append.\n- For endpoint maps, precompute bit\u2011sets L_allow(\u03c4) and R_allow(\u03c4) once; checking g_L/g_R then reduces to:\n  \u2022 membership in A_{s[i]} and E on the 2\u2011node window (constant time),\n  \u2022 \u03b21 \u2208 L_allow(\u03c4_end) or \u03b22 \u2208 R_allow(\u03c4_end),\n  \u2022 \u03b22 \u2208 OutR2(\u03c4_b,s) or \u03b21 \u2208 OutL1(\u03c4_c,s).\n- Speed hint: during f_mid verification, build per\u2011pair masks M_{b\u2299c}(s1,s2) := {\u03b1_L}\u00d7{\u03b1_R} for \u03b1_L\u2208OutR2(\u03c4_b,s1), \u03b1_R\u2208OutL1(\u03c4_c,s2), and check that M_{b\u2299c}(s1,s2) \u2286 R\u0302_{b\u2299c}(s1,s2); if not, report the first violating pair, making counterexamples easy to extract.\n\nNext steps toward full trichotomy (O(1) vs \u0398(log* n) vs \u0398(n))\n- Stage\u20112 on oriented paths. Bring in a path\u2011specialized version of the (\u2113_width,\u2113_count,\u2113_pattern)\u2011partition (paper\u2019s Lemma 22) with explicit constants compatible with \u2113_pump; then formalize the per\u2011type tiling witness Q_\u03c4 and the constant\u2011round construction. The checks already sketched in earlier rounds (tiling within \u03c4, universal bridging across \u03c4_S via Ext) should carry over verbatim with our Ext/W machinery.\n- MIS on K\u2011th power (for completeness). Add a brief lemma that on globally oriented paths one can compute an MIS of the K\u2011th power in O(log* n), and that consecutive MIS nodes are at distance in [K,2K]; cite folklore or include a 3\u2011line proof via Cole\u2013Vishkin coloring and greedy thinning. This makes the spacing claim in S1\u2011path fully self\u2011contained.\n- Regression tests. Extend the harness to check:\n  \u2022 Incremental RightColors/LeftColors updates vs direct projection of Ext after append.\n  \u2022 S1 verification equivalence in Lemma E3 form (set inclusion) using precomputed R\u0302_{b\u2299c}.\n  \u2022 Endpoint misalignment: synthesize instances violating (iii) and confirm rejection.\n  \u2022 Prop. 9 runtime constants: confirm O(\u03b2^4) append for k_flag\u22654 against O(\u03b2^5) brute force on \u03b2\u2208{2,3}.\n\nWhy these are incremental and auditable\n- Each lemma is a one\u2011line identity following mechanically from already\u2011defined objects (Ext and its slices). They admit direct unit tests on small \u03b2.\n- The endpoint extraction hygiene is a textual correction with unchanged logic; it prevents an uninstantiated symbol (w_{\u03c4_end}) and avoids padding past the endpoint while preserving the argument.\n- The feasibility filters F1/F2 are immediate consequences of definitions, implementable as constant\u2011time table emptiness checks.\n\nOpen items (to track)\n- Decide whether to keep both Lemma 2 and Lemma 11; if both retained, add an explicit \u201cLemma 11 subsumes Lemma 2\u201d note.\n- Normalize base\u2011case numbering to avoid 6/6A/6B confusion.\n- Integrate the MIS\u2011on\u2011Kth\u2011power statement and the Stage\u20112 partition lemma specialized to oriented paths to complete the constant\u2011time classification.\n"}]

Current notes.md:
Corrections and key lemmas to record

1) Correct append-one-bit recurrence (r=1)
Given a type t with Ext_t ⊆ Σ_out^4 over boundary (L1,L2,R2,R1) and an appended input bit a, the new type t′ has boundary (L1′,L2′,R2′,R1′) = (L1,L2, old R1, new), i.e., R2′ = R1 and R1′ is the label of the appended node. Formally, for each candidate quadruple (x1,x2,x3,x4) ∈ Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [x4 ∈ A_a and E(x3,x4) and ∃ z ∈ Σ_out: (x1,x2,z,x3) ∈ Ext_t].
This yields an O(β^5) DP to fill Ext_{t′} by scanning all (x1,x2,x3,x4) and checking ∃z.

Congruence lemma (needed): If Type(P)=Type(Q), then for all a ∈ {0,1}, Type(Pa)=Type(Qa). Proof sketch: The predicate “there exists an interior completion consistent with boundary assignments” over D1∪D2 is preserved under appending one node by the above DP rule, which depends only on Ext_t and a.

2) Concatenation of summaries (r=1)
If Summ(P) has Ext_P and Summ(Q) has Ext_Q, then the concatenation B=P·Q has boundary (P.left endpoint, P.left neighbor, Q.right neighbor, Q.right endpoint) and
  (o1,o2,o3′,o4′) ∈ Ext_B ⇔ ∃ x3,x4,x1′,x2′ ∈ Σ_out: (o1,o2,x3,x4) ∈ Ext_P, (x1′,x2′,o3′,o4′) ∈ Ext_Q, and E(x4,x1′).
Then R_B can be derived from Ext_B as usual.

3) Counterexample to R-composition via ∃m
Let Σ_out={a,b,c}, A_0=A_1=Σ_out. Let E={a→b, b→c} only. Suppose t_b admits a boundary tuple with right endpoint a, and t_c admits a boundary tuple with left endpoint c (interiors arbitrary but extendible). Then choose m=b. We have (x,m) ∈ R_{t_b} for any x with a valid left edge, and (m,y) ∈ R_{t_c} for suitable y. But the concatenation t_b·t_c requires the seam edge a→c, which is forbidden. Hence ∃m composition of R_t is not sound; use Ext-level concatenation and R_B instead.
Additions and fixes (r=1)

A) Correct k=2→3 base-case update
Let t=(b1,b2) and t′=t·a (length 3). Then
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [x3=x2, x1∈A_{b1}, x2∈A_{b2}, x4∈A_a, E(x1,x2), E(x2,x4)].
This replaces any prior statement that involved x2∈A_a.

B) Type representation and congruence
Define Type(t) := (b_in(t), Ext_t, k_flag(t)), where k_flag ∈ {1,2,3,≥4} indicates whether boundary coordinates coincide due to short length. Then the congruence lemma holds in the form:
  If Type(P)=Type(Q), then for all a∈{0,1}, Type(Pa)=Type(Qa).
Proof: case split on k_flag using the explicit base-case rules for k_flag∈{1,2,3} and the general append recurrence for k_flag=≥4.
Remark: Ext equality alone does not determine |t| (e.g., with E self-loops and A_0=A_1, Ext_{len 2} = Ext_{len 4}). Hence the k_flag is necessary for a length-agnostic update routine.

C) Enumeration fix
In the BFS over types, key the dictionary by the full Type(t), including k_flag. After the first transition to k_flag=≥4, all descendants remain in k_flag=≥4 and subsequent δ updates are length-agnostic.
Additions: Stage-1 and Stage-2 specifications at the Ext level (r=1, oriented paths)

Notation. Σ_out has size β. For an input word t with bits b_in(t) ∈ {0,1}^{|t|}, let Ext_t ⊆ Σ_out^4 denote the set of boundary quadruples (L1,L2,R2,R1) = (o[1],o[2],o[|t|-1],o[|t|]) that admit an interior completion o consistent with node constraints o[i]∈A_{b_in(t)[i]} and edge constraints (o[i],o[i+1])∈E. Types are Type(t)=(Ext_t, k_flag(t)), where k_flag∈{1,2,3,≥4} encodes short-length degeneracies. Concatenation of types τ⊙σ is defined by the Ext-level concatenation rule (see outputs.md) and k_flag update.

Stage-1 (Ω(n) vs o(n)): type-level feasible function
- Universe: the finite set of types T obtained by BFS from k=1 under the append-one-bit updates (keyed by (Ext,k_flag)). For τ,σ∈T, the Ext of τ⊙σ is defined by Ext-level concatenation.
- Definition (feasible f). A function f: T × {0,1}^2 × T → Σ_out^2 mapping (τ_L, s, τ_R) to (α1,α2) is feasible if:
  (i) Node/window constraints: αi ∈ A_{s[i]} for i=1,2 and (α1,α2) ∈ E (i.e., E(α1,α2) holds).
  (ii) Universal extendibility across two separators: for all τ_a,τ_b,τ_c,τ_d∈T and s1,s2∈{0,1}^2, letting α_L := second component of f(τ_a,s1,τ_b) and α_R := first component of f(τ_c,s2,τ_d), we require
      ∃ (o1,o2,o3,o4) ∈ Ext_{τ_b ⊙ τ_c} with E(α_L,o1) and E(o4,α_R).
  Comment: The quantification over τ_a and τ_d is stronger than necessary but safe; a weaker version quantifies only over τ_b,τ_c and s1,s2. Indexing uses our convention (L1,L2,R2,R1); thus o1 and o4 are the first and last outputs of the middle block of type τ_b⊙τ_c.
- NEXPTIME check: deterministically enumerate T and all Ext_{τ} and on-demand Ext_{τ⊙σ}; nondeterministically guess f; verify (i) and (ii) exhaustively. Complexity is 2^{poly(N)} in the problem description size N.
- Status: We still owe a self-contained proof that “o(n) algorithm exists iff a feasible f exists” at the Ext level (the intended replacement of the paper’s feasible-function lemma). This will rely only on our Ext-append and Ext-concat lemmas and a standard pumping argument specialized to r=1.

Stage-2 (O(1) vs Ω(log* n)): per-type boundary-interface witness
- For each τ∈T with k_flag(τ)≥4, guess Q_τ=(L1_τ,L2_τ,R2_τ,R1_τ) with Q_τ ∈ Ext_τ. Enforce:
  (a) Local consistency and tiling: E(L1_τ,L2_τ), E(R2_τ,R1_τ), and wrap E(R1_τ,L1_τ). Intuition: long blocks of type τ can be tiled by copies using the same boundary outputs.
  (b) Bridging across any middle type (including empty): for all τ_left,τ_S,τ_right ∈ T, require either
      - if τ_S has k_flag≥1: ∃ (o1,o2,o3,o4) ∈ Ext_{τ_S} with E(R1_{τ_left},o1) and E(o4,L1_{τ_right}); or
      - if τ_S is empty: E(R1_{τ_left},L1_{τ_right}).
- Decision logic: if witnesses {Q_τ} exist and pass (a)–(b), classify O(1). Else, if a Stage-1 feasible f exists, classify Θ(log* n). Otherwise, classify Θ(n).
- Status: We still owe a concrete constant-radius construction on oriented paths from {Q_τ} (e.g., a partition/tiling routine parametrized by fixed radii ℓ_width, ℓ_pattern, ℓ_count) and a proof that the produced labeling is legal. Short types (k_flag<4) are treated as separators τ_S in (b).

Faster concatenation (proven and moved to outputs.md)
- Precompute for each τ the 3D slices: Left_τ[o1,o2,x4] := ∃x3 (o1,o2,x3,x4)∈Ext_τ, and Right_τ[x1′,o3′,o4′] := ∃x2′ (x1′,x2′,o3′,o4′)∈Ext_τ.
- Then (o1,o2,o3′,o4′)∈Ext_{τ⊙σ} iff ∃x4,x1′: Left_τ[o1,o2,x4] ∧ E(x4,x1′) ∧ Right_σ[x1′,o3′,o4′]. This allows computing Ext_{τ⊙σ} in O(β^6) time after O(β^4) precomputation per type.

Sanity checks (kept as examples)
- Trivial LCL (A_0=A_1=Σ_out, E complete): Ext_τ=Σ_out^4 for all τ; Stage-2 witness exists trivially ⇒ O(1).
- Equality LCL (E={(x,x)}): take Q_τ=(c,c,c,c) ⇒ O(1).
- Proper 2-coloring: Stage-2 fails; Stage-1 feasible f should exist ⇒ Θ(log* n).
- Linear cases with incompatible seams: Stage-1 fails ⇒ Ω(n).
Updates and clarifications (r=1, oriented paths)

1) Base-case updates finalized
- k=1→2 is special and cannot be derived from the general append recurrence without over-constraining x1=x2; we record an explicit rule in outputs.md.
- k=3→4 is also added explicitly (although it follows from the same recurrence if stated for k≥2). This ensures δ can move from short types to k_flag≥4 deterministically.

2) Type-count bound corrected
Type(t) consists of (Ext_t, k_flag(t)) only; boundary input bits are not part of Type. Hence the number of types satisfies
  |T| ≤ 4 · 2^{β^4}.
The earlier 16 · 2^{β^4} bound mixed in boundary input bits unnecessarily.

3) δ well-defined and BFS enumeration
- Seeds: k=1 types for b∈{0,1} (Ext_{(b)} = {(x,x,x,x): x∈A_b}).
- Transitions: use base-cases for k<4 (1→2, 2→3, 3→4) and Lemma 1 for k≥4. By congruence, δ(Type, a) depends only on (Ext, k_flag) and a.
- Termination and complexity: at most |T| ≤ 4·2^{β^4} insertions; each append is O(β^5) in the k≥4 regime (base-cases are ≤ O(β^4)); total time/space 2^{poly(β)}.

4) Reversal operator (optional but helpful)
Define Rev(τ) = (Ext_τ^R, k_flag(τ)) with Ext_τ^R := { (y1,y2,y3,y4) : (y4,y3,y2,y1) ∈ Ext_τ }. Then Rev(Rev(τ))=τ and Ext_{Rev(τ) ⊙ Rev(σ)} = (Ext_{σ ⊙ τ})^R.

5) Stage-1 and Stage-2 (status)
- Stage-1 (Ω(n) vs o(n)): the feasible function f: T × {0,1}^2 × T → Σ_out^2 with the universal Ext-based check (seams E(α_L, o1), E(o4, α_R), using the (L1,L2,R2,R1) ordering) is the right formal object. We still need a fully self-contained proof of the equivalence “o(n) iff such f exists”.
- Stage-2 (O(1) vs Ω(log* n)): the per-type witness Q_τ∈Ext_τ for k_flag≥4 with tiling and universal bridging checks is plausible. A complete constant-radius construction on oriented paths remains to be written and verified.

6) Sanity and regression items
- β=2 trivial LCLs and equality LCL check the base-cases and concatenation routines.
- Reconfirm the 3-color counterexample for R-composition via ∃m.
- Maintain an indexing reminder: Ext quadruples are ordered (L1,L2,R2,R1); in seam checks across a middle block of type τ_b⊙τ_c, the left seam meets o1 and the right seam meets o4.
New additions (r=1, oriented paths): pumping, general concatenation, and Stage-1 equivalence

- Pumping bound and lemmas. Let T be the set of reachable types (Proposition 9) and δ: T×{0,1}→T the append transition. Define
  ℓ_pump := |T|.
  Lemma (prefix pumping). For any input w with |w| ≥ ℓ_pump there exist x,y,z with 1 ≤ |y| ≤ ℓ_pump and |xy| ≤ ℓ_pump such that Type(x y^i z) is independent of i ≥ 0.
  Lemma (periodic pumping). For any nonempty u there exist a,b with a+b ≤ ℓ_pump such that Type(u^{a+bi}) is invariant for all i ≥ 0.
  Both follow from the pigeonhole principle applied to the δ-run over Types.

- Ext-level concatenation for all k_flags and associativity. The general concatenation rule (Ext_{P·Q} witnessed by Ext_P and Ext_Q with a seam constraint E(x4,x1′)) holds verbatim for all lengths because Ext for short words already lives in Σ_out^4 with coordinate equalities enforced by k_flag. Associativity of Ext-concatenation follows semantically (concatenation of words is associative) or by rebracketing seam witnesses.

- Stage-1 (Ω(n) vs o(n)). Restrict left/right context Types to T_long := {τ∈T : k_flag(τ)≥4}. Define a feasible f: T_long×{0,1}^2×T_long→Σ_out^2 that (i) satisfies node/edge constraints on the 2-node separator and (ii) for all τ_b,τ_c∈T_long and s1,s2, and for all τ_a,τ_d∈T_long (affecting only α_L,α_R), there exists (o1,o2,o3,o4)∈Ext_{τ_b⊙τ_c} with E(α_L,o1) and E(o4,α_R), where α_L is the second output of f(τ_a,s1,τ_b) and α_R is the first output of f(τ_c,s2,τ_d). Theorem (added to output.md): an r=1, oriented-path LCL has deterministic complexity o(n) iff such a feasible f exists. Proof outline recorded in output.md: (⇒) extract f from an o(n) algorithm via pumping and a cycle-gadget; (⇐) place separators by an MIS on the K-th power of the path with K≳ℓ_pump and solve each O(K)-long block locally using the guaranteed Ext-witness; total time O(log* n).

- Stage-2 (O(1) vs Θ(log* n)). The per-type interface Q_τ∈Ext_τ (for τ∈T_long) with tiling and universal bridging checks remains a plausible certificate. However, the constant-radius partition of an arbitrary input path into “long periodic” and “short/irregular” subpaths is not yet proven in this writeup. Do not claim S2 in output.md until a self-contained partition lemma (parameters and proof) is supplied or the construction is reworked to avoid this dependency.

- Minor lemma. Nonemptiness monotonicity under concatenation: if Ext_P and Ext_Q are nonempty and there exists at least one seam pair (x4,x1′) with E(x4,x1′), then Ext_{P·Q}≠∅. This is an immediate corollary of the general concatenation rule.

Implementation notes

- Quantify over T_long for left/right contexts in Stage-1; middle types in Stage-2 can be arbitrary (short included), handled by the general concatenation lemma.
- Precompute T by BFS (Prop. 9), split T_long vs short, cache Left_τ and Right_τ for all τ, and build Ext_{τ⊙σ} for τ,σ∈T_long (Prop. 5). ℓ_pump=|T| is computable in 2^{poly(β)}.
- Separator placement for Stage-1: in O(log* n), compute an MIS on the K-th power of the directed path for K=ℓ_pump+4; distances between consecutive separators are ≤2K, ensuring each middle block is O(K)-long and solvable in O(1) rounds by exhaustive local choice of an Ext-witness–consistent interior labeling.

Open item for Stage-2

- Provide a self-contained constant-radius partition lemma on oriented paths or redesign the Stage-2 constant-round construction to avoid reliance on periodicity. Until then, keep S2 as a notes-only plan.
Endpoint handling in Stage-1 (r=1) and refinements

- Endpoint gap (to-do). The current Stage-1 (⇐) algorithm partitions the path using a K-th power MIS with K := ℓ_pump+4 and then fills each middle block between two separators using a feasible function f. This leaves one-sided end segments (from a path endpoint to the nearest separator). The proof sketch in output.md did not treat these explicitly and incorrectly asserted that every separator has long-type contexts on both sides. A separate lemma is needed to guarantee that the seam color chosen at an endpoint-adjacent separator is compatible with the end segment’s Ext set. Alternatively, redesign the partition so that every nontrivial block lies strictly between two separators, eliminating one-sided cases. Until one of these is proven, the o(n)⇔feasible-f equivalence remains open here.

- Clean k=1→2 update (no “recover b”). For a type τ with k_flag(τ)=1, let S_τ := { x ∈ Σ_out : (x,x,x,x) ∈ Ext_τ }. Then appending a bit a yields Ext_{τ·a} consisting exactly of tuples (x1,x2,x3,x4) with x1=x3, x2=x4, x1∈S_τ, x2∈A_a, and E(x1,x2). This removes the need to speak about an internal bit b and works also when A_0=A_1.

- Optimized append in O(β^4). For k_flag≥4, define Left3_t[x1,x2,x3]:=∃z (x1,x2,z,x3)∈Ext_t. Then (x1,x2,x3,x4)∈Ext_{t·a} iff Left3_t[x1,x2,x3] ∧ E(x3,x4) ∧ x4∈A_a. Precompute Left3_t in O(β^4) time and fill Ext_{t·a} in O(β^4) time (dense worst-case).

- Out-set formulation of feasibility. Given a guessed f: T_long×{0,1}^2×T_long→Σ_out^2, define
  OutR2(τ_b,s) := { second(f(τ_a,s,τ_b)) : τ_a ∈ T_long },
  OutL1(τ_c,s) := { first(f(τ_c,s,τ_d)) : τ_d ∈ T_long }.
The universal extendibility clause is equivalent to: for all τ_b,τ_c,s1,s2 and α_L∈OutR2(τ_b,s1), α_R∈OutL1(τ_c,s2), ∃(o1,o2,o3,o4)∈Ext_{τ_b⊙τ_c} with E(α_L,o1) and E(o4,α_R). This isolates the relevant seam colors and simplifies verification.

- Seam-feasibility matrices. For faster verification and construction, precompute for each pair (τ_b,τ_c) the β×β boolean matrix W_{b⊙c}[α_L][α_R] that records whether there exists (o1,o2,o3,o4) ∈ Ext_{τ_b⊙τ_c} with E(α_L,o1) and E(o4,α_R). Then the universal extendibility checks reduce to table lookups W_{b⊙c}[α_L][α_R].

- Regression checklist.
  1) Verify optimized append equals brute-force append on random small Σ_out (β≤3).
  2) Verify associativity of Ext-concatenation on random triples of types.
  3) Verify W_{b⊙c} by direct Ext scans.
  4) Sanity: equality LCL and proper 2-coloring behave as expected.
Endpoint seam projections and matrices (r=1, oriented paths)

- For any type τ, define:
  RightColors(τ) := { y ∈ Σ_out : ∃ x1,x2,x3 with (x1,x2,x3,y) ∈ Ext_τ }.
  LeftColors(τ)  := { x ∈ Σ_out : ∃ x2,x3,y with (x,x2,x3,y) ∈ Ext_τ }.
  These are just the projections of Ext_τ to coordinates R1 and L1.

- Define endpoint seam-compatibility matrices from Ext alone:
  V_left[τ][α]  := (∃ y ∈ RightColors(τ) with E(y, α)).
  V_right[α][τ] := (∃ x ∈ LeftColors(τ) with E(α, x)).

Lemma E1 (endpoint feasibility via Ext). Fix any type τ and α ∈ Σ_out.
- There exists a legal labeling of a left end-block of type τ and the adjacent separator’s first node α iff V_left[τ][α] is true.
- There exists a legal labeling of a right end-block of type τ and the adjacent separator’s second node α iff V_right[α][τ] is true.
Proof. If (x1,x2,x3,y)∈Ext_τ and E(y,α), then the end-block interior is witnessed by Ext_τ and the seam edge by E(y,α). Conversely, any legal instance provides such y. The right case is symmetric.

Endpoint gap in Stage-1 (diagnosis and fix). Our current Stage-1 construction labels interior separators using a feasible f and fills the block between them via Ext_{τ_b ⊙ τ_c} using W_{b⊙c}. For paths, the first/last interior block is bounded on one side by an endpoint-adjacent separator. If that separator is colored by an independent g_L/g_R, the right (resp. left) seam color entering the first (resp. last) interior block may lie outside the OutR2/OutL1 sets induced by f. Then the pre-verified W_{b⊙c} guarantees do not apply, and the fill of that block can fail, even if V_left/V_right holds. Hence additional coupling is required.

Corrected Stage-1 certificate for paths (proposal). Keep T_long and f as in the Out-set formulation. Replace the 2-argument endpoint maps by 3-argument ones that are aligned with the Out-sets of the adjacent long type:
- g_L: T × {0,1}^2 × T_long → Σ_out^2. For g_L(τ_end, s, τ_b)=(β1,β2) require:
  (i) node/window legality at the separator: βi ∈ A_{s[i]} and E(β1,β2);
  (ii) one-sided feasibility toward the endpoint: V_left[τ_end][β1]=true;
  (iii) alignment with interior Out-set: β2 ∈ OutR2(τ_b, s).
- g_R: T_long × {0,1}^2 × T → Σ_out^2. For g_R(τ_c, s, τ_end)=(β1,β2) require:
  (i) node/window legality and E(β1,β2);
  (ii) one-sided feasibility toward the endpoint: V_right[β2][τ_end]=true;
  (iii) alignment with interior Out-set: β1 ∈ OutL1(τ_c, s).

With these constraints, the MIS-based O(log* n) construction proceeds as before:
- Label every interior separator by f; label the endpoint-adjacent separators using g_L/g_R (using the computed adjacent long types τ_b, τ_c on their interior sides). Fill end-blocks using Lemma E1.
- For the blocks between an endpoint-adjacent separator and its nearest interior separator, use the same W_{b⊙c} check as for interior blocks, with α_L := second(g_L(…)) or α_R := first(g_R(…)). By (iii), α_L ∈ OutR2(τ_b,·) and α_R ∈ OutL1(τ_c,·), so the precomputed W_{b⊙c} guarantees existence of a witness in Ext_{τ_b ⊙ τ_c}.

Necessity (⇒) sketch under the corrected certificate. Given an o(n)-round algorithm A:
- Extract f from A as in the cycle case (pumping + concatenation).
- For each (τ_end, s, τ_b), build a path consisting of a long pumped block of type τ_b to the right, the separator with input s, and an endpoint block of type τ_end on the left (plus pumped padding as needed outside the radius of A). Let g_L(τ_end,s,τ_b) be A’s output on the separator. Pumping ensures well-definedness and (iii). The V_left constraint follows because the seam into the endpoint segment is satisfied by A. Symmetrically define g_R.

Verification remains in 2^{poly(β)}: T, T_long, Ext, W_{b⊙c}, V_left, V_right, OutR2/OutL1 are all precomputable. The guessed tables f, g_L, g_R are checked entrywise.

Action items.
- Integrate Lemma E1 and the V_left/V_right definitions into outputs.
- Replace the current endpoint witness proposal by the 3-argument version and update both directions of the Stage-1 path theorem accordingly.
- Keep Stage-2 items in notes until a self-contained partition lemma for oriented paths is written.
Endpoint‑coupled Stage‑1 for oriented paths: resolution and integration

- Gap recap. Our earlier Stage‑1 (o(n) vs Ω(n)) write‑up did not handle the endpoint‑adjacent separators. Labeling endpoints independently (even with V_left/V_right checks) can misalign the “open” seam color toward the interior with the Out‑sets induced by the interior feasible function f, causing the first/last interior block to be unfillable.

- Fix (now integrated into output.md). We strengthen the certificate by adding 3‑argument endpoint maps coupled to Out‑sets:
  • g_L(τ_end, s, τ_b) = (β1,β2) with: (i) node/window legality; (ii) V_left[τ_end][β1]; (iii) β2 ∈ OutR2(τ_b,s).
  • g_R(τ_c, s, τ_end) = (β1,β2) with: (i) node/window legality; (ii) V_right[β2][τ_end]; (iii) β1 ∈ OutL1(τ_c,s).
  With these, the interior block between an endpoint‑adjacent separator and the nearest interior separator is covered by the same W_{b⊙c} universal checks as for interior blocks. We added an explicit Endpoint–interior bridging lemma to make this step transparent.

- Theorem S1‑path (added). For β‑normalized r=1 LCLs on globally oriented paths, an o(n)‑round deterministic algorithm exists iff there are witnesses (f_mid, g_L, g_R) satisfying the above constraints. Proof: (⇒) extract f_mid and g_L/g_R from an o(n) algorithm using pumped canonical contexts and padding outside the runtime halo; (⇐) place separators by MIS on the K‑th power (K = ℓ_pump+4), color interior separators via f_mid and endpoint‑adjacent ones via g_L/g_R, and complete all blocks by table lookups in W and V. Verification is NEXPTIME (single‑exponential) via precomputed tables.

- Complexity tightening (recorded). Using Proposition 19 (O(β^4) append for k_flag ≥ 4), the BFS enumeration in Proposition 9 uses O(β^4) per transition in the long regime.

- Minimal obstruction template (for tests). Fix τ_b with OutR2(τ_b,s) = {α}. If an uncoupled g_L outputs β2 ≠ α while V_left holds, the first interior block can fail because W_{b⊙c}[β2][·] may be all false; coupling (iii) prevents this.

- Bookkeeping. Lemma 11 subsumes Lemma 2 (general vs k_flag≥4 concatenation). There are duplicated labels around Proposition 6/6A/6B; renumbering is recommended in a clean pass.


Current output.md (if any):
Setup and definitions (r=1, globally oriented paths)
- Let Σ_out be a finite output alphabet of size β. Let A_0,A_1 ⊆ Σ_out be the allowed outputs at nodes with input bit 0 or 1, respectively. Let E ⊆ Σ_out × Σ_out be the allowed directed edge relation (u→v allowed iff (u,v)∈E). For an input word t ∈ {0,1}^k with k≥1, a labeling o ∈ Σ_out^k is legal if o[i]∈A_{t[i]} for all i, and (o[i],o[i+1])∈E for all 1≤i<k.
- For k≥4, define Ext_t ⊆ Σ_out^4 as the set of boundary quadruples (L1,L2,R2,R1) that extend to a legal labeling o with L1=o[1], L2=o[2], R2=o[k−1], R1=o[k]. For k≤3, Ext_t is defined with the same 4-tuple container but with the obvious coordinate equalities imposed by overlaps (tracked by k_flag ∈ {1,2,3,≥4}). The Type of t is Type(t) := (Ext_t, k_flag(t)).

Lemma 1 (Append-one-bit recurrence; k_flag≥4 case).
Let t be an input word with k_flag(t)≥4, and let t′ := t·a be t with one bit a ∈ {0,1} appended on the right. Then for all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x4 ∈ A_a and E(x3,x4) and ∃z∈Σ_out: (x1,x2,z,x3) ∈ Ext_t ].
Proof. Standard restriction/extension argument on legal labelings. □

Proposition 6 (Base-case update; k=1→2).
Let t=(b) be a length-1 input and t′:=t·a the length-2 input obtained by appending a∈{0,1}. For all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x1 = x3, x2 = x4, x1 ∈ A_b, x2 ∈ A_a, and E(x1,x2) ].
Proof. Immediate from the definition. □

Proposition 7 (Base-case update; k=3→4).
Let t=(b1,b2,b3) be a length-3 input and t′:=t·a the length-4 input obtained by appending a∈{0,1}. For all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x1∈A_{b1}, x2∈A_{b2}, x3∈A_{b3}, x4∈A_a, and E(x1,x2), E(x2,x3), E(x3,x4) ].
Proof. Unfold the definition on the 4-node path. □

Lemma 2 (Ext-level concatenation; k_flag≥4).
Let P and Q be input words with k_flag(P), k_flag(Q) ≥4, and let B := P·Q. Then for all (o1,o2,o3′,o4′)∈Σ_out^4,
  (o1,o2,o3′,o4′) ∈ Ext_B ⇔ ∃ x3,x4,x1′,x2′ ∈ Σ_out such that
    (o1,o2,x3,x4) ∈ Ext_P, (x1′,x2′,o3′,o4′) ∈ Ext_Q, and E(x4,x1′).
Proof. Combine witnesses across the seam, or restrict a legal labeling of B. □

Proposition 3 (Type congruence under appending one bit).
If Type(P)=Type(Q), then for all a∈{0,1}, Type(P·a)=Type(Q·a). In particular, Ext_{P·a}=Ext_{Q·a} and k_flag updates identically.
Proof. For k_flag≥4, Lemma 1 shows Ext_{(·)·a} depends only on Ext_{(·)} and a. Short cases follow by the explicit base-case rules. □

Proposition 4 (Unsoundness of existential R-composition).
There exists an instance (Σ_out,A_0,A_1,E) and types t_b,t_c such that there is m∈Σ_out with (x,m) ∈ R_{t_b} and (m,y) ∈ R_{t_c} for some x,y, yet (x,y) ∉ R_{t_b·t_c}. Hence the rule “(∃m) R_{P·Q}(x,y) ⇐ R_P(x,m) ∧ R_Q(m,y)” is not valid in general.
Proof. Use Σ_out={a,b,c}, A_0=A_1=Σ_out, E={(a,b),(b,c)}; choose t_b with rightmost a and t_c with leftmost c; pick m=b. The seam would require E(a,c), which fails. □

Proposition 5 (Optimized computation of Ext for concatenation in O(β^6)).
For any types τ,σ with k_flag(τ),k_flag(σ)≥4, define the 3D slices
  Left_τ[o1,o2,x4] := ∃x3 (o1,o2,x3,x4)∈Ext_τ, and
  Right_σ[x1′,o3′,o4′] := ∃x2′ (x1′,x2′,o3′,o4′)∈Ext_σ.
Then for all (o1,o2,o3′,o4′),
  (o1,o2,o3′,o4′) ∈ Ext_{τ⊙σ} ⇔ ∃x4,x1′: Left_τ[o1,o2,x4] ∧ E(x4,x1′) ∧ Right_σ[x1′,o3′,o4′].
Moreover, after precomputing Left_τ and Right_σ for all τ,σ in O(β^4) time per type, Ext_{τ⊙σ} can be computed in O(β^6) time.
Proof. Eliminate x3,x2′ by definitions; count entries. □

Proposition 6A (k_flag=1 append update without recovering the bit).
Let τ be a type with k_flag(τ)=1 and define S_τ := { x ∈ Σ_out : (x,x,x,x) ∈ Ext_τ }. For a∈{0,1}, let τ′ := δ(τ,a). Then for all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{τ′} ⇔ [ x1=x3, x2=x4, x1∈S_τ, x2∈A_a, and E(x1,x2) ].
Proof. Any legal 2-node labeling has boundary (o1,o2,o1,o2) with o1∈S_τ, o2∈A_a and E(o1,o2). Conversely, any tuple satisfying the listed constraints is realized by a legal labeling on the 2-node input. □

Lemma 8 (Type-count bound).
With Type(t):=(Ext_t, k_flag(t)) and Ext_t⊆Σ_out^4, the number of distinct types obeys |T| ≤ 4 · 2^{β^4}.
Proof. For each k_flag value, Ext can be any subset of Σ_out^4; sum over k_flag. □

Proposition 9 (δ well-defined; deterministic BFS enumeration in 2^{poly(β)} time/space).
Let δ map a type τ and an appended bit a∈{0,1} to the type of the one-bit extension. Define δ by:
- If k_flag(τ)=1, compute Ext of the 2-node type by Proposition 6A using S_τ.
- If k_flag(τ)=2, use the explicit k=2→3 update.
- If k_flag(τ)=3, use Proposition 7.
- If k_flag(τ)≥4, use Lemma 1.
Then δ(τ,a) depends only on τ and a (by Proposition 3). A deterministic BFS that starts from the length-1 seeds (t=(0) and t=(1)), repeatedly applies δ(·,0) and δ(·,1), and interns types by equality of (Ext, k_flag), halts after at most |T| insertions and enumerates all reachable types. Each transition costs O(β^5) in the k_flag≥4 regime (base-cases are ≤O(β^4)). Since |T| ≤ 4·2^{β^4}, the total time and space are 2^{poly(β)}. □

Lemma 10 (Reversal operator; basic properties).
Define, for any type τ=(Ext_τ,k_flag(τ)), the reversed type Rev(τ):=(Ext_τ^R, k_flag(τ)), where Ext_τ^R := { (y1,y2,y3,y4) : (y4,y3,y2,y1) ∈ Ext_τ }. Then Rev(Rev(τ))=τ and, for k_flag≥4, Ext_{Rev(τ) ⊙ Rev(σ)} = (Ext_{σ ⊙ τ})^R.
Proof. Direct from definitions and Lemma 2. □

Definition (Long types and pumping bound).
- T_long := { τ ∈ T : k_flag(τ) ≥ 4 }.
- Define ℓ_pump := |T|, where T is the set of reachable Types enumerated by Proposition 9.

Lemma 11 (Ext-level concatenation; all k_flag).
For any input words P,Q (no restriction on length) and B := P·Q, for all (o1,o2,o3′,o4′) ∈ Σ_out^4,
  (o1,o2,o3′,o4′) ∈ Ext_B ⇔ ∃ x3,x4,x1′,x2′ ∈ Σ_out:
    (o1,o2,x3,x4) ∈ Ext_P, (x1′,x2′,o3′,o4′) ∈ Ext_Q, and E(x4,x1′).
Proof. As in Lemma 2; k_flag imposes only coordinate equalities. □

Proposition 12 (Associativity of Ext-concatenation).
For any input words P,Q,R, Ext_{(P·Q)·R} = Ext_{P·(Q·R)} as subsets of Σ_out^4.
Proof. Either semantically (concatenation of words) or by rebracketing witnesses from Lemma 11. □

Lemma 13 (Prefix pumping).
Let ℓ_pump := |T|. For any input string w with |w| ≥ ℓ_pump there exist a decomposition w = x y z with 1 ≤ |y| ≤ ℓ_pump and |x y| ≤ ℓ_pump such that Type(x y^i z) is independent of i ≥ 0.
Proof. Pigeonhole on the first ℓ_pump+1 states of the δ-run. □

Lemma 14 (Periodic pumping).
For any nonempty string u there exist integers a,b with a+b ≤ ℓ_pump such that Type(u^{a+bi}) is invariant for all i ≥ 0.
Proof. Pigeonhole on the sequence Type(u^j), j≥0, and determinism of δ. □

Definition (Feasible function; Out-set form).
A function f: T_long × {0,1}^2 × T_long → Σ_out^2 is feasible if for every (τ_L, s, τ_R) it outputs (α1,α2) with αi ∈ A_{s[i]} and E(α1,α2), and moreover the following universal extendibility holds: for all τ_b,τ_c∈T_long and s1,s2 ∈ {0,1}^2, and for all α_L ∈ OutR2(τ_b,s1), α_R ∈ OutL1(τ_c,s2), there exists (o1,o2,o3,o4) ∈ Ext_{τ_b ⊙ τ_c} with E(α_L,o1) and E(o4,α_R), where
  OutR2(τ_b,s) := { second(f(τ_a,s,τ_b)) : τ_a ∈ T_long },
  OutL1(τ_c,s) := { first(f(τ_c,s,τ_d)) : τ_d ∈ T_long }.

Lemma 20 (Quantifier minimization equivalence).
Let f be any function T_long×{0,1}^2×T_long→Σ_out^2 obeying node/window constraints. The universal extendibility clause stated here is equivalent to the clause “for all τ_a,τ_b,τ_c,τ_d and s1,s2, letting α_L := second(f(τ_a,s1,τ_b)) and α_R := first(f(τ_c,s2,τ_d)), there exists (o1,o2,o3,o4)∈Ext_{τ_b⊙τ_c} with E(α_L,o1), E(o4,α_R)).”
Proof. “Only if”: the α_L,α_R in the original clause range over OutR2,OutL1. “If”: for given τ_b,τ_c,s1,s2 and α_L∈OutR2, α_R∈OutL1, pick τ_a,τ_d witnessing membership and apply the original clause. □

Proposition 19 (Optimized append in O(β^4) time for k_flag≥4).
For t with k_flag≥4 and a∈{0,1}, define Left3_t[x1,x2,x3] := ∃z (x1,x2,z,x3)∈Ext_t. One can compute Left3_t in O(β^4) time. Then fill Ext_{t·a} by scanning all (x1,x2,x3) with Left3_t[x1,x2,x3]=true and, for each, iterating over x4 with E(x3,x4) and x4∈A_a, setting Ext_{t·a}[x1,x2,x3,x4]←true. The total time is O(β^4) in the dense worst-case.
Proof. Correctness follows from Lemma 1. Complexity: Left3_t has β^3 entries, each tested in O(β); the fill step is O(β^3Δ) with Δ≤β. □

Proposition 21 (Seam-feasibility matrices for τ_b ⊙ τ_c).
For τ_b,τ_c, define W_{b⊙c}[α_L][α_R] (a β×β boolean matrix) to be true iff ∃(o1,o2,o3,o4)∈Ext_{τ_b⊙τ_c} with E(α_L,o1) and E(o4,α_R). Using precomputed 3D slices or Ext_{τ_b⊙τ_c}, W_{b⊙c} can be computed in O(β^4Δ^2) time (or better with sparse E), and then universal extendibility checks reduce to testing W_{b⊙c}[α_L][α_R].
Proof. Expand the definition via Lemma 11, eliminate internal witnesses by slices, and count operations. □

Proposition 17 (Nonemptiness monotonicity under concatenation).
If Ext_P ≠ ∅ and Ext_Q ≠ ∅ and there exist x4,x1′ with E(x4,x1′), then Ext_{P·Q} ≠ ∅.
Proof. Choose any (o1,o2,x3,x4) ∈ Ext_P and (x1′,x2′,o3′,o4′) ∈ Ext_Q; Lemma 11 and E(x4,x1′) imply (o1,o2,o3′,o4′) ∈ Ext_{P·Q}. □

Remark (Stage-1 equivalence pending endpoint treatment).
The o(n)⇔feasible-f equivalence claimed earlier is temporarily removed pending a rigorous treatment of endpoint segments in the (⇐) direction (see notes). All supporting mechanics above remain valid and will be reused once the endpoint lemma/partition fix is in place.
Proposition 6B (Base-case update; k=2→3).
Let t=(b1,b2) be a length-2 input and t′:=t·a the length-3 input obtained by appending a∈{0,1}. For all (x1,x2,x3,x4) ∈ Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x3 = x2, x1 ∈ A_{b1}, x2 ∈ A_{b2}, x4 ∈ A_a, E(x1,x2), and E(x2,x4) ].
Proof. Any legal labeling on three nodes has boundary (o1,o2,o2,o3), with o1∈A_{b1}, o2∈A_{b2}, o3∈A_a and E(o1,o2), E(o2,o3). Conversely, any tuple satisfying these constraints is realized by such a labeling. □

Definitions (endpoint projections and seam matrices).
For any type τ, define the projections of Ext_τ to the endpoint coordinates:
- RightColors(τ) := { y ∈ Σ_out : ∃ x1,x2,x3 with (x1,x2,x3,y) ∈ Ext_τ }.
- LeftColors(τ)  := { x ∈ Σ_out : ∃ x2,x3,y with (x,x2,x3,y) ∈ Ext_τ }.
Define the endpoint seam-compatibility matrices by
- V_left[τ][α]  := true ⇔ ∃ y ∈ RightColors(τ) with E(y, α), and
- V_right[α][τ] := true ⇔ ∃ x ∈ LeftColors(τ) with E(α, x).

Lemma E1 (endpoint feasibility via Ext).
Let τ be any type and α ∈ Σ_out.
(i) There exists a legal labeling of a left end-block of type τ together with an adjacent separator whose first output is α if and only if V_left[τ][α] is true.
(ii) There exists a legal labeling of a right end-block of type τ together with an adjacent separator whose second output is α if and only if V_right[α][τ] is true.
Proof. (i) If V_left[τ][α] holds, pick y ∈ RightColors(τ) with E(y,α) and any (x1,x2,x3,y)∈Ext_τ; Ext-membership provides the interior, and E(y,α) the seam. Conversely, any legal instance gives y as the last output on the end block, whence (x1,x2,x3,y)∈Ext_τ and E(y,α). (ii) is symmetric. □

Remark (on endpoints and Stage-1 for paths).
The matrices V_left and V_right give necessary and sufficient local conditions to glue an endpoint block to its unique adjacent separator. In the full o(n) vs Ω(n) classification on oriented paths, one must also ensure that the separator next to an endpoint is compatible with the nearest interior separator across the intervening block. This requires coupling the endpoint separator’s “open” seam color with the Out-sets produced by the feasible function on interior separators; see notes for a corrected certificate and construction. The o(n)⇔feasible-f equivalence remains pending this endpoint–interior bridging step.
Correction to Proposition 9 (append cost for k_flag ≥ 4).
Using Proposition 19, the append step δ(τ,a) for k_flag(τ) ≥ 4 can be implemented in O(β^4) time via the precomputed Left3_τ slices. Thus the BFS enumeration in Proposition 9 runs with O(β^4) per long transition (base‑cases remain ≤ O(β^4)), keeping the overall preprocessing 2^{poly(β)}.

Lemma E2 (Endpoint–interior bridging via W_{b⊙c}).
Fix τ_b, τ_c ∈ T_long, inputs s1,s2 ∈ {0,1}^2, and seam colors α_L, α_R ∈ Σ_out. There exists a legal completion of the intervening block of type τ_b ⊙ τ_c consistent with the left seam color α_L (toward τ_b) and the right seam color α_R (toward τ_c) if and only if W_{b⊙c}[α_L][α_R] is true, i.e., iff there exists (o1,o2,o3,o4) ∈ Ext_{τ_b ⊙ τ_c} with E(α_L, o1) and E(o4, α_R).
Proof. Directly by definition of W_{b⊙c}: “if” is witnessed by (o1,o2,o3,o4); “only if” follows by restricting any legal completion of the intervening block to its boundary and the seam edges. □

Definition (Endpoint maps with Out‑set alignment).
- g_L: T × {0,1}^2 × T_long → Σ_out^2. For g_L(τ_end, s, τ_b) = (β1,β2) require:
  (i) βi ∈ A_{s[i]} (i = 1,2) and E(β1,β2);
  (ii) V_left[τ_end][β1] = true;
  (iii) β2 ∈ OutR2(τ_b, s).
- g_R: T_long × {0,1}^2 × T → Σ_out^2. For g_R(τ_c, s, τ_end) = (β1,β2) require:
  (i) βi ∈ A_{s[i]} and E(β1,β2);
  (ii) V_right[β2][τ_end] = true;
  (iii) β1 ∈ OutL1(τ_c, s).

Theorem S1‑path (Endpoint‑coupled equivalence on oriented paths).
Let an r=1 LCL be given on globally oriented paths with output alphabet Σ_out of size β. Then the following are equivalent:
(A) There exists a deterministic LOCAL algorithm with runtime o(n).
(B) There exist witnesses (f_mid, g_L, g_R) where f_mid: T_long×{0,1}^2×T_long→Σ_out^2 is feasible in the Out‑set sense (Definition “Feasible function; Out‑set form”), and g_L, g_R satisfy the endpoint map constraints above.
Moreover, existence of such witnesses is verifiable in nondeterministic time 2^{poly(β)}.

Proof.
(⇒) Assume a deterministic o(n)‑round algorithm A. Fix a large n and let R := R(n) be its runtime on paths of length n. By Lemmas 13–14 (pumping), for each τ ∈ T_long choose a canonical input string w_τ of type τ with |w_τ| ≫ R and with a short prefix y_τ of length ≤ ℓ_pump such that w_τ = x_τ y_τ^M z_τ for some M, and the δ‑state is stable across repetitions.

Define f_mid(τ_L, s, τ_R) as follows: consider the concatenation W := w_{τ_L} · S(s) · w_{τ_R}, where S(s) is the 2‑node separator with input s. Assign unique identifiers so that the ID pattern is periodic and identical within the R‑neighborhoods around S(s), and pad beyond distance R into w_{τ_L}, w_{τ_R}. Run A on W and record the 2‑node output on S(s) as f_mid(τ_L, s, τ_R). Because the neighborhoods of S(s) are isomorphic across all such choices (by periodic pumping and our canonical construction), f_mid is well defined and satisfies node/window constraints. The Out‑set feasibility of f_mid holds: for any τ_b, τ_c and α_L ∈ OutR2(τ_b, s1), α_R ∈ OutL1(τ_c, s2), choose τ_a, τ_d witnessing α_L, α_R via f_mid and form the path w_{τ_b} · S(s1) · middle · S(s2) · w_{τ_c}, where “middle” is any long block of type τ_b ⊙ τ_c built from our canonical pieces and padded so that the R‑neighborhoods of the two separators are disjoint. By locality, A’s outputs on the two separators are α_L and α_R, and since A is correct, a legal completion of the middle block exists. Projecting to Ext gives W_{b⊙c}[α_L][α_R] = true, as required by the Out‑set feasibility clause.

Define g_L(τ_end, s, τ_b) similarly by running A on w_{τ_end} · S(s) · w_{τ_b} with padding beyond distance R on both sides and taking the separator’s output (β1,β2). Local correctness of A implies (i); the existence of a legal seam into the endpoint block yields V_left[τ_end][β1] = true, i.e., (ii); and since the right context is w_{τ_b}, the second output β2 lies in OutR2(τ_b, s), giving (iii). Define g_R symmetrically.

(⇐) Assume witnesses (f_mid, g_L, g_R) as above. Let K := ℓ_pump + 4. In O(log* n) rounds, compute a maximal independent set on the K‑th power of the directed path; standard properties ensure that the distances between successive selected positions (separators) lie in [K, 2K], except possibly near endpoints.

- Interior separators: For each separator between long blocks of types τ_b and τ_c with local inputs s1 and s2 on its two adjacent 2‑node windows, set its 2‑node output to f_mid(·). By Out‑set feasibility and Lemma E2, the block between any two consecutive interior separators is fillable via Ext_{τ_b ⊙ τ_c} using table W_{b⊙c}.
- Endpoint‑adjacent separators: Let S_L be the unique separator adjacent to the left end; compute τ_end (the type of the end block to its left) and τ_b (the long type on its right). Set S_L’s output to g_L(τ_end, s, τ_b). By Lemma E1 and condition (ii), the endpoint block can be filled. For the block between S_L and the nearest interior separator S_2 (with right‑side long type τ_c), condition (iii) gives α_L := second(g_L) ∈ OutR2(τ_b, s), while the left seam color α_R at S_2 is in OutL1(τ_c, s2) by construction. Hence W_{b⊙c}[α_L][α_R] = true, and Lemma E2 fills the intervening block. Do the right endpoint symmetrically with g_R.
- Small‑n edge cases (0 or 1 separator) are handled by brute‑force completion using Ext tables in constant radius; this does not affect asymptotic runtime.

All fillings are computed from constant‑size tables; the MIS step dominates with O(log* n) rounds. Thus we obtain an O(log* n) algorithm.

Verification complexity. Deterministically enumerate T and T_long via Proposition 9 with O(β^4) per long append (Prop. 19), precompute Ext_τ and Ext_{τ_b ⊙ τ_c}, W_{b⊙c}, V_left, V_right. For a guessed f_mid, compute OutR2 and OutL1 sets. Then check the constraints entrywise; the total time is 2^{poly(β)}.

Remark (superseding the earlier endpoint remark).
The previous remark stating that Stage‑1 equivalence was pending endpoint treatment is now resolved by Theorem S1‑path.

