{
  "progress_md": "Round 0011 \u2014 Completing Stage\u20112 (O(1) vs \u0398(log* n)) on oriented paths in NEXPTIME, with an oriented\u2011path partition lemma and a per\u2011type boundary certificate; small audits and unit\u2011testable lemmas\n\nSummary of new ideas\n- Stage\u20112 certificate finalized for globally oriented paths via per\u2011type interfaces Q_\u03c4 (one quadruple per long type), augmented with an explicit one\u2011sided endpoint bridging clause. This keeps verification single\u2011exponential in \u03b2 and avoids enumerating all short words w (which would blow up to doubly\u2011exponential in \u03b2).\n- Oriented\u2011path partition lemma (constant rounds) specialized from the paper\u2019s cycle partition: in O(1) rounds, partition any oriented path into short segments (length \u2264 2\u2113_width) and long periodic segments with primitive period length \u2264 \u2113_pattern repeated \u2265 \u2113_count times, with each node knowing its role. This provides the scaffolding for the O(1) construction.\n- Auditable fillings: long periodic segments are tiled by Q_\u03c4 using the wrap constraint E(R1_\u03c4,L1_\u03c4); short separators between long segments are filled by the universal bridging condition using Ext_{\u03c4_S}; endpoint separators are filled by one\u2011sided bridging (new clause) that only needs a seam to the adjacent long block.\n\nGaps identified in output.md\n- Stage\u20112 theorem for oriented paths is not yet stated. The Stage\u20112 plan has been outlined in earlier notes; below I give a concrete, NEXPTIME\u2011verifiable certificate and an O(1) construction.\n- Optional: add a \u201ctiny\u2011path completion\u201d lemma formalizing the small\u2011n fallback already invoked in S1\u2011path.\n\nStage\u20112 certificate and theorem to add (path version)\nDefinitions (recalled)\n- T is the set of reachable types (Lemma 8, Prop. 9). T_long := {\u03c4 \u2208 T : k_flag(\u03c4) \u2265 4}. \u2113_pump := |T|.\n- Ext concatenation and associativity as in Lemma 11 and Prop. 12.\nCertificate per long type \u03c4 \u2208 T_long\n- Q_\u03c4 = (L1_\u03c4, L2_\u03c4, R2_\u03c4, R1_\u03c4) \u2208 Ext_\u03c4.\nChecks (three families)\n1) Local tiling and wrap (within \u03c4): E(L1_\u03c4,L2_\u03c4), E(R2_\u03c4,R1_\u03c4), and E(R1_\u03c4,L1_\u03c4).\n2) Two\u2011sided universal bridging (across any middle type): For all \u03c4_left, \u03c4_S, \u03c4_right \u2208 T (\u03c4_left, \u03c4_right \u2208 T_long; \u03c4_S arbitrary, including short), we require \u2203(o1,o2,o3,o4) \u2208 Ext_{\u03c4_S} with E(R1_{\u03c4_left}, o1) and E(o4, L1_{\u03c4_right}). (For \u03c4_S empty, the condition reduces to E(R1_{\u03c4_left}, L1_{\u03c4_right}).)\n3) One\u2011sided endpoint bridging (new, for paths): For all \u03c4 \u2208 T_long and all \u03c4_S \u2208 T, require both\n   \u2022 \u2203(o1,o2,o3,o4) \u2208 Ext_{\u03c4_S} with E(o4, L1_\u03c4) (fill a left\u2011endpoint short segment abutting a long \u03c4 on the right), and\n   \u2022 \u2203(o1,o2,o3,o4) \u2208 Ext_{\u03c4_S} with E(R1_\u03c4, o1) (fill a right\u2011endpoint short segment abutting a long \u03c4 on the left).\nWhy (3) is needed and sufficient. In the O(1) construction, any endpoint segment S has only one adjacent long block; filling S requires only a seam into that long block. The existence of a quadruple in Ext_{\u03c4_S} with the single seam satisfied guarantees a legal local labeling of S; the \u201cunused\u201d seam (toward the path boundary) imposes no constraint (there is no edge beyond the endpoint).\nTheorem S2\u2011path (oriented paths; O(1) vs \u0398(log* n))\n- Statement. A \u03b2\u2011normalized radius\u20111 LCL on globally oriented paths has deterministic complexity O(1) iff there exist {Q_\u03c4}_{\u03c4\u2208T_long} satisfying (1)\u2013(3). Otherwise, if S1\u2011path holds but no {Q_\u03c4} satisfies (1)\u2013(3), the deterministic complexity is \u0398(log* n).\n- NEXPTIME verification. Enumerate T (Prop. 9) and Ext_\u03c4 for \u03c4 \u2208 T, plus Ext_{\u03c4_S} for all \u03c4_S. Check (1) directly. For (2), iterate all triples (\u03c4_left, \u03c4_S, \u03c4_right) and test existence of (o1,o2,o3,o4)\u2208Ext_{\u03c4_S} with the two seam E\u2011constraints (this reduces to \u03b2^2 bit\u2011matrix membership with precomputed slices). For (3), for each (\u03c4, \u03c4_S) test existence of a right boundary color o4 or left boundary color o1 in Ext_{\u03c4_S} adjacent to L1_\u03c4 or from R1_\u03c4, respectively. Total work is |T_long|\u00b7\u03b2^O(1) for (1), |T_long|^2\u00b7|T|\u00b7\u03b2^O(1) for (2), and |T_long|\u00b7|T|\u00b7\u03b2^O(1) for (3), hence single\u2011exponential in \u03b2.\n- O(1) construction. In O(1) rounds, compute an (\u2113_width, \u2113_count, \u2113_pattern)\u2011partition with \u2113_width = \u2113_pattern = \u2113_pump and \u2113_count = 2\u2113_pump + 2 (lemma below). This yields a decomposition of the oriented path into:\n  \u2022 Plong: maximally long periodic subpaths with primitive period w of length \u2264 \u2113_pattern, repeated \u2265 \u2113_count; each node knows w.\n  \u2022 Pshort: short/irregular subpaths, each of length \u2264 2\u2113_width; endpoint segments belong to Pshort or (degenerate case) are absorbed by a long periodic P \u2208 Plong.\n  Labeling algorithm:\n  1) For each P \u2208 Plong, let \u03c4 be its long type (well defined by periodic pumping). Tile P by repeating the boundary interface Q_\u03c4; interior legality holds because Q_\u03c4 \u2208 Ext_\u03c4 and E(R1_\u03c4,L1_\u03c4) (wrap) closes each tile.\n  2) For each short interior S \u2208 Pshort between two long neighbors P_L and P_R with types \u03c4_L, \u03c4_R, fill S via (2): pick (o1,o2,o3,o4) \u2208 Ext_{Type(S)} that matches E(R1_{\u03c4_L},o1) and E(o4,L1_{\u03c4_R}); interior is legal by Ext membership.\n  3) For each endpoint short S \u2208 Pshort adjacent to a single long neighbor of type \u03c4, fill S via (3): pick a quadruple from Ext_{Type(S)} with o4 adjacent to L1_\u03c4 (left endpoint) or with o1 adjacent from R1_\u03c4 (right endpoint).\n  Every step is constant\u2011radius and local.\n- Proof sketches. (\u21d2) If an O(1) algorithm exists, define Q_\u03c4 by simulating it on a canonical long representative of \u03c4 (periodic pumping identifies \u03c4 in O(1)); the checks follow by restricting a legal labeling and concatenation (Lemma 11). (\u21d0) The algorithm above is constant\u2011round as all decisions depend on O(\u2113_pump)\u2011radius information and precomputed tables.\n\nOriented\u2011path partition lemma (to add)\nLemma P\u2011Partition (O(1) rounds on globally oriented paths). For constants \u2113_width, \u2113_pattern, \u2113_count with \u2113_pattern \u2265 \u2113_width, there is a deterministic LOCAL algorithm that in O(1) rounds partitions any globally oriented path into directed subpaths P such that: (i) each P has |P| \u2265 \u2113_width; (ii) Pshort := {P : |P| \u2264 2\u2113_width} are short, with each node knowing its rank in P; (iii) Plong := {P : |P| > 2\u2113_width} are periodic, each P is equal to wk for some primitive w with |w| \u2264 \u2113_pattern and k \u2265 \u2113_count, and each node knows w.\nProof idea. This is the path\u2011specialization of [paper, Lemmas 20\u201322]. Orientation is given, so no initial orientation step is needed. First, for each primitive w (|w| \u2264 \u2113_pattern), nodes can detect in O(1) whether they belong to a maximal subpath whose input is wx with x \u2265 \u2113_count + 2\u2113_width. Trim \u2113_width\u00b7|w| nodes from each end to form Plong. The remaining nodes form Pirreg; by the \u201cno long periodic fragment\u201d property, one can compute an (\u2113_pattern, 2\u2113_pattern)\u2011independent set in O(1) (as in Lemma 20 in the paper) using distinct colors defined by length\u2011\u2113 windows along the orientation, and then cut Pirreg into subpaths of lengths in [\u2113_pattern, 2\u2113_pattern] (hence \u2265 \u2113_width) with rank labels. Setting \u2113_width = \u2113_pattern = \u2113_pump and \u2113_count = 2\u2113_pump+2 fits the Stage\u20112 construction.\n\nWhy the one\u2011sided endpoint clause (3) is natural and minimal\n- Necessity: Without (3), an endpoint short segment S adjacent to a long \u03c4 could fail: Ext_{Type(S)} might have no boundary y with E(y, L1_\u03c4), preventing a legal seam into \u03c4 even though two\u2011sided bridging holds elsewhere.\n- Sufficiency: The seam toward the missing side is not constrained, so any quadruple (o1,o2,o3,o4) with E(o4, L1_\u03c4) (or E(R1_\u03c4, o1) on the other side) yields a legal interior labeling by Ext and satisfies all node/edge constraints in S.\n\nTiny\u2011path completion lemma (optional addition)\nLemma Tiny. For K := \u2113_pump+4, any oriented path of length < K can be decided (solved or declared unsolvable) in constant rounds by exhaustive lookup: enumerate all Ext for its Type and pick any legal completion (or reject). This justifies the small\u2011n fallbacks used in S1\u2011path and S2\u2011path.\n\nComplexity and implementation notes (verifier)\n- Precompute Ext_\u03c4 for \u03c4 \u2208 T (Prop. 9, Prop. 19); Ext_{\u03c4_S} for all \u03c4_S; 3D slices for fast checks (Prop. 5). Build auxiliary endpoint\u2011allow bitsets per \u03c4_S: RightAllow(\u03c4_S) := {o4 : \u2203o1,o2,o3 (o1,o2,o3,o4)\u2208Ext_{\u03c4_S}}, LeftAllow(\u03c4_S) := {o1 : \u2203o2,o3,o4 (o1,o2,o3,o4)\u2208Ext_{\u03c4_S}}; used in (3) via E adjacency.\n- Certificate size is O(|T_long|) quadruples. Verification is dominated by (2), which is O(|T_long|^2\u00b7|T|\u00b7\u03b2^2) boolean checks with precomputed slices.\n\nSanity checks\n- Equality LCL (E={(c,c)}, A_0=A_1={c}). Choose Q_\u03c4=(c,c,c,c) for all \u03c4\u2208T_long; (1)\u2013(3) trivially hold; classify O(1).\n- Proper 2\u2011coloring. No Q_\u03c4 can satisfy E(R1_\u03c4,L1_\u03c4) wrap across period\u20111, hence (1) fails; S1\u2011path accepts (feasible f_mid exists); classification \u0398(log* n).\n- Endpoint stress: Pick an instance where some \u03c4_S has RightAllow(\u03c4_S) disjoint from N_E(L1_\u03c4) for a candidate \u03c4; then (3) fails and the certificate is correctly rejected.\n\nRelation to f0\u2011based Stage\u20112 (notes)\n- The f0 certificate for cycles (Gw,z, Gw1,w2,S) is elegant but naive verification over all w with |w| \u2264 \u2113_pump is doubly exponential in \u03b2. The per\u2011type Q_\u03c4 approach keeps checks to a singly\u2011exponential scale using |T| \u2264 4\u00b72^{\u03b2^4}.\n\nConcrete next steps for output.md\n1) Add Theorem S2\u2011path with the statement above, the certificate Q_\u03c4 and checks (1)\u2013(3), proofs of (\u21d2) and (\u21d0), and the NEXPTIME verification argument.\n2) Add Lemma P\u2011Partition (or cite/adapt paper\u2019s Lemmas 20\u201322) specialized to oriented paths, with parameters \u2113_width=\u2113_pattern=\u2113_pump, \u2113_count=2\u2113_pump+2.\n3) Optionally add Lemma Tiny to justify small\u2011n fallback.\n4) Add a short \u201cEndpoint one\u2011sided bridging\u201d remark explaining why no extra endpoint tables (like V_left/V_right) are needed in Stage\u20112 beyond (3).\n\nObstacles and resolutions\n- Endpoint handling in Stage\u20112: resolved by the explicit one\u2011sided bridging clause (3), which is verifiable from Ext tables and does not enlarge asymptotics.\n- Avoiding double\u2011exponential blow\u2011up: resolved by using per\u2011type Q_\u03c4 and the partition lemma instead of an f0 on all words of length \u2264 \u2113_pump.\n\nUnit\u2011test ideas for the verifier\n- Verify (1): for random \u03c4\u2208T_long, check E(L1_\u03c4,L2_\u03c4), E(R2_\u03c4,R1_\u03c4), E(R1_\u03c4,L1_\u03c4).\n- Verify (2): build bit\u2011matrices M_{\u03c4_S}[\u03b1_L][\u03b1_R] := \u2203(o1,o2,o3,o4)\u2208Ext_{\u03c4_S} with E(\u03b1_L,o1) and E(o4,\u03b1_R). Then assert for all \u03c4_left,\u03c4_S,\u03c4_right that M_{\u03c4_S}[R1_{\u03c4_left}][L1_{\u03c4_right}] is true.\n- Verify (3): precompute RightAllow(\u03c4_S), LeftAllow(\u03c4_S); assert \u2200\u03c4,\u03c4_S that N_E(RightAllow(\u03c4_S)) contains L1_\u03c4 and N_E^{-1}(LeftAllow(\u03c4_S)) contains R1_\u03c4.\n\nMinor audit\n- S1\u2011path now includes Lemma M1; Prop. 9 states O(\u03b2^4) long append and references Prop. 19; endpoint extraction in S1 (\u21d2) uses P_end (short allowed) with one\u2011sided padding \u2014 good. I found no remaining contradictions in output.md.\n"
}