--- SYSTEM ---
You are a research mathematician. 

You are being run in a loop with a verifier that checks rigor. Your goal is to make **incremental, auditable progress**. You are not expected to solve the problem at once, but to generate new, testable ideas.

Inputs: 
- task statement 
- notes.md (summary of past progress; optional) 
- output.md (rigorously proven results curated so far; optional) 
- summary of past rounds (optional) 
- possibly some reference papers.

What counts as progress:
- Extract small lemmas/heuristics from literature and state them cleanly with one-line "why useful here".
- Explore small examples & try to break your own claims with toy counterexamples.
- Prove special cases or nontrivial bounds.
- If an approach fails, explain crisply why.
- Point out flaws in notes.md or output.md (but do not rewrite output.md yourself).

**Discipline.** 
- Read notes, outputs, summaries carefully before proposing new work. 
- Reference papers if relevant, but focus on *incremental, checkable steps*. 
- Do not output Markdown code fences, only raw JSON. 
- Length: at least ~200 words. 
- Organize your reasoning with short headings (Ideas, Examples, Obstacles, Next steps), make clear what your claims are and how they are supported. 
- Remember: the verifier curates notes and outputs, you only suggest.

**Return strictly JSON**:
{
  "progress_md": "Your progress notes for this round in Markdown (KaTeX allowed). Point out any gaps in output.md clearly. Do not modify output.md directly."
}


--- USER ---
Work on this problem context:

=== task.txt ===
﻿Task


\newcommand{\SigIn}{\Sigma_{\mathrm{in}}}
\newcommand{\SigOut}{\Sigma_{\mathrm{out}}}
\newcommand{\Cinout}{C_{\mathrm{in\text{--}out}}}
\newcommand{\Coutout}{C_{\mathrm{out\text{--}out}}}
\newcommand{\Type}{\mathrm{Type}}
\newcommand{\pumpLen}{\ell_{\mathrm{pump}}}


\paragraph{One-line summary.}
Design a nondeterministic exponential-time algorithm (NEXPTIME algorithm) that decides, given a $\beta$-normalized, radius-1 LCL on globally oriented paths, whether the local complexity of that problem is $O(1)$ vs.\ $\Omega(\log^* n)$ vs.\ $\Omega(n)$.


\section*{Problem setup}


We work in the standard \textsc{Local} model on globally oriented paths. An LCL is \emph{$\beta$-normalized (radius 1)} if it has:
\begin{itemize}
  \item binary input alphabet $\SigIn=\{0,1\}$,
  \item output alphabet $\SigOut$ of size $\beta$,
  \item legality checked only by two tables: $\Cinout\subseteq\SigIn\times\SigOut$ and $\Coutout\subseteq\SigOut\times\SigOut$.
\end{itemize}
A labeling is legal iff $(\mathrm{in}(v),\mathrm{out}(v))\in \Cinout$ at each node $v$ and $(\mathrm{out}(u),\mathrm{out}(v))\in \Coutout$ on each directed edge $u\!\to\! v$.


\paragraph{Encoding size.}
We assume an explicit encoding of $(\Cinout,\Coutout)$ of size $\mathrm{poly}(\beta)$ (e.g., $\Cinout$ as a $2\times \beta$ Boolean table and $\Coutout$ as a $\beta\times \beta$ Boolean table). We measure time in the input length $N=\mathrm{poly}(\beta)$.


\paragraph{Your task}
Your task is to construct as efficient an algorithm as possible for the task of deciding the local complexity of an input $\beta$-normalized problem. Aim for a nondeterministic exponential time algorithm. 


\paragraph{Attached paper}
The attached paper proves that the problem is decidable. Their algorithm is based on the notion of a feasible function and, naively, it needs doubly exponential time. You have to understand that paper thoroughly, since your goal is to improve upon their result.

=== progress.md ===
...
d path with K := ℓ_pump + 4. As in output.md, label every internal separator with f_mid and fill each middle block via the Ext-witness in Ext_{τ_b ⊙ τ_c}. For the left end block P_end with its unique neighbor separator S, let g_L(τ_end, s) = (β1, β2). By V_left[τ_end][β1], choose (o1,o2,o3,o4) ∈ Ext_{τ_end} with E(o4, β1) and fill P_end accordingly; similarly the right end via g_R and V_right. All node and edge constraints hold by Ext membership and seam E-tests. Runtime is O(log* n); endpoints add no overhead.
- NEXPTIME verification. Deterministically enumerate T, T_long, Ext tables, and precompute V_left,V_right and the seam-feasibility matrices W_{b⊙c} (already in output.md). Nondeterministically guess f_mid, g_L, g_R and verify: (i) node/window constraints for all entries; (ii) the Out-set universal checks for f_mid using W_{b⊙c}; (iii) one-sided checks for g_L,g_R using V_left,V_right. Total time 2^{poly(β)}.
Why useful here. This removes the “pending endpoint treatment” remark and completes the o(n) vs Ω(n) decision for globally oriented paths at the type/Ext level.

Explicit k=2→3 base-case to insert
Proposition (Base-case update; k=2→3). Let t = (b1, b2), t′ := t·a. For all (x1, x2, x3, x4) ∈ Σ_out^4,
(x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x3 = x2, x1 ∈ A_{b1}, x2 ∈ A_{b2}, x4 ∈ A_a, E(x1,x2), E(x2,x4) ].
Why useful here. Needed by δ to lift k_flag from 2 to 3 and to make the append DP fully constructive from seeds.

Complexity notes (consistent with output.md)
- Precompute T via δ in 2^{poly(β)}; compute Ext_τ for all τ and Ext_{τ_b ⊙ τ_c} (for τ_b,τ_c ∈ T_long) using the O(β^6) routine; precompute W_{b⊙c} and V_left,V_right in β^{O(1)} per pair.
- Certificate size: f_mid has |T_long|^2·4 entries; g_L has |T|·4, g_R has |T|·4 entries. Verification consists of constant-time table lookups per case; total time 2^{poly(β)}.

Sanity checks (toy instances)
- Equality LCL (E={(c,c)}, A_0=A_1={c}). RightColors(τ)=LeftColors(τ)={c} for all τ; choose f_mid(·)=(c,c), g_L=g_R=(c,c). All matrices trivial; accepts.
- Proper 2-coloring (Σ_out={a,b}, E forbids equal). A standard f_mid exists (alternating), and V_left,V_right are always true since RightColors=LeftColors={a,b}. Stage-1 accepts. (Stage-2 will correctly reject constant-time.)
- Linear-hard case: If for some τ_end, RightColors(τ_end) has no E-neighbor in a color forced as β1 by any g_L, then V_left fails and the verifier rejects, certifying Ω(n).

Action items for outputs.md
- Add the k=2→3 base rule explicitly (as above), beside k=1→2 and k=3→4.
- Add RightColors/LeftColors and the endpoint matrices V_left,V_right with a short correctness lemma (Lemma E1).
- Add the endpoint-aware Stage-1 theorem (Theorem P-S1) with the construction/verification outline; reference existing Lemmas 11–14 and Prop. 21 for the internal (two-sided) parts.
- Optional editorial: merge Lemma 2 and Lemma 11 into a single “all k_flag” concatenation lemma, or keep both but note that Lemma 11 subsumes Lemma 2.

Notes toward Stage-2 (constant vs log* n)
- The paper’s (ℓ_width, ℓ_count, ℓ_pattern)-partition (Lemma 22) is already reproduced for cycles and applies to oriented paths with a simpler orientation primitive. Integrating the per-type boundary-interface witness Q_τ and bridging checks from earlier rounds should now be feasible. I will prepare a path-specialized statement and proof next, using the existing Ext machinery and associativity.

Why these steps are incremental and testable
- All additions reduce to precomputable projections or matrices over already-defined Ext tables; no new global gadgets are used.
- The endpoint matrices enable immediate unit tests: compute V_left,V_right on random tiny instances and compare against brute-force searches over Ext.
- The endpoint-aware theorem uses the same MIS-based spacing (already standard and cited) and reuses W_{b⊙c}; only constant-size endpoint lookups are added.

## Round 0008 — 2025-08-27T18:49:31.402449Z

Round 0008 — Path endpoints for Stage‑1, Stage‑2 certificate formalization for oriented paths, and audit items

Summary
- I propose a complete, endpoint-aware Stage‑1 characterization for globally oriented paths that is verifiable in NEXPTIME and closes the gap currently marked as “pending endpoint treatment” in output.md. The witness consists of (i) a two-sided feasible function f_mid on long types, plus (ii) one-sided endpoint witnesses g_L and g_R certified via precomputed endpoint seam-compatibility matrices derived from Ext.
- I also propose a precise Stage‑2 (O(1) vs Ω(log* n)) certificate specialized to globally oriented paths, with a constant-time construction proof that reuses the paper’s (ℓ_width,ℓ_count,ℓ_pattern)-partition framework, now expressed wholly in Ext/type terms. This fills the other major missing piece.
- I point out several small gaps/cleanups in output.md (notably the missing k=2→3 base case and a minor duplication) and list concise steps to integrate the new lemmas and theorems.

Audit of output.md: gaps and cleanups
- Missing base case k=2→3. Proposition 6 (k=1→2) and Proposition 7 (k=3→4) are present, but the explicit k=2→3 update is absent. This is needed to seed δ transitions from length 2.
  • Correct rule to add: for t=(b1,b2), t′=t·a,
    (x1,x2,x3,x4)∈Ext_{t′} iff [x3=x2, x1∈A_{b1}, x2∈A_{b2}, x4∈A_a, E(x1,x2), E(x2,x4)].
- Stage‑1 equivalence on paths is marked “pending endpoint treatment.” Below I supply a self-contained endpoint-aware witness, a verification routine, and an equivalence theorem using only Ext and Types.
- Redundancy: Lemma 2 (Ext concatenation for k_flag≥4) and Lemma 11 (for all k_flag) both appear. Lemma 11 subsumes Lemma 2; we can keep both but it is clearer to refer uniformly to Lemma 11.
- Stage‑2 (O(1) vs Ω(log* n)) is not yet included. I give a precise per-type boundary-interface witness and an O(1) labeling construction for oriented paths, with checks entirely in Ext.

Preliminaries to add (endpoint projections)
- Define for any type τ:
  • RightColors(τ) := { y ∈ Σ_out : ∃x1,x2,x3 s.t. (x1,x2,x3,y) ∈ Ext_τ }.
  • LeftColors(τ)  := { x ∈ Σ_out : ∃x2,x3,y s.t. (x,x2,x3,y) ∈ Ext_τ }.
  These are just projections of Ext_τ; computable in O(β^4) per τ.
- Define endpoint seam-compatibility (precompute once):
  • V_left[τ][α1] = true iff ∃y∈RightColors(τ) with E(y,α1).
  • V_right[α2][τ] = true iff ∃x∈LeftColors(τ) with E(α2,x).
  These witness that an end block of type τ can be attached to the first (resp. last) node of the adjacent 2-node separator colored α1 (resp. α2).

Stage‑1 (Ω(n) vs o(n)) on globally oriented paths — endpoint-aware witness and equivalence
Witness objects to guess and verify
- Long types: T_long := {τ : k_flag(τ)≥4}. Precompute T and split.
- Mid-separator feasible function f_mid: T_long × {0,1}^2 × T_long → Σ_out^2.
  • Local legality: if f_mid(τ_L, s, τ_R)=(α1,α2), require αi∈A_{s[i]} and E(α1,α2).
  • Universal extendibility across two separators: For all τ_b,τ_c∈T_long, s1,s2∈{0,1}^2 and for all α_L ∈ OutR2(τ_b,s1), α_R ∈ OutL1(τ_c,s2), require ∃(o1,o2,o3,o4)∈Ext_{τ_b⊙τ_c} with E(α_L,o1) and E(o4,α_R). Here
    OutR2(τ_b,s):={second(f_mid(τ_a,s,τ_b)): τ_a∈T_long},
    OutL1(τ_c,s):={first(f_mid(τ_c,s,τ_d)): τ_d∈T_long}.
  • Verification reduction: precompute W_{b⊙c}[α_L][α_R] as in Prop. 21; then check W_{b⊙c}[α_L][α_R]=true for all required α_L, α_R.
- Endpoint witnesses: g_L : T × {0,1}^2 → Σ_out^2 and g_R : {0,1}^2 × T → Σ_out^2.
  • Local legality: if g_L(τ_end,s)=(β1,β2) then βi∈A_{s[i]} and E(β1,β2). Symmetric for g_R.
  • One-sided feasibility: V_left[τ_end][β1]=true for g_L, and V_right[β2][τ_end]=true for g_R.

Theorem S1-path (equivalence; oriented paths).
An r=1, β-normalized LCL on globally oriented paths has deterministic complexity o(n) iff there exist witnesses (f_mid, g_L, g_R) satisfying the above checks. Moreover, existence is verifiable in nondeterministic time 2^{poly(β)}.
Sketch proof (⇒): Given an o(n)-round algorithm A, define f_mid exactly as in the cycle case by pumping the two long contexts on either side of a 2-node separator; feasibility uses Ext_{τ_b⊙τ_c} (Lemma 11) and pumping (Lemmas 13–14). Define g_L(τ_end,s), g_R(s,τ_end) by simulating A on a path that consists of a long pumped left (resp. right) context, then the endpoint block of type τ_end, then a 2-node separator S with input s, then a long pumped right (resp. left) context; pick IDs so that A’s runtime halo is well inside the pumped parts. Local legality is by correctness of A; one-sided feasibility follows because the seam edge between the endpoint block and S is satisfied in the simulation, hence V_left/V_right holds by projection to Ext.
Sketch proof (⇐): From (f_mid, g_L, g_R), construct in O(log* n) a labeling as follows. In O(log* n) rounds, compute an MIS on the K-th power of the oriented path (K:=ℓ_pump+4); separators are the selected MIS nodes augmented to 2-node blocks with inputs s, spaced in [K,2K]. For each interior pair of separators (S1, S2) with adjacent long types τ_b, τ_c on their sides, color S1 and S2 by f_mid, and complete the middle using the witness in Ext_{τ_b⊙τ_c}. For endpoint segments, color the unique separator S by g_L or g_R and complete the adjoining block using V_left or V_right and Ext of the endpoint type. All checks and fillings are local and constant-radius; runtime O(log* n) comes from MIS.
NEXPTIME verification: Deterministically compute T, T_long, Ext and W_{b⊙c}, V_left, V_right in 2^{poly(β)} time. Nondeterministically guess f_mid, g_L, g_R and verify the finite set of constraints via table lookups; total time 2^{poly(β)}.

Stage‑2 (O(1) vs Ω(log* n)) on globally oriented paths — per-type boundary interface
Witness per long type τ∈T_long: Q_τ=(L1_τ,L2_τ,R2_τ,R1_τ)∈Ext_τ.
Checks
- Per-type tiling:
  • E(L1_τ,L2_τ), E(R2_τ,R1_τ) (redundant but explicit), and wrap E(R1_τ,L1_τ).
- Universal bridging across any middle type τ_S (short or long):
  • For all τ_left, τ_S, τ_right with τ_left,τ_right∈T_long: ∃(o1,o2,o3,o4)∈Ext_{τ_S} with E(R1_{τ_left},o1) and E(o4,L1_{τ_right}). For S empty, this reduces to E(R1_{τ_left},L1_{τ_right}).
Theorem S2-path (constant-time construction).
If {Q_τ} satisfy the above, there is an O(1)-round deterministic algorithm on oriented paths.
Sketch construction: In O(1) rounds compute an (ℓ_width,ℓ_count,ℓ_pattern)-partition (as in the paper’s Lemma 22; here orientation is globally given). Choose parameters ℓ_width=ℓ_pattern=ℓ_pump and ℓ_count=2ℓ_pump+2. Long paths are periodic with primitive period length ≤ℓ_pump, repeated ≥ℓ_count. Each long path P has a long type τ; tile P by repeats of τ using E(R1_τ,L1_τ); interior legality holds since Q_τ∈Ext_τ. Each short/irregular separator S (any τ_S) is filled using its Ext witness to match the boundary colors of adjacent long blocks (bridging condition). Endpoints need no special treatment beyond bridging to the nearest long block. All decisions are constant-radius.
NEXPTIME verification: Guess {Q_τ} over T_long; verify tiling and bridging universally with Ext lookups; total time 2^{poly(β)}.

Complexity refinements and preprocessing
- Append optimization (already Proposition 19): O(β^4) per append after Left3 slices.
- Concatenation optimization (Proposition 5): O(β^6) per pair via Left/Right 3D slices.
- Seam feasibility matrices W_{b⊙c} (Proposition 21): speed up Stage‑1 verification.
- Endpoint matrices V_left, V_right: O(|T|·β·Δ) preprocessing; used by g_L/g_R verification.

Sanity checks on examples
- Equality LCL: choose c∈A_0∩A_1 with E(c,c); f_mid constant (c,c); g_L, g_R constant (c,c); any Q_τ=(c,c,c,c); both stages accept ⇒ O(1).
- Proper 2-coloring: Stage‑1 witnesses exist (Θ(log* n)); Stage‑2 fails due to wrap E(R1_τ,L1_τ) and universal bridging impossibility with a period‑1 interface; classification Θ(log* n).
- Linear case: if no feasible (f_mid,g_L,g_R) exists, Stage‑1 rejects ⇒ Ω(n).

Actionable insertions for output.md
1) Add Proposition (Base-case update; k=2→3) exactly as stated in the audit.
2) Add definitions of RightColors, LeftColors, V_left, V_right, and a short proposition on their computation/complexity.
3) Add the endpoint-aware Stage‑1 theorem S1-path: statement, witness definitions (f_mid, g_L, g_R), quantifier-minimized verification using W_{b⊙c}, and both directions of the equivalence (with brief, oriented-path-specific proofs relying on Lemmas 11, 13–14).
4) Add Stage‑2 theorem S2-path: the per-type boundary interface witness Q_τ, universal checks, and the O(1) labeling construction using the (ℓ_width,ℓ_count,ℓ_pattern)-partition on oriented paths (cite the paper’s lemma if not reproved in full; parameters explicit).
5) Note that Lemma 11 subsumes Lemma 2 and refer to Lemma 11 uniformly for concatenation; optionally keep Lemma 2 as a corollary for readability.

Why these fill the gaps
- Stage‑1 now covers finite paths with endpoints rigorously, removing the caveat. All conditions are expressed with Ext plus precomputed matrices, so the verification remains single-exponential. The construction uses only standard Kth‑power MIS.
- Stage‑2 shifts entirely to per-type interfaces and Ext bridging, matching the paper’s constant-time regime but specialized to globally oriented paths. The verification is again single-exponential; the algorithm is explicit and constant‑round.

Next steps
- Integrate the new statements into output.md with concise proofs. Keep the MIS step description and (ℓ_width,ℓ_count,ℓ_pattern)-partition paraphrased from the paper but specialized to oriented paths.
- Add a small regression suite for β∈{2,3}: (i) verify k=2→3 update; (ii) validate V_left/V_right vs direct Ext; (iii) test W_{b⊙c} correctness; (iv) confirm Stage‑1 acceptance on equality LCL, Stage‑2 rejection on 2‑coloring.

## Round 0009 — 2025-08-27T18:59:35.895061Z

Round 0009 — Endpoint-coupled Stage‑1 for paths; certificate fix, proofs, and verifiable checks

Status and audit of output.md
- Good: r=1 machinery is solid and comprehensive: append DP with k-flag cases (k=1→2, k=2→3, k=3→4), congruence, general Ext-concatenation (all k_flag) and associativity, δ-enumeration with |T| ≤ 4·2^{β^4}, optimized append (O(β^4)), optimized concatenation (O(β^6)), pumping lemmas, W_{b⊙c} feasibility matrices, and endpoint projections RightColors/LeftColors with V_left/V_right + Lemma E1.
- Gap: Stage-1 (o(n) vs Ω(n)) is marked “pending endpoint treatment”. The current notes already identify that we must couple the endpoint-adjacent separators with the interior feasible function via OutR2/OutL1; output.md does not yet contain the corrected endpoint-aware certificate and equivalence theorem.
- Minor: We can note under Proposition 9 that k_flag≥4 transitions can use Proposition 19 to reduce per-append cost from O(β^5) to O(β^4).

Idea — Corrected Stage‑1 path certificate with endpoint coupling
- Motivation (why necessary). Without coupling, g_L/g_R can choose seam colors that are legal at the endpoint (V_left/V_right true) but fall outside the Out-sets produced by f_mid, so the first interior block (between the endpoint-adjacent separator and the next interior separator) may be unfillable even though interior checks pass. This was the “minimal obstruction” pointed out in the feedback.
- Definitions (objects and sets already available):
  • T_long := {τ : k_flag(τ)≥4}.
  • OutR2(τ_b,s) := { second(f(τ_a,s,τ_b)) : τ_a∈T_long }.
  • OutL1(τ_c,s) := { first(f(τ_c,s,τ_d)) : τ_d∈T_long }.
  • W_{b⊙c}[α_L][α_R] records the existence of an Ext-witness across τ_b⊙τ_c consistent with seam colors α_L, α_R.
  • V_left, V_right as in output.md (endpoint seam feasibility).
- Certificate (to add):
  1) f_mid: T_long×{0,1}^2×T_long→Σ_out^2, feasible in the Out-set sense (already defined) and verified via W_{b⊙c}.
  2) g_L: T×{0,1}^2×T_long→Σ_out^2; for g_L(τ_end,s,τ_b)=(β1,β2) require:
     (i) node legality βi∈A_{s[i]} and E(β1,β2);
     (ii) endpoint seam feasibility V_left[τ_end][β1]=true;
     (iii) interior alignment β2∈OutR2(τ_b,s).
  3) g_R: T_long×{0,1}^2×T→Σ_out^2; for g_R(τ_c,s,τ_end)=(β1,β2) require:
     (i) node legality and E(β1,β2);
     (ii) endpoint seam feasibility V_right[β2][τ_end]=true;
     (iii) interior alignment β1∈OutL1(τ_c,s).
  Remarks.
  - The third argument in g_L/g_R couples endpoint separators to the adjacent long type on the interior side. This ensures the open seam color toward the interior is drawn from the same Out-set used by f_mid, so the W_{b⊙c} universal checks cover the first interior block as well.

Theorem S1-path (Endpoint-coupled equivalence; to insert)
- Statement. For a β-normalized r=1 LCL on globally oriented paths, the following are equivalent:
  (A) There is a deterministic LOCAL algorithm with runtime o(n).
  (B) There exist witnesses (f_mid,g_L,g_R) satisfying: f_mid is feasible in the Out-set sense, g_L,g_R satisfy (i)–(iii) above.
  Moreover, existence of such witnesses is verifiable in nondeterministic time 2^{poly(β)}.
- Proof sketch (⇒):
  • As in Lemma 18 (already in outputs.pdf/paper), choose s≫T(n), pump any short context w to w^+ with |w^+|∈[s,s+ℓ_pump]. Extract f_mid(·) by simulating the o(n)-algorithm A on w_L^+·S·w_R^+ and reading the 2-node outputs on S, implying Out-set feasibility via W_{b⊙c}.
  • For g_L(τ_end,s,τ_b): embed (left end-block of type τ_end) + separator S with input s + a long pumped block of type τ_b on the right into a large path padded beyond the runtime halo, run A, and set g_L to the 2-node output on S. Local correctness implies (i); the seam into the endpoint implies (ii); the presence of τ_b on the right forces the second output to lie in OutR2(τ_b,s), i.e., (iii). Similarly define g_R with τ_c on the left.
- Proof sketch (⇐):
  • Place 2-node separators in O(log* n) by an MIS on the K-th power (K:=ℓ_pump+4), so distances between successive separators are in [K,2K], except for one-sided end segments.
  • Interior: label each interior separator by f_mid and complete the middle block between any two interior separators using W_{b⊙c} and Ext_{τ_b⊙τ_c}.
  • Ends: label the left (resp. right) endpoint-adjacent separator using g_L(τ_end,s,τ_b) (resp. g_R(τ_c,s,τ_end)), where τ_b,τ_c are the long types on the interior sides. Then:
    – Fill the endpoint block via Lemma E1 using V_left/V_right (local seam feasibility).
    – Fill the intervening block between the endpoint separator and the nearest interior separator via W_{b⊙c}, with α_L=second(g_L) (in OutR2 by (iii)) and α_R=first(f_mid on the interior separator) (in OutL1 by construction), so the prechecked W_{b⊙c}[α_L][α_R] entry guarantees a witness in Ext_{τ_b⊙τ_c}.
  • All checks are local; the MIS step dominates time: O(log* n).
- NEXPTIME verification. Deterministically compute T and T_long; precompute Ext_τ and Ext_{τ_b⊙τ_c}, W_{b⊙c}, OutR2/OutL1 sets from f_mid; V_left,V_right from Ext tables. Nondeterministically guess f_mid, g_L, g_R. Verify:
  • f_mid node legality and the universal Out-set checks via W_{b⊙c}.
  • For all (τ_end,s,τ_b): g_L node legality; V_left[τ_end][β1]; β2∈OutR2(τ_b,s).
  • For all (τ_c,s,τ_end): g_R node legality; V_right[β2][τ_end]; β1∈OutL1(τ_c,s).
  Each is a table lookup; total time 2^{poly(β)}.

Toy counterexample (why alignment is essential; optional to include)
- Template. Choose τ_b with OutR2(τ_b,s)={α} and a τ_c with some OutL1-set; suppose W_{b⊙c}[α][·] admits fills. Let g_L output (β1,β2) with β2≠α but V_left[τ_end][β1] true. Then the first interior block fails to fill because W_{b⊙c}[β2][α_R] can be false for all α_R. Hence the uncoupled endpoint certificate can produce false positives.
- This simple construction can be instantiated by adapting the 3-color a→b→c gadget used earlier (Proposition 4), with compatible A/E and Types.

Implementation refinements (verifier-side)
- Precomputations (single-exponential):
  • T by BFS; Ext_τ for τ∈T; Left3_t to speed appends (Proposition 19); Ext_{τ_b⊙τ_c} for τ_b,τ_c∈T_long via Proposition 5.
  • W_{b⊙c}; V_left, V_right.
  • For a guessed f_mid, compute OutR2(τ_b,s) and OutL1(τ_c,s) (max size β each); for speed, precompute their bitsets.
- Optional matrices: for endpoints, precompute L_allow[τ_end]:={α | V_left[τ_end][α]} and R_allow[τ_end]:={α | V_right[α][τ_end]} to reduce g_L/g_R checks to set membership plus E/A.
- Complexity note (to amend Proposition 9). For k_flag≥4 transitions during δ-enumeration, the O(β^4) append (Proposition 19) reduces total preprocessing constants; asymptotics remain 2^{poly(β)}.

Small auxiliary lemmas (easy to add, testable)
- Endpoint allowable-color sets are exactly the E-neighbors of endpoint projections (already implicit):
  • L_allow(τ) = N_E(RightColors(τ)) and R_allow(τ) = N_E^{-1}(LeftColors(τ)). This is Lemma E1 reformulated as set identities.
- RightColors/LeftColors under append (computational aid). For τ′=τ·a with k_flag(τ)≥4,
  • RightColors(τ′) = { y ∈ A_a : ∃(x1,x2,x3) with Left3_τ[x1,x2,x3] and E(x3,y) }.
  • LeftColors(τ·a) = LeftColors(τ). These follow directly from Lemma 1 and the definition of Left3_τ.
  Use: fast updates of V_left/V_right if recomputed incrementally.

Examples and sanity
- Equality LCL (E={(c,c)}, c∈A_0∩A_1). Choose f_mid(·)=(c,c). OutR2/OutL1 are {c}. Let g_L=g_R=(c,c). V_left/V_right trivially true; W_{b⊙c}[c][c]≈true. Classified O(1) by Stage-2; Stage-1 accepts.
- Proper 2-coloring: With Σ_out={a,b} and E forbidding equal neighbors, an f_mid exists; OutR2/OutL1={a,b}; pick endpoint g_L/g_R alternating; Stage-1 accepts; Stage-2 later rejects (Θ(log* n)).

Concrete next steps (edits to output.md)
1) Add “Theorem S1-path (endpoint-coupled equivalence)” with the witnesses and proofs (both directions) as above.
2) Define g_L, g_R with third argument and spell out the three verification clauses; reference V_left/V_right, OutR2/OutL1, W_{b⊙c}.
3) Under Proposition 9, note that Proposition 19 yields O(β^4) per-append for k_flag≥4.
4) Optionally include the toy counterexample to document why the endpoint coupling is necessary.
5) Leave Stage-2 (constant-time) for paths out of output.md until we integrate a self-contained partition lemma (the paper’s Lemma 22 can be specialized to oriented paths; drafting this is queued for next round).

Regression checklist (to add to notes/tests)
- Validate endpoint-coupled certificate:
  • Construct a random small β instance; enumerate T, T_long; nondeterministically synthesize f_mid; derive OutR2/OutL1; then attempt to synthesize g_L/g_R and verify constraints.
  • Show that dropping (iii) can create false positives (use the minimal obstruction template).
- Re-run: optimized append vs brute-force append on β≤3; Ext-concatenation associativity; W_{b⊙c} correctness vs direct Ext scans.

Potential pitfalls addressed
- Seam and indexing: we adhere to (L1,L2,R2,R1); the left seam meets o1 in Ext_{τ_b⊙τ_c}, the right seam meets o4. Endpoint seam checks use β1=first(g_L) at the left seam and β2=second(g_R) at the right seam.
- Edge cases (small n): if MIS yields 0 or 1 separators, handle with constant-radius fallback (brute-force local completion using Ext tables) — this does not affect asymptotic classification.

## Round 0009 — 2025-08-27T19:01:12.517580Z

Round 0009 — Endpoint-correct Stage-1 for paths, audits, and verifiable fixes

Status and quick audit of output.md
- What is solid: r=1 primitives (append DP with k-flag, corrected base cases k=1→2, 3→4; concatenation; associativity; congruence), type enumeration and |T| bound; pumping lemmas; Out-set version of feasible f over T_long; optimized append O(β^4); seam-feasibility matrices W; endpoint projections RightColors/LeftColors and endpoint seam matrices V_left,V_right with Lemma E1.
- Main gap (explicitly acknowledged): Stage-1 equivalence on oriented paths is “pending endpoint treatment.” As written, there is no coupling between the endpoint-adjacent separator’s open seam color and the Out-sets of the interior feasible function; this can admit false positives.
- Minor editorial/numbering issues to flag: (i) There are two different “Proposition 6” items (base k=1→2 and k_flag=1 update as 6A) and also “Proposition 6B” (k=2→3), which is confusing; consider renumbering. (ii) Both Lemma 2 (k_flag≥4) and Lemma 11 (all k_flag) state concatenation; Lemma 11 subsumes Lemma 2—either keep both with a note or refer to Lemma 11 uniformly. (iii) Proposition 9 still quotes O(β^5) per append in the long regime; Proposition 19 improves this to O(β^4), so the preprocessing bound can be tightened accordingly.

Problem and minimal counterexample (why the current endpoint certificate is insufficient)
- Obstruction template: Fix a long type τ_b and an input s such that OutR2(τ_b,s) = {α}. Suppose W_{b⊙c}[α][·] admits all right seams induced by f on the next separator. If an endpoint witness g_L(τ_end,s) outputs (β1,β2) with β2 ≠ α but V_left[τ_end][β1]=true, the current checks pass but the fill of the block between this separator and the next separator (colored by f) may fail, as there may be no (o1,o2,o3,o4) ∈ Ext_{τ_b ⊙ τ_c} with E(β2,o1). Hence the endpoint separator must be aligned with the interior Out-sets.

Claim (corrected endpoint-aware Stage-1 certificate for oriented paths)
- Augmented endpoint witnesses aligned to Out-sets:
  • g_L: T × {0,1}^2 × T_long → Σ_out^2. For g_L(τ_end,s,τ_b)=(β1,β2) require: (i) βi∈A_{s[i]} and E(β1,β2); (ii) V_left[τ_end][β1]=true; (iii) β2 ∈ OutR2(τ_b,s).
  • g_R: T_long × {0,1}^2 × T → Σ_out^2. For g_R(τ_c,s,τ_end)=(β1,β2) require: (i) βi∈A_{s[i]} and E(β1,β2); (ii) V_right[β2][τ_end]=true; (iii) β1 ∈ OutL1(τ_c,s).
- Feasible mid-separator function f_mid: as in output.md (Out-set form over T_long), with universal extendibility checked via W_{b⊙c}.
- Theorem S1-path (equivalence; oriented paths). An r=1, β-normalized LCL on globally oriented paths has deterministic complexity o(n) iff there exist (f_mid,g_L,g_R) satisfying the above. Verification is in nondeterministic 2^{poly(β)} time.

Proof sketch (auditable pieces)
- (⇒) Existence. Given an o(n)-round algorithm A:
  • f_mid: As in output.md (cycle gadget + pumping). Well-definedness uses that we pump to length in [s,s+ℓ_pump] and choose IDs inside the <0.1s halos.
  • g_L: For any (τ_end,s,τ_b), form a path consisting of a long pumped block of type τ_b to the right, the 2-node separator S with input s, and a left endpoint block of type τ_end; pad far outside S so A’s runtime halo is contained. Set g_L(τ_end,s,τ_b) to A’s 2-node output on S. Then: (i) node/window legality holds by correctness of A; (ii) V_left holds because the seam into τ_end is satisfied in A’s run; (iii) alignment β2∈OutR2(τ_b,s) holds by construction since S’s right output was produced in a context of type τ_b, i.e., it is one of the attained second outputs for τ_b under f_mid with input s. Define g_R symmetrically.
- (⇐) Construction of an O(log* n) algorithm.
  • Place separators by an MIS on the K-th power of the directed path in O(log* n) rounds with K := ℓ_pump+4. Standard properties ensure that the distance between neighboring separators is in [K,2K], and that the long contexts abutting each interior side are T_long.
  • Label interior separators by f_mid (using local s and adjacent long types τ_b,τ_c). Use the precomputed matrix W_{b⊙c} to fill each interior middle block between two separators by choosing a witness in Ext_{τ_b⊙τ_c} consistent with the seams.
  • Endpoints: Let S_left be the unique separator adjacent to the left end. Compute τ_end (type of the left end-block) and τ_b (long type on S_left’s right). Color S_left by g_L(τ_end,s,τ_b). By V_left there is (o1,o2,o3,o4)∈Ext_{τ_end} with E(o4,β1), so we fill the endpoint block. For the block between S_left and the nearest interior separator S2, by (iii) the outward seam color β2 is in OutR2(τ_b,s), while the left seam color from S2 lies in OutL1(τ_c,s2). Hence W_{b⊙c}[β2][α_R] is true and the block is fillable via Ext_{τ_b⊙τ_c}. Do the right end symmetrically with g_R. Runtime is O(log* n); all fillings are constant-radius lookups in precomputed tables.

NEXPTIME verification details
- Precompute deterministically in 2^{poly(β)} time:
  • T, T_long via BFS (Prop. 9) and Ext_τ for τ∈T; use Prop. 19 to implement k_flag≥4 appends in O(β^4).
  • Ext_{τ_b⊙τ_c} for τ_b,τ_c∈T_long via Prop. 5, and W_{b⊙c}.
  • V_left, V_right from endpoint projections (as in output.md).
  • OutR2(τ_b,s), OutL1(τ_c,s) sets from f_mid.
- Guess f_mid, g_L, g_R. Verify:
  • For all entries: node legality and E on the 2-node window.
  • f_mid universal extendibility via W_{b⊙c} (Out-set form; Lemma 20).
  • g_L: V_left[τ_end][β1]=true and β2 ∈ OutR2(τ_b,s). g_R: V_right[β2][τ_end]=true and β1 ∈ OutL1(τ_c,s).
- All checks are constant-time table lookups; total number of cases is |T_long|^2·4 for f_mid and (|T|·|T_long|)·4 for each endpoint map; overall time 2^{poly(β)}.

Small example illustrating necessity of alignment
- Let Σ_out={a,b}, A_0=A_1=Σ_out, and E contains only edges a→a and b→b. Suppose a feasible f_mid exists that always outputs (a,a), hence OutR2(τ_b,s)={a}. Choose τ_end with RightColors(τ_end)={a,b}. If g_L(τ_end,s) outputs (b,a), V_left holds (since E(b,b) and b∈RightColors(τ_end)) but β2=a… OK here it matches. Now flip: define f_mid that always outputs (b,b), so OutR2={b}, but g_L outputs (a,a). V_left still holds if a∈RightColors(τ_end), yet β2=a∉OutR2. There is no guarantee that the endpoint–interior block can be completed respecting the next separator colored according to f_mid. This shows (iii) is required.

Additional small lemmas/propositions to add (self-contained)
- Endpoint–interior bridging lemma. Given τ_b,τ_c∈T_long, inputs s1,s2, and endpoint-adjacent separator colors α_L,α_R with α_L∈OutR2(τ_b,s1), α_R∈OutL1(τ_c,s2), there exists a completion of the intervening block consistent with both seams iff W_{b⊙c}[α_L][α_R]=true. Proof: by definition of W_{b⊙c}; direction “only if” follows by restricting any legal completion; “if” follows by taking the witnessing (o1,o2,o3,o4)∈Ext_{τ_b⊙τ_c}.
- Preprocessing remark (tightening Prop. 9). Using Prop. 19, the k_flag≥4 append step is O(β^4), so the BFS enumeration can cite O(β^4) per transition in the long regime; short base-case transitions remain O(β^4).

Implementation notes and counts
- OutR2/OutL1 sets have size ≤β; precompute once per (τ, s). For faster Stage-1 checks, one can precompute for each (τ_b,τ_c,s1,s2) the β×β mask W_{b⊙c} and then just iterate over α_L in OutR2(τ_b,s1) and α_R in OutL1(τ_c,s2).
- Endpoints: the verification size of g_L is |T|·|T_long|·4 entries; g_R symmetric. Sparse E can reduce preprocessing time for W and V matrices.

Explicit gaps to address in output.md
- Integrate the corrected Stage-1 path theorem (S1-path) with (f_mid,g_L,g_R) as above, and add the (⇒) and (⇐) proofs specialized to globally oriented paths.
- Add the endpoint–interior bridging lemma stated above; it is just an unpacking of W_{b⊙c} and will clarify the fill of the first interior block.
- Tighten Prop. 9’s complexity to use Prop. 19 (O(β^4) per long append).
- Note that Lemma 11 subsumes Lemma 2; consider merging references.
- Clean up numbering: avoid multiple “Proposition 6/6A/6B”.

Next steps
- Promote S1-path into output.md with full statement and auditable proofs, together with the augmented endpoint witnesses. Update the classification logic: if Stage-1 fails, classify Ω(n); if Stage-1 holds but Stage-2 certificate fails, classify Θ(log* n); if Stage-2 holds, classify O(1).
- Prepare unit tests: (i) synthetic instances where OutR2 is singleton and g_L is misaligned; the augmented certificate must reject; (ii) equality LCL (accept both stages); (iii) proper 2-coloring (accept Stage-1, reject Stage-2).
- Return to Stage-2: port the (ℓ_width,ℓ_count,ℓ_pattern)-partition to oriented paths with explicit parameters and a short self-contained proof, then finalize the per-type boundary interface certificate Q_τ.

## Round 0010 — 2025-08-27T19:46:44.278526Z

Round 0010 — audits after integrating S1‑path; minor fixes, endpoint extraction hygiene, and incremental lemmas for endpoint projections

Audit of output.md (gaps, small bugs, and numbering)
- Numbering consistency. There are now four “Proposition 6/6A/6B/7” base rules: 6 (k=1→2), 6A (k_flag=1 append), 6B (k=2→3), 7 (k=3→4). This is fine logically but confusing; consider renumbering or grouping the three base updates together (k=1→2, 2→3, 3→4) and listing the k_flag=1 append normalization as a lemma.
- Proposition 9 complexity text still says O(β^5) per long append, while a later correction notes O(β^4) via Proposition 19. Please reconcile in the body of Prop. 9 (replace O(β^5) with O(β^4) for k_flag≥4) so the main statement matches the correction.
- S1‑path (⇒) endpoint extraction: the proof says “run A on w_{τ_end} · S(s) · w_{τ_b} with padding beyond distance R on both sides”. Here τ_end ranges over T (short and long), but w_τ is only defined for τ∈T_long in the pumping construction. Also, for an endpoint there is no left padding beyond the path boundary. This is easily fixed by: (i) replacing w_{τ_end} with “an arbitrary path P_end realizing Type τ_end” (short allowed), and (ii) only padding on the right by choosing w_{τ_b} long enough so the R‑neighborhood around S is contained in w_{τ_b} on its right side; on the left side the endpoint may lie inside the halo, which is intended. The extraction remains valid and captures the true endpoint behavior.
- Minor duplication: Lemma 2 (k_flag≥4 concatenation) is subsumed by Lemma 11 (all k_flags). A note that Lemma 11 subsumes Lemma 2 would avoid potential confusion.

Endpoint mechanics — incremental, checkable additions
1) Fast incremental updates for endpoint projections under append (k_flag≥4)
- Statement. For τ with k_flag(τ)≥4 and τ′=τ·a,
  • LeftColors(τ′) = LeftColors(τ).
  • RightColors(τ′) = { y ∈ A_a : ∃ x1,x2,x3 with Left3_τ[x1,x2,x3]=true and E(x3,y) }.
- Why useful. Lets the verifier update V_left/V_right incrementally during δ‑BFS using the already‑precomputed Left3_τ, avoiding recomputing projections from scratch (O(β^3) instead of scanning all β^4 quadruples).
- Proof sketch. LeftColors projects the first coordinate, which is unaffected by appending a new node at the right. RightColors of τ′ consists of those y that can appear as new R1; by Lemma 1, (x1,x2,x3,y)∈Ext_{τ′} iff Left3_τ[x1,x2,x3] and E(x3,y) and y∈A_a.

2) Endpoint allow sets as E‑neighborhoods (explicit identities)
- Identities. L_allow(τ) := {α : V_left[τ][α]} = N_E(RightColors(τ)), and R_allow(τ) := {α : V_right[α][τ]} = N_E^{-1}(LeftColors(τ)).
- Why useful. Makes explicit that V_left/V_right are just one‑step E‑blowups of the endpoint projections; convenient for unit tests and caching.
- Proof. By the definitions of V_left/V_right and LeftColors/RightColors.

3) Early infeasibility filters for Stage‑1 verification (constant‑time table checks)
- Filter F1 (interior Out‑sets nonempty). If there exist τ_b,s with OutR2(τ_b,s)=∅ or τ_c,s with OutL1(τ_c,s)=∅, then no feasible f_mid can exist — reject.
- Filter F2 (endpoint alignment reachability). For any τ_end,τ_b,s, if L_allow(τ_end)=∅ or OutR2(τ_b,s)=∅, then any g_L(τ_end,s,τ_b) is impossible. Symmetric for g_R.
- Why useful. Fast rejections before scanning W_{b⊙c} matrices; reduces witness search space.
- Justification. Trivial from definitions of Out‑sets and V_left/V_right.

4) Endpoint extraction hygiene for S1‑path (⇒) — revised, auditable phrasing
- Current line: “run A on w_{τ_end} · S(s) · w_{τ_b} … with padding on both sides.”
- Revised statement (suggested edit). For each (τ_end∈T, s, τ_b∈T_long): pick any finite path P_end with Type(P_end)=τ_end; pick w_{τ_b} long (as in the f_mid construction) so that the radius‑R halo of S lies entirely inside w_{τ_b} on the right. Run A on the finite path P := P_end · S(s) · w_{τ_b} (no left padding beyond the endpoint). Define g_L(τ_end,s,τ_b) as the output on S. Local correctness implies (i) node/edge legality. Since the seam edge from P_end into S is respected, V_left[τ_end][β1] holds (ii). Because the right context is of Type τ_b and the halo on that side is entirely inside w_{τ_b}, the second output belongs to OutR2(τ_b,s) (iii). Symmetric for g_R.
- Why this matters. It removes reliance on w_{τ_end} (undefined if τ_end is short) and avoids padding past the endpoint.

Concrete, testable lemmas to consider adding
- Lemma E3 (Bridging equivalence, restated as set inclusion). For τ_b,τ_c and inputs s1,s2, define the seam‑reachable pair set
  R̂_{b⊙c}(s1,s2) := { (α_L,α_R) : W_{b⊙c}[α_L][α_R]=true }.
  Then feasibility of f_mid is equivalent to the pairwise inclusions
  OutR2(τ_b,s1) × OutL1(τ_c,s2) ⊆ R̂_{b⊙c}(s1,s2) for all τ_b,τ_c,s1,s2.
  Proof: Unpack Lemma 20 and Prop. 21.
- Lemma E4 (Endpoint–interior block fill, explicit construction). Given g_L(τ_end,s,τ_b)=(β1,β2) satisfying (i)–(iii) and an interior separator S2 with color pair (α1,α2)=f_mid(τ_c,s2,τ_d), the intervening block between the endpoint separator and S2 admits a completion. Construction: pick (o1,o2,o3,o4) from Ext_{τ_b⊙τ_c} witnessing W_{b⊙c}[β2][α1], then fill by Ext_{τ_b⊙τ_c}; correctness follows from Lemma E2.

Small example to document the need for endpoint alignment (suggested to add as a remark)
- Let Σ_out={a,b}, A_0=A_1=Σ_out, E={(a,a),(b,b)}. Suppose f_mid always outputs (b,b), thus OutR2={b}. Take τ_end with RightColors(τ_end)={a}. If one chose g_L(τ_end,s,τ_b)=(a,a) based only on V_left (true) but ignored alignment (β2∈OutR2), the adjacent interior block would require W_{b⊙c}[a][·], which can be false, and the construction would fail. The alignment clause (iii) prevents this.

Implementation notes (verifier/solver side)
- Precompute Left3_τ during δ‑BFS and use the identities in item 1) to maintain RightColors(·), LeftColors(·), thus V_left/V_right, in O(β^3) per long append.
- For endpoint maps, precompute bit‑sets L_allow(τ) and R_allow(τ) once; checking g_L/g_R then reduces to:
  • membership in A_{s[i]} and E on the 2‑node window (constant time),
  • β1 ∈ L_allow(τ_end) or β2 ∈ R_allow(τ_end),
  • β2 ∈ OutR2(τ_b,s) or β1 ∈ OutL1(τ_c,s).
- Speed hint: during f_mid verification, build per‑pair masks M_{b⊙c}(s1,s2) := {α_L}×{α_R} for α_L∈OutR2(τ_b,s1), α_R∈OutL1(τ_c,s2), and check that M_{b⊙c}(s1,s2) ⊆ R̂_{b⊙c}(s1,s2); if not, report the first violating pair, making counterexamples easy to extract.

Next steps toward full trichotomy (O(1) vs Θ(log* n) vs Θ(n))
- Stage‑2 on oriented paths. Bring in a path‑specialized version of the (ℓ_width,ℓ_count,ℓ_pattern)‑partition (paper’s Lemma 22) with explicit constants compatible with ℓ_pump; then formalize the per‑type tiling witness Q_τ and the constant‑round construction. The checks already sketched in earlier rounds (tiling within τ, universal bridging across τ_S via Ext) should carry over verbatim with our Ext/W machinery.
- MIS on K‑th power (for completeness). Add a brief lemma that on globally oriented paths one can compute an MIS of the K‑th power in O(log* n), and that consecutive MIS nodes are at distance in [K,2K]; cite folklore or include a 3‑line proof via Cole–Vishkin coloring and greedy thinning. This makes the spacing claim in S1‑path fully self‑contained.
- Regression tests. Extend the harness to check:
  • Incremental RightColors/LeftColors updates vs direct projection of Ext after append.
  • S1 verification equivalence in Lemma E3 form (set inclusion) using precomputed R̂_{b⊙c}.
  • Endpoint misalignment: synthesize instances violating (iii) and confirm rejection.
  • Prop. 9 runtime constants: confirm O(β^4) append for k_flag≥4 against O(β^5) brute force on β∈{2,3}.

Why these are incremental and auditable
- Each lemma is a one‑line identity following mechanically from already‑defined objects (Ext and its slices). They admit direct unit tests on small β.
- The endpoint extraction hygiene is a textual correction with unchanged logic; it prevents an uninstantiated symbol (w_{τ_end}) and avoids padding past the endpoint while preserving the argument.
- The feasibility filters F1/F2 are immediate consequences of definitions, implementable as constant‑time table emptiness checks.

Open items (to track)
- Decide whether to keep both Lemma 2 and Lemma 11; if both retained, add an explicit “Lemma 11 subsumes Lemma 2” note.
- Normalize base‑case numbering to avoid 6/6A/6B confusion.
- Integrate the MIS‑on‑Kth‑power statement and the Stage‑2 partition lemma specialized to oriented paths to complete the constant‑time classification.

## Round 0010 — 2025-08-27T19:47:47.645358Z

Round 0010 — audit of output.md, endpoint-cleanup notes, and a concrete Stage‑2 plan for oriented paths (O(1) vs Θ(log* n))

Audit of output.md (gaps, inconsistencies, and easy fixes)
- Duplicate/contradictory remarks on Stage‑1: There is still a “Remark (Stage‑1 equivalence pending endpoint treatment)” before Lemma E2, but Theorem S1‑path later resolves endpoint issues. This is now inconsistent. Suggested fix: remove or rewrite the earlier remark to forward‑reference Theorem S1‑path.
- Numbering collisions and duplication:
  • Proposition 6, 6A, 6B all exist; 6 and 6B both are base cases (k=1→2 and k=2→3) and 6A is another base case (k_flag=1 variant). Consider renumbering to 6 (k=1→2), 7 (k=2→3), 8 (k=3→4), or add clear “(Base cases)” headers to avoid confusion.
  • Concatenation appears as Lemma 2 (k_flag≥4) and Lemma 11 (all k_flag). Lemma 11 strictly subsumes Lemma 2; a short note stating “Lemma 11 subsumes Lemma 2” would prevent confusion.
- Transition‑cost mismatch: Proposition 9 still states “Each transition costs O(β^5) in the k_flag≥4 regime,” while a later “Correction to Proposition 9” paragraph records the improved O(β^4) bound (via Proposition 19). These must be aligned; keep the O(β^4) bound in the definitive statement of Proposition 9.
- Small‑n fallback in Theorem S1‑path (⇐): It says “0 or 1 separators handled by brute‑force completion using Ext tables in constant radius.” This is plausible, but a one‑line lemma would clarify that any path of length < K can be labeled (or rejected) by a constant‑time rule derived from Ext (finite lookup radius K). This would parallel Lemma E2’s style, ensuring no gap at tiny n.
- Orientation/convention reminder: Theorem S1‑path relies on the global convention (L1,L2,R2,R1); all seam references are consistent with earlier definitions. No action, but a short “Indexing reminder” near Definition of OutR2/OutL1 would help readers.

Endpoint coupling in Stage‑1 — sanity check on the new content
- The strengthened endpoint witnesses g_L(τ_end,s,τ_b), g_R(τ_c,s,τ_end), with (iii) β2∈OutR2(τ_b,s), β1∈OutL1(τ_c,s), are now integrated and correctly cover the first/last interior block via W_{b⊙c}. This closes the earlier gap.
- Preprocessing coverage is complete: T and T_long (Prop. 9), Ext (Lemmas 1, 11), W (Prop. 21), V_left/V_right (Lemma E1), and OutR2/OutL1 are all defined. The NEXPTIME verification clause is sound.

Stage‑2 on globally oriented paths (O(1) vs Θ(log* n)) — proposed path‑specific certificate and theorem
Rationale. To complete the trichotomy with a single‑exponential (in β) nondeterministic verifier, it is convenient to mirror the paper’s Section 4.4 feasible‑function framework, specialized to oriented paths. This avoids having to synthesize interior outputs from bare boundary quadruples and leverages the (ℓ_width,ℓ_count,ℓ_pattern) partition (Section 4.3 in the paper) in O(1) rounds.

Definitions (path specialization; reusing the paper’s Gw,z and Gw1,w2,S)
- Fix r=1 and ℓ_pump=|T| from Prop. 9. For any 1≤|w|≤ℓ_pump and z≥0, Gw,z is the path wr · wz · wr with complete output labeling f0(w)^{z+2r} (here f0 is a Stage‑2 function; see below). Mid(Gw,z): the central wz.
- For any w1,w2 with 1≤|wi|≤ℓ_pump and any S (possibly empty), Gw1,w2,S is the path w1^{ℓ_pump+2r} · S · w2^{ℓ_pump+2r} with a partial labeling that fixes the first 2r|w1| outputs to f0(w1)^{2r} and the last 2r|w2| outputs to f0(w2)^{2r}. Mid(Gw1,w2,S): w1^{ℓ_pump+r} · S · w2^{ℓ_pump+r}.
- Stage‑2 feasible function for paths. A map f0: {w ∈ Σ_in^k : 1≤k≤ℓ_pump} → Σ_out^k is path‑feasible if:
  (F1) For each w, the complete labeling f0(w) is locally legal, and for Gw,1 the labeling is locally consistent on Mid(Gw,1). (Equivalently, Gw,z is locally consistent on its mid for all z≥1.)
  (F2) For each Gw1,w2,S, there exists a completion L⋄ that is locally consistent on Mid(Gw1,w2,S).
Remark. This is the path analogue of the cycle notion used in the attached paper (Lemmas 23–27), with the same quantitative parameters (ℓ_pump) and “mid‑block extendibility” semantics; the only change is that we do not wrap ends.

Theorem S2‑path (O(1) vs Θ(log* n) on oriented paths; verifiable in NEXPTIME)
- Statement. An r=1 β‑normalized LCL on globally oriented paths has deterministic LOCAL complexity O(1) iff there exists a path‑feasible function f0. Otherwise, if Theorem S1‑path holds but no f0 exists, the complexity is Θ(log* n).
- (⇒) Given an O(1)‑round algorithm A, extract f0 as in the paper’s Lemma 24: for each 1≤|w|≤ℓ_pump, simulate A on wi · w^{2r+1} · wi with distinct IDs confined to a constant halo; define f0(w) as A’s outputs on w (one period). Local legality implies (F1), and by the same mid‑block simulation trick, (F2) holds for all Gw1,w2,S (replace the two long contexts by pumped canonical representatives so that the constant runtime halos are disjoint). This is the path version of Lemmas 24–25.
- (⇐) Given f0, compute in O(1) rounds an (ℓ_width,ℓ_count,ℓ_pattern)‑partition tailored to oriented paths (paper’s Lemma 22; orientation is given, so Lemma 19’s orientation step is unnecessary): short paths of length ≤2ℓ_width get explicit ranks; long paths P are repetitions wk with primitive w, |w|≤ℓ_pattern and k≥ℓ_count, and each node knows w. Label as follows:
  • For each long P with period w, label the central window of length 2r in every period occurrence by f0(w) (anchored and repeated), thereby fixing a 2r‑spaced set of “mid blocks” across P.
  • The remaining subpaths between these mid blocks (and any adjacent short/irregular segments) have total length O(ℓ_width+ℓ_pattern)=O(1). For each such S with adjacent periodic contexts represented by w1 and w2, apply (F2) to Gw1,w2,S to complete S locally. (Ends of the path are treated similarly, with one side lacking a further context; in that case the partially labeled path is a prefix/suffix of Gw1,w2,S and is handled within the same constant‑radius templates.)
  • All fillings are constant‑radius choices from precomputed tables indexed by (w1,S,w2), exactly as in the cycle proof.
  Hence a deterministic O(1) algorithm exists.
- NEXPTIME verification. As in Lemma 23, checking path‑feasibility of f0 reduces to finitely many Gw,1 (one z=1 per w) and finitely many Gw1,w2,S, where S ranges over a representative per Type τ (Lemmas 11 and 14 guarantee a choice with |S|≤ℓ_pump), plus S=∅. With T enumerated (Prop. 9) and Ext computed (Props. 5, 19), all checks are boolean table lookups; total time 2^{poly(β)}.

Endpoint handling in Stage‑2
- Unlike Stage‑1, Stage‑2’s construction does not require special endpoint witnesses: every short/irregular segment, including the two end segments, falls under the Gw1,w2,S completion rule with one or both contexts being (constant‑size) pumped fragments. No extra V_left/V_right matrices are needed; the end segments are simply instances of S.

Relation to the earlier Q_τ approach
- The boundary‑quadruple certificate Q_τ (with bridging across arbitrary τ_S) is intuitively sufficient but requires embedding a per‑type interior filler to produce node outputs in O(1). The f0‑based approach avoids this extra layer and follows the attached paper’s decidable formulation; both are single‑exponential in β. We suggest integrating S2‑path using f0 for clarity and alignment with the literature.

Mini‑lemmas to consider adding (short, testable)
- Tiny‑path completion lemma. Any path of length < K := ℓ_pump+4 is solvable or rejectable in constant radius by enumerating all candidates in Ext for its Type. This justifies the small‑n fallback in S1‑path and S2‑path.
- Orientation‑specialized (ℓ_width,ℓ_count,ℓ_pattern) partition. State the oriented‑path version (derivable from the paper’s Lemma 22 without re‑orienting) with explicit parameters ℓ_width=ℓ_pattern=ℓ_pump and ℓ_count=2ℓ_pump+2.

Sanity checks and examples for S2‑path
- Equality LCL (E={(c,c)}, A_0=A_1={c}). Take f0(w)≡c^{|w|}. Gw,1 and all Gw1,w2,S mid‑blocks are trivially consistent. Classified O(1) (agrees with S1‑path acceptance).
- Proper 2‑coloring on oriented paths. f0 cannot satisfy (F1) across Gw,1 (mid‑block requires a consistent 2r window under period‑1), so S2‑path rejects; S1‑path accepts with f_mid, hence Θ(log* n).

Actionable next steps for output.md
1) Add S2‑path (Stage‑2 theorem for oriented paths) using the f0 certificate: definitions of Gw,z and Gw1,w2,S, the feasibility conditions (F1)–(F2), the two directions of the equivalence, and the NEXPTIME verification argument.
2) Insert the oriented‑path (ℓ_width,ℓ_count,ℓ_pattern) partition statement with parameters and a short proof sketch (pointing to the paper’s Lemmas 20–22, noting global orientation simplifies the orientation step).
3) Clean up numbering and the lingering Stage‑1 remark; align Prop. 9’s transition cost to O(β^4) where referenced.
4) Optionally add the tiny‑path completion lemma to justify the small‑n fallback.

Why this is incremental and auditable
- All added checks for S2‑path reduce to Ext‑table membership (finite, precomputable) and pumping lemmas already in output.md; the structure matches the paper’s decidable formulation (Lemma 23). The verifier modifications (table sizes, enumeration scopes, and complexity bounds) remain within 2^{poly(β)}.
- The proposed edits are localized: no changes to S1‑path content, just removal of an obsolete remark and consistency fixes, plus the new S2‑path section with explicit definitions and a proof outline tied to existing lemmas.



=== summary.md ===

## round-0001 — model summary — 2025-08-27T11:03:04.494639Z
This round specialized the paper's feasible-function framework to radius-1, β-normalized LCLs on globally oriented paths and developed an explicit single-exponential finite-state abstraction (types). We proved a type-count bound |T| ≤ 16·2^{β^4}, gave a deterministic DP to enumerate reachable types and compute the append-one-bit successor δ in time 2^{poly(β)}, and defined per-type macro relations R_t summarizing how a block bridges outside outputs. Using these primitives we sketched NEXPTIME verifiers: (i) guess a type-indexed feasible function F to separate Ω(n) vs o(n); (ii) guess per-type boundary quadruples Q_t to separate O(1) vs Ω(log* n). The Verifier flagged a critical soundness gap: naive composition of R_t via an intermediate label m is unsound — one must compute concatenated summaries (Ext) and derive R for the concatenation (a small 3-color counterexample demonstrates the failure). Next steps are to formalize/correct δ, fix bridging composition, and prove the boundary-interface witness equivalence.

## round-0002 — model summary — 2025-08-27T12:05:19.309268Z
Round 0002: fixed the r=1 DP and repaired verifier soundness. Derived an exact append-one-bit recurrence for Ext-tables with explicit k=1,2,3 base cases and proved append-congruence (with the practical caveat that types must carry a k_flag for short lengths). Replaced the unsound R-composition by an Ext-level concatenation lemma and supplied a minimal 3-symbol counterexample (a→b→c). Gave a deterministic BFS to enumerate reachable types (type = (b_in, Ext, k_flag)), bounded |T| ≤ 16·2^{β^4} and O(β^5) per-append, so preprocessing is 2^{poly(N)}. Rewrote both NEXPTIME verifiers (Ω(n) vs o(n) and O(1) vs Ω(log* n)) to use Ext-concatenation with explicit universal checks and provided pseudocode. Remaining polishing: fix the k=2 base-case wording, add unit/regression tests, and complete a full equivalence proof for the boundary-interface witness. Files: prover-01.out.json, prover-02.out.json (Round 0002) and verifier summary.

## round-0003 — model summary — 2025-08-27T14:56:35.613633Z
This round closes two formalization gaps from outputs.pdf and records an optimization. Stage-1: a type-level feasible-function f : T × {0,1}^2 × T → Σ_out^2 is defined with (i) local node constraints and (ii) a universal Ext-concatenation membership condition across separators; existence of f is verifiable in NEXPTIME by computing T and Ext-tables and nondeterministically guessing f. The definition is argued equivalent to the paper’s feasible function (both directions). Stage-2: each type τ gets a boundary-interface witness Q_τ=(L1,L2,R2,R1) with checks (a) local tiling via Ext_τ and wrap-around E, and (b) bridging across any middle type τ_S via Ext membership; if all checks pass the instance is O(1), if Stage-1 passes but Stage-2 fails it’s Θ(log* n), else Θ(n). Optimization: concatenation time reduced from O(β^8) to O(β^6) by precomputing Left/Right 3D slices per type. Examples and endpoint/orientation notes included. Next steps identify formal proofs, the faster routine, and a small regression suite. Citations: prover-01.out.json (progress_md), outputs.pdf.

## round-0004 — model summary — 2025-08-27T15:04:44.798705Z
Round 0004 audit: outputs.md now records the core r=1 ingredients with complete proofs for the high-k append recurrence (k_flag≥4), Ext-level concatenation, congruence (type preserved under append), an explicit counterexample showing R-composition via ∃m is unsound, and an O(β^6) concatenation routine via 3D slices. Missing/needed pieces were identified and concrete additions proposed: an explicit k=1→2 base rule to seed the DP; a deterministic BFS enumeration of Types T and a proof that δ is well-defined with complexity bounds; a reversal operator Rev(·); precise Stage-1 (feasible table f and the o(n)⇔existence-of-f equivalence checked via Ext_{τ⊙σ}); precise Stage-2 (per-type witnesses Q_τ, universal bridging checks, and a constant-round construction); optional Ext_{∅} handling; small sanity/regression tests and an appendix with O(β^6) implementation details. Action items: promote sections 1–5 into outputs.md, add the concatenation appendix, and add regressions (β∈{2,3}). Citations: prover-01.out.json (progress_md); outputs.md (Round 0004).

## round-0005 — model summary — 2025-08-27T15:13:04.337690Z
This round produced a near-complete specification and verification plan for the r=1 oriented-path decision procedure. Key additions: a computable pumping bound ℓ_pump := |T| with two pumping lemmas (prefix and periodic) that let us normalize and lengthen contexts while preserving Types; a general Ext-concatenation lemma (handles short k_flag types) plus associativity and a monotonicity lemma; a Stage-1 theorem S1 equating o(n) complexity with existence of a feasible per-type function f over long types T_long (k_flag≥4), together with an O(log* n) construction and NEXPTIME verifier; and a Stage-2 theorem S2 showing that per-type boundary interfaces Q_τ certify O(1) solvability, with bridging checks that use Ext tables and handle short middle types. Implementation notes cover restricting left/right quantification to T_long, precomputing/caching Ext tables, and verifier complexity (2^{poly(β)}). The verifier returned success. Next steps focus on integrating the lemmas and adding the MIS/partition appendix and regression tests.

## round-0006 — model summary — 2025-08-27T15:24:57.440078Z
Round 0006 audited output.md and supplied small lemmas, implementation optimizations, and sanity checks to close minor gaps in the Stage‑1 machinery. Main fixes: rewrite the δ base case for k_flag=1 using S_τ (Lemma A) so it does not rely on recovering an internal bit; add an endpoint-completion lemma to close the Stage‑1 (⇐) construction for finite directed paths (Lemma B); and rephrase feasible-function verification to quantify only over attainable seam-color sets (Lemma C). An important implementation speedup reduces append from O(β^5) to O(β^4) by precomputing 3D Left3 slices, and further preprocessing of seam-feasibility matrices W_{b⊙c} moves heavy tuple scanning into preprocessing. Sanity checks on equality LCL and 2‑coloring were noted and an actionable checklist of edits and regression tests was supplied. The Verifier returned an "uncertain" verdict. Next work: apply the documented edits, run regression tests, and resolve Stage‑2 (partition lemma vs certificate redesign).

Citations: prover-01.out.json (progress_md, Round 0006); output.md; Verifier (verdict).

## round-0008 — model summary — 2025-08-27T18:55:32.759824Z
Round 0008: Two provers independently supply the missing endpoint handling and a Stage‑2 certificate specialization for globally oriented paths. They identify and give the explicit k=2→3 base-case needed for the δ DP seed; introduce RightColors/LeftColors and endpoint seam matrices V_left and V_right (Lemma E1) computed from Ext tables to reduce endpoint feasibility to constant-time lookups; and define endpoint witnesses g_L and g_R to accompany the mid-separator feasible function f_mid. Theorem P‑S1 (aka S1‑path) states: an r=1, β‑normalized LCL has deterministic complexity o(n) on oriented paths iff (f_mid,g_L,g_R) satisfying Ext/W_{b⊙c}/V_left/V_right checks exist — existence verifiable in nondeterministic time 2^{poly(β)}. They also propose a Stage‑2 per-type boundary interface Q_τ giving an O(1) construction when tiling/bridging conditions hold, with similar NEXPTIME verification. Action items: insert k=2→3, endpoint projections/matrices and Lemma E1, plus the endpoint-aware Stage‑1 and Stage‑2 statements into output.md. (Sources: prover-01.out.json, prover-02.out.json)

## round-0009 — model summary — 2025-08-27T19:44:21.713594Z
Round 0009 fixes the Stage‑1 certificate for r=1 LCLs on globally oriented paths by coupling endpoint witnesses to interior Out-sets. The main change: g_L: T×{0,1}^2×T_long→Σ_out^2 and g_R: T_long×{0,1}^2×T→Σ_out^2, with three checks — node legality, endpoint seam feasibility (V_left/V_right), and alignment of the interior-directed seam with OutR2/OutL1 from f_mid. f_mid remains the interior separator map (Out-set form) and is verified universally via W_{b⊙c}. Theorem S1-path: an r=1, β-normalized LCL on oriented paths has deterministic complexity o(n) iff such (f_mid,g_L,g_R) exist; existence is verifiable nondeterministically in 2^{poly(β)} time. Proof sketches: (⇒) extract witnesses by pumping and simulating an o(n)-algorithm; (⇐) build an O(log* n) LOCAL algorithm using an MIS on the Kth power, precomputed Ext and W tables, and endpoint fills via V_left/V_right. Prop.19 lowers append costs to O(β^4) in preprocessing. A minimal counterexample shows the alignment clause is necessary. (Citations: prover-02.out.json, prover-01.out.json).

## round-0010 — model summary — 2025-08-27T19:53:26.539089Z
Round 0010 audited output.md and proposed a concrete Stage‑2 plan for globally oriented paths. Key editorial fixes were flagged (numbering collisions, Prop.9’s transition‑cost text should be O(β^4), and a tiny‑path fallback lemma to justify small‑n cases). Stage‑1 endpoint handling was cleaned up: strengthened endpoint witnesses g_L/g_R close the gap and endpoint extraction was rephrased to avoid undefined padding. A path‑specialized Stage‑2 certificate f0 (definitions Gw,z and Gw1,w2,S, feasibility conditions F1–F2) was proposed; Theorem S2‑path states O(1) iff a path‑feasible f0 exists, otherwise Θ(log* n), with NEXPTIME verifiability via finite Ext/T tables (2^{poly(β)}). Verifier optimizations (incremental Left/RightColors via Left3_τ, L_allow/R_allow identities, early infeasibility filters) and testable lemmas (tiny‑path completion, oriented partition) were suggested. Verifier verdict: partial success. Citations: prover-01.out.json, prover-02.out.json.



=== notes.md ===
Corrections and key lemmas to record

1) Correct append-one-bit recurrence (r=1)
Given a type t with Ext_t ⊆ Σ_out^4 over boundary (L1,L2,R2,R1) and an appended input bit a, the new type t′ has boundary (L1′,L2′,R2′,R1′) = (L1,L2, old R1, new), i.e., R2′ = R1 and R1′ is the label of the appended node. Formally, for each candidate quadruple (x1,x2,x3,x4) ∈ Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [x4 ∈ A_a and E(x3,x4) and ∃ z ∈ Σ_out: (x1,x2,z,x3) ∈ Ext_t].
This yields an O(β^5) DP to fill Ext_{t′} by scanning all (x1,x2,x3,x4) and checking ∃z.

Congruence lemma (needed): If Type(P)=Type(Q), then for all a ∈ {0,1}, Type(Pa)=Type(Qa). Proof sketch: The predicate “there exists an interior completion consistent with boundary assignments” over D1∪D2 is preserved under appending one node by the above DP rule, which depends only on Ext_t and a.

2) Concatenation of summaries (r=1)
If Summ(P) has Ext_P and Summ(Q) has Ext_Q, then the concatenation B=P·Q has boundary (P.left endpoint, P.left neighbor, Q.right neighbor, Q.right endpoint) and
  (o1,o2,o3′,o4′) ∈ Ext_B ⇔ ∃ x3,x4,x1′,x2′ ∈ Σ_out: (o1,o2,x3,x4) ∈ Ext_P, (x1′,x2′,o3′,o4′) ∈ Ext_Q, and E(x4,x1′).
Then R_B can be derived from Ext_B as usual.

3) Counterexample to R-composition via ∃m
Let Σ_out={a,b,c}, A_0=A_1=Σ_out. Let E={a→b, b→c} only. Suppose t_b admits a boundary tuple with right endpoint a, and t_c admits a boundary tuple with left endpoint c (interiors arbitrary but extendible). Then choose m=b. We have (x,m) ∈ R_{t_b} for any x with a valid left edge, and (m,y) ∈ R_{t_c} for suitable y. But the concatenation t_b·t_c requires the seam edge a→c, which is forbidden. Hence ∃m composition of R_t is not sound; use Ext-level concatenation and R_B instead.
Additions and fixes (r=1)

A) Correct k=2→3 base-case update
Let t=(b1,b2) and t′=t·a (length 3). Then
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [x3=x2, x1∈A_{b1}, x2∈A_{b2}, x4∈A_a, E(x1,x2), E(x2,x4)].
This replaces any prior statement that involved x2∈A_a.

B) Type representation and congruence
Define Type(t) := (b_in(t), Ext_t, k_flag(t)), where k_flag ∈ {1,2,3,≥4} indicates whether boundary coordinates coincide due to short length. Then the congruence lemma holds in the form:
  If Type(P)=Type(Q), then for all a∈{0,1}, Type(Pa)=Type(Qa).
Proof: case split on k_flag using the explicit base-case rules for k_flag∈{1,2,3} and the general append recurrence for k_flag=≥4.
Remark: Ext equality alone does not determine |t| (e.g., with E self-loops and A_0=A_1, Ext_{len 2} = Ext_{len 4}). Hence the k_flag is necessary for a length-agnostic update routine.

C) Enumeration fix
In the BFS over types, key the dictionary by the full Type(t), including k_flag. After the first transition to k_flag=≥4, all descendants remain in k_flag=≥4 and subsequent δ updates are length-agnostic.
Additions: Stage-1 and Stage-2 specifications at the Ext level (r=1, oriented paths)

Notation. Σ_out has size β. For an input word t with bits b_in(t) ∈ {0,1}^{|t|}, let Ext_t ⊆ Σ_out^4 denote the set of boundary quadruples (L1,L2,R2,R1) = (o[1],o[2],o[|t|-1],o[|t|]) that admit an interior completion o consistent with node constraints o[i]∈A_{b_in(t)[i]} and edge constraints (o[i],o[i+1])∈E. Types are Type(t)=(Ext_t, k_flag(t)), where k_flag∈{1,2,3,≥4} encodes short-length degeneracies. Concatenation of types τ⊙σ is defined by the Ext-level concatenation rule (see outputs.md) and k_flag update.

Stage-1 (Ω(n) vs o(n)): type-level feasible function
- Universe: the finite set of types T obtained by BFS from k=1 under the append-one-bit updates (keyed by (Ext,k_flag)). For τ,σ∈T, the Ext of τ⊙σ is defined by Ext-level concatenation.
- Definition (feasible f). A function f: T × {0,1}^2 × T → Σ_out^2 mapping (τ_L, s, τ_R) to (α1,α2) is feasible if:
  (i) Node/window constraints: αi ∈ A_{s[i]} for i=1,2 and (α1,α2) ∈ E (i.e., E(α1,α2) holds).
  (ii) Universal extendibility across two separators: for all τ_a,τ_b,τ_c,τ_d∈T and s1,s2∈{0,1}^2, letting α_L := second component of f(τ_a,s1,τ_b) and α_R := first component of f(τ_c,s2,τ_d), we require
      ∃ (o1,o2,o3,o4) ∈ Ext_{τ_b ⊙ τ_c} with E(α_L,o1) and E(o4,α_R).
  Comment: The quantification over τ_a and τ_d is stronger than necessary but safe; a weaker version quantifies only over τ_b,τ_c and s1,s2. Indexing uses our convention (L1,L2,R2,R1); thus o1 and o4 are the first and last outputs of the middle block of type τ_b⊙τ_c.
- NEXPTIME check: deterministically enumerate T and all Ext_{τ} and on-demand Ext_{τ⊙σ}; nondeterministically guess f; verify (i) and (ii) exhaustively. Complexity is 2^{poly(N)} in the problem description size N.
- Status: We still owe a self-contained proof that “o(n) algorithm exists iff a feasible f exists” at the Ext level (the intended replacement of the paper’s feasible-function lemma). This will rely only on our Ext-append and Ext-concat lemmas and a standard pumping argument specialized to r=1.

Stage-2 (O(1) vs Ω(log* n)): per-type boundary-interface witness
- For each τ∈T with k_flag(τ)≥4, guess Q_τ=(L1_τ,L2_τ,R2_τ,R1_τ) with Q_τ ∈ Ext_τ. Enforce:
  (a) Local consistency and tiling: E(L1_τ,L2_τ), E(R2_τ,R1_τ), and wrap E(R1_τ,L1_τ). Intuition: long blocks of type τ can be tiled by copies using the same boundary outputs.
  (b) Bridging across any middle type (including empty): for all τ_left,τ_S,τ_right ∈ T, require either
      - if τ_S has k_flag≥1: ∃ (o1,o2,o3,o4) ∈ Ext_{τ_S} with E(R1_{τ_left},o1) and E(o4,L1_{τ_right}); or
      - if τ_S is empty: E(R1_{τ_left},L1_{τ_right}).
- Decision logic: if witnesses {Q_τ} exist and pass (a)–(b), classify O(1). Else, if a Stage-1 feasible f exists, classify Θ(log* n). Otherwise, classify Θ(n).
- Status: We still owe a concrete constant-radius construction on oriented paths from {Q_τ} (e.g., a partition/tiling routine parametrized by fixed radii ℓ_width, ℓ_pattern, ℓ_count) and a proof that the produced labeling is legal. Short types (k_flag<4) are treated as separators τ_S in (b).

Faster concatenation (proven and moved to outputs.md)
- Precompute for each τ the 3D slices: Left_τ[o1,o2,x4] := ∃x3 (o1,o2,x3,x4)∈Ext_τ, and Right_τ[x1′,o3′,o4′] := ∃x2′ (x1′,x2′,o3′,o4′)∈Ext_τ.
- Then (o1,o2,o3′,o4′)∈Ext_{τ⊙σ} iff ∃x4,x1′: Left_τ[o1,o2,x4] ∧ E(x4,x1′) ∧ Right_σ[x1′,o3′,o4′]. This allows computing Ext_{τ⊙σ} in O(β^6) time after O(β^4) precomputation per type.

Sanity checks (kept as examples)
- Trivial LCL (A_0=A_1=Σ_out, E complete): Ext_τ=Σ_out^4 for all τ; Stage-2 witness exists trivially ⇒ O(1).
- Equality LCL (E={(x,x)}): take Q_τ=(c,c,c,c) ⇒ O(1).
- Proper 2-coloring: Stage-2 fails; Stage-1 feasible f should exist ⇒ Θ(log* n).
- Linear cases with incompatible seams: Stage-1 fails ⇒ Ω(n).
Updates and clarifications (r=1, oriented paths)

1) Base-case updates finalized
- k=1→2 is special and cannot be derived from the general append recurrence without over-constraining x1=x2; we record an explicit rule in outputs.md.
- k=3→4 is also added explicitly (although it follows from the same recurrence if stated for k≥2). This ensures δ can move from short types to k_flag≥4 deterministically.

2) Type-count bound corrected
Type(t) consists of (Ext_t, k_flag(t)) only; boundary input bits are not part of Type. Hence the number of types satisfies
  |T| ≤ 4 · 2^{β^4}.
The earlier 16 · 2^{β^4} bound mixed in boundary input bits unnecessarily.

3) δ well-defined and BFS enumeration
- Seeds: k=1 types for b∈{0,1} (Ext_{(b)} = {(x,x,x,x): x∈A_b}).
- Transitions: use base-cases for k<4 (1→2, 2→3, 3→4) and Lemma 1 for k≥4. By congruence, δ(Type, a) depends only on (Ext, k_flag) and a.
- Termination and complexity: at most |T| ≤ 4·2^{β^4} insertions; each append is O(β^5) in the k≥4 regime (base-cases are ≤ O(β^4)); total time/space 2^{poly(β)}.

4) Reversal operator (optional but helpful)
Define Rev(τ) = (Ext_τ^R, k_flag(τ)) with Ext_τ^R := { (y1,y2,y3,y4) : (y4,y3,y2,y1) ∈ Ext_τ }. Then Rev(Rev(τ))=τ and Ext_{Rev(τ) ⊙ Rev(σ)} = (Ext_{σ ⊙ τ})^R.

5) Stage-1 and Stage-2 (status)
- Stage-1 (Ω(n) vs o(n)): the feasible function f: T × {0,1}^2 × T → Σ_out^2 with the universal Ext-based check (seams E(α_L, o1), E(o4, α_R), using the (L1,L2,R2,R1) ordering) is the right formal object. We still need a fully self-contained proof of the equivalence “o(n) iff such f exists”.
- Stage-2 (O(1) vs Ω(log* n)): the per-type witness Q_τ∈Ext_τ for k_flag≥4 with tiling and universal bridging checks is plausible. A complete constant-radius construction on oriented paths remains to be written and verified.

6) Sanity and regression items
- β=2 trivial LCLs and equality LCL check the base-cases and concatenation routines.
- Reconfirm the 3-color counterexample for R-composition via ∃m.
- Maintain an indexing reminder: Ext quadruples are ordered (L1,L2,R2,R1); in seam checks across a middle block of type τ_b⊙τ_c, the left seam meets o1 and the right seam meets o4.
New additions (r=1, oriented paths): pumping, general concatenation, and Stage-1 equivalence

- Pumping bound and lemmas. Let T be the set of reachable types (Proposition 9) and δ: T×{0,1}→T the append transition. Define
  ℓ_pump := |T|.
  Lemma (prefix pumping). For any input w with |w| ≥ ℓ_pump there exist x,y,z with 1 ≤ |y| ≤ ℓ_pump and |xy| ≤ ℓ_pump such that Type(x y^i z) is independent of i ≥ 0.
  Lemma (periodic pumping). For any nonempty u there exist a,b with a+b ≤ ℓ_pump such that Type(u^{a+bi}) is invariant for all i ≥ 0.
  Both follow from the pigeonhole principle applied to the δ-run over Types.

- Ext-level concatenation for all k_flags and associativity. The general concatenation rule (Ext_{P·Q} witnessed by Ext_P and Ext_Q with a seam constraint E(x4,x1′)) holds verbatim for all lengths because Ext for short words already lives in Σ_out^4 with coordinate equalities enforced by k_flag. Associativity of Ext-concatenation follows semantically (concatenation of words is associative) or by rebracketing seam witnesses.

- Stage-1 (Ω(n) vs o(n)). Restrict left/right context Types to T_long := {τ∈T : k_flag(τ)≥4}. Define a feasible f: T_long×{0,1}^2×T_long→Σ_out^2 that (i) satisfies node/edge constraints on the 2-node separator and (ii) for all τ_b,τ_c∈T_long and s1,s2, and for all τ_a,τ_d∈T_long (affecting only α_L,α_R), there exists (o1,o2,o3,o4)∈Ext_{τ_b⊙τ_c} with E(α_L,o1) and E(o4,α_R), where α_L is the second output of f(τ_a,s1,τ_b) and α_R is the first output of f(τ_c,s2,τ_d). Theorem (added to output.md): an r=1, oriented-path LCL has deterministic complexity o(n) iff such a feasible f exists. Proof outline recorded in output.md: (⇒) extract f from an o(n) algorithm via pumping and a cycle-gadget; (⇐) place separators by an MIS on the K-th power of the path with K≳ℓ_pump and solve each O(K)-long block locally using the guaranteed Ext-witness; total time O(log* n).

- Stage-2 (O(1) vs Θ(log* n)). The per-type interface Q_τ∈Ext_τ (for τ∈T_long) with tiling and universal bridging checks remains a plausible certificate. However, the constant-radius partition of an arbitrary input path into “long periodic” and “short/irregular” subpaths is not yet proven in this writeup. Do not claim S2 in output.md until a self-contained partition lemma (parameters and proof) is supplied or the construction is reworked to avoid this dependency.

- Minor lemma. Nonemptiness monotonicity under concatenation: if Ext_P and Ext_Q are nonempty and there exists at least one seam pair (x4,x1′) with E(x4,x1′), then Ext_{P·Q}≠∅. This is an immediate corollary of the general concatenation rule.

Implementation notes

- Quantify over T_long for left/right contexts in Stage-1; middle types in Stage-2 can be arbitrary (short included), handled by the general concatenation lemma.
- Precompute T by BFS (Prop. 9), split T_long vs short, cache Left_τ and Right_τ for all τ, and build Ext_{τ⊙σ} for τ,σ∈T_long (Prop. 5). ℓ_pump=|T| is computable in 2^{poly(β)}.
- Separator placement for Stage-1: in O(log* n), compute an MIS on the K-th power of the directed path for K=ℓ_pump+4; distances between consecutive separators are ≤2K, ensuring each middle block is O(K)-long and solvable in O(1) rounds by exhaustive local choice of an Ext-witness–consistent interior labeling.

Open item for Stage-2

- Provide a self-contained constant-radius partition lemma on oriented paths or redesign the Stage-2 constant-round construction to avoid reliance on periodicity. Until then, keep S2 as a notes-only plan.
Endpoint handling in Stage-1 (r=1) and refinements

- Endpoint gap (to-do). The current Stage-1 (⇐) algorithm partitions the path using a K-th power MIS with K := ℓ_pump+4 and then fills each middle block between two separators using a feasible function f. This leaves one-sided end segments (from a path endpoint to the nearest separator). The proof sketch in output.md did not treat these explicitly and incorrectly asserted that every separator has long-type contexts on both sides. A separate lemma is needed to guarantee that the seam color chosen at an endpoint-adjacent separator is compatible with the end segment’s Ext set. Alternatively, redesign the partition so that every nontrivial block lies strictly between two separators, eliminating one-sided cases. Until one of these is proven, the o(n)⇔feasible-f equivalence remains open here.

- Clean k=1→2 update (no “recover b”). For a type τ with k_flag(τ)=1, let S_τ := { x ∈ Σ_out : (x,x,x,x) ∈ Ext_τ }. Then appending a bit a yields Ext_{τ·a} consisting exactly of tuples (x1,x2,x3,x4) with x1=x3, x2=x4, x1∈S_τ, x2∈A_a, and E(x1,x2). This removes the need to speak about an internal bit b and works also when A_0=A_1.

- Optimized append in O(β^4). For k_flag≥4, define Left3_t[x1,x2,x3]:=∃z (x1,x2,z,x3)∈Ext_t. Then (x1,x2,x3,x4)∈Ext_{t·a} iff Left3_t[x1,x2,x3] ∧ E(x3,x4) ∧ x4∈A_a. Precompute Left3_t in O(β^4) time and fill Ext_{t·a} in O(β^4) time (dense worst-case).

- Out-set formulation of feasibility. Given a guessed f: T_long×{0,1}^2×T_long→Σ_out^2, define
  OutR2(τ_b,s) := { second(f(τ_a,s,τ_b)) : τ_a ∈ T_long },
  OutL1(τ_c,s) := { first(f(τ_c,s,τ_d)) : τ_d ∈ T_long }.
The universal extendibility clause is equivalent to: for all τ_b,τ_c,s1,s2 and α_L∈OutR2(τ_b,s1), α_R∈OutL1(τ_c,s2), ∃(o1,o2,o3,o4)∈Ext_{τ_b⊙τ_c} with E(α_L,o1) and E(o4,α_R). This isolates the relevant seam colors and simplifies verification.

- Seam-feasibility matrices. For faster verification and construction, precompute for each pair (τ_b,τ_c) the β×β boolean matrix W_{b⊙c}[α_L][α_R] that records whether there exists (o1,o2,o3,o4) ∈ Ext_{τ_b⊙τ_c} with E(α_L,o1) and E(o4,α_R). Then the universal extendibility checks reduce to table lookups W_{b⊙c}[α_L][α_R].

- Regression checklist.
  1) Verify optimized append equals brute-force append on random small Σ_out (β≤3).
  2) Verify associativity of Ext-concatenation on random triples of types.
  3) Verify W_{b⊙c} by direct Ext scans.
  4) Sanity: equality LCL and proper 2-coloring behave as expected.
Endpoint seam projections and matrices (r=1, oriented paths)

- For any type τ, define:
  RightColors(τ) := { y ∈ Σ_out : ∃ x1,x2,x3 with (x1,x2,x3,y) ∈ Ext_τ }.
  LeftColors(τ)  := { x ∈ Σ_out : ∃ x2,x3,y with (x,x2,x3,y) ∈ Ext_τ }.
  These are just the projections of Ext_τ to coordinates R1 and L1.

- Define endpoint seam-compatibility matrices from Ext alone:
  V_left[τ][α]  := (∃ y ∈ RightColors(τ) with E(y, α)).
  V_right[α][τ] := (∃ x ∈ LeftColors(τ) with E(α, x)).

Lemma E1 (endpoint feasibility via Ext). Fix any type τ and α ∈ Σ_out.
- There exists a legal labeling of a left end-block of type τ and the adjacent separator’s first node α iff V_left[τ][α] is true.
- There exists a legal labeling of a right end-block of type τ and the adjacent separator’s second node α iff V_right[α][τ] is true.
Proof. If (x1,x2,x3,y)∈Ext_τ and E(y,α), then the end-block interior is witnessed by Ext_τ and the seam edge by E(y,α). Conversely, any legal instance provides such y. The right case is symmetric.

Endpoint gap in Stage-1 (diagnosis and fix). Our current Stage-1 construction labels interior separators using a feasible f and fills the block between them via Ext_{τ_b ⊙ τ_c} using W_{b⊙c}. For paths, the first/last interior block is bounded on one side by an endpoint-adjacent separator. If that separator is colored by an independent g_L/g_R, the right (resp. left) seam color entering the first (resp. last) interior block may lie outside the OutR2/OutL1 sets induced by f. Then the pre-verified W_{b⊙c} guarantees do not apply, and the fill of that block can fail, even if V_left/V_right holds. Hence additional coupling is required.

Corrected Stage-1 certificate for paths (proposal). Keep T_long and f as in the Out-set formulation. Replace the 2-argument endpoint maps by 3-argument ones that are aligned with the Out-sets of the adjacent long type:
- g_L: T × {0,1}^2 × T_long → Σ_out^2. For g_L(τ_end, s, τ_b)=(β1,β2) require:
  (i) node/window legality at the separator: βi ∈ A_{s[i]} and E(β1,β2);
  (ii) one-sided feasibility toward the endpoint: V_left[τ_end][β1]=true;
  (iii) alignment with interior Out-set: β2 ∈ OutR2(τ_b, s).
- g_R: T_long × {0,1}^2 × T → Σ_out^2. For g_R(τ_c, s, τ_end)=(β1,β2) require:
  (i) node/window legality and E(β1,β2);
  (ii) one-sided feasibility toward the endpoint: V_right[β2][τ_end]=true;
  (iii) alignment with interior Out-set: β1 ∈ OutL1(τ_c, s).

With these constraints, the MIS-based O(log* n) construction proceeds as before:
- Label every interior separator by f; label the endpoint-adjacent separators using g_L/g_R (using the computed adjacent long types τ_b, τ_c on their interior sides). Fill end-blocks using Lemma E1.
- For the blocks between an endpoint-adjacent separator and its nearest interior separator, use the same W_{b⊙c} check as for interior blocks, with α_L := second(g_L(…)) or α_R := first(g_R(…)). By (iii), α_L ∈ OutR2(τ_b,·) and α_R ∈ OutL1(τ_c,·), so the precomputed W_{b⊙c} guarantees existence of a witness in Ext_{τ_b ⊙ τ_c}.

Necessity (⇒) sketch under the corrected certificate. Given an o(n)-round algorithm A:
- Extract f from A as in the cycle case (pumping + concatenation).
- For each (τ_end, s, τ_b), build a path consisting of a long pumped block of type τ_b to the right, the separator with input s, and an endpoint block of type τ_end on the left (plus pumped padding as needed outside the radius of A). Let g_L(τ_end,s,τ_b) be A’s output on the separator. Pumping ensures well-definedness and (iii). The V_left constraint follows because the seam into the endpoint segment is satisfied by A. Symmetrically define g_R.

Verification remains in 2^{poly(β)}: T, T_long, Ext, W_{b⊙c}, V_left, V_right, OutR2/OutL1 are all precomputable. The guessed tables f, g_L, g_R are checked entrywise.

Action items.
- Integrate Lemma E1 and the V_left/V_right definitions into outputs.
- Replace the current endpoint witness proposal by the 3-argument version and update both directions of the Stage-1 path theorem accordingly.
- Keep Stage-2 items in notes until a self-contained partition lemma for oriented paths is written.
Endpoint‑coupled Stage‑1 for oriented paths: resolution and integration

- Gap recap. Our earlier Stage‑1 (o(n) vs Ω(n)) write‑up did not handle the endpoint‑adjacent separators. Labeling endpoints independently (even with V_left/V_right checks) can misalign the “open” seam color toward the interior with the Out‑sets induced by the interior feasible function f, causing the first/last interior block to be unfillable.

- Fix (now integrated into output.md). We strengthen the certificate by adding 3‑argument endpoint maps coupled to Out‑sets:
  • g_L(τ_end, s, τ_b) = (β1,β2) with: (i) node/window legality; (ii) V_left[τ_end][β1]; (iii) β2 ∈ OutR2(τ_b,s).
  • g_R(τ_c, s, τ_end) = (β1,β2) with: (i) node/window legality; (ii) V_right[β2][τ_end]; (iii) β1 ∈ OutL1(τ_c,s).
  With these, the interior block between an endpoint‑adjacent separator and the nearest interior separator is covered by the same W_{b⊙c} universal checks as for interior blocks. We added an explicit Endpoint–interior bridging lemma to make this step transparent.

- Theorem S1‑path (added). For β‑normalized r=1 LCLs on globally oriented paths, an o(n)‑round deterministic algorithm exists iff there are witnesses (f_mid, g_L, g_R) satisfying the above constraints. Proof: (⇒) extract f_mid and g_L/g_R from an o(n) algorithm using pumped canonical contexts and padding outside the runtime halo; (⇐) place separators by MIS on the K‑th power (K = ℓ_pump+4), color interior separators via f_mid and endpoint‑adjacent ones via g_L/g_R, and complete all blocks by table lookups in W and V. Verification is NEXPTIME (single‑exponential) via precomputed tables.

- Complexity tightening (recorded). Using Proposition 19 (O(β^4) append for k_flag ≥ 4), the BFS enumeration in Proposition 9 uses O(β^4) per transition in the long regime.

- Minimal obstruction template (for tests). Fix τ_b with OutR2(τ_b,s) = {α}. If an uncoupled g_L outputs β2 ≠ α while V_left holds, the first interior block can fail because W_{b⊙c}[β2][·] may be all false; coupling (iii) prevents this.

- Bookkeeping. Lemma 11 subsumes Lemma 2 (general vs k_flag≥4 concatenation). There are duplicated labels around Proposition 6/6A/6B; renumbering is recommended in a clean pass.
Addendum: Stage‑2 on oriented paths via a path‑feasible function f0 (plan and checks)

We record here a path‑specialized Stage‑2 certificate that matches the cycle proof technique in the literature and avoids embedding per‑type interior fillers.

Definitions (r=1; pumping length ℓ_pump = |T| from Prop. 9)
- For a word w with 1 ≤ |w| ≤ ℓ_pump and integer z ≥ 0, define the path Gw,z := wr · wz · wr, where wr denotes a fixed context of length r = 1 on each side, and equip it with a complete output labeling f0(w)^{z+2r} (periodic by f0(w)). Mid(Gw,z) denotes the middle wz.
- For w1, w2 with 1 ≤ |wi| ≤ ℓ_pump and any finite substring S (possibly empty), define Gw1,w2,S := w1^{ℓ_pump+2r} · S · w2^{ℓ_pump+2r} with a partial labeling that fixes the first 2r|w1| outputs to f0(w1)^{2r} and the last 2r|w2| outputs to f0(w2)^{2r}. Mid(Gw1,w2,S) := w1^{ℓ_pump+r} · S · w2^{ℓ_pump+r}.

Path‑feasible function (F1)–(F2)
- f0: { w ∈ Σ_in^k : 1 ≤ k ≤ ℓ_pump } → Σ_out^k is path‑feasible if:
  (F1) For every w, the labeling f0(w) is locally legal; moreover, the labeling of Gw,1 is locally consistent on Mid(Gw,1). (Equivalently, for all z ≥ 1, Gw,z is locally consistent on its mid.)
  (F2) For every Gw1,w2,S, there exists a completion that is locally consistent on Mid(Gw1,w2,S).

Intuition and relation to Ext/W tables
- (F1) ensures that when the short word w is periodically repeated with a unit of separation (z ≥ 1), the outputs at the mid block can be anchored by f0(w) without conflict.
- (F2) ensures that any finite irregular gap S flanked by long pumped contexts with periodic mid‑anchors f0(w1), f0(w2) can be completed using constant‑radius rules, exactly mirroring how W_{b⊙c} checks mediate between Out‑sets in Stage‑1.

Verification (NEXPTIME)
- With T and Ext enumerated (Prop. 9) and the standard pumping lemmas (Lemmas 13–14), it suffices to check finitely many Gw,1 and a finite representative set of Gw1,w2,S where S ranges over types τ_S with |S| ≤ ℓ_pump (plus S = ∅). Each check reduces to Ext‑table membership and adjacency constraints; total time 2^{poly(β)}.

Construction sketch (if f0 exists; to be moved to output.md once the partition lemma is proven)
- Use an oriented‑path version of the (ℓ_width, ℓ_count, ℓ_pattern) partition (as in the cycle proof), with parameters ℓ_width = ℓ_pattern = ℓ_pump and ℓ_count = 2ℓ_pump + 2. On long periodic regions with primitive period w (|w| ≤ ℓ_pattern and repeat count ≥ ℓ_count), label the central 2r‑window of every period by f0(w), creating evenly spaced mid‑anchors. The remaining subpaths between anchors (and near endpoints) have O(ℓ_width + ℓ_pattern) length and are filled using (F2) by constant‑radius table lookups indexed by (w1, S, w2). Orientation is given, so no orientation step is required.

Sanity examples
- Equality LCL (E = {(c,c)}, A_0 = A_1 = {c}): f0(w) ≡ c^{|w|} satisfies (F1)–(F2); classified O(1).
- Proper 2‑coloring: no f0 exists (F1 fails on Gw,1 due to parity); Stage‑1 with endpoints succeeds; classified Θ(log* n).

Endpoint incremental identities and filters (implementation notes)
- Incremental projection under append (k_flag ≥ 4): RightColors(τ·a) = { y ∈ A_a : ∃ x1,x2,x3 Left3_τ[x1,x2,x3] ∧ E(x3,y) }, LeftColors(τ·a) = LeftColors(τ). Direct from Lemma 1 via projections.
- Allow sets: L_allow(τ) = N_E(RightColors(τ)), R_allow(τ) = N_E^{-1}(LeftColors(τ)). This restates V_left/V_right.
- Early feasibility filters for Stage‑1: If some OutR2(τ_b,s) or OutL1(τ_c,s) is empty, no feasible f_mid exists. If L_allow(τ_end)=∅ or OutR2(τ_b,s)=∅, then g_L(τ_end,s,τ_b) is impossible; similarly for g_R. These are constant‑time table emptiness checks.

Open items to promote S2 to output.md
- Provide a self‑contained oriented‑path partition lemma (constant rounds) with the explicit ℓ parameters above, or adapt an established reference to our notation.
- Integrate the S2‑path theorem with full proofs and NEXPTIME verification, pointing to our Ext/W machinery for the finite checks.


=== output.md ===
Setup and definitions (r=1, globally oriented paths)
- Let Σ_out be a finite output alphabet of size β. Let A_0,A_1 ⊆ Σ_out be the allowed outputs at nodes with input bit 0 or 1, respectively. Let E ⊆ Σ_out × Σ_out be the allowed directed edge relation (u→v allowed iff (u,v)∈E). For an input word t ∈ {0,1}^k with k≥1, a labeling o ∈ Σ_out^k is legal if o[i]∈A_{t[i]} for all i, and (o[i],o[i+1])∈E for all 1≤i<k.
- For k≥4, define Ext_t ⊆ Σ_out^4 as the set of boundary quadruples (L1,L2,R2,R1) that extend to a legal labeling o with L1=o[1], L2=o[2], R2=o[k−1], R1=o[k]. For k≤3, Ext_t is defined with the same 4‑tuple container but with the obvious coordinate equalities imposed by overlaps (tracked by k_flag ∈ {1,2,3,≥4}). The Type of t is Type(t) := (Ext_t, k_flag(t)).
- Indexing reminder: Throughout, boundary quadruples are ordered as (L1, L2, R2, R1).

Lemma 1 (Append‑one‑bit recurrence; k_flag ≥ 4).
Let t be an input word with k_flag(t)≥4, and let t′ := t·a be t with one bit a ∈ {0,1} appended on the right. Then for all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x4 ∈ A_a and E(x3,x4) and ∃z∈Σ_out: (x1,x2,z,x3) ∈ Ext_t ].
Proof. Standard restriction/extension argument on legal labelings. □

Proposition 6 (Base‑case update; k=1→2).
Let t=(b) be a length‑1 input and t′:=t·a the length‑2 input obtained by appending a∈{0,1}. For all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x1 = x3, x2 = x4, x1 ∈ A_b, x2 ∈ A_a, and E(x1,x2) ].
Proof. Immediate from the definition. □

Proposition 6B (Base‑case update; k=2→3).
Let t=(b1,b2) be a length‑2 input and t′:=t·a the length‑3 input obtained by appending a∈{0,1}. For all (x1,x2,x3,x4) ∈ Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x3 = x2, x1 ∈ A_{b1}, x2 ∈ A_{b2}, x4 ∈ A_a, E(x1,x2), and E(x2,x4) ].
Proof. Any legal labeling on three nodes has boundary (o1,o2,o2,o3), with o1∈A_{b1}, o2∈A_{b2}, o3∈A_a and E(o1,o2), E(o2,o3). Conversely, any tuple satisfying these constraints is realized by such a labeling. □

Proposition 7 (Base‑case update; k=3→4).
Let t=(b1,b2,b3) be a length‑3 input and t′:=t·a the length‑4 input obtained by appending a∈{0,1}. For all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x1∈A_{b1}, x2∈A_{b2}, x3∈A_{b3}, x4∈A_a, and E(x1,x2), E(x2,x3), E(x3,x4) ].
Proof. Unfold the definition on the 4‑node path. □

Lemma 2 (Ext‑level concatenation; k_flag ≥ 4).
Let P and Q be input words with k_flag(P), k_flag(Q) ≥4, and let B := P·Q. Then for all (o1,o2,o3′,o4′)∈Σ_out^4,
  (o1,o2,o3′,o4′) ∈ Ext_B ⇔ ∃ x3,x4,x1′,x2′ ∈ Σ_out such that
    (o1,o2,x3,x4) ∈ Ext_P, (x1′,x2′,o3′,o4′) ∈ Ext_Q, and E(x4,x1′).
Proof. Combine witnesses across the seam, or restrict a legal labeling of B. □

Proposition 3 (Type congruence under appending one bit).
If Type(P)=Type(Q), then for all a∈{0,1}, Type(P·a)=Type(Q·a). In particular, Ext_{P·a}=Ext_{Q·a} and k_flag updates identically.
Proof. For k_flag≥4, Lemma 1 shows Ext_{(·)·a} depends only on Ext_{(·)} and a. Short cases follow by the explicit base‑case rules. □

Proposition 4 (Unsoundness of existential R‑composition).
There exists an instance (Σ_out,A_0,A_1,E) and types t_b,t_c such that there is m∈Σ_out with (x,m) ∈ R_{t_b} and (m,y) ∈ R_{t_c} for some x,y, yet (x,y) ∉ R_{t_b·t_c}. Hence the rule “(∃m) R_{P·Q}(x,y) ⇐ R_P(x,m) ∧ R_Q(m,y)” is not valid in general.
Proof. Use Σ_out={a,b,c}, A_0=A_1=Σ_out, E={(a,b),(b,c)}; choose t_b with rightmost a and t_c with leftmost c; pick m=b. The seam would require E(a,c), which fails. □

Proposition 5 (Optimized computation of Ext for concatenation in O(β^6)).
For any types τ,σ with k_flag(τ),k_flag(σ)≥4, define the 3D slices
  Left_τ[o1,o2,x4] := ∃x3 (o1,o2,x3,x4)∈Ext_τ, and
  Right_σ[x1′,o3′,o4′] := ∃x2′ (x1′,x2′,o3′,o4′)∈Ext_σ.
Then for all (o1,o2,o3′,o4′),
  (o1,o2,o3′,o4′) ∈ Ext_{τ⊙σ} ⇔ ∃x4,x1′: Left_τ[o1,o2,x4] ∧ E(x4,x1′) ∧ Right_σ[x1′,o3′,o4′].
Moreover, after precomputing Left_τ and Right_σ for all τ,σ in O(β^4) time per type, Ext_{τ⊙σ} can be computed in O(β^6) time.
Proof. Eliminate x3,x2′ by definitions; count entries. □

Proposition 6A (k_flag=1 append update without recovering the bit).
Let τ be a type with k_flag(τ)=1 and define S_τ := { x ∈ Σ_out : (x,x,x,x) ∈ Ext_τ }. For a∈{0,1}, let τ′ := δ(τ,a). Then for all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{τ′} ⇔ [ x1=x3, x2=x4, x1∈S_τ, x2∈A_a, and E(x1,x2) ].
Proof. Any legal 2‑node labeling has boundary (o1,o2,o1,o2) with o1∈S_τ, o2∈A_a and E(o1,o2). Conversely, any tuple satisfying the listed constraints is realized by a legal labeling on the 2‑node input. □

Lemma 8 (Type‑count bound).
With Type(t):=(Ext_t, k_flag(t)) and Ext_t⊆Σ_out^4, the number of distinct types obeys |T| ≤ 4 · 2^{β^4}.
Proof. For each k_flag value, Ext can be any subset of Σ_out^4; sum over k_flag. □

Proposition 9 (δ well‑defined; deterministic BFS enumeration in 2^{poly(β)} time/space).
Let δ map a type τ and an appended bit a∈{0,1} to the type of the one‑bit extension. Define δ by:
- If k_flag(τ)=1, compute Ext of the 2‑node type by Proposition 6A using S_τ.
- If k_flag(τ)=2, use the explicit k=2→3 update (Proposition 6B).
- If k_flag(τ)=3, use Proposition 7.
- If k_flag(τ)≥4, use Lemma 1 (implementable in O(β^4) time via Proposition 19).
Then δ(τ,a) depends only on τ and a (by Proposition 3). A deterministic BFS that starts from the length‑1 seeds (t=(0) and t=(1)), repeatedly applies δ(·,0) and δ(·,1), and interns types by equality of (Ext, k_flag), halts after at most |T| insertions and enumerates all reachable types. Each transition costs O(β^4) in the k_flag≥4 regime (base‑cases are ≤O(β^4)). Since |T| ≤ 4·2^{β^4}, the total time and space are 2^{poly(β)}. □

Lemma 10 (Reversal operator; basic properties).
Define, for any type τ=(Ext_τ,k_flag(τ)), the reversed type Rev(τ):=(Ext_τ^R, k_flag(τ)), where Ext_τ^R := { (y1,y2,y3,y4) : (y4,y3,y2,y1) ∈ Ext_τ }. Then Rev(Rev(τ))=τ and, for k_flag≥4, Ext_{Rev(τ) ⊙ Rev(σ)} = (Ext_{σ ⊙ τ})^R.
Proof. Direct from definitions and Lemma 2. □

Definition (Long types and pumping bound).
- T_long := { τ ∈ T : k_flag(τ) ≥ 4 }.
- Define ℓ_pump := |T|, where T is the set of reachable Types enumerated by Proposition 9.

Lemma 11 (Ext‑level concatenation; all k_flag).
For any input words P,Q (no restriction on length) and B := P·Q, for all (o1,o2,o3′,o4′) ∈ Σ_out^4,
  (o1,o2,o3′,o4′) ∈ Ext_B ⇔ ∃ x3,x4,x1′,x2′ ∈ Σ_out:
    (o1,o2,x3,x4) ∈ Ext_P, (x1′,x2′,o3′,o4′) ∈ Ext_Q, and E(x4,x1′).
Proof. As in Lemma 2; k_flag imposes only coordinate equalities. □

Proposition 12 (Associativity of Ext‑concatenation).
For any input words P,Q,R, Ext_{(P·Q)·R} = Ext_{P·(Q·R)} as subsets of Σ_out^4.
Proof. Either semantically (concatenation of words) or by rebracketing witnesses from Lemma 11. □

Lemma 13 (Prefix pumping).
Let ℓ_pump := |T|. For any input string w with |w| ≥ ℓ_pump there exist a decomposition w = x y z with 1 ≤ |y| ≤ ℓ_pump and |x y| ≤ ℓ_pump such that Type(x y^i z) is independent of i ≥ 0.
Proof. Pigeonhole on the first ℓ_pump+1 states of the δ‑run. □

Lemma 14 (Periodic pumping).
For any nonempty string u there exist integers a,b with a+b ≤ ℓ_pump such that Type(u^{a+bi}) is invariant for all i ≥ 0.
Proof. Pigeonhole on the sequence Type(u^j), j≥0, and determinism of δ. □

Definition (Feasible function; Out‑set form).
A function f: T_long × {0,1}^2 × T_long → Σ_out^2 is feasible if for every (τ_L, s, τ_R) it outputs (α1,α2) with αi ∈ A_{s[i]} and E(α1,α2), and moreover the following universal extendibility holds: for all τ_b,τ_c∈T_long and s1,s2 ∈ {0,1}^2, and for all α_L ∈ OutR2(τ_b,s1), α_R ∈ OutL1(τ_c,s2), there exists (o1,o2,o3,o4) ∈ Ext_{τ_b ⊙ τ_c} with E(α_L,o1) and E(o4,α_R), where
  OutR2(τ_b,s) := { second(f(τ_a,s,τ_b)) : τ_a ∈ T_long },
  OutL1(τ_c,s) := { first(f(τ_c,s,τ_d)) : τ_d ∈ T_long }.

Lemma 20 (Quantifier minimization equivalence).
Let f be any function T_long×{0,1}^2×T_long→Σ_out^2 obeying node/window constraints. The universal extendibility clause stated here is equivalent to the clause “for all τ_a,τ_b,τ_c,τ_d and s1,s2, letting α_L := second(f(τ_a,s1,τ_b)) and α_R := first(f(τ_c,s2,τ_d)), there exists (o1,o2,o3,o4)∈Ext_{τ_b⊙τ_c} with E(α_L,o1), E(o4,α_R)).”
Proof. “Only if”: the α_L,α_R in the original clause range over OutR2,OutL1. “If”: for given τ_b,τ_c,s1,s2 and α_L∈OutR2, α_R∈OutL1, pick τ_a,τ_d witnessing membership and apply the original clause. □

Proposition 19 (Optimized append in O(β^4) time for k_flag ≥ 4).
For t with k_flag≥4 and a∈{0,1}, define Left3_t[x1,x2,x3] := ∃z (x1,x2,z,x3)∈Ext_t. One can compute Left3_t in O(β^4) time. Then fill Ext_{t·a} by scanning all (x1,x2,x3) with Left3_t[x1,x2,x3]=true and, for each, iterating over x4 with E(x3,x4) and x4∈A_a, setting Ext_{t·a}[x1,x2,x3,x4]←true. The total time is O(β^4) in the dense worst‑case.
Proof. Correctness follows from Lemma 1. Complexity: Left3_t has β^3 entries, each tested in O(β); the fill step is O(β^3Δ) with Δ≤β. □

Proposition 21 (Seam‑feasibility matrices for τ_b ⊙ τ_c).
For τ_b,τ_c, define W_{b⊙c}[α_L][α_R] (a β×β boolean matrix) to be true iff ∃(o1,o2,o3,o4)∈Ext_{τ_b⊙τ_c} with E(α_L,o1) and E(o4,α_R). Using precomputed 3D slices or Ext_{τ_b⊙τ_c}, W_{b⊙c} can be computed in O(β^4Δ^2) time (or better with sparse E), and then universal extendibility checks reduce to testing W_{b⊙c}[α_L][α_R].
Proof. Expand the definition via Lemma 11, eliminate internal witnesses by slices, and count operations. □

Proposition 17 (Nonemptiness monotonicity under concatenation).
If Ext_P ≠ ∅ and Ext_Q ≠ ∅ and there exist x4,x1′ with E(x4,x1′), then Ext_{P·Q} ≠ ∅.
Proof. Choose any (o1,o2,x3,x4) ∈ Ext_P and (x1′,x2′,o3′,o4′) ∈ Ext_Q; Lemma 11 and E(x4,x1′) imply (o1,o2,o3′,o4′) ∈ Ext_{P·Q}. □

Definitions (endpoint projections and seam matrices).
For any type τ, define the projections of Ext_τ to the endpoint coordinates:
- RightColors(τ) := { y ∈ Σ_out : ∃ x1,x2,x3 with (x1,x2,x3,y) ∈ Ext_τ }.
- LeftColors(τ)  := { x ∈ Σ_out : ∃ x2,x3,y with (x,x2,x3,y) ∈ Ext_τ }.
Define the endpoint seam‑compatibility matrices by
- V_left[τ][α]  := true ⇔ ∃ y ∈ RightColors(τ) with E(y, α), and
- V_right[α][τ] := true ⇔ ∃ x ∈ LeftColors(τ) with E(α, x).

Lemma E1 (Endpoint feasibility via Ext).
Let τ be any type and α ∈ Σ_out.
(i) There exists a legal labeling of a left end‑block of type τ together with an adjacent separator whose first output is α if and only if V_left[τ][α] is true.
(ii) There exists a legal labeling of a right end‑block of type τ together with an adjacent separator whose second output is α if and only if V_right[α][τ] is true.
Proof. (i) If V_left[τ][α] holds, pick y ∈ RightColors(τ) with E(y,α) and any (x1,x2,x3,y)∈Ext_τ; Ext‑membership provides the interior, and E(y,α) the seam. Conversely, any legal instance gives y as the last output on the end block, whence (x1,x2,x3,y)∈Ext_τ and E(y,α). (ii) is symmetric. □

Lemma E2 (Endpoint–interior bridging via W_{b⊙c}).
Fix τ_b, τ_c ∈ T_long, inputs s1,s2 ∈ {0,1}^2, and seam colors α_L, α_R ∈ Σ_out. There exists a legal completion of the intervening block of type τ_b ⊙ τ_c consistent with the left seam color α_L (toward τ_b) and the right seam color α_R (toward τ_c) if and only if W_{b⊙c}[α_L][α_R] is true.
Proof. Directly by definition of W_{b⊙c}: “if” is witnessed by (o1,o2,o3,o4); “only if” follows by restricting any legal completion of the intervening block to its boundary and the seam edges. □

Lemma E3 (Feasible‑f condition as set inclusion).
Let f be as in Definition “Feasible function; Out‑set form.” For all τ_b,τ_c∈T_long and s1,s2,
  OutR2(τ_b,s1) × OutL1(τ_c,s2) ⊆ { (α_L,α_R) : W_{b⊙c}[α_L][α_R] = true }.
Conversely, if these inclusions hold for all τ_b,τ_c,s1,s2, then f satisfies the universal extendibility clause.
Proof. Immediate from Lemma E2 and the definition of W_{b⊙c}. □

Definition (Endpoint maps with Out‑set alignment).
- g_L: T × {0,1}^2 × T_long → Σ_out^2. For g_L(τ_end, s, τ_b) = (β1,β2) require:
  (i) βi ∈ A_{s[i]} (i = 1,2) and E(β1,β2);
  (ii) V_left[τ_end][β1] = true;
  (iii) β2 ∈ OutR2(τ_b, s).
- g_R: T_long × {0,1}^2 × T → Σ_out^2. For g_R(τ_c, s, τ_end) = (β1,β2) require:
  (i) βi ∈ A_{s[i]} and E(β1,β2);
  (ii) V_right[β2][τ_end] = true;
  (iii) β1 ∈ OutL1(τ_c, s).

Lemma M1 (MIS on the K‑th power of a path in O(log* n); spacing [K,2K]).
For every constant K ≥ 1, there is a deterministic LOCAL algorithm that in O(log* n) rounds computes a maximal independent set on the K‑th power of the underlying undirected path. In the resulting set, consecutive selected positions are at distances in [K, 2K].
Proof sketch. First compute a proper O(1)‑coloring of the path in O(log* n) rounds (e.g., Cole–Vishkin color reduction). Then greedily construct an MIS on the K‑th power in O(1) rounds by iterating over color classes and adding a node if none of its K‑neighbors is already selected. Maximality and the spacing bounds follow from construction. □

Theorem S1‑path (Endpoint‑coupled equivalence on oriented paths).
Let an r=1 LCL be given on globally oriented paths with output alphabet Σ_out of size β. Then the following are equivalent:
(A) There exists a deterministic LOCAL algorithm with runtime o(n).
(B) There exist witnesses (f_mid, g_L, g_R) where f_mid: T_long×{0,1}^2×T_long→Σ_out^2 is feasible in the Out‑set sense (Definition “Feasible function; Out‑set form”), and g_L, g_R satisfy the endpoint map constraints above.
Moreover, existence of such witnesses is verifiable in nondeterministic time 2^{poly(β)}.

Proof.
(⇒) Assume a deterministic o(n)‑round algorithm A. Fix a large n and let R := R(n) be its runtime on paths of length n. By Lemmas 13–14 (pumping), for each τ ∈ T_long choose a canonical input string w_τ of type τ with |w_τ| ≫ R and with a short prefix y_τ of length ≤ ℓ_pump such that w_τ = x_τ y_τ^M z_τ for some M, and the δ‑state is stable across repetitions.

Define f_mid(τ_L, s, τ_R) as follows: consider W := w_{τ_L} · S(s) · w_{τ_R}, where S(s) is the 2‑node separator with input s. Assign unique identifiers so that the ID pattern is periodic and identical within the R‑neighborhoods around S(s), and pad beyond distance R into w_{τ_L}, w_{τ_R}. Run A on W and record the 2‑node output on S(s) as f_mid(τ_L, s, τ_R). Because the neighborhoods of S(s) are isomorphic across all such choices (by periodic pumping and our canonical construction), f_mid is well defined and satisfies node/window constraints. The Out‑set feasibility of f_mid holds: for any τ_b, τ_c and α_L ∈ OutR2(τ_b, s1), α_R ∈ OutL1(τ_c, s2), choose τ_a, τ_d witnessing α_L, α_R via f_mid and form the path w_{τ_b} · S(s1) · middle · S(s2) · w_{τ_c}, where “middle” is any long block of type τ_b ⊙ τ_c built from our canonical pieces and padded so that the R‑neighborhoods of the two separators are disjoint. By locality, A’s outputs on the two separators are α_L and α_R, and since A is correct, a legal completion of the middle block exists. Projecting to Ext gives W_{b⊙c}[α_L][α_R] = true, as required by the Out‑set feasibility clause.

Define g_L(τ_end, s, τ_b) as follows: pick any finite path P_end with Type(P_end)=τ_end; pick w_{τ_b} (as above) long enough so that the radius‑R neighborhood of S(s) lies entirely inside w_{τ_b} on the right. Run A on the finite path P := P_end · S(s) · w_{τ_b} (with padding only on the right beyond distance R if needed). Let g_L(τ_end,s,τ_b) be the output on S(s). Local correctness of A implies (i); the existence of a legal seam into the endpoint block yields V_left[τ_end][β1] = true (ii); and since the right context is w_{τ_b}, the second output β2 lies in OutR2(τ_b, s), giving (iii). Define g_R symmetrically by choosing any P_end of type τ_end on the right and padding on the left within w_{τ_c}.

(⇐) Assume witnesses (f_mid, g_L, g_R) as above. Let K := ℓ_pump + 4. By Lemma M1, compute in O(log* n) rounds a maximal independent set on the K‑th power of the path; consecutive MIS nodes (separators) are at distances in [K, 2K].
- Interior separators: For each separator between long blocks of types τ_b and τ_c with local inputs s1 and s2 on its two adjacent 2‑node windows, set its 2‑node output to f_mid(·). By Out‑set feasibility and Lemma E2, the block between any two consecutive interior separators is fillable via Ext_{τ_b ⊙ τ_c} using table W_{b⊙c}.
- Endpoint‑adjacent separators: Let S_L be the unique separator adjacent to the left end; compute τ_end (the type of the end block to its left) and τ_b (the long type on its right). Set S_L’s output to g_L(τ_end, s, τ_b). By Lemma E1 and condition (ii), the endpoint block can be filled. For the block between S_L and the nearest interior separator S_2 (with right‑side long type τ_c), condition (iii) gives α_L := second(g_L) ∈ OutR2(τ_b, s), while the left seam color α_R at S_2 is in OutL1(τ_c, s2) by construction. Hence W_{b⊙c}[α_L][α_R] = true, and Lemma E2 fills the intervening block. Do the right endpoint symmetrically with g_R.
- Small‑n edge cases (0 or 1 separator) are handled by brute‑force completion using Ext tables in constant radius; this does not affect asymptotic runtime.
All fillings are computed from constant‑size tables; the MIS step dominates with O(log* n) rounds. Thus we obtain an O(log* n) algorithm.

Verification complexity. Deterministically enumerate T and T_long via Proposition 9 with O(β^4) per long append (Prop. 19), precompute Ext_τ and Ext_{τ_b ⊙ τ_c}, W_{b⊙c}, V_left, V_right. For a guessed f_mid, compute OutR2 and OutL1 sets. Then check the constraints entrywise; the total time is 2^{poly(β)}.

Remark. Lemma 11 strictly subsumes Lemma 2; we retain Lemma 2 for emphasis in the k_flag ≥ 4 regime.


=== 1811.01672v2.pdf ===

--- Page 1 ---
The distributed complexity of locally
checkable problems on paths is
decidable
Alkida Balliu · alkida.balliu@aalto.ﬁ· Aalto University
Sebastian Brandt · brandts@ethz.ch · ETH Zurich
Yi-Jun Chang · cyijun@umich.edu · University of Michigan
Dennis Olivetti · dennis.olivetti@aalto.ﬁ· Aalto University
Mika¨el Rabie · mikael.rabie@irif.fr · Aalto University and IRIF, University Paris Diderot
Jukka Suomela · jukka.suomela@aalto.ﬁ· Aalto University
Abstract. Consider a computer network that consists of a path with n nodes. The
nodes are labeled with inputs from a constant-sized set, and the task is to ﬁnd output
labels from a constant-sized set subject to some local constraints—more formally, we
have an LCL (locally checkable labeling) problem. How many communication rounds
are needed (in the standard LOCAL model of computing) to solve this problem?
It is well known that the answer is always either O(1) rounds, or Θ(log∗n) rounds,
or Θ(n) rounds. In this work we show that this question is decidable (albeit PSPACE-
hard): we present an algorithm that, given any LCL problem deﬁned on a path,
outputs the distributed computational complexity of this problem and the corresponding
asymptotically optimal algorithm.
arXiv:1811.01672v2  [cs.DC]  18 Feb 2019

--- Page 2 ---
1
Introduction
To what extent is it possible to automate the design of algorithms and the study of computational
complexity? While algorithm synthesis problems are typically undecidable, there are areas of
theoretical computer science in which we can make use of computational techniques in algorithm
design—at least in principle, and sometimes also in practice. One such area is the theory of
distributed computing; see [3, 5, 6, 9, 11, 17, 19, 26] for examples of recent success stories. In this
work we bring yet another piece of good news:
Consider this setting: there is a computer network that consists of a path with n nodes, the
nodes are labeled with inputs from a constant-sized set, and the task is to ﬁnd output labels from
a constant-sized set subject to some local constraints. We show that for any given set of local
constraints, it is decidable to tell what is the asymptotically optimal number of communication
rounds needed to solve this problem (as a function of n, for the worst-case input).
Background: LCLs and the LOCAL Model.
We focus on what are known as LCL (locally
checkable labeling) problems [22] in the LOCAL model of distributed computing [20, 24]. We deﬁne
the setting formally in Section 2, but in essence we look at the following question:
• We are given an unknown input graph of maximum degree ∆= O(1); the nodes are labeled
with input labels from a constant-size set Σin, and the nodes also have unique identiﬁers from
a polynomially-sized set.
• The task is to label the nodes with output labels from a constant-size set Σout, subject to
some local constraints P; a labeling is globally feasible if it is locally feasible in all radius-r
neighborhoods for some r = O(1).
• Each node has to produce its own output label based on the information that it sees in its
own radius-T(n) neighborhoods for some function T.
Here the local constraints P deﬁne an LCL problem. The rule that the nodes apply to determine
their output labels is called a distributed algorithm in the LOCAL model, and function T(n) is the
running time of the algorithm—here T(n) determines how far a node has to see in order to choose
its own part of the solution, or equivalently, how many communication rounds are needed for each
node to gather the relevant information if we view the input graph as a communication network.
In this setting, the case of T(n) = Θ(n) is trivial, as all nodes can see the entire input. The
key question is to determine which problems P can be solved in sublinear time—here are some
examples:
• Vertex coloring with ∆+ 1 colors: can be solved in time O(log∗n) [8, 16] and this is tight
[20, 21].
• Vertex coloring with ∆colors, for ∆> 2: can be solved in polylogarithmic time [23] and
requires at least logarithmic time [7] for deterministic algorithms.
While the study of this setting was initiated already in the seminal work by Naor and Stockmeyer
in 1995 [22], our understanding of these questions has rapidly advanced in the past three years
[1, 2, 4, 6, 7, 12–15, 25]. The big surprises have been these:
1

--- Page 3 ---
• There are LCL problems with inﬁnitely many diﬀerent time complexities—for example, we
can construct LCL problems with a time complexity exactly Θ(nα) for any rational number
0 < α ≤1.
• Nevertheless, there are also wide gaps in the complexity landscape: for example, no LCL
problem has a (deterministic) computational complexity that is between ω(log∗n) and o(log n).
However, what is perhaps most relevant for us is the following observation: if we look at the case
of ∆= 2 (paths and cycles), then the time complexity of any LCL problem is either O(1), Θ(log∗n),
or Θ(n), and the same holds for both deterministic and randomized algorithms [5, 6, 22].
Decidability of LCL Time Complexities.
For a ﬁxed ∆, any LCL problem has a trivial ﬁnite
representation: simply enumerate all feasible radius-r local neighborhoods. Hence it makes sense to
ask whether, given an LCL problem, it is possible to determine its time complexity. The following
results are known by prior work:
• If the input graph is an unlabeled path or cycle, the time complexity is decidable [5, 22].
• If the input graph is a grid or toroidal grid, the time complexity is undecidable [22]. However,
there are also some good news: in unlabeled toroidal grids, the time complexity falls in one of
the classes O(1), Θ(log∗n), or Θ(n), it is trivial to tell if the time complexity is O(1), and it
is semi-decidable to tell if it is Θ(log∗n) [5].
• In the case of trees, there are inﬁnitely many diﬀerent time complexities, but there is a gap
between ω(log n) and no(1), and it is decidable to tell on which side of the gap a given problem
lies [6].
Somewhat surprisingly, the seemingly simple case of labeled paths or cycles has remained open all
the way since the 1995 paper by Naor and Stockmeyer [22], which deﬁned LCLs with inputs but
analyzed decidability questions only in the case of unlabeled graphs.
We initially expected that the question of paths with input labels is a mere technicality and the
interesting open questions are related to much broader graph families, such as rooted trees, trees,
and bounded-treewidth graphs. However, it turned out that the main obstacle for understanding
decidability in any such graph family seems to lie in the fact that the structure of the graph can be
used to encode arbitrary input labels, hence it is necessary to ﬁrst understand how the input labels
inﬂuence decidability—and it turns out that this makes all the diﬀerence in the case of paths.
In this work we show that the time complexity of a given LCL problem on labeled paths or
cycles is decidable. However, we also show that decidability is far from trivial: the problem is
PSPACE-hard, as LCL problems on labeled paths are expressive enough to capture linear bounded
automata (Turing machines with bounded tapes).
2
Model
The LOCAL Model.
The model of computation we consider in this work is the LOCAL model of
distributed computing [20, 24]. In the LOCAL model, each node of the input graph is considered as
a computational entity that can communicate with the neighboring nodes in order to solve some
given graph problem. Computation is divided into synchronous rounds, where in each round each
node ﬁrst sends messages of arbitrary size to its neighbors, then receives the messages sent by
its neighbors, and ﬁnally performs some local computation of arbitrary complexity. Each node is
equipped with a globally unique identiﬁer (ID) which is simply a bit string of length O(log n), where
2

--- Page 4 ---
n denotes the number of nodes of the input graph. In the beginning of the computation, each node
is aware of its own ID, the number of nodes and the maximum degree ∆of the input graph, and
potentially some additional problem-speciﬁc input. Each node has to decide at some point that it
terminates, upon which it returns a local output and does not take part in any further computation;
the problem is solved correctly if the local outputs of all nodes together constitute a global output
that satisﬁes the output constraints of the given problem.
Each node executes the same algorithm; the running time of the distributed algorithm is the
number of rounds until the last node terminates. It is well known that, due to the unbounded
message sizes, an algorithm with runtime T(n) can be equivalently described as a function from
the set of all possible radius-T(n) neighborhoods to the set of allowed outputs. In other words, we
can assume that in a T(n)-round algorithm, each node ﬁrst gathers the topology of and the input
labels contained in its radius-T(n) neighborhood, and then decides on its output based solely on
the collected information.
Locally Checkable Labelings.
The class of problems we consider is locally checkable labeling
(LCL) problems [22]. LCL problems are deﬁned on graphs of bounded degree, i.e., we will assume
that ∆= O(1). Formally, an LCL problem is given by a ﬁnite input label set Σin, a ﬁnite output
label set Σout, an integer r, and a ﬁnite set C of graphs where every node is labeled with a pair
(ℓin, ℓout) ∈Σin × Σout and one node is marked (as the center). Each node of the input graph
is assigned an input label from Σin before the computation begins, and the global output of a
distributed algorithm is correct if the radius-r neighborhood of each node v, including the input
labels given to the contained nodes and the output labels returned by the contained nodes, is
isomorphic to an element of C where v corresponds to the node marked as the center.
In the case of directed paths as our class of input graphs, we are interested in identifying the
simplest possible form of LCL problems. For this purpose, we deﬁne β-normalized LCLs; these are
problems for which the input is just binary, and the size of the set of output labels is β. Moreover, the
solution can be checked at each node v by just inspecting the input and output of v, and, separately,
the output of v and the output of its predecessor. More formally, a β-normalized LCL problem is
given by ﬁnite input and output label sets Σin, Σout satisfying |Σin| = 2, |Σout| = β, a ﬁnite set
Cin −out of pairs (ℓin, ℓout) ∈Σin × Σout and a ﬁnite set Cout −out of pairs (ℓout, ℓ′
out) ∈Σout × Σout.
The global output of a distributed algorithm for the β-normalized LCL problem is correct if the
following hold:
• For each node v, we have (Input(v), Output(v)) ∈Cin −out, where Input(v) denotes the input
label of v, and Output(v) the output label of v.
• For each node v that has a predecessor, we have (Output(v), Output(u)) ∈Cout −out, where u is
the predecessor of v, and Output(v), Output(u) are the output labels of v and u, respectively.
It is straightforward to check that a β-normalized LCL problem is indeed a special case of an LCL
problem where r = 1.
3
Hardness
In this section we study the hardness of determining the distributed complexity of LCLs on paths
and cycles with input labels. More precisely, we start by proving the existence of a family Π of
LCL problems for consistently globally oriented paths, such that, given an LCL problem in Π, it is
PSPACE-hard to decide if its distributed complexity is O(1) or Θ(n). Our main result shows the
following.
3

--- Page 5 ---
L
0
0
0
0
0
0
R
q0
L
0
0
0
0
0
0
R
q1
L
1
0
0
0
0
0
R
L
R
L
R
L
R
L
R
q1
L
R
q1
q1
q1
q1
q1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
0
0
1
1
1
1
1
1
1
1
1
1
1
1
1
1
L
R
qf
1
1
1
1
1
1
a
L
L
L
R
R
R
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
T
T
T
F
F
F
F
F
F
F
F
F
F
F
F
F
F
F
F
F
F
F
F
q0
q0
q0
q0
q0
q0
q0
q0
q1
q1
q1
q1
q1
q1
q1
q1
q1
q1
q1
q1
q1
q1
q1
q1
F
· · ·
Figure 1: Illustration of a correct encoding of the execution of an LBA on a path; black nodes act as separators
between the encoding of two consecutive steps of the LBA; in the example, the LBA executes a unary counter.
It is PSPACE-hard to distinguish whether a given LCL problem P with input labels can be
solved in O(1) time or needs Ω(n) time on globally oriented path graphs.
The high level idea of the proof of the above result is as follows. We would like to encode the
execution of Turing machines as LCLs on consistently oriented paths, and then deﬁne some LCL for
which the complexity depends on the running time of the machine. This is fairly easy on oriented
grids, for example, where we can use one dimension of the grid as a tape, and the other dimension
as time. One may try to do the same on paths, by projecting everything on a single dimension,
concatenating the tape state of each step. Unfortunately, the obtained encoding is not locally
checkable, since the length of the tape may be non-constant. Hence, in order to guarantee the local
checkability, we should consider Turing machines having a tape of size at most B, where B is a
constant with respect to the number of nodes in the path where we want to encode its execution.
For this purpose, we consider Linear Bounded Automata (LBA) [18, p. 225]. An LBA is a Turing
machine that has a tape of size upper bounded by some B. We show that, if B is constant with
respect to the number of nodes in the path, we can then encode the execution of an LBA MB as
an LCL for directed paths. Moreover, we show that by seeing this encoding as a two party game
between a prover and a disprover, we can encode the execution of MB using labels of constant size
that do not depend on B, even in the case in which the LCL checkability radius is 1. If the execution
of MB is not correctly encoded in the input of the LCL, then we can disprove its correctness using
output labels of size O(B). Moreover, we ensure that, if the execution of MB is correctly encoded
in the input of the LCL, it is not possible to produce a correct proof of non-correctness. Then, in
order to obtain an LCL with a distributed complexity that depends on the execution time of MB,
we encode some secret input at the ﬁrst node of the path. We require then that all nodes involved
in a correct encoding must produce the same secret as output.
Figure 1 shows an example of an LBA that executes a unary counter, and its encoding as input
to nodes on a path. In this instance, all nodes must produce the symbol a as output. Figure 2 shows
an example of the wrong input (the tape has been copied incorrectly between two consecutive steps
4

--- Page 6 ---
a
L
L
L
R
R
R
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
1
T
T
T
F
F
F
F
F
F
F
F
F
F
F
F
F
F
F
F
F
F
F
F
q0
q0
q0
q0
q0
q0
q0
q0
q1
q1
q1
q1
q1
q1
q1
q1
q1
q1
q1
q1
q1
q1
q1
q1
F
· · ·
a
a
a
E2
E
E
E
E
E
E
E
E
E
E
E
E
a
a
a
a
0
0
E2
E2
E2
E2
E2
E2
E2
E2
E2
0
0
0
0
0
0
0
0
0
1
2
3
4
5
6
7
8
9
Input
Output
Figure 2: Illustration of an incorrect encoding of the execution of an LBA on a path; in the example, the
tape of the LBA is wrongly copied (the inputs in red are diﬀerent, while they should be the same). The error
output E2 encodes the distance of B + 1 between the two nodes, and the input wrongly copied.
3
5
Input size: 8
1
1
1
1
0
0
1
1
0
1
1
1
1
1
1
0
0
0
(⌈log 8⌉+ 1) 1s
(⌈log 8⌉+ 1) 1s
3
5
· · ·
· · ·
· · ·
· · ·
Separator
0
Separator
Figure 3: Illustration of the normalization of an LCL.
of the LBA). In this case, nodes are allowed to produce a chain of errors. Diﬀerent types of errors
will be handled using diﬀerent types of error labels. In the example, all nodes that produce the
error chain, output E2, indicating an error of type 2. We will show that we need O(B) symbols to
handle all possible errors (including the case in which the input tape is too long, way more than B).
Also, it is necessary that all error chains that we allow as outputs must be locally checkable.
Another interesting problem is to identify, for an LCL that can be distributedly solved in constant
time, how big this constant can be. In particular, we ﬁrst focus on identifying the simplest possible
description of an LCL, and then, we provide a lower bound on the complexity of a constant time
LCL, as a function of the size of the LCL description. For this purpose, we consider β-normalized
LCLs, i.e., problems for which the input labeling is just binary and there are β possible output
labels. Also, the veriﬁer for these LCLs is the simplest possible: it can only check if the output of a
node is correct w.r.t. its input, and separately, if the output of a node is correct w.r.t. the output of
its predecessor. Therefore, we show how to convert an LCL to a β-normalized one by encoding the
input in binary (Figure 3 shows an example), and obtain the following result.
There are β-normalized LCLs that can be solved in constant time but the distributed time
complexity is 2Ω(β).
All results that we have been described so far apply to globally oriented paths. Nevertheless, we
show that ideas and techniques can be generalized to work on undirected path and cycles as well,
obtaining essentially the same results. Finally, we will show how to lift these results to trees without
input labels, proving the following result.
It is PSPACE-hard to distinguish whether a given LCL problem P without input labels can be
solved in O(1) time or needs Ω(n) time on trees with degree ∆= 3.
5

--- Page 7 ---
3.1
Linear Bounded Automata
A Linear Bounded Automata MB is a Turing Machine having a bounded tape of size at most B,
such that it is able to recognize the boundaries of the tape [18, p. 225]. More formally, we deﬁne an
LBA as a tuple of 5 elements M = (Q, q0, qf, Γ, δ), where
• Q is a ﬁnite set of states;
• q0 ∈Q is the initial state;
• qf ∈Q is the ﬁnal state;
• Γ is a ﬁnite set of tape alphabet symbols that contains integers 0, 1, and special symbols L
(left), and R (right);
• δ is the transition function, where δ: Q \ {qf} × Γ →Q × Γ × {−, ←, →}.
The tape of MB is initialized as follows:
• the ﬁrst cell is marked with the symbol L;
• the last cell is marked with the symbol R;
• all other cells contain an integer in {0, 1}.
An execution of an LBA is a sequence (stepi | i ∈{1, . . . , t}), where
• stepi = (statei, tapei, headi);
• statet = qf;
• δ(statei, tapei[headi]) = (statei+1, tapei+1[headi], ϵ), and headi+1 is
– headi −1 if ϵ is ←;
– headi if ϵ is −;
– headi + 1 if ϵ is →.
3.2
The LCL Problem
We deﬁne a family Π of LCLs, in which each problem ΠMB depends on the LBA MB. The general
idea is that the input of the LCL may encode the execution of an LBA MB. If it is the case, nodes
are required to solve a problem that requires a time proportional to the execution time of MB. On
the other hand, if it is not the case, nodes can produce an output that proves that this encoding is
wrong. In order to deﬁne valid LCLs, we consider the case where B = O(1), that is, the size of the
tape does not depend on the size of the distributed network.
3.2.1
Input Labels
We deﬁne the input labels of our LCL as follows:
• Start(φ), where φ ∈{a, b}, indicates a symbol that will be used as some kind of secret;
• Separator, a label that acts as a separator between two steps of MB;
• Tape(c, s, h) gives information about the tape and the state of MB, where the content c ∈
{0, 1, L, R}, the state s ∈Q, and the head h ∈{true, false};
• Empty, indicating an empty input.
Note that the size of the set of possible input labels does not depend on the size B of the tape.
6

--- Page 8 ---
3.2.2
Encoding an LBA on a Path
Suppose we have a consistent global orientation in the path P = (p0, p1, p2, . . . , pn−1). Let step =
 stepi = (statei, tapei, headi) | i ∈{1, . . . , t}

be the execution of the LBA MB starting from a tape
initialized with (L, 0, . . . , 0, R).
Deﬁnition 1. The input of the LCL is a good input if the ﬁrst node of the path has in input
Start(φ), where φ ∈{a, b}, and the rest of the path correctly encodes the execution of an LBA MB
initialized with (L, 0, . . . , 0, R) (see Figure 1). More precisely:
• Input(p0) = Start(φ);
• Input(p(i−1)(B+1)+1) = Separator for i ∈1, . . . , t;
• Input(p(i−1)(B+1)+1+j) = Tape(c, s, h) for i ∈1, . . . , t, j ∈{1, . . . , B}, where
– c = tapei[j];
– s = statei;
– h = true if headi = j, otherwise h = false;
• All other nodes have in input Empty.
3.2.3
Output Labels
The set of output labels is the following.
• Start(φ);
• Empty;
• Error: a generic error label;
• Error0(i) where 0 ≤i ≤B + 1: an error of type 0 indicating that the machine is not correctly
initialized;
• Error1(i), where 0 ≤i ≤B: an error of type 1 that we will use in the case where the size of
the tape is not correct, i.e., when the size of the tape is not B;
• Error2(x, i), where x ∈{0, 1, L, R} and 0 ≤i ≤B + 1: an error of type 2 used when the tape
of MB is wrongly copied;
• Error3: an error of type 3 is used in case nodes have inconsistent states;
• Error4(current state, tape content, i), where 0 ≤i ≤B + 2: an error of type 4 indicating that
the transition of MB is encoded incorrectly (this error captures also the case where the head
is missing);
• Error5(x) where x ∈{0, 1}: an error of type 5 used in the case when there is more than one
head.
3.2.4
LCL Constraints
The high level idea is the following. If the path encodes a good input, then nodes that are not
labeled Empty are required to output the input given to the ﬁrst node of the path (either a or b).
Otherwise, nodes can produce a locally checkable proof of an error (see Figure 2 for an example).
While nodes may output a or b even in the case in which the input is not a good input, nodes
must not be able to produce a proof error in the case in which the path encodes a good input. We
describe all these requirements as locally checkable constraints.
An output labeling for problem ΠMB is correct if the following conditions are satisﬁed for nodes
of the path P = (p0, . . . , pn−1). Note that, although nodes do not know their position on the path,
for the sake of simplicity we will denote with pi−1 the predecessor of pi, if it exists.
7

--- Page 9 ---
1. Each node v produces exactly one output label.
2. If Output(v) = Empty then Input(v) = Empty.
3. If v has no predecessors (i.e., v = p0) and Output(v) = Start(φ), then Input(v) = Start(φ).
4. If Output(pi−1) = a then Output(pi) ̸= b, and if Output(pi−1) = b then Output(pi) ̸= a.
5. If Output(pi) = Error0(j), then
• if j = 0 then the node has no predecessor;
• if j > 0 then Output(pi−1) = Error0(j −1).
6. If Output(pi) = Error1(j), then
• if j = 0, then Input(pi) = Separator;
• if j > 0 then Input(pi) ̸= Separator and Output(pi−1) = Error1(j −1).
7. If Output(pi) = Error2(x, j), then
• if j = 0, then Input(pi) = Tape(c, s, h) where h = false, c = x;
• if j = B + 1 then Input(pi) = Tape(c, s, h) where c ̸= x;
• if 0 < j < B + 1 then Output(pi−1) = Error2(x, j −1).
8. If Output(pi) = Error3, then Input(pi) = Tape(c, s, h), Input(pi−1) = Tape(c′, s′, h′), and s ̸= s′.
9. If Output(pi) = Error4(current state, tape content, j), let (transition state, new content, ϵ) =
δ(current state, tape content)
• if j = 0, then Input(pi) = Tape(c, s, h) where c = tape content, s = current state, h = true;
• if j = B and ϵ = ←, or j = B +1 and ϵ = −, or j = B +2 and ϵ = →(i.e., if node pi is an
“Error4 ﬁnal node”), then either current state is a ﬁnal state or Input(pi) = Tape(c, s, h)
where s ̸= transition state or h = false;
• otherwise, then Output(pi−1) = Error4(current state, tape content, j −1).
10. If Output(pi) = Error5(x)
• if Output(pi−1) ̸= Error5 then Input(pi) = Tape(c, s, h) where h = true and x = 0.
11. If Output(pi) = Error then one of the following condition holds:
• Input(pi) ̸= Start(φ) and pi has no predecessors;
• Input(pi) = Start(φ) and pi has a predecessor;
• Input(pi−1) or Output(pi−1) is Empty;
• Output(pi−1) = Error;
• Output(pi−1) = Error0(j), j > 0, and
– if j = 1 then Input(pi−1) ̸= Separator;
– if j ≥2 then either Input(pi−1) ̸= Tape, or Input(pi−1) = Tape(c, s, h) and:
∗if j = 2 either c ̸= L, or s ̸= q0 or h = false;
∗if 2 < j ≤B either c ̸= 0, or s ̸= q0 or h = true;
8

--- Page 10 ---
∗if j = B + 1, either c ̸= R, or s ̸= q0 or h = true;
• Input(pi) = Separator and Output(pi−1) = Error1(x) where x ̸= B;
• Input(pi) ̸= Separator and Output(pi−1) = Error1(B);
• Output(pi−1) = Error2(x, j) where j = B + 1;
• Output(pi−1) = Error3;
• pi−1 is an “Error4 ﬁnal node”;
• Output(pi−1) = Error5(x) and Input(pi−1) = Tape(c, s, h) where h = true and x = 1.
12. If Output(pi) is of type Errorx, then Output(pi−1) must not be of type Errory where y ̸= x.
The following property directly holds by deﬁnition of the constraints.
Property 1. Each node is able to locally check all constraints by just inspecting its own input and
output, and the ones of its predecessor (if it exists).
3.3
Upper Bound on the Complexity of the LCL
We need to consider two possible scenarios: either MB terminates within time T, or MB loops. In
the case in which MB loops, we show a simple O(n) algorithm that solves the LCL ΠMB. As we
know, any problem for which a solution exists can be solved in O(n) rounds in the LOCAL model by
gathering all the graph and solving the problem locally. There always exists a solution for problem
ΠMB if MB loops, in fact:
• If Input(p0) = Start(φ), then all nodes output φ, even if there are errors in the machine
encoding.
• Otherwise, if Input(p0) ̸= Start(φ), all nodes output Error.
It is easy to see that this output satisﬁes the LCL constraints described above.
Suppose that MB terminates. In this case, we show how to solve the LCL problem ΠMB in
constant time. More precisely, if MB terminates in T rounds, we show a distributed algorithm that
solves ΠMB in T ′ = 2+(B +1)T rounds. Each node v starts by gathering its T ′-radius neighborhood
Bv(T ′). Notice that, by deﬁnition, if the input is a good input, then for each node v that is taking
part in the encoding of the execution of MB (i.e., Input(v) ̸= Empty), Bv(T ′) contains p0. Hence, if
a node v does not see p0 after gathering its ball Bv(T ′), it means that the input is not a good input.
So, after gathering its T ′-radius ball, each node v does the following.
• If Input(v) = Empty, then Output(v) = Empty.
• If Bv(T ′) does not contain p0, or if Input(p0) ̸= Start(φ), then v outputs Error.
• If Bv(T ′) is a good input, then v outputs Start(φ).
The remaining case that we still need to handle is when Bv(T ′) contains p0, Input(p0) = Start(φ),
but Bv(T ′) does not look like a good input. We want nodes to produce a proof of an error in some
consistent way. Thus, we show that nodes can identify the ﬁrst error and produce a proof based on
that. First of all, notice that, since v sees the ﬁrst node in the path, v can compute its position i on
the path. Also, node v can identify who is the ﬁrst node u not satisfying the constraints of being a
good input. Let j be the position of u in the path, that is u = pj. Now we distinguish the following
cases based on Bu(B + 2) (the output of each node will be determined by the ﬁrst case encountered
in the following list).
9

--- Page 11 ---
1. If Input(pj) = Start(φ) and j ̸= 0, then, if i < j, Output(v) = Start(φ); otherwise Output(v) =
Error.
2. If j ≤B + 1, it means that either the initial state is encoded incorrectly, or the tape is not
initialized correctly, or the head is not initialized on the correct position. In this case, if i ≤j,
then Output(v) = Error0(i), otherwise Output(v) = Error.
3. If Input(pj−(B+1)) = Separator and Input(pj) ̸= Separator, then the length of the tape is too
long, and u expected to have in input Separator. Then, if i < j −(B +1), Output(v) = Start(φ);
if i > j then Output(v) = Error; otherwise, Output(v) = Error1(i −j + B + 1).
4. If Input(pj) = Separator and there exists a k such that 1 ≤j −k < B + 1 such that
Input(pk) = Separator, then the length of the tape is too short, and u did not expect to have a
separator. In this case, if i < k then Output(v) = Start(φ); if i ≥j then Output(v) = Error;
otherwise Output(v) = Error1(k −i).
5. If Input(pj−(B+1)) = Tape(c, s, h) where h = false, c = x, and Input(pj) = Tape(c′, s′, h′), where
c′ ̸= x, then the tape of MB has been copied incorrectly. In this case, if i < j −(B + 1), then
Output(v) = Start(φ); if i > j then Output(v) = Error; otherwise, Output(v) = Error2(x, i −j +
B + 1).
6. If Input(pj) = Tape(c, s, h) and Input(pj−1) = Separator and there exists a k < j + B such
that Input(pk) = Tape(c′, s′, h′) and that s ̸= s′, it means that nodes have inconsistent states.
Consider the minimum k satisfying the constraints. If i < k then Output(v) = Start(φ); if
i > k then Output(v) = Error; otherwise, Output(v) = Error3.
7. If none of the above is satisﬁed, it means that there exist a k satisfying j −k ≤B +2, such that
Input(pk) = Tape(c, s, h) and h = true. Let (transition state, new content, ϵ) = δ(s, c). It holds
that if ϵ is ←, −, or →, then j−k is respectively B, B+1, or B+2. If Input(pj) = Tape(c′, s′, h′),
where either h′ = false, or transition state ̸= s′, or s is a ﬁnal state, then there is some
error in the transition (this captures also the case where there is no head). If i < k, then
Output(v) = Start(φ); if i > j then Output(v) = Error; otherwise, Output(v) = Error4(s, c, k−i).
Notice that this case captures also the one where the head is missing.
8. If Input(pj) = Tape(c, s, h) where h = true, since all the above cases are not satisﬁed, it means
that there exists a k, such that Input(pk) = Tape(c′, s′, h′), h′ = true, |j −k| < B and all nodes
pmin(j,k), . . . , pmax(j,k) are labeled with some Tape. That is, there are at least two heads, one
on node pj and one on node pk. In this case, if i < min(j, k), then Output(v) = Start(φ); if
i > max(j, k) then Output(v) = Error; if i = min(j, k) then Output(v) = Error5(0), otherwise
Output(v) = Error5(1).
If the path encodes a good input, every node taking part in the encoding of the execution of MB
outputs Start(φ), and in this case it is easy to see that the output satisﬁes the LCL constraints.
Therefore, assume that the path does not correctly encode the execution of MB starting from
the correct tape content. First of all, notice that the algorithm handles all possible errors in the
machine encoding, that is, if the input is not good, at least one case of the list applies. Consider
all nodes v that do not have in input Empty, that is, all nodes taking part in the encoding of the
execution of MB. If node v sees the ﬁrst node p0, i.e., if the distance between p0 and v is at most
T ′ (notice that a good input has length T ′), then it is easy to see that the output satisﬁes the LCL
constraints. Some care is needed in the case where a node v outputs a generic error Error and v
does not see p0: we need to show that also in this case the output is valid, meaning that the LCL
10

--- Page 12 ---
constraints are satisﬁed. In this case, the distance between p0 and v is strictly greater than T ′, and
since the encoding of the execution of MB is not correct, then
• either the path (p0, . . . , v) does not correctly encode the execution of MB,
• or MB is not correctly initialized and it loops.
In the ﬁrst case, some node on the path between p0 and v will output some speciﬁc error Errorx where
x > 0, while in the second case initial nodes will output Error0. In both scenarios the constraints for
Error are satisﬁed. The complexity of the algorithm is O(B · T).
3.4
Lower Bound on the Complexity of the LCL
Let us deﬁne T ′′ as follows. If MB terminates in time T, then T ′′ = T ′ = 2 + (B + 1)T. If MB loops,
then T ′′ = n. We prove a lower bound on the complexity of ΠMB of Ω(T ′′) rounds, by showing that
Ω(T ′′) rounds are needed in the case where the input is a good input. In particular, we show that,
in a good input, for all nodes v such that Input(v) ̸= Empty, Output(v) must be Start(φ). The result
then comes from the fact that, for some nodes, it requires Ω(T ′′) rounds in order to see if φ = a or
φ = b.
First of all, we ignore nodes that have in input Empty since, in a good input, they are at distance
at least T ′′ + 1 from p0, the ﬁrst node of the path. Hence, assume that a node v not having Empty in
input does not output Start(φ). In this case, v can either output a generic error Error, or a speciﬁc
error Errorx. If all nodes output Error, the veriﬁer rejects on p0. If all nodes, starting from a node
pi where i > 0, output Error, and all nodes pi′ with i′ < i output Start(φ), then the veriﬁer rejects
on pi. Therefore, let us assume that there is at least a node that outputs a speciﬁc error Errorx. We
write succ(v) and dist(u, v) to denote respectively the successor of a node v in the path, and the
distance between two nodes u and v in the path.
• If x = 0, the veriﬁer accepts only if this error produces a chain that starts from p0 and
proceeds with increasing values. In order to be accepted, this chain must end at a node w′,
and succ(w′) must output Error. Then, succ(w′) must witness that w′ indeed has a local error
in the machine initialization, which is not possible in a good input.
• If x = 1, we could have two cases:
– there is a chain of increasing values that starts from a node w with Input(w) = Separator,
and ends on a node w′ such that dist(w, w′) < B, Input(succ(w′)) = Separator, and
Output(succ(w′)) = Error (the tape is too short);
– there is a chain of increasing values that starts from a node w with Input(w) = Separator,
and ends on a node w′ such that dist(w, w′) = B, Input(succ(w′)) ̸= Separator, and
Output(succ(w′)) = Error (the tape is too long).
Since, in a good input, the distance between two nodes having in input Separator is always
B + 1, the above scenarios are not possible.
• If x = 2, there must be a chain of length exactly B + 1, starting from a node w having
Input(w) = Tape(c, s, h), where c = x ∈{0, 1}, h = false, and ending on a node w′ such that
dist(w, w′) = B + 1, and Input(w′) = Tape(c′, s′, h′), where c′ ̸= x. In a good input, the tape
content of nodes w and w′ must be the same.
• If x = 3, it means that there must exist two neighbors having two diﬀerent states, and this
can not happen in a good input.
11

--- Page 13 ---
• If x = 4, there must be a chain that propagates the old state and old input, and the veriﬁer
accepts only if acknowledges that the transition has been wrongly encoded, which can not the
case in a good input.
• If x = 5, there must be a chain of length at least 2 not passing through nodes having in input
Separator, starting from a node w with Input(w) = Tape(c, s, h) where h = true, and ending
on a node w′ with Input(w′) = Tape(c′, s′, h′) where h′ = true. This is not possible on a good
input.
Therefore, since nodes can not output any kind of error, and since Empty is not a valid output for
the nodes encoding the LBA, then these nodes must output Start(φ), where the value of φ matches
the input of the ﬁrst node of the path. Hence, ΠMB requires Ω(T ′′).
3.5
Normalizing an LCL Problem
We now show how to β-normalize an LCL ΠMB and obtain a new LCL having roughly the same time
complexity. We deﬁne three diﬀerent veriﬁers depending on their view.
• A Vin,in −out,out veriﬁer running at node v, checks Input(v), Input(pred(v)), Output(v), and
Output((pred(v)).
• A Vin −out veriﬁer running at node v, checks Input(v) and Output(v).
• A Vout −out veriﬁer running at node v checks Output(v) and Output((pred(v)).
Lemma 2. Consider an LCL P with |ΣP
in| = α and |ΣP
out| = β that can be solved in time T and can
be locally checked with a Vin,in −out,out veriﬁer. It is possible to deﬁne an LCL P′ such that |ΣP′
in | = α
and |ΣP′
out| = α · β that can be solved in time T and can be locally checked with a Vin −out and a
Vout −out veriﬁer.
Proof. We deﬁne ΣP′
in = ΣP
in, and ΣP′
out = ΣP
out × ΣP
out. Let Output(v) = (in, out) ∈ΣP′
out. Let
Output(pred(v)) = (in′, out′) ∈ΣP′
out. The Vin −out veriﬁer checks that Input(v) = in. The Vout −out
veriﬁer acts the same as the Vin,in −out,out veriﬁer executed on ((in′, out′), (in, out)). The LCL problem
P′ can be solved with the following algorithm at each node v.
• Gather the ball Bv(T).
• Simulate the original algorithm on Bv(T); let out be the output of this simulation.
• Output (Input(v), out).
It is easy to check that this output is valid for the problem P′, and that it requires T rounds. Also,
note that it is not possible to solve P′ faster than T. In fact, in order to satisfy the Vin −out veriﬁer,
the input must be copied correctly; while in order to satisfy the Vout −out veriﬁer, we need to satisfy
the Vin,in −out,out veriﬁer executed giving the same input that it would have seen on P.
Lemma 3. Consider an LCL P with |ΣP
in| = α and |ΣP
out| = β that can be solved in time T and can
be locally checked with a Vin −out and a Vout −out veriﬁer. We can deﬁne a β′-normalized LCL P′
with β′ = |ΣP′
out| = 2γ · (|ΣP
out| + 3) that can be solved in time Θ(γ · T(n/γ)), where γ = 2⌈log α⌉+ 3.
Proof. In the following we will exploit the ability of an algorithm to work on identiﬁers that can
be polynomial in the size of the graph. In particular, we assume that if an algorithm works on an
instance with IDs in the range 1, . . . , r, then it works also on an instance with IDs in the range
1, . . . , γ · r. Then, we show how to deﬁne an LCL P′ such that:
• if the input instance encodes a virtual instance for the problem P, it is required to solve P on
the virtual instance;
12

--- Page 14 ---
• otherwise, it is required to prove that the encoding is wrong.
Let V′
in −out and V′
out −out be the veriﬁers of our β′-normalized LCL.
Encoding P in P′.
We start by deﬁning how to encode an instance of P of size n, as an
instance of P′ of size N = γ · n. We denote with p0, . . . , pn−1 and p′
0, . . . , p′
γ·n−1 respectively the
instance of P and the one of P′. Let a = ⌈log α⌉. For the sake of simplicity, let us rename nodes
p′
γi, . . . , p′
γ(i+1)−1, where 0 ≤i ≤n −1, as qi
0, . . . , qi
2a+2 (notice that 2a + 2 = γ −1). The ﬁrst a + 1
nodes, qi
0, . . . , qi
a, have input 1, while nodes qi
a+1 and qi
2a+2 have input 0. Each of the remaining a
nodes, qi
a+2, . . . , qi
2a+1, has in input one bit of the binary representation of Input(pi), in some ﬁxed
order (see Figure 3 for an illustration).
The V′
in −out Veriﬁer.
The set of output labels of P′ is ΣP′
out = 2γ × (Σout ∪{Er, E, El}). Let qi
j
be a node of the instance of P′ where 0 ≤i ≤n −1 and 0 ≤j ≤2a + 2. Let Input(qi
j) ∈{0, 1}, and
let Output(qi
j) = ((b0, . . . , b2a+2), out) ∈ΣP′
out. The V′
in −out veriﬁer running at qi
j checks that
• Input(qi
j) = b0, and
• if out ∈ΣP
out, then
– if all bits in b0, . . . , ba are 1s, checks that the original Vin −out veriﬁer accepts on
(x, out), where x is obtained by recovering the input pi for the original algorithm from
ba+2, . . . , b2a+1.
The V′
out −out Veriﬁer.
Let the output of pi
j be ((b0, . . . , b2a+2), out) ∈ΣP′
out and the output of
the predecessor of pi
j be ((b′
0, . . . , b′
2a+2), out′) ∈ΣP′
out The O-O veriﬁer ﬁrst checks that
• b0 = b′
1, b1 = b′
2, . . . , b2a+1 = b′
2a+2, and
• if out ∈ΣP
out and out′ ∈ΣP
out, then
– if at least one bit in b0, . . . , ba is 0 , then out = out′,
– if all bits in b0, . . . , ba are 1s, then check that the original Vout −out executed on (out′, out)
accepts.
Dealing with Errors.
We now add some constraints to handle the case in which out /∈
ΣP
out. Let the output of pi
j be ((b0, . . . , b2a+2), out) and the output of the predecessor of pi
j be
((b′
0, . . . , b′
2a+2), out′). The V′
in −out veriﬁer additionally checks that, if out = E, then the encoding is
not locally valid, that is,
• either
– there are two numbers x, y ≥0, x + y ≤a, such that b0, . . . , bx−1 and b2a+3−y, . . . , b2a+2
are all equal to 1, bx = 0, b2a+2−y = 0, and
– there is not a contiguous sequence of length a + 1 of all 1s in b0, . . . , b2a+2,
• or b0, . . . , ba are all 1s but either ba+1 ̸= 0 or b2a+2 ̸= 0.
The V′
out −out veriﬁer running on pi
j additionally checks that,
• if out = El, then pi
j must have a predecessor, and it must hold that out′ /∈{Er} ∪ΣP
out;
• if out ∈ΣP
out, if pi
j has a predecessor, then out′ must be diﬀerent from Er;
• if out = Er, then pi
j must have a successor.
13

--- Page 15 ---
Let N be the size of the graph. An algorithm solving P′ in (γ + 1) · T rounds does the following at
each node v′:
• Gather the ball Bv′((γ + 1) · T).
• If Bv′((γ + 1) · T) looks like a correct encoding of an input instance of P
– let u′ be the nearest left node having input 1 and other a successors, succ(1)u′, . . . , succ(a)u′,
having also input 1
– Compute the virtual instance for P (setting the IDs to be the same of the nodes satisfying
the above)
– Simulate the original algorithm on the virtual instance by setting n = N/γ, let out be
the output of u′
– Output ((Input(v′), Input(succ(1)v′), . . . , Input(succ(γ−1)v′), out)
• Otherwise,
– if there is a local error, output E
– if the nearest error is on the left, output El
– otherwise, output Er
It is easy to check that the output of the algorithm satisﬁes the constraints. In order to show a
lower bound for the new LCL, we now show that it is not possible to produce errors in a graph
that is a valid encoding. In fact, nodes can not cheat by wrongly outputting the input of the
neighbors, otherwise either the input-output veriﬁer notices inconsistencies on the ﬁrst bit, or the
output-output veriﬁer notices inconsistencies on the other bits. Then, on a valid encoding, no input
satisﬁes the constraints that allows to produce E as output. Finally, the constraints impose that a
chain of Er or El points to a node that is outputting E.
Note that, if the original LCL has complexity T, then the new LCL, on instances of size N = γ ·n,
has complexity Θ(γ(T(n))) = Θ(γ · T(N
γ )).
3.6
Hardness Results
Theorem 4. There are β-normalized LCLs that can be solved in constant time but the distributed
time complexity is 2Ω(β).
Proof. The complexity of ΠMB is Θ(B · T) if MB terminates in T steps.
|Σin| = O(1) and
|Σout| = Θ(B). We can convert it to an LCL where |Σin| = 2, |Σout| = Θ(B), and the complexity is
still Θ(B · T). There exist LBAs that terminate in 2Θ(B) steps (e.g. a binary counter). Thus, the
complexity of the obtained LCL is Θ(B · 2Θ(B)), that is 2Ω(B) = 2Ω(|Σout|) = 2Ω(β).
Theorem 5. It is PSPACE-hard to distinguish whether a given LCL problem P with input labels
can be solved in O(1) time or needs Ω(n) time on globally oriented path graphs.
Proof. It is PSPACE-hard to distinguish whether a given LBA terminates or loops (see e.g. [10]).
Note that the description of a β-normalized LCL has size O(β2). In order to decide if a β-normalized
version of a problem in Π requires O(1) or Ω(n) we need to decide if its associated LBA, running on
a tape of size B = Θ(β), terminates or loops, and this implies the theorem.
14

--- Page 16 ---
3.7
Extending the Results to Undirected Cycles
We show how to extend the above results, which apply to globally oriented paths, to the case where
the input graph is an undirected path or an undirected cycle. We ﬁrst focus on showing how to
adapt these results to undirected paths. Given a β-normalized LCL P deﬁned on directed paths,
we can deﬁne an LCL P′ in which the set of input labels is Σ′
in = {0, 1} × {0, 1, 2}, and the set of
output labels is Σ′
out = {0, 1, 2} × {1, . . . , β, E}. Let Vin −out and Vout −out be the veriﬁers of the
β-normalized LCL P, and let V′
in −out and V′
out −out be the veriﬁers of the LCL P′. The idea is that
we can use 3 symbols to give an orientation as input to the nodes, by giving 0 to the ﬁrst node, 1 to
the second, 2 to the third, 0 to the fourth, and so on. Nodes must copy their orientation number to
the output, and then, if the given orientation is consistent, nodes are required to solve the original
problem P. On the other hand, if the orientation is not consistent, nodes are allowed to output an
error E. Also, in order to avoid the need of error pointers, we allow nodes to treat the places where
the orientation is not consistent, as a place where the path ends.
This new LCL can be checked as follows. The V′
in −out veriﬁer takes in input the input and
the output of the current node (as before) and ﬁrst checks that the orientation has been copied
correctly, and then checks that the original Vin −out veriﬁer accepts. To verify the output, we allow
the V′
out −out veriﬁer to see slightly more than the original veriﬁer Vout −out. The V′
out −out veriﬁer
sees a triple containing the output of the node and the outputs of its neighbors. Note that the
veriﬁer does not know the orientation of the path (and the orientation of the triple), but it can
recover it from the output of the nodes (that contains a copy of the orientation given as input).
Then the V′
out −out veriﬁer checks that, if the node outputted E, the orientation is indeed wrong. If
the output is a value in 1, . . . , β, the veriﬁer V′
out −out runs the original Vout −out veriﬁer, since it
can compute which neighbor is the predecessor. It is easy to see that the complexity of P′ is the
same as the one of P.
The LCL description of P′, that is, the size of its input, its output, and its veriﬁer, is now O(β3),
therefore the hardness result still applies.
We now show how an LCL for paths can be converted to an LCL for cycles. The idea is the
following. On a cycle, we give an additional input to each node in {0, 1}. Nodes marked as 1 are
exempt to solve the problem and act as separators between the other nodes. That is, nodes are
required to solve the original problem on the subpaths that lie between nodes marked as 1. It may
be the case that no node has 1 as input. In this case we allow nodes to output a special error. If a
node decides to output this error, both its neighbors must output the same, that is, all nodes must
output the same. We impose the constraint that a node marked as 1 can not output this error. A
worst case instance would be the one in which one node is marked 1 and all other nodes are marked
0—this would represent a path with a length that is roughly equal to the one of the cycle. There
is one case that requires a bit of care: if all nodes are marked 0, but the original problem can be
solved in sublinear time, nodes could not be able to coordinate to produce the special error. For our
purpose, it is possible to check that, if we consider the problem ΠMB previously deﬁned in the case
in which MB terminates, in an instance in which nobody has a predecessor, nodes can eﬃciently
solve the problem by just outputting Error or Empty, depending on their input.
3.8
Encoding Input Labels as Trees
In this section we demonstrate a reduction from the LCL problem P with input labels on any graph
G to an LCL problem P⋆without input labels on the modiﬁed graph G⋆. The modiﬁed graph G⋆
is the result of attaching a rooted tree to each v ∈V (G) that encodes the input label of v for the
LCL problem P. The reduction allows us to extend the hardness proof to the case of LCL problems
15

--- Page 17 ---
without input labels.
Encoding.
Given a 2k-bit binary string S = (s1, . . . , s2k), deﬁne Enc(S) as the rooted tree
constructed as follows.
• Begin with the full binary tree which has 2k leaves, and the distance from the root to each
leaf is k.
• For each non-leaf node v, let u be any one of its two children, and subdivide the edge {v, u}
into two edges {v, w} and {w, u}, where w is a new node. The node w is designated as the
left child of v.
• Let U = (u1 . . . , u2k) be the leaves ordered by the in-order traversal.
• For each i ∈[2k], add two new nodes x and y as the children of ui. If si = 1, add two more
new nodes x′ and y′ and the two edges {x, x′} and {y, y′}.
The tree Enc(S) has maximum degree 3, and all nodes are within distance 2(k + 1) to the root.
Given a graph G such that each node v ∈V (G) is associated with an input label L(v) ∈Σin, deﬁne
G⋆as the graph resulting from the following operations on G. For each node v ∈V (G), attach the
rooted tree T = Enc(L(v)) to v by adding the edge {v, z}, where z is the root of T. Notice that
∆(G⋆) = max{3, ∆(G) + 1}.
Decoding.
Given a rooted tree T = Enc(S) for some S ∈{0, 1}2k, deﬁne Dec(T) = S. The
decoding can be done by the following procedure. Consider an in-order traversal of the tree such
that (i) for each node v such that exactly one of its children w has degree 2, treat w as the left child
of v, (ii) print ‘1’ if a node that has two children of degree 2 is encountered, (iii) print ‘0’ if a node
that has two children of degree 1 is encountered. Then the printed sequence is S.
The Modiﬁed LCL Problem P⋆.
Let P be an LCL problem with input labels. Suppose that
the radius of P is r, and the maximum degree is ∆. Set k = ⌈log log |Σin|⌉, and let each label in Σin
be represented by a distinct 2k-bit string. The modiﬁed LCL problem P⋆, which does not require
input label, is deﬁned by the following rules. The set of the output labels of P⋆is Σout, the same as
that of P. Let G⋆be a graph with maximum degree ≤∆+ 1.
• Deﬁne G1 = G⋆.
For each 2 ≤i ≤k + 2, deﬁne Gi as the graph induced by nodes in V (G⋆) −Si−1
j=1(Aj ∪Bj).
For each i ∈[k + 2], deﬁne Ai = {v ∈V (Gi)| degGi(v) = 1}.
For each i ∈[k + 1], deﬁne Bi = {v ∈V (Gi)| degGi(v) = 2 and ∃u ∈Ai s.t. {u, v} ∈E(Gi)}.
• Deﬁne Vlabel = Sk+2
j=1 Aj ∪Sk+1
j=1 Bj.
Deﬁne Vmain as the set of nodes in V (G⋆) \ Vlabel that have exactly one neighbor in Vlabel.
• For each v ∈Vmain, deﬁne L(v) as follows. Let u be the unique node in Vlabel adjacent to
v, and let T be the connected component induced by nodes in Vlabel that contains u. Set
L(v) = Dec(T) (with u being the root of T). If the decoding procedure Dec(T) fails, simply
set L(v) as the ﬁrst label in Σin.
• The output labeling, together with the input labeling deﬁned by the function L(·), forms a
legal labeling of the subgraph induced by the nodes in Vmain for P.
16

--- Page 18 ---
Notice that the connected components in Vlabel are the trees encoding input labels, and the subgraph
induced by the nodes in Vmain is G (as long as G does not contain isolated node). The function L(v)
recovers the input label of v for each v ∈V (G). Given that P has a valid labeling on all graphs
(resp., trees) of maximum degree ∆, the modiﬁed LCL problem P⋆also has a valid labeling on all
graphs (resp., trees) of maximum degree ∆+ 1.
Reducing the Radius.
The above deﬁnition of P⋆requires radius r + O(k), as a node v ∈Vmain
needs O(k) extra rounds to calculate L(u) for all u ∈Nr(v)∪Vmain. We present a simple modiﬁcation
that reduces the radius to only r + O(1) at the cost of expanding the number of output labels from
|Σout| to |Σout| + 22k < |Σout| + |Σin|2. The idea is to let nodes in Vlabel to use output labels to
pass the information stored at the leaves to the root based on local rules. Consider a connected
component T induced by nodes in Vlabel. The subgraph T is interpreted as a tree rooted at the
unique node in T that is adjacent to some node in Vmain.
Base Case: Let v ∈A2. If v is adjacent to two nodes in B1, the output label of v is 1; otherwise
the output label of v is 0.
Root / Degree-3 Nodes: Let 3 ≤i ≤k + 2, and let v ∈Ai. Then v has a unique neighbor
uleft ∈Bi+1 and a unique neighbor uright ∈Ai+1. Let Sleft be the output label of uleft, and let
Sright be the output label of uright. Then the output label of v is the binary string Sleft ◦Sright.
Degree-2 Nodes: Let 3 ≤i ≤k + 1, and let v ∈Bi. Then v has a unique neighbor u ∈Ai+1. The
output label of v is the same as the output label of u.
Thus, for each node v ∈Vmain, L(v) is simply the output label of the unique node u ∈Vlabel ∩N(v).
Theorem 6. For any LCL problem P on any graph G of maximum degree ∆that does not have
isolated nodes, the following two statements are equivalent.
• The labeling L: V (G) →Σout is a valid labeling of G for the problem P.
• There exists some labeling L′ of the nodes in Vlabel such that L and L′ together form a valid
labeling of G⋆for the problem P⋆.
Theorem 7. It is PSPACE-hard to distinguish whether a given LCL problem P without input labels
can be solved in O(1) time or needs Ω(n) time on trees with degree ∆= 3.
4
Decidability
In this section, we show that the two gaps ω(1)—o(log∗n) and ω(log∗n)—o(n) for LCL problems
with input labels on paths and cycles are decidable. More speciﬁcally, given a speciﬁcation of an
LCL problem P, there is an algorithm that outputs a description of an asymptotically optimal
deterministic LOCAL algorithm for P, as well as its time complexity.
We will prove the statements for the case of cycles, but the analogous results for cycles and paths
follows as a simple corollary, as we can encode constraints related to degree-1 nodes as constraints
related to nodes adjacent to a special input label. Furthermore, having a promise that the input is
a path does not change the time complexity of an LCL problem: if a problem can be solved in time
T = o(n) in labeled paths, the same algorithm will solve it also in time T = o(n) in labeled cycles.
The proof of Theorem 8 is in Section 4.2; the proof of Theorem 9 is in Section 4.5.
17

--- Page 19 ---
Theorem 8. For any LCL problem P on cycle graphs, its deterministic LOCAL complexity is either
Ω(n) or O(log∗n). Moreover, there is an algorithm that decides whether P has complexity Ω(n)
or O(log∗n) on cycle graphs; for the case the complexity is O(log∗n), the algorithm outputs a
description of an O(log∗n)-round deterministic LOCAL algorithm that solves P.
Theorem 9. For any LCL problem P on cycle graphs, its deterministic LOCAL complexity is either
Ω(log∗n) or O(1). Moreover, there is an algorithm that decides whether P has complexity Ω(log∗n)
or O(1) on cycle graphs; for the case the complexity is O(1), the algorithm outputs a description of
an O(1)-round deterministic LOCAL algorithm that solves P.
Graph Notation.
For convenience, in this section, a directed path P with input labels is
alternatively described as a string in Σk
in, where k > 0 is the number of nodes in P. Similarly,
an output labeling L of P is alternatively described as a string in Σk
out. In subsequent discussion,
we freely switch between the graph-theoretic notation and the string notation. Given an output
labeling L of P, we say that L is locally consistent at v if the input and output labeling assigned to
Nr(v) is acceptable for v. Note that Nr(v) refers to the radius-r neighborhood of v. Given two
integers a ≤b, the notation [a, b] represents the set of all integers {a, a + 1, . . . , b}. Given a string
w, denote wR as the reverse of w.
Overview.
Before we proceed, we brieﬂy discuss the high level idea of the proofs. The main tool
underlying the proofs is the “pumping lemma” which was developed in [6]. Intuitively, we classify
the set of all input-labeled paths into a ﬁnite number of equivalence classes satisfying the following
property. Let P be a subpath of G, and let P ′ be another path that is of the same equivalence
class as P. Given a complete legal labeling of G, if we let G′ be the result of replacing P with
P ′, then it is always possible to extend this partial labeling of G′ to a complete legal labeling by
appropriately labeling P ′. The pumping lemma guarantees that for any path P whose length is
at least the pumping constant ℓpump, and for any number x ≥ℓpump, there is another path P ′ of
length at least x and P ′ is of the same equivalence class as P.
Informally, in the proof of Theorem 8, we show that any LCL problem P solvable in o(n) rounds
can be solved in O(log∗n) rounds in the following canonical way based on a “feasible labeling
function” f. Intuitively, a labeling function f is feasible if for any given independent set I that is
suﬃciently well-spaced, we can apply f to assign the output labels to each v ∈I and its nearby
neighbors locally such that this partial labeling can always be extended to a complete legal labeling.
The ω(log∗n)—o(n) gap and the decidability result follows from these two claims.
• If there is an o(n)-round algorithm A that solves P, then a feasible function f exists. This
is proved by ﬁrst create an imaginary graph where some paths are extended using pumping
lemmas, and then apply a simulation of A on the imaginary graph.
• Whether a feasible function exists is decidable. Intuitively, this is due to the fact that the
number of equivalence classes is ﬁnite.
The proof of Theorem 9 is a little more complicated since the time budget is only O(1), so
we cannot even aﬀord to ﬁnd an MIS. To solve this issue, we decompose the cycle graph G into
paths with unrepetitive patterns and paths with repetitive patterns, in O(1) rounds. For paths
with unrepetitive patterns, we are able to compute a suﬃciently well-spaced MIS in O(1) rounds
by making use of the irregularity of the input patterns. Paths with repetitive patterns are similar
to the paths without input labels, and we will show that we can always label them by repetitive
output patterns, given that the underlying LCL problem is o(log∗n)-time solvable.
18

--- Page 20 ---
𝑠
𝑡
𝐷1
𝐷1
𝐷2
𝐷2
𝐷3
𝑠
𝑡
𝐷1
𝐷1
𝐷2
Figure 4: Illustration of the tripartition ξ(P) = (D1, D2, D3) with r = 3.
4.1
Pumping Lemmas for Paths
Let P = (s, . . . , t) be a directed path, where each node has an input label from Σin. The tripartition
of the nodes ξ(P) = (D1, D2, D3) is deﬁned as follows:
D1 = Nr−1(s) ∪Nr−1(t),
D2 =
 N2r−1(s) ∪N2r−1(t)

\ D1,
D3 = P \ (D1 ∪D2).
See Figure 4 for an illustration. More speciﬁcally, suppose P = (u1, . . . , uk), and let i ∈[1, k]. Then
we have:
• ui ∈D1 if and only if i ∈[1, r] ∪[k −r + 1, k].
• ui ∈D2 if and only if i ∈[r + 1, 2r] ∪[k −2r + 1, k −r].
• ui ∈D3 if and only if i /∈[1, 2r] ∪[k −2r + 1, k].
Let L: D1 ∪D2 →Σout assign output labels to D1 ∪D2. We say that L is extendible w.r.t. P if
there exists a complete labeling L⋄of P such that L⋄agrees with L on D1 ∪D2, and L⋄is locally
consistent at all nodes in D2 ∪D3.
An Equivalence Class.
We deﬁne an equivalence class ⋆∼for the directed paths (i.e., the set of
all non-empty strings in Σ∗
in), as follows.
Consider two directed paths P = (u1, . . . , ux) and P ′ = (v1, . . . , vy), and let ξ(P) = (D1, D2, D3)
and ξ(P ′) = (D′
1, D′
2, D′
3). Consider the following natural 1-to-1 correspondence φ: (D1 ∪D2) →
(D′
1 ∪D′
2) deﬁned as φ(ui) = vi and φ(ux−i+1) = vy−i+1 for each i ∈[1, 2r].
The 1-to-1
correspondence is well-deﬁned so long as (i) x = y or (ii) x ≥4r and y ≥4r. We have P
⋆∼P ′ if
and only if the following two statements are met:
• Isomorphism: The 1-to-1 correspondence φ is well-deﬁned, and for each ui ∈D1 ∪D2,
the input label of ui is identical to the input label of φ(ui).
• Extendibility: Let L be any assignment of output labels to nodes in D1 ∪D2, and let
L′ be the corresponding output labeling of D′
1 ∪D′
2 under φ. Then L is extendible w.r.t.
P if and only if L′ is extendible w.r.t. P ′.
Note that for the special case of x ≤4r, we have P
⋆∼P ′ if and only if P is identical to P ′.
Deﬁne Type(P) as the equivalence class of P w.r.t. ⋆∼. The following technical lemma is analogous
to [6, Lemma 1] in a specialized setting. We only use this lemma to prove the lemmas in Section 4.1.
19

--- Page 21 ---
Lemma 10. Let G be a path graph or a cycle graph where all nodes have input labels from Σin. Let
P be a directed subpath of G, and let P ′ be another directed path such that Type(P ′) = Type(P).
We write ξ(P) = (D1, D2, D3) and ξ(P ′) = (D′
1, D′
2, D′
3). Let L⋄be any complete labeling of G
such that L⋄is locally consistent at all nodes in D2 ∪D3. Let G′ = Replace(G, P, P ′) be the graph
resulting from replacing P with P ′ in G. Then there exists a complete labeling L′
⋄of G′ such that
the following two conditions are met.
1. For each v ∈(V (G) \ V (P))∪(D1∪D2) and its corresponding v′ ∈(V (G′) \ V (P ′))∪(D′
1∪D′
2),
we have L⋄(v) = L′
⋄(v′). Moreover, if v ∈(V (G) \ V (P)) ∪D1 and L⋄is locally consistent at
v, then L′
⋄is locally consistent at v′.
2. L′
⋄is locally consistent at all nodes in D′
2 ∪D′
3.
Proof. The labeling L′
⋄(v′) of G′ for each v′ ∈(V (G′) \ V (P ′)) ∪(D′
1 ∪D′
2) is chosen “naturally”
as follows.
For each v′ ∈V (G′) \ V (P ′), we set L′
⋄(v′) = L⋄(v) for its corresponding node
v ∈V (G)\V (P). For each v′ ∈D′
1∪D′
2, we set L′
⋄(v′) = L⋄(v) for its corresponding node v ∈D1∪D2
such that φ(v) = v′ in the deﬁnition of ⋆∼. At this point, it is clear that if v ∈(V (G) \ V (P)) ∪D1
has a locally consistent labeling under L⋄, then its corresponding node v′ ∈(V (G′) \ V (P ′)) ∪D′
1
also has a locally consistent labeling under L′
⋄, so Condition 1 holds.
Now, the labeling L′
⋄is only undeﬁned for nodes in D′
3. We show that we can complete the
labeling in such a way that is locally consistent at all nodes in D′
2 ∪D′
3. Denote L as L⋄restricted
to D1 ∪D2. Since L⋄is locally consistent at all nodes in P, the labeling L is extendible w.r.t. P.
Note that if we let L′ be L⋄restricted to D′
1 ∪D′
2, then according to the way we deﬁne L′
⋄, the two
labeling L′ and L are identical under the 1-to-1 correspondence φ speciﬁed in the deﬁnition of ⋆∼.
That is, for each v′ ∈D′
1 ∪D′
2, we have L′(v′) = L(v) for its corresponding node v ∈D1 ∪D2 such
that φ(v) = v′. Since P
⋆∼P ′, the labeling L′ must be extendible w.r.t. P ′. That is, there is a way
to assign L′
⋄(v′) for each v′ ∈D′
3 such that all nodes in D′
2 ∪D′
3 have locally consistent labelings
under L′
⋄, so Condition 2 holds.
One useful consequence of this lemma is that if we start with a path or a cycle G with a legal
labeling, after replacing its subpath P with another one P ′ having the same type as P, then it
is always possible to assign output labeling to P ′ to get a legal labeling without changing the
already-assigned output labels of nodes outside of P ′.
Lemma 11. Let G be a path graph or a cycle graph where all nodes have input labels from Σin. Let
P be a directed subpath of G, and let P ′ be another directed path such that Type(P ′) = Type(P). Let
L⋄be complete labeling of G that is locally consistent at all nodes in P. Let G′ = Replace(G, P, P ′)
be the graph resulting from replacing P with P ′ in G. Then there exists a legal labeling L′
⋄of G′
such that the following two conditions are met.
1. For each v ∈V (G) \ V (P) and its corresponding v′ ∈V (G′) \ V (P ′), we have L⋄(v) = L′
⋄(v′).
Moreover, if L⋄is locally consistent at v ∈V (G) \ V (P), then L′
⋄is locally consistent at v′.
2. L′
⋄is locally consistent at all nodes in P ′.
Proof. We write ξ(P ′) = (D′
1, D′
2, D′
3). Condition 1 in this lemma is implied by Condition 1 in
Lemma 10. To see that Condition 2 in this lemma holds, note that in this lemma we additionally
require that L⋄is locally consistent at all nodes in P. Therefore, Condition 1 of Lemma 10 implies
that L′
⋄is locally consistent at all nodes in D′
1. This observation, together with Condition 2 of
Lemma 10, implies that L′
⋄is locally consistent at all nodes in P ′.
20

--- Page 22 ---
The following lemma is analogous to [6, Theorem 4] in a specialized setting. We only use this
lemma in Section 4.1.
Lemma 12. Let P = (v1, . . . , vk), and let P ′ = (v1, . . . , vk−1). Let the input label of vk be α. Then
Type(P) is a function of α and Type(P ′).
Proof. We prove the following stronger statement. Let G be a directed path, and let H be a
directed subpath of G.
Suppose H′ is another directed path satisfying Type(H) = Type(H′).
Let G′ = Replace(G, H, H′) be the result of replacing H with H′ in G.
Then we claim that
Type(G) = Type(G′). The lemma is a corollary of this claim.
Consider the tripartitions ξ(H) = (B1, B2, B3), ξ(H′) = (B′
1, B′
2, B′
3), ξ(G) = (D1, D2, D3), and
ξ(G′) = (D′
1, D′
2, D′
3). We write B0 = V (G) \ V (H) and B′
0 = V (G′) \ V (H′).
Let φ⋆be the natural 1-to-1 correspondence from B0 ∪B1 ∪B2 to B′
0 ∪B′
1 ∪B′
2. Note that
D1 ∪D2 ⊆B0 ∪B1 ∪B2 and D′
1 ∪D′
2 ⊆B′
0 ∪B′
1 ∪B′
2. Also, the 1-to-1 correspondence between
D1 ∪D2 and D′
1 ∪D′
2 given by φ⋆is exactly the 1-to-1 correspondence φ speciﬁed in the requirement
of G ⋆∼G′.
Let L: (D1 ∪D2) →Σout and let L′ be the corresponding output labeling of D′
1 ∪D′
2, under
the 1-to-1 correspondence φ. To show that G ⋆∼G′, all we need to do is show that L is extendible
w.r.t. G if and only if L′ is extendible w.r.t. G′. Since we can also write G = Replace(G′, H′, H), it
suﬃces to show just one direction, i.e., if L is extendible then L′ is extendible.
Suppose L is extendible. Then there exists an output labeling L⋄of G such that (i) for each
v ∈D1 ∪D2, we have L⋄(v) = L(v), and (ii) L⋄is locally consistent at all nodes in D2 ∪D3. Since
D2 ∪D3 ⊇B2 ∪B3, we can apply Lemma 10, which shows that there exists a complete labeling
L′
⋄of G′ such that the two conditions in Lemma 10 are met. We argue that this implies that L′ is
extendible. We verify that (i) L′(v′) = L′
⋄(v′) for each v′ ∈D′
1 ∪D′
2, and (ii) L′
⋄is locally consistent
at all nodes in D′
2 ∪D′
3.
• Condition 1 of Lemma 10 guarantees that L⋄(v) = L′
⋄(φ⋆(v)) for each v ∈(V (G) \ V (H)) ∪
(B1 ∪B2) = B0 ∪B1 ∪B2 and its corresponding node φ⋆(v) ∈B′
0 ∪B′
1 ∪B′
2. Since D′
1 ∪D′
2 ⊆
B′
0 ∪B′
1 ∪B′
2, we have L′(v′) = L′
⋄(v′) for each v′ ∈D′
1 ∪D′
2.
• The fact that L⋄is locally consistent at all nodes in D2 ∪D3, together with Condition 1 in
Lemma 10, guarantees that L′
⋄is locally consistent at all nodes in (D′
2 ∪D′
3) \ B′
3. Condition 2
in Lemma 10 guarantees that L′
⋄is locally consistent at all nodes in B′
2 ∪B′
3. Therefore, L′
⋄is
locally consistent at all nodes in D′
2 ∪D′
3, as required.
The number of types can be upper bounded as follows.
Lemma 13. The number of equivalence classes of ⋆∼(i.e., types) is at most |Σin|4r2|Σout|4r.
Proof. Let P be a directed path, and let ξ(P) = (D1, D2, D3). Then Type(P) is determined by the
following information.
• The input labels in D1 ∪D2. Note that there are at most |Σin|4r possible input labeling of
D1 ∪D2.
• A length-x binary string indicating the extendibility of each possible output labeling of D1∪D2,
where x = |Σout|4r.
Therefore, the number of equivalence classes of ⋆∼is at most |Σin|4r2|Σout|4r.
21

--- Page 23 ---
Deﬁne ℓpump as the total number of types. Observe that Lemma 12 implies that Type(P) can be
computed by a ﬁnite automaton whose number of states is the total number of types, which is a
constant independent of P. Thus, we have the following two pumping lemmas which allow us to
extend the length of a given directed path P while preserving the type of P. The following two
lemmas follow from the standard pumping lemma for regular language.
Lemma 14. Let P ∈Σk
in with k ≥ℓpump.
Then P can be decomposed into three substrings
P = x ◦y ◦z such that (i) |xy| ≤ℓpump, (ii) |y| ≥1, and (iii) for each non-negative integer i,
Type(x ◦yi ◦z) = Type(P).
Lemma 15. For each w ∈Σ>0
in , there exist two positive integers a and b such that a + b ≤ℓpump,
and Type(wai+b) is invariant for each non-negative integer i.
4.2
The ω(log∗n)—o(n) Gap
In this section we show that the ω(log∗n)—o(n) gap is decidable. More speciﬁcally, we show that
an LCL problem P can be solved in O(log∗n) rounds if and only if there exists a feasible function,
which is deﬁned as follows.
Input: A directed path P = w1 ◦S ◦w2, where |w1| ∈[ℓpump, ℓpump + 1], |w2| ∈[ℓpump, ℓpump + 1],
and |S| = 2r. The decomposition P = w1 ◦S ◦w2 is considered part of the input.
Output: A string L ∈Σ2r
out that represents the output labeling of S.
Requirement: Any such function f is said to be feasible if the following requirement is met for
any paths S1, S2 and wa, wb, wc, wd such that |S1| = |S2| = 2r and {|wa|, |wb|, |wc|, |wd|} ⊆
[ℓpump, ℓpump + 1]. Let P = wa ◦S1 ◦wb ◦wc ◦S2 ◦wd, and consider the following assignment
of output labels to S1 ∪S2.
• Either label S1 by f(wa ◦S1 ◦wb) or label SR
1 by f(wR
b ◦SR
1 ◦wR
a ).
• Either label S2 by f(wc ◦S2 ◦wd) or label SR
2 by f(wR
d ◦SR
2 ◦wR
c ).
It is required that given such a partial labeling of P, the middle part wb ◦wc can be assigned
output labels in such a way that the labeling of (i) the last r nodes of S1, (ii) all nodes in
wb ◦wc, and (iii) the ﬁrst r nodes of S2 are locally consistent.
The following lemma is a straightforward consequence of the well-known O(log∗n)-round MIS
algorithm on cycles.
Lemma 16. Let G be a cycle graph of n nodes, and let s ≤k be two constant integers such that
s + k ≤n. Then in O(log∗n) rounds we can compute a decomposition V = A ∪B such that each
connected component of A has size s, and each connected component of B has size within [k, k + 1].
Proof. For any given constant integer 1 ≤L < n, we will show that in O(log∗n) time we can ﬁnd
an independent set I of G such that each connected component induced by V \ I has at least L
nodes and at most 2L nodes. Using this result with L = 2(s −1) + k(s + k + 1), it is straightforward
to obtain the desired decomposition V = A ∪B, as follows.
For each v ∈I, it arbitrarily chooses a size-s path Sv that contains v, and all nodes in Sv are
included to A. Now each connected component S′ induced by the remaining nodes is a path of
size at least L −2(s −1) ≥k(s + k + 1) and at most 2L. We will divide the path S′ into subpaths
R1, R2, . . . , Rt meeting the following conditions: (i) if i is odd, then the size of Ri is k or k + 1;
22

--- Page 24 ---
(ii) if i is even, then the size of Ri is s; (iii) t is odd. Hence we obtain the desired decomposition
V = A ∪B if we include the nodes in R1, R3, . . . to B and include the nodes in R2, R4, . . . to A. We
show that such a decomposition of S′ into subpaths R1, R2, . . . , Rt exists. Denote z as the size of
S′. We write z = α(s + k + 1) + β, where α > 0 and 0 ≤β < s + k + 1 are integers. Note that we
must have α ≥k and β ≤2k.
• For the case β ≥k, there is a decomposition R1, R2, . . . , Rt satisﬁes the following conditions:
(i) if i is odd, then the size of Ri is k + 1 when i < t or β when i = t; (ii) if i is even, then the
size of Ri is s; (iii) t = 2α + 1 is odd.
• For the case β < k, there is a decomposition R1, R2, . . . , Rt satisﬁes the following conditions:
(i) if i is odd, then the size of Ri is k when i ∈{1, 3, 5, . . . , 2(k−β)−1}∪{t} or k+1 otherwise;
(ii) if i is even, then the size of Ri is s; (iii) t = 2α + 1 is odd.
For the rest of the proof, we show that in O(log∗n) time we can ﬁnd the required independent
set I. We prove the lemma by an induction on L. The base case of L = 1 is identical to the MIS
problem. Now consider L > 1. By induction hypothesis, we ﬁnd an independent set I′ in O(log∗n)
time such that each connected component induced by V \ I′ has at least L′ nodes and at most 2L′
nodes, where L′ = ⌊L/2⌋. Let G′ be the graph resulting from contracting all nodes in V \ I′, and
we compute an MIS I′′ on this graph G′, which can be done in O(log∗n) rounds in the original
graph G. Note that each connected component S of V \ I′′ has size at least 2L′ + 1 ≥L and at most
3(2L′) + 2. If the size of S is higher than 2L, then we can add some nodes in S to the independent
set I′′ so that the component size of the remaining nodes in S is within [L, 2L].
Lemma 17. If a feasible function f exists, then there is an O(log∗n)-round deterministic LOCAL
algorithm for P on cycles.
Proof. Given that the number of nodes n is at least some large enough constant, in O(log∗n) rounds
we can compute a decomposition V = A ∪B such that each connected component of A has size 2r,
and each connected component of B has size within [2ℓpump, 2ℓpump + 1]. This can be done using
Lemma 16 with s = 2r and k = 2ℓpump. We further decompose each connected component P of
B into two paths P = P1 ◦P2 in such a way that the size of both P1 and P2 are within the range
[ℓpump, ℓpump + 1]. We write P to denote the set of all these paths.
Let S be a connected component of A, and let w1 and w2 be its two neighboring paths in P so
that (w1 ◦S ◦w2) is a subpath of the underlying graph G. The output labels of S are assigned either
by labeling S with f(w1 ◦S ◦w2) or by labeling SR with f(wR
2 ◦SR ◦wR
1 ). At this moment, all
components of A have been assigned output labels using f. By the feasibility of f, each connected
component of B is able to label itself output labels in such a way that the labeling of all nodes are
locally consistent.
Lemma 18. If there is an o(n)-round deterministic LOCAL algorithm A for P on cycles, then a
feasible function f exists.
Proof. Fix s to be some suﬃciently large number, and ﬁx n = 8(s + ℓpump) + 2(2r). We select s to
be large enough so that the runtime of A is smaller than 0.1s. For any given directed path w with
|w| ∈[ℓpump, ℓpump + 1], we ﬁx w+ as the result of applying the pumping lemma (Lemma 14) on w
so that the following two conditions are met: (i) |w+| ∈[s, s + ℓpump] and (ii) Type(w) = Type(w+).
23

--- Page 25 ---
Constructing a Feasible Function f by Simulating A.
The function f(w1 ◦S ◦w2) is
constructed by simulating a given o(n)-round deterministic LOCAL algorithm for P. The output
labeling given by f(w1 ◦S ◦w2) is exactly the result of simulating A on the path P = w+
1 ◦S ◦w+
2
while assuming the number of nodes of the underlying graph is n. Remember that the round
complexity of A is o(n) on n-node graphs. By setting s to be large enough, the runtime of A can be
made smaller than 0.1s. Thus, the calculation of f(w1 ◦S ◦w2) only depends on the IDs and the
input labels of (i) the last 0.1s nodes in w+
1 , (ii) all nodes in S, and (iii) the ﬁrst 0.1s nodes in w+
2 .
In the calculation of f(w1 ◦S ◦w2), the IDs of the nodes that participate in the simulation of A are
chosen arbitrarily so long as they are distinct.
Feasibility of f.
Now we verify that the function f constructed above is feasible. Consider any
choices of paths S1, S2 and wa, wb, wc, wd such that |S1| = |S2| = 2r and {|wa|, |wb|, |wc|, |wd|} ⊆
[ℓpump, ℓpump + 1]. Deﬁne P = wa ◦S1 ◦wb ◦wc ◦S2 ◦wd, and let G be the cycle graph formed by
connecting the two ends of the path P. To show that f is feasible, we need to consider the following
four ways of assigning output labels to S1 ∪S2.
1. Label S1 by f(wa ◦S1 ◦wb); label S2 by f(wc ◦S2 ◦wd).
2. Label S1 by f(wa ◦S1 ◦wb); label SR
2 by f(wR
d ◦SR
2 ◦wR
c ).
3. Label SR
1 by f(wR
b ◦SR
1 ◦wR
a ); label S2 by f(wc ◦S2 ◦wd).
4. Label SR
1 by f(wR
b ◦SR
1 ◦wR
a ); label SR
2 by f(wR
d ◦SR
2 ◦wR
c ).
For each of the above four partial labelings of P, we need to show that the middle part wb ◦wc
can still be assigned output labels in such a way that the labeling of (i) the last r nodes of S1, (ii)
all nodes in wb ◦wc, and (iii) the ﬁrst r nodes of S2 are locally consistent.
Proof of the First Case.
In what follows, we focus on the ﬁrst case, i.e., the partial labeling is
given by labeling S1 by f(wa ◦S1 ◦wb) and labeling S2 by f(wc ◦S2 ◦wd); the proof for the other
three cases are analogous. In this case, we deﬁne P ′ = w+
a ◦S1 ◦w+
b ◦w+
c ◦S2 ◦w+
d , and let G′ be
the cycle graph formed by connecting the two ends of P ′. Note that the number of nodes in G′ is at
most 8(s + ℓpump) + 2(2r) = n. All we need to do is to ﬁnd an output labeling L of G such that the
following conditions are satisﬁed.
(a) The output labels of S1 is given by f(wa ◦S1 ◦wb).
(b) The output labels of S2 is given by f(wc ◦S2 ◦wd).
(c) The labeling of (i) the last r nodes of S1, (ii) all nodes in wb ◦wc, and (iii) the ﬁrst r nodes of
S2 are locally consistent.
We ﬁrst generate an output labeling L′ of G′ by executing A on G′ under the following ID
assignment. The IDs of (i) the last 0.1s nodes in w+
a , (ii) all nodes in S1, and (iii) the ﬁrst 0.1s
nodes in w+
b are chosen as the ones used in the deﬁnition of f(wa ◦S1 ◦wb). Similarly, the IDs of (i)
the last 0.1s nodes in w+
c , (ii) all nodes in S2, and (iii) the ﬁrst 0.1s nodes in w+
d are chosen as the
ones used in the deﬁnition of f(wc ◦S2 ◦wd). The IDs of the rest of the nodes are chosen arbitrarily
so long as when we run A on G′, no node sees two nodes with the same ID. Due to the way we
deﬁne f, the output labeling L′ of the subpath S1 is exactly given by f(wa ◦S1 ◦wb), and the output
labeling L′ of S2 is exactly f(wc ◦S2 ◦wd). Due to the correctness of A, L′ is a legal labeling.
We transform the output labeling L′ of G′ to a desired output labeling L of G. Remember that
G is the result of replacing the four subpaths w+ of G′ by w, and we have Type(w+) = Type(w). In
view of Lemma 11, there is a legal labeling L of G such that all nodes in S1 and S2 are labeled the
same as in G′. Therefore, the labeling L satisﬁes the above three conditions (a), (b), and (c).
24

--- Page 26 ---
The Other Cases.
We brieﬂy discuss how we modify the proof to deal with the other three
cases. For example, consider the second case, where the partial labeling is given by labeling S1 by
f(wa ◦S1 ◦wb) and labeling SR
2 by f(wR
d ◦SR
2 ◦wR
c ). In this case, the path P ′ is deﬁned as
P ′ = w+
a ◦S1 ◦w+
b ◦
 (wR
c )+R ◦SR
2 ◦
 (wR
d )+R .
During the ID assignment of G′, the IDs of (i) the last 0.1s nodes in w+
c , (ii) all nodes in S2, and
(iii) the ﬁrst 0.1s nodes in w+
d are now chosen as the ones used in the deﬁnition of f(wR
d ◦SR
2 ◦wR
c ).
Using such an ID assignment, the output labeling L′ of SR
2 as the result of executing A on G′ will
be exactly the same as the output labeling given by f(wR
d ◦SR
2 ◦wR
c ). The rest of the proof is the
same.
Theorem 8 follows from the above two lemmas. The decidability result is due to the simple
observation that whether a feasible function exists is decidable.
4.3
Partitioning a Cycle
In the following sections, we prove the decidability result associated with the ω(1)—o(log∗n) gap.
In this proof, we also deﬁne a feasible function, prove its decidability, and show the existence given
an o(log∗n)-time algorithm. The main challenge here is that an MIS cannot be computed in O(1)
time. To solve this issue, we decompose a cycle into paths with unrepetitive patterns and paths
with repetitive patterns. For paths with unrepetitive patterns, we are able to compute a suﬃciently
well-spaced MIS in O(1) time by making use of the irregularity of the input patterns.
Section 4.3 considers an O(1)-round algorithm that partitions a cycle into some short paths
and some paths that have a repeated input pattern. Section 4.4 deﬁnes a feasible function whose
existence characterizes the O(1)-round solvable LCL problems. In Section 4.5, we prove Theorem 9.
Partitioning an Undirected Cycle into Directed Paths.
Let G be a cycle graph.
An
orientation of a node v is an assignment to one of its neighbor, this can be speciﬁed using port-
numbering. An orientation of the nodes in G is called ℓ-orientation if the following condition is met.
If |V (G)| ≤ℓ, then all nodes in G are oriented to the same direction. If |V (G)| > ℓ, then each node
v ∈V (G) belongs to a path P such that (i) all nodes in P are oriented to the same direction, and
(ii) the number of nodes in P is at least ℓ. In O(1) rounds we can compute an ℓ-orientation of G for
any constant ℓ.
Lemma 19 ([6]). Let G be a cycle graph. Let ℓbe a constant. There is a deterministic LOCAL
algorithm that computes an ℓ-orientation of G in O(1) rounds.
In this section, we will use a generalization of an ℓ-orientation that satisﬁes an additional
requirement that the input labels of each directed path P in the decomposition with |V (P)| > 2ℓwidth
(where 2ℓwidth is a threshold) must form a periodic string (whose period length is at most ℓpattern).
A string w ∈Σ∗
in is called primitive if w cannot be written as xi for some x ∈Σ∗
in and i ≥2. Let
G be a cycle graph or a path graph where each node v ∈V (G) has an input label from Σin. We
deﬁne an (ℓwidth, ℓcount, ℓpattern)-partition as a partition of G into a set of connected subgraphs P
meeting the following criteria. We assume |V (G)| > 2ℓwidth and ℓpattern ≥ℓwidth.
Direction and Minimum Length: For each P ∈P, the nodes in P are oriented to the same
direction, and |V (P)| ≥ℓwidth.
25

--- Page 27 ---
Short Paths: Deﬁne Pshort as the subset of P that contains paths having at most 2ℓwidth
nodes. For each directed path P = (v1, . . . , vk) ∈Pshort, each node vi in P knows its rank i.
Long Paths: Deﬁne Plong = P \ Pshort. Then the input labeling of the nodes in P is of the
form wk for some primitive string w ∈Σ∗
in such that |w| ≤ℓpattern and k ≥ℓcount. Moreover,
each node v in P knows the string w.
Note that P may contain a cycle. This is possible only when G is a cycle where the input
labeling is a repetition (at least ℓcount times) of a primitive string w ∈Σ∗
in of length at most ℓpattern.
In this case, we must have P = Plong = {G}. Otherwise, P contains only paths.
The goal of this section is to show that an (ℓwidth, ℓcount, ℓpattern)-partition can be found in O(1)
rounds. First of all, in Lemma 20 we demonstrate how we can break symmetry in O(1) rounds
given that the underlying graph is directed and the input labels does not form long periodic strings.
Let G be a path or a cycle. A set I ⊆V (G) is called an (α, β)-independent set if the following
conditions are met: (i) I is an independent set, and I does not contain either endpoint of G (if G is
a path), and (ii) each connected component induced by V \ I has at least α nodes and at most β
nodes, unless |V | ≤α, in which case we allow I = ∅. Note that ﬁnding an (α, β)-independent set
takes O(log∗n) rounds in general, but in Lemma 20 we show that by leveraging the “irregularity”
of input labels, we can do this in O(1) rounds on directed paths or cycles without periodic patterns.
Lemma 20. Let γ and ℓbe any two constants with ℓ≥γ. Let G be a directed cycle or a directed
path that does not contain any subpath of the form wx, with |w| ≤γ and |wx| ≥ℓ. There is a
deterministic LOCAL algorithm that computes an (γ, 2γ)-independent set I of G in O(1) rounds.
Proof. For the case G is a directed path P = (s, . . . , t), deﬁne V ′ as the set of nodes in G whose
distance to t is at least ℓ−1. For the case G is a directed cycle, deﬁne V ′ = V (G). In what follows,
we focus on ﬁnding an (γ, 2γ)-independent set I′ of the nodes in V ′. Extending the set I′ to produce
the desired independent set I can be done with extra O(1) rounds.
Recall that G is directed. Deﬁne the color of a node v ∈V ′ by the sequence of the ℓinput labels
of v and the ℓ−1 nodes following v in G. For each node v ∈V ′, there is no other node within
distance γ to v having the same color as v, since otherwise we can ﬁnd a subpath whose input labels
form a string wx, with |w| ≤γ and |wx| ≥ℓ. By applying the standard procedure that computes an
MIS from a coloring, within O(1) rounds a (γ, 2γ)-independent set I′ can be obtained.
Using Lemma 20, we ﬁrst show that an (ℓwidth, ℓcount, ℓpattern)-partition can be found in O(1)
rounds for the case G is directed. That is, all nodes in G are initially oriented to the same direction,
and we are allowed to re-orient the nodes.
Lemma 21. Let G be a directed cycle or a directed path where each node v ∈V (G) has an input label
from Σin, and |V (G)| > 2ℓwidth. Let ℓwidth, ℓcount, ℓpattern be three constants such that ℓpattern ≥ℓwidth.
There is a deterministic LOCAL algorithm that computes an (ℓwidth, ℓcount, ℓpattern)-partition in O(1)
rounds
Proof. Let (w1, w2, . . . , wk) be any ordering of the primitive strings in Σ∗
in of length at most ℓpattern.
First, construct a set of subgraphs Plong as follows. Initialize U = V (G) and Plong = ∅. For i = 1 to
k, execute the following procedure. Let Si be the set of maximal-size connected subgraphs formed by
nodes in U such that the input labels form the string wx
i with x ≥ℓcount + 2ℓwidth. Each node v ∈U
in O(1) rounds checks if v belongs to a subgraph in Si; if so, remove v from U. For each P ∈Si,
26

--- Page 28 ---
deﬁne P ′ as follows. If P is a cycle, then P ′ = P. If P is a path, then P ′ is the result of removing
all nodes that are within distance ℓwidth|wi| −1 to an endpoint in P. Note that each node v in P
knows whether v belongs to P ′. Deﬁne S′
i = {P ′|P ∈Si}, and then update Plong ←Plong ∪S′
i.
It is straightforward to verify that each path or cycle P ∈Plong satisﬁes the requirement in the
deﬁnition of (ℓwidth, ℓcount, ℓpattern)-partition. Deﬁne the set of subgraphs Pirreg as the connected
components of the nodes not in any subgraph in Plong. Deﬁne ℓ= (ℓpattern + 2ℓwidth) · ℓcount. By
our construction, the input labeling in each subgraph P ∈Pirreg does not contain any substring
wx, with 1 ≤|w| ≤ℓpattern and |wx| ≥ℓ. An (ℓpattern, 2ℓpattern)-independent set of each P ∈Pirreg
can be computed using Lemma 20 in O(1) rounds. Observe that each subgraph P ∈Pirreg has at
least ℓwidth nodes. Given an (ℓpattern, 2ℓpattern)-independent set of a subgraph P ∈Pirreg, in O(1)
rounds P can be partitioned into subpaths, each of which contains at least ℓpattern nodes and at
most 2ℓpattern nodes. This ﬁnishes the construction of an (ℓwidth, ℓcount, ℓpattern)-partition.
Combining Lemma 21 and Lemma 19, we are able to construct an (ℓwidth, ℓcount, ℓpattern)-partition
in O(1) rounds for undirected graphs.
Lemma 22. Let G be a cycle or a path where each node v ∈V (G) has an input label from Σin, and
|V (G)| > 2ℓwidth. Let ℓwidth, ℓcount, ℓpattern be three constants such that ℓpattern ≥ℓwidth. There is a
deterministic LOCAL algorithm that computes an (ℓwidth, ℓcount, ℓpattern)-partition in O(1) rounds
Proof. The algorithm is as follows. Compute an ℓ-orientation of G by Lemma 19 in O(1) rounds
with ℓ= 2ℓwidth + 1. For each maximal-length connected subgraph P where each constituent node
is oriented to the same direction, ﬁnd an (ℓwidth, ℓcount, ℓpattern)-partition of P in O(1) rounds by
Lemma 21.
4.4
Feasible Function
The goal of this section is to deﬁne a feasible function whose existence characterizes the O(1)-round
solvable LCL problems. With respect to an LCL problem P and a function f which takes a string
w ∈Σk
in with 1 ≤k ≤ℓpump as input, and returns a string f(w) ∈Σk
out, we deﬁne some partially or
completely labeled path graphs which are used in the deﬁnition of a feasible function.
Completely Labeled Graph Gw,z: Let w ∈Σ∗
in be any string of length at least 1 and at most
ℓpump. Let z be any non-negative integer. Deﬁne Gw,z = (Gw,z, L) as follows. The graph Gw,z
is a path of the form wr ◦wz ◦wr. The labeling L is a complete labeling of the form f(w)z+2r.
Deﬁne Mid(Gw,z) as the middle subpath wz of Gw,z.
Partially Labeled Graph Gw1,w2,S: Let w1, w2 ∈Σ∗
in be any two strings of length at least 1 and
at most ℓpump. Let S ∈Σ∗
in be any string (can be empty). Deﬁne Gw1,w2,S = (Gw1,w2,S, L) as
follows. The graph Gw1,w2,S is the path of the form wℓpump+2r
1
◦S ◦wℓpump+2r
2
. The labeling
L is a partial labeling of Gw1,w2,S which ﬁxes the output labels of the ﬁrst 2r|w1| and the
last 2r|w2| nodes by f(w1)2r and f(w2)2r, respectively. Deﬁne Mid(Gw1,w2,S) as the middle
subpath wℓpump+r
1
◦S ◦wℓpump+r
2
of Gw1,w2,S.
Feasible Function: We call f a feasible function if the following conditions are met: (i) For each
Gw,z = (Gw,z, L), the complete labeling L is locally consistent at all nodes in Mid(Gw,z). (ii)
Each partially labeled graph Gw1,w2,S admits a complete labeling L⋄that is locally consistent
at all nodes in Mid(Gw1,w2,S).
Lemma 23. Given an LCL problem P on cycle graphs. It is decidable whether there is a feasible
function.
27

--- Page 29 ---
Proof. Note that it is not immediate from its deﬁnition as to whether a feasible function exists is
decidable, since there appears to be inﬁnitely many graphs Gw,z and Gw1,w2,S needed to be examined.
However, the following simple observations show that it suﬃces to check only a constant number of
these graphs.
• If the complete labeling L of Gw,1 = (Gw,1, L) is locally consistent at all nodes in Mid(Gw,1),
then for all z ≥1, the complete labeling L of Gw,z = (Gw,z, L) is also locally consistent at all
nodes in Mid(Gw,z).
• If Gw1,w2,S admits a complete labeling L⋄that is locally consistent at all nodes in Mid(Gw1,w2,S),
then for each S′ such that Type(S) = Type(S′), the partially labeled graph Gw1,w2,S′ also
admits a complete labeling L⋄that is locally consistent at all nodes in Mid(Gw1,w2,S′). This is
due to Lemma 11.
Therefore, to decide whether a function f is feasible, we only need to check all possible Gw,z and
Gw1,w2,S. For each w we only need to consider the graph Gw,z with z = 1. For each w1 and w2, we
do not need to go over all S; we only need to consider (i) the empty string S = ∅, and (ii) for each
type τ, a string S ∈Σ∗
in such that Type(S) = τ. By Lemma 14, for each type τ, there exists P ∈Σx
in
with x ≤ℓpump such that Type(P) = τ. Therefore, a string S with Type(S) = τ can be found in
bounded amount of time; also note that the number of types is bounded; see Lemma 13.
For the rest of this section, we show that as long as the deterministic LOCAL complexity of
P is o(log∗n) on cycle graphs, there exists a feasible function f. In Lemma 24 we show how to
extract a function f from a given o(log∗n)-round deterministic LOCAL algorithm A, and then in
Lemma 25 we prove that such a function f is feasible. Intuitively, Lemma 24 shows that there exists
an ID-assignment such that when we run A on a subpath whose input labeling is a repetition of a
length-k pattern w, the output labeling is also a repetition of a length-k pattern w′. The function f
will be deﬁned as f(w) = w′.
Lemma 24. Let A be any deterministic LOCAL algorithm that solves P in t(n) = o(log∗n) rounds.
Then there is a number n′ and function f which takes a string w ∈Σk
in with 1 ≤k ≤ℓpump as input,
and returns a string f(w) ∈Σk
out meeting the following condition. For any P = wi ◦w2r+1 ◦wi such
that |wi| ≥t(n′) and 1 ≤|w| ≤ℓpump, there is an assignment of distinct Θ(log n′)-bit IDs to the
nodes in P such that the following is true. Simulating A on P while assuming that the total number
of nodes in the underlying graph is n′ yields the output labeling f(w)2r+1 for the middle subpath
w2r+1.
Proof. In this proof we assume that there is no such a number n′. Then we claim that using A it is
possible to obtain a deterministic LOCAL algorithm for MIS on an n-node directed cycle G without
input labeling, in O(t(n)) + O(1) = o(log∗n) rounds. This contradicts the well-known Ω(log∗n)
lower bound for MIS [20].
Let G be an n-node directed cycle without input labeling. The MIS algorithm on G is described
as follows. Let w ∈Σk
in with 1 ≤k ≤ℓpump be chosen such that for any function f, the string
f(w) ∈Σk
out does not satisfy the conditions stated in the lemma for the number n′ = nk. Deﬁne
G′ as the graph resulting from replacing each node v ∈V (G) with a path w. We can simulate the
imaginary graph G′ in the communication network G by letting each node v ∈V (G) simulate a
path w.
We execute the algorithm A on G′ while assuming that the total number of nodes is n′. The
execution takes t(n′) = O(t(n)) rounds. For each node v ∈V (G), deﬁne the color of v as the
sequence of the output labels of the path w2r simulated by the node v and the 2r −1 nodes following
28

--- Page 30 ---
v in the directed cycle G. This gives us a proper O(1)-coloring, since otherwise there must exist
a subpath P = w2r+1 of G′ such that the output labeling of P is of the form y2r+1 for some y,
contradicting our choice of w. Using the standard procedure of computing an MIS from a coloring,
with extra O(1) rounds, an MIS of G can be obtained.
Note that there is a subtle issue about how we set the IDs of nodes in V (G′). The following
method is guaranteed to output distinct IDs. Let v ∈V (G), and let u1, . . . , uk be the nodes in
V (G′) simulated by v. Then we may use ID(ui) = k · ID(v) + i.
Lemma 25. Suppose that the deterministic LOCAL complexity of P is o(log∗n) on cycle graphs.
Then there exists a feasible function f.
Proof. Let A be any deterministic LOCAL algorithm that solves P in t(n) = o(log∗n) rounds. Let
n′ and f be chosen to meet the conditions in Lemma 24 for A. The goal of the proof is to show
that f is a feasible function. According to the conditions speciﬁed in Lemma 24 for the function f,
we already know that the complete labeling L of each Gw,z = (Gw,z, L) is locally consistent at all
nodes in Mid(Gw,z). Therefore, all we need to do is the following. For each partially labeled graph
Gw1,w2,S, ﬁnd a complete labeling L⋄that is locally consistent at all nodes in Mid(Gw1,w2,S).
Given the three parameters w1, w2, and S, deﬁne G as the cycle resulting from linking the
two ends of the path wℓpump
1
◦w2r+1
1
◦wℓpump
1
◦S ◦wℓpump
2
◦w2r+1
2
◦wℓpump
2
. Deﬁne L as the partial
labeling of G which ﬁxes the output labeling of the two subpaths w2r+1
1
and w2r+1
2
by f(w1)2r+1
and f(w2)2r+1, respectively. We write P mid
1
and P mid
2
to denote the two subpaths w2r+1
1
and w2r+1
2
,
respectively.
In what follows, we show that the partially labeled graph G = (G, L) admits a legal labeling L⋄.
Since Gw1,w2,S is a subgraph of G = (G, L), such a legal labeling L⋄is also a complete labeling of
Gw1,w2,S that is locally consistent at all nodes in Mid(Gw1,w2,S).
For the rest of the proof, we show the existence of L⋄. This will be established by applying a
pumping lemma. Deﬁne the graph G′ as the result of the following operations on G.
• Replace the two subpaths wℓpump
1
by wx
1, where the number x is chosen such that x|w1| ≥
2t(n′) + r, and Type(wℓpump
1
) = Type(wx
1).
• Replace the two subpaths wℓpump
2
by wy
2, where the number y is chosen such that y|w2| ≥
2t(n′) + r, and Type(wℓpump
2
) = Type(wy
2).
The existence of the numbers x and y above is guaranteed by Lemma 15. The IDs of nodes in G′ are
assigned as follows. For i = 1, 2, select the IDs of the nodes in S
v∈P mid
i
Nt(n′)(v) in such a way that
the output labeling of P mid
i
resulting from executing A on G′ while assuming that the total number
of nodes is n′ is f(wi)2r+1. The existence of such an ID assignment is guaranteed by Lemma 24. For
all remaining nodes in G′, select their IDs in such a way that all nodes in Nr+t(n′)(v) receive distinct
IDs, for each v ∈V (G′). This ensures that the outcome of executing A on G′ while assuming that
the total number of nodes is n′ is a legal labeling.
Let L′
⋄be the legal labeling of G′ resulting from executing A with the above IDs while pretending
that the total number of nodes is n′. Note that L′
⋄must label P mid
1
and P mid
2
by f(w1)2r+1 and
f(w2)2r+1, respectively. A desired legal labeling L⋄of G can be obtained from the legal labeling L′
⋄of
G′ by applying Lemma 11, as we have Type(wℓpump
1
) = Type(wx
1) and Type(wℓpump
2
) = Type(wy
2).
4.5
The ω(1)—o(log∗n) Gap
In this section we prove that it is decidable whether a given LCL problem P has complexity Ω(log∗n)
or O(1) on cycle graphs.
29

--- Page 31 ---
Lemma 26. Let f be any feasible function. Let G be any cycle graph. Let P be any set of
disjoint subgraphs in G such that the input labeling of each P ∈P is of the form wx such that
x ≥2ℓpump + 2r, and w ∈Σk
in is a string with 1 ≤k ≤ℓpump. For each P ∈P, deﬁne the subgraph
P ′ as follows. If P is a cycle, deﬁne P ′ = P. If P is a path, write P = wℓpump ◦wi ◦wℓpump, and
deﬁne P ′ as the middle subpath wi. Let L be a partial labeling of G deﬁned as follows. For each
P = wx ∈P, ﬁx the output labels of each subpath w of P ′ by f(w). Then G = (G, L) admits a legal
labeling L⋄.
Proof. Deﬁne V1 as the set of all nodes such that v ∈V1 if v belongs to the middle subpath wj
of some path P = wℓpump ◦wr ◦wj ◦wr ◦wℓpump ∈P. By the deﬁnition of feasible function, L is
already locally consistent at all nodes in V1. Thus, all we need to do is to construct a complete
labeling L⋄of G = (G, L), and argue that L⋄is locally consistent at all nodes in V2 = V (G) \ V1.
There are two easy special cases. If P = ∅, then no output label of any node in G is ﬁxed, and
so G trivially admits a legal labeling. If P contains a cycle, then P = {G}, and hence L is already
a legal labeling as V1 = V (G).
In subsequent discussion, we restrict ourselves to the case that P is non-empty and contains only
paths. The output labeling L⋄is constructed as follows. Deﬁne Punlabeled as the maximal-length
subpaths of G that are not assigned any output labels by L. A path P ∈Punlabeled must be of the
form wℓpump
1
◦S ◦wℓpump
2
, where w1, w2 ∈Σ∗
in are two strings of length at least 1 and at most ℓpump,
and S ∈Σ∗
in can be any string (including the empty string). Given P ∈Punlabeled, we make the
following deﬁnitions.
• Deﬁne P + as the subpath of G that includes P and the r|w1| nodes preceding P, and the
r|w2| nodes following P in the graph G. Note that the set V2 is exactly the union of nodes in
P + for all P ∈Punlabeled.
• Deﬁne P ++ as the subpath of G that includes P and the 2r|w1| nodes preceding P, and the
2r|w2| nodes following P in the graph G. The path P ++ must be of the form wℓpump+2r
1
◦S ◦
wℓpump+2r
2
, and the labeling L already ﬁxes the output labels of the ﬁrst 2r|w1| and the last
2r|w2| nodes of P ++ by f(w1)2r and f(w2)2r, respectively.
Observe that the path P ++ = wℓpump+2r
1
◦S ◦wℓpump+2r
2
together with the labeling L is exactly the
partially labeled graph Gw1,w2,S. We assign the output labels to the nodes in P by the labeling
L⋄guaranteed in the deﬁnition of feasible function. It is ensured that the labeling of all nodes
within P + are locally consistent. By doing so for each P ∈Punlabeled, we obtain a desired complete
labeling that is locally consistent at all nodes in V2.
Lemma 27. Suppose that there is a feasible function f for the LCL problem P. Then there is an
O(1)-round deterministic LOCAL algorithm A on cycle graphs.
Proof. The ﬁrst step of the algorithm A is to compute an (ℓwidth, ℓcount, ℓpattern)-partition in O(1)
rounds by Lemma 22. We set ℓcount = 2ℓpump + 2r and ℓwidth = ℓpattern = ℓpump. We assume
|V (G)| > 2ℓwidth. Recall that an (ℓwidth, ℓcount, ℓpattern)-partition decomposes the cycle G into two
sets of disjoint subgraphs Pshort and Plong.
Deﬁne G′ as the graph resulting from applying the following operations on G.
For each
P ∈Pshort, replace the path P by the path P ∗= x ◦yi ◦z such that i = ℓcount, 1 ≤|y| ≤ℓpattern,
and the type of P ∗is the same as the type of P. The path P ∗is obtained via Lemma 14. Note that
each path P ∈Pshort has at least ℓwidth = ℓpump nodes and at most 2ℓwidth = 2ℓpump nodes. Deﬁne
P∗as the set of all P ∗such that P ∈Pshort. The graph G′ is simulated in the communication
graph G by electing a leader for each path P ∈Pshort to simulate P ∗.
30

--- Page 32 ---
𝑃∈𝒫short
𝑃′ = 𝑤𝑘∈𝒫long
𝑥
𝑦
𝑧
𝑃′ = 𝑤𝑘∈𝒫long
𝑥
𝑦𝑖
𝑧
𝐺
𝐺′
𝑃∗
𝑃′ = 𝑤𝑘∈𝒫long
𝑥
𝑦𝑖
𝑧𝑤ℓpump
𝑤ℓpump
𝑤𝑗
𝑃′ = 𝑤𝑘∈𝒫long
𝑥
𝑦𝑖
𝑧
𝑤ℓpump
𝑤ℓpump
𝑤𝑗
𝑃∈𝒫short
𝑃′ = 𝑤𝑘∈𝒫long
𝑥
𝑦
𝑧
(1)
(2)
(3)
(4)
𝑃∗
𝑃∗
Figure 5: Illustration of Lemma 27.
Calculate a partial labeling L′ of G′ using the feasible function f as follows. Recall ℓcount =
2ℓpump + 2r. For each P ∗= x ◦yℓpump ◦y2r ◦yℓpump ◦z ∈P∗, label the middle subpath y2r by the
function f. For each P = wℓpump ◦wi ◦wℓpump ∈Plong, label the middle subpath wi by f(w)i. Even
though a path P ∈Plong can have ω(1) nodes, this step can be done locally in O(1) rounds due to
the following property of (ℓwidth, ℓcount, ℓpattern)-partition. All nodes in a path P ∈Plong agree with
the same direction and know the primitive string w.
By Lemma 26, the remaining unlabeled nodes in G′ can be labeled to yield a legal labeling of
G′. This can be done in O(1) rounds since the connected components formed by unlabeled nodes
have at most O(1) nodes. Given any valid labeling of G′, a legal labeling of G can be obtained by
applying Lemma 11 in O(1) rounds. Remember that Type(P) = Type(P ∗) for each P ∈Pshort, and
G′ is exactly the result of replacing each P ∈Pshort by P ∗.
See Figure 5 for an illustration of Lemma 27: (1) applying a pumping lemma to extend each
path P ∈Pshort; (2) labeling the middle subpath y2r of P ∗= x ◦yℓpump ◦y2r ◦yℓpump ◦z ∈P∗and
the middle subpath wj of P ′ = wℓpump ◦wi ◦wℓpump ∈Plong by the function f; (3) the remaining
unlabeled nodes in G′ can be labeled to yield a legal labeling of G′ by Lemma 26; (4) since
Type(P) = Type(P ∗) for each P ∈Pshort, we can recover a legal labeling of G by re-labeling nodes
in each P ∈Pshort.
Combining Lemma 23, Lemma 25, and Lemma 27, we have proved Theorem 9. That is, for any
LCL problem P on cycle graphs, its deterministic LOCAL complexity is either Ω(log∗n) or O(1).
Moreover, there is an algorithm that decides whether P has complexity Ω(log∗n) or O(1) on cycle
graphs; for the case the complexity is O(1), the algorithm outputs a description of an O(1)-round
deterministic LOCAL algorithm that solves P.
Acknowledgments
Many thanks to Laurent Feuilloley, Juho Hirvonen, Janne H. Korhonen, Christoph Lenzen, Yannic
Maus, and Seth Pettie for discussions, and to anonymous reviewers for their helpful comments on
previous versions of this work. This work was supported in part by the Academy of Finland, Grant
285721.
31

--- Page 33 ---
References
[1] Alkida Balliu, Sebastian Brandt, Dennis Olivetti, and Jukka Suomela. Almost global problems
in the LOCAL model. In Proc. 32nd International Symposium on Distributed Computing (DISC
2018), Leibniz International Proceedings in Informatics (LIPIcs). Schloss DagstuhlLeibniz-
Zentrum f¨ur Informatik, 2018. doi:10.4230/LIPIcs.DISC.2018.9.
[2] Alkida Balliu, Juho Hirvonen, Janne H Korhonen, Tuomo Lempi¨ainen, Dennis Olivetti, and
Jukka Suomela. New classes of distributed time complexity. In Proc. 50th ACM Symposium on
Theory of Computing (STOC 2018), pages 1307–1318. ACM Press, 2018. doi:10.1145/3188745.
3188860.
[3] Roderick Bloem, Nicolas Braud-Santoni, and Swen Jacobs. Synthesis of Self-Stabilising and
Byzantine-Resilient Distributed Systems. In Proc. International Conference on Computer Aided
Veriﬁcation (CAV 2016), pages 157–176. Springer, 2016. doi:10.1007/978-3-319-41528-4 9.
[4] Sebastian Brandt, Orr Fischer, Juho Hirvonen, Barbara Keller, Tuomo Lempi¨ainen, Joel
Rybicki, Jukka Suomela, and Jara Uitto. A lower bound for the distributed Lov´asz local lemma.
In Proc. 48th ACM Symposium on Theory of Computing (STOC 2016), pages 479–488. ACM
Press, 2016. doi:10.1145/2897518.2897570.
[5] Sebastian Brandt, Juho Hirvonen, Janne H Korhonen, Tuomo Lempi¨ainen, Patric R J ¨Osterg˚ard,
Christopher Purcell, Joel Rybicki, Jukka Suomela, and Przemys law Uzna´nski. LCL problems
on grids. In Proc. 36th ACM Symposium on Principles of Distributed Computing (PODC 2017),
pages 101–110. ACM Press, 2017. doi:10.1145/3087801.3087833.
[6] Yi-Jun Chang and Seth Pettie. A Time Hierarchy Theorem for the LOCAL Model. In Proc.
58th IEEE Symposium on Foundations of Computer Science (FOCS 2017), pages 156–167.
IEEE, 2017. doi:10.1109/FOCS.2017.23.
[7] Yi-Jun Chang, Tsvi Kopelowitz, and Seth Pettie. An Exponential Separation between Ran-
domized and Deterministic Complexity in the LOCAL Model. In Proc. 57th IEEE Sym-
posium on Foundations of Computer Science (FOCS 2016), pages 615–624. IEEE, 2016.
doi:10.1109/FOCS.2016.72.
[8] Richard Cole and Uzi Vishkin. Deterministic coin tossing with applications to optimal parallel
list ranking. Information and Control, 70(1):32–53, 1986. doi:10.1016/S0019-9958(86)80023-7.
[9] Danny Dolev, Keijo Heljanko, Matti J¨arvisalo, Janne H Korhonen, Christoph Lenzen, Joel
Rybicki, Jukka Suomela, and Siert Wieringa.
Synchronous counting and computational
algorithm design. Journal of Computer and System Sciences, 82(2):310–332, 2016. doi:10.1016/j.
jcss.2015.09.002.
[10] Javier Esparza. Decidability and complexity of Petri net problems — An introduction. In
Lectures on Petri Nets I: Basic Models: Advances in Petri Nets, pages 374–428. Springer Berlin
Heidelberg, 1998. doi:10.1007/3-540-65306-6 20.
[11] Fathiyeh Faghih and Borzoo Bonakdarpour. SMT-Based Synthesis of Distributed Self-Stabilizing
Systems. ACM Transactions on Autonomous and Adaptive Systems, 10(3):1–26, 2015. doi:10.
1145/2767133.
32

--- Page 34 ---
[12] Manuela Fischer and Mohsen Ghaﬀari. Sublogarithmic Distributed Algorithms for Lov´asz Local
Lemma, and the Complexity Hierarchy. In Proc. 31st International Symposium on Distributed
Computing (DISC 2017), pages 18:1–18:16, 2017. doi:10.4230/LIPIcs.DISC.2017.18.
[13] Mohsen Ghaﬀari and Hsin-Hao Su. Distributed Degree Splitting, Edge Coloring, and Orien-
tations. In Proc. 28th ACM-SIAM Symposium on Discrete Algorithms (SODA 2017), pages
2505–2523. Society for Industrial and Applied Mathematics, 2017. doi:10.1137/1.9781611974782.166.
[14] Mohsen Ghaﬀari, David G Harris, and Fabian Kuhn. On Derandomizing Local Distributed
Algorithms. In Proc. 59th IEEE Symposium on Foundations of Computer Science (FOCS
2018), 2018. doi:10.1109/FOCS.2018.00069.
[15] Mohsen Ghaﬀari, Juho Hirvonen, Fabian Kuhn, and Yannic Maus. Improved Distributed
∆-Coloring. In Proc. 37th ACM Symposium on Principles of Distributed Computing (PODC
2018), pages 427–436. ACM, 2018. doi:10.1145/3212734.3212764.
[16] Andrew V. Goldberg, Serge A. Plotkin, and Gregory E. Shannon. Parallel Symmetry-Breaking in
Sparse Graphs. SIAM Journal on Discrete Mathematics, 1(4):434–446, 1988. doi:10.1137/0401044.
[17] Juho Hirvonen, Joel Rybicki, Stefan Schmid, and Jukka Suomela. Large cuts with local
algorithms on triangle-free graphs. Electronic Journal of Combinatorics, 24(4), 2017. URL
http://www.combinatorics.org/ojs/index.php/eljc/article/view/v24i4p21.
[18] John E Hopcroft and Jeﬀrey D Ullman. Introduction to Automata Theory, Languages and
Computation. Addison-Wesley, 1979.
[19] Alex Klinkhamer. On the Limits and Practice of Automatically Designing Self-Stabilization.
Doctoral thesis, Michigan Technological University, 2016. URL https://digitalcommons.mtu.
edu/etdr/90.
[20] Nathan Linial. Locality in Distributed Graph Algorithms. SIAM Journal on Computing, 21(1):
193–201, 1992. doi:10.1137/0221015.
[21] Moni Naor. A lower bound on probabilistic algorithms for distributive ring coloring. SIAM
Journal on Discrete Mathematics, 4(3):409–412, 1991. doi:10.1137/0404036.
[22] Moni Naor and Larry Stockmeyer. What Can be Computed Locally?
SIAM Journal on
Computing, 24(6):1259–1277, 1995. doi:10.1137/S0097539793254571.
[23] Alessandro Panconesi and Aravind Srinivasan. The local nature of ∆-coloring and its algorithmic
applications. Combinatorica, 15(2):255–280, 1995. doi:10.1007/BF01200759.
[24] David Peleg. Distributed Computing: A Locality-Sensitive Approach. Society for Industrial and
Applied Mathematics, 2000. doi:10.1137/1.9780898719772.
[25] Seth Pettie. Automatically Speeding Up LOCAL Graph Algorithms. In 7th Workshop on
Advances in Distributed Graph Algorithms (ADGA 2018), 2018. URL http://adga.hiit.ﬁ/2018/
Seth.pdf.
[26] Joel Rybicki and Jukka Suomela. Exact bounds for distributed graph colouring. In Proc.
22nd International Colloquium on Structural Information and Communication Complexity
(SIROCCO 2015), volume 9439 of Lecture Notes in Computer Science, pages 46–60. Springer,
2015. doi:10.1007/978-3-319-25258-2 4.
33


=== outputs.pdf ===

--- Page 1 ---
r=1: precise append-one-bit DP, congruence (with k flag),
concatenation lemmas, and a small counterexample
(formalization of corrections from notes)
Abstract
This note records precise, fully rigorous statements and proofs for the following items that were
identified as corrections in the informal notes: (1) the exact append-one-bit dynamic-programming
recurrence for the radius-1 summaries (”r=1”), including the full boundary indexing and the
base cases for short segments (length k < 4); (2) a corrected statement of the congruence lemma
that explicitly includes a k flag which carries the short-length boundary-equality pattern as
part of the type; (3) a clean concatenation lemma for Ext-tables (the summary objects used
for r = 1), with proof; (4) a succinct counterexample showing that composing binary relations
derived from summaries via an existential intermediate color can be unsound; and (5) a revised
description of the Stage-1 verifier that uses concatenation at the Ext-table level rather than
composing the two-element relations.
1
Preliminaries and notation
Fix finite alphabets
Σin = {0, 1},
Σout
and a binary relation (adjacency) E ⊆Σout × Σout. For each input bit a ∈Σin let Aa ⊆Σout be the
set of output symbols allowed at a node whose input bit equals a (we allow the natural special case
A0 = A1 = Σout). We use β := |Σout|.
A (finite) input segment (bitstring) is t = t1t2 · · · tk ∈Σk
in with k ≥1; write |t| = k. An output
coloring of t is a tuple c = (c1, . . . , ck) ∈Σk
out satisfying the local constraints
ci ∈Ati
(1 ≤i ≤k),
and
(ci, ci+1) ∈E
(1 ≤i < k).
For radius r = 1 we record a summary (the ”Ext-table”) for a segment by the colors that can
appear on the two leftmost and two rightmost positions of the segment. The mapping from a full
coloring c to its boundary quadruple depends on the segment length k because for short segments
some of the positions coincide; we formalize this below.
Definition 1.1 (boundary quadruple Bk(c)). Let t have length k ≥1 and let c = (c1, . . . , ck) be a
coloring of t. Define the boundary quadruple Bk(c) = (x1, x2, x3, x4) ∈Σ4
out by
Bk(c) = (c1, c1, c1, c1)
if k = 1,
Bk(c) = (c1, c2, c1, c2)
if k = 2,
Bk(c) = (c1, c2, c2, c3)
if k = 3,
Bk(c) = (c1, c2, ck−1, ck)
if k ≥4.
1

--- Page 2 ---
(Thus the quadruple reads “leftmost, second-from-left, second-from-right, rightmost”, with obvious
coincidences when k < 4.)
Definition 1.2 (Ext-table). For a bitstring t of length k ≥1 define
Extt := { Bk(c) : c is an output coloring of t } ⊆Σ4
out.
Intuitively Extt records exactly which assignments to the four boundary positions are extendible
to a full coloring of the interior of t; for long segments (k ≥4) the four positions are distinct.
We will also use, for any set S ⊆Σ4
out, the projections
L(S) := {(x1, x2) : ∃x3, x4, (x1, x2, x3, x4) ∈S},
R(S) := {(x3, x4) : ∃x1, x2, (x1, x2, x3, x4) ∈S}.
For a segment t we abbreviate R(Extt) by Rt when convenient; this is the set of rightmost pairs
that can occur for t.
Type and the k-flag
To make the subsequent congruence statement precise we include, as part of the summary object
for a segment, a small finite indicator that records whether boundary coordinates coincide due to
short length.
Definition 1.3 (k flag and Type). For a bitstring t let
kflag(t) := min{4, |t|} ∈{1, 2, 3, 4},
where we interpret the value 4 as the label “≥4” (i.e. kflag(t) = 4 precisely when |t| ≥4). Let
bin(t) := t1 denote the leftmost input bit of t. We define
Type(t) :=
 bin(t), Extt, kflag(t)

.
Remark. The k-flag carries the boundary-equality pattern (which coordinates in Bk(c) may
coincide) as part of the type. As shown below, equality of the full Type (not merely Ext) is preserved
under appending bits; furthermore, equality of Ext alone does not determine |t| in general (see the
short example below).
2
Append-one-bit recurrence and the r=1 congruence lemma
We first give the elementary base cases for short segments and then the general recurrence for
appending a single input bit (the ”append-one-bit” DP step). After that we state and prove the
congruence lemma in the corrected form that quantifies over Types rather than only Ext-tables.
2.1
Base cases (k < 4)
Let t be a bitstring of length k ∈{1, 2, 3}. By Definition 1.1 the set Extt has an explicit characteri-
zation in terms of small tuples:
2

--- Page 3 ---
 (Length 1) If t = (a) then
Extt = {(x, x, x, x) ∈Σ4
out : x ∈Aa}.
 (Length 2) If t = (a1, a2) then
Extt = {(x1, x2, x1, x2) ∈Σ4
out : x1 ∈Aa1, x2 ∈Aa2, (x1, x2) ∈E}.
 (Length 3) If t = (a1, a2, a3) then
Extt = {(x1, x2, x2, x3) ∈Σ4
out : xi ∈Aai (i = 1, 2, 3), (x1, x2) ∈E, (x2, x3) ∈E}.
These are immediate from the definition of Bk(c) and from the local adjacency constraints that
define a legal coloring.
2.2
Append-one-bit recurrence (general case |t| ≥3)
Let t be a bitstring of length k ≥3 and let a ∈Σin be a single input bit. Put t′ := t · a (appending
a on the right). Then t′ has length k + 1 ≥4, so a candidate boundary quadruple for t′ is of the
form (x1, x2, x3, x4) with the usual interpretation.
Proposition 2.1 (append-one-bit recurrence for k ≥3). With the notation above, for every
(x1, x2, x3, x4) ∈Σ4
out we have
(x1, x2, x3, x4) ∈Extt′
⇐⇒
x4 ∈Aa and (x3, x4) ∈E and ∃z ∈Σout : (x1, x2, z, x3) ∈Extt.
(1)
Consequently, given Extt (as a boolean table indexed by Σ4
out) one can compute Extt′ by iterating
over all β4 candidate quadruples and testing the existential over z, yielding a naive running time
O(β5) for this single append step.
Proof. The proof is identical to the straightforward ”remove the last node” and ”append a compatible
symbol” gluing argument: if a coloring of t′ realizes (x1, x2, x3, x4) then its restriction to t realizes
some quadruple (x1, x2, z, x3) ∈Extt with z the penultimate color; conversely, given such a witness
z and x4 ∈Aa with (x3, x4) ∈E, one appends x4 to the coloring of t to obtain a coloring of t′. The
details are the same as in the earlier presentation and yield equivalence (1). The cost bound follows
from testing the existential ∃z for each of the β4 candidate quadruples.
2.3
Append-one-bit: the k < 4 cases
When |t| < 4 the quadruples in Extt encode coinciding positions, therefore the recurrence in
Proposition 2.1 must be replaced by the appropriate base-case to get a correct algorithm that builds
up from length 1. We spell these out as constructive update rules that compute Extt′ from Extt
when |t| = 1, 2, 3. (These are the explicit small-length instantiations of the same gluing principle
used in the proof of Proposition 2.1.)
Let t have length k ∈{1, 2, 3} and let t′ = t · a.
3

--- Page 4 ---
 If k = 1 then t = (b) for some b ∈Σin. Using the characterization above we have
Extt = {(x, x, x, x) : x ∈Ab}.
Hence t′ has length 2 and
(x1, x2, x3, x4) ∈Extt′ ⇐⇒x1 = x3, x2 = x4, x1 ∈Ab, x2 ∈Aa, (x1, x2) ∈E.
(Operationally: enumerate x1, x2 with (x1, x2) ∈E, check x1 ∈Ab and x2 ∈Aa, and add the
quadruple (x1, x2, x1, x2).)
 If k = 2 then t = (b1, b2), and Extt consists of tuples (x1, x2, x1, x2) with adjacency (x1, x2) ∈E
and membership xi ∈Abi. The appended string t′ has length 3, and the correct condition is
(x1, x2, x3, x4) ∈Extt′ ⇐⇒x3 = x2, x1 ∈Ab1, x2 ∈Ab2, x4 ∈Aa, (x1, x2) ∈E, (x2, x4) ∈E.
(Equivalently: set c1 = x1, c2 = x2, c3 = x4 and check the two edges and the three membership
constraints.)
 If k = 3 then t = (b1, b2, b3) and Extt has tuples of the form (x1, x2, x2, x3) satisfying the two
edges (x1, x2) and (x2, x3). Appending a produces length 4, and the explicit characterization is
(x1, x2, x3, x4) ∈Extt′ ⇐⇒x1 ∈Ab1, x2 ∈Ab2, x3 ∈Ab3, x4 ∈Aa, (x1, x2) ∈E, (x2, x3) ∈E, (x3, x4) ∈E.
These formulas are the only special cases one needs when implementing a forward DP that starts
from single-bit segments and builds up by repeated appends: for k ≥3 one may use Proposition 2.1
(which in particular applies when k = 3), and for k ∈{1, 2, 3} the explicit checks above are convenient
to implement directly.
2.4
Congruence lemma (r=1), with k-flag
We now state and prove the congruence property in the corrected form: equality of Types (which
includes the k-flag) is preserved by appending a bit.
Lemma 2.2 (r=1 congruence lemma). Let P, Q be two bitstrings and suppose
Type(P) = Type(Q).
Then for every bit a ∈Σin we have
Type(P · a) = Type(Q · a).
In particular, if two segments have equal Type then appending the same input bit to both yields equal
Ext-tables and the same k-flag and leftmost input bit.
Proof. Write kP := kflag(P) and kQ := kflag(Q). The hypothesis Type(P) = Type(Q) means (by
definition of Type) that
bin(P) = bin(Q),
ExtP = ExtQ,
kP = kQ.
We prove that Type(P · a) = Type(Q · a) by a case analysis on the common k-flag kP = kQ.
4

--- Page 5 ---
Case kP = 1. Then |P| = |Q| = 1 and the explicit update rule for length 1 segments (see the
previous subsection) determines ExtP·a and ExtQ·a from ExtP = ExtQ, from Aa, and from E; the
leftmost input bit remains the same and kflag(P · a) = kflag(Q · a) = 2. Hence the two resulting
Types coincide.
Case kP = 2. Then |P| = |Q| = 2 and the corrected length-2 update rule (see above) shows
that membership in ExtP·a is determined solely by membership in ExtP , the sets Aa, and the
adjacency relation E.
Therefore ExtP·a = ExtQ·a; the leftmost bits agree by hypothesis and
kflag(P · a) = kflag(Q · a) = 3, so the Types agree.
Case kP = 3. Then |P| = |Q| = 3 and the explicit rule for k = 3 (given above) produces Ext·a from
ExtP and from Aa, E. Concretely, appending yields segments of length 4, so kflag(·a) = 4 for both
and the leftmost bit is unchanged; hence Types agree.
Case kP = 4 (that is, kP ≥4). In this case both P and Q have length at least 4, and Proposition 2.1
(the general recurrence) applies to both. The right-hand side of the recurrence (1) depends only on
ExtP (resp. ExtQ), on Aa, and on E. Since ExtP = ExtQ the outputs ExtP·a and ExtQ·a coincide;
the leftmost bits remain equal and kflag(·a) = 4 still, so Types agree.
This completes the case analysis and the proof.
Remark 2.3. Two points deserve emphasis. First, the hypothesis in Lemma 2.2 is equality of the full
Type (which includes the k-flag) and not merely equality of Ext. Second, the proof is a simple case
split on the k-flag using the explicit small-length update rules for kflag ∈{1, 2, 3} and the general
recurrence of Proposition 2.1 for kflag = 4 (i.e. |t| ≥4).
Remark 2.4 (Ext does not determine length). Equality of Ext alone does not determine |t| in
general. For instance, let Σout = {s} be a one-symbol alphabet, let E = {(s, s)} (a self-loop), and let
A0 = A1 = {s}. Then for every length k ≥1 the only legal coloring is the constant s-string, and in
every case Extt = {(s, s, s, s)}. Thus Ext is identical for all lengths, so Ext alone cannot distinguish
|t| = 2 from |t| = 4. This justifies carrying the k-flag as part of the Type.
3
Concatenation lemma for Ext-tables
Concatenation is the other fundamental operation we need. We give a clean statement that directly
tells how to compute ExtP·Q from ExtP and ExtQ (no intermediate projection to binary relations is
needed or used). The statement is valid for all lengths |P|, |Q| ≥1; the proof is a straightforward
gluing argument.
Lemma 3.1 (concatenation lemma for Ext-tables). Let P and Q be bitstrings of lengths m, n ≥1,
respectively, and let B := P · Q be their concatenation (length m + n). Then for any (o1, o2, o′
3, o′
4) ∈
Σ4
out we have
(o1, o2, o′
3, o′
4) ∈ExtB
⇐⇒∃x3, x4, x′
1, x′
2 ∈Σout : (o1, o2, x3, x4) ∈ExtP , (x′
1, x′
2, o′
3, o′
4) ∈ExtQ, and (x4, x′
1) ∈E.
(2)
In words: a boundary quadruple appears for the concatenation exactly when there exist matching
interior boundary pairs for the left and right factors whose seam colors are adjacent.
5

--- Page 6 ---
Proof. The proof is the standard gluing argument: a coloring of B restricts to colorings of P and
Q whose internal boundary coordinates provide the witnesses x3, x4, x′
1, x′
2, and conversely such
witnessing quadruples glue to a valid coloring of B if and only if the seam adjacency (x4, x′
1) ∈E holds.
The formal details are the same as in the original presentation and omitted here for brevity.
Remark 3.2. Note that the existential quantification ranges only over four symbols from Σout; a
naive implementation of (2) would therefore take time O(β8) to produce the full ExtB table by
trying all (o1, o2, o′
3, o′
4) and all witnesses x3, x4, x′
1, x′
2. In practice one can do significantly better
(e.g. by iterating witnesses x4, x′
1 first and using precomputed adjacency lists) but the point for
correctness is that concatenation is computable entirely from the two operand Ext-tables and the
adjacency E.
4
Why composing Rt via an existential intermediate color is un-
sound (a short counterexample)
It is tempting to try to speed up concatenation by passing to the binary projection Rt = R(Extt)
(the rightmost pair) and to define the right-projection of a concatenation by composing these binary
relations via an existential intermediate color m ∈Σout, i.e.
RP·Q? = {(u, w) : ∃m ∈Σout, (u, m) ∈RP and (m, w) ∈RQ}.
We give a brief counterexample showing this is unsound in general: the right-projection of the
concatenation can be strictly smaller than the projection obtained by composing the R-relations in
the above way.
Proposition 4.1 (counterexample). Let Σout = {a, b, c}, A0 = A1 = Σout, and let the adjacency
relation be
E = {(a, b), (b, c)}.
Let P and Q both be the two-bit segment 00 (length 2). Then
 RP contains the pair (a, b) (witnessing the extension a7→b on the two nodes of P), and RQ
contains the pair (b, c).
 Hence the existential composition yields the pair (a, c) via the intermediate color m = b.
 However (a, c) /∈RP·Q, i.e. there is no extension of the length-4 segment P ·Q whose rightmost
coordinate is c while the leftmost coordinate is a; consequently the composition above is unsound.
Proof. For P = 00 (two bits) a legal coloring is a pair (x1, x2) ∈Σ2
out with (x1, x2) ∈E. Thus ExtP
contains tuples of the form (x1, x2, x1, x2) exactly when (x1, x2) ∈E. In particular (a, b, a, b) ∈ExtP ,
so RP contains the rightmost pair (a, b). Similarly (b, c, b, c) ∈ExtQ so RQ contains (b, c).
The existential composition of RP and RQ therefore contains (a, c) because there exists m = b
with (a, b) ∈RP and (b, c) ∈RQ.
But consider the concatenation B := P · Q, which has length 4. A coloring of B is a tuple
(y1, y2, y3, y4) with (y1, y2), (y2, y3), (y3, y4) ∈E. If y1 = a then the only possibility for y2 is b
(because the only outgoing edge from a is to b). Then y3 must be c (because the only outgoing
edge from b is to c). But there is no outgoing edge from c in E, so there is no symbol y4 with
6

--- Page 7 ---
(y3, y4) = (c, y4) ∈E. Consequently there is no coloring of B with y1 = a and y4 = c; hence (a, c)
does not occur as the rightmost pair in any entry of ExtB. That is, (a, c) /∈RP·Q, completing the
counterexample.
This simple example illustrates that projecting summaries (here to Rt) and then composing
those projections by existentially quantifying over a single intermediate color may produce spurious
pairs: the existential witness m might be realized in different global extensions of the two factors
that are incompatible at the seam. The correct (sound) operation is concatenation at the Ext-table
level (Lemma 3.1) which enforces seam adjacency while keeping the two-sided context.
5
Rewriting the verifier specification: use concatenation, not R-
composition
Below we give a concise, explicit rewrite of the Stage-1 verifier specification (and the correspond-
ing Stage-2 checks) so that every place that previously composed R-relations via an existential
intermediate color is replaced by a concatenation of Ext-tables followed by a projection to R if
needed.
The description below is intentionally modular and abstract (it operates on the certificate objects
the prover supplies). It is stated so that it is immediately implementable using the formulas in
Lemma 3.1 and Proposition 2.1.
Inputs to the verifier
The verifier receives (from the prover/certificate) the following finite objects:
 A finite set R of representative bitstrings (the claimed representatives of the finitely many types
used by the proof). Each ρ ∈R is a bitstring in Σ∗
in.
 For each representative ρ ∈R a table Extcert
ρ
⊆Σ4
out claimed to equal the true Extρ. (Because
the certificate supplies the bitstring ρ itself, the verifier can compute kflag(ρ) and bin(ρ) if it needs
the full Type.)
 A finite set of claims (rules) of the form ”the concatenation of representatives ρb, ρc has represen-
tative ρbc”; for each such claim the certificate may also furnish (or one can derive) the asserted
relation Rcert
ρbc := R(Extcert
ρbc ) if that is part of the witnessed invariant in the original scheme.
The verifier’s job is to check that the supplied Ext-tables are self-consistent and closed under
the operations (append, concatenation) required by the scheme. It performs the following checks.
Stage-1 verifier (using concatenation)
For every asserted concatenation claim (ρb, ρc, ρbc) do the following checks:
1. Let P := ρb and Q := ρc, and compute the candidate concatenation table
Extcomp
P·Q := { (o1, o2, o′
3, o′
4) ∈Σ4
out : ∃x3, x4, x′
1, x′
2 ∈Σout s.t. (o1, o2, x3, x4) ∈Extcert
P
, (x′
1, x′
2, o′
3, o′
4) ∈Extcert
Q ,
(Use the formula of Lemma 3.1.)
7

--- Page 8 ---
2. Compute the projected right relation
Rcomp
P·Q := R(Extcomp
P·Q ).
3. Verify that the certificate’s claimed representative ρbc satisfies
Rcert
ρbc = Rcomp
P·Q
and
Extcert
ρbc = Extcomp
P·Q
if the certificate supplies Extcert
ρbc explicitly.
(At minimum the verifier must check that the
representative’s stored relation/table agrees with the one computed by concatenation; checking
equality of the full Ext-tables is sound and recommended.)
Remarks:
 The crucial change compared to the earlier, unsound specification is that the verifier does not
compute Rcomp
P·Q
simply as {(u, w) : ∃m, (u, m) ∈Rcert
P
∧(m, w) ∈Rcert
Q }. Instead the verifier
constructs the full Ext-table by concatenation and only then projects to R.
 If the certificate does not explicitly supply Extcert
ρbc but does claim the representative ρbc, the
verifier may still compute Extcomp
P·Q and check that Rcomp
P·Q equals the stored Rcert
ρbc . This is sufficient
to guarantee that the claimed representative behaves correctly as far as the right projection is
concerned.
Adjustments in Stage-2 checks
Any Stage-2 check that previously reasoned about the compatibility of two representatives by
composing their R-relations must be replaced by the corresponding check that computes the
concatenation Ext-table and then performs the required membership or projection tests on Extcomp
P·Q .
Concretely, whenever the verifier earlier intended to test
∃m ∈Σout : (u, m) ∈RP ∧(m, w) ∈RQ
it should instead test (by computing Extcomp
P·Q ) whether there exists a quadruple in Extcomp
P·Q whose
left projection matches the left context (as required) and whose right projection produces the desired
(u, w) outcome; equivalently, test membership in Rcomp
P·Q . This substitution is sound by Lemma 3.1
and avoids the spurious pairs that may be produced by existentially composing R-relations alone
(see Proposition 4.1).
6
Enumerating types (brief algorithmic remark)
When constructing or exploring the set of reachable types by repeated appends (for instance in a
BFS that enumerates all nonisomorphic Types under the append operation) the dictionary of seen
types should be keyed by the full Type triple
(bin, Ext, kflag).
Concretely, a simple BFS starts from the two single-bit types t = (0) and t = (1) (whose Types
are immediately computed), and repeatedly for each seen Type computes the Types obtained by
8

--- Page 9 ---
appending 0 and 1 using the appropriate base-case formulas when kflag ∈{1, 2, 3} and otherwise
using the general recurrence of Proposition 2.1 when kflag = 4 (i.e. |t| ≥4). If a newly computed
Type is not yet in the dictionary it is added and enqueued.
Note the monotonicity: once a Type with kflag = 4 has been reached, all of its descendants
(by appending further input bits) also have kflag = 4, and therefore future updates for these
descendants may use the general case (Proposition 2.1) exclusively. This is the reason the BFS
becomes length-agnostic beyond the threshold and why the k-flag is sufficient to control the case
analysis for appends.
7
Complexity remark
We refrain from attempting a tighter complexity analysis in this note. The elementary operations
on Ext-tables that we used above have the following simple size bounds:
 Each Extt is a subset of Σ4
out and hence can be represented in size O(β4). The projections Rt
and Lt have size O(β2).
 The naive append-one-bit step (Proposition 2.1) takes O(β5) time in the worst case per append
when implemented by brute-force enumeration of all quadruples and the existential witness.
 The naive concatenation step (Lemma 3.1) can be implemented by checking all β4 candidate
output quadruples and, for each, all β4 possible witnesses x3, x4, x′
1, x′
2, hence O(β8) time in the
worst-case with a fully naive method; modest algorithmic improvements reduce this significantly
in practice (for instance by iterating seam colors x4, x′
1 first and using lookups), but we do not
rely on such micro-optimizations here.
Because the verifier is supplied with a (potentially exponentially large) nondeterministic certificate
of representatives and Ext-tables, and because checking the correctness of the certificate requires
the potentially expensive concatenation operations above, the natural coarse-grained upper bound
to assert without further assumptions is NEXPTIME: a nondeterministic verifier can guess the
certificate and then perform the table computations and equality checks in time exponential in the
size of the original problem description. If, however, a deterministic (polynomial-time, or otherwise
bounded-time) solver for the small constraint checks is provided as an oracle, the complexity claims
can be made correspondingly stronger; in this note we intentionally keep the complexity statement
at the NEXPTIME level since no such deterministic subroutine is assumed.
8
Conclusion
We summarized and proved the corrected append-one-bit recurrence (including the full k < 4 base
cases, with the corrected length-2 update), formulated the r=1 congruence lemma in the form
that carries the k-flag in the Type, proved concatenation at the Ext-table level, displayed a simple
counterexample showing that composing R-relations via an existential intermediate color is unsound,
and rewrote the Stage-1 verifier specification (and the Stage-2 checks) so that concatenation at the
Ext-table level is used in place of the unsound R-composition. We also added the small explicit
example that shows Ext alone does not determine segment length, which justifies the inclusion of
the k-flag in the Type.
9

--- Page 10 ---
Acknowledgements. This document formalizes and expands the corrections recorded in the
informal notes supplied with the task.
10


=== round-0010/verifier.feedback.md ===
Overall status: Solid progress. The Stage‑1 path theorem is essentially in place, but a few correctness and hygiene fixes are still needed in output.md. The proposed Stage‑2 (O(1) vs Θ(log* n)) plan via the path‑feasible f0 certificate looks promising, but it depends on a constant‑time partition lemma that we have not yet formalized in this write‑up; do not add S2 to output.md yet.

Key audits and fixes:
- Contradictory remark: output.md still contains “Remark (Stage‑1 equivalence pending endpoint treatment)” even though Theorem S1‑path later resolves endpoints. This remark should be removed to avoid contradiction.
- Prop. 9 complexity mismatch: the main statement still says O(β^5) per long append while a later correction sets O(β^4). The definitive statement of Prop. 9 should claim O(β^4) for k_flag ≥ 4, with a pointer to Prop. 19; remove the separate “Correction to Prop. 9.”
- S1 (⇒) endpoint extraction hygiene: The proof currently defines g_L using w_{τ_end} and pads “on both sides.” For short τ_end, w_{τ_end} was never defined, and for an endpoint there is no left padding. Replace with: pick any finite P_end of Type τ_end; run A on P_end · S(s) · w_{τ_b} with right‑side padding only; define g_L as the output on S(s). This fixes the uninstantiated symbol and the endpoint padding issue. Symmetric for g_R.
- Minor but useful: add a one‑line Lemma E3 rephrasing the universal extendibility check as the inclusion OutR2(τ_b,s1) × OutL1(τ_c,s2) ⊆ W_{b⊙c}, which follows from Lemma E2. This both clarifies and simplifies verification.
- MIS on K‑th power: we use this in the S1 (⇐) construction. It is standard that on paths one can compute an MIS on the K‑th power in O(log* n), and consecutive MIS nodes have distance in [K,2K]. For self‑containment, include a brief lemma (with a standard reference or a short proof via Cole–Vishkin color reduction + greedy thinning).

What not to add yet:
- Stage‑2 path theorem via f0 (S2‑path): conceptually sound and well‑aligned with the literature, but it depends on an oriented‑path version of the (ℓ_width, ℓ_count, ℓ_pattern) partition (constant‑round) that is not yet in output.md. Keep S2 in notes with clear definitions (Gw,z, Gw1,w2,S, F1–F2) and an outline of the NEXPTIME verification; defer moving it to output.md until the partition lemma is proven and parameterized.

Triage/value:
- The endpoint‑coupled S1‑path framework and its proof are valuable and publication‑quality once the small textual fixes are applied.
- The incremental lemmas proposed by Prover 02 (incremental endpoint projection updates, L_allow/R_allow identities, early feasibility filters) are correct and helpful for implementation/testing; keep them in notes unless needed for the main mathematical narrative.

Concrete next steps for provers:
1) Prove and record in output.md the short MIS‑on‑Kth‑power lemma (deterministic, O(log* n), spacing [K,2K]); provide either a short self‑contained proof or a precise citation.
2) Formalize the oriented‑path partition lemma for Stage‑2 with explicit constants (suggested ℓ_width = ℓ_pattern = ℓ_pump, ℓ_count = 2ℓ_pump + 2); once done, add S2‑path to output.md using the f0 certificate (definitions Gw,z and Gw1,w2,S, F1–F2, and NEXPTIME check via Ext/W tables).
3) Add a tiny‑path completion lemma (optional): handle the “0 or 1 separator” cases with constant‑radius table lookups; align with the K used in S1.
4) Clean mild numbering friction (6/6A/6B/7) in a dedicated pass or group them under a “Base‑cases” header; add a note that Lemma 11 subsumes Lemma 2.

Testing suggestions:
- Verify E3 (set inclusion) against precomputed W_{b⊙c} on random instances.
- Regression for Prop. 19: check the O(β^4) optimized append against O(β^5) brute force for β ∈ {2,3}.
- Endpoint misalignment tests: construct instances where condition (iii) in g_L/g_R fails and confirm the verifier rejects.
- Incremental RightColors/LeftColors updates match direct recomputation from Ext after append.


=== notes.md ===
Corrections and key lemmas to record

1) Correct append-one-bit recurrence (r=1)
Given a type t with Ext_t ⊆ Σ_out^4 over boundary (L1,L2,R2,R1) and an appended input bit a, the new type t′ has boundary (L1′,L2′,R2′,R1′) = (L1,L2, old R1, new), i.e., R2′ = R1 and R1′ is the label of the appended node. Formally, for each candidate quadruple (x1,x2,x3,x4) ∈ Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [x4 ∈ A_a and E(x3,x4) and ∃ z ∈ Σ_out: (x1,x2,z,x3) ∈ Ext_t].
This yields an O(β^5) DP to fill Ext_{t′} by scanning all (x1,x2,x3,x4) and checking ∃z.

Congruence lemma (needed): If Type(P)=Type(Q), then for all a ∈ {0,1}, Type(Pa)=Type(Qa). Proof sketch: The predicate “there exists an interior completion consistent with boundary assignments” over D1∪D2 is preserved under appending one node by the above DP rule, which depends only on Ext_t and a.

2) Concatenation of summaries (r=1)
If Summ(P) has Ext_P and Summ(Q) has Ext_Q, then the concatenation B=P·Q has boundary (P.left endpoint, P.left neighbor, Q.right neighbor, Q.right endpoint) and
  (o1,o2,o3′,o4′) ∈ Ext_B ⇔ ∃ x3,x4,x1′,x2′ ∈ Σ_out: (o1,o2,x3,x4) ∈ Ext_P, (x1′,x2′,o3′,o4′) ∈ Ext_Q, and E(x4,x1′).
Then R_B can be derived from Ext_B as usual.

3) Counterexample to R-composition via ∃m
Let Σ_out={a,b,c}, A_0=A_1=Σ_out. Let E={a→b, b→c} only. Suppose t_b admits a boundary tuple with right endpoint a, and t_c admits a boundary tuple with left endpoint c (interiors arbitrary but extendible). Then choose m=b. We have (x,m) ∈ R_{t_b} for any x with a valid left edge, and (m,y) ∈ R_{t_c} for suitable y. But the concatenation t_b·t_c requires the seam edge a→c, which is forbidden. Hence ∃m composition of R_t is not sound; use Ext-level concatenation and R_B instead.
Additions and fixes (r=1)

A) Correct k=2→3 base-case update
Let t=(b1,b2) and t′=t·a (length 3). Then
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [x3=x2, x1∈A_{b1}, x2∈A_{b2}, x4∈A_a, E(x1,x2), E(x2,x4)].
This replaces any prior statement that involved x2∈A_a.

B) Type representation and congruence
Define Type(t) := (b_in(t), Ext_t, k_flag(t)), where k_flag ∈ {1,2,3,≥4} indicates whether boundary coordinates coincide due to short length. Then the congruence lemma holds in the form:
  If Type(P)=Type(Q), then for all a∈{0,1}, Type(Pa)=Type(Qa).
Proof: case split on k_flag using the explicit base-case rules for k_flag∈{1,2,3} and the general append recurrence for k_flag=≥4.
Remark: Ext equality alone does not determine |t| (e.g., with E self-loops and A_0=A_1, Ext_{len 2} = Ext_{len 4}). Hence the k_flag is necessary for a length-agnostic update routine.

C) Enumeration fix
In the BFS over types, key the dictionary by the full Type(t), including k_flag. After the first transition to k_flag=≥4, all descendants remain in k_flag=≥4 and subsequent δ updates are length-agnostic.
Additions: Stage-1 and Stage-2 specifications at the Ext level (r=1, oriented paths)

Notation. Σ_out has size β. For an input word t with bits b_in(t) ∈ {0,1}^{|t|}, let Ext_t ⊆ Σ_out^4 denote the set of boundary quadruples (L1,L2,R2,R1) = (o[1],o[2],o[|t|-1],o[|t|]) that admit an interior completion o consistent with node constraints o[i]∈A_{b_in(t)[i]} and edge constraints (o[i],o[i+1])∈E. Types are Type(t)=(Ext_t, k_flag(t)), where k_flag∈{1,2,3,≥4} encodes short-length degeneracies. Concatenation of types τ⊙σ is defined by the Ext-level concatenation rule (see outputs.md) and k_flag update.

Stage-1 (Ω(n) vs o(n)): type-level feasible function
- Universe: the finite set of types T obtained by BFS from k=1 under the append-one-bit updates (keyed by (Ext,k_flag)). For τ,σ∈T, the Ext of τ⊙σ is defined by Ext-level concatenation.
- Definition (feasible f). A function f: T × {0,1}^2 × T → Σ_out^2 mapping (τ_L, s, τ_R) to (α1,α2) is feasible if:
  (i) Node/window constraints: αi ∈ A_{s[i]} for i=1,2 and (α1,α2) ∈ E (i.e., E(α1,α2) holds).
  (ii) Universal extendibility across two separators: for all τ_a,τ_b,τ_c,τ_d∈T and s1,s2∈{0,1}^2, letting α_L := second component of f(τ_a,s1,τ_b) and α_R := first component of f(τ_c,s2,τ_d), we require
      ∃ (o1,o2,o3,o4) ∈ Ext_{τ_b ⊙ τ_c} with E(α_L,o1) and E(o4,α_R).
  Comment: The quantification over τ_a and τ_d is stronger than necessary but safe; a weaker version quantifies only over τ_b,τ_c and s1,s2. Indexing uses our convention (L1,L2,R2,R1); thus o1 and o4 are the first and last outputs of the middle block of type τ_b⊙τ_c.
- NEXPTIME check: deterministically enumerate T and all Ext_{τ} and on-demand Ext_{τ⊙σ}; nondeterministically guess f; verify (i) and (ii) exhaustively. Complexity is 2^{poly(N)} in the problem description size N.
- Status: We still owe a self-contained proof that “o(n) algorithm exists iff a feasible f exists” at the Ext level (the intended replacement of the paper’s feasible-function lemma). This will rely only on our Ext-append and Ext-concat lemmas and a standard pumping argument specialized to r=1.

Stage-2 (O(1) vs Ω(log* n)): per-type boundary-interface witness
- For each τ∈T with k_flag(τ)≥4, guess Q_τ=(L1_τ,L2_τ,R2_τ,R1_τ) with Q_τ ∈ Ext_τ. Enforce:
  (a) Local consistency and tiling: E(L1_τ,L2_τ), E(R2_τ,R1_τ), and wrap E(R1_τ,L1_τ). Intuition: long blocks of type τ can be tiled by copies using the same boundary outputs.
  (b) Bridging across any middle type (including empty): for all τ_left,τ_S,τ_right ∈ T, require either
      - if τ_S has k_flag≥1: ∃ (o1,o2,o3,o4) ∈ Ext_{τ_S} with E(R1_{τ_left},o1) and E(o4,L1_{τ_right}); or
      - if τ_S is empty: E(R1_{τ_left},L1_{τ_right}).
- Decision logic: if witnesses {Q_τ} exist and pass (a)–(b), classify O(1). Else, if a Stage-1 feasible f exists, classify Θ(log* n). Otherwise, classify Θ(n).
- Status: We still owe a concrete constant-radius construction on oriented paths from {Q_τ} (e.g., a partition/tiling routine parametrized by fixed radii ℓ_width, ℓ_pattern, ℓ_count) and a proof that the produced labeling is legal. Short types (k_flag<4) are treated as separators τ_S in (b).

Faster concatenation (proven and moved to outputs.md)
- Precompute for each τ the 3D slices: Left_τ[o1,o2,x4] := ∃x3 (o1,o2,x3,x4)∈Ext_τ, and Right_τ[x1′,o3′,o4′] := ∃x2′ (x1′,x2′,o3′,o4′)∈Ext_τ.
- Then (o1,o2,o3′,o4′)∈Ext_{τ⊙σ} iff ∃x4,x1′: Left_τ[o1,o2,x4] ∧ E(x4,x1′) ∧ Right_σ[x1′,o3′,o4′]. This allows computing Ext_{τ⊙σ} in O(β^6) time after O(β^4) precomputation per type.

Sanity checks (kept as examples)
- Trivial LCL (A_0=A_1=Σ_out, E complete): Ext_τ=Σ_out^4 for all τ; Stage-2 witness exists trivially ⇒ O(1).
- Equality LCL (E={(x,x)}): take Q_τ=(c,c,c,c) ⇒ O(1).
- Proper 2-coloring: Stage-2 fails; Stage-1 feasible f should exist ⇒ Θ(log* n).
- Linear cases with incompatible seams: Stage-1 fails ⇒ Ω(n).
Updates and clarifications (r=1, oriented paths)

1) Base-case updates finalized
- k=1→2 is special and cannot be derived from the general append recurrence without over-constraining x1=x2; we record an explicit rule in outputs.md.
- k=3→4 is also added explicitly (although it follows from the same recurrence if stated for k≥2). This ensures δ can move from short types to k_flag≥4 deterministically.

2) Type-count bound corrected
Type(t) consists of (Ext_t, k_flag(t)) only; boundary input bits are not part of Type. Hence the number of types satisfies
  |T| ≤ 4 · 2^{β^4}.
The earlier 16 · 2^{β^4} bound mixed in boundary input bits unnecessarily.

3) δ well-defined and BFS enumeration
- Seeds: k=1 types for b∈{0,1} (Ext_{(b)} = {(x,x,x,x): x∈A_b}).
- Transitions: use base-cases for k<4 (1→2, 2→3, 3→4) and Lemma 1 for k≥4. By congruence, δ(Type, a) depends only on (Ext, k_flag) and a.
- Termination and complexity: at most |T| ≤ 4·2^{β^4} insertions; each append is O(β^5) in the k≥4 regime (base-cases are ≤ O(β^4)); total time/space 2^{poly(β)}.

4) Reversal operator (optional but helpful)
Define Rev(τ) = (Ext_τ^R, k_flag(τ)) with Ext_τ^R := { (y1,y2,y3,y4) : (y4,y3,y2,y1) ∈ Ext_τ }. Then Rev(Rev(τ))=τ and Ext_{Rev(τ) ⊙ Rev(σ)} = (Ext_{σ ⊙ τ})^R.

5) Stage-1 and Stage-2 (status)
- Stage-1 (Ω(n) vs o(n)): the feasible function f: T × {0,1}^2 × T → Σ_out^2 with the universal Ext-based check (seams E(α_L, o1), E(o4, α_R), using the (L1,L2,R2,R1) ordering) is the right formal object. We still need a fully self-contained proof of the equivalence “o(n) iff such f exists”.
- Stage-2 (O(1) vs Ω(log* n)): the per-type witness Q_τ∈Ext_τ for k_flag≥4 with tiling and universal bridging checks is plausible. A complete constant-radius construction on oriented paths remains to be written and verified.

6) Sanity and regression items
- β=2 trivial LCLs and equality LCL check the base-cases and concatenation routines.
- Reconfirm the 3-color counterexample for R-composition via ∃m.
- Maintain an indexing reminder: Ext quadruples are ordered (L1,L2,R2,R1); in seam checks across a middle block of type τ_b⊙τ_c, the left seam meets o1 and the right seam meets o4.
New additions (r=1, oriented paths): pumping, general concatenation, and Stage-1 equivalence

- Pumping bound and lemmas. Let T be the set of reachable types (Proposition 9) and δ: T×{0,1}→T the append transition. Define
  ℓ_pump := |T|.
  Lemma (prefix pumping). For any input w with |w| ≥ ℓ_pump there exist x,y,z with 1 ≤ |y| ≤ ℓ_pump and |xy| ≤ ℓ_pump such that Type(x y^i z) is independent of i ≥ 0.
  Lemma (periodic pumping). For any nonempty u there exist a,b with a+b ≤ ℓ_pump such that Type(u^{a+bi}) is invariant for all i ≥ 0.
  Both follow from the pigeonhole principle applied to the δ-run over Types.

- Ext-level concatenation for all k_flags and associativity. The general concatenation rule (Ext_{P·Q} witnessed by Ext_P and Ext_Q with a seam constraint E(x4,x1′)) holds verbatim for all lengths because Ext for short words already lives in Σ_out^4 with coordinate equalities enforced by k_flag. Associativity of Ext-concatenation follows semantically (concatenation of words is associative) or by rebracketing seam witnesses.

- Stage-1 (Ω(n) vs o(n)). Restrict left/right context Types to T_long := {τ∈T : k_flag(τ)≥4}. Define a feasible f: T_long×{0,1}^2×T_long→Σ_out^2 that (i) satisfies node/edge constraints on the 2-node separator and (ii) for all τ_b,τ_c∈T_long and s1,s2, and for all τ_a,τ_d∈T_long (affecting only α_L,α_R), there exists (o1,o2,o3,o4)∈Ext_{τ_b⊙τ_c} with E(α_L,o1) and E(o4,α_R), where α_L is the second output of f(τ_a,s1,τ_b) and α_R is the first output of f(τ_c,s2,τ_d). Theorem (added to output.md): an r=1, oriented-path LCL has deterministic complexity o(n) iff such a feasible f exists. Proof outline recorded in output.md: (⇒) extract f from an o(n) algorithm via pumping and a cycle-gadget; (⇐) place separators by an MIS on the K-th power of the path with K≳ℓ_pump and solve each O(K)-long block locally using the guaranteed Ext-witness; total time O(log* n).

- Stage-2 (O(1) vs Θ(log* n)). The per-type interface Q_τ∈Ext_τ (for τ∈T_long) with tiling and universal bridging checks remains a plausible certificate. However, the constant-radius partition of an arbitrary input path into “long periodic” and “short/irregular” subpaths is not yet proven in this writeup. Do not claim S2 in output.md until a self-contained partition lemma (parameters and proof) is supplied or the construction is reworked to avoid this dependency.

- Minor lemma. Nonemptiness monotonicity under concatenation: if Ext_P and Ext_Q are nonempty and there exists at least one seam pair (x4,x1′) with E(x4,x1′), then Ext_{P·Q}≠∅. This is an immediate corollary of the general concatenation rule.

Implementation notes

- Quantify over T_long for left/right contexts in Stage-1; middle types in Stage-2 can be arbitrary (short included), handled by the general concatenation lemma.
- Precompute T by BFS (Prop. 9), split T_long vs short, cache Left_τ and Right_τ for all τ, and build Ext_{τ⊙σ} for τ,σ∈T_long (Prop. 5). ℓ_pump=|T| is computable in 2^{poly(β)}.
- Separator placement for Stage-1: in O(log* n), compute an MIS on the K-th power of the directed path for K=ℓ_pump+4; distances between consecutive separators are ≤2K, ensuring each middle block is O(K)-long and solvable in O(1) rounds by exhaustive local choice of an Ext-witness–consistent interior labeling.

Open item for Stage-2

- Provide a self-contained constant-radius partition lemma on oriented paths or redesign the Stage-2 constant-round construction to avoid reliance on periodicity. Until then, keep S2 as a notes-only plan.
Endpoint handling in Stage-1 (r=1) and refinements

- Endpoint gap (to-do). The current Stage-1 (⇐) algorithm partitions the path using a K-th power MIS with K := ℓ_pump+4 and then fills each middle block between two separators using a feasible function f. This leaves one-sided end segments (from a path endpoint to the nearest separator). The proof sketch in output.md did not treat these explicitly and incorrectly asserted that every separator has long-type contexts on both sides. A separate lemma is needed to guarantee that the seam color chosen at an endpoint-adjacent separator is compatible with the end segment’s Ext set. Alternatively, redesign the partition so that every nontrivial block lies strictly between two separators, eliminating one-sided cases. Until one of these is proven, the o(n)⇔feasible-f equivalence remains open here.

- Clean k=1→2 update (no “recover b”). For a type τ with k_flag(τ)=1, let S_τ := { x ∈ Σ_out : (x,x,x,x) ∈ Ext_τ }. Then appending a bit a yields Ext_{τ·a} consisting exactly of tuples (x1,x2,x3,x4) with x1=x3, x2=x4, x1∈S_τ, x2∈A_a, and E(x1,x2). This removes the need to speak about an internal bit b and works also when A_0=A_1.

- Optimized append in O(β^4). For k_flag≥4, define Left3_t[x1,x2,x3]:=∃z (x1,x2,z,x3)∈Ext_t. Then (x1,x2,x3,x4)∈Ext_{t·a} iff Left3_t[x1,x2,x3] ∧ E(x3,x4) ∧ x4∈A_a. Precompute Left3_t in O(β^4) time and fill Ext_{t·a} in O(β^4) time (dense worst-case).

- Out-set formulation of feasibility. Given a guessed f: T_long×{0,1}^2×T_long→Σ_out^2, define
  OutR2(τ_b,s) := { second(f(τ_a,s,τ_b)) : τ_a ∈ T_long },
  OutL1(τ_c,s) := { first(f(τ_c,s,τ_d)) : τ_d ∈ T_long }.
The universal extendibility clause is equivalent to: for all τ_b,τ_c,s1,s2 and α_L∈OutR2(τ_b,s1), α_R∈OutL1(τ_c,s2), ∃(o1,o2,o3,o4)∈Ext_{τ_b⊙τ_c} with E(α_L,o1) and E(o4,α_R). This isolates the relevant seam colors and simplifies verification.

- Seam-feasibility matrices. For faster verification and construction, precompute for each pair (τ_b,τ_c) the β×β boolean matrix W_{b⊙c}[α_L][α_R] that records whether there exists (o1,o2,o3,o4) ∈ Ext_{τ_b⊙τ_c} with E(α_L,o1) and E(o4,α_R). Then the universal extendibility checks reduce to table lookups W_{b⊙c}[α_L][α_R].

- Regression checklist.
  1) Verify optimized append equals brute-force append on random small Σ_out (β≤3).
  2) Verify associativity of Ext-concatenation on random triples of types.
  3) Verify W_{b⊙c} by direct Ext scans.
  4) Sanity: equality LCL and proper 2-coloring behave as expected.
Endpoint seam projections and matrices (r=1, oriented paths)

- For any type τ, define:
  RightColors(τ) := { y ∈ Σ_out : ∃ x1,x2,x3 with (x1,x2,x3,y) ∈ Ext_τ }.
  LeftColors(τ)  := { x ∈ Σ_out : ∃ x2,x3,y with (x,x2,x3,y) ∈ Ext_τ }.
  These are just the projections of Ext_τ to coordinates R1 and L1.

- Define endpoint seam-compatibility matrices from Ext alone:
  V_left[τ][α]  := (∃ y ∈ RightColors(τ) with E(y, α)).
  V_right[α][τ] := (∃ x ∈ LeftColors(τ) with E(α, x)).

Lemma E1 (endpoint feasibility via Ext). Fix any type τ and α ∈ Σ_out.
- There exists a legal labeling of a left end-block of type τ and the adjacent separator’s first node α iff V_left[τ][α] is true.
- There exists a legal labeling of a right end-block of type τ and the adjacent separator’s second node α iff V_right[α][τ] is true.
Proof. If (x1,x2,x3,y)∈Ext_τ and E(y,α), then the end-block interior is witnessed by Ext_τ and the seam edge by E(y,α). Conversely, any legal instance provides such y. The right case is symmetric.

Endpoint gap in Stage-1 (diagnosis and fix). Our current Stage-1 construction labels interior separators using a feasible f and fills the block between them via Ext_{τ_b ⊙ τ_c} using W_{b⊙c}. For paths, the first/last interior block is bounded on one side by an endpoint-adjacent separator. If that separator is colored by an independent g_L/g_R, the right (resp. left) seam color entering the first (resp. last) interior block may lie outside the OutR2/OutL1 sets induced by f. Then the pre-verified W_{b⊙c} guarantees do not apply, and the fill of that block can fail, even if V_left/V_right holds. Hence additional coupling is required.

Corrected Stage-1 certificate for paths (proposal). Keep T_long and f as in the Out-set formulation. Replace the 2-argument endpoint maps by 3-argument ones that are aligned with the Out-sets of the adjacent long type:
- g_L: T × {0,1}^2 × T_long → Σ_out^2. For g_L(τ_end, s, τ_b)=(β1,β2) require:
  (i) node/window legality at the separator: βi ∈ A_{s[i]} and E(β1,β2);
  (ii) one-sided feasibility toward the endpoint: V_left[τ_end][β1]=true;
  (iii) alignment with interior Out-set: β2 ∈ OutR2(τ_b, s).
- g_R: T_long × {0,1}^2 × T → Σ_out^2. For g_R(τ_c, s, τ_end)=(β1,β2) require:
  (i) node/window legality and E(β1,β2);
  (ii) one-sided feasibility toward the endpoint: V_right[β2][τ_end]=true;
  (iii) alignment with interior Out-set: β1 ∈ OutL1(τ_c, s).

With these constraints, the MIS-based O(log* n) construction proceeds as before:
- Label every interior separator by f; label the endpoint-adjacent separators using g_L/g_R (using the computed adjacent long types τ_b, τ_c on their interior sides). Fill end-blocks using Lemma E1.
- For the blocks between an endpoint-adjacent separator and its nearest interior separator, use the same W_{b⊙c} check as for interior blocks, with α_L := second(g_L(…)) or α_R := first(g_R(…)). By (iii), α_L ∈ OutR2(τ_b,·) and α_R ∈ OutL1(τ_c,·), so the precomputed W_{b⊙c} guarantees existence of a witness in Ext_{τ_b ⊙ τ_c}.

Necessity (⇒) sketch under the corrected certificate. Given an o(n)-round algorithm A:
- Extract f from A as in the cycle case (pumping + concatenation).
- For each (τ_end, s, τ_b), build a path consisting of a long pumped block of type τ_b to the right, the separator with input s, and an endpoint block of type τ_end on the left (plus pumped padding as needed outside the radius of A). Let g_L(τ_end,s,τ_b) be A’s output on the separator. Pumping ensures well-definedness and (iii). The V_left constraint follows because the seam into the endpoint segment is satisfied by A. Symmetrically define g_R.

Verification remains in 2^{poly(β)}: T, T_long, Ext, W_{b⊙c}, V_left, V_right, OutR2/OutL1 are all precomputable. The guessed tables f, g_L, g_R are checked entrywise.

Action items.
- Integrate Lemma E1 and the V_left/V_right definitions into outputs.
- Replace the current endpoint witness proposal by the 3-argument version and update both directions of the Stage-1 path theorem accordingly.
- Keep Stage-2 items in notes until a self-contained partition lemma for oriented paths is written.
Endpoint‑coupled Stage‑1 for oriented paths: resolution and integration

- Gap recap. Our earlier Stage‑1 (o(n) vs Ω(n)) write‑up did not handle the endpoint‑adjacent separators. Labeling endpoints independently (even with V_left/V_right checks) can misalign the “open” seam color toward the interior with the Out‑sets induced by the interior feasible function f, causing the first/last interior block to be unfillable.

- Fix (now integrated into output.md). We strengthen the certificate by adding 3‑argument endpoint maps coupled to Out‑sets:
  • g_L(τ_end, s, τ_b) = (β1,β2) with: (i) node/window legality; (ii) V_left[τ_end][β1]; (iii) β2 ∈ OutR2(τ_b,s).
  • g_R(τ_c, s, τ_end) = (β1,β2) with: (i) node/window legality; (ii) V_right[β2][τ_end]; (iii) β1 ∈ OutL1(τ_c,s).
  With these, the interior block between an endpoint‑adjacent separator and the nearest interior separator is covered by the same W_{b⊙c} universal checks as for interior blocks. We added an explicit Endpoint–interior bridging lemma to make this step transparent.

- Theorem S1‑path (added). For β‑normalized r=1 LCLs on globally oriented paths, an o(n)‑round deterministic algorithm exists iff there are witnesses (f_mid, g_L, g_R) satisfying the above constraints. Proof: (⇒) extract f_mid and g_L/g_R from an o(n) algorithm using pumped canonical contexts and padding outside the runtime halo; (⇐) place separators by MIS on the K‑th power (K = ℓ_pump+4), color interior separators via f_mid and endpoint‑adjacent ones via g_L/g_R, and complete all blocks by table lookups in W and V. Verification is NEXPTIME (single‑exponential) via precomputed tables.

- Complexity tightening (recorded). Using Proposition 19 (O(β^4) append for k_flag ≥ 4), the BFS enumeration in Proposition 9 uses O(β^4) per transition in the long regime.

- Minimal obstruction template (for tests). Fix τ_b with OutR2(τ_b,s) = {α}. If an uncoupled g_L outputs β2 ≠ α while V_left holds, the first interior block can fail because W_{b⊙c}[β2][·] may be all false; coupling (iii) prevents this.

- Bookkeeping. Lemma 11 subsumes Lemma 2 (general vs k_flag≥4 concatenation). There are duplicated labels around Proposition 6/6A/6B; renumbering is recommended in a clean pass.
Addendum: Stage‑2 on oriented paths via a path‑feasible function f0 (plan and checks)

We record here a path‑specialized Stage‑2 certificate that matches the cycle proof technique in the literature and avoids embedding per‑type interior fillers.

Definitions (r=1; pumping length ℓ_pump = |T| from Prop. 9)
- For a word w with 1 ≤ |w| ≤ ℓ_pump and integer z ≥ 0, define the path Gw,z := wr · wz · wr, where wr denotes a fixed context of length r = 1 on each side, and equip it with a complete output labeling f0(w)^{z+2r} (periodic by f0(w)). Mid(Gw,z) denotes the middle wz.
- For w1, w2 with 1 ≤ |wi| ≤ ℓ_pump and any finite substring S (possibly empty), define Gw1,w2,S := w1^{ℓ_pump+2r} · S · w2^{ℓ_pump+2r} with a partial labeling that fixes the first 2r|w1| outputs to f0(w1)^{2r} and the last 2r|w2| outputs to f0(w2)^{2r}. Mid(Gw1,w2,S) := w1^{ℓ_pump+r} · S · w2^{ℓ_pump+r}.

Path‑feasible function (F1)–(F2)
- f0: { w ∈ Σ_in^k : 1 ≤ k ≤ ℓ_pump } → Σ_out^k is path‑feasible if:
  (F1) For every w, the labeling f0(w) is locally legal; moreover, the labeling of Gw,1 is locally consistent on Mid(Gw,1). (Equivalently, for all z ≥ 1, Gw,z is locally consistent on its mid.)
  (F2) For every Gw1,w2,S, there exists a completion that is locally consistent on Mid(Gw1,w2,S).

Intuition and relation to Ext/W tables
- (F1) ensures that when the short word w is periodically repeated with a unit of separation (z ≥ 1), the outputs at the mid block can be anchored by f0(w) without conflict.
- (F2) ensures that any finite irregular gap S flanked by long pumped contexts with periodic mid‑anchors f0(w1), f0(w2) can be completed using constant‑radius rules, exactly mirroring how W_{b⊙c} checks mediate between Out‑sets in Stage‑1.

Verification (NEXPTIME)
- With T and Ext enumerated (Prop. 9) and the standard pumping lemmas (Lemmas 13–14), it suffices to check finitely many Gw,1 and a finite representative set of Gw1,w2,S where S ranges over types τ_S with |S| ≤ ℓ_pump (plus S = ∅). Each check reduces to Ext‑table membership and adjacency constraints; total time 2^{poly(β)}.

Construction sketch (if f0 exists; to be moved to output.md once the partition lemma is proven)
- Use an oriented‑path version of the (ℓ_width, ℓ_count, ℓ_pattern) partition (as in the cycle proof), with parameters ℓ_width = ℓ_pattern = ℓ_pump and ℓ_count = 2ℓ_pump + 2. On long periodic regions with primitive period w (|w| ≤ ℓ_pattern and repeat count ≥ ℓ_count), label the central 2r‑window of every period by f0(w), creating evenly spaced mid‑anchors. The remaining subpaths between anchors (and near endpoints) have O(ℓ_width + ℓ_pattern) length and are filled using (F2) by constant‑radius table lookups indexed by (w1, S, w2). Orientation is given, so no orientation step is required.

Sanity examples
- Equality LCL (E = {(c,c)}, A_0 = A_1 = {c}): f0(w) ≡ c^{|w|} satisfies (F1)–(F2); classified O(1).
- Proper 2‑coloring: no f0 exists (F1 fails on Gw,1 due to parity); Stage‑1 with endpoints succeeds; classified Θ(log* n).

Endpoint incremental identities and filters (implementation notes)
- Incremental projection under append (k_flag ≥ 4): RightColors(τ·a) = { y ∈ A_a : ∃ x1,x2,x3 Left3_τ[x1,x2,x3] ∧ E(x3,y) }, LeftColors(τ·a) = LeftColors(τ). Direct from Lemma 1 via projections.
- Allow sets: L_allow(τ) = N_E(RightColors(τ)), R_allow(τ) = N_E^{-1}(LeftColors(τ)). This restates V_left/V_right.
- Early feasibility filters for Stage‑1: If some OutR2(τ_b,s) or OutL1(τ_c,s) is empty, no feasible f_mid exists. If L_allow(τ_end)=∅ or OutR2(τ_b,s)=∅, then g_L(τ_end,s,τ_b) is impossible; similarly for g_R. These are constant‑time table emptiness checks.

Open items to promote S2 to output.md
- Provide a self‑contained oriented‑path partition lemma (constant rounds) with the explicit ℓ parameters above, or adapt an established reference to our notation.
- Integrate the S2‑path theorem with full proofs and NEXPTIME verification, pointing to our Ext/W machinery for the finite checks.


=== output.md ===
Setup and definitions (r=1, globally oriented paths)
- Let Σ_out be a finite output alphabet of size β. Let A_0,A_1 ⊆ Σ_out be the allowed outputs at nodes with input bit 0 or 1, respectively. Let E ⊆ Σ_out × Σ_out be the allowed directed edge relation (u→v allowed iff (u,v)∈E). For an input word t ∈ {0,1}^k with k≥1, a labeling o ∈ Σ_out^k is legal if o[i]∈A_{t[i]} for all i, and (o[i],o[i+1])∈E for all 1≤i<k.
- For k≥4, define Ext_t ⊆ Σ_out^4 as the set of boundary quadruples (L1,L2,R2,R1) that extend to a legal labeling o with L1=o[1], L2=o[2], R2=o[k−1], R1=o[k]. For k≤3, Ext_t is defined with the same 4‑tuple container but with the obvious coordinate equalities imposed by overlaps (tracked by k_flag ∈ {1,2,3,≥4}). The Type of t is Type(t) := (Ext_t, k_flag(t)).
- Indexing reminder: Throughout, boundary quadruples are ordered as (L1, L2, R2, R1).

Lemma 1 (Append‑one‑bit recurrence; k_flag ≥ 4).
Let t be an input word with k_flag(t)≥4, and let t′ := t·a be t with one bit a ∈ {0,1} appended on the right. Then for all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x4 ∈ A_a and E(x3,x4) and ∃z∈Σ_out: (x1,x2,z,x3) ∈ Ext_t ].
Proof. Standard restriction/extension argument on legal labelings. □

Proposition 6 (Base‑case update; k=1→2).
Let t=(b) be a length‑1 input and t′:=t·a the length‑2 input obtained by appending a∈{0,1}. For all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x1 = x3, x2 = x4, x1 ∈ A_b, x2 ∈ A_a, and E(x1,x2) ].
Proof. Immediate from the definition. □

Proposition 6B (Base‑case update; k=2→3).
Let t=(b1,b2) be a length‑2 input and t′:=t·a the length‑3 input obtained by appending a∈{0,1}. For all (x1,x2,x3,x4) ∈ Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x3 = x2, x1 ∈ A_{b1}, x2 ∈ A_{b2}, x4 ∈ A_a, E(x1,x2), and E(x2,x4) ].
Proof. Any legal labeling on three nodes has boundary (o1,o2,o2,o3), with o1∈A_{b1}, o2∈A_{b2}, o3∈A_a and E(o1,o2), E(o2,o3). Conversely, any tuple satisfying these constraints is realized by such a labeling. □

Proposition 7 (Base‑case update; k=3→4).
Let t=(b1,b2,b3) be a length‑3 input and t′:=t·a the length‑4 input obtained by appending a∈{0,1}. For all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x1∈A_{b1}, x2∈A_{b2}, x3∈A_{b3}, x4∈A_a, and E(x1,x2), E(x2,x3), E(x3,x4) ].
Proof. Unfold the definition on the 4‑node path. □

Lemma 2 (Ext‑level concatenation; k_flag ≥ 4).
Let P and Q be input words with k_flag(P), k_flag(Q) ≥4, and let B := P·Q. Then for all (o1,o2,o3′,o4′)∈Σ_out^4,
  (o1,o2,o3′,o4′) ∈ Ext_B ⇔ ∃ x3,x4,x1′,x2′ ∈ Σ_out such that
    (o1,o2,x3,x4) ∈ Ext_P, (x1′,x2′,o3′,o4′) ∈ Ext_Q, and E(x4,x1′).
Proof. Combine witnesses across the seam, or restrict a legal labeling of B. □

Proposition 3 (Type congruence under appending one bit).
If Type(P)=Type(Q), then for all a∈{0,1}, Type(P·a)=Type(Q·a). In particular, Ext_{P·a}=Ext_{Q·a} and k_flag updates identically.
Proof. For k_flag≥4, Lemma 1 shows Ext_{(·)·a} depends only on Ext_{(·)} and a. Short cases follow by the explicit base‑case rules. □

Proposition 4 (Unsoundness of existential R‑composition).
There exists an instance (Σ_out,A_0,A_1,E) and types t_b,t_c such that there is m∈Σ_out with (x,m) ∈ R_{t_b} and (m,y) ∈ R_{t_c} for some x,y, yet (x,y) ∉ R_{t_b·t_c}. Hence the rule “(∃m) R_{P·Q}(x,y) ⇐ R_P(x,m) ∧ R_Q(m,y)” is not valid in general.
Proof. Use Σ_out={a,b,c}, A_0=A_1=Σ_out, E={(a,b),(b,c)}; choose t_b with rightmost a and t_c with leftmost c; pick m=b. The seam would require E(a,c), which fails. □

Proposition 5 (Optimized computation of Ext for concatenation in O(β^6)).
For any types τ,σ with k_flag(τ),k_flag(σ)≥4, define the 3D slices
  Left_τ[o1,o2,x4] := ∃x3 (o1,o2,x3,x4)∈Ext_τ, and
  Right_σ[x1′,o3′,o4′] := ∃x2′ (x1′,x2′,o3′,o4′)∈Ext_σ.
Then for all (o1,o2,o3′,o4′),
  (o1,o2,o3′,o4′) ∈ Ext_{τ⊙σ} ⇔ ∃x4,x1′: Left_τ[o1,o2,x4] ∧ E(x4,x1′) ∧ Right_σ[x1′,o3′,o4′].
Moreover, after precomputing Left_τ and Right_σ for all τ,σ in O(β^4) time per type, Ext_{τ⊙σ} can be computed in O(β^6) time.
Proof. Eliminate x3,x2′ by definitions; count entries. □

Proposition 6A (k_flag=1 append update without recovering the bit).
Let τ be a type with k_flag(τ)=1 and define S_τ := { x ∈ Σ_out : (x,x,x,x) ∈ Ext_τ }. For a∈{0,1}, let τ′ := δ(τ,a). Then for all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{τ′} ⇔ [ x1=x3, x2=x4, x1∈S_τ, x2∈A_a, and E(x1,x2) ].
Proof. Any legal 2‑node labeling has boundary (o1,o2,o1,o2) with o1∈S_τ, o2∈A_a and E(o1,o2). Conversely, any tuple satisfying the listed constraints is realized by a legal labeling on the 2‑node input. □

Lemma 8 (Type‑count bound).
With Type(t):=(Ext_t, k_flag(t)) and Ext_t⊆Σ_out^4, the number of distinct types obeys |T| ≤ 4 · 2^{β^4}.
Proof. For each k_flag value, Ext can be any subset of Σ_out^4; sum over k_flag. □

Proposition 9 (δ well‑defined; deterministic BFS enumeration in 2^{poly(β)} time/space).
Let δ map a type τ and an appended bit a∈{0,1} to the type of the one‑bit extension. Define δ by:
- If k_flag(τ)=1, compute Ext of the 2‑node type by Proposition 6A using S_τ.
- If k_flag(τ)=2, use the explicit k=2→3 update (Proposition 6B).
- If k_flag(τ)=3, use Proposition 7.
- If k_flag(τ)≥4, use Lemma 1 (implementable in O(β^4) time via Proposition 19).
Then δ(τ,a) depends only on τ and a (by Proposition 3). A deterministic BFS that starts from the length‑1 seeds (t=(0) and t=(1)), repeatedly applies δ(·,0) and δ(·,1), and interns types by equality of (Ext, k_flag), halts after at most |T| insertions and enumerates all reachable types. Each transition costs O(β^4) in the k_flag≥4 regime (base‑cases are ≤O(β^4)). Since |T| ≤ 4·2^{β^4}, the total time and space are 2^{poly(β)}. □

Lemma 10 (Reversal operator; basic properties).
Define, for any type τ=(Ext_τ,k_flag(τ)), the reversed type Rev(τ):=(Ext_τ^R, k_flag(τ)), where Ext_τ^R := { (y1,y2,y3,y4) : (y4,y3,y2,y1) ∈ Ext_τ }. Then Rev(Rev(τ))=τ and, for k_flag≥4, Ext_{Rev(τ) ⊙ Rev(σ)} = (Ext_{σ ⊙ τ})^R.
Proof. Direct from definitions and Lemma 2. □

Definition (Long types and pumping bound).
- T_long := { τ ∈ T : k_flag(τ) ≥ 4 }.
- Define ℓ_pump := |T|, where T is the set of reachable Types enumerated by Proposition 9.

Lemma 11 (Ext‑level concatenation; all k_flag).
For any input words P,Q (no restriction on length) and B := P·Q, for all (o1,o2,o3′,o4′) ∈ Σ_out^4,
  (o1,o2,o3′,o4′) ∈ Ext_B ⇔ ∃ x3,x4,x1′,x2′ ∈ Σ_out:
    (o1,o2,x3,x4) ∈ Ext_P, (x1′,x2′,o3′,o4′) ∈ Ext_Q, and E(x4,x1′).
Proof. As in Lemma 2; k_flag imposes only coordinate equalities. □

Proposition 12 (Associativity of Ext‑concatenation).
For any input words P,Q,R, Ext_{(P·Q)·R} = Ext_{P·(Q·R)} as subsets of Σ_out^4.
Proof. Either semantically (concatenation of words) or by rebracketing witnesses from Lemma 11. □

Lemma 13 (Prefix pumping).
Let ℓ_pump := |T|. For any input string w with |w| ≥ ℓ_pump there exist a decomposition w = x y z with 1 ≤ |y| ≤ ℓ_pump and |x y| ≤ ℓ_pump such that Type(x y^i z) is independent of i ≥ 0.
Proof. Pigeonhole on the first ℓ_pump+1 states of the δ‑run. □

Lemma 14 (Periodic pumping).
For any nonempty string u there exist integers a,b with a+b ≤ ℓ_pump such that Type(u^{a+bi}) is invariant for all i ≥ 0.
Proof. Pigeonhole on the sequence Type(u^j), j≥0, and determinism of δ. □

Definition (Feasible function; Out‑set form).
A function f: T_long × {0,1}^2 × T_long → Σ_out^2 is feasible if for every (τ_L, s, τ_R) it outputs (α1,α2) with αi ∈ A_{s[i]} and E(α1,α2), and moreover the following universal extendibility holds: for all τ_b,τ_c∈T_long and s1,s2 ∈ {0,1}^2, and for all α_L ∈ OutR2(τ_b,s1), α_R ∈ OutL1(τ_c,s2), there exists (o1,o2,o3,o4) ∈ Ext_{τ_b ⊙ τ_c} with E(α_L,o1) and E(o4,α_R), where
  OutR2(τ_b,s) := { second(f(τ_a,s,τ_b)) : τ_a ∈ T_long },
  OutL1(τ_c,s) := { first(f(τ_c,s,τ_d)) : τ_d ∈ T_long }.

Lemma 20 (Quantifier minimization equivalence).
Let f be any function T_long×{0,1}^2×T_long→Σ_out^2 obeying node/window constraints. The universal extendibility clause stated here is equivalent to the clause “for all τ_a,τ_b,τ_c,τ_d and s1,s2, letting α_L := second(f(τ_a,s1,τ_b)) and α_R := first(f(τ_c,s2,τ_d)), there exists (o1,o2,o3,o4)∈Ext_{τ_b⊙τ_c} with E(α_L,o1), E(o4,α_R)).”
Proof. “Only if”: the α_L,α_R in the original clause range over OutR2,OutL1. “If”: for given τ_b,τ_c,s1,s2 and α_L∈OutR2, α_R∈OutL1, pick τ_a,τ_d witnessing membership and apply the original clause. □

Proposition 19 (Optimized append in O(β^4) time for k_flag ≥ 4).
For t with k_flag≥4 and a∈{0,1}, define Left3_t[x1,x2,x3] := ∃z (x1,x2,z,x3)∈Ext_t. One can compute Left3_t in O(β^4) time. Then fill Ext_{t·a} by scanning all (x1,x2,x3) with Left3_t[x1,x2,x3]=true and, for each, iterating over x4 with E(x3,x4) and x4∈A_a, setting Ext_{t·a}[x1,x2,x3,x4]←true. The total time is O(β^4) in the dense worst‑case.
Proof. Correctness follows from Lemma 1. Complexity: Left3_t has β^3 entries, each tested in O(β); the fill step is O(β^3Δ) with Δ≤β. □

Proposition 21 (Seam‑feasibility matrices for τ_b ⊙ τ_c).
For τ_b,τ_c, define W_{b⊙c}[α_L][α_R] (a β×β boolean matrix) to be true iff ∃(o1,o2,o3,o4)∈Ext_{τ_b⊙τ_c} with E(α_L,o1) and E(o4,α_R). Using precomputed 3D slices or Ext_{τ_b⊙τ_c}, W_{b⊙c} can be computed in O(β^4Δ^2) time (or better with sparse E), and then universal extendibility checks reduce to testing W_{b⊙c}[α_L][α_R].
Proof. Expand the definition via Lemma 11, eliminate internal witnesses by slices, and count operations. □

Proposition 17 (Nonemptiness monotonicity under concatenation).
If Ext_P ≠ ∅ and Ext_Q ≠ ∅ and there exist x4,x1′ with E(x4,x1′), then Ext_{P·Q} ≠ ∅.
Proof. Choose any (o1,o2,x3,x4) ∈ Ext_P and (x1′,x2′,o3′,o4′) ∈ Ext_Q; Lemma 11 and E(x4,x1′) imply (o1,o2,o3′,o4′) ∈ Ext_{P·Q}. □

Definitions (endpoint projections and seam matrices).
For any type τ, define the projections of Ext_τ to the endpoint coordinates:
- RightColors(τ) := { y ∈ Σ_out : ∃ x1,x2,x3 with (x1,x2,x3,y) ∈ Ext_τ }.
- LeftColors(τ)  := { x ∈ Σ_out : ∃ x2,x3,y with (x,x2,x3,y) ∈ Ext_τ }.
Define the endpoint seam‑compatibility matrices by
- V_left[τ][α]  := true ⇔ ∃ y ∈ RightColors(τ) with E(y, α), and
- V_right[α][τ] := true ⇔ ∃ x ∈ LeftColors(τ) with E(α, x).

Lemma E1 (Endpoint feasibility via Ext).
Let τ be any type and α ∈ Σ_out.
(i) There exists a legal labeling of a left end‑block of type τ together with an adjacent separator whose first output is α if and only if V_left[τ][α] is true.
(ii) There exists a legal labeling of a right end‑block of type τ together with an adjacent separator whose second output is α if and only if V_right[α][τ] is true.
Proof. (i) If V_left[τ][α] holds, pick y ∈ RightColors(τ) with E(y,α) and any (x1,x2,x3,y)∈Ext_τ; Ext‑membership provides the interior, and E(y,α) the seam. Conversely, any legal instance gives y as the last output on the end block, whence (x1,x2,x3,y)∈Ext_τ and E(y,α). (ii) is symmetric. □

Lemma E2 (Endpoint–interior bridging via W_{b⊙c}).
Fix τ_b, τ_c ∈ T_long, inputs s1,s2 ∈ {0,1}^2, and seam colors α_L, α_R ∈ Σ_out. There exists a legal completion of the intervening block of type τ_b ⊙ τ_c consistent with the left seam color α_L (toward τ_b) and the right seam color α_R (toward τ_c) if and only if W_{b⊙c}[α_L][α_R] is true.
Proof. Directly by definition of W_{b⊙c}: “if” is witnessed by (o1,o2,o3,o4); “only if” follows by restricting any legal completion of the intervening block to its boundary and the seam edges. □

Lemma E3 (Feasible‑f condition as set inclusion).
Let f be as in Definition “Feasible function; Out‑set form.” For all τ_b,τ_c∈T_long and s1,s2,
  OutR2(τ_b,s1) × OutL1(τ_c,s2) ⊆ { (α_L,α_R) : W_{b⊙c}[α_L][α_R] = true }.
Conversely, if these inclusions hold for all τ_b,τ_c,s1,s2, then f satisfies the universal extendibility clause.
Proof. Immediate from Lemma E2 and the definition of W_{b⊙c}. □

Definition (Endpoint maps with Out‑set alignment).
- g_L: T × {0,1}^2 × T_long → Σ_out^2. For g_L(τ_end, s, τ_b) = (β1,β2) require:
  (i) βi ∈ A_{s[i]} (i = 1,2) and E(β1,β2);
  (ii) V_left[τ_end][β1] = true;
  (iii) β2 ∈ OutR2(τ_b, s).
- g_R: T_long × {0,1}^2 × T → Σ_out^2. For g_R(τ_c, s, τ_end) = (β1,β2) require:
  (i) βi ∈ A_{s[i]} and E(β1,β2);
  (ii) V_right[β2][τ_end] = true;
  (iii) β1 ∈ OutL1(τ_c, s).

Lemma M1 (MIS on the K‑th power of a path in O(log* n); spacing [K,2K]).
For every constant K ≥ 1, there is a deterministic LOCAL algorithm that in O(log* n) rounds computes a maximal independent set on the K‑th power of the underlying undirected path. In the resulting set, consecutive selected positions are at distances in [K, 2K].
Proof sketch. First compute a proper O(1)‑coloring of the path in O(log* n) rounds (e.g., Cole–Vishkin color reduction). Then greedily construct an MIS on the K‑th power in O(1) rounds by iterating over color classes and adding a node if none of its K‑neighbors is already selected. Maximality and the spacing bounds follow from construction. □

Theorem S1‑path (Endpoint‑coupled equivalence on oriented paths).
Let an r=1 LCL be given on globally oriented paths with output alphabet Σ_out of size β. Then the following are equivalent:
(A) There exists a deterministic LOCAL algorithm with runtime o(n).
(B) There exist witnesses (f_mid, g_L, g_R) where f_mid: T_long×{0,1}^2×T_long→Σ_out^2 is feasible in the Out‑set sense (Definition “Feasible function; Out‑set form”), and g_L, g_R satisfy the endpoint map constraints above.
Moreover, existence of such witnesses is verifiable in nondeterministic time 2^{poly(β)}.

Proof.
(⇒) Assume a deterministic o(n)‑round algorithm A. Fix a large n and let R := R(n) be its runtime on paths of length n. By Lemmas 13–14 (pumping), for each τ ∈ T_long choose a canonical input string w_τ of type τ with |w_τ| ≫ R and with a short prefix y_τ of length ≤ ℓ_pump such that w_τ = x_τ y_τ^M z_τ for some M, and the δ‑state is stable across repetitions.

Define f_mid(τ_L, s, τ_R) as follows: consider W := w_{τ_L} · S(s) · w_{τ_R}, where S(s) is the 2‑node separator with input s. Assign unique identifiers so that the ID pattern is periodic and identical within the R‑neighborhoods around S(s), and pad beyond distance R into w_{τ_L}, w_{τ_R}. Run A on W and record the 2‑node output on S(s) as f_mid(τ_L, s, τ_R). Because the neighborhoods of S(s) are isomorphic across all such choices (by periodic pumping and our canonical construction), f_mid is well defined and satisfies node/window constraints. The Out‑set feasibility of f_mid holds: for any τ_b, τ_c and α_L ∈ OutR2(τ_b, s1), α_R ∈ OutL1(τ_c, s2), choose τ_a, τ_d witnessing α_L, α_R via f_mid and form the path w_{τ_b} · S(s1) · middle · S(s2) · w_{τ_c}, where “middle” is any long block of type τ_b ⊙ τ_c built from our canonical pieces and padded so that the R‑neighborhoods of the two separators are disjoint. By locality, A’s outputs on the two separators are α_L and α_R, and since A is correct, a legal completion of the middle block exists. Projecting to Ext gives W_{b⊙c}[α_L][α_R] = true, as required by the Out‑set feasibility clause.

Define g_L(τ_end, s, τ_b) as follows: pick any finite path P_end with Type(P_end)=τ_end; pick w_{τ_b} (as above) long enough so that the radius‑R neighborhood of S(s) lies entirely inside w_{τ_b} on the right. Run A on the finite path P := P_end · S(s) · w_{τ_b} (with padding only on the right beyond distance R if needed). Let g_L(τ_end,s,τ_b) be the output on S(s). Local correctness of A implies (i); the existence of a legal seam into the endpoint block yields V_left[τ_end][β1] = true (ii); and since the right context is w_{τ_b}, the second output β2 lies in OutR2(τ_b, s), giving (iii). Define g_R symmetrically by choosing any P_end of type τ_end on the right and padding on the left within w_{τ_c}.

(⇐) Assume witnesses (f_mid, g_L, g_R) as above. Let K := ℓ_pump + 4. By Lemma M1, compute in O(log* n) rounds a maximal independent set on the K‑th power of the path; consecutive MIS nodes (separators) are at distances in [K, 2K].
- Interior separators: For each separator between long blocks of types τ_b and τ_c with local inputs s1 and s2 on its two adjacent 2‑node windows, set its 2‑node output to f_mid(·). By Out‑set feasibility and Lemma E2, the block between any two consecutive interior separators is fillable via Ext_{τ_b ⊙ τ_c} using table W_{b⊙c}.
- Endpoint‑adjacent separators: Let S_L be the unique separator adjacent to the left end; compute τ_end (the type of the end block to its left) and τ_b (the long type on its right). Set S_L’s output to g_L(τ_end, s, τ_b). By Lemma E1 and condition (ii), the endpoint block can be filled. For the block between S_L and the nearest interior separator S_2 (with right‑side long type τ_c), condition (iii) gives α_L := second(g_L) ∈ OutR2(τ_b, s), while the left seam color α_R at S_2 is in OutL1(τ_c, s2) by construction. Hence W_{b⊙c}[α_L][α_R] = true, and Lemma E2 fills the intervening block. Do the right endpoint symmetrically with g_R.
- Small‑n edge cases (0 or 1 separator) are handled by brute‑force completion using Ext tables in constant radius; this does not affect asymptotic runtime.
All fillings are computed from constant‑size tables; the MIS step dominates with O(log* n) rounds. Thus we obtain an O(log* n) algorithm.

Verification complexity. Deterministically enumerate T and T_long via Proposition 9 with O(β^4) per long append (Prop. 19), precompute Ext_τ and Ext_{τ_b ⊙ τ_c}, W_{b⊙c}, V_left, V_right. For a guessed f_mid, compute OutR2 and OutL1 sets. Then check the constraints entrywise; the total time is 2^{poly(β)}.

Remark. Lemma 11 strictly subsumes Lemma 2; we retain Lemma 2 for emphasis in the k_flag ≥ 4 regime.



Current round tag: Round 0011 — 2025-08-27T19:53:26.588358Z
Return ONLY valid JSON with a single field:
{ "progress_md": "<your progress notes for this round>" }

Read output.md. If you spot gaps, errors, or missing justifications in output.md, point them out clearly inside progress_md.
