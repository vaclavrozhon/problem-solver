--- SYSTEM ---
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (summary so far)
- output.md (rigorously proven results so far)

Guidelines:
- notes.md: should be a readable running log of interesting work. Prefer appending. Replace only if old notes are clearly misleading. Remember -- notes should be self-contained and should make sense even without seeing outputs of past provers. 
- output.md:  Think twice before you add something to this file. Everything here should be rigorous, almost publication-ready. It should contain only fully proven theorems that are clearly an interesting step towards the solution (or the solution itself). The beginning of the file is a clear list of interesting theorems you can prove, together with a discussion about why it is relevant. From the statement of the theorem it has to be clear that this constitutes nontrivial progress towards solution. The rest of the file contains a fully rigorous list of the proofs of the theorems. Keep only proven theorems with clear proofs. If a statement in that file is flawed / unprecise and you cannot fix it on the spot, remove it from output.md and instead add it to notes.md with explanation.
- Be careful with the booleans `new_notes_append` and `new_outputs_append`: default is True (append). Use False only when deliberately rewriting everything.

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (≥200 words). Include concrete next-step suggestions. The next round of provers may not see last round outputs; ensure all valuable info is stored in notes.",
  "new_notes_md": "Markdown (KaTeX allowed). Usually appended to notes.",
  "new_notes_append": "True|False",
  "new_outputs_md": "Markdown (KaTeX allowed). Usually appended to output.md.",
  "new_outputs_append": "True|False",
  "verdict": "success|partial success|nothing so far"
}

**Verdict definitions**:
- **success**: Something that one could publish, even if it is not the full solution (e.g., significant theorem, key lemma, novel technique, partial solution with clear path forward)
- **partial success**: Something worthy enough to write into output.md (e.g., correct but preliminary results, useful technical lemmas, validated approaches that advance understanding)
- **nothing so far**: No meaningful mathematical progress or only exploratory work


--- USER ---
You receive multiple prover reports. Evaluate correctness, value, and pick promising directions. Update notes.md (append/replace) with useful ideas and update output.md (append/replace) ONLY with rigorously verified results.

Prover reports (JSON):
[{"prover_id": "01", "progress_md": "Round 0011 \u2014 Completing Stage\u20112 (O(1) vs \u0398(log* n)) on oriented paths in NEXPTIME, with an oriented\u2011path partition lemma and a per\u2011type boundary certificate; small audits and unit\u2011testable lemmas\n\nSummary of new ideas\n- Stage\u20112 certificate finalized for globally oriented paths via per\u2011type interfaces Q_\u03c4 (one quadruple per long type), augmented with an explicit one\u2011sided endpoint bridging clause. This keeps verification single\u2011exponential in \u03b2 and avoids enumerating all short words w (which would blow up to doubly\u2011exponential in \u03b2).\n- Oriented\u2011path partition lemma (constant rounds) specialized from the paper\u2019s cycle partition: in O(1) rounds, partition any oriented path into short segments (length \u2264 2\u2113_width) and long periodic segments with primitive period length \u2264 \u2113_pattern repeated \u2265 \u2113_count times, with each node knowing its role. This provides the scaffolding for the O(1) construction.\n- Auditable fillings: long periodic segments are tiled by Q_\u03c4 using the wrap constraint E(R1_\u03c4,L1_\u03c4); short separators between long segments are filled by the universal bridging condition using Ext_{\u03c4_S}; endpoint separators are filled by one\u2011sided bridging (new clause) that only needs a seam to the adjacent long block.\n\nGaps identified in output.md\n- Stage\u20112 theorem for oriented paths is not yet stated. The Stage\u20112 plan has been outlined in earlier notes; below I give a concrete, NEXPTIME\u2011verifiable certificate and an O(1) construction.\n- Optional: add a \u201ctiny\u2011path completion\u201d lemma formalizing the small\u2011n fallback already invoked in S1\u2011path.\n\nStage\u20112 certificate and theorem to add (path version)\nDefinitions (recalled)\n- T is the set of reachable types (Lemma 8, Prop. 9). T_long := {\u03c4 \u2208 T : k_flag(\u03c4) \u2265 4}. \u2113_pump := |T|.\n- Ext concatenation and associativity as in Lemma 11 and Prop. 12.\nCertificate per long type \u03c4 \u2208 T_long\n- Q_\u03c4 = (L1_\u03c4, L2_\u03c4, R2_\u03c4, R1_\u03c4) \u2208 Ext_\u03c4.\nChecks (three families)\n1) Local tiling and wrap (within \u03c4): E(L1_\u03c4,L2_\u03c4), E(R2_\u03c4,R1_\u03c4), and E(R1_\u03c4,L1_\u03c4).\n2) Two\u2011sided universal bridging (across any middle type): For all \u03c4_left, \u03c4_S, \u03c4_right \u2208 T (\u03c4_left, \u03c4_right \u2208 T_long; \u03c4_S arbitrary, including short), we require \u2203(o1,o2,o3,o4) \u2208 Ext_{\u03c4_S} with E(R1_{\u03c4_left}, o1) and E(o4, L1_{\u03c4_right}). (For \u03c4_S empty, the condition reduces to E(R1_{\u03c4_left}, L1_{\u03c4_right}).)\n3) One\u2011sided endpoint bridging (new, for paths): For all \u03c4 \u2208 T_long and all \u03c4_S \u2208 T, require both\n   \u2022 \u2203(o1,o2,o3,o4) \u2208 Ext_{\u03c4_S} with E(o4, L1_\u03c4) (fill a left\u2011endpoint short segment abutting a long \u03c4 on the right), and\n   \u2022 \u2203(o1,o2,o3,o4) \u2208 Ext_{\u03c4_S} with E(R1_\u03c4, o1) (fill a right\u2011endpoint short segment abutting a long \u03c4 on the left).\nWhy (3) is needed and sufficient. In the O(1) construction, any endpoint segment S has only one adjacent long block; filling S requires only a seam into that long block. The existence of a quadruple in Ext_{\u03c4_S} with the single seam satisfied guarantees a legal local labeling of S; the \u201cunused\u201d seam (toward the path boundary) imposes no constraint (there is no edge beyond the endpoint).\nTheorem S2\u2011path (oriented paths; O(1) vs \u0398(log* n))\n- Statement. A \u03b2\u2011normalized radius\u20111 LCL on globally oriented paths has deterministic complexity O(1) iff there exist {Q_\u03c4}_{\u03c4\u2208T_long} satisfying (1)\u2013(3). Otherwise, if S1\u2011path holds but no {Q_\u03c4} satisfies (1)\u2013(3), the deterministic complexity is \u0398(log* n).\n- NEXPTIME verification. Enumerate T (Prop. 9) and Ext_\u03c4 for \u03c4 \u2208 T, plus Ext_{\u03c4_S} for all \u03c4_S. Check (1) directly. For (2), iterate all triples (\u03c4_left, \u03c4_S, \u03c4_right) and test existence of (o1,o2,o3,o4)\u2208Ext_{\u03c4_S} with the two seam E\u2011constraints (this reduces to \u03b2^2 bit\u2011matrix membership with precomputed slices). For (3), for each (\u03c4, \u03c4_S) test existence of a right boundary color o4 or left boundary color o1 in Ext_{\u03c4_S} adjacent to L1_\u03c4 or from R1_\u03c4, respectively. Total work is |T_long|\u00b7\u03b2^O(1) for (1), |T_long|^2\u00b7|T|\u00b7\u03b2^O(1) for (2), and |T_long|\u00b7|T|\u00b7\u03b2^O(1) for (3), hence single\u2011exponential in \u03b2.\n- O(1) construction. In O(1) rounds, compute an (\u2113_width, \u2113_count, \u2113_pattern)\u2011partition with \u2113_width = \u2113_pattern = \u2113_pump and \u2113_count = 2\u2113_pump + 2 (lemma below). This yields a decomposition of the oriented path into:\n  \u2022 Plong: maximally long periodic subpaths with primitive period w of length \u2264 \u2113_pattern, repeated \u2265 \u2113_count; each node knows w.\n  \u2022 Pshort: short/irregular subpaths, each of length \u2264 2\u2113_width; endpoint segments belong to Pshort or (degenerate case) are absorbed by a long periodic P \u2208 Plong.\n  Labeling algorithm:\n  1) For each P \u2208 Plong, let \u03c4 be its long type (well defined by periodic pumping). Tile P by repeating the boundary interface Q_\u03c4; interior legality holds because Q_\u03c4 \u2208 Ext_\u03c4 and E(R1_\u03c4,L1_\u03c4) (wrap) closes each tile.\n  2) For each short interior S \u2208 Pshort between two long neighbors P_L and P_R with types \u03c4_L, \u03c4_R, fill S via (2): pick (o1,o2,o3,o4) \u2208 Ext_{Type(S)} that matches E(R1_{\u03c4_L},o1) and E(o4,L1_{\u03c4_R}); interior is legal by Ext membership.\n  3) For each endpoint short S \u2208 Pshort adjacent to a single long neighbor of type \u03c4, fill S via (3): pick a quadruple from Ext_{Type(S)} with o4 adjacent to L1_\u03c4 (left endpoint) or with o1 adjacent from R1_\u03c4 (right endpoint).\n  Every step is constant\u2011radius and local.\n- Proof sketches. (\u21d2) If an O(1) algorithm exists, define Q_\u03c4 by simulating it on a canonical long representative of \u03c4 (periodic pumping identifies \u03c4 in O(1)); the checks follow by restricting a legal labeling and concatenation (Lemma 11). (\u21d0) The algorithm above is constant\u2011round as all decisions depend on O(\u2113_pump)\u2011radius information and precomputed tables.\n\nOriented\u2011path partition lemma (to add)\nLemma P\u2011Partition (O(1) rounds on globally oriented paths). For constants \u2113_width, \u2113_pattern, \u2113_count with \u2113_pattern \u2265 \u2113_width, there is a deterministic LOCAL algorithm that in O(1) rounds partitions any globally oriented path into directed subpaths P such that: (i) each P has |P| \u2265 \u2113_width; (ii) Pshort := {P : |P| \u2264 2\u2113_width} are short, with each node knowing its rank in P; (iii) Plong := {P : |P| > 2\u2113_width} are periodic, each P is equal to wk for some primitive w with |w| \u2264 \u2113_pattern and k \u2265 \u2113_count, and each node knows w.\nProof idea. This is the path\u2011specialization of [paper, Lemmas 20\u201322]. Orientation is given, so no initial orientation step is needed. First, for each primitive w (|w| \u2264 \u2113_pattern), nodes can detect in O(1) whether they belong to a maximal subpath whose input is wx with x \u2265 \u2113_count + 2\u2113_width. Trim \u2113_width\u00b7|w| nodes from each end to form Plong. The remaining nodes form Pirreg; by the \u201cno long periodic fragment\u201d property, one can compute an (\u2113_pattern, 2\u2113_pattern)\u2011independent set in O(1) (as in Lemma 20 in the paper) using distinct colors defined by length\u2011\u2113 windows along the orientation, and then cut Pirreg into subpaths of lengths in [\u2113_pattern, 2\u2113_pattern] (hence \u2265 \u2113_width) with rank labels. Setting \u2113_width = \u2113_pattern = \u2113_pump and \u2113_count = 2\u2113_pump+2 fits the Stage\u20112 construction.\n\nWhy the one\u2011sided endpoint clause (3) is natural and minimal\n- Necessity: Without (3), an endpoint short segment S adjacent to a long \u03c4 could fail: Ext_{Type(S)} might have no boundary y with E(y, L1_\u03c4), preventing a legal seam into \u03c4 even though two\u2011sided bridging holds elsewhere.\n- Sufficiency: The seam toward the missing side is not constrained, so any quadruple (o1,o2,o3,o4) with E(o4, L1_\u03c4) (or E(R1_\u03c4, o1) on the other side) yields a legal interior labeling by Ext and satisfies all node/edge constraints in S.\n\nTiny\u2011path completion lemma (optional addition)\nLemma Tiny. For K := \u2113_pump+4, any oriented path of length < K can be decided (solved or declared unsolvable) in constant rounds by exhaustive lookup: enumerate all Ext for its Type and pick any legal completion (or reject). This justifies the small\u2011n fallbacks used in S1\u2011path and S2\u2011path.\n\nComplexity and implementation notes (verifier)\n- Precompute Ext_\u03c4 for \u03c4 \u2208 T (Prop. 9, Prop. 19); Ext_{\u03c4_S} for all \u03c4_S; 3D slices for fast checks (Prop. 5). Build auxiliary endpoint\u2011allow bitsets per \u03c4_S: RightAllow(\u03c4_S) := {o4 : \u2203o1,o2,o3 (o1,o2,o3,o4)\u2208Ext_{\u03c4_S}}, LeftAllow(\u03c4_S) := {o1 : \u2203o2,o3,o4 (o1,o2,o3,o4)\u2208Ext_{\u03c4_S}}; used in (3) via E adjacency.\n- Certificate size is O(|T_long|) quadruples. Verification is dominated by (2), which is O(|T_long|^2\u00b7|T|\u00b7\u03b2^2) boolean checks with precomputed slices.\n\nSanity checks\n- Equality LCL (E={(c,c)}, A_0=A_1={c}). Choose Q_\u03c4=(c,c,c,c) for all \u03c4\u2208T_long; (1)\u2013(3) trivially hold; classify O(1).\n- Proper 2\u2011coloring. No Q_\u03c4 can satisfy E(R1_\u03c4,L1_\u03c4) wrap across period\u20111, hence (1) fails; S1\u2011path accepts (feasible f_mid exists); classification \u0398(log* n).\n- Endpoint stress: Pick an instance where some \u03c4_S has RightAllow(\u03c4_S) disjoint from N_E(L1_\u03c4) for a candidate \u03c4; then (3) fails and the certificate is correctly rejected.\n\nRelation to f0\u2011based Stage\u20112 (notes)\n- The f0 certificate for cycles (Gw,z, Gw1,w2,S) is elegant but naive verification over all w with |w| \u2264 \u2113_pump is doubly exponential in \u03b2. The per\u2011type Q_\u03c4 approach keeps checks to a singly\u2011exponential scale using |T| \u2264 4\u00b72^{\u03b2^4}.\n\nConcrete next steps for output.md\n1) Add Theorem S2\u2011path with the statement above, the certificate Q_\u03c4 and checks (1)\u2013(3), proofs of (\u21d2) and (\u21d0), and the NEXPTIME verification argument.\n2) Add Lemma P\u2011Partition (or cite/adapt paper\u2019s Lemmas 20\u201322) specialized to oriented paths, with parameters \u2113_width=\u2113_pattern=\u2113_pump, \u2113_count=2\u2113_pump+2.\n3) Optionally add Lemma Tiny to justify small\u2011n fallback.\n4) Add a short \u201cEndpoint one\u2011sided bridging\u201d remark explaining why no extra endpoint tables (like V_left/V_right) are needed in Stage\u20112 beyond (3).\n\nObstacles and resolutions\n- Endpoint handling in Stage\u20112: resolved by the explicit one\u2011sided bridging clause (3), which is verifiable from Ext tables and does not enlarge asymptotics.\n- Avoiding double\u2011exponential blow\u2011up: resolved by using per\u2011type Q_\u03c4 and the partition lemma instead of an f0 on all words of length \u2264 \u2113_pump.\n\nUnit\u2011test ideas for the verifier\n- Verify (1): for random \u03c4\u2208T_long, check E(L1_\u03c4,L2_\u03c4), E(R2_\u03c4,R1_\u03c4), E(R1_\u03c4,L1_\u03c4).\n- Verify (2): build bit\u2011matrices M_{\u03c4_S}[\u03b1_L][\u03b1_R] := \u2203(o1,o2,o3,o4)\u2208Ext_{\u03c4_S} with E(\u03b1_L,o1) and E(o4,\u03b1_R). Then assert for all \u03c4_left,\u03c4_S,\u03c4_right that M_{\u03c4_S}[R1_{\u03c4_left}][L1_{\u03c4_right}] is true.\n- Verify (3): precompute RightAllow(\u03c4_S), LeftAllow(\u03c4_S); assert \u2200\u03c4,\u03c4_S that N_E(RightAllow(\u03c4_S)) contains L1_\u03c4 and N_E^{-1}(LeftAllow(\u03c4_S)) contains R1_\u03c4.\n\nMinor audit\n- S1\u2011path now includes Lemma M1; Prop. 9 states O(\u03b2^4) long append and references Prop. 19; endpoint extraction in S1 (\u21d2) uses P_end (short allowed) with one\u2011sided padding \u2014 good. I found no remaining contradictions in output.md.\n"}, {"prover_id": "02", "progress_md": "Round 0011 \u2014 Endpoint\u2011coupled Stage\u20111 is in place; hygiene fixes, tiny\u2011path fallback, and small auxiliary lemmas for verification and preprocessing\n\nAudit of output.md (gaps and clarifications)\n- Numbering hygiene. Base cases appear as Proposition 6 (k=1\u21922), Proposition 6B (k=2\u21923), and Proposition 7 (k=3\u21924), plus Proposition 6A for k_flag=1 append. This is logically fine but confusing; consider grouping the three base updates under a common \u201cBase cases\u201d header (or renumber 6,7,8) and keep the k_flag=1 variant as a lemma.\n- Interior separator wording (minor ambiguity). In Theorem S1\u2011path (\u21d0), the bullet \u201cInterior separators: For each separator between long blocks of types \u03c4_b and \u03c4_c with local inputs s1 and s2 on its two adjacent 2\u2011node windows \u2026\u201d is ambiguous (a single separator has one 2\u2011node window and one input s). Suggested clarification: \u201cFor each separator S with adjacent long types (\u03c4_L,\u03c4_R) and input s, set its 2\u2011node output to f_mid(\u03c4_L,s,\u03c4_R). For a pair of consecutive separators S1,S2 (with adjacent long types \u03c4_b,\u03c4_c to the middle block and inputs s1,s2), use W_{b\u2299c}[\u03b1_L][\u03b1_R] with \u03b1_L = second(f_mid at S1) and \u03b1_R = first(f_mid at S2) to fill the intervening block.\u201d\n- \u0394 symbol not defined. Propositions 19 and 21 use \u0394 (maximum out\u2011degree of E). Add a one\u2011line definition near Setup: \u201cLet \u0394 := max_{x\u2208\u03a3_out} |{y : E(x,y)}|.\u201d\n\nTiny\u2011path fallback (to justify the small\u2011n cases in S1\u2011path)\nLemma TP (constant\u2011radius completion for tiny paths). Let K := \u2113_pump+4. There exists a constant M = 2K such that any globally oriented path of length \u2264 M can be solved (or rejected) by a deterministic LOCAL algorithm in O(1) rounds using the precomputed Ext tables.\nSketch proof. Precompute, offline, for each input t with |t| \u2264 M, whether Ext_t \u2260 \u2205 and, if so, a witness labeling for each admissible boundary quadruple; by dynamic programming this is O(\u03b2^4\u00b72^M) preprocessing (constant in \u03b2). At runtime, each node gathers its entire path in M rounds (a constant) and applies the precomputed decision for its exact instance. This justifies the \u201c0 or 1 separator\u201d fallback in S1\u2011path. Why useful: removes the last informal piece in the (\u21d0) direction.\n\nEndpoint\u2011projection identities (implementation/verification aids)\nLemma E1\u2032 (allow sets as E\u2011neighborhoods). Define L_allow(\u03c4):={\u03b1:V_left[\u03c4][\u03b1]} and R_allow(\u03c4):={\u03b1:V_right[\u03b1][\u03c4]}. Then L_allow(\u03c4)=N_E(RightColors(\u03c4)) and R_allow(\u03c4)=N_E^{-1}(LeftColors(\u03c4)).\nProof. Immediate from definitions of V_left,V_right and the endpoint projections. Why useful: quick consistency checks and caches for verifying g_L,g_R.\n\nIncremental updates of endpoint projections under append (k_flag\u22654)\nLemma INC (fast update). For \u03c4 with k_flag(\u03c4)\u22654 and \u03c4\u2032=\u03c4\u00b7a,\n- LeftColors(\u03c4\u2032)=LeftColors(\u03c4).\n- RightColors(\u03c4\u2032)={ y\u2208A_a : \u2203x1,x2,x3 with Left3_\u03c4[x1,x2,x3] and E(x3,y) }.\nProof. Left endpoint is unchanged by appending on the right. For the right endpoint, use Lemma 1 in the Left3 formulation (Prop. 19) and project to R1. Why useful: enables incremental maintenance of V_left/V_right during \u03b4\u2011BFS in O(\u03b2^3) per long append.\n\nEarly infeasibility filters for Stage\u20111 verification\n- F1 (nonempty Out\u2011sets). If \u2203(\u03c4_b,s) with OutR2(\u03c4_b,s)=\u2205 or \u2203(\u03c4_c,s) with OutL1(\u03c4_c,s)=\u2205, then no feasible f_mid exists (reject early). Reason: universal extendibility requires these sets to be nonempty to produce seam colors.\n- F2 (endpoint viability). If L_allow(\u03c4_end)=\u2205 or R_allow(\u03c4_end)=\u2205, then no endpoint map g_L/g_R exists for \u03c4_end. Reason: V_left/V_right must be satisfiable for at least one seam color.\nWhy useful: reduces certificate search space and speeds up negative instances.\n\nExplicit clarification for Out\u2011set feasibility check\nLemma E3 (already implied; restated). For all long \u03c4_b,\u03c4_c and inputs s1,s2, the universal clause is equivalent to OutR2(\u03c4_b,s1)\u00d7OutL1(\u03c4_c,s2) \u2286 {(\u03b1_L,\u03b1_R): W_{b\u2299c}[\u03b1_L][\u03b1_R]=true}. Proof is a direct unpacking of Lemma E2 and the definition of W. Why useful: matches the verifier\u2019s implementation (matrix inclusion tests on \u03b2\u00d7\u03b2 masks).\n\nSanity check on endpoint coupling (toy obstruction)\n- Minimal obstruction persists if (iii) is dropped: choose \u03c4_b with OutR2(\u03c4_b,s)={\u03b1} and pick g_L with second output \u03b22\u2260\u03b1 but V_left true; the block between the endpoint separator and the next interior separator may be unfillable as all W_{b\u2299c}[\u03b22][\u00b7] can be false. This validates the necessity of the alignment condition in g_L/g_R.\n\nComplexity accounting (verification)\n- Precompute T via \u03b4 (Prop. 9) with O(\u03b2^4) per long append (Prop. 19), |T| \u2264 4\u00b72^{\u03b2^4}. Split T_long.\n- Build Ext_\u03c4 for \u03c4\u2208T and Ext_{\u03c4_b\u2299\u03c4_c} for all \u03c4_b,\u03c4_c\u2208T_long (Prop. 5), then W_{b\u2299c} (Prop. 21), and V_left,V_right (endpoint projections). These are all in 2^{poly(\u03b2)}.\n- Certificate sizes: f_mid has |T_long|^2\u00b74 entries; g_L has |T|\u00b7|T_long|\u00b74; g_R symmetric. Verification is table lookups; filters F1\u2013F2 prune trivially impossible instances.\n\nActionable edits to output.md\n1) Add the \u0394 definition (max out\u2011degree of E) in Setup; align Prop. 19/21 text to refer to \u0394 explicitly.\n2) Insert Lemma TP (tiny\u2011path fallback) with a one\u2011paragraph proof to justify small\u2011n handling.\n3) Add Lemma E1\u2032 (allow\u2011set identities) under the endpoint projections section (optional but harmless and testable).\n4) Optionally add Lemma INC (incremental endpoint projections) in the preprocessing/complexity section as an implementation remark to speed \u03b4\u2011BFS.\n5) Clarify the interior separator wording in S1\u2011path (\u21d0) as noted above.\n\nNext steps toward full trichotomy (kept out of output.md per prior guidance)\n- Formalize the oriented\u2011path (\u2113_width,\u2113_count,\u2113_pattern) partition (constant rounds) with parameters \u2113_width=\u2113_pattern=\u2113_pump and \u2113_count=2\u2113_pump+2; then port the f0\u2011based Stage\u20112 certificate into output.md. All checks reduce to finitely many Gw,1 and Gw1,w2,S instances with types bounded by \u2113_pump.\n- Add a short \u201ctype detection within blocks\u201d remark: since K=\u2113_pump+4 is constant, each separator can learn the input of its O(K) neighborhood in O(1) rounds and determine the adjacent long/short types locally.\n\nWhy these are incremental and auditable\n- Each lemma is a local identity or constant\u2011radius construction derived mechanically from Ext and already\u2011defined slices (Left3), and can be unit\u2011tested on small \u03b2 by direct enumeration.\n- The tiny\u2011path fallback removes an informal step, and the \u0394 definition plus interior\u2011separator wording fix readability issues without changing substance.\n- Early filters F1\u2013F2 are simple emptiness checks and can be added to the verifier immediately.\n"}]

Current notes.md:
Corrections and key lemmas to record

1) Correct append-one-bit recurrence (r=1)
Given a type t with Ext_t ⊆ Σ_out^4 over boundary (L1,L2,R2,R1) and an appended input bit a, the new type t′ has boundary (L1′,L2′,R2′,R1′) = (L1,L2, old R1, new), i.e., R2′ = R1 and R1′ is the label of the appended node. Formally, for each candidate quadruple (x1,x2,x3,x4) ∈ Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [x4 ∈ A_a and E(x3,x4) and ∃ z ∈ Σ_out: (x1,x2,z,x3) ∈ Ext_t].
This yields an O(β^5) DP to fill Ext_{t′} by scanning all (x1,x2,x3,x4) and checking ∃z.

Congruence lemma (needed): If Type(P)=Type(Q), then for all a ∈ {0,1}, Type(Pa)=Type(Qa). Proof sketch: The predicate “there exists an interior completion consistent with boundary assignments” over D1∪D2 is preserved under appending one node by the above DP rule, which depends only on Ext_t and a.

2) Concatenation of summaries (r=1)
If Summ(P) has Ext_P and Summ(Q) has Ext_Q, then the concatenation B=P·Q has boundary (P.left endpoint, P.left neighbor, Q.right neighbor, Q.right endpoint) and
  (o1,o2,o3′,o4′) ∈ Ext_B ⇔ ∃ x3,x4,x1′,x2′ ∈ Σ_out: (o1,o2,x3,x4) ∈ Ext_P, (x1′,x2′,o3′,o4′) ∈ Ext_Q, and E(x4,x1′).
Then R_B can be derived from Ext_B as usual.

3) Counterexample to R-composition via ∃m
Let Σ_out={a,b,c}, A_0=A_1=Σ_out. Let E={a→b, b→c} only. Suppose t_b admits a boundary tuple with right endpoint a, and t_c admits a boundary tuple with left endpoint c (interiors arbitrary but extendible). Then choose m=b. We have (x,m) ∈ R_{t_b} for any x with a valid left edge, and (m,y) ∈ R_{t_c} for suitable y. But the concatenation t_b·t_c requires the seam edge a→c, which is forbidden. Hence ∃m composition of R_t is not sound; use Ext-level concatenation and R_B instead.
Additions and fixes (r=1)

A) Correct k=2→3 base-case update
Let t=(b1,b2) and t′=t·a (length 3). Then
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [x3=x2, x1∈A_{b1}, x2∈A_{b2}, x4∈A_a, E(x1,x2), E(x2,x4)].
This replaces any prior statement that involved x2∈A_a.

B) Type representation and congruence
Define Type(t) := (b_in(t), Ext_t, k_flag(t)), where k_flag ∈ {1,2,3,≥4} indicates whether boundary coordinates coincide due to short length. Then the congruence lemma holds in the form:
  If Type(P)=Type(Q), then for all a∈{0,1}, Type(Pa)=Type(Qa).
Proof: case split on k_flag using the explicit base-case rules for k_flag∈{1,2,3} and the general append recurrence for k_flag=≥4.
Remark: Ext equality alone does not determine |t| (e.g., with E self-loops and A_0=A_1, Ext_{len 2} = Ext_{len 4}). Hence the k_flag is necessary for a length-agnostic update routine.

C) Enumeration fix
In the BFS over types, key the dictionary by the full Type(t), including k_flag. After the first transition to k_flag=≥4, all descendants remain in k_flag=≥4 and subsequent δ updates are length-agnostic.
Additions: Stage-1 and Stage-2 specifications at the Ext level (r=1, oriented paths)

Notation. Σ_out has size β. For an input word t with bits b_in(t) ∈ {0,1}^{|t|}, let Ext_t ⊆ Σ_out^4 denote the set of boundary quadruples (L1,L2,R2,R1) = (o[1],o[2],o[|t|-1],o[|t|]) that admit an interior completion o consistent with node constraints o[i]∈A_{b_in(t)[i]} and edge constraints (o[i],o[i+1])∈E. Types are Type(t)=(Ext_t, k_flag(t)), where k_flag∈{1,2,3,≥4} encodes short-length degeneracies. Concatenation of types τ⊙σ is defined by the Ext-level concatenation rule (see outputs.md) and k_flag update.

Stage-1 (Ω(n) vs o(n)): type-level feasible function
- Universe: the finite set of types T obtained by BFS from k=1 under the append-one-bit updates (keyed by (Ext,k_flag)). For τ,σ∈T, the Ext of τ⊙σ is defined by Ext-level concatenation.
- Definition (feasible f). A function f: T × {0,1}^2 × T → Σ_out^2 mapping (τ_L, s, τ_R) to (α1,α2) is feasible if:
  (i) Node/window constraints: αi ∈ A_{s[i]} for i=1,2 and (α1,α2) ∈ E (i.e., E(α1,α2) holds).
  (ii) Universal extendibility across two separators: for all τ_a,τ_b,τ_c,τ_d∈T and s1,s2∈{0,1}^2, letting α_L := second component of f(τ_a,s1,τ_b) and α_R := first component of f(τ_c,s2,τ_d), we require
      ∃ (o1,o2,o3,o4) ∈ Ext_{τ_b ⊙ τ_c} with E(α_L,o1) and E(o4,α_R).
  Comment: The quantification over τ_a and τ_d is stronger than necessary but safe; a weaker version quantifies only over τ_b,τ_c and s1,s2. Indexing uses our convention (L1,L2,R2,R1); thus o1 and o4 are the first and last outputs of the middle block of type τ_b⊙τ_c.
- NEXPTIME check: deterministically enumerate T and all Ext_{τ} and on-demand Ext_{τ⊙σ}; nondeterministically guess f; verify (i) and (ii) exhaustively. Complexity is 2^{poly(N)} in the problem description size N.
- Status: We still owe a self-contained proof that “o(n) algorithm exists iff a feasible f exists” at the Ext level (the intended replacement of the paper’s feasible-function lemma). This will rely only on our Ext-append and Ext-concat lemmas and a standard pumping argument specialized to r=1.

Stage-2 (O(1) vs Ω(log* n)): per-type boundary-interface witness
- For each τ∈T with k_flag(τ)≥4, guess Q_τ=(L1_τ,L2_τ,R2_τ,R1_τ) with Q_τ ∈ Ext_τ. Enforce:
  (a) Local consistency and tiling: E(L1_τ,L2_τ), E(R2_τ,R1_τ), and wrap E(R1_τ,L1_τ). Intuition: long blocks of type τ can be tiled by copies using the same boundary outputs.
  (b) Bridging across any middle type (including empty): for all τ_left,τ_S,τ_right ∈ T, require either
      - if τ_S has k_flag≥1: ∃ (o1,o2,o3,o4) ∈ Ext_{τ_S} with E(R1_{τ_left},o1) and E(o4,L1_{τ_right}); or
      - if τ_S is empty: E(R1_{τ_left},L1_{τ_right}).
- Decision logic: if witnesses {Q_τ} exist and pass (a)–(b), classify O(1). Else, if a Stage-1 feasible f exists, classify Θ(log* n). Otherwise, classify Θ(n).
- Status: We still owe a concrete constant-radius construction on oriented paths from {Q_τ} (e.g., a partition/tiling routine parametrized by fixed radii ℓ_width, ℓ_pattern, ℓ_count) and a proof that the produced labeling is legal. Short types (k_flag<4) are treated as separators τ_S in (b).

Faster concatenation (proven and moved to outputs.md)
- Precompute for each τ the 3D slices: Left_τ[o1,o2,x4] := ∃x3 (o1,o2,x3,x4)∈Ext_τ, and Right_τ[x1′,o3′,o4′] := ∃x2′ (x1′,x2′,o3′,o4′)∈Ext_τ.
- Then (o1,o2,o3′,o4′)∈Ext_{τ⊙σ} iff ∃x4,x1′: Left_τ[o1,o2,x4] ∧ E(x4,x1′) ∧ Right_σ[x1′,o3′,o4′]. This allows computing Ext_{τ⊙σ} in O(β^6) time after O(β^4) precomputation per type.

Sanity checks (kept as examples)
- Trivial LCL (A_0=A_1=Σ_out, E complete): Ext_τ=Σ_out^4 for all τ; Stage-2 witness exists trivially ⇒ O(1).
- Equality LCL (E={(x,x)}): take Q_τ=(c,c,c,c) ⇒ O(1).
- Proper 2-coloring: Stage-2 fails; Stage-1 feasible f should exist ⇒ Θ(log* n).
- Linear cases with incompatible seams: Stage-1 fails ⇒ Ω(n).
Updates and clarifications (r=1, oriented paths)

1) Base-case updates finalized
- k=1→2 is special and cannot be derived from the general append recurrence without over-constraining x1=x2; we record an explicit rule in outputs.md.
- k=3→4 is also added explicitly (although it follows from the same recurrence if stated for k≥2). This ensures δ can move from short types to k_flag≥4 deterministically.

2) Type-count bound corrected
Type(t) consists of (Ext_t, k_flag(t)) only; boundary input bits are not part of Type. Hence the number of types satisfies
  |T| ≤ 4 · 2^{β^4}.
The earlier 16 · 2^{β^4} bound mixed in boundary input bits unnecessarily.

3) δ well-defined and BFS enumeration
- Seeds: k=1 types for b∈{0,1} (Ext_{(b)} = {(x,x,x,x): x∈A_b}).
- Transitions: use base-cases for k<4 (1→2, 2→3, 3→4) and Lemma 1 for k≥4. By congruence, δ(Type, a) depends only on (Ext, k_flag) and a.
- Termination and complexity: at most |T| ≤ 4·2^{β^4} insertions; each append is O(β^5) in the k≥4 regime (base-cases are ≤ O(β^4)); total time/space 2^{poly(β)}.

4) Reversal operator (optional but helpful)
Define Rev(τ) = (Ext_τ^R, k_flag(τ)) with Ext_τ^R := { (y1,y2,y3,y4) : (y4,y3,y2,y1) ∈ Ext_τ }. Then Rev(Rev(τ))=τ and Ext_{Rev(τ) ⊙ Rev(σ)} = (Ext_{σ ⊙ τ})^R.

5) Stage-1 and Stage-2 (status)
- Stage-1 (Ω(n) vs o(n)): the feasible function f: T × {0,1}^2 × T → Σ_out^2 with the universal Ext-based check (seams E(α_L, o1), E(o4, α_R), using the (L1,L2,R2,R1) ordering) is the right formal object. We still need a fully self-contained proof of the equivalence “o(n) iff such f exists”.
- Stage-2 (O(1) vs Ω(log* n)): the per-type witness Q_τ∈Ext_τ for k_flag≥4 with tiling and universal bridging checks is plausible. A complete constant-radius construction on oriented paths remains to be written and verified.

6) Sanity and regression items
- β=2 trivial LCLs and equality LCL check the base-cases and concatenation routines.
- Reconfirm the 3-color counterexample for R-composition via ∃m.
- Maintain an indexing reminder: Ext quadruples are ordered (L1,L2,R2,R1); in seam checks across a middle block of type τ_b⊙τ_c, the left seam meets o1 and the right seam meets o4.
New additions (r=1, oriented paths): pumping, general concatenation, and Stage-1 equivalence

- Pumping bound and lemmas. Let T be the set of reachable types (Proposition 9) and δ: T×{0,1}→T the append transition. Define
  ℓ_pump := |T|.
  Lemma (prefix pumping). For any input w with |w| ≥ ℓ_pump there exist x,y,z with 1 ≤ |y| ≤ ℓ_pump and |xy| ≤ ℓ_pump such that Type(x y^i z) is independent of i ≥ 0.
  Lemma (periodic pumping). For any nonempty u there exist a,b with a+b ≤ ℓ_pump such that Type(u^{a+bi}) is invariant for all i ≥ 0.
  Both follow from the pigeonhole principle applied to the δ-run over Types.

- Ext-level concatenation for all k_flags and associativity. The general concatenation rule (Ext_{P·Q} witnessed by Ext_P and Ext_Q with a seam constraint E(x4,x1′)) holds verbatim for all lengths because Ext for short words already lives in Σ_out^4 with coordinate equalities enforced by k_flag. Associativity of Ext-concatenation follows semantically (concatenation of words is associative) or by rebracketing seam witnesses.

- Stage-1 (Ω(n) vs o(n)). Restrict left/right context Types to T_long := {τ∈T : k_flag(τ)≥4}. Define a feasible f: T_long×{0,1}^2×T_long→Σ_out^2 that (i) satisfies node/edge constraints on the 2-node separator and (ii) for all τ_b,τ_c∈T_long and s1,s2, and for all τ_a,τ_d∈T_long (affecting only α_L,α_R), there exists (o1,o2,o3,o4)∈Ext_{τ_b⊙τ_c} with E(α_L,o1) and E(o4,α_R), where α_L is the second output of f(τ_a,s1,τ_b) and α_R is the first output of f(τ_c,s2,τ_d). Theorem (added to output.md): an r=1, oriented-path LCL has deterministic complexity o(n) iff such a feasible f exists. Proof outline recorded in output.md: (⇒) extract f from an o(n) algorithm via pumping and a cycle-gadget; (⇐) place separators by an MIS on the K-th power of the path with K≳ℓ_pump and solve each O(K)-long block locally using the guaranteed Ext-witness; total time O(log* n).

- Stage-2 (O(1) vs Θ(log* n)). The per-type interface Q_τ∈Ext_τ (for τ∈T_long) with tiling and universal bridging checks remains a plausible certificate. However, the constant-radius partition of an arbitrary input path into “long periodic” and “short/irregular” subpaths is not yet proven in this writeup. Do not claim S2 in output.md until a self-contained partition lemma (parameters and proof) is supplied or the construction is reworked to avoid this dependency.

- Minor lemma. Nonemptiness monotonicity under concatenation: if Ext_P and Ext_Q are nonempty and there exists at least one seam pair (x4,x1′) with E(x4,x1′), then Ext_{P·Q}≠∅. This is an immediate corollary of the general concatenation rule.

Implementation notes

- Quantify over T_long for left/right contexts in Stage-1; middle types in Stage-2 can be arbitrary (short included), handled by the general concatenation lemma.
- Precompute T by BFS (Prop. 9), split T_long vs short, cache Left_τ and Right_τ for all τ, and build Ext_{τ⊙σ} for τ,σ∈T_long (Prop. 5). ℓ_pump=|T| is computable in 2^{poly(β)}.
- Separator placement for Stage-1: in O(log* n), compute an MIS on the K-th power of the directed path for K=ℓ_pump+4; distances between consecutive separators are ≤2K, ensuring each middle block is O(K)-long and solvable in O(1) rounds by exhaustive local choice of an Ext-witness–consistent interior labeling.

Open item for Stage-2

- Provide a self-contained constant-radius partition lemma on oriented paths or redesign the Stage-2 constant-round construction to avoid reliance on periodicity. Until then, keep S2 as a notes-only plan.
Endpoint handling in Stage-1 (r=1) and refinements

- Endpoint gap (to-do). The current Stage-1 (⇐) algorithm partitions the path using a K-th power MIS with K := ℓ_pump+4 and then fills each middle block between two separators using a feasible function f. This leaves one-sided end segments (from a path endpoint to the nearest separator). The proof sketch in output.md did not treat these explicitly and incorrectly asserted that every separator has long-type contexts on both sides. A separate lemma is needed to guarantee that the seam color chosen at an endpoint-adjacent separator is compatible with the end segment’s Ext set. Alternatively, redesign the partition so that every nontrivial block lies strictly between two separators, eliminating one-sided cases. Until one of these is proven, the o(n)⇔feasible-f equivalence remains open here.

- Clean k=1→2 update (no “recover b”). For a type τ with k_flag(τ)=1, let S_τ := { x ∈ Σ_out : (x,x,x,x) ∈ Ext_τ }. Then appending a bit a yields Ext_{τ·a} consisting exactly of tuples (x1,x2,x3,x4) with x1=x3, x2=x4, x1∈S_τ, x2∈A_a, and E(x1,x2). This removes the need to speak about an internal bit b and works also when A_0=A_1.

- Optimized append in O(β^4). For k_flag≥4, define Left3_t[x1,x2,x3]:=∃z (x1,x2,z,x3)∈Ext_t. Then (x1,x2,x3,x4)∈Ext_{t·a} iff Left3_t[x1,x2,x3] ∧ E(x3,x4) ∧ x4∈A_a. Precompute Left3_t in O(β^4) time and fill Ext_{t·a} in O(β^4) time (dense worst-case).

- Out-set formulation of feasibility. Given a guessed f: T_long×{0,1}^2×T_long→Σ_out^2, define
  OutR2(τ_b,s) := { second(f(τ_a,s,τ_b)) : τ_a ∈ T_long },
  OutL1(τ_c,s) := { first(f(τ_c,s,τ_d)) : τ_d ∈ T_long }.
The universal extendibility clause is equivalent to: for all τ_b,τ_c,s1,s2 and α_L∈OutR2(τ_b,s1), α_R∈OutL1(τ_c,s2), ∃(o1,o2,o3,o4)∈Ext_{τ_b⊙τ_c} with E(α_L,o1) and E(o4,α_R). This isolates the relevant seam colors and simplifies verification.

- Seam-feasibility matrices. For faster verification and construction, precompute for each pair (τ_b,τ_c) the β×β boolean matrix W_{b⊙c}[α_L][α_R] that records whether there exists (o1,o2,o3,o4) ∈ Ext_{τ_b⊙τ_c} with E(α_L,o1) and E(o4,α_R). Then the universal extendibility checks reduce to table lookups W_{b⊙c}[α_L][α_R].

- Regression checklist.
  1) Verify optimized append equals brute-force append on random small Σ_out (β≤3).
  2) Verify associativity of Ext-concatenation on random triples of types.
  3) Verify W_{b⊙c} by direct Ext scans.
  4) Sanity: equality LCL and proper 2-coloring behave as expected.
Endpoint seam projections and matrices (r=1, oriented paths)

- For any type τ, define:
  RightColors(τ) := { y ∈ Σ_out : ∃ x1,x2,x3 with (x1,x2,x3,y) ∈ Ext_τ }.
  LeftColors(τ)  := { x ∈ Σ_out : ∃ x2,x3,y with (x,x2,x3,y) ∈ Ext_τ }.
  These are just the projections of Ext_τ to coordinates R1 and L1.

- Define endpoint seam-compatibility matrices from Ext alone:
  V_left[τ][α]  := (∃ y ∈ RightColors(τ) with E(y, α)).
  V_right[α][τ] := (∃ x ∈ LeftColors(τ) with E(α, x)).

Lemma E1 (endpoint feasibility via Ext). Fix any type τ and α ∈ Σ_out.
- There exists a legal labeling of a left end-block of type τ and the adjacent separator’s first node α iff V_left[τ][α] is true.
- There exists a legal labeling of a right end-block of type τ and the adjacent separator’s second node α iff V_right[α][τ] is true.
Proof. If (x1,x2,x3,y)∈Ext_τ and E(y,α), then the end-block interior is witnessed by Ext_τ and the seam edge by E(y,α). Conversely, any legal instance provides such y. The right case is symmetric.

Endpoint gap in Stage-1 (diagnosis and fix). Our current Stage-1 construction labels interior separators using a feasible f and fills the block between them via Ext_{τ_b ⊙ τ_c} using W_{b⊙c}. For paths, the first/last interior block is bounded on one side by an endpoint-adjacent separator. If that separator is colored by an independent g_L/g_R, the right (resp. left) seam color entering the first (resp. last) interior block may lie outside the OutR2/OutL1 sets induced by f. Then the pre-verified W_{b⊙c} guarantees do not apply, and the fill of that block can fail, even if V_left/V_right holds. Hence additional coupling is required.

Corrected Stage-1 certificate for paths (proposal). Keep T_long and f as in the Out-set formulation. Replace the 2-argument endpoint maps by 3-argument ones that are aligned with the Out-sets of the adjacent long type:
- g_L: T × {0,1}^2 × T_long → Σ_out^2. For g_L(τ_end, s, τ_b)=(β1,β2) require:
  (i) node/window legality at the separator: βi ∈ A_{s[i]} and E(β1,β2);
  (ii) one-sided feasibility toward the endpoint: V_left[τ_end][β1]=true;
  (iii) alignment with interior Out-set: β2 ∈ OutR2(τ_b, s).
- g_R: T_long × {0,1}^2 × T → Σ_out^2. For g_R(τ_c, s, τ_end)=(β1,β2) require:
  (i) node/window legality and E(β1,β2);
  (ii) one-sided feasibility toward the endpoint: V_right[β2][τ_end]=true;
  (iii) alignment with interior Out-set: β1 ∈ OutL1(τ_c, s).

With these constraints, the MIS-based O(log* n) construction proceeds as before:
- Label every interior separator by f; label the endpoint-adjacent separators using g_L/g_R (using the computed adjacent long types τ_b, τ_c on their interior sides). Fill end-blocks using Lemma E1.
- For the blocks between an endpoint-adjacent separator and its nearest interior separator, use the same W_{b⊙c} check as for interior blocks, with α_L := second(g_L(…)) or α_R := first(g_R(…)). By (iii), α_L ∈ OutR2(τ_b,·) and α_R ∈ OutL1(τ_c,·), so the precomputed W_{b⊙c} guarantees existence of a witness in Ext_{τ_b ⊙ τ_c}.

Necessity (⇒) sketch under the corrected certificate. Given an o(n)-round algorithm A:
- Extract f from A as in the cycle case (pumping + concatenation).
- For each (τ_end, s, τ_b), build a path consisting of a long pumped block of type τ_b to the right, the separator with input s, and an endpoint block of type τ_end on the left (plus pumped padding as needed outside the radius of A). Let g_L(τ_end,s,τ_b) be A’s output on the separator. Pumping ensures well-definedness and (iii). The V_left constraint follows because the seam into the endpoint segment is satisfied by A. Symmetrically define g_R.

Verification remains in 2^{poly(β)}: T, T_long, Ext, W_{b⊙c}, V_left, V_right, OutR2/OutL1 are all precomputable. The guessed tables f, g_L, g_R are checked entrywise.

Action items.
- Integrate Lemma E1 and the V_left/V_right definitions into outputs.
- Replace the current endpoint witness proposal by the 3-argument version and update both directions of the Stage-1 path theorem accordingly.
- Keep Stage-2 items in notes until a self-contained partition lemma for oriented paths is written.
Endpoint‑coupled Stage‑1 for oriented paths: resolution and integration

- Gap recap. Our earlier Stage‑1 (o(n) vs Ω(n)) write‑up did not handle the endpoint‑adjacent separators. Labeling endpoints independently (even with V_left/V_right checks) can misalign the “open” seam color toward the interior with the Out‑sets induced by the interior feasible function f, causing the first/last interior block to be unfillable.

- Fix (now integrated into output.md). We strengthen the certificate by adding 3‑argument endpoint maps coupled to Out‑sets:
  • g_L(τ_end, s, τ_b) = (β1,β2) with: (i) node/window legality; (ii) V_left[τ_end][β1]; (iii) β2 ∈ OutR2(τ_b,s).
  • g_R(τ_c, s, τ_end) = (β1,β2) with: (i) node/window legality; (ii) V_right[β2][τ_end]; (iii) β1 ∈ OutL1(τ_c,s).
  With these, the interior block between an endpoint‑adjacent separator and the nearest interior separator is covered by the same W_{b⊙c} universal checks as for interior blocks. We added an explicit Endpoint–interior bridging lemma to make this step transparent.

- Theorem S1‑path (added). For β‑normalized r=1 LCLs on globally oriented paths, an o(n)‑round deterministic algorithm exists iff there are witnesses (f_mid, g_L, g_R) satisfying the above constraints. Proof: (⇒) extract f_mid and g_L/g_R from an o(n) algorithm using pumped canonical contexts and padding outside the runtime halo; (⇐) place separators by MIS on the K‑th power (K = ℓ_pump+4), color interior separators via f_mid and endpoint‑adjacent ones via g_L/g_R, and complete all blocks by table lookups in W and V. Verification is NEXPTIME (single‑exponential) via precomputed tables.

- Complexity tightening (recorded). Using Proposition 19 (O(β^4) append for k_flag ≥ 4), the BFS enumeration in Proposition 9 uses O(β^4) per transition in the long regime.

- Minimal obstruction template (for tests). Fix τ_b with OutR2(τ_b,s) = {α}. If an uncoupled g_L outputs β2 ≠ α while V_left holds, the first interior block can fail because W_{b⊙c}[β2][·] may be all false; coupling (iii) prevents this.

- Bookkeeping. Lemma 11 subsumes Lemma 2 (general vs k_flag≥4 concatenation). There are duplicated labels around Proposition 6/6A/6B; renumbering is recommended in a clean pass.
Addendum: Stage‑2 on oriented paths via a path‑feasible function f0 (plan and checks)

We record here a path‑specialized Stage‑2 certificate that matches the cycle proof technique in the literature and avoids embedding per‑type interior fillers.

Definitions (r=1; pumping length ℓ_pump = |T| from Prop. 9)
- For a word w with 1 ≤ |w| ≤ ℓ_pump and integer z ≥ 0, define the path Gw,z := wr · wz · wr, where wr denotes a fixed context of length r = 1 on each side, and equip it with a complete output labeling f0(w)^{z+2r} (periodic by f0(w)). Mid(Gw,z) denotes the middle wz.
- For w1, w2 with 1 ≤ |wi| ≤ ℓ_pump and any finite substring S (possibly empty), define Gw1,w2,S := w1^{ℓ_pump+2r} · S · w2^{ℓ_pump+2r} with a partial labeling that fixes the first 2r|w1| outputs to f0(w1)^{2r} and the last 2r|w2| outputs to f0(w2)^{2r}. Mid(Gw1,w2,S) := w1^{ℓ_pump+r} · S · w2^{ℓ_pump+r}.

Path‑feasible function (F1)–(F2)
- f0: { w ∈ Σ_in^k : 1 ≤ k ≤ ℓ_pump } → Σ_out^k is path‑feasible if:
  (F1) For every w, the labeling f0(w) is locally legal; moreover, the labeling of Gw,1 is locally consistent on Mid(Gw,1). (Equivalently, for all z ≥ 1, Gw,z is locally consistent on its mid.)
  (F2) For every Gw1,w2,S, there exists a completion that is locally consistent on Mid(Gw1,w2,S).

Intuition and relation to Ext/W tables
- (F1) ensures that when the short word w is periodically repeated with a unit of separation (z ≥ 1), the outputs at the mid block can be anchored by f0(w) without conflict.
- (F2) ensures that any finite irregular gap S flanked by long pumped contexts with periodic mid‑anchors f0(w1), f0(w2) can be completed using constant‑radius rules, exactly mirroring how W_{b⊙c} checks mediate between Out‑sets in Stage‑1.

Verification (NEXPTIME)
- With T and Ext enumerated (Prop. 9) and the standard pumping lemmas (Lemmas 13–14), it suffices to check finitely many Gw,1 and a finite representative set of Gw1,w2,S where S ranges over types τ_S with |S| ≤ ℓ_pump (plus S = ∅). Each check reduces to Ext‑table membership and adjacency constraints; total time 2^{poly(β)}.

Construction sketch (if f0 exists; to be moved to output.md once the partition lemma is proven)
- Use an oriented‑path version of the (ℓ_width, ℓ_count, ℓ_pattern) partition (as in the cycle proof), with parameters ℓ_width = ℓ_pattern = ℓ_pump and ℓ_count = 2ℓ_pump + 2. On long periodic regions with primitive period w (|w| ≤ ℓ_pattern and repeat count ≥ ℓ_count), label the central 2r‑window of every period by f0(w), creating evenly spaced mid‑anchors. The remaining subpaths between anchors (and near endpoints) have O(ℓ_width + ℓ_pattern) length and are filled using (F2) by constant‑radius table lookups indexed by (w1, S, w2). Orientation is given, so no orientation step is required.

Sanity examples
- Equality LCL (E = {(c,c)}, A_0 = A_1 = {c}): f0(w) ≡ c^{|w|} satisfies (F1)–(F2); classified O(1).
- Proper 2‑coloring: no f0 exists (F1 fails on Gw,1 due to parity); Stage‑1 with endpoints succeeds; classified Θ(log* n).

Endpoint incremental identities and filters (implementation notes)
- Incremental projection under append (k_flag ≥ 4): RightColors(τ·a) = { y ∈ A_a : ∃ x1,x2,x3 Left3_τ[x1,x2,x3] ∧ E(x3,y) }, LeftColors(τ·a) = LeftColors(τ). Direct from Lemma 1 via projections.
- Allow sets: L_allow(τ) = N_E(RightColors(τ)), R_allow(τ) = N_E^{-1}(LeftColors(τ)). This restates V_left/V_right.
- Early feasibility filters for Stage‑1: If some OutR2(τ_b,s) or OutL1(τ_c,s) is empty, no feasible f_mid exists. If L_allow(τ_end)=∅ or OutR2(τ_b,s)=∅, then g_L(τ_end,s,τ_b) is impossible; similarly for g_R. These are constant‑time table emptiness checks.

Open items to promote S2 to output.md
- Provide a self‑contained oriented‑path partition lemma (constant rounds) with the explicit ℓ parameters above, or adapt an established reference to our notation.
- Integrate the S2‑path theorem with full proofs and NEXPTIME verification, pointing to our Ext/W machinery for the finite checks.


Current output.md (if any):
Setup and definitions (r=1, globally oriented paths)
- Let Σ_out be a finite output alphabet of size β. Let A_0,A_1 ⊆ Σ_out be the allowed outputs at nodes with input bit 0 or 1, respectively. Let E ⊆ Σ_out × Σ_out be the allowed directed edge relation (u→v allowed iff (u,v)∈E). For an input word t ∈ {0,1}^k with k≥1, a labeling o ∈ Σ_out^k is legal if o[i]∈A_{t[i]} for all i, and (o[i],o[i+1])∈E for all 1≤i<k.
- For k≥4, define Ext_t ⊆ Σ_out^4 as the set of boundary quadruples (L1,L2,R2,R1) that extend to a legal labeling o with L1=o[1], L2=o[2], R2=o[k−1], R1=o[k]. For k≤3, Ext_t is defined with the same 4‑tuple container but with the obvious coordinate equalities imposed by overlaps (tracked by k_flag ∈ {1,2,3,≥4}). The Type of t is Type(t) := (Ext_t, k_flag(t)).
- Indexing reminder: Throughout, boundary quadruples are ordered as (L1, L2, R2, R1).

Lemma 1 (Append‑one‑bit recurrence; k_flag ≥ 4).
Let t be an input word with k_flag(t)≥4, and let t′ := t·a be t with one bit a ∈ {0,1} appended on the right. Then for all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x4 ∈ A_a and E(x3,x4) and ∃z∈Σ_out: (x1,x2,z,x3) ∈ Ext_t ].
Proof. Standard restriction/extension argument on legal labelings. □

Proposition 6 (Base‑case update; k=1→2).
Let t=(b) be a length‑1 input and t′:=t·a the length‑2 input obtained by appending a∈{0,1}. For all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x1 = x3, x2 = x4, x1 ∈ A_b, x2 ∈ A_a, and E(x1,x2) ].
Proof. Immediate from the definition. □

Proposition 6B (Base‑case update; k=2→3).
Let t=(b1,b2) be a length‑2 input and t′:=t·a the length‑3 input obtained by appending a∈{0,1}. For all (x1,x2,x3,x4) ∈ Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x3 = x2, x1 ∈ A_{b1}, x2 ∈ A_{b2}, x4 ∈ A_a, E(x1,x2), and E(x2,x4) ].
Proof. Any legal labeling on three nodes has boundary (o1,o2,o2,o3), with o1∈A_{b1}, o2∈A_{b2}, o3∈A_a and E(o1,o2), E(o2,o3). Conversely, any tuple satisfying these constraints is realized by such a labeling. □

Proposition 7 (Base‑case update; k=3→4).
Let t=(b1,b2,b3) be a length‑3 input and t′:=t·a the length‑4 input obtained by appending a∈{0,1}. For all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{t′} ⇔ [ x1∈A_{b1}, x2∈A_{b2}, x3∈A_{b3}, x4∈A_a, and E(x1,x2), E(x2,x3), E(x3,x4) ].
Proof. Unfold the definition on the 4‑node path. □

Lemma 2 (Ext‑level concatenation; k_flag ≥ 4).
Let P and Q be input words with k_flag(P), k_flag(Q) ≥4, and let B := P·Q. Then for all (o1,o2,o3′,o4′)∈Σ_out^4,
  (o1,o2,o3′,o4′) ∈ Ext_B ⇔ ∃ x3,x4,x1′,x2′ ∈ Σ_out such that
    (o1,o2,x3,x4) ∈ Ext_P, (x1′,x2′,o3′,o4′) ∈ Ext_Q, and E(x4,x1′).
Proof. Combine witnesses across the seam, or restrict a legal labeling of B. □

Proposition 3 (Type congruence under appending one bit).
If Type(P)=Type(Q), then for all a∈{0,1}, Type(P·a)=Type(Q·a). In particular, Ext_{P·a}=Ext_{Q·a} and k_flag updates identically.
Proof. For k_flag≥4, Lemma 1 shows Ext_{(·)·a} depends only on Ext_{(·)} and a. Short cases follow by the explicit base‑case rules. □

Proposition 4 (Unsoundness of existential R‑composition).
There exists an instance (Σ_out,A_0,A_1,E) and types t_b,t_c such that there is m∈Σ_out with (x,m) ∈ R_{t_b} and (m,y) ∈ R_{t_c} for some x,y, yet (x,y) ∉ R_{t_b·t_c}. Hence the rule “(∃m) R_{P·Q}(x,y) ⇐ R_P(x,m) ∧ R_Q(m,y)” is not valid in general.
Proof. Use Σ_out={a,b,c}, A_0=A_1=Σ_out, E={(a,b),(b,c)}; choose t_b with rightmost a and t_c with leftmost c; pick m=b. The seam would require E(a,c), which fails. □

Proposition 5 (Optimized computation of Ext for concatenation in O(β^6)).
For any types τ,σ with k_flag(τ),k_flag(σ)≥4, define the 3D slices
  Left_τ[o1,o2,x4] := ∃x3 (o1,o2,x3,x4)∈Ext_τ, and
  Right_σ[x1′,o3′,o4′] := ∃x2′ (x1′,x2′,o3′,o4′)∈Ext_σ.
Then for all (o1,o2,o3′,o4′),
  (o1,o2,o3′,o4′) ∈ Ext_{τ⊙σ} ⇔ ∃x4,x1′: Left_τ[o1,o2,x4] ∧ E(x4,x1′) ∧ Right_σ[x1′,o3′,o4′].
Moreover, after precomputing Left_τ and Right_σ for all τ,σ in O(β^4) time per type, Ext_{τ⊙σ} can be computed in O(β^6) time.
Proof. Eliminate x3,x2′ by definitions; count entries. □

Proposition 6A (k_flag=1 append update without recovering the bit).
Let τ be a type with k_flag(τ)=1 and define S_τ := { x ∈ Σ_out : (x,x,x,x) ∈ Ext_τ }. For a∈{0,1}, let τ′ := δ(τ,a). Then for all (x1,x2,x3,x4)∈Σ_out^4,
  (x1,x2,x3,x4) ∈ Ext_{τ′} ⇔ [ x1=x3, x2=x4, x1∈S_τ, x2∈A_a, and E(x1,x2) ].
Proof. Any legal 2‑node labeling has boundary (o1,o2,o1,o2) with o1∈S_τ, o2∈A_a and E(o1,o2). Conversely, any tuple satisfying the listed constraints is realized by a legal labeling on the 2‑node input. □

Lemma 8 (Type‑count bound).
With Type(t):=(Ext_t, k_flag(t)) and Ext_t⊆Σ_out^4, the number of distinct types obeys |T| ≤ 4 · 2^{β^4}.
Proof. For each k_flag value, Ext can be any subset of Σ_out^4; sum over k_flag. □

Proposition 9 (δ well‑defined; deterministic BFS enumeration in 2^{poly(β)} time/space).
Let δ map a type τ and an appended bit a∈{0,1} to the type of the one‑bit extension. Define δ by:
- If k_flag(τ)=1, compute Ext of the 2‑node type by Proposition 6A using S_τ.
- If k_flag(τ)=2, use the explicit k=2→3 update (Proposition 6B).
- If k_flag(τ)=3, use Proposition 7.
- If k_flag(τ)≥4, use Lemma 1 (implementable in O(β^4) time via Proposition 19).
Then δ(τ,a) depends only on τ and a (by Proposition 3). A deterministic BFS that starts from the length‑1 seeds (t=(0) and t=(1)), repeatedly applies δ(·,0) and δ(·,1), and interns types by equality of (Ext, k_flag), halts after at most |T| insertions and enumerates all reachable types. Each transition costs O(β^4) in the k_flag≥4 regime (base‑cases are ≤O(β^4)). Since |T| ≤ 4·2^{β^4}, the total time and space are 2^{poly(β)}. □

Lemma 10 (Reversal operator; basic properties).
Define, for any type τ=(Ext_τ,k_flag(τ)), the reversed type Rev(τ):=(Ext_τ^R, k_flag(τ)), where Ext_τ^R := { (y1,y2,y3,y4) : (y4,y3,y2,y1) ∈ Ext_τ }. Then Rev(Rev(τ))=τ and, for k_flag≥4, Ext_{Rev(τ) ⊙ Rev(σ)} = (Ext_{σ ⊙ τ})^R.
Proof. Direct from definitions and Lemma 2. □

Definition (Long types and pumping bound).
- T_long := { τ ∈ T : k_flag(τ) ≥ 4 }.
- Define ℓ_pump := |T|, where T is the set of reachable Types enumerated by Proposition 9.

Lemma 11 (Ext‑level concatenation; all k_flag).
For any input words P,Q (no restriction on length) and B := P·Q, for all (o1,o2,o3′,o4′) ∈ Σ_out^4,
  (o1,o2,o3′,o4′) ∈ Ext_B ⇔ ∃ x3,x4,x1′,x2′ ∈ Σ_out:
    (o1,o2,x3,x4) ∈ Ext_P, (x1′,x2′,o3′,o4′) ∈ Ext_Q, and E(x4,x1′).
Proof. As in Lemma 2; k_flag imposes only coordinate equalities. □

Proposition 12 (Associativity of Ext‑concatenation).
For any input words P,Q,R, Ext_{(P·Q)·R} = Ext_{P·(Q·R)} as subsets of Σ_out^4.
Proof. Either semantically (concatenation of words) or by rebracketing witnesses from Lemma 11. □

Lemma 13 (Prefix pumping).
Let ℓ_pump := |T|. For any input string w with |w| ≥ ℓ_pump there exist a decomposition w = x y z with 1 ≤ |y| ≤ ℓ_pump and |x y| ≤ ℓ_pump such that Type(x y^i z) is independent of i ≥ 0.
Proof. Pigeonhole on the first ℓ_pump+1 states of the δ‑run. □

Lemma 14 (Periodic pumping).
For any nonempty string u there exist integers a,b with a+b ≤ ℓ_pump such that Type(u^{a+bi}) is invariant for all i ≥ 0.
Proof. Pigeonhole on the sequence Type(u^j), j≥0, and determinism of δ. □

Definition (Feasible function; Out‑set form).
A function f: T_long × {0,1}^2 × T_long → Σ_out^2 is feasible if for every (τ_L, s, τ_R) it outputs (α1,α2) with αi ∈ A_{s[i]} and E(α1,α2), and moreover the following universal extendibility holds: for all τ_b,τ_c∈T_long and s1,s2 ∈ {0,1}^2, and for all α_L ∈ OutR2(τ_b,s1), α_R ∈ OutL1(τ_c,s2), there exists (o1,o2,o3,o4) ∈ Ext_{τ_b ⊙ τ_c} with E(α_L,o1) and E(o4,α_R), where
  OutR2(τ_b,s) := { second(f(τ_a,s,τ_b)) : τ_a ∈ T_long },
  OutL1(τ_c,s) := { first(f(τ_c,s,τ_d)) : τ_d ∈ T_long }.

Lemma 20 (Quantifier minimization equivalence).
Let f be any function T_long×{0,1}^2×T_long→Σ_out^2 obeying node/window constraints. The universal extendibility clause stated here is equivalent to the clause “for all τ_a,τ_b,τ_c,τ_d and s1,s2, letting α_L := second(f(τ_a,s1,τ_b)) and α_R := first(f(τ_c,s2,τ_d)), there exists (o1,o2,o3,o4)∈Ext_{τ_b⊙τ_c} with E(α_L,o1), E(o4,α_R)).”
Proof. “Only if”: the α_L,α_R in the original clause range over OutR2,OutL1. “If”: for given τ_b,τ_c,s1,s2 and α_L∈OutR2, α_R∈OutL1, pick τ_a,τ_d witnessing membership and apply the original clause. □

Proposition 19 (Optimized append in O(β^4) time for k_flag ≥ 4).
For t with k_flag≥4 and a∈{0,1}, define Left3_t[x1,x2,x3] := ∃z (x1,x2,z,x3)∈Ext_t. One can compute Left3_t in O(β^4) time. Then fill Ext_{t·a} by scanning all (x1,x2,x3) with Left3_t[x1,x2,x3]=true and, for each, iterating over x4 with E(x3,x4) and x4∈A_a, setting Ext_{t·a}[x1,x2,x3,x4]←true. The total time is O(β^4) in the dense worst‑case.
Proof. Correctness follows from Lemma 1. Complexity: Left3_t has β^3 entries, each tested in O(β); the fill step is O(β^3Δ) with Δ≤β. □

Proposition 21 (Seam‑feasibility matrices for τ_b ⊙ τ_c).
For τ_b,τ_c, define W_{b⊙c}[α_L][α_R] (a β×β boolean matrix) to be true iff ∃(o1,o2,o3,o4)∈Ext_{τ_b⊙τ_c} with E(α_L,o1) and E(o4,α_R). Using precomputed 3D slices or Ext_{τ_b⊙τ_c}, W_{b⊙c} can be computed in O(β^4Δ^2) time (or better with sparse E), and then universal extendibility checks reduce to testing W_{b⊙c}[α_L][α_R].
Proof. Expand the definition via Lemma 11, eliminate internal witnesses by slices, and count operations. □

Proposition 17 (Nonemptiness monotonicity under concatenation).
If Ext_P ≠ ∅ and Ext_Q ≠ ∅ and there exist x4,x1′ with E(x4,x1′), then Ext_{P·Q} ≠ ∅.
Proof. Choose any (o1,o2,x3,x4) ∈ Ext_P and (x1′,x2′,o3′,o4′) ∈ Ext_Q; Lemma 11 and E(x4,x1′) imply (o1,o2,o3′,o4′) ∈ Ext_{P·Q}. □

Definitions (endpoint projections and seam matrices).
For any type τ, define the projections of Ext_τ to the endpoint coordinates:
- RightColors(τ) := { y ∈ Σ_out : ∃ x1,x2,x3 with (x1,x2,x3,y) ∈ Ext_τ }.
- LeftColors(τ)  := { x ∈ Σ_out : ∃ x2,x3,y with (x,x2,x3,y) ∈ Ext_τ }.
Define the endpoint seam‑compatibility matrices by
- V_left[τ][α]  := true ⇔ ∃ y ∈ RightColors(τ) with E(y, α), and
- V_right[α][τ] := true ⇔ ∃ x ∈ LeftColors(τ) with E(α, x).

Lemma E1 (Endpoint feasibility via Ext).
Let τ be any type and α ∈ Σ_out.
(i) There exists a legal labeling of a left end‑block of type τ together with an adjacent separator whose first output is α if and only if V_left[τ][α] is true.
(ii) There exists a legal labeling of a right end‑block of type τ together with an adjacent separator whose second output is α if and only if V_right[α][τ] is true.
Proof. (i) If V_left[τ][α] holds, pick y ∈ RightColors(τ) with E(y,α) and any (x1,x2,x3,y)∈Ext_τ; Ext‑membership provides the interior, and E(y,α) the seam. Conversely, any legal instance gives y as the last output on the end block, whence (x1,x2,x3,y)∈Ext_τ and E(y,α). (ii) is symmetric. □

Lemma E2 (Endpoint–interior bridging via W_{b⊙c}).
Fix τ_b, τ_c ∈ T_long, inputs s1,s2 ∈ {0,1}^2, and seam colors α_L, α_R ∈ Σ_out. There exists a legal completion of the intervening block of type τ_b ⊙ τ_c consistent with the left seam color α_L (toward τ_b) and the right seam color α_R (toward τ_c) if and only if W_{b⊙c}[α_L][α_R] is true.
Proof. Directly by definition of W_{b⊙c}: “if” is witnessed by (o1,o2,o3,o4); “only if” follows by restricting any legal completion of the intervening block to its boundary and the seam edges. □

Lemma E3 (Feasible‑f condition as set inclusion).
Let f be as in Definition “Feasible function; Out‑set form.” For all τ_b,τ_c∈T_long and s1,s2,
  OutR2(τ_b,s1) × OutL1(τ_c,s2) ⊆ { (α_L,α_R) : W_{b⊙c}[α_L][α_R] = true }.
Conversely, if these inclusions hold for all τ_b,τ_c,s1,s2, then f satisfies the universal extendibility clause.
Proof. Immediate from Lemma E2 and the definition of W_{b⊙c}. □

Definition (Endpoint maps with Out‑set alignment).
- g_L: T × {0,1}^2 × T_long → Σ_out^2. For g_L(τ_end, s, τ_b) = (β1,β2) require:
  (i) βi ∈ A_{s[i]} (i = 1,2) and E(β1,β2);
  (ii) V_left[τ_end][β1] = true;
  (iii) β2 ∈ OutR2(τ_b, s).
- g_R: T_long × {0,1}^2 × T → Σ_out^2. For g_R(τ_c, s, τ_end) = (β1,β2) require:
  (i) βi ∈ A_{s[i]} and E(β1,β2);
  (ii) V_right[β2][τ_end] = true;
  (iii) β1 ∈ OutL1(τ_c, s).

Lemma M1 (MIS on the K‑th power of a path in O(log* n); spacing [K,2K]).
For every constant K ≥ 1, there is a deterministic LOCAL algorithm that in O(log* n) rounds computes a maximal independent set on the K‑th power of the underlying undirected path. In the resulting set, consecutive selected positions are at distances in [K, 2K].
Proof sketch. First compute a proper O(1)‑coloring of the path in O(log* n) rounds (e.g., Cole–Vishkin color reduction). Then greedily construct an MIS on the K‑th power in O(1) rounds by iterating over color classes and adding a node if none of its K‑neighbors is already selected. Maximality and the spacing bounds follow from construction. □

Theorem S1‑path (Endpoint‑coupled equivalence on oriented paths).
Let an r=1 LCL be given on globally oriented paths with output alphabet Σ_out of size β. Then the following are equivalent:
(A) There exists a deterministic LOCAL algorithm with runtime o(n).
(B) There exist witnesses (f_mid, g_L, g_R) where f_mid: T_long×{0,1}^2×T_long→Σ_out^2 is feasible in the Out‑set sense (Definition “Feasible function; Out‑set form”), and g_L, g_R satisfy the endpoint map constraints above.
Moreover, existence of such witnesses is verifiable in nondeterministic time 2^{poly(β)}.

Proof.
(⇒) Assume a deterministic o(n)‑round algorithm A. Fix a large n and let R := R(n) be its runtime on paths of length n. By Lemmas 13–14 (pumping), for each τ ∈ T_long choose a canonical input string w_τ of type τ with |w_τ| ≫ R and with a short prefix y_τ of length ≤ ℓ_pump such that w_τ = x_τ y_τ^M z_τ for some M, and the δ‑state is stable across repetitions.

Define f_mid(τ_L, s, τ_R) as follows: consider W := w_{τ_L} · S(s) · w_{τ_R}, where S(s) is the 2‑node separator with input s. Assign unique identifiers so that the ID pattern is periodic and identical within the R‑neighborhoods around S(s), and pad beyond distance R into w_{τ_L}, w_{τ_R}. Run A on W and record the 2‑node output on S(s) as f_mid(τ_L, s, τ_R). Because the neighborhoods of S(s) are isomorphic across all such choices (by periodic pumping and our canonical construction), f_mid is well defined and satisfies node/window constraints. The Out‑set feasibility of f_mid holds: for any τ_b, τ_c and α_L ∈ OutR2(τ_b, s1), α_R ∈ OutL1(τ_c, s2), choose τ_a, τ_d witnessing α_L, α_R via f_mid and form the path w_{τ_b} · S(s1) · middle · S(s2) · w_{τ_c}, where “middle” is any long block of type τ_b ⊙ τ_c built from our canonical pieces and padded so that the R‑neighborhoods of the two separators are disjoint. By locality, A’s outputs on the two separators are α_L and α_R, and since A is correct, a legal completion of the middle block exists. Projecting to Ext gives W_{b⊙c}[α_L][α_R] = true, as required by the Out‑set feasibility clause.

Define g_L(τ_end, s, τ_b) as follows: pick any finite path P_end with Type(P_end)=τ_end; pick w_{τ_b} (as above) long enough so that the radius‑R neighborhood of S(s) lies entirely inside w_{τ_b} on the right. Run A on the finite path P := P_end · S(s) · w_{τ_b} (with padding only on the right beyond distance R if needed). Let g_L(τ_end,s,τ_b) be the output on S(s). Local correctness of A implies (i); the existence of a legal seam into the endpoint block yields V_left[τ_end][β1] = true (ii); and since the right context is w_{τ_b}, the second output β2 lies in OutR2(τ_b, s), giving (iii). Define g_R symmetrically by choosing any P_end of type τ_end on the right and padding on the left within w_{τ_c}.

(⇐) Assume witnesses (f_mid, g_L, g_R) as above. Let K := ℓ_pump + 4. By Lemma M1, compute in O(log* n) rounds a maximal independent set on the K‑th power of the path; consecutive MIS nodes (separators) are at distances in [K, 2K].
- Interior separators: For each separator between long blocks of types τ_b and τ_c with local inputs s1 and s2 on its two adjacent 2‑node windows, set its 2‑node output to f_mid(·). By Out‑set feasibility and Lemma E2, the block between any two consecutive interior separators is fillable via Ext_{τ_b ⊙ τ_c} using table W_{b⊙c}.
- Endpoint‑adjacent separators: Let S_L be the unique separator adjacent to the left end; compute τ_end (the type of the end block to its left) and τ_b (the long type on its right). Set S_L’s output to g_L(τ_end, s, τ_b). By Lemma E1 and condition (ii), the endpoint block can be filled. For the block between S_L and the nearest interior separator S_2 (with right‑side long type τ_c), condition (iii) gives α_L := second(g_L) ∈ OutR2(τ_b, s), while the left seam color α_R at S_2 is in OutL1(τ_c, s2) by construction. Hence W_{b⊙c}[α_L][α_R] = true, and Lemma E2 fills the intervening block. Do the right endpoint symmetrically with g_R.
- Small‑n edge cases (0 or 1 separator) are handled by brute‑force completion using Ext tables in constant radius; this does not affect asymptotic runtime.
All fillings are computed from constant‑size tables; the MIS step dominates with O(log* n) rounds. Thus we obtain an O(log* n) algorithm.

Verification complexity. Deterministically enumerate T and T_long via Proposition 9 with O(β^4) per long append (Prop. 19), precompute Ext_τ and Ext_{τ_b ⊙ τ_c}, W_{b⊙c}, V_left, V_right. For a guessed f_mid, compute OutR2 and OutL1 sets. Then check the constraints entrywise; the total time is 2^{poly(β)}.

Remark. Lemma 11 strictly subsumes Lemma 2; we retain Lemma 2 for emphasis in the k_flag ≥ 4 regime.

