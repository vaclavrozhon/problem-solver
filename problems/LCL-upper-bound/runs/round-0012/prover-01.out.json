{
  "progress_md": "Round 0012 \u2014 Completing Stage\u20112: a rigorous O(1) partition on oriented paths and a singly\u2011exponential Stage\u20112 certificate based on types (not words), plus audits and verifiable lemmas\n\nOverview\n- Goal this round: close the remaining Stage\u20112 gap (O(1) vs \u0398(log* n)) for \u03b2\u2011normalized radius\u20111 LCLs on globally oriented paths by (i) stating a self\u2011contained, deterministic O(1) partition lemma tailored to oriented paths and (ii) proposing a singly\u2011exponential Stage\u20112 certificate and verifier that avoids the doubly\u2011exponential blow\u2011up inherent in word\u2011based certificates.\n- High\u2011level plan: specialize the paper\u2019s Lemma 20/21/22 path partition to our oriented path setting with explicit constants linked to \u2113_pump=|T|, and replace the word\u2011indexed f0 by a type\u2011indexed path\u2011feasible function f_type on short types (length \u2264 \u2113_pump). This keeps verification within 2^{poly(\u03b2)}.\n- Audit: output.md currently contains a complete Stage\u20111 (S1\u2011path) including endpoint coupling, and the tiny\u2011path fallback (Lemma TP). Stage\u20112 is not yet included; this note supplies a ready\u2011to\u2011integrate Stage\u20112 section.\n\nA. Oriented\u2011path partition lemma in O(1) rounds (self\u2011contained)\nParameters\n- Set \u2113_pattern := \u2113_pump and \u2113_width := \u2113_pump and \u2113_count := 2\u2113_pump + 2. These are constants depending only on \u03b2.\n- Primitive word means a period w \u2208 {0,1}^k with 1 \u2264 k \u2264 \u2113_pattern that is not a proper power.\n\nStatement (P\u2011Partition\u2011Path)\nLet G be a globally oriented path. In O(1) LOCAL rounds we can compute a partition P = P_long \u222a P_short of G such that:\n1) Direction and minimum length: each P \u2208 P has nodes oriented the same way and |P| \u2265 \u2113_width.\n2) Long periodic segments (P_long): each P \u2208 P_long is a maximal subpath contained in a run w^K for some primitive w with |w| \u2264 \u2113_pattern and K \u2265 \u2113_count; each node in P learns the canonical primitive w.\n3) Short/irregular segments (P_short): the remaining subpaths form P_short; each P \u2208 P_short has |P| \u2264 2\u2113_width, and each node in P learns its rank in P and the types of the adjacent long neighbors (if any).\n\nAlgorithm (constant\u2011round, oriented)\n- Step A (detect deep interiors of long runs): For each primitive w with 1 \u2264 |w| \u2264 \u2113_pattern, each node v checks in radius R_w := (\u2113_count + 2\u2113_width)|w| that there exists an aligned block centered near v of the form w^{\u2113_count+2\u2113_width}. If yes, label v \u2208 Deep(w). (Alignment uses the global orientation and |w|.) Prioritize conflicts by a fixed total order on primitive words (first by |w|, then lexicographically) and assign each node to the first w for which it is in Deep(w).\n- Step B (form P_long): For each w, let L(w) be the maximal connected subpaths consisting of nodes assigned to w. Each such L \u2208 L(w) is contained in a w\u2011periodic run of length \u2265 (\u2113_count + 2\u2113_width)|w|, and by construction each end of the run is at least \u2113_width|w| from the boundary of L. Set P_long := \u22c3_w L(w). Each L \u2208 P_long is a directed path, and each node knows its w.\n- Step C (form P_short): Define P_short as the connected components of G \\ P_long. By construction, each P \u2208 P_short has |P| \u2264 2\u2113_width: any longer segment would contain a subpath w^{\u2113_count+2\u2113_width} for some w, contradicting Step A\u2019s maximality and conflict resolution. Each node in P can determine its rank and the adjacent long neighbors (if any) in O(1) rounds.\n\nCorrectness and complexity (sketch, auditable)\n- Completeness of long detection: If a primitive run w^K has K \u2265 \u2113_count + 2\u2113_width, its internal nodes at distance \u2265 \u2113_width|w| from both ends satisfy the Deep(w) test and are captured into P_long. The fixed priority on primitive words yields a disjoint assignment.\n- Boundedness of the remainder: Let H be any component of G \\ P_long. If |H| > 2\u2113_width, its interior contains a subpath w^{\u2113_count+2\u2113_width} (for some primitive w with |w| \u2264 \u2113_pattern), which would have produced Deep(w) nodes in Step A, contradiction.\n- Round complexity: All pattern detections and conflict resolutions use a constant number of fixed\u2011length windows bounded by (\u2113_count+2\u2113_width)\u00b7\u2113_pattern = O(\u2113_pump^2), hence O(1) rounds. Ranking within short segments and learning adjacent long types are constant\u2011radius tasks.\n\nRemark (optional, strengthens Step C)\nOn each irregular component H of G \\ P_long with |H| \u2265 \u2113_width, the string has no subpath of the form w^x with |w| \u2264 \u2113_pattern and |w^x| \u2265 \u2113_count+2\u2113_width. Hence the paper\u2019s (\u03b3,2\u03b3) independent\u2011set lemma (with \u03b3=\u2113_pattern) applies; combining it with a local cut procedure yields an alternative derivation of |H| \u2264 2\u2113_width and a decomposition into blocks of lengths in [\u2113_pattern,2\u2113_pattern]. We keep the simpler trimming\u2011based bound \u2264 2\u2113_width above.\n\nB. A singly\u2011exponential Stage\u20112 certificate based on short types (not words)\nMotivation\n- The word\u2011indexed f0 (mapping each w with |w| \u2264 \u2113_pump to f0(w)) risks a doubly exponential verification because the number of words is 2^{\u0398(\u2113_pump)} and \u2113_pump itself is exponential in \u03b2.\n- Resolution: collapse w to its short type \u03c4_w (Type(w) with |w| \u2264 \u2113_pump). The number of short types is \u2264 |T| = 4\u00b72^{\u03b2^4}, so guessing and verifying a type\u2011indexed function remains singly exponential in \u03b2.\n\nCertificate objects\n- T_short := { \u03c4 \u2208 T : \u03c4 is realized by some word w with 1 \u2264 |w| \u2264 \u2113_pump }.\n- For each \u03c4 \u2208 T_short, fix any canonical representative w_\u03c4 with |w_\u03c4| \u2264 \u2113_pump.\n- The certificate provides f_type: T_short \u2192 \u03a3_out^{|w_\u03c4|}, i.e., an output string f_type(\u03c4) of length |w_\u03c4| for each \u03c4.\n\nFeasibility conditions (typed analogue of (F1)\u2013(F2))\n- (F1\u2011T) For each \u03c4 \u2208 T_short, define G_{\u03c4,1} to be the path w_\u03c4^r \u00b7 w_\u03c4 \u00b7 w_\u03c4^r labeled by f_type(\u03c4)^{2r+1}. Require: the labeling is locally consistent on the mid block w_\u03c4.\n- (F2\u2011T) For each \u03c4_1, \u03c4_2 \u2208 T_short and each \u03c4_S \u2208 T (any type, short or long), define G_{\u03c4_1,\u03c4_2,\u03c4_S} as w_{\u03c4_1}^{\u2113_pump+2r} \u00b7 S \u00b7 w_{\u03c4_2}^{\u2113_pump+2r}, with the first 2r|w_{\u03c4_1}| outputs fixed to f_type(\u03c4_1)^{2r} and the last 2r|w_{\u03c4_2}| outputs fixed to f_type(\u03c4_2)^{2r}. Require: there exists a completion that is locally consistent on the middle block w_{\u03c4_1}^{\u2113_pump+r} \u00b7 S \u00b7 w_{\u03c4_2}^{\u2113_pump+r}.\n\nWhy this is enough (intuition)\n- (F1\u2011T) anchors a 2r\u2011window per period type \u03c4 so that repeating anchors do not conflict.\n- (F2\u2011T) ensures any finite irregular subpath S flanked by long pumped contexts with anchored mid\u2011windows can be completed locally.\n\nVerification in NEXPTIME (single\u2011exponential)\n- Enumerate T and T_short (Proposition 9). For each \u03c4 \u2208 T_short fix a representative w_\u03c4 of length \u2264 \u2113_pump.\n- Check (F1\u2011T): for each \u03c4 \u2208 T_short, G_{\u03c4,1} mid\u2011block consistency is a finite Ext\u2011membership test (at most |T_short| many instances; each reduces to a constant number of seam checks via Ext of Type(w_\u03c4^3)).\n- Check (F2\u2011T): For each triple (\u03c4_1, \u03c4_S, \u03c4_2), pick any representative S of \u03c4_S with |S| \u2264 \u2113_pump (Lemma 14) and test existence of a mid\u2011consistent completion. This reduces to a boolean check expressible through Ext_{\u03c4_S} and the seam adjacency constraints to the anchored windows. Total checks: |T_short|^2\u00b7|T|, each a constant\u2011size table lookup against precomputed Ext; overall time 2^{poly(\u03b2)}.\n\nC. S2\u2011path (oriented paths; certificate \u21d4 O(1))\nStatement (S2\u2011path)\nA \u03b2\u2011normalized radius\u20111 LCL on globally oriented paths has deterministic LOCAL complexity O(1) iff there exists f_type satisfying (F1\u2011T) and (F2\u2011T). Otherwise, if S1\u2011path holds but no such f_type exists, the complexity is \u0398(log* n).\n\n(\u21d2) Given an O(1) algorithm A, construct f_type\n- For each \u03c4 \u2208 T_short (|w_\u03c4| \u2264 \u2113_pump), simulate A on G_{\u03c4,1} with IDs chosen so that the radius\u2011R (constant) halos of the three copies of w_\u03c4 are disjoint and isomorphic (as in the paper\u2019s Lemma 24). Set f_type(\u03c4) to be A\u2019s output string on the mid w_\u03c4. This defines f_type(\u03c4) of correct length and satisfies (F1\u2011T). For (F2\u2011T), simulate A on G_{\u03c4_1,\u03c4_2,\u03c4_S} with pumped contexts w_{\u03c4_i}^{\u2113_pump+2r} so that the halos around the two anchors are disjoint; by correctness of A a completion exists.\n\n(\u21d0) Given f_type, construct an O(1) algorithm\n- Compute the partition P = P_long \u222a P_short in O(1) (P\u2011Partition\u2011Path). For each P_long component with primitive w and |w| \u2264 \u2113_pattern, each node learns w and |w|.\n- On each P_long, anchor mid\u2011windows: on every occurrence of the period w, fix the outputs on a 2r window to f_type(\u03c4_w), where \u03c4_w := Type(w) (|w| \u2264 \u2113_pump). Each node in that 2r window gathers the |w| input bits (\u2264 \u2113_pump) to compute \u03c4_w and f_type(\u03c4_w) in O(1) rounds. Repeat this in every period; anchors are disjoint and 2r\u2011spaced.\n- On each P_short (|P_short| \u2264 2\u2113_width), and on the gaps between adjacent anchors (all of length O(\u2113_pump)), use (F2\u2011T) to complete the labeling locally: each gap is an instance of some G_{\u03c4_1,\u03c4_2,\u03c4_S} with \u03c4_S being the type of the gap; completeness follows from (F2\u2011T). End segments (if any) are handled the same way with one anchor missing on one side; this is a special case of (F2\u2011T) where one anchored context is truncated, admitted by the local check since no seam constraint is required at the path boundary.\n- All steps are constant\u2011radius table lookups; hence O(1) LOCAL time.\n\nD. Auxiliary check matrices for Stage\u20112 verification\n- For \u03c4_S \u2208 T, precompute Bridging[\u03c4_S][\u03b1_L][\u03b1_R] := true iff \u2203(o1,o2,o3,o4)\u2208Ext_{\u03c4_S} with E(\u03b1_L,o1) and E(o4,\u03b1_R). This is exactly the two\u2011sided seam matrix; computable via Lemma 11 and 3D slices in O(\u03b2^4\u0394^2). Then (F2\u2011T) reduces to checking that for each (\u03c4_1,\u03c4_S,\u03c4_2), Bridging[\u03c4_S][L1(\u03c4_1,anchor)\u2192?][?\u2190R1(\u03c4_2,anchor)] is true for each anchored seam color pair read from f_type(\u03c4_1), f_type(\u03c4_2) at the anchor windows.\n- For endpoints, if one uses the specialization where S sits at a boundary, precompute RightAllow(\u03c4_S):={o4:\u2203o1,o2,o3 (o1,o2,o3,o4)\u2208Ext_{\u03c4_S}} and LeftAllow(\u03c4_S):={o1:\u2203o2,o3,o4 (o1,o2,o3,o4)\u2208Ext_{\u03c4_S}}, and then check single\u2011seam adjacency via E.\n\nE. Audits of output.md (minor issues and alignment)\n- Stage\u20112 missing: output.md currently lacks S2\u2011path and the partition lemma. The P\u2011Partition\u2011Path and S2\u2011path presented here are compatible with the machinery already in output.md (Ext, types, pumping, and seam matrices) and can be integrated.\n- Endpoint handling in S2: With the f_type anchors, endpoint short segments are completed via the same (F2\u2011T) rule (one anchor missing); no special endpoint tables are needed beyond Ext.\n- MIS mention: Stage\u20112 does not rely on MIS; all steps are O(1) owing to the partition and anchors.\n\nF. Testable subclaims and sanity\n- Partition lemma: unit tests on random inputs verifying that P_long obeys periodicity and that all P_short lengths are \u2264 2\u2113_pump.\n- Typed anchoring (F1\u2011T): for random \u03c4 \u2208 T_short, construct G_{\u03c4,1} and assert mid\u2011block consistency from f_type(\u03c4).\n- Bridging (F2\u2011T): for random triples (\u03c4_1,\u03c4_S,\u03c4_2), verify Bridging[\u03c4_S][\u00b7][\u00b7] includes all seam pairs induced by the anchor windows of f_type(\u03c4_1) and f_type(\u03c4_2).\n- Endpoints: verify that single\u2011seam completions exist via RightAllow/LeftAllow + E.\n\nG. Complexity summary (verifier)\n- Enumerating T and T_short takes 2^{poly(\u03b2)} (Prop. 9 with Prop. 19). Building Ext tables and slices is 2^{poly(\u03b2)} (Props. 5, 19). The certificate f_type has |T_short| entries. Checking (F1\u2011T) needs |T_short| instances, (F2\u2011T) needs |T_short|^2\u00b7|T| instances; each reduces to constant\u2011time lookups in precomputed Ext and Bridging matrices. Total nondeterministic time: 2^{poly(\u03b2)}.\n\nH. Why type\u2011indexed f_type avoids the Q_\u03c4 tiling gap\n- The earlier Q_\u03c4 certificate requires the algorithm to produce an interior labeling of long blocks from boundary quadruples alone; while Ext_\u03c4 guarantees existence, it does not supply a constructive constant\u2011round filler. The f_type anchors provide explicit periodic interior labels (a short block per period), and the remaining gaps are filled by (F2\u2011T), which is a finite Ext\u2011check. This is exactly the construct used in the paper\u2019s Section 4.4 but expressed over types to keep verification singly\u2011exponential.\n\nI. Integration plan for output.md\n1) Add Lemma (P\u2011Partition\u2011Path) with parameters \u2113_pattern=\u2113_width=\u2113_pump and \u2113_count=2\u2113_pump+2, algorithm and proof sketch (as above).\n2) Add the S2\u2011path theorem with the type\u2011indexed f_type certificate, the (\u21d2) extraction from an O(1) algorithm, the (\u21d0) O(1) construction via anchors and (F2\u2011T) fills, and the NEXPTIME verification argument.\n3) Add Bridging[\u03c4_S] matrices and endpoint allow sets RightAllow/LeftAllow (optional) as implementation aids; all precomputable from Ext.\n4) Cross\u2011reference existing Ext machinery (Lemmas 11, 12; Props. 5, 19, 21) and the tiny\u2011path fallback (Lemma TP) for the very small\u2011n cases.\n\nJ. Potential objections and how we address them\n- Do nodes need to know the type of a long block? No: they only need to know the type \u03c4_w of the period w (|w| \u2264 \u2113_pump) to read f_type(\u03c4_w) for anchors; gathering |w| inputs is O(\u2113_pump)=O(1).\n- Does irregular segmentation require symmetry breaking? No: the partition is computed solely from input windows and the fixed global orientation (Step A); no MIS is used here.\n- Is (F2\u2011T) \u201ctyped\u201d formulation sufficient? Yes: by Lemma 11, feasibility depends only on the middle type \u03c4_S and the anchored seam colors, which are determined by f_type(\u03c4_1), f_type(\u03c4_2) and Ext_{\u03c4_S}.\n\nK. Closing note\n- With P\u2011Partition\u2011Path and the typed Stage\u20112 certificate, we now have a clean, singly\u2011exponential NEXPTIME pipeline for the full trichotomy on globally oriented paths: (i) S1\u2011path (endpoint\u2011coupled) separates \u03a9(n) vs o(n); (ii) S2\u2011path (typed anchors) separates O(1) vs \u0398(log* n). The constructions reduce to precomputed Ext tables, type enumeration, and constant\u2011radius decisions.\n"
}