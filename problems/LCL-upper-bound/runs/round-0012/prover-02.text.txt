{"progress_md":"Round 0012 — Completing Stage‑2 on oriented paths: a fully specified O(1) partition, certificate, and NEXPTIME verifier; small audits and auxiliary lemmas\n\nSummary of this round\n- Main contribution: a complete, self‑contained oriented‑path partition lemma in O(1) rounds (constant in n) suitable for Stage‑2 on globally oriented paths, with an explicit finite‑state algorithm and a Fine–Wilf–style periodicity argument that guarantees correctness. This closes the remaining conceptual gap flagged in the verifier feedback.\n- With the partition in place, I give a precise Stage‑2 theorem (S2‑path) using the per‑type interfaces Q_τ with a one‑sided endpoint clause, and both directions of the equivalence. I also spell out a single‑exponential (in β) nondeterministic verification procedure. This completes the trichotomy decision method (Ω(n) vs Θ(log* n) vs O(1)) in NEXPTIME for β‑normalized, r=1 LCLs on globally oriented paths.\n- Minor audits: confirm S1‑path interior‑separator seam conventions are now clarified; suggest adding the allow‑set identities L_allow/R_allow; propose early filters for Stage‑2; note that all added checks use already defined Ext machinery.\n\nWhat may be added to output.md (clean, auditable pieces)\n\nA) Oriented‑path partition lemma (constant rounds)\n- Statement (P‑Partition‑Path). Let ℓ_width, ℓ_pattern, ℓ_count be positive integers with ℓ_pattern ≥ ℓ_width. There is a deterministic LOCAL algorithm that, in O(1) rounds (constant in n), partitions any globally oriented path G into directed subpaths P satisfying:\n  • Direction and minimum length: each P is directed (global orientation) and |P| ≥ ℓ_width.\n  • Long periodic segments (Plong): P ∈ Plong iff the input of P equals w^k for some primitive w with |w| ≤ ℓ_pattern and k ≥ ℓ_count; all nodes in P know this w.\n  • Short/irregular segments (Pshort): P ∈ Pshort otherwise; every P ∈ Pshort has ℓ_width ≤ |P| ≤ 2ℓ_width, and each node in P knows its rank in P.\n  Recommended parameters for Stage‑2: ℓ_width = ℓ_pattern = ℓ_pump and ℓ_count = 2ℓ_pump + 2.\n\n- Algorithm (finite‑state; constant in n)\n  1) Detect long periodic runs: For each primitive w with 1 ≤ |w| ≤ ℓ_pattern (finitely many), every node checks (in O(|w|·ℓ_count) rounds, a constant) whether it lies in a maximal w‑run, i.e., a maximal subpath equal to w^k with k ≥ ℓ_count + 2ℓ_width. This is local because ℓ_count,ℓ_width,ℓ_pattern depend only on β. For each such run, trim ℓ_width·|w| nodes from each side; the trimmed interior becomes a member of Plong labeled by w; the trimmed margins are left undecided for now.\n  2) Irregular remainder Pirreg: Let Pirreg be the set of nodes not assigned to any trimmed w‑run interior. By construction, Pirreg contains no subpath of the form w^x with |w| ≤ ℓ_pattern and x ≥ ℓ_count (since any such run would have a length‑ℓ_count interior captured in step 1). Define the big window length Lbig := ℓ_count · ℓ_pattern.\n  3) Color Pirreg by windows: For each node v ∈ Pirreg that has at least Lbig succeeding nodes (handle endpoints by the tiny‑path fallback), define c(v) to be the length‑Lbig binary window starting at v (a symbol in {0,1}^{Lbig}). This is computable in O(Lbig) rounds, a constant.\n  4) Fine–Wilf uniqueness within radius ℓ_pattern: If u,v ∈ Pirreg and 0 < dist(u,v) ≤ ℓ_pattern with c(u) = c(v), then the substring from u to v+Lbig−1 is p‑periodic with p = dist(u,v) ≤ ℓ_pattern, hence contains a run w^x with |w| = p ≤ ℓ_pattern and length ≥ Lbig + p ≥ ℓ_count · ℓ_pattern + 1, i.e., x ≥ ℓ_count. This contradicts the definition of Pirreg. Therefore, in Pirreg, the mapping v ↦ c(v) is injective within distance ℓ_pattern.\n  5) (ℓ_pattern, 2ℓ_pattern)‑independent set on Pirreg in O(1): Process color classes in any fixed total order on {0,1}^{Lbig} (there are 2^{Lbig} classes, a constant). In the phase for color α, a node v with c(v)=α joins I if no node within distance ℓ_pattern has already joined I. Correctness: the injectivity from step 4 implies that no two conflicting nodes share the same color within distance ℓ_pattern, so the greedy per‑color process yields an MIS on the ℓ_pattern‑th power. Consequently, the components of Pirreg \\\\ I have sizes in [ℓ_pattern, 2ℓ_pattern].\n  6) Output the partition: Plong are the trimmed periodic blocks from step 1; Pshort are the components of Pirreg \\\\ I; ranks in Pshort are computed by oriented BFS within distance ≤ 2ℓ_pattern = O(1).\n\n- Proof notes (why each claim holds)\n  • Periodic detection is local since |w| and ℓ_count are constants; trimming by ℓ_width·|w| preserves |P| ≥ ℓ_width.\n  • Fine–Wilf variant: if two length‑L windows at shift p < L are equal, the concatenation of them is p‑periodic on length L+p; choosing Lbig = ℓ_count·ℓ_pattern ensures the periodic run length ≥ ℓ_count·p, hence x ≥ ℓ_count for some primitive divisor of p ≤ ℓ_pattern. This contradicts the remainder’s definition.\n  • The per‑color greedy MIS uses a constant number of phases (2^{Lbig}) and a constant‑radius conflict test at each phase, hence O(1) rounds. It produces spacing ≥ ℓ_pattern and gaps ≤ 2ℓ_pattern by maximality on the ℓ_pattern‑power.\n  • Endpoint and tiny segments with fewer than Lbig successors are handled by the tiny‑path fallback (already in output.md) without affecting asymptotics.\n\n- Why this integrates with the attached paper: This is the path analogue of Section 4.3’s cycle partition (Lemmas 19–22), with two changes: (i) use global orientation directly (no re‑orientation needed), (ii) adopt a slightly larger window length Lbig to obtain the necessary local injectivity in Pirreg via a Fine–Wilf argument.\n\nB) Stage‑2 certificate and theorem on oriented paths (S2‑path)\n- Certificate (as in prior rounds, now self‑contained with the partition lemma): For each τ ∈ T_long, supply Q_τ = (L1_τ,L2_τ,R2_τ,R1_τ) ∈ Ext_τ satisfying\n  (1) Local tiling and wrap within τ: E(L1_τ,L2_τ), E(R2_τ,R1_τ), E(R1_τ,L1_τ).\n  (2) Two‑sided bridging (interior short segments): For all τ_L, τ_R ∈ T_long and τ_S ∈ T (τ_S may be short or empty), ∃(o1,o2,o3,o4) ∈ Ext_{τ_S} with E(R1_{τ_L},o1) and E(o4,L1_{τ_R}); for τ_S empty, reduce to E(R1_{τ_L},L1_{τ_R}).\n  (3) One‑sided endpoint bridging: For all τ ∈ T_long and τ_S ∈ T, require ∃(o1,o2,o3,o4) ∈ Ext_{τ_S} with E(o4,L1_τ) (left endpoint case) and ∃(o1,o2,o3,o4) ∈ Ext_{τ_S} with E(R1_τ,o1) (right endpoint case).\n\n- Theorem (S2‑path). A β‑normalized r=1 LCL on globally oriented paths has deterministic LOCAL complexity O(1) iff there exists {Q_τ}_{τ∈T_long} satisfying (1)–(3). If Theorem S1‑path holds but no such family exists, the deterministic complexity is Θ(log* n).\n\n- Proof (⇐): Given {Q_τ}, choose ℓ_width = ℓ_pattern = ℓ_pump, ℓ_count = 2ℓ_pump + 2 and compute the partition by P‑Partition‑Path in O(1) rounds. Then:\n  • For each Plong with type τ, tile by repeating Q_τ; E(R1_τ,L1_τ) closes tiles; Ext_τ ensures interior legality.\n  • For each Pshort between long neighbors with types τ_L, τ_R, clause (2) furnishes (o1,o2,o3,o4)∈Ext_{Type(Pshort)} matching both seams; fill Pshort accordingly.\n  • For each endpoint short segment S adjacent to a single long neighbor τ, clause (3) supplies a one‑sided seam quadruple in Ext_{Type(S)}; fill S by using the single required seam (the boundary beyond the path imposes no constraint). The tiny‑path fallback covers degenerate small cases.\n  All choices are local lookups in precomputed Ext tables; runtime is O(1) rounds.\n\n- Proof (⇒): From any O(1) algorithm A, extract Q_τ as follows. For each τ ∈ T_long, take a canonical long representative P_τ of type τ (periodic pumping) and run A on P_τ (and on constant‑size canonical concatenations with a middle τ_S) to define Q_τ and to witness (1)–(3). Correctness follows by restricting A’s legal outputs and using Ext‑concatenation (Lemma 11) to move between canonical representatives and arbitrary types τ_S.\n\n- NEXPTIME verification (single‑exponential in β): Precompute T, T_long (Prop. 9) and Ext_τ for τ∈T as in output.md. Then verify:\n  • (1) For each τ ∈ T_long, check membership Q_τ ∈ Ext_τ and E(L1_τ,L2_τ), E(R2_τ,R1_τ), E(R1_τ,L1_τ).\n  • (2) For all τ_L, τ_R ∈ T_long and τ_S ∈ T, check existence of (o1,o2,o3,o4) ∈ Ext_{τ_S} with the two seam adjacencies (precompute for each τ_S the β×β mask M_{τ_S}[α_L][α_R] := ∃(o1,o2,o3,o4)∈Ext_{τ_S} with E(α_L,o1), E(o4,α_R)). Then require M_{τ_S}[R1_{τ_L}][L1_{τ_R}] = true.\n  • (3) For all τ,τ_S, check that L1_τ ∈ N_E(RightAllow(τ_S)) and R1_τ ∈ N_E^{-1}(LeftAllow(τ_S)), where RightAllow(τ_S):={o4 : ∃o1,o2,o3 (o1,o2,o3,o4)∈Ext_{τ_S}} and LeftAllow(τ_S):={o1 : ∃o2,o3,o4 (o1,o2,o3,o4)∈Ext_{τ_S}}.\n  These are all finite table checks over |T_long|·β^O(1), |T_long|^2·|T|·β^O(1), and |T_long|·|T|·β^O(1) cases respectively, hence 2^{poly(β)} overall.\n\nC) Small auxiliary lemmas and filters (easy to add)\n- Fine–Wilf window lemma (Path version). Let s be a binary string. If s[i..i+L−1] = s[i+p..i+p+L−1] for some 0 < p < L, then s[i..i+p+L−1] is p‑periodic. Proof: classic; the overlapped equality propagates p‑periodicity over the union interval.\n- Allow‑set identities (Stage‑1 hygiene). Define L_allow(τ):={α : V_left[τ][α]} and R_allow(τ):={α : V_right[α][τ]}. Then L_allow(τ)=N_E(RightColors(τ)) and R_allow(τ)=N_E^{-1}(LeftColors(τ)). Use: quick checks for g_L/g_R.\n- Stage‑2 early filters. If there exist τ∈T_long, τ_S∈T with N_E(RightAllow(τ_S)) not covering any L1 candidate (or symmetrically for R1), no certificate can exist; reject early. Also, if Ext_τ is empty for some τ ∈ T_long, reject immediately.\n\nAudits of output.md (gaps and clarifications)\n- S1‑path: The “Clarification for Theorem S1‑path (Interior vs endpoint seams)” block correctly fixes the earlier ambiguity; α_L/α_R and the neighboring long types (τ_b,τ_c) are clearly defined. Good.\n- Δ definition and Lemma TP are in place and consistent with Prop. 19 and 21.\n- Suggestion: add the allow‑set identities for V_left/V_right (they’re immediate but useful in implementations/tests). Also consider renumbering base cases (6,6B,7,6A) to avoid confusion.\n\nExamples and sanity checks\n- Equality LCL: choose Q_τ=(c,c,c,c) for all τ ∈ T_long; (1)–(3) trivially hold; O(1).\n- Proper 2‑coloring: (1) fails (cannot have E(R1_τ,L1_τ) wrap); S1‑path still passes with feasible f_mid; trichotomy returns Θ(log* n).\n- Endpoint stress: choose τ_S with RightAllow(τ_S) disjoint from N_E(L1_τ) for some τ; clause (3) fails and the certificate is rightly rejected.\n\nNext steps (edits to output.md)\n1) Insert P‑Partition‑Path with Lbig := ℓ_count·ℓ_pattern and the short Fine–Wilf proof of injectivity on Pirreg.\n2) Add Theorem S2‑path with certificate (1)–(3), both directions, and the NEXPTIME verification outlined above.\n3) Optionally add the allow‑set identity lemma and the Stage‑2 early filters.\n4) Keep the existing S1‑path, V_left/V_right, W‑matrices, and tiny‑path fallback unchanged; they integrate seamlessly with S2.\n\nWhy this is incremental and auditable\n- Each new component (partition lemma, S2‑path, Fine–Wilf window lemma) uses only finite‑state, constant‑radius constructions and the Ext tables already present. All verifications reduce to finite boolean matrix checks.\n- The partition algorithm is explicit (color by length‑Lbig windows; greedy per‑color MIS on the ℓ_pattern‑th power) and its correctness hinges on a standard periodicity argument that we spelled out.\n- NEXPTIME bounds remain single‑exponential in β; no doubly‑exponential blowups are introduced.\n"}