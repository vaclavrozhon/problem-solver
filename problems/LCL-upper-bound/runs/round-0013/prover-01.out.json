{
  "progress_md": "Round 0013 \u2014 Towards a sound Stage\u20112 (O(1) vs \u0398(log* n)) on oriented paths: typed anchors + corrected partition injectivity; small audits, new lemmas, and NEXPTIME checks\n\nSummary of this round\n- I propose a type\u2011based \u201canchor\u201d certificate f_anc that avoids the earlier length/phase mismatch and does not rely on tiling a long block by a single quadruple Q_\u03c4. The anchors are 2\u2011node windows placed at a canonical phase inside long periodic runs; they only fix seam colors and rely on Ext\u2011based bridging to fill the O(1) gaps. All checks are reducible to finite Ext/Bridging matrices and verifiable in NEXPTIME (single\u2011exponential in \u03b2).\n- I give a corrected per\u2011component injectivity lemma for the irregular remainder Pirreg and an O(1) greedy MIS construction on the \u2113_pattern\u2011th power of each Pirreg component. This patches the partition lemma gap flagged in the feedback (explicitly avoiding the distance\u2011mixing issue and boundary leaks). The parameters and proof outline are stated fully so they can be curated into output.md after polishing.\n- I add two small, unit\u2011testable identities: a reversal identity for W\u2011matrices (useful to cut verification work by \u22482\u00d7) and a formal \u201cno tiling\u201d counterexample to document why Q_\u03c4 cannot be naively repeated.\n- Minor output.md hygiene: an indexing reminder near OutR2/OutL1, and a cross\u2011reference for Lemma E3 where Out\u2011sets and W are used.\n\nAudit of output.md (gaps/clarifications)\n- OutR2/OutL1 indexing. Suggest adding, immediately after the Definition \u201cFeasible function; Out\u2011set form,\u201d a one\u2011liner \u201cIndexing reminder: Ext quadruples are (L1,L2,R2,R1), hence the middle block\u2019s left seam meets o1 and right seam meets o4.\u201d This is used implicitly in Lemma E3.\n- Stage\u20112 is intentionally absent (good per the verifier). The proposed additions below (typed anchors + corrected partition) are designed to be inserted as a new Stage\u20112 section once curated.\n\nPart I \u2014 Typed anchor certificate for Stage\u20112 (avoids length/phase mismatch and tiling)\nIdea at a glance\n- Instead of tiling long periodic blocks by Q_\u03c4, we place 2\u2011node anchors at a canonical phase in each period and require two kinds of finite checks:\n  (A) self\u2011compatibility of the anchor within a periodic context (no collisions when repeating anchors at period\u2011spacing), and\n  (B) bridging existence across any short middle type \u03c4_S between two anchored contexts (including the empty middle and one\u2011sided endpoint cases).\n- All checks are expressed via Ext concatenations and Bridging matrices on short types; no word enumeration, no full\u2011period outputs.\n\nObjects\n- T, T_long, Ext, W_{b\u2299c} as in output.md. Fix constants (as in the paper and notes): \u2113_pattern := \u2113_pump, \u2113_width := \u2113_pump, \u2113_count := 2\u2113_pump + 2.\n- Period base types: Let T_base := {\u03c3 \u2208 T : k_flag(\u03c3) \u2208 {1,2,3} and 1 \u2264 |\u03c3| \u2264 \u2113_pattern}. Intuitively, \u03c3 represents a short block of length p \u2264 \u2113_pattern that can act as a period tile when repeated.\n  Remark. We avoid word\u2011level primitive testing; instead, the verifier (see below) checks only those \u03c3 that actually appear as a base in some long periodic type realized by \u03c3^{\u2299k} for k \u2265 \u2113_count (all in type space via Ext\u2011concatenation).\n- Long periodic types from a base \u03c3: define \u03a0(\u03c3) := {\u03c4 \u2208 T_long : \u2203k \u2265 \u2113_count with \u03c4 \u2261 Type(\u03c3^{\u2299k})} (computed by repeated concatenation in T). This is singly\u2011ex enumeratable since \u03c3 \u2208 T and k \u2264 \u2113_count is a constant depending only on \u03b2.\n\nCertificate (typed anchors)\n- For each \u03c3 \u2208 T_base used by the certificate, choose a phase m \u2208 {0,1,\u2026,|\u03c3|\u22121} and an anchor pair a(\u03c3) = (\u03b11(\u03c3), \u03b12(\u03c3)) \u2208 \u03a3_out^2.\n- Canonical phase selection rule (executed locally in O(1) inside Plong): On a long period run whose long type lies in \u03a0(\u03c3), nodes know |\u03c3| and rank mod |\u03c3| (from the partition); the anchors are exactly those two\u2011node windows whose left endpoint has rank \u2261 m (mod |\u03c3|). This fixes one anchor per period, spaced by |\u03c3|.\n\nTyped anchor feasibility checks (finite, NEXPTIME)\nLet \u03c3 \u2208 T_base. Define \u03c4 = any member of \u03a0(\u03c3) (choice irrelevant by periodic pumping; picking the \u03c4 with k = \u2113_count suffices). Let \u03b1(\u03c3):=a(\u03c3).\n- (F1\u2011anc self\u2011compatibility): Repeatability of anchors at period spacing:\n  There exists a witness in Ext for the middle \u03c3 of \u03c3 \u2299 \u03c3 \u2299 \u03c3, such that the seam edges toward the two neighbors are E\u2011adjacent to \u03b1(\u03c3) on both sides. Formally, define M_self[\u03c3] := \u201cW_{\u03c3\u2299\u03c3}[\u03b1(\u03c3)][\u03b1(\u03c3)] = true\u201d. This guarantees that placing anchors at phase m in consecutive periods imposes no conflict across the intervening \u03c3 block. Because of associativity (Prop. 12), iterating this condition yields consistency for any number of repeats.\n  Why this captures local legality: the adjacency E(\u03b11,\u03b12) and node constraints at the two anchor nodes are baked into the Bridging table via Ext (the middle block \u03c3 must accept \u03b1(\u03c3) on both seams to be extensible); we do not need to read input bits explicitly.\n- (F2\u2011anc bridging across arbitrary short middle type): For every \u03c4_S \u2208 T (including \u03c4_S = \u2205) and for every pair of periodic long types \u03c4_L \u2208 \u03a0(\u03c3_L), \u03c4_R \u2208 \u03a0(\u03c3_R), require bridging across \u03c4_S from \u03b1(\u03c3_L) to \u03b1(\u03c3_R):\n  Bridging[\u03c4_S][\u03b1(\u03c3_L)][\u03b1(\u03c3_R)] = true, where Bridging[\u03c4_S] is the \u03b2\u00d7\u03b2 mask defined in the notes and computable from Ext_{\u03c4_S} and E.\n- (F3\u2011anc endpoints one\u2011sided): For every \u03c4 \u2208 \u03a0(\u03c3) and every \u03c4_S \u2208 T,\n  \u2022 left endpoint: \u2203(o1,o2,o3,o4)\u2208Ext_{\u03c4_S} with E(o4, \u03b11(\u03c3)), i.e., \u03b11(\u03c3) \u2208 N_E(RightAllow(\u03c4_S)), and\n  \u2022 right endpoint: \u2203(o1,o2,o3,o4)\u2208Ext_{\u03c4_S} with E(\u03b12(\u03c3), o1), i.e., \u03b12(\u03c3) \u2208 N_E^{-1}(LeftAllow(\u03c4_S)).\nThese are the one\u2011sided analogues of Stage\u20111\u2019s V_left/V_right, now phrased via Ext projections of \u03c4_S.\n\nWhy this is enough for an O(1) algorithm (to be added after partition is curated)\n- Compute in O(1) the (\u2113_width,\u2113_count,\u2113_pattern)\u2011partition (Part II). On each P \u2208 Plong with long type in \u03a0(\u03c3), place anchors at the canonical phase m modulo |\u03c3|.\n- The anchors carve P \u2208 Plong into O(|\u03c3|)=O(1) gaps (each equal to \u03c3). Gaps between distinct Plong blocks, and all of Pshort components, have length O(\u2113_pump) by construction. Use (F2\u2011anc) to fill each such gap S (between left \u03b1(\u03c3_L) and right \u03b1(\u03c3_R)), and (F3\u2011anc) at endpoints, by table lookups; (F1\u2011anc) ensures no conflicts between adjacent anchors inside the same Plong block.\n- Everything depends only on constant\u2011radius information and precomputed tables; hence O(1) LOCAL rounds.\n\nNEXPTIME verification of f_anc (single\u2011exponential)\n- Enumerate T (Prop. 9), compute Ext_\u03c4 for \u03c4\u2208T and Bridging[\u03c4_S], RightAllow/LeftAllow of each \u03c4_S. For each \u03c3 \u2208 T_base and k \u2208 [\u2113_count], compute Type(\u03c3^{\u2299k}) via Prop. 5 to populate \u03a0(\u03c3).\n- Check F1\u2011anc for each \u03c3 by querying W_{\u03c3\u2299\u03c3}[\u03b1(\u03c3)][\u03b1(\u03c3)]. Check F2\u2011anc for all triples (\u03c3_L,\u03c4_S,\u03c3_R) and all \u03c4_L \u2208 \u03a0(\u03c3_L), \u03c4_R \u2208 \u03a0(\u03c3_R) by Bridging[\u03c4_S][\u03b1(\u03c3_L)][\u03b1(\u03c3_R)]. Check F3\u2011anc for all (\u03c3,\u03c4_S) via precomputed allow\u2011sets.\n- Total work: |T_base|\u00b7\u03b2^O(1) for F1, |T_base|^2\u00b7|T|\u00b7\u03b2^O(1) for F2, and |T_base|\u00b7|T|\u00b7\u03b2^O(1) for F3; with |T| \u2264 4\u00b72^{\u03b2^4}, this is 2^{poly(\u03b2)}.\n\nNotes on correctness vs earlier gaps\n- No tiling by Q_\u03c4: We never assume a reusable interior tile; \u03c3 \u2299 \u03c3 compatibility (F1\u2011anc) is enforced by W and guarantees only that anchors coexist when separated by one \u03c3, which by associativity extends to any number of periods.\n- No phase/length mismatch: The algorithm fixes a canonical m modulo |\u03c3| and only places anchors at that phase. The check is independent of the actual bit pattern and uses Ext tables to ensure local legality via extendibility.\n\nPart II \u2014 Corrected partition: injectivity in Pirreg and an O(1) MIS\nParameter recap\n- \u2113_width = \u2113_pattern = \u2113_pump, \u2113_count = 2\u2113_pump + 2, as in output.md prose.\n- Lwin = (\u2113_count + 2\u2113_width)\u00b7\u2113_pattern + (\u2113_pattern \u2212 1). This is chosen so that equal length\u2011Lwin windows at shift p \u2264 \u2113_pattern imply a p\u2011periodic substring of length \u2265 (\u2113_count + 2\u2113_width)\u00b7p fully contained in the union interval (Fine\u2013Wilf), see below.\n\nConstruction (directed case; undirected handled by an initial \u2113\u2011orientation as in the paper)\n1) Detect and trim long periodic runs (unchanged): For each p \u2208 [1..\u2113_pattern] and each short type \u03c3 of length p, identify maximal \u03c3^{\u2299K} runs with K \u2265 \u2113_count + 2\u2113_width. Trim \u2113_width\u00b7p nodes from both ends. The interiors form Plong; the remainder is Pirreg.\n2) Define legal window colors on Pirreg: For each directed component H of Pirreg, define c(v) for a node v \u2208 H that has at least Lwin successors also in H, as the binary window of length Lwin starting at v and fully contained in H. Nodes within Lwin\u22121 from the H\u2011boundary are marked boundary and will not attempt to join the MIS (handled by the fallback cuts below).\n3) Injectivity lemma (per component, induced metric). For any H, if u,v \u2208 H with dist_H(u,v) \u2208 [1..\u2113_pattern], and both have defined colors c(u)=c(v), then H contains a p\u2011periodic subpath of length \u2265 (\u2113_count + 2\u2113_width)\u00b7p for p = dist_H(u,v). This contradicts the construction of Pirreg, since such a subpath would have been captured (and trimmed) in step 1.\n  Proof sketch. Let P_H be the unique directed simple path in H from u to v (length p \u2264 \u2113_pattern). Since both length\u2011Lwin windows at u and v lie entirely within H and are identical, the standard Fine\u2013Wilf lemma implies that the length\u2011(Lwin+p) union interval (in the ambient path) is p\u2011periodic. Because P_H is contained in H, the entire union interval also lies within H (by the choice of c(\u00b7) we excluded windows spilling outside H), yielding a p\u2011periodic subpath inside H of length at least Lwin \u2265 (\u2113_count+2\u2113_width)\u00b7\u2113_pattern \u2265 (\u2113_count+2\u2113_width)\u00b7p. This would have created a run \u03c3^{\u2299K} with K \u2265 \u2113_count + 2\u2113_width in step 1, hence is impossible in Pirreg.\n4) Greedy MIS on the \u2113_pattern\u2011th power of H in O(1): Process color classes in any fixed total order on {0,1}^{Lwin}. In the phase for color x, a node with c(\u00b7)=x joins I_H if none of its predecessors within distance \u2264 \u2113_pattern in H has already joined. By the injectivity (step 3), no two conflicting nodes share a color within distance \u2113_pattern, so the greedy per\u2011color process yields an MIS on the \u2113_pattern\u2011power. Consequently, each component of H\\I_H has directed length in [\u2113_pattern, 2\u2113_pattern].\n5) Final partition: Plong are as in step 1. Pshort consists of (i) all components of H\\I_H over all H (each length \u2208 [\u2113_pattern, 2\u2113_pattern]), and (ii) for boundary nodes within distance < Lwin of H\u2019s endpoints, attach them to neighboring Pshort pieces to ensure every piece has length \u2265 \u2113_width (this is feasible since Lwin \u226b \u2113_width). Each node knows its role and rank in O(1) rounds.\n\nRemarks\n- All constants depend only on \u03b2; the number of color phases 2^{Lwin} is a large constant, but the LOCAL time is O(1).\n- This fixes the feedback issues: injectivity is proved within the induced metric of H, and colors are defined only by windows fully contained in H, preventing \u201cleaks\u201d into trimmed interiors.\n\nPart III \u2014 Small, testable identities and examples\n1) Reversal identity for W.\nLemma W\u2011rev. For any \u03c4_b, \u03c4_c \u2208 T and \u03b1_L,\u03b1_R \u2208 \u03a3_out,\n  W_{Rev(\u03c4_c) \u2299 Rev(\u03c4_b)}[\u03b1_R][\u03b1_L] = W_{\u03c4_b \u2299 \u03c4_c}[\u03b1_L][\u03b1_R].\nProof. Combine Lemma 10 (Rev) with the definition of W via Ext and E, and swap coordinates.\nUse. Halves the number of distinct W\u2011checks in preprocessing and in Stage\u20112 verification.\n\n2) \u201cNo tiling by Q_\u03c4\u201d counterexample (documenting a pitfall).\nLet \u03a3_out={a,b}, A_0=A_1={a,b}, and E={(a,b)} (single directed edge). For a length\u20114 block \u03c4 with Ext_\u03c4 containing (a,b,b,a) and (a,b,b,b), one can pick Q_\u03c4=(a,b,b,a)\u2208Ext_\u03c4 and E(R1_\u03c4,L1_\u03c4)=E(a,a) fails. Even if a different Q_\u03c4 has E(R1_\u03c4,L1_\u03c4) true, repeating Q_\u03c4 creates two adjacent b at the seam (needs E(b,\u00b7)), which is impossible. Hence Ext_\u03c4 does not imply an interior tile repeatable at period\u20111. This illustrates why our anchor\u2011only approach is needed.\n\n3) Early rejection filters for anchors.\n- If for some \u03c3, W_{\u03c3\u2299\u03c3}[\u03b1][\u03b1] is false for every \u03b1\u2208\u03a3_out^2, \u03c3 cannot be a usable base; skip \u03c3.\n- If Bridging[\u03c4_S] has a row or column of all false entries for some \u03c4_S, any certificate must fail; reject early.\n\n4) Sanity examples.\n- Equality LCL: take any \u03c3, set \u03b1(\u03c3)=(c,c); all F1\u2013F3 pass trivially.\n- Proper 2\u2011coloring: With E={(0,1),(1,0)}, any attempt to anchor at period\u20111 fails F1\u2011anc (W_{\u03c3\u2299\u03c3}[\u03b1][\u03b1]=false). Stage\u20111 feasible f still exists; classification \u0398(log* n).\n\nPart IV \u2014 How to integrate (suggested edits)\n- Add the typed anchors section as Stage\u20112 (path version): objects, certificate (\u03c3,m,\u03b1(\u03c3)), feasibility checks (F1\u2013F3), and the O(1) construction sketch. Defer inserting the full partition proof until Part II is curated. Explicitly point out that all verification reduces to finite Ext/Bridging tables.\n- Insert Lemma W\u2011rev in the preprocessing section to shrink checks; reference it in Stage\u20111/2.\n- In the Stage\u20111 section, add the short Indexing reminder after Lemma E3 as noted above.\n\nWhy these steps are incremental and auditable\n- The anchor checks (F1\u2013F3) are boolean matrix queries over objects already defined (Ext, W, Bridging, allow\u2011sets). They can be unit\u2011tested directly on small \u03b2.\n- The corrected injectivity lemma is local to each Pirreg component and uses only standard Fine\u2013Wilf periodicity; it fixes the earlier distance\u2011mixing flaw and is independently testable.\n- The reversal identity for W is an immediate corollary of existing lemmas (Rev + Ext\u2011concatenation); it reduces implementation burden and can be asserted with a simple proof.\n\nOpen items\n- Provide the full, polished write\u2011up of Part II\u2019s partition (directed and undirected cases), including the small boundary\u2011aggregation argument in step 5.\n- After integrating the partition, complete the (\u21d0) proof: full O(1) algorithm using typed anchors + Bridging tables on oriented paths. Finally, add the NEXPTIME verification argument tying together F1\u2013F3.\n"
}