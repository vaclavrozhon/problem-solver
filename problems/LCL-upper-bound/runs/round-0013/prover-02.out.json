{
  "progress_md": "Round 0013 \u2014 Repairing the O(1) partition on oriented paths and proposing a typed\u2011anchor Stage\u20112 certificate (singly\u2011exponential verification); audits and unit tests\n\nStatus and goals\n- Stage\u20111 (o(n) vs \u03a9(n)) is now cleanly integrated in output.md via Theorem S1\u2011path with endpoint coupling (g_L,g_R aligned to Out\u2011sets) and W/V tables.\n- Stage\u20112 (O(1) vs \u0398(log* n)) remains out of output.md; prior notes included two alternative certificates. The verifier feedback identified two correctness gaps: (i) the O(1) partition on oriented paths, and (ii) \u201ctiling by Q_\u03c4\u201d is unsound; we should instead use short anchors and Ext\u2011bridging.\n- This round: (A) I give a repaired, fully local O(1) partition (for globally oriented paths) with an explicit \u201cGood\u201d set and a Fine\u2013Wilf\u2011based injectivity proof, stated with constants that close earlier gaps; (B) I specify a typed\u2011anchor Stage\u20112 certificate (2\u2011node anchors per period type) whose verification is singly\u2011exponential in \u03b2 and whose construction uses only Ext\u2011based Bridging/Allow matrices. I also outline unit tests. I do not modify output.md yet; I propose concrete text to add when ready.\n\nA) Oriented\u2011path partition (repaired; constant rounds)\nParameters and precomputation (constants depend only on \u03b2)\n- Set \u2113_pattern := \u2113_pump and \u2113_width := \u2113_pump, and \u2113_count := 2\u2113_pump + 2 (as in the cycle proof). Let r=1.\n- Define Lbig := (\u2113_count + 2\u2113_width \u2212 1) \u00b7 \u2113_pattern. This is strictly larger than (\u2113_count+2\u2113_width\u22121)\u00b7p for every period p \u2264 \u2113_pattern; it is the key window length used below.\n\nAlgorithm (three steps; all O(1) rounds)\n1) Detect long periodic runs and trim interiors (Plong). For each 1 \u2264 p \u2264 \u2113_pattern and each primitive binary word w of length p, each node checks in radius (\u2113_count+2\u2113_width)\u00b7p whether it belongs to a maximal w\u2011run of length at least (\u2113_count+2\u2113_width)\u00b7p. This is a finite\u2011state, constant\u2011radius test with the global orientation. For each detected run, trim \u2113_width\u00b7p nodes from each end; the trimmed interior segments form Plong; each node in Plong learns p and the primitive w (by reading its p\u2011window). The trimmed margins remain outside Plong.\n2) Define Pirreg and the Good set. Let Pirreg be the induced subgraph on nodes not in Plong (i.e., all nodes outside the trimmed interiors). Define Good \u2286 Pirreg as the set of nodes v such that the directed forward window of length Lbig (positions v..v+Lbig\u22121) lies entirely in Pirreg. Each node can test Good locally by seeing both its Plong flags (nearby) and the next Lbig\u22121 nodes (constant radius).\n3) Beacons via per\u2011window greedy MIS on Good. Color each v \u2208 Good by c(v) := the input substring of length Lbig starting at v. Process colors in any fixed total order on {0,1}^{Lbig}. In the phase of color \u03b1, a Good\u2011node v with c(v)=\u03b1 joins I if no node within directed path distance \u2264 \u2113_pattern to the right or left in the underlying path has already joined I. This is the classic greedy MIS on the \u2113_pattern\u2011th power, restricted to Good.\n\nKey injectivity claim (new; closes the Fine\u2013Wilf gap)\nClaim. If u,v \u2208 Good, dist_G(u,v) \u2264 \u2113_pattern, and c(u) = c(v), then contradiction.\nSketch. Let p := dist_G(u,v) \u2264 \u2113_pattern (since the underlying graph is a path, the unique path length equals the shift). Equality c(u)=c(v) (two length\u2011Lbig windows at shift p<Lbig) implies, by Fine\u2013Wilf, that the concatenation s[u..v+Lbig\u22121] is p\u2011periodic over length Lbig+p. Our choice Lbig \u2265 (\u2113_count+2\u2113_width\u22121)\u00b7\u2113_pattern ensures Lbig+p \u2265 (\u2113_count+2\u2113_width)\u00b7p. Hence the input contains a p\u2011periodic run of length at least (\u2113_count+2\u2113_width)\u00b7p around u..v+Lbig\u22121. By Step 1, the \u2113_width\u00b7p\u2011trimmed interior of this run is in Plong. But u,v \u2208 Good means their entire forward Lbig windows avoid Plong; that forces the p\u2011periodic region s[u..v+Lbig\u22121] to avoid Plong, contradicting the previous sentence. Therefore c(u) \u2260 c(v) for any two Good nodes at path distance \u2264 \u2113_pattern.\nConsequence. The per\u2011color greedy selection on Good computes an MIS on the \u2113_pattern\u2011th power of the underlying path restricted to Good in O(1) phases; any two beacons are \u2265 \u2113_pattern apart, and maximality implies gaps in Good \\ I have size \u2264 2\u2113_pattern in the Good\u2011metric.\n\nBounding the irregular residuals\n- Nodes in Pirreg \\ Good are those within < Lbig positions of some Plong boundary. Every directed component C of Pirreg can be covered by (i) trimmed margins of Plong blocks (each margin has size < \u2113_width\u00b7p \u2264 \u2113_width\u00b7\u2113_pattern) plus (ii) Good\u2011intervals between margins. After placing beacons in Good, each Good\u2011interval breaks into pieces of length \u2264 2\u2113_pattern, and the leftover margin pieces have length < Lbig + 2\u2113_width\u00b7\u2113_pattern by definition of Good. Hence every connected subpath of Pirreg \\ I has length bounded by K_part := Lbig + 2\u2113_width\u00b7\u2113_pattern + 2\u2113_pattern = O(\u2113_pump^2), a constant.\n- The final partition P is: Plong (from Step 1) and Pshort: the connected components of the complement (Pirreg \\ I) plus the size\u2011\u22642\u2113_pattern residuals inside Good. Each P \u2208 Pshort has \u2113_width \u2264 |P| \u2264 2K_part (constants), and each node can determine its rank in O(1) rounds.\n\nWhy this fixes previous gaps\n- The earlier incorrect \u201cP_short \u2264 2\u2113_width\u201d claim is replaced by an explicit residual bound K_part tied to Lbig and \u2113_pattern.\n- The injectivity is proved only inside Good, and the contradiction explicitly uses that c\u2011windows stay within Pirreg (hence the periodic run would have forced a Plong interior). We avoid mixing induced\u2011subgraph and full\u2011graph distances by measuring MIS adjacency on the underlying path.\n- All steps are constant\u2011round with global orientation and fixed parameters.\n\nB) Typed\u2011anchor Stage\u20112 certificate (no tiling; singly\u2011exponential verification)\nMotivation. Instead of \u201ctiling by Q_\u03c4\u201d (unsound), place short anchors (2 nodes for r=1) inside long periodic runs and fill all O(1) gaps using Ext\u2011based Bridging matrices. To keep verification single\u2011exponential, anchor types are indexed by period types (derived from short types), not by words.\n\nObjects\n- Period types \u0398: for each primitive binary word w with |w| \u2264 \u2113_pattern, let \u03b8 := Type(w) (on length |w|) \u2014 equivalently, any representative of that short type with primitive period p(w). \u0398 is finite, |\u0398| \u2264 |T|.\n- Phase selection (deterministic, local). In a long p\u2011periodic run P \u2208 Plong with primitive period w, choose the unique phase \u03c6(w) \u2208 {0,1,\u2026,p\u22121} minimizing the length\u2011p window lexicographically (ties broken by a fixed total order on {0,1}^p). Each node can compute p and w (p \u2264 \u2113_pattern), hence \u03c6(w), in O(1) rounds in Plong.\n- Anchors per period type: f_anchor: \u0398 \u2192 \u03a3_out^2 assigns a 2\u2011node output (\u03b11,\u03b12) to be placed on the two consecutive nodes starting at phase \u03c6(w) modulo p across any long run of period w (one anchor per period).\n- Bridging matrices: as already suggested, for every type \u03c4_S (short middle type) define Bridging[\u03c4_S][\u03b1_L][\u03b1_R] := true iff \u2203(o1,o2,o3,o4) \u2208 Ext_{\u03c4_S} with E(\u03b1_L,o1) and E(o4,\u03b1_R). For endpoints, LeftAllow/RightAllow sets are the projections used with E (these equal the V_left/V_right allow\u2011sets already defined in output.md).\n\nCertificate (finite)\n- f_anchor on \u0398.\n- For every \u03c4_S \u2208 T, the precomputed Bridging[\u03c4_S], and for endpoints the LeftAllow/RightAllow sets (derivable from Ext; not guessed).\n\nFeasibility conditions (typed anchors)\n- (A1) Local legality of anchors and periodic compatibility: for any \u03b8 \u2208 \u0398 with representative primitive period w, the 2\u2011node string f_anchor(\u03b8) must be locally legal (node/edge checks against A\u00b7 and E). Moreover, if two copies of the anchor are placed at distance p(w) inside the same run, all edges crossing the two 2\u2011node windows are locally legal. (This reduces to checking E on a constant number of edges: within and across adjacent anchored windows.)\n- (A2) Two\u2011sided bridging across short separators: For all \u03c4_L,\u03c4_R \u2208 T_long that occur adjacent to a separator S of type \u03c4_S, the seam colors \u03b1_L := second(f_anchor(\u03b8_L)) and \u03b1_R := first(f_anchor(\u03b8_R)) must satisfy Bridging[\u03c4_S][\u03b1_L][\u03b1_R] = true.\n- (A3) One\u2011sided endpoint bridging: For all \u03c4 \u2208 T_long and \u03c4_S \u2208 T that may appear at an endpoint, require LeftAllow(\u03c4_S) \u220b o4 with E(o4, L1_\u03c4) and RightAllow(\u03c4_S) \u220b o1 with E(R1_\u03c4, o1) (the same one\u2011sided check as in Stage\u20112 plan; endpoints impose only one seam).\n\nConstruction from the certificate (O(1) rounds)\n- Partition by the repaired scheme above. Inside each Plong component (period w) pick the phase \u03c6(w) and place one 2\u2011node anchor f_anchor(\u03b8(w)) on each period occurrence; this is consistent and legal by (A1). Then every gap between consecutive anchors (and the short irregular components Pshort and endpoints) has O(1) length by the residual bound K_part; complete each such gap S using (A2) with Bridging[\u03c4_S] (two\u2011sided interior) or (A3) (one\u2011sided endpoints). All lookups are in precomputed tables, hence O(1) rounds.\n\nExtraction from an O(1) algorithm (standard) and verification\n- (\u21d2) Given an O(1) algorithm, extract f_anchor by simulating on a canonical long representative of each \u03b8 with disjoint runtime halos, exactly as in Lemma 24/25 of the paper (cycle case). The halo\u2011isomorphism ensures (A1) and the Ext\u2011concatenation ensures (A2)\u2013(A3).\n- Verification is singly\u2011exponential: enumerate T and \u0398 (\u2264|T|), compute Ext tables and Bridging/Allow matrices in 2^{poly(\u03b2)}, and check (A1)\u2013(A3) entrywise. No enumeration over all words up to length \u2113_pump is needed.\n\nC) Unit\u2011testable subclaims and experiments\n- Partition injectivity (Good): On adversarial inputs combining long periodic runs and irregular zones (including de Bruijn\u2011like strings), assert that for random u,v \u2208 Good with dist_G(u,v) \u2264 \u2113_pattern we never get c(u)=c(v). Also verify that no Good interval without beacons exceeds 2\u2113_pattern, and that residual components have size \u2264 K_part.\n- Bridging matrices: for random \u03c4_S, verify Bridging[\u03c4_S] computed from Ext equals the direct scan definition. Sanity: Equality LCL yields all\u2011true Bridging; proper 2\u2011coloring yields failure of (A1) for period p=1.\n- Endpoints: pick \u03c4_S with RightAllow(\u03c4_S) disjoint from N_E(L1_\u03c4); (A3) must fail.\n\nD) Audits of output.md (gaps or clarifications)\n- No Stage\u20112 is claimed in output.md; good. The Stage\u20112 content to add later should follow the typed\u2011anchor scheme; \u201ctiling by Q_\u03c4\u201d should be avoided.\n- Theorem S1\u2011path (\u21d2) mentions a periodic ID pattern; a one\u2011line remark could note that pumped contexts are chosen long enough so that the runtime halos around the separator(s) do not intersect, ensuring the outputs used to define f_mid and g_L/g_R are well\u2011defined.\n- Minor hygiene: add an \u201cIndexing reminder\u201d near Lemma E2 (already present at top; consider repeating before E2) to avoid confusion with (L1,L2,R2,R1).\n\nE) Actionable next steps for output.md\n- Add the repaired oriented\u2011path partition lemma with parameters (\u2113_pattern,\u2113_width,\u2113_count) and Lbig as above, including the Good\u2011set injectivity proof and the residual bound K_part.\n- State the typed\u2011anchor Stage\u20112 theorem (certificate \u21d4 O(1)) with (A1)\u2013(A3) and the O(1) construction via anchors + Bridging/Allow matrices; provide NEXPTIME verification. Cross\u2011reference Ext, W/Bridging, and endpoint Allow/V tables already defined.\n- Keep S2 out until the partition text is fully integrated; the verifier can nonetheless implement Bridging/Allow tables now (purely precomputable from Ext).\n\nWhy this is incremental and auditable\n- Each new component is finite\u2011state and reduces to boolean table checks based on Ext. The only nontrivial proof is the Good\u2011set injectivity, spelled with a Fine\u2013Wilf argument that explicitly forces a Plong interior, avoiding the earlier boundary collision.\n- All constants (Lbig, K_part) are expressed in terms of \u2113_pump and \u2113_pattern and are independent of n; all LOCAL steps are O(1) rounds.\n- Unit tests outlined above can be automated for small \u03b2 (e.g., \u03b2\u2208{2,3}) by enumerating types and random inputs.\n"
}