
## round-0001 — model summary — 2025-08-27T11:03:04.494639Z
This round specialized the paper's feasible-function framework to radius-1, β-normalized LCLs on globally oriented paths and developed an explicit single-exponential finite-state abstraction (types). We proved a type-count bound |T| ≤ 16·2^{β^4}, gave a deterministic DP to enumerate reachable types and compute the append-one-bit successor δ in time 2^{poly(β)}, and defined per-type macro relations R_t summarizing how a block bridges outside outputs. Using these primitives we sketched NEXPTIME verifiers: (i) guess a type-indexed feasible function F to separate Ω(n) vs o(n); (ii) guess per-type boundary quadruples Q_t to separate O(1) vs Ω(log* n). The Verifier flagged a critical soundness gap: naive composition of R_t via an intermediate label m is unsound — one must compute concatenated summaries (Ext) and derive R for the concatenation (a small 3-color counterexample demonstrates the failure). Next steps are to formalize/correct δ, fix bridging composition, and prove the boundary-interface witness equivalence.

## round-0002 — model summary — 2025-08-27T12:05:19.309268Z
Round 0002: fixed the r=1 DP and repaired verifier soundness. Derived an exact append-one-bit recurrence for Ext-tables with explicit k=1,2,3 base cases and proved append-congruence (with the practical caveat that types must carry a k_flag for short lengths). Replaced the unsound R-composition by an Ext-level concatenation lemma and supplied a minimal 3-symbol counterexample (a→b→c). Gave a deterministic BFS to enumerate reachable types (type = (b_in, Ext, k_flag)), bounded |T| ≤ 16·2^{β^4} and O(β^5) per-append, so preprocessing is 2^{poly(N)}. Rewrote both NEXPTIME verifiers (Ω(n) vs o(n) and O(1) vs Ω(log* n)) to use Ext-concatenation with explicit universal checks and provided pseudocode. Remaining polishing: fix the k=2 base-case wording, add unit/regression tests, and complete a full equivalence proof for the boundary-interface witness. Files: prover-01.out.json, prover-02.out.json (Round 0002) and verifier summary.

## round-0003 — model summary — 2025-08-27T14:56:35.613633Z
This round closes two formalization gaps from outputs.pdf and records an optimization. Stage-1: a type-level feasible-function f : T × {0,1}^2 × T → Σ_out^2 is defined with (i) local node constraints and (ii) a universal Ext-concatenation membership condition across separators; existence of f is verifiable in NEXPTIME by computing T and Ext-tables and nondeterministically guessing f. The definition is argued equivalent to the paper’s feasible function (both directions). Stage-2: each type τ gets a boundary-interface witness Q_τ=(L1,L2,R2,R1) with checks (a) local tiling via Ext_τ and wrap-around E, and (b) bridging across any middle type τ_S via Ext membership; if all checks pass the instance is O(1), if Stage-1 passes but Stage-2 fails it’s Θ(log* n), else Θ(n). Optimization: concatenation time reduced from O(β^8) to O(β^6) by precomputing Left/Right 3D slices per type. Examples and endpoint/orientation notes included. Next steps identify formal proofs, the faster routine, and a small regression suite. Citations: prover-01.out.json (progress_md), outputs.pdf.

## round-0004 — model summary — 2025-08-27T15:04:44.798705Z
Round 0004 audit: outputs.md now records the core r=1 ingredients with complete proofs for the high-k append recurrence (k_flag≥4), Ext-level concatenation, congruence (type preserved under append), an explicit counterexample showing R-composition via ∃m is unsound, and an O(β^6) concatenation routine via 3D slices. Missing/needed pieces were identified and concrete additions proposed: an explicit k=1→2 base rule to seed the DP; a deterministic BFS enumeration of Types T and a proof that δ is well-defined with complexity bounds; a reversal operator Rev(·); precise Stage-1 (feasible table f and the o(n)⇔existence-of-f equivalence checked via Ext_{τ⊙σ}); precise Stage-2 (per-type witnesses Q_τ, universal bridging checks, and a constant-round construction); optional Ext_{∅} handling; small sanity/regression tests and an appendix with O(β^6) implementation details. Action items: promote sections 1–5 into outputs.md, add the concatenation appendix, and add regressions (β∈{2,3}). Citations: prover-01.out.json (progress_md); outputs.md (Round 0004).

