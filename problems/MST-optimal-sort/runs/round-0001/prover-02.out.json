{
  "content": "# Ideas\n\n- Prove a one-sided domination MST_log \u2264 C\u00b7Reg_log via a scale-by-scale component count (Kruskal-style integral) and a very sparse auxiliary graph that only uses two kinds of short edges: (i) time-adjacent (i,i\u22121), and (ii) value-adjacent (|\u03c0(i)\u2212\u03c0(j)|=1). This yields a clean per-scale bound that integrates to a sum of logs dominated by Reg_log.\n- Show the reverse domination fails by constructing an infinite family with small per-step vertical variation (so MST_log is \u0398(n)) but large t_i for most i (so Reg_log is \u0398(n log n)). A simple \u201cby residue classes\u201d (C-striding) permutation works.\n\n# Main Lemma (Kruskal integral for log-weights)\n\nLet P be any finite point set in a normed plane with distance d(\u00b7,\u00b7) and define G(t) as the graph on P with edges {u,v} whenever d(u,v) \u2264 t. Let \u03ba(t) be the number of connected components of G(t). For the MST in the complete graph with edge weights f(d)=log(1+d),\n\n\u2211_{e in MST} log(1+length(e)) = \u222b_{0}^{\u221e} (\u03ba(t)\u22121)\u00b7(dt/(1+t)).\n\nSketch proof. Sort MST edges by increasing length \u2113_1\u2264\u22ef\u2264\u2113_{n\u22121}. Then log(1+\u2113_j)=\u222b_0^{\u2113_j} dt/(1+t). Summing and swapping sum/integral gives \u222b_0^\u221e m(t) dt/(1+t) where m(t)=|{j:\u2113_j\u2265t}|. Kruskal\u2019s algorithm implies m(t)=\u03ba(t)\u22121: after inserting all edges of length \u2264t the MST forest has exactly \u03ba(t) components. (Standard; details omitted.)\n\n# A sparse subgraph that upper-bounds \u03ba(t)\n\nWork with the L\u221e norm (all norms are equivalent up to constants; see below). For t\u22650, build H(t) on {p_i=(i,\u03c0(i))} by adding, for each i\u22652, the following edges to earlier vertices only when they have L\u221e-length \u2264t:\n- Time edge: connect p_i to p_{i\u22121} if |\u03c0(i)\u2212\u03c0(i\u22121)|\u2264t.\n- Value-neighbor edge: if there exists j<i with |\u03c0(i)\u2212\u03c0(j)|=1 and i\u2212j=t_i\u2264t, connect p_i to that j.\n\nLet \u0394_i:=|\u03c0(i)\u2212\u03c0(i\u22121)| and recall t_i:=min{i\u2212j: j<i, |\u03c0(i)\u2212\u03c0(j)|=1}, or t_i=i\u22121 if no such j exists. Then, processing vertices in the order i=1,\u2026,n, the only moments when p_i could fail to attach to the existing H(t)-forest are those with both \u0394_i>t and t_i>t. Hence, with H(t) built this way,\n\n\u03ba_{H}(t) \u2264 1 + |{i\u22652: \u0394_i>t and t_i>t}|.\n\nSince H(t) is a subgraph of G(t) (it only omits edges, never adds), \u03ba(t)\u2264\u03ba_H(t). Combining with the integral lemma,\n\nMST_log(L\u221e) \u2264 \u222b_0^\u221e |{i\u22652: \u0394_i>t and t_i>t}| \u00b7 (dt/(1+t))\n= \u2211_{i=2}^n \u222b_0^{min(\u0394_i,t_i)} dt/(1+t)\n= \u2211_{i=2}^n log(1 + min(\u0394_i, t_i)).\n\nFinally, since r_i:=min(d_i+t_i, i) satisfies r_i \u2265 t_i for every i, we have min(\u0394_i, t_i) \u2264 t_i \u2264 r_i, hence\n\nMST_log(L\u221e) \u2264 \u2211_{i=2}^n log(1 + r_i) = Reg_log(\u03c0).\n\n# Norm invariance up to a universal constant\n\nFor any norm \u2016\u00b7\u2016, there exist constants a,b>0 with a\u2016\u00b7\u2016\u221e \u2264 \u2016\u00b7\u2016 \u2264 b\u2016\u00b7\u2016\u221e. For any spanning tree T,\n\n\u2211 log(1+\u2016e\u2016) \u2264 \u2211 log(1+b\u2016e\u2016\u221e) \u2264 (n\u22121)log(1+b) + \u2211 log(1+\u2016e\u2016\u221e).\n\nChoosing T to be an L\u221e-MST and using MST_log(L\u221e) \u2264 Reg_log gives\n\nMST_log(\u2016\u00b7\u2016) \u2264 (n\u22121)log(1+b) + Reg_log(\u03c0).\n\nSince Reg_log(\u03c0) \u2265 (n\u22121)log 2, we obtain a clean multiplicative bound\n\nMST_log(\u2016\u00b7\u2016) \u2264 C_1 \u00b7 Reg_log(\u03c0)\n\nfor a universal C_1 depending only on the choice of norm (e.g., C_1 = 1 + log(1+b)/log 2).\n\nConclusion (Q1): Reg dominates MST up to a universal constant. In fact, with L\u221e, MST_log \u2264 Reg_log holds pointwise.\n\n# Separation against the converse (Reg \u2270 C\u00b7MST)\n\nDefine, for a fixed constant C\u22652 and for each n, the permutation \u03c0_n that lists integers by residue classes modulo C in increasing residue order, and within each class in increasing order:\n\n\u03c0_n = (1, 1+C, 1+2C, \u2026; 2, 2+C, 2+2C, \u2026; \u2026; C, 2C, 3C, \u2026).\n\nLet m_r be the size of residue class r (m_r = \u230a(n\u2212r)/C\u230b+1). Then for all adjacent times we have |\u03c0(i)\u2212\u03c0(i\u22121)| \u2264 C, so the time-adjacent path is a spanning tree whose total MST_log cost is\n\nMST_log(\u03c0_n) \u2264 (n\u22121)\u00b7log(1+C) = \u0398(n).\n\nOn the other hand, for any r\u22652 and any k\u2264m_r, the element v=r+kC has a previous true value-neighbor v\u22121 in residue class r\u22121 at the same index k. That neighbor occurred exactly m_{r\u22121} steps earlier, so t_i = m_{r\u22121} = \u0398(n/C). Consequently r_i \u2265 t_i and\n\nReg_log(\u03c0_n) \u2265 \u2211_{r=2}^C m_r \u00b7 log(1+m_{r\u22121}) = \u0398(n log(n/C)).\n\nFor fixed C, this is \u0398(n log n). Therefore\n\nReg_log(\u03c0_n) / MST_log(\u03c0_n) \u224d log(n/C) \u2192 \u221e as n\u2192\u221e.\n\nConclusion (Q2, Q3): There is no universal C_2 with Reg_log \u2264 C_2\u00b7MST_log. We exhibit an infinite family with Reg_log/MST_log diverging like \u0398(log n).\n\n# Examples and sanity checks\n\n- Identity or reverse permutations: \u0394_i=1, t_i=1 for all i>1. Then MST_log=\u0398(n) and Reg_log=\u0398(n). The bound MST_log \u2264 Reg_log is tight up to constants.\n- Random permutation: Using the component integral and known spacing of adjacent-by-value positions, both MST_log and Reg_log are \u0398(n log n) in expectation.\n\n# Obstacles and remarks\n\n- A per-index bound of the form log(1+\u2016p_i\u2212p_j\u2016) \u2264 O(log(1+r_i)) for a fixed choice of j<i fails for small i (e.g., i=2) where log(1+\u2016p_2\u2212p_1\u2016) can be \u0398(log n) but log(1+r_2) is O(1). The integral/charging-by-scale circumvents this by aggregating over scales.\n- The domination MST_log \u2264 Reg_log is exact for L\u221e (no multiplicative loss) but requires only a constant factor for arbitrary norms because of norm equivalence inside the logarithm.\n\n# Next steps\n\n- Tight constants: For L\u221e, is MST_log = \u2211 log(1+min(\u0394_i,t_i)) always attainable (i.e., tight) or can we sharpen the upper bound? A lower bound of similar flavor might characterize MST_log up to additive O(n).\n- Refined probabilistic analysis: For random \u03c0, estimate E[MST_log] and E[Reg_log] with explicit leading constants via the integral identity and exact distribution of |pos(v)\u2212pos(v+1)|.\n- Structural characterization: Identify permutation classes where MST_log is \u0398(n) but Reg_log ranges from \u0398(n) to \u0398(n log n), beyond the residue-class example.\n"
}