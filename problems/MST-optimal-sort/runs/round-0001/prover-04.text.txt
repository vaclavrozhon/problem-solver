# Ideas

- Establish a clean separation showing MST_log does not dominate Reg_log: construct a family with MST_log = Θ(n) but Reg_log = Θ(n log n). The simplest is “parity blocks”: list all even values first (in increasing order), then all odd values (in increasing order).
- Record baseline, universally valid bounds that will be useful for both upper/lower estimates in later rounds.
- Explore whether the converse (Reg_log dominates MST_log) might plausibly hold; provide partial reductions, and outline why the straightforward strategies to refute it fail.

# Baseline facts and easy bounds

Let the metric be any fixed norm on R^2; constants below may depend on the norm.

1) Linear lower bound for MST_log on permutation grids.

Lemma 1 (MST_log ≥ c n). For any π ∈ S_n, any two distinct points p_i = (i,π(i)) and p_j = (j,π(j)) have integer coordinate differences with both coordinates nonzero; hence ‖p_i − p_j‖ ≥ √2 (e.g., in L2) and w(p_i,p_j) = log(1+‖p_i−p_j‖) ≥ log(1+√2) =: c0 > 0. Any spanning tree has n−1 edges, so
MST_log(π) ≥ (n−1) c0 = Ω(n).

2) Two canonical spanning trees upper-bounding MST_log.

- Index-path tree T_idx: connect (i−1,π(i−1)) to (i,π(i)) for i=2,…,n. Then
w(p_{i−1},p_i) ≤ log(1 + (1 + |π(i) − π(i−1)|)) ≤ log(2 + |Δπ_i|),
so
MST_log(π) ≤ ∑_{i=2}^n log(2 + |π(i) − π(i−1)|) =: W_idx(π).

- Value-path tree T_val: connect the two points whose values are consecutive in value order, i.e., (π^{-1}(v),v) to (π^{-1}(v+1),v+1) for v=1,…,n−1. Writing s_v := |π^{-1}(v+1) − π^{-1}(v)|,
MST_log(π) ≤ ∑_{v=1}^{n−1} log(2 + s_v) =: W_val(π).

Therefore MST_log(π) ≤ min{W_idx(π), W_val(π)} ≤ W_idx(π) + W_val(π).

3) Trivial bounds for Reg_log.

For every i ≥ 2: d_i ≥ 1 and t_i ≥ 1 if a neighbor exists; if not, by definition t_i = i−1. Hence r_i ≥ 2 and Reg_log(π) ≥ (n−1) log 3 = Ω(n). For random π, standard occupancy/independence heuristics give E[Reg_log] = Θ(n log n) (as noted in the task statement).

# Main separation: MST_log can be asymptotically smaller than Reg_log

Define (for even n) the “parity blocks” permutation π_even-first by
- For i=1,…,n/2: π(i) = 2i (the even values in increasing order),
- For i=n/2+1,…,n: π(i) = 2(i−n/2)−1 (the odd values in increasing order).

Claim A: MST_log(π_even-first) = Θ(n).

Proof (upper bound). Inside the even block, each index-adjacent edge has |Δπ|=2, so every such edge contributes a constant log(1+‖(1,2)‖). The same holds inside the odd block. One extra edge connects the two blocks; take, e.g., the edge between i=n/2 and i=n/2+1, whose length is ≤ n in any norm, hence weight ≤ log(1+n). Thus
MST_log(π_even-first) ≤ C·(n−2) + O(log n) = O(n).
Lower bound Ω(n) follows from Lemma 1. ∎

Claim B: Reg_log(π_even-first) = Θ(n log n).

Proof. For i=2,…,n/2 (still inside the even block): no odd number has appeared, so t_i=i−1. Also d_i=1 (the open interval between two consecutive evens contains one odd, which is not in the prefix), hence r_i=min{1+(i−1), i}=i. Contribution: ∑_{i=2}^{n/2} log(1+i) = Θ((n/2) log(n/2)).

At i=n/2+1 (first odd), π just jumped from n to 1. The open interval (1,n) contains all even values previously inserted, i.e., n/2−1 of them; so d_{n/2+1} = 1 + (n/2 − 1) = n/2. The nearest true neighbor 2 occurs at index 1, hence t_{n/2+1} = n/2. Therefore r_{n/2+1} = min{n, n/2+1} = n/2+1 and this index contributes Θ(log n).

For i ≥ n/2+2 (the remaining odds), consecutive odds differ by 2; the unique even in the open interval is always present among previous keys, so d_i = 2. The nearest true neighbor (even) lies in the first half, hence t_i = n/2 for all those i. Therefore r_i = min{2 + n/2, i} = 2 + n/2 for all but at most two indices in the odd block. Those contribute Θ((n/2) log(n/2)). Summing both blocks gives Reg_log(π_even-first) = Θ(n log n). ∎

Corollary (Separation). The ratio Reg_log(π_even-first)/MST_log(π_even-first) = Θ(log n). Hence there is no universal C_2 with Reg_log(π) ≤ C_2·MST_log(π) for all π.

A convenient generalization: partition values by congruence classes mod m, list classes in order 0,1,…,m−1, and place each class internally in increasing order. Then MST_log = Θ(n) while Reg_log = Θ(n log(n/m)); taking m=2 yields the Θ(log n) factor above.

# Examples and sanity checks

- Monotone permutations (identity or reverse): MST_log = Θ(n) via the index path with |Δπ|=1 and Reg_log = Θ(n) because r_i=2 for all i≥2.
- Random permutations: W_idx(π) = Θ(n log n) in expectation (adjacent value gaps are uniform on {1,…,n−1} up to low-order dependence), hence MST_log = O(n log n) in expectation. Meanwhile the definition in the task states Reg_log(π) = Θ(n log n) in expectation. So both measures typically match.

# Obstacles to the opposite separation (MST much larger than Reg)

A tempting attempt is to pick positions pos(k) so that consecutive-value index gaps s_k=|pos(k)−pos(k−1)| are large for many k (making the value-path tree heavy), but arrange the index-adjacent value gaps |Δπ_i| to be mostly small so that Reg stays small. This fails because:
- If one tries to keep r_i small, one needs simultaneously small d_i and small t_i at most steps. Small t_i pushes some s_k (or s_{k±1}) to be small near the index of k, thereby providing an inexpensive value edge; the MST can then take those cheap value edges, preventing a global blow-up.
- Keeping d_i small across most steps essentially forces index-adjacent values to be close within the seen set; global constructions that make the value-path heavy inevitably create many steps where the open interval between π(i−1) and π(i) already contains many previously inserted keys, pushing d_i up and hence r_i up.

We therefore found no family with MST_log/Reg_log → ∞; producing one would require making both index-path and value-path trees heavy while keeping almost all r_i = O(1), which appears mutually incompatible.

# Tentative direction toward “Reg dominates MST”

Conjecture. There exists a universal C_1 > 0 such that for all π,
MST_log(π) ≤ C_1 · Reg_log(π).

Partial evidence and plan:
- MST_log ≤ min{W_idx, W_val}. Proving W_idx + W_val ≤ O(Reg_log) would imply the conjecture. A purely local per-i comparison fails (individual heavy index jumps can sit next to small r_i), so a charging scheme must amortize an index jump to nearby indices where r is large (e.g., to i+1, where d_{i+1} accounts for the just-made jump), and similarly amortize a large s_k to the indices of values k or k+1 via their t-terms. The parity-blocks family is consistent with the conjecture (MST = Θ(n) ≪ Reg = Θ(n log n)).
- A simple, albeit weak, always-valid bound is MST_log ≤ W_val and ∑_{v} log(2 + s_v) can be charged to ∑_{i} log(2 + t_i) up to a factor that depends on how often s_v is a local peak. Bounding the total contribution of local peaks (where s_v > max{s_{v−1}, s_{v+1}}) by a constant multiple of ∑ log(1 + r_i) is the key subproblem; we did not resolve it yet.

# Next steps

- Formalize and prove the m-class generalization (already sketched) to supply a flexible separation family parameterized by m.
- Develop an amortized charging lemma relating W_idx + W_val to ∑ log(1 + r_i):
  • Show that a large index jump at time i forces r_{i+1} ≥ Ω(min{|Δπ_i|, i}), yielding log(1 + |Δπ_i|) ≤ O(log(1 + r_{i+1})) except for the regime |Δπ_i| ≫ i; isolate and bound that exceptional regime en masse.
  • For the value-side, control the contribution of local peaks of the sequence s_2,…,s_n by neighboring t-terms; attempt a “peak-to-valley” charging with geometric decay.
- Try to construct, or rule out, families with MST_log/Reg_log → ∞. Current heuristics suggest incompatibility but a proof remains open.

# Proven results to record

- Lemma 1 (MST_log ≥ c n): universal linear lower bound.
- MST_log(π) ≤ W_idx(π) and ≤ W_val(π) (two explicit spanning-tree upper bounds).
- Separation Theorem: The parity-block permutations satisfy MST_log(π) = Θ(n) and Reg_log(π) = Θ(n log n), so Reg_log does not admit an O(1) upper bound by MST_log.
- Generalized separation (sketch): For m congruence classes listed class-by-class, MST_log = Θ(n) while Reg_log = Θ(n log(n/m)).