{
  "content": "# Ideas\n\n- Prove a tight (up to \u0398(log n)) upper bound: for all \u03c0 and any norm, Reg_log(\u03c0) \u2264 O(log n)\u00b7MST_log(\u03c0). This matches the \u0398(log n) lower bound already exhibited by parity/mod-m families, completing the frontier.\n- Give a clean, fully rigorous proof of the one-sided domination via the component-integral identity, clarifying the key inequality min(\u0394_i,t_i) \u2264 r_i.\n- Add a per-scale counting lemma relating #{i: r_i>t} to two simple threshold graphs (time edges and value-neighbor edges). Though coarse, it provides an auditable handle that integrates to O(log n)\u00b7MST via the trivial MST \u2265 \u03a9(n) lower bound.\n\n# Rigorous statements and proofs\n\nNotation: Work with L\u221e for concreteness; all norms are equivalent up to constants. Let \u0394_i := |\u03c0(i)\u2212\u03c0(i\u22121)| for i\u22652.\n\nLemma 1 (Kruskal\u2013integral identity). For L\u221e, with w(e)=log(1+\u2225e\u2225\u221e),\n\nMST_log(\u03c0) = \u222b_0^\u221e (\u03ba_G(t)\u22121) d ln(1+t),\n\nwhere \u03ba_G(t) is the number of connected components of the threshold graph G(t) on P_\u03c0 having edges between pairs at L\u221e-distance \u2264 t.\n\nProof sketch. Standard: Kruskal\u2019s algorithm picks edges in increasing threshold order; for any increasing weight f(d) with f\u2032 well-defined and monotone, the MST weight equals \u222b (\u03ba(t)\u22121)f\u2032(t)dt. Here f(d)=log(1+d), f\u2032(t)=1/(1+t).\n\nLemma 2 (Reg dominates MST for L\u221e). For all \u03c0,\n\nMST_log(\u03c0) \u2264 \u2211_{i=2}^n log(1+min{\u0394_i,t_i}) \u2264 \u2211_{i=2}^n log(1+r_i) = Reg_log(\u03c0).\n\nProof. Consider the sparse subgraph H(t): for each i\u22652, add the time edge (i\u22121,i) if \u0394_i\u2264t and add the edge (j,i) to the most recent earlier value-neighbor if t_i\u2264t. Then H(t)\u2286G(t), so \u03ba_G(t)\u2264\u03ba_H(t). Sequentially, a new component is created at step i only if both edges are absent, i.e., \u0394_i>t and t_i>t; hence \u03ba_H(t)\u22641+|{i:\u0394_i>t and t_i>t}|. Integrating by Lemma 1 yields MST_log(\u03c0) \u2264 \u2211 log(1+min{\u0394_i,t_i}). Finally, for each i, min{\u0394_i,t_i} \u2264 min{d_i+t_i,i}=r_i: if t_i\u2264\u0394_i then min= t_i \u2264 r_i; if \u0394_i\u2264t_i then min=\u0394_i\u2264i\u22121<i so again \u2264 r_i. This gives the second inequality.\n\nLemma 3 (Universal O(log n) upper bound). For any norm and any \u03c0\u2208S_n,\n\nReg_log(\u03c0) \u2264 (log(1+n)/log 2) \u00b7 MST_log(\u03c0).\n\nProof. Trivially, r_i\u2264i, so Reg_log(\u03c0)=\u2211_{i=2}^n log(1+r_i) \u2264 \u2211_{i=2}^n log(1+i) \u2264 (n\u22121)\u00b7log(1+n). On the other hand, for any norm and any two distinct points in P_\u03c0, the distance is \u22651, hence each MST edge has weight at least log(1+1)=log 2; therefore MST_log(\u03c0) \u2265 (n\u22121)\u00b7log 2. Dividing gives Reg_log(\u03c0)/MST_log(\u03c0) \u2264 log(1+n)/log 2.\n\nThis matches (up to constants) the previously exhibited lower bound Reg_log/MST_log = \u0398(log n) for parity/mod-m families, so sup_\u03c0 Reg_log/MST_log is \u0398(log n).\n\nLemma 4 (Per-scale counting). For t\u22651, define\n- \u03ba_time(t): #components in the path on indices {1,\u2026,n} keeping only the time edges (i\u22121,i) with \u0394_i\u2264t.\n- \u03ba_val(t): #components in the \u201cvalue-chain\u201d graph on {p_{i}} keeping only edges between consecutive values {v,v+1} when their index gap s_v:=|i_{v+1}\u2212i_v|\u2264t.\nThen for all t\u22651,\n\n|{i\u22652: r_i>t}| \u2264 \u03ba_time(t/2)+\u03ba_val(t/2)\u22122.\n\nProof. If r_i>t, then d_i+t_i>t and i>t. Because d_i\u2264\u0394_i+1, we must have \u0394_i>t/2 or t_i>t/2 (else d_i+t_i\u2264\u0394_i+t_i\u2264t). If \u0394_i>t/2, then the time edge at i is absent at threshold t/2, which contributes one to \u03ba_time(t/2)\u22121 when scanning indices left-to-right. If instead t_i>t/2 (including \u201cno earlier value neighbor\u201d), then the oriented value-neighbor edge that would connect i to the most recent earlier neighbor is absent; this event contributes one to \u03ba_val(t/2)\u22121 when growing the value-chain graph by increasing i (these edges never merge older components, so missing-edge counts equal component increments). Summing the two possibilities yields the bound.\n\nRemark. Integrating the dyadic version of Lemma 4 gives Reg_log bounded by a weighted sum of \u03ba_time and \u03ba_val across scales. Using \u03ba_time,\u03ba_val\u2264n and O(log n) dyadic scales re-derives Lemma 3 via MST_log\u2265(n\u22121)log 2.\n\n# Examples\n\nParity interleaving (even/odd blocks): for even n, \u03c0(2m\u22121)=m and \u03c0(2m)=n/2+m.\n- MST_log (L\u221e): Connect the even subsequence by (2-step in index, \u00b11 in value) edges and the odd subsequence similarly; add one bridge between them. Total weight \u2264 (n\u22122)\u00b7log 3 + log(1+n/2)=\u0398(n).\n- Reg_log: For i=2m\u22121\u22653, d_{2m\u22121}=m\u22121, t_{2m\u22121}=2 \u21d2 r_{2m\u22121}=m+1. For i=2m\u22652, d_{2m}=m, t_{2m}=2 \u21d2 r_{2m}=m+2. Hence Reg_log=\u2211_{m=1}^{n/2}[log(2+m)+log(3+m)]=\u0398(n log n).\nThus Reg_log/MST_log=\u0398(log n), matching the upper bound in Lemma 3.\n\n# Obstacles\n\n- A constant-factor reverse domination is impossible (parity/mod-m). Any refinement seeking Reg_log \u2264 c\u00b7MST_log must fail; Lemma 3\u2019s O(log n) factor is tight up to constants.\n- Turning Lemma 4 into a per-scale bound directly in terms of \u03ba_G(t) (not \u03ba_time,\u03ba_val) appears delicate: H(t)\u2286G(t), so \u03ba_G can be much smaller than either \u03ba_time or \u03ba_val.\n\n# Next steps\n\n- Tighten the constants in Lemma 3 (track exact log bases and minimal interpoint distance under arbitrary norms).\n- Quantify the exact leading constant in the \u0398(log n) separation for mod-m constructions by computing MST_log and Reg_log to first order.\n- Explore refined per-scale inequalities that interpolate between \u03ba_time, \u03ba_val, and \u03ba_G, possibly yielding Reg_log \u2264 (C+o(1))\u00b7log n \u00b7 MST_log with an explicit small C.\n- Extend the domination Lemma 2 to other concave weights w(d) (e.g., log^\u03b1(1+d)), to see for which exponents \u03b1 the same \u0398(log n) frontier persists."
}