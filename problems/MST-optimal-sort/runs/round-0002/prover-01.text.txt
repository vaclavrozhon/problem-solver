# Ideas

- Prove a tight (up to Θ(log n)) upper bound: for all π and any norm, Reg_log(π) ≤ O(log n)·MST_log(π). This matches the Θ(log n) lower bound already exhibited by parity/mod-m families, completing the frontier.
- Give a clean, fully rigorous proof of the one-sided domination via the component-integral identity, clarifying the key inequality min(Δ_i,t_i) ≤ r_i.
- Add a per-scale counting lemma relating #{i: r_i>t} to two simple threshold graphs (time edges and value-neighbor edges). Though coarse, it provides an auditable handle that integrates to O(log n)·MST via the trivial MST ≥ Ω(n) lower bound.

# Rigorous statements and proofs

Notation: Work with L∞ for concreteness; all norms are equivalent up to constants. Let Δ_i := |π(i)−π(i−1)| for i≥2.

Lemma 1 (Kruskal–integral identity). For L∞, with w(e)=log(1+∥e∥∞),

MST_log(π) = ∫_0^∞ (κ_G(t)−1) d ln(1+t),

where κ_G(t) is the number of connected components of the threshold graph G(t) on P_π having edges between pairs at L∞-distance ≤ t.

Proof sketch. Standard: Kruskal’s algorithm picks edges in increasing threshold order; for any increasing weight f(d) with f′ well-defined and monotone, the MST weight equals ∫ (κ(t)−1)f′(t)dt. Here f(d)=log(1+d), f′(t)=1/(1+t).

Lemma 2 (Reg dominates MST for L∞). For all π,

MST_log(π) ≤ ∑_{i=2}^n log(1+min{Δ_i,t_i}) ≤ ∑_{i=2}^n log(1+r_i) = Reg_log(π).

Proof. Consider the sparse subgraph H(t): for each i≥2, add the time edge (i−1,i) if Δ_i≤t and add the edge (j,i) to the most recent earlier value-neighbor if t_i≤t. Then H(t)⊆G(t), so κ_G(t)≤κ_H(t). Sequentially, a new component is created at step i only if both edges are absent, i.e., Δ_i>t and t_i>t; hence κ_H(t)≤1+|{i:Δ_i>t and t_i>t}|. Integrating by Lemma 1 yields MST_log(π) ≤ ∑ log(1+min{Δ_i,t_i}). Finally, for each i, min{Δ_i,t_i} ≤ min{d_i+t_i,i}=r_i: if t_i≤Δ_i then min= t_i ≤ r_i; if Δ_i≤t_i then min=Δ_i≤i−1<i so again ≤ r_i. This gives the second inequality.

Lemma 3 (Universal O(log n) upper bound). For any norm and any π∈S_n,

Reg_log(π) ≤ (log(1+n)/log 2) · MST_log(π).

Proof. Trivially, r_i≤i, so Reg_log(π)=∑_{i=2}^n log(1+r_i) ≤ ∑_{i=2}^n log(1+i) ≤ (n−1)·log(1+n). On the other hand, for any norm and any two distinct points in P_π, the distance is ≥1, hence each MST edge has weight at least log(1+1)=log 2; therefore MST_log(π) ≥ (n−1)·log 2. Dividing gives Reg_log(π)/MST_log(π) ≤ log(1+n)/log 2.

This matches (up to constants) the previously exhibited lower bound Reg_log/MST_log = Θ(log n) for parity/mod-m families, so sup_π Reg_log/MST_log is Θ(log n).

Lemma 4 (Per-scale counting). For t≥1, define
- κ_time(t): #components in the path on indices {1,…,n} keeping only the time edges (i−1,i) with Δ_i≤t.
- κ_val(t): #components in the “value-chain” graph on {p_{i}} keeping only edges between consecutive values {v,v+1} when their index gap s_v:=|i_{v+1}−i_v|≤t.
Then for all t≥1,

|{i≥2: r_i>t}| ≤ κ_time(t/2)+κ_val(t/2)−2.

Proof. If r_i>t, then d_i+t_i>t and i>t. Because d_i≤Δ_i+1, we must have Δ_i>t/2 or t_i>t/2 (else d_i+t_i≤Δ_i+t_i≤t). If Δ_i>t/2, then the time edge at i is absent at threshold t/2, which contributes one to κ_time(t/2)−1 when scanning indices left-to-right. If instead t_i>t/2 (including “no earlier value neighbor”), then the oriented value-neighbor edge that would connect i to the most recent earlier neighbor is absent; this event contributes one to κ_val(t/2)−1 when growing the value-chain graph by increasing i (these edges never merge older components, so missing-edge counts equal component increments). Summing the two possibilities yields the bound.

Remark. Integrating the dyadic version of Lemma 4 gives Reg_log bounded by a weighted sum of κ_time and κ_val across scales. Using κ_time,κ_val≤n and O(log n) dyadic scales re-derives Lemma 3 via MST_log≥(n−1)log 2.

# Examples

Parity interleaving (even/odd blocks): for even n, π(2m−1)=m and π(2m)=n/2+m.
- MST_log (L∞): Connect the even subsequence by (2-step in index, ±1 in value) edges and the odd subsequence similarly; add one bridge between them. Total weight ≤ (n−2)·log 3 + log(1+n/2)=Θ(n).
- Reg_log: For i=2m−1≥3, d_{2m−1}=m−1, t_{2m−1}=2 ⇒ r_{2m−1}=m+1. For i=2m≥2, d_{2m}=m, t_{2m}=2 ⇒ r_{2m}=m+2. Hence Reg_log=∑_{m=1}^{n/2}[log(2+m)+log(3+m)]=Θ(n log n).
Thus Reg_log/MST_log=Θ(log n), matching the upper bound in Lemma 3.

# Obstacles

- A constant-factor reverse domination is impossible (parity/mod-m). Any refinement seeking Reg_log ≤ c·MST_log must fail; Lemma 3’s O(log n) factor is tight up to constants.
- Turning Lemma 4 into a per-scale bound directly in terms of κ_G(t) (not κ_time,κ_val) appears delicate: H(t)⊆G(t), so κ_G can be much smaller than either κ_time or κ_val.

# Next steps

- Tighten the constants in Lemma 3 (track exact log bases and minimal interpoint distance under arbitrary norms).
- Quantify the exact leading constant in the Θ(log n) separation for mod-m constructions by computing MST_log and Reg_log to first order.
- Explore refined per-scale inequalities that interpolate between κ_time, κ_val, and κ_G, possibly yielding Reg_log ≤ (C+o(1))·log n · MST_log with an explicit small C.
- Extend the domination Lemma 2 to other concave weights w(d) (e.g., log^α(1+d)), to see for which exponents α the same Θ(log n) frontier persists.