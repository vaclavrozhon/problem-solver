{
  "content": "# Goal of this round\n\n- Provide rigorous, auditable proofs of the two key comparisons now on record:\n  1) MST_log \u2264 Reg_log (exact for L\u221e; constant-factor for any fixed norm).\n  2) Reg_log \u2264 \u0398(log n)\u00b7MST_log for every permutation and any fixed norm, with explicit constants.\n- Give a complete, detailed separation proof via mod-m blocks, showing \u0398(log n) tightness.\n- Record explicit constants for L1/L2/L\u221e and a quick expectation check for random permutations.\n\n\n## Preliminaries\n\n- Points: p_i=(i,\u03c0(i)), i=1,\u2026,n.\n- Distances by L\u221e unless noted; b_N>0 with ||z||_N \u2264 b_N||z||_\u221e, and \u03b1_N>0 with ||z||_N \u2265 \u03b1_N||z||_\u221e (norm equivalence).\n- \u0394_i := |\u03c0(i)\u2212\u03c0(i\u22121)| (i\u22652). For consecutive values v, s_v := |\u03c0^{-1}(v+1)\u2212\u03c0^{-1}(v)|.\n- t_i as in task; d_i \u2265 1; r_i = min{d_i + t_i, i}. Useful inequality: r_i \u2265 t_i + 1.\n\n\n## A. MST_log \u2264 Reg_log (L\u221e exact)\n\nWe use Kruskal\u2019s integral identity: for the threshold graph G\u221e(t) on P_\u03c0 connecting pairs with L\u221e-distance \u2264 t, letting \u03ba(t) be its number of components,\n  MST_log^\u221e(\u03c0) = \u222b_0^\u221e (\u03ba(t) \u2212 1) d log(1+t).\n\nConstruct a sparse subgraph H(t) on the same vertices by adding edges as we sweep i=2,\u2026,n:\n- Time edge: add (i\u22121,i) if \u0394_i \u2264 t.\n- Value-neighbor edge: if t_i \u2264 t, let j<i be the latest index with |\u03c0(i)\u2212\u03c0(j)|=1 and add (i,j).\nBoth edges are valid in G\u221e(t): for time edges, ||p_{i}\u2212p_{i\u22121}||_\u221e = max{1,\u0394_i} \u2264 t; for value edges, ||p_i\u2212p_j||_\u221e = max{t_i,1} \u2264 t.\n\nClaim A.1. \u03ba_G\u221e(t) \u2264 \u03ba_H(t) \u2264 1 + |{i\u22652: \u0394_i>t and t_i>t}|.\n\nProof. The first inequality is clear since H(t)\u2286G\u221e(t) in edges. For the second, expose edges in H(t) in increasing i and maintain the number of components of the graph H_i(t) induced by indices {1,\u2026,i}.\n- If \u0394_i \u2264 t, the time edge (i\u22121,i) merges the two adjacent time-blocks; this reduces the component count by 1 relative to splitting at i.\n- If \u0394_i > t and t_i \u2264 t, the value edge (i,j) crosses the cut at i (since j<i), and because no value edges anchored at indices >i have been added yet, the left-of-i and right-of-i parts are not connected at this moment; hence (i,j) reduces the component count by 1.\nThus, starting from 1 + |{k\u2264i: \u0394_k>t}| components after time edges, each i with \u0394_i>t and t_i\u2264t eliminates one. After processing all i, we get \u03ba_H(t) \u2264 1 + |{i\u22652: \u0394_i>t and t_i>t}|. \u220e\n\nIntegrating via the identity and the indicator calculus gives\n  MST_log^\u221e(\u03c0) = \u222b_0^\u221e (\u03ba_G\u221e(t) \u2212 1) d log(1+t) \u2264 \u222b_0^\u221e |{i: \u0394_i>t, t_i>t}| d log(1+t)\n  = \u2211_{i=2}^n \u222b_0^{min(\u0394_i,t_i)} d log(1+t)\n  = \u2211_{i=2}^n log(1 + min{\u0394_i,t_i})\n  \u2264 \u2211_{i=2}^n log(1 + t_i) \u2264 \u2211_{i=2}^n log(1 + r_i) = Reg_log(\u03c0).\nThis proves MST_log^\u221e(\u03c0) \u2264 Reg_log(\u03c0).\n\n\n## B. Lifting to any fixed norm N\n\nLet b_N = sup_{||z||\u221e=1} ||z||_N (<\u221e) and pick any L\u221e-MST T. Then for each edge e,\n  log(1+||e||_N) \u2264 log(1 + b_N||e||_\u221e) \u2264 log(1+b_N) + log(1+||e||_\u221e).\nSumming over the n\u22121 edges of T:\n  MST_log^N(\u03c0) \u2264 (n\u22121)\u00b7log(1+b_N) + MST_log^\u221e(\u03c0) \u2264 (n\u22121)\u00b7log(1+b_N) + Reg_log(\u03c0).\nSince Reg_log(\u03c0) \u2265 (n\u22121)\u00b7log 3 (because r_i \u2265 2), we obtain\n  MST_log^N(\u03c0) \u2264 (1 + log(1+b_N)/log 3) \u00b7 Reg_log(\u03c0).\nExplicit constants:\n- L\u221e: b_\u221e=1 \u2192 factor = 1 (exact domination).\n- L2: b_2=\u221a2 \u2192 factor = 1 + log(1+\u221a2)/log 3 \u2248 1.803.\n- L1: b_1=2 \u2192 factor = 1 + log 3/log 3 = 2.\n\n\n## C. Universal logarithmic upper bound: Reg_log \u2264 \u0398(log n)\u00b7MST_log\n\nWe need a norm-dependent per-edge lower bound. In a permutation grid, for any i\u2260j, both coordinates differ by at least 1; hence\n- L\u221e: ||p_i\u2212p_j||_\u221e \u2265 1 \u2192 weight \u2265 log 2.\n- L2: ||p_i\u2212p_j||_2 \u2265 \u221a2 \u2192 weight \u2265 log(1+\u221a2).\n- L1: ||p_i\u2212p_j||_1 \u2265 2 \u2192 weight \u2265 log 3.\nMore generally, any norm N obeys ||z||_N \u2265 \u03b1_N||z||_\u221e with \u03b1_N>0, so every MST edge weighs \u2265 c_N := log(1+\u03b1_N).\nThus MST_log^N(\u03c0) \u2265 (n\u22121)\u00b7c_N. Also r_i \u2264 i implies\n  Reg_log(\u03c0) = \u2211_{i=2}^n log(1+r_i) \u2264 \u2211_{i=2}^n log(1+i) \u2264 (n\u22121)\u00b7log(1+n).\nConsequently,\n  Reg_log(\u03c0) \u2264 (log(1+n)/c_N) \u00b7 MST_log^N(\u03c0).\nIn particular, L\u221e: c_\u221e=log 2; L2: c_2=log(1+\u221a2); L1: c_1=log 3.\nThis yields the universal Reg \u2264 \u0398(log n)\u00b7MST bound, tight up to constants (see D).\n\n\n## D. Separation family (\u0398(log n) tightness)\n\nParity blocks (even n): \u03c0(i)=2i for i\u2264n/2, and \u03c0(i)=2(i\u2212n/2)\u22121 for i>n/2.\n\n- MST_log^N(\u03c0) = \u0398(n) for any fixed norm N. Upper bound: span each half by time edges (each has constant weight) and add one bridge between the halves of cost O(log n). Lower bound: (n\u22121)\u00b7c_N by Part C.\n- Reg_log(\u03c0) = \u0398(n log n).\n  \u2022 For i=2,\u2026,n/2: no odd seen. d_i=1, t_i=i\u22121, so r_i=i and contribution is \u0398((n/2)\u00b7log n).\n  \u2022 At i=n/2+1: d_i\u2248n/2, t_i=n/2, so r_i=\u0398(n) adds \u0398(log n).\n  \u2022 For the remaining odds: each has t_i=n/2 (nearest even is in the first half) and d_i=2, hence r_i=\u0398(n), contributing \u0398(log n) per index. Summing gives \u0398(n log n).\nTherefore Reg_log/MST_log = \u0398(log n). No constant C can satisfy Reg_log \u2264 C\u00b7MST_log universally.\n\nMod-m generalization (n arbitrary). Partition values by residues r mod m, list the classes r=0,1,\u2026,m\u22121, each internally increasing. Let m_r be class sizes (\u03a3 m_r=n). MST_log=\u0398(n): span each class by time edges (constant cost per edge) and connect the m classes with O(m) bridges of cost O(log n) each. For Reg: the first class contributes \u0398(m_0 log m_0) and for r\u22651, each element\u2019s t equals m_{r\u22121} (its earlier neighbor v\u22121 appears in the previous class), with d_i \u2265 1. Hence each such element contributes \u03a9(log(1+m_{r\u22121})), giving\n  Reg_log \u2265 \u2211_{r=1}^{m\u22121} m_r\u00b7log(1+m_{r\u22121}) = \u0398(n\u00b7log(n/m)) when m is constant.\nTaking m=2 yields the parity \u0398(log n) ratio.\n\n\n## E. Random permutations (sanity check)\n\nFor random \u03c0, \u0394_i has P(\u0394=k)=2(n\u2212k)/(n(n\u22121)) for k=1,\u2026,n\u22121. Thus\n  E[log(1+\u0394_i)] = (2/(n(n\u22121)))\u2211_{k=1}^{n\u22121}(n\u2212k)log(1+k)\n                 = log n + O(1).\nHence E[\u2211_{i=2}^n log(2+\u0394_i)] = \u0398(n log n). Using MST_log^\u221e \u2264 \u2211 log(2+min{\u0394_i,t_i}) \u2264 \u2211 log(2+\u0394_i) shows E[MST_log]=O(n log n). Meanwhile Reg_log=\u0398(n log n) in expectation (by the task\u2019s note), so the two measures typically match in order.\n\n\n## Remarks on subtle points (addressing pitfalls)\n\n- The earlier flawed step \u201ct at the later endpoint equals the value gap s_v\u201d is incorrect: the most recent earlier neighbor of value v or v+1 could be v\u00b12. Our proof avoids this by working at the component level via the threshold subgraph H(t) and integral identity.\n- In Claim A.1, the key is the left-to-right exposure of value edges: when processing i, no future value edges (anchored at indices > i) exist yet, so adding (i,j) with j<i necessarily reduces the count if \u0394_i>t; this justifies \u03ba_H(t) \u2264 1 + |{\u0394_i>t and t_i>t}|.\n\n\n## Next steps\n\n- Finalize constants per norm (we already have tight, simple choices for L1/L2/L\u221e). Minor improvements are possible by exploiting the \u201cboth coordinates differ\u201d property in general Minkowski norms that dominate L2.\n- Optional quantitative refinements: compute leading constants in E[MST_log] and E[Reg_log] for random \u03c0 using exact summations.\n- Per-scale decomposition: a dyadic \u201clayer-cake\u201d proof of Reg \u2264 O(log n)\u00b7MST via counts |{i: r_i>2^k}| versus |{i: \u0394_i>2^k and t_i>2^k}| could give alternate constants; we leave this as a future technical exercise.\n\n\n## Summary of provable statements to add to proofs.md/output.md\n\n- For L\u221e, MST_log(\u03c0) \u2264 Reg_log(\u03c0) for all \u03c0 (exact).\n- For any fixed norm N, MST_log^N(\u03c0) \u2264 (1 + log(1+b_N)/log 3)\u00b7Reg_log(\u03c0) with b_N as above.\n- For any fixed norm N, Reg_log(\u03c0) \u2264 (log(1+n)/c_N)\u00b7MST_log^N(\u03c0), with c_N = log 2 (L\u221e), log(1+\u221a2) (L2), log 3 (L1).\n- Separation: mod-m blocks (incl. parity) have MST_log = \u0398(n) and Reg_log = \u0398(n log(n/m)); choosing m=2 gives Reg_log/MST_log = \u0398(log n)."
}