# New results and refinements

## 1) Concave-weight extension of the MST bound

Statement. Let φ:[0,∞)→[0,∞) be nondecreasing and concave with φ(0)=0. Define MST_φ as the MST weight with edge-weight φ(‖·‖∞). Then for all permutations π,
\[
\mathrm{MST}_{\varphi}^{\,\infty}(\pi)\;\le\; \sum_{i=2}^n \varphi\bigl(\min\{\Delta_i, t_i\}\bigr)\;\le\; \sum_{i=2}^n \varphi(r_i).
\]

Why useful. It shows the MST≤Reg mechanism is not peculiar to the logarithm; any concave nondecreasing φ behaves similarly under L∞.

Proof. Concavity implies φ(x)=∫_0^x f(t) dt for some nonincreasing f≥0 (e.g., f is the right-derivative). Applying the Kruskal integral (Lemma 1 in the notes) with weight φ(ℓ)=∫_0^{ℓ} f(t) dt gives
∑_{e∈MST} φ(ℓ_e) = ∫_0^∞ f(t)·(κ(t)−1) dt.
With the sparse subgraph H(t) used previously (time-edge and most-recent value-neighbor edge), κ(t)−1 ≤ |{i≥2: Δ_i>t and t_i>t}|. Hence
\[\mathrm{MST}_{\varphi}^{\,\infty}(\pi)\le \int_0^{\infty} f(t)\, |\{i\ge 2: \min\{\Delta_i,t_i\}>t\}|\,dt
= \sum_{i=2}^n \int_0^{\min\{\Delta_i,t_i\}} f(t)\,dt
= \sum_{i=2}^n \varphi\bigl(\min\{\Delta_i,t_i\}\bigr).
\]
Since r_i≥t_i, the second inequality follows. ∎

Remark. Taking φ(x)=log(1+x) recovers the established bound MST_log^{∞} ≤ ∑ log(1+min{Δ_i,t_i}) ≤ Reg_log.

## 2) Sharper norm-lifting constant

Lemma. For any norm ∥·∥ on R^2, let b:=sup_{z≠0} ∥z∥/∥z∥∞ (finite by norm equivalence). Then for any π,
\[
\mathrm{MST}_{\log}^{\,\|\cdot\|}(\pi) \le \mathrm{MST}_{\log}^{\,\infty}(\pi) + (n-1)\log b \le \Bigl(1 + \tfrac{\log b}{\log 3}\Bigr)\mathrm{Reg}_{\log}(\pi).
\]

Proof. For any edge e, 1+∥e∥ ≤ b(1+∥e∥∞) (since b≥1), hence log(1+∥e∥) ≤ log b + log(1+∥e∥∞). Summing over an L∞-MST and using MST_log^{∞} ≤ Reg_log plus Reg_log ≥ (n−1) log 3 yields the claim. For L_p in R^2, b=2^{1/p}, so the factor is 1+ (log 2)/(p·log 3). ∎

## 3) Universal logarithmic upper bound Reg ≤ O(log n)·MST with explicit constants

Proposition. For any norm ∥·∥ and any π,
\[\mathrm{Reg}_{\log}(\pi) \le \frac{\log(1+n)}{\log(1+\beta)}\,\mathrm{MST}_{\log}^{\,\|\cdot\|}(\pi),\]
where \(\beta = \inf\{\| (x,y)\| : x\ge 1,\ y\ge 1\}\). In particular, for L_p: β=2^{1/p}, giving
- L∞: Reg_log ≤ [log(1+n)/log 2]·MST_log^{∞};
- L2: Reg_log ≤ [log(1+n)/log(1+√2)]·MST_log^{2};
- L1: Reg_log ≤ [log(1+n)/log 3]·MST_log^{1}.

Proof. Any two distinct permutation points differ by at least 1 in each coordinate, hence any tree edge has length ≥ β and weight ≥ log(1+β) (Lemma A in notes). Summing over n−1 edges yields MST_log ≥ (n−1) log(1+β). Also r_i ≤ i implies Reg_log ≤ ∑_{i=2}^n log(1+i) ≤ (n−1) log(1+n). Divide. ∎

Tightness. The residue-class (mod-m) family (with fixed m) attains Reg_log/MST_log ≍ log(n/m), so the Θ(log n) factor is worst-case tight.

## 4) Tunable separation by choosing m=m(n)

Proposition. Let m=m(n)∈[2,n] and define π by grouping values by residues mod m in increasing residue order, increasing within each class. Then under L∞,
- MST_log(π) = Θ(n + m log n);
- Reg_log(π) = Θ(n log(n/m)).
In particular,
\[\frac{\mathrm{Reg}_{\log}(\pi)}{\mathrm{MST}_{\log}(\pi)} \asymp \frac{n\log(n/m)}{n + m\log n}.
\]
Choosing m=n^α (0≤α≤1) yields Reg/MST ≍ (1−α)·log n for α<1 and ≍ 1 for α=1.

Proof. Spanning each residue class by time-adjacent edges contributes (n−m)·log(1+m). Connecting the m class-blocks by m−1 boundary edges costs O(m log n). Thus MST_log = Θ(n + m log n) (for fixed m, Θ(n)). For Reg, as shown earlier, each element of class r≥2 has t_i=m_{r−1}≈n/m; summing gives Θ(n log(n/m)). ∎

## 5) Small auxiliary inequalities

- For all i, r_i = min(d_i+t_i, i) ≤ (1+d_i)(1+t_i)−1, hence
\[\log(1+r_i) \le \log(1+d_i) + \log(1+t_i).\]
Useful to decompose Reg_log into a “value-gap” part and a “neighbor-lag” part.

- In L∞, the integral proof also yields the intermediate bound
\[\mathrm{MST}_{\log}^{\,\infty}(\pi) \le \sum_{i=2}^n \log(1+t_i)\quad\text{and}\quad \mathrm{MST}_{\log}^{\,\infty}(\pi) \le \sum_{i=2}^n \log(1+\Delta_i),\]
by using only value-neighbor or only time edges in H(t). These are weaker than MST_log ≤ Reg_log but can be useful for diagnostics.

# Examples

- Monotone permutations: Δ_i=1, t_i=1. Then MST_log^{∞}=(n−1) log 2, Reg_log=(n−1) log 3.
- Alternating high/low (zig-zag) patterns where Δ_i are large but t_i often small: the inequality with min{Δ_i,t_i} is critical; using only one side (Δ_i or t_i) may be loose.
- Mod-m with m=n^α tunes Reg/MST between Θ(log n) and Θ(1) as above.

# Obstacles

- Converting Reg’s union-type radius r_i=d_i+t_i into an intersection count inside the Kruskal integral seems impossible without an Ω(log n) loss (e.g., when one of d_i,t_i is small and the other is ≈i). This explains the tight Θ(log n) worst-case separation.
- Precise constants for E[MST_log] under random π require controlling E[κ(t)] for permutation threshold graphs; this appears delicate.

# Next steps

- Record and verify the concave-weight extension (Section 1) in proofs.md; it may be of independent interest.
- Sharpen constants for norm lifting (Section 2) in proofs.md, especially listing C_p = 1 + (log 2)/(p·log 3) for L_p.
- If desired, quantify constants for random π: aim to prove c_1 n log n ≤ E[MST_log^{∞}] ≤ c_2 n log n with explicit c_1,c_2 via the integral identity.
- Explore instance-sensitive upper bounds improving on Θ(log n) in structured classes (e.g., bounded number of residue blocks, bounded Δ_i, or bounded variation of π).