We can now present a complete, rigorous resolution of the three questions and have written a self-contained proof into output.md. The core engine is the Kruskal integral identity specialized to log(1+distance), coupled with a sparse threshold subgraph H(t) that only uses two local edge types: (i) time-adjacent (i−1,i) when Δ_i≤t, and (ii) the most recent value-neighbor when t_i≤t. This yields, in L∞, MST_log ≤ ∑ log(1+min{Δ_i,t_i}) ≤ Reg_log, with a fully justified component-count bound κ_G(t) ≤ 1 + |{i≥2: Δ_i>t and t_i>t}|. Lifting to any norm uses the refined inequality 1+||e|| ≤ b(1+||e||∞) and Reg_log ≥ (n−1)log 3, giving MST_log^||·|| ≤ (1 + (log b)/log 3)·Reg_log, with explicit constants for L_p (C_p = 1 + (log 2)/(p·log 3)).

For the reverse direction, we provide a tight family (parity blocks) with MST_log = Θ(n) and Reg_log = Θ(n log n), hence no constant-factor domination of Reg by MST. We also show the universal upper bound Reg_log ≤ (log(1+n)/c_N)·MST_log^N via the minimal per-edge weight of any spanning tree in a permutation grid (explicit constants for L∞/L2/L1). Thus the worst-case multiplicative gap is Θ(log n), and this is optimal.

Auditing details: (i) The earlier flawed identification t_{i*}=s_v is no longer used. (ii) The component integral and H(t) construction are sound; the counting argument is correctly phrased so that components can only increase when both local edges are absent. (iii) The norm-lift constant is sharpened to log b (not log(1+b)), and Reg_log ≥ (n−1)log 3 is used to absorb the additive term. (iv) The separation proof computes r_i and the MST tree cost explicitly and is correct for any fixed norm.

Next steps (optional): quantify leading constants in E[MST_log] and E[Reg_log] under random π; and explore instance-sensitive bounds beyond the Θ(log n) worst-case (e.g., mod-m structure).