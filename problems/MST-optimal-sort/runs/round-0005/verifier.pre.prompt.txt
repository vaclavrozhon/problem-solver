=== SYSTEM ===
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md, proofs.md, and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (informal progress & exploratory work so far)
- proofs.md (rigorous proofs & detailed mathematics so far)
- output.md (main results summary so far)

**Three-tier file system guidelines**:
- **notes.md**: Readable running log of exploratory work, intuitions, failed attempts, ideas. Prefer appending. Replace only if old notes are clearly misleading. Should be self-contained.
- **proofs.md**: Complete rigorous mathematical proofs with full details. Think twice before adding anything. Contains proven lemmas, theorems, and detailed derivations. Only add mathematically verified content here.
- **output.md**: This is the only file that the user is supposed to read. It has to be self-contained. It should contain ONLY the main problem results, and a discussion why they are relevant. It is extremely selective. Think twice before promoting proofs from proofs.md to output.md. Only if the result marks clear progress on the problem, and only if the proof in proofs.md has been thoroughly vetted by provers and you, it can join output.md. Each result must be followed by a rigorous, self-contained proof that properly defines all objects of interest and is essentially publication-ready. 

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (≥200 words). Include concrete next-step suggestions.",
  "summary_md": "Concise summary of this round's work for summarizer.",
  "verdict": "promising|uncertain|unlikely",
  "blocking_issues": ["List of issues preventing progress"],
  "per_prover": [{"prover_id": "01", "brief_feedback": "feedback", "score": "promising|uncertain|unlikely"}],
  "notes_update": {"action": "append|replace", "content": "Markdown for notes.md"},
  "proofs_update": {"action": "append|replace", "content": "Markdown for proofs.md"}, 
  "output_update": {"action": "append|replace", "content": "Markdown for output.md"}
}

**Verdict definitions**:
- **promising**: Significant mathematical progress, publishable results, or clear path to solution
- **uncertain**: Some progress but with unresolved issues or incomplete reasoning  
- **unlikely**: No meaningful progress, fundamentally flawed approaches, or just exploratory work

**Update guidelines**:
- Use null for any update field you don't want to modify
- notes_update: Include informal reasoning, failed attempts, intuitions, exploratory work
- proofs_update: Only include complete, rigorous proofs that you have verified
- output_update: Only include main problem results that directly advance toward the solution


### User's Request
It seems you claim to have resolved the question. in that case, write the proof to the output.md file. Remember, it has to be rigorous and self-contained.


=== USER ===
=== Task (txt) ===

# Problem: Asymptotic Dominance Between an MST–Log Distance Measure and **Reg**

Let \(n \in \mathbb{N}\) and let \(\pi \in S_n\) be a permutation. Represent the input as
\[
P_\pi = \{\,p_i = (i,\pi(i)) : i=1,\dots,n\,\}\subset \{1,\dots,n\}^2 .
\]

Fix any norm \(\|\cdot\|\) on \(\mathbb{R}^2\) (e.g., \(L_1, L_2,\) or \(L_\infty\)). All choices are equivalent up to constant factors, so asymptotic comparisons are norm-invariant.

---

## Measure 1: \(\mathrm{MST}_{\log}(\pi)\)

Define edge weights between points \(p_i,p_j\) by  
\[
w(p_i,p_j)=\log\!\bigl(1+\|p_i-p_j\|\bigr),
\]  
where the logarithm base is fixed but arbitrary.

Let \(T\) be a minimum spanning tree of the complete graph on \(P_\pi\) with weights \(w\). Set  
\[
\boxed{\mathrm{MST}_{\log}(\pi)=\sum_{e\in E(T)} w(e).}
\]

---

## Measure 2: \(\mathrm{Reg}_{\log}(\pi)\)

For \(i \ge 2\), let

* **Value-distance from the previous key**  
  \[
  d_i = 1 + \#\{\,k < i : \min(\pi(i-1),\pi(i)) < \pi(k) < \max(\pi(i-1),\pi(i))\,\}.
  \]

* **Temporal distance to the most recent true neighbor in value order**  
  \[
  t_i = \min\{\, i-j : 1 \le j < i,\; |\pi(i)-\pi(j)| = 1 \,\},
  \]  
  with \(t_i = i-1\) if no such \(j\) exists.

* **Regional radius**  
  \[
  r_i = \min\{\, d_i + t_i,\; i \,\}.
  \]

Define the logged regional cost  
\[
\boxed{\mathrm{Reg}_{\log}(\pi) = \sum_{i=2}^n \log(1 + r_i).}
\]

Using \(\log(1+r_i)\) (rather than \(r_i-1\)) ensures that a **random permutation** has  
\[
\mathrm{Reg}_{\log}(\pi) = \Theta(n \log n),
\]  
matching the \(\Theta(n \log n)\) comparisons needed for typical sorting.  
Without the logarithm, \(\sum (r_i-1)\) for a random permutation is \(\Theta(n^2)\), which is too large compared to standard sorting bounds.

---

## Asymptotic Dominance Questions

> **Problem.** For permutations \(\pi \in S_n\), compare \(\mathrm{MST}_{\log}(\pi)\) and \(\mathrm{Reg}_{\log}(\pi)\) up to universal constant factors.
>
> 1. (**Does Reg dominate MST?**)  
>    Does there exist a constant \(C_1>0\) such that for all \(n\) and all \(\pi\),  
>    \[
>    \mathrm{MST}_{\log}(\pi) \le C_1 \cdot \mathrm{Reg}_{\log}(\pi)?
>    \]
>
> 2. (**Does MST dominate Reg?**)  
>    Does there exist a constant \(C_2>0\) such that for all \(n\) and all \(\pi\),  
>    \[
>    \mathrm{Reg}_{\log}(\pi) \le C_2 \cdot \mathrm{MST}_{\log}(\pi)?
>    \]
>
> 3. (**Separation.**)  
>    If either inequality fails, exhibit infinite families \(\{\pi_n\}\) for which the ratio  
>    \(\mathrm{MST}_{\log}(\pi_n)/\mathrm{Reg}_{\log}(\pi_n)\)  
>    or  
>    \(\mathrm{Reg}_{\log}(\pi_n)/\mathrm{MST}_{\log}(\pi_n)\)  
>    diverges as \(n \to \infty\).

**Notes.**

* The choice of norm and log base only rescales values by constants.  
* Using \(\log(1+r_i)\) aligns \(\mathrm{Reg}_{\log}\) with classical adaptive-sorting analyses where a random permutation costs \(\Theta(n\log n)\).  
* One may also consider variants such as asking whether  
  \[
  C^{-1}\mathrm{Reg}_{\log}(\pi)\le \mathrm{MST}_{\log}(\pi)\le C\,\mathrm{Reg}_{\log}(\pi)
  \]  
  holds for some universal \(C\).



=== Notes ===

# Research Notes



Summary of current understanding

- Definitions: P_π = {(i, π(i))}, MST_log uses weights w(u,v)=log(1+||u−v||). Reg_log(π)=∑_{i=2}^n log(1+r_i) with r_i=min(d_i+t_i, i), d_i counts prior values between π(i−1) and π(i), and t_i is the temporal distance to the most recent earlier value-neighbor (|Δ value|=1), defaulting to i−1 if none exists.

- One-sided domination (L∞): Using Kruskal’s integral identity, ∑_{e∈MST} log(1+ℓ_e) = ∫_0^∞ (κ(t)−1) dt/(1+t), where κ(t) is the number of components in the threshold graph with edges of L∞-length ≤ t. Build a sparse subgraph H(t): when processing p_i, add the time edge (i−1,i) if |π(i)−π(i−1)|≤t, and the value-neighbor edge to the most recent earlier neighbor if t_i≤t. Then κ_G(t) ≤ κ_H(t) ≤ 1 + |{i≥2: Δ_i>t and t_i>t}|. Integrating yields MST_log(L∞) ≤ ∑ log(1+min(Δ_i,t_i)) ≤ ∑ log(1+r_i) = Reg_log.

- Norm invariance: For any norm ||·|| with ||z|| ≤ b||z||∞, choose an L∞-MST T∞ and obtain MST_log(||·||) ≤ (n−1)log(1+b) + MST_log(L∞) ≤ (1 + log(1+b)/log 3)·Reg_log, since Reg_log ≥ (n−1)log 3.

- Separation (no reverse domination): Order values by residue classes mod m, listing each class block in increasing order. For fixed m, we can span each block by index-adjacent edges (each costs log(1+m) under L∞), and connect the blocks with O(m) bridges (each costs O(log n)). Hence MST_log = Θ(n). Meanwhile, for any r≥2 and any element v=r+k m of class r, the earlier neighbor v−1 lies in class r−1 exactly m_{r−1} positions earlier, so t_i = m_{r−1} = Θ(n/m); therefore Reg_log ≥ ∑_{r=2}^m m_r log(1+m_{r−1}) = Θ(n log(n/m)). For m constant (e.g., parity), Reg_log/MST_log = Θ(log n).

- Remarks: A previously attempted charge (linking the value-adjacency path edge length directly to t_i at the later endpoint) is invalid in general (the closest earlier neighbor might be v±2). The component-integral method avoids this pitfall.

Open directions

- Likely tight frontier: prove a universal upper bound Reg_log(π) ≤ O(log n)·MST_log(π) for all π, matching the Θ(log n) lower bound from mod-m families.
- Tighten constants in the domination for specific norms; compute best b for L1 and L2.
- Quantify leading constants for E[MST_log], E[Reg_log] under random π.


Addition: universal logarithmic upper bound

- Minimal MST edge weight: For any fixed norm N on R^2, there exists α_N>0 such that ||z||_N ≥ α_N||z||_∞ for all z. Since any two distinct points p_i=(i,π(i)), p_j differ by at least 1 in each coordinate, ||p_i−p_j||_∞ ≥ 1, hence ||p_i−p_j||_N ≥ α_N. Therefore every tree edge has weight ≥ log(1+α_N), so MST_log^N(π) ≥ (n−1)·log(1+α_N).
- Trivial Reg upper bound: r_i ≤ i implies Reg_log(π) ≤ ∑_{i=2}^n log(1+i) ≤ (n−1)·log(1+n).
- Combining: Reg_log(π) ≤ (log(1+n)/log(1+α_N)) · MST_log^N(π) for all π. In particular: L∞ gives factor log(1+n)/log 2; for L2, one may sharpen c_N using ||(1,1)||_2=√2 (so each edge has weight ≥ log(1+√2)); for L1 similarly ||(1,1)||_1=2.

Thus, universally Reg_log ≤ Θ(log n)·MST_log, matching the Θ(log n) lower bound from parity/mod-m constructions. This complements the established MST_log ≤ Reg_log (exact in L∞, constant-factor for any fixed norm).

Refined constants for norm lifting and universal upper bound

- Norm lifting (refinement): For any norm ||·|| with b := sup_{z≠0} ||z||/||z||_∞ ≥ 1, we have 1+||e|| ≤ b(1+||e||_∞) for any edge e, hence log(1+||e||) ≤ log b + log(1+||e||_∞). Summing over an L∞-MST gives MST_log^{||·||} ≤ (n−1)·log b + MST_log^{∞}.
  Combining with MST_log^{∞} ≤ Reg_log and Reg_log ≥ (n−1)·log 3 yields MST_log^{||·||} ≤ (1 + (log b)/log 3)·Reg_log.
  For L_p in R^2, b_p = 2^{1/p}, so C_p = 1 + (log 2)/(p·log 3).

- Universal upper bound Reg ≤ Θ(log n)·MST (constants): For permutation grids, any two distinct points have both coordinate gaps ≥1, so every MST edge under
  • L∞ has weight ≥ log 2;
  • L2 has weight ≥ log(1+√2);
  • L1 has weight ≥ log 3.
  Since r_i ≤ i, Reg_log(π) ≤ (n−1)·log(1+n). Therefore Reg_log(π) ≤ (log(1+n)/c_N)·MST_log^N(π), where c_N is the per-edge lower-bound constant above. This gives a tight Θ(log n) worst-case factor, matching mod-m separations.

- Optional generalization: For any concave, nondecreasing φ with φ(0)=0, the L∞ integral method gives MST_φ(π) ≤ ∑_{i=2}^n φ(min{Δ_i, t_i}).

Further refinements and generalizations

- Refined norm-lift constant: For any norm ||·|| with b := sup_{z≠0} ||z||/||z||_∞ ≥ 1, 1+||e|| ≤ b(1+||e||_∞) implies log(1+||e||) ≤ log b + log(1+||e||_∞). Thus MST_log^{||·||} ≤ (n−1)·log b + MST_log^{∞} ≤ (1 + (log b)/log 3)·Reg_log. For L_p in R^2: b_p = 2^{1/p}, so C_p = 1 + (log 2)/(p·log 3).

- Universal upper bound with explicit constants: Every MST edge has weight at least c_N := log(1+α_N), where α_N>0 satisfies ||z|| ≥ α_N||z||_∞. Hence MST_log^N ≥ (n−1)·c_N. Since r_i ≤ i, Reg_log ≤ (n−1)·log(1+n), giving Reg_log ≤ (log(1+n)/c_N)·MST_log^N. In particular: L∞: c_∞=log 2; L2: c_2=log(1+√2); L1: c_1=log 3.

- Concave-weight extension in L∞: For any concave, nondecreasing φ with φ(0)=0, Kruskal’s integral with the sparse H(t) yields MST_φ^{∞}(π) ≤ ∑_{i=2}^n φ(min{Δ_i,t_i}) ≤ ∑_{i=2}^n φ(r_i).

- Temporal-to-value pairing: Let pos[v] be index of value v and s_v=|pos[v+1]−pos[v]|. For I_val={i≥2: ∃ j<i with |π(i)−π(j)|=1}, the map sending i to v=min{π(i),π(j)} (j realizes t_i) is injective and t_i=s_v. Hence ∑_{i∈I_val} log(1+t_i) ≤ ∑_{v=1}^{n−1} log(1+s_v).

These complement the established results MST_log^{∞} ≤ Reg_log and the Θ(log n) tight separation via mod-m families.


=== Current Output ===




=== Prover 1 Output ===

# Main Results and Proofs

We work on the point set P_π = {(i, π(i)) : i = 1,…,n}. Fix any norm ||·|| on R^2 and define the weight of an edge e = {p_i,p_j} to be w(e) = log(1 + ||p_i − p_j||). Let MST_log(π) be the total weight of a minimum spanning tree (MST) and Reg_log(π) := ∑_{i=2}^n log(1 + r_i) with r_i := min{d_i + t_i, i}, where
- d_i := 1 + #{k < i : min(π(i−1), π(i)) < π(k) < max(π(i−1), π(i))},
- t_i := min{i − j : 1 ≤ j < i and |π(i) − π(j)| = 1}, with t_i := i − 1 if no such j exists.

We use the L∞ norm first; all norms are equivalent up to constants, which we quantify below.


Theorem 1 (Reg dominates MST in L∞). For all permutations π, we have

MST_log^{(∞)}(π) ≤ Reg_log(π).

Proof.
Let G(t) be the threshold graph on P_π joining pairs at L∞-distance ≤ t, and let κ_G(t) denote its number of connected components. For any edge length ℓ, we have the layer-cake identity log(1 + ℓ) = ∫_0^∞ 1{t < ℓ} dt/(1 + t). Hence, writing the edge lengths of the L∞-MST as ℓ_1,…,ℓ_{n−1},

MST_log^{(∞)}(π) = ∑_{e} log(1 + ℓ_e) = ∫_0^∞ (# {e : ℓ_e > t}) dt/(1 + t).

We claim that # {e : ℓ_e > t} = κ_G(t) − 1 for every t ≥ 0. Indeed, in G(t) each connected component can be contracted; any spanning tree needs at least κ_G(t) − 1 edges joining different components, and Kruskal’s algorithm chooses exactly n − κ_G(t) edges of length ≤ t (the maximum possible without cycles), leaving exactly κ_G(t) − 1 edges of length > t. Therefore

MST_log^{(∞)}(π) = ∫_0^∞ (κ_G(t) − 1) dt/(1 + t).

Next we upper-bound κ_G(t) by a quantity expressible through (Δ_i, t_i), where Δ_i := |π(i) − π(i−1)| for i ≥ 2. Define a sparse subgraph H(t) on P_π as follows. For each i ≥ 2, add
- the “time edge” (i−1,i) if Δ_i ≤ t, and
- the “value-neighbor edge” (j,i), where j < i achieves t_i and |π(i) − π(j)| = 1, if t_i ≤ t.

Each such edge has L∞-length max(1,Δ_i) (for the time edge) or max(1,t_i) (for the value-neighbor edge), and since Δ_i, t_i ≥ 1 when present, these edges belong to G(t). Hence H(t) ⊆ G(t), so κ_G(t) ≤ κ_H(t).

Process vertices in order i = 1,2,…,n. Let κ_i(t) be the number of connected components in the subgraph of H(t) induced by {1,…,i}. Clearly κ_1(t) = 1. For i ≥ 2, if at least one of the two potential edges incident to i is present, then i is connected to {1,…,i−1} and κ_i(t) ≤ κ_{i−1}(t); if both edges are absent (i.e., Δ_i > t and t_i > t), then i forms a new component and κ_i(t) = κ_{i−1}(t) + 1. Thus

κ_H(t) = κ_n(t) ≤ 1 + |{i ≥ 2 : Δ_i > t and t_i > t}|.

Combining with the integral representation,

MST_log^{(∞)}(π) ≤ ∫_0^∞ |{i ≥ 2 : min(Δ_i, t_i) > t}| dt/(1 + t) = ∑_{i=2}^n log(1 + min(Δ_i, t_i)).

Finally, for each i ≥ 2 we have d_i ≤ Δ_i (since at most Δ_i − 1 integers lie strictly between π(i−1) and π(i)), and Δ_i ≤ i − 1 < i. Therefore

min(Δ_i, t_i) ≤ min(d_i + t_i, i) = r_i.

Applying log(1 + ·) to both sides and summing over i yields MST_log^{(∞)}(π) ≤ ∑_{i=2}^n log(1 + r_i) = Reg_log(π), as claimed. ∎


Corollary 2 (Reg dominates MST for any norm, with an explicit constant). Let ||·|| be any norm on R^2 and set b := sup_{z≠0} ||z||/||z||_∞ (finite). Then for all π,

MST_log^{||·||}(π) ≤ (1 + (log b)/(log 3)) · Reg_log(π).

Proof.
For any edge e, 1 + ||e|| ≤ b(1 + ||e||_∞), hence log(1 + ||e||) ≤ log b + log(1 + ||e||_∞). Summing along an L∞-MST gives

MST_log^{||·||}(π) ≤ MST_log^{(∞)}(π) + (n − 1)·log b.

By Theorem 1, MST_log^{(∞)}(π) ≤ Reg_log(π). Also, r_i ≥ 2 for i ≥ 2 (since d_i ≥ 1 and t_i ≥ 1), so Reg_log(π) = ∑_{i=2}^n log(1 + r_i) ≥ (n − 1)·log 3. Therefore

MST_log^{||·||}(π) ≤ Reg_log(π) + (n − 1)·log b ≤ (1 + (log b)/(log 3)) · Reg_log(π). ∎


Theorem 3 (No reverse domination; optimal Θ(log n) separation). There is no universal constant C such that Reg_log(π) ≤ C · MST_log^{||·||}(π) holds for all n and all permutations π (for any fixed norm ||·||). In fact, there exists a family {π_n} with

Reg_log(π_n) / MST_log^{||·||}(π_n) = Θ(log n).

Proof.
It suffices to work under L∞ (the argument below also yields Θ(log n) for any fixed norm). For even n, define π by interleaving the lower and upper halves:

π(2m−1) = m and π(2m) = n/2 + m, for m = 1,…,n/2.

1) Upper bound on MST_log^{(∞)}(π).
Consider the spanning tree that connects the odd-indexed vertices in order (2m−1)→(2(m+1)−1) and similarly connects the even-indexed vertices in order, plus one bridge between the two chains. Along each odd chain step, the difference vector is (Δx,Δy) = (2,1), so the L∞-length is 2 and the weight is log 3. There are (n/2−1) such odd steps and (n/2−1) even steps, contributing (n−2)·log 3 in total. One bridge of length O(n) contributes O(log n). Hence MST_log^{(∞)}(π) ≤ (n−2)·log 3 + O(log n) = Θ(n).

a) A matching lower bound MST_log^{(∞)}(π) ≥ (n − 1)·log 2 holds for every permutation, since any two distinct permutation points have L∞-distance at least 1. Thus MST_log^{(∞)}(π) = Θ(n).

2) Lower bound on Reg_log(π).
We compute r_i explicitly. For i = 2m − 1 ≥ 3, we have π(i) = m and π(i−1) = n/2 + (m − 1). Among earlier indices k < i, exactly the even indices 2,4,…,2m − 4 contribute values strictly between π(i−1) and π(i), giving d_i = 1 + (m − 2) = m − 1. The most recent true neighbor in value of m is m − 1, which appears at index 2m − 3, so t_i = 2. Therefore r_{2m−1} = min(d_i + t_i, i) = min(m + 1, 2m − 1) = m + 1.

For i = 2m ≥ 2, we have π(i) = n/2 + m and π(i−1) = m. Among earlier indices, the even ones 2,4,…,2m − 2 (there are m − 1 of them) contribute values strictly between, so d_i = 1 + (m − 1) = m. The most recent true neighbor in value of n/2 + m is n/2 + (m − 1) at index 2m − 2, so t_i = 2. Hence r_{2m} = min(m + 2, 2m) = m + 2.

Thus

Reg_log(π) = ∑_{m=1}^{n/2} [log(1 + r_{2m−1}) + log(1 + r_{2m})]
= ∑_{m=1}^{n/2} [log(2 + m) + log(3 + m)] = Θ(n log n).

Therefore Reg_log(π)/MST_log^{(∞)}(π) = Θ(log n). Since a constant-factor reverse inequality would force the ratio to be O(1) uniformly in n, no such constant exists.

Finally, for any fixed norm ||·||, the same construction yields MST_log^{||·||}(π) = Θ(n) (use the same spanning tree; each (2,1) step has constant ||·||-length, while one bridge contributes O(log n)), and the above Reg_log lower bound is norm-independent. Hence Reg_log(π)/MST_log^{||·||}(π) = Θ(log n) in any fixed norm. ∎


Proposition 4 (Universal logarithmic reverse bound). For any fixed norm ||·|| on R^2 there exists α>0 such that ||z|| ≥ α||z||_∞ for all z. Consequently, for all π,

Reg_log(π) ≤ (log(1 + n)/log(1 + α)) · MST_log^{||·||}(π).

Proof.
Since ||·|| ≥ α||·||_∞ for some α>0 (norm equivalence), any edge in the MST has length at least α (because ||·||_∞ ≥ 1 on any difference between two distinct permutation points), hence weight at least log(1 + α). Therefore MST_log^{||·||}(π) ≥ (n − 1)·log(1 + α).

On the other hand, r_i ≤ i for all i, so Reg_log(π) ≤ ∑_{i=2}^n log(1 + i) ≤ (n − 1)·log(1 + n). Dividing yields the claim. ∎


Remarks.
- Theorems 1 and 3 together resolve the asymptotic dominance questions: Reg dominates MST (exactly in L∞ and within a universal constant factor for any fixed norm), while MST does not dominate Reg (worst-case gap Θ(log n)). Proposition 4 shows this Θ(log n) gap is optimal in order.
- Explicit constants can be tracked for common norms. For L_p in R^2, sup_{z} ||z||_p/||z||_∞ = 2^{1/p}, so Corollary 2 gives MST_log^{(p)} ≤ (1 + (log 2)/(p·log 3)) · Reg_log. In Proposition 4, one may take α = 1 (L∞), α = √2 (L2), α = 2 (L1), yielding per-edge lower weights log 2, log(1 + √2), log 3, respectively.



=== Prover 2 Output ===

# Main Results and Proofs

We fix a logarithm base throughout (all bases differ by a constant factor). For a permutation π∈S_n let P_π={p_i=(i,π(i))}⊂{1,…,n}^2. For a norm ∥·∥ on R^2 define w(u,v)=log(1+∥u−v∥). Let MST_log^{∥·∥}(π) be the w-weight of a minimum spanning tree on P_π. For i≥2 define
- Δ_i := |π(i)−π(i−1)|,
- t_i := min{ i−j : 1≤j<i and |π(i)−π(j)|=1 }, with t_i:=i−1 if the set is empty,
- d_i := 1 + #{ k<i : min(π(i−1),π(i)) < π(k) < max(π(i−1),π(i)) },
- r_i := min{ d_i + t_i, i }.
Set Reg_log(π) := ∑_{i=2}^n log(1+r_i).

We prove:
- Theorem A (one-sided domination). Under L∞, MST_log^{∞}(π) ≤ Reg_log(π) for all π. For any norm ∥·∥, MST_log^{∥·∥}(π) ≤ C_∥·∥·Reg_log(π) with an explicit constant C_∥·∥ depending only on the norm.
- Theorem B (no reverse constant). There is no universal constant C such that Reg_log(π) ≤ C·MST_log^{∥·∥}(π) for all π and all n (for any fixed norm); in fact there are families with Reg_log/MST_log → ∞, quantitatively Θ(log n).
- Theorem C (universal logarithmic upper bound). Nevertheless, for any fixed norm ∥·∥ and all π,
Reg_log(π) ≤ (log(1+n)/c_∥·∥)·MST_log^{∥·∥}(π), with explicit c_∥·∥>0 depending only on the norm. Thus the worst-case multiplicative gap is Θ(log n) and is tight by Theorem B.

We proceed in order.


1) Kruskal’s integral identity for log-weights

For a metric space (X,d), and t≥0, let G(t) be the graph on X with edges {u,v} whenever d(u,v)≤t, and let κ(t) be its number of connected components. Let T be an MST of the complete graph on X with edge weights log(1+d). If the MST edge lengths are ℓ_1≤⋯≤ℓ_{|X|−1}, then
∑_{e∈T} log(1+ℓ_e) = ∫_0^∞ (κ(t)−1) dt/(1+t).

Proof. For each j, log(1+ℓ_j)=∫_0^{ℓ_j} dt/(1+t). Summing and exchanging sum and integral gives ∫_0^∞ m(t) dt/(1+t), where m(t):=|{j: ℓ_j≥t}|. By Kruskal’s algorithm, after inserting all edges of length ≤t, the forest has κ(t) components, so exactly κ(t)−1 edges of T still exceed t, i.e., m(t)=κ(t)−1 for all but finitely many t (ties). The finitely many exceptional t do not affect the integral. ∎

We apply this with X=P_π and d=∥·∥_∞.


2) A sparse threshold subgraph controlling components (L∞)

For t≥0, build a graph H(t) on P_π as follows. Process i=1,…,n in order; when adding p_i,
- if Δ_i ≤ t, add the edge {p_{i−1},p_i};
- if there exists j<i with |π(i)−π(j)|=1 and t_i:=i−j ≤ t, add the edge {p_j,p_i} (choose the most recent such j).

Claim. For all t≥0,
κ_{G_∞}(t) − 1 ≤ |{ i≥2 : Δ_i>t and t_i>t }|,
where G_∞(t) is the L∞-threshold graph.

Proof. H(t) is a subgraph of G_∞(t), hence κ_{G_∞}(t) ≤ κ_{H}(t). In H(t), add p_1 as an isolated vertex. Inductively, when adding p_i,
- if at least one of the above edges is present (i.e., Δ_i≤t or t_i≤t), then p_i attaches to some existing component, possibly fusing two components if both edges are present, so κ_H does not increase;
- if both Δ_i>t and t_i>t, no edge is added from p_i to earlier vertices, so κ_H increases by 1.
Hence κ_H(t)−1 ≤ |{i≥2: Δ_i>t and t_i>t}|. The claim follows. ∎


3) Theorem A: MST_log^{∞} ≤ Reg_log, and norm lifting

Theorem A. For all permutations π,
MST_log^{∞}(π) ≤ ∑_{i=2}^n log(1+min{Δ_i,t_i}) ≤ Reg_log(π).
In particular MST_log^{∞}(π) ≤ Reg_log(π).

Proof. By the integral identity and the claim,
MST_log^{∞}(π) = ∫_0^∞ (κ_{G_∞}(t)−1) dt/(1+t) ≤ ∫_0^∞ |{i≥2: Δ_i>t and t_i>t}| dt/(1+t)
= ∑_{i=2}^n ∫_0^{min{Δ_i,t_i}} dt/(1+t) = ∑_{i=2}^n log(1+min{Δ_i,t_i}).
Since d_i≥1 and t_i≤i−1, we have r_i=min{d_i+t_i, i} ≥ t_i+1 ≥ t_i, hence log(1+min{Δ_i,t_i}) ≤ log(1+r_i). Summing over i yields the result. ∎

Corollary (norm lifting). Let ∥·∥ be any norm and let b:=sup_{z≠0} ∥z∥/∥z∥_∞ (finite by norm equivalence). Then for all π,
MST_log^{∥·∥}(π) ≤ MST_log^{∞}(π) + (n−1)·log b ≤ (1 + (log b)/log 3)·Reg_log(π).

Proof. For any edge e, 1+∥e∥ ≤ b(1+∥e∥_∞) (as b≥1), hence log(1+∥e∥) ≤ log b + log(1+∥e∥_∞). Summing over edges of an L∞-MST gives the first inequality. For the second, use Theorem A and the baseline bound Reg_log(π) ≥ ∑_{i=2}^n log 3 = (n−1) log 3 (since r_i≥2 for all i). ∎

Examples (explicit constants in R^2). For L_p, b=2^{1/p}, so MST_log^{(p)} ≤ (1 + (log 2)/(p·log 3))·Reg_log.


4) Theorem B: No reverse constant domination; quantitative separation

For m≥2, define π^{(m)}_n∈S_n by listing values by increasing residue class mod m, and within each class in increasing order:
π^{(m)}_n = (1,1+m,1+2m,…; 2,2+m,2+2m,…; …; m,2m,3m,…), truncated at n.
Let m_r be the size of residue class r (r=1,…,m), so m_r∈{⌊n/m⌋,⌈n/m⌉} and ∑_r m_r=n.

Proposition. Under L∞, for π=π^{(m)}_n we have
MST_log^{∞}(π) ≤ (n−m)·log(1+m) + (m−1)·log(1+n) = Θ(n + m log n),
Reg_log(π) ≥ ∑_{r=2}^m m_r·log(1+m_{r−1}) = Θ(n log(n/m)).
In particular, for any fixed m, MST_log^{∞}(π)=Θ(n) while Reg_log(π)=Θ(n log n), hence Reg_log/MST_log ≍ log n → ∞.

Proof (MST upper bound). Inside each residue class r, the corresponding indices in the sequence are contiguous. Connect consecutive indices within each class by time-edges; each such edge has L∞-length max{1,m}=m and weight log(1+m). There are (m_r−1) such edges in class r; summing over r gives (n−m)·log(1+m). Connect the m class-blocks into a tree by m−1 boundary time-edges; each such edge has L∞-length at most n (value jump O(n)), hence weight ≤ log(1+n). Total ≤ (n−m)·log(1+m)+(m−1)·log(1+n).

Proof (Reg lower bound). Fix r≥2. For the k-th element of class r, its value is v=r+km; its most recent earlier true neighbor v−1 lies in class r−1 at the same within-class index k, which occurs exactly m_{r−1} steps earlier. Thus t_i=m_{r−1} and hence r_i≥t_i, so log(1+r_i) ≥ log(1+m_{r−1}). Summing over the m_r elements of class r yields the stated lower bound. Since m_r≈n/m, the sum is Θ(n log(n/m)). ∎

By norm equivalence, the same Θ(log n) separation holds (up to constant factors) for any fixed norm on R^2. Therefore no universal constant C can satisfy Reg_log ≤ C·MST_log^{∥·∥} for all π.


5) Theorem C: Universal logarithmic upper bound Reg_log ≤ O(log n)·MST_log

Let ∥·∥ be any norm on R^2 and define the constant
β_∥·∥ := inf{ ∥(x,y)∥ : x≥1, y≥1 } > 0.
For L_p, β_{(p)} = 2^{1/p}. Then for all π,
Reg_log(π) ≤ (log(1+n)/log(1+β_∥·∥)) · MST_log^{∥·∥}(π).

Proof. Any two distinct permutation points differ by at least 1 in each coordinate; hence every spanning-tree edge e has ∥e∥ ≥ β_∥·∥ and weight ≥ log(1+β_∥·∥). Therefore MST_log^{∥·∥}(π) ≥ (n−1)·log(1+β_∥·∥). On the other hand, r_i ≤ i gives Reg_log(π) ≤ ∑_{i=2}^n log(1+i) ≤ (n−1)·log(1+n). Dividing yields the claim. For L∞, L2, L1 this gives denominators log 2, log(1+√2), log 3 respectively. ∎

Combining Theorems A–C, we obtain the complete picture (up to constant factors): for any fixed norm on R^2 and all permutations π,
- MST_log(π) ≤ C_1·Reg_log(π) with explicit C_1 depending only on the norm (and C_1=1 for L∞);
- Reg_log(π) ≤ C_2·log(1+n)·MST_log(π) with explicit C_2 depending only on the norm;
- the Θ(log n) factor is worst-case tight by the residue-class family in Theorem B.

This resolves Questions (1)–(3) from the task statement.



=== Prover 3 Output ===

Main theorems and proofs

Setup and basic facts
- Input: a permutation π∈S_n represented by points P_π={p_i=(i,π(i)) : i=1,…,n}⊂{1,…,n}^2.
- Fix a norm ||·|| on R^2. Define w(u,v)=log(1+||u−v||). Let MST_log^{||·||}(π) be the sum of w(e) over the edges of a minimum spanning tree of the complete graph on P_π with weights w. We write MST_log(π) when ||·||=||·||_∞ (L∞).
- For i≥2, define Δ_i=|π(i)−π(i−1)|, the L∞-distance between consecutive time indices; define t_i = min{i−j : 1≤j<i, |π(i)−π(j)|=1}, with t_i:=i−1 if no such j exists; define d_i = 1 + #{k<i : min(π(i−1),π(i)) < π(k) < max(π(i−1),π(i))}. Set r_i = min{d_i + t_i, i}. Finally, Reg_log(π) = ∑_{i=2}^n log(1+r_i).
- Trivial bounds used below: for all i≥2 we have t_i≥1, d_i≥1, hence r_i≥2 and log(1+r_i)≥log 3.

Theorem A (One-sided domination in L∞).
For every π and n, MST_log(π) ≤ Reg_log(π).

Proof.
For t≥0, let G(t) be the threshold graph on P_π with an edge between p_i and p_j iff ||p_i−p_j||_∞ ≤ t. Let κ(t) be the number of connected components of G(t). A standard Kruskal integral identity gives
MST_log(π) = ∫_0^∞ (κ(t)−1) dt/(1+t).
Indeed, if the L∞-lengths of the MST edges are {ℓ_e}, then log(1+ℓ_e)=∫_0^{ℓ_e} dt/(1+t), and summing over e yields ∫_0^∞ #(e:ℓ_e>t) dt/(1+t). In Kruskal’s process at threshold t, exactly κ(t)−1 edges of the MST have length > t (they are the ones that will connect the κ(t) components), up to changes on a measure-zero set of t (ties), which does not affect the integral.
For each t, construct a directed forest F(t) on {1,…,n} by assigning at most one parent par_t(i) to each i≥2 as follows:
- If Δ_i≤t, set par_t(i)=i−1.
- Else, if there exists j<i with |π(i)−π(j)|=1 and i−j≤t (i.e., t_i≤t), set par_t(i)=j (choose the largest such j).
- Else, i has no parent.
Whenever a parent is assigned, the L∞-distance between i and par_t(i) is at most t, so F(t) is a subgraph of G(t). Because every parent index is < i, F(t) is acyclic. The number of components of F(t) is 1 + |{i≥2 : Δ_i>t and t_i>t}| (vertex 1 is a root; every i≥2 with no parent contributes one root). Hence κ(t) ≤ 1 + |{i≥2 : Δ_i>t and t_i>t}|. Integrating,
MST_log(π) ≤ ∫_0^∞ ∑_{i=2}^n 1[Δ_i>t and t_i>t] dt/(1+t) = ∑_{i=2}^n log(1+min{Δ_i,t_i}).
Finally, since r_i ≥ t_i, we have log(1+min{Δ_i,t_i}) ≤ log(1+t_i) ≤ log(1+r_i). Summing over i gives MST_log(π) ≤ Reg_log(π).
∎

Theorem B (Extension to any fixed norm).
Let ||·|| be any norm on R^2, and let b:=sup_{z≠0} ||z||/||z||_∞ ∈ [1,∞). Then for all π,
MST_log^{||·||}(π) ≤ [1 + (log b)/log 3] · Reg_log(π).

Proof.
Let T_∞ be an L∞-MST. For any edge e, 1+||e|| ≤ b(1+||e||_∞), so log(1+||e||) ≤ log b + log(1+||e||_∞). Summing over e∈T_∞,
MST_log^{||·||}(π) ≤ (n−1)·log b + ∑_{e∈T_∞} log(1+||e||_∞) = (n−1)·log b + MST_log(π).
By Theorem A, MST_log(π) ≤ Reg_log(π), and since r_i≥2 for i≥2, Reg_log(π) ≥ (n−1)·log 3. Therefore
MST_log^{||·||}(π) ≤ Reg_log(π) + (n−1)·log b ≤ [1 + (log b)/log 3]·Reg_log(π).
∎

Theorem C (Universal logarithmic upper bound for Reg).
Fix a norm ||·||. There exists c(||·||)>0 such that for all π and n,
Reg_log(π) ≤ [log(1+n)/c(||·||)] · MST_log^{||·||}(π).
In particular, one can take c(L∞)=log 2, c(L2)=log(1+√2), c(L1)=log 3.

Proof.
In a permutation grid, for any distinct p_i≠p_j, both coordinates differ by at least 1, hence: ||p_i−p_j||_∞≥1; ||p_i−p_j||_2≥√2; ||p_i−p_j||_1≥2. Consequently every MST edge has weight at least c(||·||):=log(1+α), with α=1,√2,2 for L∞,L2,L1 respectively. Therefore MST_log^{||·||}(π) ≥ (n−1)·c(||·||). On the other hand r_i≤i gives Reg_log(π) ≤ ∑_{i=2}^n log(1+i) ≤ (n−1)·log(1+n). Combining,
Reg_log(π) ≤ [(n−1)·log(1+n)] / [(n−1)·c(||·||)] · MST_log^{||·||}(π) = [log(1+n)/c(||·||)] · MST_log^{||·||}(π).
∎

Theorem D (Separation; sharpness of the Θ(log n) gap).
There exists a family of permutations {π_n} for which Reg_log(π_n)/MST_log^{||·||}(π_n) = Θ(log n) for any fixed norm ||·||. In particular, there is no universal constant C with Reg_log(π) ≤ C·MST_log^{||·||}(π) for all π.

Proof.
Consider n=2m and the permutation π that lists all odds then all evens:
π(i)=2i−1 for 1≤i≤m, and π(m+j)=2j for 1≤j≤m.
1) MST_log under L∞. Construct a spanning tree T with edges: (i,i+1) for i=1,…,m−1 and (i,i+1) for i=m+1,…,2m−1, plus a single bridge (m,m+1).
- For 1≤i≤m−1 (odd block), ||p_{i+1}−p_i||_∞ = max{|(i+1)−i|, |(2(i+1)−1)−(2i−1)|} = max{1,2} = 2, so w=log 3.
- For m+1≤i≤2m−1 (even block), similarly w=log 3.
- The bridge has ||p_{m+1}−p_m||_∞ = max{1, |2−(2m−1)|} = 2m−3, so w=log(2m−2) ≤ log n.
Therefore MST_log(π) ≤ (2m−2)·log 3 + log n = Θ(n). Since every MST has n−1 edges and each has weight at least log 2, MST_log(π) ≥ (n−1)·log 2 = Ω(n). Hence MST_log(π)=Θ(n).
2) Reg_log. For 2≤i≤m (odd block), there is no earlier value-neighbor; thus t_i=i−1, and the interval between π(i−1)=2i−3 and π(i)=2i−1 contains no earlier value, so d_i=1. Hence r_i=min{1+(i−1), i}=i and ∑_{i=2}^m log(1+r_i)=∑_{i=2}^m log(1+i)=Θ(m log m).
For the even block, write i=m+j with 1≤j≤m. Then π(i)=2j.
- For j=1, the nearest earlier value-neighbor is value 3 at index 2, so t_i=m−1; as noted, a direct count gives d_i=m−1. Thus r_i=min{2m−2, m+1}=m+1, contributing Θ(log m).
- For 2≤j≤m, the unique earlier neighbor 2j−1 occurs at index j, so t_i=(m+j)−j=m; the interval between π(i−1)=2j−2 and π(i)=2j contains the single earlier value 2j−1, hence d_i=2. Consequently r_i=min{m+2, m+j}=m+2, and each contributes log(1+m+2)=Θ(log m).
Summing over the even block yields Θ(m log m). Therefore Reg_log(π)=Θ(m log m + m log m)=Θ(n log n).
3) Other norms. For L2 and L1 the same tree T has constant-cost intra-block edges (length √5 for L2, length 3 for L1) and a single bridge of length Θ(n), so MST_log^{||·||}(π)=Θ(n). Thus for any fixed norm, Reg_log(π)/MST_log^{||·||}(π)=Θ(log n), and no universal constant C can satisfy Reg_log ≤ C·MST_log^{||·||} for all π.
∎

Corollary (Two-sided comparison up to a Θ(log n) factor).
Fix any norm ||·|| on R^2. There exist positive constants A(||·||), B(||·||) such that for all n and all π,
A(||·||)·MST_log^{||·||}(π) ≤ Reg_log(π) ≤ B(||·||)·log(1+n)·MST_log^{||·||}(π),
with A(L∞)=1 and, for example, B(L∞)=1/log 2. Moreover, the multiplicative Θ(log n) dependence in the upper bound is tight in general by Theorem D.

Remarks on constants and norms
- In Theorem B, for L_p norms in R^2 one can take b=2^{1/p}, giving MST_log^{(p)}(π) ≤ [1 + (log 2)/(p·log 3)]·Reg_log(π).
- In Theorem C, the explicit constants are c(L∞)=log 2, c(L2)=log(1+√2), c(L1)=log 3.
- The logarithm base is arbitrary but fixed; changing the base rescales all three quantities by the same positive constant, preserving all asymptotic inequalities.

This completes the comparison of MST_log and Reg_log up to universal constant factors: Reg_log always dominates MST_log (exactly in L∞ and up to a fixed constant in any norm), while the reverse domination fails by a tight Θ(log n) factor in the worst case, though a universal Reg_log ≤ O(log n)·MST_log bound always holds.


=== Prover 4 Output ===

# Main results (self-contained)

Throughout, n≥2 is an integer and π∈S_n. Set P_π={p_i=(i,π(i)) : i=1,…,n}⊂R^2. Fix a norm ||·|| on R^2 and a logarithm base; changing either only affects constants.

Define edge weights w(u,v)=log(1+||u−v||). Let MST_log^||·||(π) be the total weight of a minimum spanning tree (MST) of the complete graph on P_π with these weights. Define for i≥2
- Δ_i := |π(i)−π(i−1)|,
- t_i := min{i−j : 1≤j<i and |π(i)−π(j)|=1}, with t_i:=i−1 if no such j exists,
- d_i := 1 + #{ k<i : min(π(i−1),π(i)) < π(k) < max(π(i−1),π(i)) },
- r_i := min{ d_i + t_i, i }.
Set Reg_log(π) := ∑_{i=2}^n log(1+r_i).

We prove three theorems giving the exact L∞ domination, norm-lifted domination, a universal O(log n) reverse bound, and a tight separation.


Theorem 1 (Exact domination in L∞). For the L∞ norm,
  MST_log^∞(π) ≤ Reg_log(π) for all π.

Proof. For t≥0, let G(t) be the threshold graph on P_π joining u,v iff ||u−v||_∞ ≤ t, and let κ(t) be its number of connected components. Kruskal’s identity (layer-cake) for φ(x)=log(1+x) with φ′(t)=1/(1+t) gives
  MST_log^∞(π) = ∫_0^∞ (κ(t)−1) d log(1+t) = ∫_0^∞ (κ(t)−1) φ′(t) dt.
We upper bound κ(t) via a sparse subgraph H(t): process i=2,…,n in order and add to H(t)
- the time edge (i−1,i) if Δ_i ≤ t;
- the value-neighbor edge (i,j) where j<i is the largest index with |π(i)−π(j)|=1, if t_i ≤ t.
Each added edge has L∞-length ≤ t: for a time edge, ||p_i−p_{i−1}||_∞=max{1,Δ_i}≤t; for a value edge, ||p_i−p_j||_∞=max{t_i,1}≤t. Hence H(t)⊆G(t), so κ(t)≤κ_H(t).
Expose vertices in increasing i and write κ_H,i(t) for the component count of the subgraph on {1,…,i}. When vertex i arrives, the component count increases by 1, but if Δ_i≤t we add (i−1,i) which merges the new vertex into the component of i−1, reducing the count by 1; if instead Δ_i>t but t_i≤t we add (i,j) with j<i which merges the new vertex into an existing component, again reducing the count by 1. Therefore the count fails to drop back by 1 only when both Δ_i>t and t_i>t. Starting from κ_H,1(t)=1, we get
  κ_H(t) ≤ 1 + |{ i∈{2,…,n} : Δ_i>t and t_i>t }|.
Integrating,
  MST_log^∞(π) ≤ ∫_0^∞ |{i : Δ_i>t, t_i>t}| φ′(t) dt
                 = ∑_{i=2}^n ∫_0^{min{Δ_i,t_i}} φ′(t) dt
                 = ∑_{i=2}^n log(1 + min{Δ_i,t_i})
                 ≤ ∑_{i=2}^n log(1 + r_i) = Reg_log(π),
using r_i ≥ t_i. ∎

Corollary 2 (Domination for any norm). Let b:=sup_{||z||_∞=1} ||z|| (finite). Then for all π,
  MST_log^||·||(π) ≤ ((log b)/log 3 + 1) · Reg_log(π).

Proof. Let T∞ be an L∞-MST. For any edge e, 1+||e|| ≤ b(1+||e||_∞), so log(1+||e||) ≤ log b + log(1+||e||_∞). Summing over the n−1 edges of T∞,
  MST_log^||·||(π) ≤ (n−1) log b + MST_log^∞(π) ≤ (n−1) log b + Reg_log(π).
Since r_i ≥ 2 for all i (d_i≥1 and t_i≥1 or =i−1), Reg_log(π) ≥ (n−1) log 3. Rearranging yields the stated bound. For L_p, b=2^{1/p}, giving MST_log^{(p)}(π) ≤ (1 + (log 2)/(p·log 3)) Reg_log(π). ∎


Theorem 3 (Universal logarithmic reverse bound). For any fixed norm ||·|| there exists c>0 such that for all π and all n,
  Reg_log(π) ≤ (log(1+n)/c) · MST_log^||·||(π).

Proof. In the permutation grid, any two distinct points differ by at least 1 in each coordinate. Hence for L∞, every edge has length ≥1 and weight ≥ log 2; for L2, length ≥√2 and weight ≥ log(1+√2); for L1, length ≥2 and weight ≥ log 3. More generally, by norm equivalence there exists α>0 such that ||z|| ≥ α||z||_∞ for all z, hence every edge has weight ≥ c:=log(1+α). Therefore MST_log^||·||(π) ≥ (n−1) c. Also r_i ≤ i gives Reg_log(π) ≤ ∑_{i=2}^n log(1+i) ≤ (n−1) log(1+n). Combining yields Reg_log(π) ≤ (log(1+n)/c)·MST_log^||·||(π). ∎


Theorem 4 (Tight separation). There is no universal constant C with Reg_log(π) ≤ C·MST_log^||·||(π) for all π. In fact there exists a family {π_n} such that Reg_log(π_n)/MST_log^||·||(π_n) = Θ(log n) for any fixed norm.

Proof. For even n, define the parity-block permutation by listing even values in increasing order followed by odd values in increasing order: π(i)=2i for i≤n/2 and π(i)=2(i−n/2)−1 for i>n/2.
- MST_log^||·||(π)=Θ(n). Upper bound: Within each half, the time edges (i−1,i) have Δ_i=2, hence constant weight; these n−2 edges contribute Θ(n). One bridge connects the halves, costing O(log n). Lower bound: by the previous proof, every MST has total weight ≥ (n−1)c for a norm-dependent c>0. Thus MST_log=Θ(n).
- Reg_log(π)=Θ(n log n). In the first half (i=2,…,n/2), no odd value has appeared, so t_i=i−1 and d_i=1; hence r_i=i and the contribution is ∑_{i=2}^{n/2} log(1+i)=Θ((n/2) log n). At i=n/2+1 we have a jump from n to 1, giving r_{n/2+1}=Θ(n). For the remaining odds, the nearest value-neighbor (the preceding even) lies in the first half at temporal distance t_i=n/2, and d_i=2, so r_i=Θ(n) and each contributes Θ(log n). Summing yields Reg_log=Θ(n log n).
Therefore Reg_log/MST_log=Θ(log n), proving that no universal constant C suffices in the reverse direction. ∎


Consequences.
- Combining Theorems 1–3, the two measures are equivalent up to a Θ(log n) factor in the worst case: for every fixed norm ||·|| and every π,
    MST_log^||·||(π) ≤ K_1 · Reg_log(π) and Reg_log(π) ≤ K_2 log(1+n) · MST_log^||·||(π),
  with explicit K_1,K_2 depending only on the norm and logarithm base. The Θ(log n) factor is optimal by Theorem 4.
- For random π, both measures have expectation Θ(n log n) (the upper/lower bounds above are consistent), and the L∞ inequality MST_log ≤ Reg_log holds pointwise.

Remarks on constants. In Corollary 2, for L∞ one has b=1 and MST_log^∞ ≤ Reg_log exactly. In Theorem 3, c=log 2 for L∞, c=log(1+√2) for L2, c=log 3 for L1. All constants depend only on the norm and the logarithm base.
