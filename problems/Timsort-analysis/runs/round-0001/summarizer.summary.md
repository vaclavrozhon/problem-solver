Round summary: The claim that TimSort always uses ≤ n·H + O(n) comparisons (leading constant 1) is false: Buss–Knop give input families with ≥ (3/2−o(1))·n·log2 n comparisons when H ≈ log2 n. However, Python TimSort with the de Gouw fix (extra guard r2+r3 ≥ r4) is proved to use at most C·n + C'·n·H comparisons, i.e., O(n + nH). A self-contained proof is given: model the core stack rules; establish a Fibonacci-type (exponential) growth invariant; decompose each push into a starting sequence (maximal #2 merges) and an ending sequence; show starting sequences cost O(n) via geometric bounds; account ending-sequence costs with a token scheme (each element gets 2 c-tokens + 1 s-token on push/height drop) and prove no deficits; bound post-starting-sequence stack height by h ≤ 4 + 2 log2(n/r) so each element pays O(1+log(n/r)) tokens, summing to O(n + nH). A potential-function refinement yields a tight upper bound (3/2)·n·H + O(n). Lower bound: any comparison sort needs ≥ nH − O(n) comparisons (Stirling).