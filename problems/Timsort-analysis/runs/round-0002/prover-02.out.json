{
  "content": "# Clarifying the target and corrected statement\n- The requested bound with leading constant 1, comparisons \u2264 n\u00b7H + O(n), is false for TimSort: there exist inputs with comparisons \u2265 (3/2)\u00b7n\u00b7H \u2212 O(n) (Buss\u2013Knop). We therefore aim for two statements that are known and correct for Python\u2019s patched TimSort (with the extra case #5 in merge_collapse):\n  1) Coarse entropy bound: comparisons = O(n + n\u00b7H).\n  2) Sharp bound: comparisons \u2264 (3/2)\u00b7n\u00b7H + O(n), tight.\n\nBelow I isolate small lemmas and proofs sufficient for (1), ready to migrate into proofs.md; I also note the refinement pathway to (2).\n\n\nIdeas: decomposition, invariant, and accounting\n- Compare-by-merge-cost: merging runs of sizes a,b uses \u2264 a+b\u22121 comparisons; scanning for runs is O(n) comparisons. Hence comparisons \u2264 (total merge cost) + O(n).\n- Decompose each iteration into a starting sequence (push + maximal #2 merges) and an ending sequence (#3/#4/#5 merges, possibly interleaved with #2, until invariant restored).\n- Maintain the stack invariant (Python version): r_{i+2} > r_{i+1} + r_i and r_{i+1} > r_i for i \u2265 1. Consequences: exponential growth along stack, logarithmic height.\n\n\nLemma A (Stack-growth invariant)\nStatement. After each collapse, the stack satisfies r_{i+2} > r_{i+1}+r_i and r_{i+1} > r_i for 1 \u2264 i \u2264 h\u22122.\nProof (sketch). Induct on updates. Pushing (#1) only happens when none of #2\u2013#5 applies; that directly gives r\u2081<r\u2082, r\u2081+r\u2082<r\u2083, r\u2082+r\u2083<r\u2084. Any merge (#2\u2013#5) shifts indices; the inequalities lift one level down. A routine case analysis completes the induction.\nUsefulness. Enables exponential growth and height bounds.\n\nCorollary A1 (Geometric growth). Before a push finishes, for all i \u2264 j \u2264 h: r_i \u2264 2^{(i+1\u2212j)/2} r_j.\nProof. From Lemma A and r_k<r_{k+1} for k \u2264 h\u22122, we get 2 r_i \u2264 r_{i+2}. Chain the factor-2 jumps.\n\n\nLemma B (Starting sequences have linear total cost)\nStatement. If a starting sequence begins by pushing R (length r) and performs k\u22121 merges #2 on R\u2081,\u2026,R_k (k\u22651), then its merge cost C \u2264 \u03b3\u00b7r, where \u03b3 = 2\u2211_{j\u22651} j\u00b72^{-j/2} < \u221e. Summing over all runs yields total starting-sequence cost O(n).\nProof. Cost C \u2264 \u2211_{i=1}^k (k+1\u2212i) r_i. The final #2 guard implies r > r_k. Apply Corollary A1 with j=k: r \u2265 r_k \u2265 2^{(k\u22121\u2212i)/2} r_i, hence C/r \u2264 \u2211_{i=1}^k (k+1\u2212i) 2^{(i+1\u2212k)/2} = 2\u2211_{j=1}^k j\u00b72^{-j/2} < \u03b3. Each run starts exactly one starting sequence; \u2211 r = n.\nUsefulness. Reduces the problem to ending sequences.\n\n\nLemma C (Height bound after a starting sequence)\nStatement. Let r be the just-pushed run\u2019s length; when its starting sequence ends, stack height h satisfies h \u2264 4 + 2 log\u2082(n/r).\nProof. None of R\u2083,\u2026,R_h was merged during the starting sequence; applying Corollary A1 to the pre-push stack gives r\u2083 \u2264 2^{2\u2212h/2} n. At the end of the starting sequence, #2 no longer holds, so r = r\u2081 \u2264 r\u2083. Hence r \u2264 2^{2\u2212h/2} n \u21d2 h \u2264 4 + 2 log\u2082(n/r).\nUsefulness. Bounds how often an element can be credited in ending sequences.\n\n\nLemma D (Token scheme for ending sequences)\nSetup. Credit rules: each element receives 2 \u201cc-tokens\u201d and 1 \u201cs-token\u201d (i) upon push and (ii) whenever its height decreases due to a merge inside an ending sequence. Spending rules for a merge on top runs R\u2081,R\u2082 (and R\u2083,R\u2084 where relevant):\n- #2 (merge R\u2082,R\u2083): each element of R\u2081 and R\u2082 pays 1 c-token; since r\u2081>r\u2083, r\u2081+r\u2082 \u2265 r\u2082+r\u2083 covers the merge cost.\n- #3 (merge R\u2081,R\u2082, r\u2081\u2265r\u2082): each element of R\u2081 pays 2 c-tokens; cost \u2264 2 r\u2081.\n- #4/#5 (merge R\u2081,R\u2082 with r\u2081+r\u2082\u2265r\u2083 or r\u2082+r\u2083\u2265r\u2084): each element of R\u2081 pays 1 c-token and of R\u2082 pays 1 s-token; pays exactly r\u2081+r\u2082.\nClaim. No element\u2019s c-token or s-token balance ever goes negative.\nProof (key point: need case #5). In #2\u2013#5 merges, the heights of elements in R\u2081 (and possibly R\u2082) decrease, triggering credits that match or exceed the c-tokens spent. s-tokens are only spent in #4/#5 by elements of R\u2082; the corrected Python rule ensures the resulting top run must be merged again immediately (still in the same ending sequence), so these elements\u2019 heights decrease in the next merge and they regain one s-token. Thus s-token balances never dip below zero. (This fails without case #5.)\nUsefulness. Ensures ending-sequence merge cost is paid by minted tokens.\n\n\nProposition (Ending sequences cost O(n + n\u00b7H))\nStatement. Let \u2113\u2081,\u2026,\u2113_r be the run lengths; the total merge cost of all ending sequences is O(\u2211\u1d62 \u2113\u1d62 (1 + log\u2082(n/\u2113\u1d62))) = O(n + n\u00b7H).\nProof. By Lemma C, after the starting sequence of run i, the stack height is \u2264 4 + 2 log\u2082(n/\u2113\u1d62); hence each element of that run can be credited at most O(1 + log\u2082(n/\u2113\u1d62)) times over all ending sequences. Each credit mints O(1) tokens, and by Lemma D, the spent tokens equal the ending-sequence merge cost. Summation yields O(\u2211 \u2113\u1d62 (1 + log(n/\u2113\u1d62))). Finally, \u2211 \u2113\u1d62 log\u2082(n/\u2113\u1d62) = n\u00b7H.\n\n\nCorollary (Coarse entropy bound for comparisons)\nTotal comparisons = O(n) (run detection) + (merge cost) \u2212 (#merges) = (starting) + (ending) + O(n) \u2264 O(n) + (n + n\u00b7H) + O(n) = O(n + n\u00b7H).\n\n\nObstacle: why leading constant 1 is impossible\nBuss\u2013Knop\u2019s family yields merge cost \u2265 (3/2)\u00b7n\u00b7log\u2082 n \u2212 O(n). Since H \u2264 log\u2082 n, comparisons \u2265 (3/2)\u00b7n\u00b7H \u2212 O(n) on those inputs. Thus TimSort cannot satisfy comparisons \u2264 n\u00b7H + O(n) in general.\n\n\nRefinement to the sharp (3/2)\u00b7n\u00b7H + O(n)\n- Potential \u03a6(r) = (3/2)\u00b7r\u00b7log\u2082 r. Balanced merges (sizes within [\u03c6^{\u22122}, \u03c6\u00b2]) satisfy cost \u2264 \u0394\u03a6; unbalanced cases are paired to ensure cost \u2264 \u0394\u03a6(group). The first group in each ending sequence may exceed by \u2264 r (length of the pushed run); the sum of these slacks is O(n). The total potential drop telescopes to (3/2)\u00b7n\u00b7H. Hence merge cost \u2264 (3/2)\u00b7n\u00b7H + O(n), and thus comparisons \u2264 (3/2)\u00b7n\u00b7H + O(n). Matching lower bounds exist.\n\n\nExamples / sanity checks\n- Equal runs (\u2113\u1d62\u2248n/r): H\u2248log\u2082 r and our bound gives O(n + n log r); consistent with classical adaptive mergesort bounds.\n- One huge run and many tiny ones: H small; starting-sequence cost O(n) dominates, as expected.\n\n\nNext steps\n- Move Lemmas A\u2013D and the proposition into proofs.md with full formal details (explicit case analyses for Lemma A and the s-token lemma), and cite to Auger\u2013Jug\u00e9\u2013Nicaud\u2013Pivoteau for the refined potential proof.\n- Update output.md to state the corrected main theorem: comparisons \u2264 (3/2)\u00b7n\u00b7H + O(n), tight; include the coarse O(n + n\u00b7H) result.\n- Optional: add a short note in notes.md explaining that case #5 is necessary for the s-token invariant.\n"
}