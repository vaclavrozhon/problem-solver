{
  "content": "Ideas\n\n- Correct target: For Python\u2019s patched TimSort (with the extra collapse rule r_2 + r_3 \u2265 r_4), the number of comparisons on inputs with run lengths (\u2113_i) is O(n + n H) where H = \u2211 (\u2113_i/n) log_2(n/\u2113_i). This is the coarse entropy-adaptivity. The sharp constant 3/2 is known but not needed here.\n- Strategy: Bound comparisons by merge cost plus O(n). Decompose each iteration into starting vs. ending sequences. Prove starting sequences contribute O(n). For ending sequences, an amortized token scheme credits O(1 + log(n/r)) tokens per element in a run of length r; summing yields O(n + n H).\n\nRigorous steps\n\n1) Comparisons vs. merge cost.\n- Merging two runs of sizes a, b uses \u2264 a + b \u2212 1 \u2264 a + b comparisons. Counting runs on the fly uses \u2264 n \u2212 1 comparisons (each adjacent pair is compared at most once while extending a run; run reversals use no comparisons). So total comparisons \u2264 total merge cost + O(n).\n\n2) Invariant and growth.\n- After any collapse, the stack (top R_1, next R_2, \u2026) satisfies r_{i+2} > r_{i+1} + r_i and r_{i+1} > r_i, for i in range. Proof: case analysis over #1\u2013#5 shows preservation; merges stop only when no condition holds. Consequence: r_{i+2} \u2265 2 r_i, and for any i \u2264 j \u2264 h (h = height) when about to push, r_i \u2264 2^{(i+1\u2212j)/2} r_j.\n\n3) Starting sequences cost O(n).\n- A starting sequence begins by pushing a run R of length r, then performs k \u2212 1 merges of type #2 (merging R_2,R_3,\u2026,R_k). Its cost is C \u2264 \u2211_{i=1}^k (k+1\u2212i) r_i. The last #2 implies r > r_k, hence r \u2265 r_k \u2265 2^{(k\u22121\u2212i)/2} r_i for all i; therefore C/r \u2264 2 \u2211_{j=1}^k j 2^{\u2212j/2} < \u03b3 with \u03b3 = 2 q/(1\u2212q)^2 and q = 2^{\u22121/2}; numerically \u03b3 \u2248 16.49. Summing over all starting sequences (each run starts exactly one) yields total cost \u2264 \u03b3 n = O(n).\n\n4) Ending sequences via tokens.\n- Credit rule: When a run is pushed, or when an element\u2019s height decreases due to a merge in an ending sequence, give each element 2 \u201cc-tokens\u201d and 1 \u201cs-token\u201d.\n- Spending rule per merge in an ending sequence:\n  - #2: every element of R_1 and R_2 pays 1 c-token.\n  - #3: every element of R_1 pays 2 c-tokens.\n  - #4/#5: every element of R_1 pays 1 c-token and every element of R_2 pays 1 s-token.\n- Nonnegativity of balances: In #2/#3/#4/#5, heights of the charged elements strictly decrease, so new credits (2 c + 1 s) are issued after the merge to those elements; c-token spends are thus covered. For s-tokens: #4/#5 cannot end an ending sequence; the very next action is another merge, which decreases the height of the top run and re-credits one s-token before any further s-token is spent; thus s-balances never go negative.\n\n5) Height bound after starting sequence.\n- Let run R of length r be pushed; at the end of its starting sequence, no #2 applies. The runs below (indices \u22653) were untouched since the push. From r_1 \u2264 r_3 and r_3 \u2264 2^{2\u2212h/2} r_h \u2264 2^{2\u2212h/2} n (by the growth corollary), we get r \u2264 2^{2\u2212h/2} n, hence h \u2264 4 + 2 log_2(n/r).\n- Each element of R receives \u2264 2h c-tokens and \u2264 h s-tokens over the remainder of the main loop, so O(h) tokens per element.\n\n6) Summation and entropy.\n- For a run of length r, token credits per element are O(1 + log(n/r)). Therefore total tokens (and hence total ending-sequence merge cost) is O(\u2211_i r_i (1 + log(n/r_i))) = O(n + n H).\n- Adding starting sequences (O(n)) and run detection (O(n)) yields total merge cost O(n + n H), hence total comparisons O(n + n H).\n\nExamples\n\n- Many short runs: \u2113_i \u2248 1, H \u2248 log_2 \u03c1; bound gives O(n log n). Token bound matches since h = O(log n) for each element.\n- One large run r \u2248 n and few tiny runs: H = O(1); height bound gives O(1) tokens per element in the big run; total O(n).\n\nObstacles\n\n- The s-token nonnegativity relies on the corrected Python rule (#5). Without #5 (Java\u2019s original), the immediate-follow-up-merge guarantee can fail; the token proof needs changes.\n- Galloping merge heursitics are ignored; they cannot increase comparisons beyond a + b \u2212 1 and thus do not harm the upper bound.\n\nNext steps\n\n- Curate proofs.md with full statements and proofs of: invariant, starting-sequence bound with explicit \u03b3, token lemma, height bound, and the final summation to O(n + n H).\n- Optionally, add the sharp (3/2)\u00b7nH + O(n) proof via potential \u03a6(r) = (3/2) r log_2 r: (i) balanced merges (size ratio within \u03c6^2) satisfy cost \u2264 \u0394\u03a6; (ii) group the few unbalanced merges within each ending sequence into singletons/pairs so cost \u2264 \u0394\u03a6(group) plus at most r for the first group; summing r over runs gives O(n). Lower bound inputs from Buss\u2013Knop give tightness.\n"
}