{
  "content": "# Ideas\n- The leading-constant-1 claim \u201ccomparisons \u2264 n\u00b7H + O(n)\u201d is false for TimSort (Buss\u2013Knop show \u2265(3/2)\u00b7n\u00b7H\u2212O(n) in worst case). We aim to: (i) prove the coarse entropy bound comparisons = O(n + n\u00b7H); (ii) outline the sharp bound comparisons \u2264 (3/2)\u00b7n\u00b7H + O(n).\n- We work with merge-cost (sum of sizes of merged pairs). Since merging a,b uses \u2264 a+b\u22121 comparisons, total comparisons \u2264 total merge-cost + O(n) (also +O(n) to detect runs). Thus proving merge-cost = O(n + n\u00b7H) suffices.\n\n# Rigorous lemmas toward O(n+nH)\nWe analyze patched Python TimSort, in the \u201ctranslated\u201d form with cases #1\u2013#5 (the extra #5 condition).\n\nLemma 1 (Fibonacci growth invariant).\nAt any time in the main loop, for the stack S=(R_1,\u2026,R_h) (top to bottom, lengths r_1,\u2026,r_h), we have r_{i+2} > r_{i+1} + r_i for all i\u22653; moreover, just before a push finishes (when no further merges are triggered) r_1<r_2, r_1+r_2<r_3, r_2+r_3<r_4.\nProof. By induction over updates #1\u2013#5. Case #1 shifts indices (and we know the collapse conditions are false), preserving the strict inequalities. Cases #2\u2013#5 replace some consecutive runs by their sum and shift the rest; a direct check shows r_{i+2} > r_{i+1}+r_i continues to hold for all i\u22653.\n\nCorollary 1 (exponential growth along the stack).\nWhenever a push is about to occur (no further merges triggered), for all i\u2264j\u2264h, r_i \u2264 2^{(i+1\u2212j)/2} r_j. In particular r_{i+2} \u2265 2 r_i and the sequence increases strictly.\nProof. From r_i+r_{i+1}<r_{i+2} for all i\u22651 at that moment, deduce 2 r_i \u2264 r_{i+2}. Iterating by jumps of 2 and noting monotonicity yields the inequality.\n\nDefinition (starting- vs. ending-sequence of an iteration).\nAfter pushing the new run R of length r (case #1), perform maximal #2 merges (starting-sequence), then continue with merges of type #3/#4/#5 (and possibly #2 interspersed) until no rule applies (ending-sequence). The next push then starts a new iteration.\n\nLemma 2 (starting-sequences cost O(n)).\nLet a starting-sequence merging runs R_1,\u2026,R_k (k\u22652) beneath the just-pushed run R of length r>r_k (since the last #2 no longer holds). Its total merge-cost C satisfies C \u2264 \u03b3 r, where \u03b3=2\u2211_{j\u22651} j\u00b72^{\u2212j/2} (a constant). Summing over all pushes gives O(n).\nProof. The merges produce cost C \u2264 \u2211_{i=1}^k (k+1\u2212i) r_i. By Corollary 1 applied to the pre-push stack, r \u2265 r_k \u2265 2^{(k\u22121\u2212i)/2} r_i for each i, hence C/r \u2264 \u2211_{i=1}^k (k+1\u2212i) 2^{(i+1\u2212k)/2} = 2\u2211_{j=1}^k j 2^{\u2212j/2} < \u03b3. Each element is charged at most once at the push that creates its run, so \u2211 r = n gives O(n).\n\nToken accounting for ending-sequences.\n- Credit rule: Each element receives 2 c-tokens and 1 s-token when its run is pushed; it also receives 2 c-tokens and 1 s-token whenever its height decreases due to a merge inside an ending-sequence: when merging R_1+R_2, every element of R_1 is credited; when merging R_2+R_3, every element of R_1 and R_2 is credited.\n- Spend rule per merge case:\n  \u2022 #2: every element of R_1 and R_2 pays 1 c-token (covers cost r_1+r_2 \u2265 r_2+r_3 since r_1>r_3).\n  \u2022 #3: every element of R_1 pays 2 c-tokens (cost r_1+r_2 \u2264 2 r_1).\n  \u2022 #4, #5: every element of R_1 pays 1 c-token and every element of R_2 pays 1 s-token (cost r_1+r_2 equals tokens spent).\n\nLemma 3 (nonnegativity of token balances).\nThroughout the main loop, c- and s-token balances of each element never become negative.\nProof. In any ending-sequence merge, involved elements lose tokens as per spend rule but simultaneously their heights drop, granting credits. For c-tokens, the credits per height drop dominate spends by the above schedule. For s-tokens (only spent by R_2 in #4/#5), after merging R_1+R_2 to become the top run, the patched rule (#5) plus the current sizes imply another merge must immediately follow within the same ending-sequence (no push occurs in between); that next merge decreases the height of the new top run, re-crediting 1 s-token to those elements before any further spend. Induction over the merges in the same ending-sequence proves nonnegativity.\n\nLemma 4 (height bound after starting-sequence).\nLet r be the length of the just-pushed run and h the stack height after its starting-sequence. Then h \u2264 4 + 2 log_2(n/r).\nProof. Runs at positions \u22653 were not merged in the starting-sequence. By Corollary 1 applied to the pre-push tail, r\u0304_3 \u2264 2^{2\u2212h/2} r\u0304_h \u2264 2^{2\u2212h/2} n. At the end of the starting-sequence, case #2 no longer applies, so r\u0304_1=r \u2264 r\u0304_3. Hence r \u2264 2^{2\u2212h/2} n, i.e., h \u2264 4 + 2 log_2(n/r).\n\nProposition (ending-sequences cost O(n+nH)).\nSum over all ending-sequences of merge-cost \u2264 C \u2211_runs r (1 + log_2(n/r)) = O(n + nH) for a constant C.\nProof. Each element pays O(1) tokens upon push and O(1) tokens per height level it passes through. By Lemma 4, an element in a run of length r belongs to a stack of height \u2264 O(1+log(n/r)) after its starting-sequence; its height decreases at most that many times during later ending-sequences. By Lemma 3, the total tokens minted per element suffice for all spends, so total spend (which equals ending-sequence merge-cost) is O(\u2211 r (1+log(n/r)))=O(n+nH).\n\nTheorem (coarse entropy bound for TimSort).\nOn input with greedy run lengths \u2113_1,\u2026,\u2113_r and H=\u2211 (\u2113_i/n) log_2(n/\u2113_i), patched Python TimSort performs merges of total cost O(n + nH), and hence at most O(n + nH) + O(n) comparisons overall.\nProof. Run detection is O(n). Starting-sequences cost O(n) (Lemma 2). Ending-sequences cost O(n+nH) (Proposition). The final collapse can be enforced during the main loop by appending a sentinel run of length > n (or separately charged O(n)). Since each merge uses \u2264 size\u22121 comparisons and #merges \u2264 r\u22121 \u2264 n, add O(n) to convert merge-cost to comparisons.\n\n# Examples\n- Two runs: lengths x and n\u2212x. H \u2264 1; TimSort does one merge; comparisons \u2264 n \u2264 n\u00b7H + O(n) holds.\n- r equal runs: H = log_2 r; Lemmas give O(n log r) cost; agrees with known O(n+n log r).\n\n# Obstacles\n- The s-token nonnegativity (Lemma 3) uses the patched rule #5 to force a continuation of the ending-sequence; without it (older Java variant), the next action might break the ending-sequence, and the simple s-token argument can fail.\n- The leading-constant-1 target is unachievable for TimSort; Buss\u2013Knop\u2019s bad-case family yields \u2265(3/2)\u00b7n\u00b7log n comparisons and hence \u2265(3/2)\u00b7n\u00b7H.\n\n# Next steps\n- Formalize the above proofs in proofs.md (Lemma 1/Corollary 1, Lemma 2, Lemma 3, Lemma 4, coarse theorem).\n- Add the refined (3/2)\u00b7n\u00b7H + O(n) upper bound via the potential \u03a6(r) = (3/2) r log_2 r: prove (i) merges within factor \u03c6^2 are \u201cbalanced\u201d (cost \u2264 \u0394\u03a6); (ii) group the remaining merges of each ending-sequence into singletons/pairs so each group\u2019s cost \u2264 \u0394\u03a6(group) except the first (excess \u2264 r), summing to O(n). Cite Buss\u2013Knop for matching lower bound.\n- Update output.md to state the corrected main theorem (sharp and coarse bounds).\n"
}