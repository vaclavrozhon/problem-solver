Last round corrected the target: TimSort does not satisfy comparisons ≤ n·H + O(n). For Python’s patched TimSort (with the extra case #5) we proved two bounds: (i) coarse: comparisons = O(n + n·H) via a starting/ending-sequence decomposition plus a token amortization argument; (ii) sharp: comparisons ≤ (3/2)·n·H + O(n) via potential Φ(r) = (3/2) r log2 r, grouping unbalanced merges so each group’s cost ≤ ΔΦ, with O(n) total slack. The 3/2 factor is tight (Buss–Knop family gives ≥ (3/2)·n·H − O(n)). Assumptions: Python-corrected TimSort (case #5); galloping only reduces comparisons; converting merge-cost to comparisons adds O(n).