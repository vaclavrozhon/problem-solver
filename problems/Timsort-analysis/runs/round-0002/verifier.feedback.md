Both provers correctly set the target to the true statement for TimSort: comparisons ≤ C n + C′ n H for universal constants C, C′, where H is the entropy of the run-length distribution. The requested “O(n H)” bound without the additive n term is false in general (even counting only comparisons): H can be 0 (single run), yet scanning/detection and the final invariant maintenance still take Θ(n) comparisons, and moreover Buss–Knop’s family shows that the leading constant 1 in front of nH is impossible for TimSort. So we should present the correct O(n + nH) theorem and explain the impossibility of nH-only.

Rigor audit: The stack-growth invariant (Fibonacci-type) is sound; derivation of exponential growth and the stack-height bound h ≤ 4 + 2 log2(n/r) is correct. The split into starting/ending sequences is standard; the O(n) total bound for starting sequences via the r > rk fact and the 2^{-j/2} decay is valid. The token scheme for ending sequences is carefully specified: charges for #2/#3/#4/#5 and immediate credits on height drops prevent deficits; the crucial point is that in #4/#5, elements of R2 pay 1 s-token and are re-credited before any further s-charge because another merge is forced immediately. This is explicitly justified. Per-element credits O(1+log(n/r)) follow from the height bound; summing gives O(n + nH). Translating merge-cost to comparisons and adding O(n) for run detection and control overhead is standard. Both provers also note the tight upper bound (3/2) nH + O(n); Prover 2 gives substantial proof structure (balanced merges/potential). That refinement can be finished later.

Minor nits to keep explicit: we analyze the Python-fixed rule set (with r2 + r3 ≥ r4); fold the final collapse into the main loop (or charge O(n)); and clearly state the cost model (each merge a+b, comparisons ≤ a+b−1 per merge plus O(n) scan). These are covered.

Next steps: (1) Publish a self-contained main result in output.md (done here), retaining the correct O(n + nH) form and including a full proof. (2) Optionally, complete and add the refined (3/2) nH + O(n) proof to proofs.md in a later round. (3) Briefly note in output.md/notes.md why an nH-only upper bound cannot hold for TimSort (H can be 0; and the tight worst-case constant is 3/2).