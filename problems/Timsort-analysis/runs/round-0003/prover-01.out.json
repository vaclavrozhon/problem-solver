{
  "content": "## Ideas\nWe finalize the coarse entropy-adaptivity bound for Python\u2019s patched TimSort (with case #5). We give short, checkable proofs of the key lemmas and compute an explicit constant for the starting-sequence cost. We also isolate the step that critically uses the patch (#5) to keep s-token balances nonnegative. This yields a rigorous proof that total comparisons are O(n + n\u00b7H), where H = \u2211 (\u2113_i/n) log2(n/\u2113_i).\n\n### Lemma 1 (Stack growth invariant)\nStatement. After each merge_collapse, with runs r_1 (top), r_2, \u2026, r_h, we have: (i) r_{i+1} > r_i for all i, and (ii) r_{i+2} > r_{i+1} + r_i for all i with i+2 \u2264 h.\nWhy useful here. Ensures exponential growth along the stack, enabling geometric bounds and height control.\nProof sketch. Routine case analysis on #1\u2013#5: pushing (#1) is only possible when #2\u2013#5 are false, which implies r_1<r_2, r_1+r_2<r_3, r_2+r_3<r_4; merging (#2\u2013#5) shifts indices and preserves strict superadditivity for indices \u22653. (As in paper1.)\n\nCorollary 1.1 (Exponential growth). If a run is about to be pushed, then for any i \u2264 j \u2264 h, r_i \u2264 2^{(i+1\u2212j)/2} r_j. Reason: r_{i+2} \u2265 2 r_i hence by induction r_{i+2k} \u2265 2^k r_i and r_{i+2k+1} \u2265 2^k r_i.\n\n### Lemma 2 (Starting sequences cost O(n) with explicit constant)\nStatement. Let a starting sequence begin by pushing a run R of length r, followed by k\u22121 merges #2 (k\u22652). The total merge cost in that sequence is \u2264 \u03b3\u00b7r for \u03b3 = 2\u2211_{j\u22651} j\u00b72^{\u2212j/2} = 2\u00b7\u03b1/(1\u2212\u03b1)^2 with \u03b1=2^{\u22121/2}\u22480.7071, so \u03b3\u224816.4925. Summed over all runs, the starting-sequence cost \u2264 \u03b3\u00b7n.\nProof. After pushing, merges are (R_1,R_2), \u2026, (R_{k\u22121},R_k). Cost C \u2264 \u2211_{i=1}^k (k+1\u2212i) r_i. The last #2 implies r>r_k. By Cor. 1.1 on the pre-push stack, r \u2265 r_k \u2265 2^{(k\u22121\u2212i)/2} r_i, so (k+1\u2212i)r_i \u2264 r\u00b7(k+1\u2212i)\u00b72^{(i+1\u2212k)/2}. Sum over i to obtain C/r \u2264 2\u2211_{j=1}^k j 2^{\u2212j/2} \u2264 \u03b3.\n\n### Lemma 3 (Immediate continuation after #4/#5)\nStatement. If a merge in an ending sequence is #4 or #5, the next update is necessarily another merge in the same ending sequence.\nWhy useful here. Ensures s-tokens spent by R_2 are promptly re-credited (height decreases again), keeping s-token balances nonnegative.\nProof. After #4/#5, the new top run size is r\u2032_1 = r_1+r_2 and the new second r\u2032_2 = r_3. By the triggering condition, r\u2032_1 \u2265 r\u2032_2 (for #4) or r\u2032_1 + r\u2032_2 \u2265 r\u2032_3 (for #5), so the merge_collapse loop continues with another merge, not a break.\n\n### Lemma 4 (Token balances nonnegative)\nStatement. In ending sequences, under the spending rules: #2: each element of R_1 and R_2 spends 1 c-token; #3: each element of R_1 spends 2 c-tokens; #4/#5: each element of R_1 spends 1 c-token and each element of R_2 spends 1 s-token; and the crediting rule: every height decrease mints (2 c + 1 s) per element; then no element ever has negative balances of c- or s-tokens.\nProof. c-tokens: every merge that reduces a run\u2019s height also mints \u2265 the c-tokens it spends, by design. s-tokens: only R_2 spends them in #4/#5; the next update is another merge by Lemma 3, reducing their height, and re-crediting 1 s-token before it can be spent again; the top run never spends s-tokens. Induct.\n\n### Lemma 5 (Height bound after starting sequence)\nStatement. If a run R of length r has just finished its starting sequence with current stack height h, then h \u2264 4 + 2 log2(n/r).\nWhy useful here. Bounds per-element token minting by O(1 + log(n/r)).\nProof. During R\u2019s starting sequence, runs R_3,\u2026,R_h are untouched; by Cor. 1.1 on the pre-push stack, r_3 \u2264 2^{2\u2212h/2} r_h \u2264 2^{2\u2212h/2} n. At the end of the starting sequence, #2 is false, thus r = r_1 \u2264 r_3. Hence r \u2264 2^{2\u2212h/2} n and h \u2264 4 + 2 log2(n/r).\n\n### Proposition (Coarse entropy bound)\nFor run lengths \u2113_1,\u2026,\u2113_r summing to n with entropy H, the total merge cost of TimSort is O(n + n\u00b7H), hence comparisons \u2264 O(n + n\u00b7H).\nProof. Split costs: starting-sequences contribute \u2264 \u03b3\u00b7n by Lemma 2. Ending-sequences: every comparison is paid by tokens (Lemma 4). Each element accrues at most (2 c + 1 s) per height decrease; the number of decreases is \u2264 the stack height bound after its starting sequence, which is \u2264 4 + 2 log2(n/\u2113_i) by Lemma 5. Thus minted tokens per element are O(1 + log(n/\u2113_i)), summing to O(\u2211 \u2113_i(1+log(n/\u2113_i))) = O(n + n\u00b7H). Merge cost equals tokens spent. Converting to comparisons adds at most (#merges) \u2264 r\u22121 \u2264 n\u22121, hence comparisons = O(n + n\u00b7H).\n\n## Examples\n- Toy pattern check (for Lemma 3): Suppose top four runs have sizes (r_1,r_2,r_3,r_4) with r_1+r_2 \u2265 r_3 (#4). After merging R_1 and R_2, the new top is r\u2032_1 = r_1+r_2 and second r\u2032_2 = r_3; since r\u2032_1 \u2265 r\u2032_2, the collapse loop continues (another merge), not a break.\n- Starting-sequence constant \u03b3: with \u03b1=1/\u221a2, \u03b3 = 2\u03b1/(1\u2212\u03b1)^2 \u2248 16.49; this gives a concrete bound \u2264 16.5\u00b7n for starting sequences.\n\n## Obstacles\n- The requested leading constant 1 in n\u00b7H + O(n) is unachievable for TimSort (Buss\u2013Knop examples give \u2265 (3/2)\u00b7n\u00b7H \u2212 O(n)). Our coarse proof rightly gives only O(n + n\u00b7H). The sharp constant 3/2 requires the potential argument and the grouping of merges.\n- The s-token argument crucially needs Python\u2019s corrected case #5; without it (legacy Java), the immediate follow-up merge is not guaranteed and the simple s-token proof breaks.\n\n## Next steps\n- Move Lemmas 1\u20135 and the coarse bound into proofs.md with the explicit \u03b3 constant and the reliance on case #5.\n- Add the refined analysis: potential \u03a6(r) = (3/2) r log2 r; \u201cbalanced-merge\u201d lemma (sizes within \u03c6^2 factor) have cost \u2264 \u0394\u03a6; forbidden patterns (no X X #2, no #2#2) and the pairing lemma to bound unbalanced steps; group merges per ending sequence so total cost \u2264 \u0394\u03a6 + O(r). Conclude merge cost \u2264 (3/2)\u00b7n\u00b7H + O(n), hence comparisons \u2264 (3/2)\u00b7n\u00b7H + O(n), tight by Buss\u2013Knop.\n- Keep output.md as the corrected main theorem with the 3/2 factor and the coarse O(n + n\u00b7H) bound.\n"
}