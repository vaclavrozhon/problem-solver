{
  "content": "# Scope and corrected target\n- The requested bound with leading constant 1 (comparisons \u2264 n\u00b7H + O(n)) is false for TimSort. Buss\u2013Knop exhibit run-length sequences with merge cost \u2265 (3/2)\u00b7n\u00b7log\u2082 n \u2212 O(n); since H \u2264 log\u2082 n, TimSort needs \u2265 (3/2)\u00b7n\u00b7H \u2212 O(n) comparisons on those inputs.\n- We therefore pursue: (i) a coarse entropy bound comparisons = O(n + n\u00b7H); and (ii) the sharp bound comparisons \u2264 (3/2)\u00b7n\u00b7H + O(n), tight. Throughout, we analyze Python\u2019s corrected TimSort (extra case #5); \u201cgalloping\u201d only reduces comparisons. We measure work via merge cost (sum of merged run sizes), then add O(n) for run detection and the \u22121 per merge savings.\n\n\nIdeas\n- Decompose each iteration into a starting sequence (push + maximal #2 merges) and an ending sequence (merges #3/#4/#5 until invariant is restored). Establish: starting sequences cost O(n); ending sequences cost O(n + n\u00b7H) by amortized tokens bounded per element by O(1 + log(n/\u2113)).\n- Use the corrected invariant on the stack: r_{i+2} > r_{i+1}+r_i and r_{i+1} > r_i. Consequence: \u201cFibonacci growth\u201d along the stack and a logarithmic height bound after each starting sequence.\n\n\nFormal steps (coarse bound)\n\nLemma 1 (Invariant). After each collapse, the stack (top to bottom lengths r\u2081,\u2026,r_h) satisfies r_{i+2} > r_{i+1}+r_i and r_{i+1}>r_i for 1 \u2264 i \u2264 h\u22122.\nProof (sketch). Induct on updates. Pushing (#1) happens only when none of #2\u2013#5 applies, yielding r\u2081<r\u2082, r\u2081+r\u2082<r\u2083, r\u2082+r\u2083<r\u2084. A merge (#2\u2013#5) shifts indices and preserves the inequalities. (Complete case analysis as in Auger\u2013Jug\u00e9\u2013Nicaud\u2013Pivoteau.)\n\nCorollary 1. For any i \u2264 j \u2264 h, r_i \u2264 2^{(i+1\u2212j)/2}\u00b7r_j.\nProof. From Lemma 1, 2 r_k \u2264 r_{k+2} for k \u2264 h\u22122; chaining these yields the stated inequality.\n\nLemma 2 (Starting sequences cost O(n)). If a starting sequence begins by pushing a run R of length r and performs k\u22121 merges (#2) eliminating runs R\u2081,\u2026,R_k (k\u22651), its cost C \u2264 \u03b3\u00b7r, where \u03b3 = 2\u2211_{j\u22651} j\u00b72^{-j/2} = 2\u00b7x/(1\u2212x)\u00b2 with x=2^{-1/2} (numerically \u03b3\u224816.49). Hence, summing over all runs, total starting-sequence cost is O(n).\nProof. The merges cost at most C \u2264 \u2211_{i=1}^k (k+1\u2212i) r_i. From the final #2 guard r > r_k and Corollary 1 applied to the pre-push stack, r \u2265 r_k \u2265 2^{(k\u22121\u2212i)/2} r_i. Thus C/r \u2264 \u2211 (k+1\u2212i)2^{(i+1\u2212k)/2} = 2\u2211_{j=1}^k j\u00b72^{-j/2} < \u03b3.\n\nLemma 3 (Height bound after a starting sequence). Let R have length r, and let h be the height after its starting sequence ends. Then h \u2264 4 + 2 log\u2082(n/r).\nProof. None of R\u0304\u2083,\u2026,R\u0304_h was merged during the starting sequence; Corollary 1 on the pre-push stack yields r\u0304\u2083 \u2264 2^{2\u2212h/2} n. At the end of the starting sequence, #2 no longer holds, so r = r\u0304\u2081 \u2264 r\u0304\u2083. Hence r \u2264 2^{2\u2212h/2} n \u21d2 h \u2264 4 + 2 log\u2082(n/r).\n\nLemma 4 (Token scheme for ending sequences). Credit each element 2 c-tokens and 1 s-token upon push and whenever its height decreases due to a merge within an ending sequence. Spend:\n- #2 (merge R\u2082,R\u2083): each element of R\u2081 and R\u2082 pays 1 c-token; since r\u2081>r\u2083, r\u2081+r\u2082 \u2265 r\u2082+r\u2083.\n- #3 (merge R\u2081,R\u2082 with r\u2081\u2265r\u2082): each element of R\u2081 pays 2 c-tokens; cost \u2264 2 r\u2081.\n- #4/#5 (merge R\u2081,R\u2082): each element of R\u2081 pays 1 c-token and each element of R\u2082 pays 1 s-token (exactly r\u2081+r\u2082 tokens).\nThen no element\u2019s c- or s-balance goes negative.\nProof. In #2\u2013#5, heights of R\u2081 (and maybe R\u2082) decrease, minting at least the c-tokens spent. s-tokens are only spent by R\u2082-elements in #4/#5; in Python\u2019s corrected TimSort, the next update is necessarily another merge in the same ending sequence (this is exactly where case #5 is used), so those elements\u2019 heights drop again and they regain an s-token before any s-token is required of the top run. Thus s-balances never go negative. (Without the #5 patch, this claim can fail; de Gouw et al. identified a broken invariant in the original rule.)\n\nProposition (Ending sequences cost O(n + n\u00b7H)). The total ending-sequence merge cost is O(\u2211\u1d62 \u2113\u1d62(1 + log\u2082(n/\u2113\u1d62))) = O(n + n\u00b7H).\nProof. By Lemma 3, after run i\u2019s starting sequence the height is \u2264 4 + 2 log\u2082(n/\u2113\u1d62); thus each element of that run can be credited at most O(1 + log\u2082(n/\u2113\u1d62)) times. By Lemma 4, the ending-sequence cost is exactly the number of spent tokens, which is O(\u2211 \u2113\u1d62 (1 + log\u2082(n/\u2113\u1d62))). Noting \u2211 \u2113\u1d62 log\u2082(n/\u2113\u1d62) = n\u00b7H yields O(n + n\u00b7H).\n\nLemma 5 (Comparisons vs merge cost). The total number of merges equals r\u22121 (each merge reduces the number of runs by 1), and each merge saves at least one comparison over its cost (a+b\u22121 comparisons for sizes a,b). Run detection uses \u2264 n\u22121 comparisons. Therefore comparisons \u2264 (merge cost) + O(n).\n\nTheorem (Coarse entropy bound). Python\u2019s corrected TimSort uses O(n + n\u00b7H) comparisons.\nProof. Combine Lemma 2 (starting sequences O(n)) and the Proposition (ending sequences O(n + n\u00b7H)), then apply Lemma 5.\n\n\nToward the sharp (3/2)\u00b7n\u00b7H + O(n) bound (key ingredients)\nDefine the potential \u03a6(r) = (3/2)\u00b7r\u00b7log\u2082 r (per run), and \u0394\u03a6 the variation through merges.\n\nLemma 6 (Balanced merge). If \u03c6^{\u22122} r \u2264 r\u2032 \u2264 \u03c6\u00b2 r, then merging sizes r,r\u2032 is balanced: cost \u2264 \u0394\u03a6. Proof. Let x = r/(r+r\u2032) \u2208 (\u03a6,1\u2212\u03a6) with \u03a6 = 1/(1+\u03c6\u00b2). \u0394\u03a6 = (3/2)(r+r\u2032) H(x) and H(\u03a6)\u22480.852>2/3, so \u0394\u03a6 > r+r\u2032.\n\nLemma 7 (Forbidden patterns in ending sequences). No ending sequence contains \u201c#2#2\u201d nor \u201cX X #2\u201d, where X \u2208 {#3,#4,#5}. Proof. Each pattern forces r-relations that contradict Lemma 1 and Lemma 2\u2019s consequences; see Fig. XX2 in the reference or the derivation in papers/paper1.txt.\n\nLemma 8 (Pairing unbalanced merges). If a merge X has r\u2081 < \u03c6^{\u22122} r\u2082, then it must be followed by a #3 merge, and the pair\u2019s total cost is \u2264 total \u0394\u03a6. Proof. After X, the next top lengths satisfy constraints forcing a #3 merge; with variables x = r\u2081/(r\u2081+r\u2082), y = (r\u2081+r\u2082)/(r\u2081+r\u2082+r\u2083), one shows via concavity of F(y) = (3/2)(y H(2\u22121/y)+H(y)) \u2212 (1+y) that F(y) \u2265 0 on y \u2208 [1/2,(1+\u03c6\u00b2)/(1+2\u03c6\u00b2)], hence cost \u2264 \u0394\u03a6.\n\nProposition (Ending sequence grouping). Group merges in each ending sequence so that each group is either a single balanced merge or one of the above pairs; the first group in the ending sequence may exceed its \u0394\u03a6 by \u2264 r (length of the pushed run). Hence the ending sequence cost \u2264 \u0394\u03a6(sequence) + r.\nSumming over all runs, the excess \u2211 r = O(n).\n\nFinally, telescoping \u03a6 across the whole process yields total \u0394\u03a6 = (3/2)(n log\u2082 n \u2212 \u2211 \u2113\u1d62 log\u2082 \u2113\u1d62) = (3/2)\u00b7n\u00b7H. Therefore merge cost \u2264 (3/2)\u00b7n\u00b7H + O(n), and comparisons \u2264 (3/2)\u00b7n\u00b7H + O(n). Buss\u2013Knop provide matching lower bounds.\n\n\nExamples\n- Equal-length runs (\u2113\u1d62\u2248n/r): H\u2248log\u2082 r, so our coarse bound gives O(n + n log r), consistent with classical adaptive mergesort analyses.\n- One huge run plus tiny ones: H is small; starting-sequence cost O(n) dominates, as observed in practice.\n\n\nObstacles\n- The s-token nonnegativity relies on the extra case #5; without it, a #4 merge need not be followed by another merge, breaking the refund mechanism. This is consistent with the Java bug reported by de Gouw et al.\n\n\nNext steps\n- Move the coarse proof (Lemmas 1\u20135 and the Proposition) into proofs.md, with explicit case-by-case verifications for Lemma 1 and the s-token argument.\n- Add the sharp proof skeleton: state Lemmas 6\u20138 and the grouping proposition with the functional inequality F(y) concavity; reference papers/paper1.txt for the detailed constants and domains.\n- Keep output.md with the corrected theorem: comparisons \u2264 (3/2)\u00b7n\u00b7H + O(n), tight; and list the coarse O(n + n\u00b7H) as a corollary.\n"
}