## Scope and corrected target
We analyze Python’s corrected TimSort (with the extra rule “#5”). The requested constant-1 bound comparisons ≤ n·H + O(n) is false for TimSort; the right results are:
- Coarse: comparisons = O(n + nH).
- Sharp: comparisons ≤ (3/2)·n·H + O(n), and the factor 3/2 is tight.
Galloping is ignored (it only reduces comparisons), and detecting runs costs O(n).

## Ideas: small, checkable lemmas

Lemma 1 (Stack growth invariant).
At any moment just before pushing a new run, we have r_1 < r_2, r_1 + r_2 < r_3, and for all i ≥ 3, r_i + r_{i+1} < r_{i+2}.
Why useful here: implies exponential growth along the stack.

Proof sketch. Routine case analysis of updates #1–#5 shows each preserves these inequalities; pushing (#1) occurs only when all merging conditions fail (hence r_1 < r_2, r_1 + r_2 < r_3 and r_2 + r_3 < r_4), and #2–#5 shift indices while retaining the strict “Fibonacci” growth below the top.

Corollary 2 (Geometric decay along stack).
For all i ≤ j ≤ h, r_i ≤ 2^{(i+1−j)/2} r_j.
Why useful here: converts weighted starting-sequence sums to a constant·r bound.

Lemma 3 (Starting sequences cost ≤ 16.5·n).
When a run R of size r is pushed and absorbed by k−1 merges #2 with underlying runs (k≥2), the total cost C satisfies C ≤ γ r with γ = 2 Σ_{j≥1} j 2^{-j/2} = 2·x/(1−x)^2 with x=2^{-1/2} = 16.485…; summing over pushes gives total starting-sequence cost ≤ 16.5·n.
Why useful here: isolates a linear term; entropy term arises in ending sequences.

Proof. If the last #2 holds then r > r_k; by Cor. 2, r ≥ r_k ≥ 2^{(k−1−i)/2} r_i, so C/r ≤ Σ_{i=1}^k (k+1−i)·2^{(i+1−k)/2} = 2 Σ_{j=1}^k j·2^{-j/2} < γ.

Lemma 4 (Height after starting sequence).
If the just-pushed run has length r, the height h afterwards satisfies h ≤ 4 + 2 log2(n/r).
Why useful here: caps how many height decreases (and therefore token credits) any element can experience during the ending sequence.

Proof. From Lemma 1 and “no more #2 now”, r = r_1 ≤ r_3 ≤ 2^{2−h/2} n, hence h ≤ 4 + 2 log2(n/r).

Lemma 5 (Token amortization for ending sequences).
Credit per element whenever its height decreases due to an ending-sequence merge: 2 C-tokens and 1 S-token. Spending: #2 spends 1 C on each of R_1,R_2; #3 spends 2 C on R_1; #4/#5 spend 1 C on R_1 and 1 S on R_2. Then balances never go negative in ending sequences.
Why useful here: shows ending-sequence merge-cost equals minted tokens, so we can bound by O(Σ r (1+log(n/r))).

Proof. Each spend coincides with height decreases (thus credits) of the same elements: C-tokens cover all C-spends. For S-tokens: after #4/#5, the merged top becomes ≥ second and top+second ≥ third, forcing another merge in the same ending sequence (this is where #5 is used); thus the R_2-elements regain their S-token on the very next merge. Induct.

Lemma 6 (Ending sequence total cost).
For a run R of size r, by Lemma 4 each element’s height can decrease in at most O(1 + log(n/r)) steps; with fixed per-step credits, the minted tokens per element are O(1 + log(n/r)), hence the ending-sequence cost for R is O(r (1 + log(n/r))). Summing over runs yields O(n + Σ r_i log(n/r_i)) = O(n + nH).

Lemma 7 (Comparisons vs. merge-cost).
Counting runs costs O(n) comparisons. Each merge of a,b uses ≤ a+b−1 comparisons, hence total comparisons ≤ (total merge-cost) − (ρ−1) + O(n) ≤ (total merge-cost) + O(n).

Conclusion (coarse). By Lemma 3 + Lemma 6 + Lemma 7, TimSort performs O(n + nH) comparisons.

## Towards the sharp constant 3/2 (succinct, testable pieces)

Potential Φ(r) = (3/2) r log2 r.

Lemma 8 (Balanced merge criterion).
If two run sizes satisfy φ^{−2} r ≤ r′ ≤ φ^{2} r, then cost(r,r′) ≤ ΔΦ.
Why useful here: most merges in ending sequences are balanced and paid by potential.

Proof sketch. Let x = r/(r+r′). Then ΔΦ = (3/2)(r+r′) H(x). For x ∈ [1/(1+φ^2), 1−1/(1+φ^2)], H(x) ≥ H(1/(1+φ^2)) ≈ 0.85 > 2/3, so ΔΦ > r+r′.

Lemma 9 (Forbidden patterns in ending sequences).
No ending sequence contains #2#2, nor XX#2 (where X∈{#3,#4,#5}).
Why useful here: enables grouping of unbalanced merges into small groups whose combined cost is covered by potential.

Proof sketch. Both patterns force contradictory inequalities with Lemma 1 and Lemma 2; cf. AJNP (Fig. XX2) for a case-by-case contradiction.

Lemma 10 (Pairing unbalanced merges).
If a merge X of R_1,R_2 is too unbalanced (r_1 ≪ r_2), it is immediately followed by #3 (by Lemma 9); the two consecutive merges together satisfy cost ≤ ΔΦ(pair).
Why useful here: localizes unbalanced work into paid groups.

Lemma 11 (First-merge slack per ending sequence).
The first merge of an ending sequence may exceed its potential increase by at most r (length of the just-pushed run). Summing over all runs adds ≤ n slack.

Conclusion (sharp). Summing ΔΦ over all merges telescopes to −(3/2) Σ r_i log2(r_i) = (3/2) n·H. With grouping (Lemmas 8–11) and +O(n) slack, total merge-cost ≤ (3/2)·n·H + O(n), hence comparisons ≤ (3/2)·n·H + O(n). Buss–Knop’s family shows ≥ (3/2)·n·H − O(n): factor 3/2 is tight.

## Examples / sanity checks
- Small stack r=(5,7,11,17): #4 triggers (5+7≥11), then #3 triggers next; S-token is reimbursed as claimed in Lemma 5.
- Attempt to realize #2#2: inequalities force r_1+r_2 ≥ r_5 and r_3+r_4 < r_5 with r_2<r_4; contradiction since r_1+r_2 < r_3+r_4 fails.

## Obstacles
- Lemma 5 relies on the extra #5 rule; without it, S-tokens can break (this matches the original Java bug). Our scope is Python’s fixed TimSort.

## Next steps
- Move the detailed proofs of Lemmas 1–7 into proofs.md to finalize the O(n + nH) bound with explicit constant γ ≈ 16.49 for starting sequences.
- Add concise proofs of Lemmas 8–11 (potential method) to complete the (3/2)·n·H + O(n) bound, and cite the Buss–Knop lower bound family.
- Keep output.md to the corrected main theorem and the coarse statement.
