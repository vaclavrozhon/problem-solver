{
  "content": "# Ideas\n- Solidify the O(n + nH) bound by isolating two rigorously checkable components: (i) a precise constant for the total cost of all starting sequences; (ii) a clean height bound after starting sequences and a tight token accounting for ending sequences.\n- Provide explicit constants in the starting-sequence bound (\u03b3 \u2248 16.49), and a short, self-contained proof of the height bound h \u2264 4 + 2 log2(n/r).\n- Record an explicit conversion from merge-cost to comparisons (merging a,b takes \u2264 a+b\u22121 comparisons) and the run-detection O(n) overhead.\n\n# Starting sequences: explicit constant\nLemma (Starting sequences cost).\nFix a stack S=(R_1,\u2026,R_h) before a push, and let a run R of length r be pushed. If the starting sequence comprises k\u22121 \u2265 1 merges #2 of the pre-existing runs R_1,\u2026,R_k, then its merge-cost C satisfies\nC \u2264 \u03b3 r with \u03b3 = 2\u2211_{j\u22651} j\u00b72^{\u2212j/2} = 2\u00b7x/(1\u2212x)^2 for x=2^{\u22121/2} \u2248 0.7071, hence \u03b3 \u2248 16.4853.\nSumming over all pushes (\u2211 r = n) yields total starting-sequence cost \u2264 \u03b3 n.\nProof.\nWe have C \u2264 \u2211_{i=1}^k (k+1\u2212i)r_i. At the last #2, r>r_k. Applying the exponential growth corollary (just before the push) gives r \u2265 r_k \u2265 2^{(k\u22121\u2212i)/2} r_i, so\nC/r \u2264 \u2211_{i=1}^k (k+1\u2212i)2^{(i+1\u2212k)/2} = 2\u2211_{j=1}^k j 2^{\u2212j/2} < 2\u2211_{j\u22651} j 2^{\u2212j/2}.\nUsing \u2211_{j\u22651} j x^j = x/(1\u2212x)^2 with x=2^{\u22121/2} finishes the constant computation.\n\n# Height bound after a starting sequence\nLemma (Height bound).\nLet r be the length of the just-pushed run and h the stack height after its starting sequence. Then h \u2264 4 + 2 log_2(n/r).\nProof.\nRuns at depth \u22653 were not merged during the starting sequence, so in the pre-push tail the exponential-growth corollary gives r\u0304_3 \u2264 2^{2\u2212h/2} r\u0304_h \u2264 2^{2\u2212h/2} n. At the end of the starting sequence, #2 no longer applies, hence r\u0304_1=r \u2264 r\u0304_3, so r \u2264 2^{2\u2212h/2} n, i.e. h \u2264 4 + 2 log_2(n/r).\n\n# Ending sequences: token accounting and entropy\nToken scheme.\n- Credits: When a run is pushed, each element gets 2 c-tokens + 1 s-token; whenever its height decreases due to an ending-sequence merge, it gets 2 c + 1 s again.\n- Spends per merge (with current top runs R_1,R_2,R_3):\n  \u2022 #2 (merge R_2,R_3): each element of R_1 and R_2 pays 1 c-token (r_1+r_2 tokens \u2265 r_2+r_3 by r_1>r_3).\n  \u2022 #3 (merge R_1,R_2): each element of R_1 pays 2 c-tokens (cost r_1+r_2 \u2264 2r_1).\n  \u2022 #4/#5 (merge R_1,R_2): each element of R_1 pays 1 c, each element of R_2 pays 1 s (exactly r_1+r_2 tokens).\n\nClaim (Nonnegativity of token balances).\nFor every element, c- and s-token balances never become negative throughout the main loop.\nSketch.\nEach ending-sequence merge that reduces an element\u2019s height immediately re-credits (2 c, 1 s); the charged c-spends are dominated by these credits by inspection of #2\u2013#5. For s-tokens (spent only by R_2 in #4/#5), after merging R_1+R_2 the new top run ensures another merge immediately follows (either by #3 because r\u0304_1\u2265r\u0304_2 after #4, or by the patched #5 condition), re-crediting the s-token before any further spend. Induction over the merges in the same ending sequence concludes.\n\nCost bound for ending sequences.\nBy the height bound, an element in a run of length r sees at most O(1+log(n/r)) height decreases over all future ending-sequences; it receives at most O(1+log(n/r)) credits of (2 c + 1 s), and (by nonnegativity) spends no more than that many tokens in total. Summing tokens over all elements gives\nending-sequence merge-cost \u2264 C\u2211_runs r (1 + log_2(n/r)) = O(n + \u2211_i \u2113_i log_2(n/\u2113_i)) = O(n + nH).\n\n# Comparisons vs. merge-cost and run detection\n- Merging two runs of sizes a,b uses \u2264 a+b\u22121 comparisons; thus total comparisons for merges \u2264 total merge-cost. The number of merges is (r\u22121), but we do not need this saving for an upper bound.\n- Detecting the greedy runs costs O(n) comparisons via a single scan.\nConclusion (coarse bound). Total comparisons \u2264 \u03b3 n (starting) + O(n+nH) (ending) + O(n) (run detection) = O(n + nH).\n\n# Examples\n- Two runs (\u2113_1=x, \u2113_2=n\u2212x): H \u2264 1; TimSort does one merge; comparisons \u2264 n \u2264 n\u00b7H + O(n).\n- r equal runs (\u2113_i = n/r): H = log_2 r; the above yields O(n log r) comparisons.\n\n# Obstacles\n- The target \u201c\u2264 n\u00b7H + O(n)\u201d with leading constant 1 is false for TimSort: Buss\u2013Knop give inputs with merge-cost \u2265 (3/2)\u00b7n\u00b7log n \u2212 O(n), i.e., \u2265 (3/2)\u00b7n\u00b7H \u2212 O(n). The sharp bound is (3/2)\u00b7n\u00b7H + O(n), tight.\n- The s-token argument relies on the patched Python rule (#5) to force a subsequent merge after a #5-spend; we analyze that variant.\n\n# Next steps\n- Move these two lemmas (starting-sequence constant and height bound) into proofs.md with full details.\n- Add the refined potential-analysis (\u03a6(r)=(3/2) r log_2 r) for the sharp (3/2)\u00b7n\u00b7H + O(n) bound: (i) prove \u201cbalanced\u201d merges within factor \u03c6^2 satisfy cost \u2264 \u0394\u03a6; (ii) prove the pairing lemma for unbalanced #X merges; (iii) use grouping plus the forbidden patterns to charge at most +r slack per ending sequence; sum to O(n).\n- Optionally, record explicit constants in the O(n) terms, and note the conversion comparisons \u2264 merge-cost + O(n) (for run detection)."
}