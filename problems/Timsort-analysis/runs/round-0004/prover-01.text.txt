## Aim of this round
Provide auditable, explicit-constant bounds for the coarse entropy-adaptivity of Python’s patched TimSort (with case #5): comparisons = O(n + n·H). We isolate two pieces with full details: (i) starting-sequence cost with a closed-form constant γ, and (ii) an explicit constant bound for ending-sequence costs via token accounting and the stack-height lemma. This gives a concrete coarse bound comparisons ≤ 6 n H + C n for a universal constant C.

## Setting and notation
- Input of length n with greedy run decomposition lengths ℓ_1,…,ℓ_r (∑ℓ_i=n). Entropy H = ∑ (ℓ_i/n) log2(n/ℓ_i).
- Merge cost of merging lengths a,b is a+b; comparisons for a merge ≤ (a+b−1).
- Python’s corrected merge-cascade with cases #1–#5 (case #5 present). Galloping only decreases comparisons.
- We decompose updates into starting sequences (#1 then maximal #2’s) and ending sequences (beginning with #3/#4/#5, possibly interleaved with #2’s, but no #1).
- Stack invariant (proved by routine case analysis): r_{i+1}>r_i and r_{i+2}>r_{i+1}+r_i after each collapse; consequence: r_{i+2}≥2 r_i and, just before a push, r_i ≤ 2^{(i+1−j)/2} r_j for i≤j.

## 1) Explicit constant for starting sequences
Lemma (Geometric bound with constant). If a run R of length r begins a starting sequence of k≥2 steps (#1 then k−1 merges #2), the total merge cost within that sequence is ≤ γ·r, where
γ = 2 ∑_{j≥1} j·2^{−j/2} = 2·α/(1−α)^2 with α=2^{−1/2} ≈ 0.7071, thus γ ≈ 16.4925.
Proof. If the pre-push stack is S=(R_1,…,R_h), then the k−1 merges #2 are (R_1,R_2), …,(R_{k−1},R_k). Total cost C ≤ ∑_{i=1}^k (k+1−i) r_i. The last #2 implies r>r_k. By the pre-push exponential growth, r ≥ r_k ≥ 2^{(k−1−i)/2} r_i. Hence (k+1−i) r_i ≤ r·(k+1−i)·2^{(i+1−k)/2}. Summing over i gives
C/r ≤ 2∑_{j=1}^k j 2^{−j/2} ≤ 2∑_{j≥1} j 2^{−j/2} = γ.
Summing over all runs R (each begins exactly one starting sequence) yields StartingCost ≤ γ·n.

## 2) Explicit constant for ending sequences via tokens and height bound
Token scheme (patched Python, case #5 used): whenever an element’s height decreases within an ending sequence, credit it with 2 c-tokens and 1 s-token; spend tokens on merges as follows: #2: each element of R_1 and R_2 spends 1 c; #3: each element of R_1 spends 2 c; #4/#5: each element of R_1 spends 1 c and each element of R_2 spends 1 s. A standard argument shows balances never go negative; crucially, after #4/#5 there is necessarily a follow-up merge in the same ending sequence (case #5 guarantees immediate continuation), so s-tokens are re-credited on the next height decrease before they could be spent again. Thus, total ending-sequence merge cost equals total tokens minted in ending sequences.

Height bound after a starting sequence. If a run R of length r has just finished its starting sequence and the stack height is h, then h ≤ 4 + 2 log2(n/r). Proof: runs below index 3 were untouched; by exponential growth before the push, r_3 ≤ 2^{2−h/2} n; at end of the starting sequence, #2 is false, so r = r_1 ≤ r_3 ≤ 2^{2−h/2} n; rearrange.

Minted tokens bound. Each height decrease for an element mints (2 c + 1 s)=3 tokens; the number of decreases an element can undergo is at most the stack height when its starting sequence ends. Therefore the total tokens minted for elements of run i (length ℓ_i) is ≤ 3·(4 + 2 log2(n/ℓ_i))·ℓ_i. Summing over i,
EndingCost ≤ ∑_{i=1}^r 3(4 + 2 log2(n/ℓ_i)) ℓ_i = 12 n + 6 ∑ ℓ_i log2(n/ℓ_i) = 12 n + 6 n H.

## 3) Coarse explicit-constant bound on comparisons
Total merge cost ≤ StartingCost + EndingCost ≤ γ n + (12 n + 6 n H) = 6 n H + (γ+12) n.
The number of comparisons over all merges is at most (merge cost − (#merges)), but we can upper bound simply by the merge cost. Add O(n) for run detection and for the final collapse (or realize it via a sentinel run). Hence there exists an absolute constant C (e.g., C=γ+13 ≈ 29.5) such that
Comparisons(TimSort) ≤ 6 n H + C n.

This gives an explicit coarse entropy-adaptive bound (with a loose factor 6 on H) that is fully justified by the above lemmas. It matches the classical O(n + n H) form and is adequate for the coarse result.

## Examples and sanity checks
- One run (ℓ_1=n): H=0, bound gives ≤ C n comparisons, consistent: TimSort detects sorted input and performs no merges, O(n).
- All runs of length 1: H=log2 n, bound gives ≤ 6 n log2 n + C n.
- Two runs (a,b): H ≤ 1, bound ≤ 6 n + C n = O(n).

## Obstacles
- The constant factor 6 on H is not tight; improving to the sharp factor 3/2 requires the potential method with Φ(r)=(3/2) r log2 r, the balanced-merge lemma (sizes within φ²), forbidden patterns (no #2#2 and no XX#2), the pairing lemma for unbalanced merges, and grouping per ending sequence. Those ingredients are already outlined; a full write-up is the next step.
- The s-token nonnegativity critically uses the corrected #5 rule; the legacy Java variant needs different handling.

## Next steps
- Move the above explicit-constant coarse proof (γ and 12 constants, height lemma, token argument, case #5 reliance) into proofs.md.
- Add the refined potential-function proof to reach the sharp (3/2)·n·H + O(n) comparisons, citing or re-proving the functional inequality in the pairing lemma and the forbidden-pattern lemma.
- Keep output.md’s corrected main theorem and include the coarse bound as a secondary statement.
