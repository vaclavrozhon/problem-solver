{
  "content": "# Focused progress toward the coarse O(n + nH) bound\n\nI isolate three technical steps that are both standard and critical to the entropy-adaptivity proof for Python\u2019s patched TimSort (with case #5). Each is stated and proven cleanly so they can be dropped into proofs.md.\n\n\n1) Immediate follow-up merges after #4/#5 (s-token refund)\n\nLemma (follow-up after #4/#5). Consider the stack just after merging the top two runs R\u2081 and R\u2082 by one of the conditions #4 or #5. Denote new top runs by R\u0304\u2081, R\u0304\u2082, R\u0304\u2083 with lengths r\u0304\u2081, r\u0304\u2082, r\u0304\u2083. Then the very next loop iteration must perform another merge (either #3 or #4). In particular, the algorithm does not break between these two merges.\n\nProof. Case #4 triggers when r\u2081 + r\u2082 \u2265 r\u2083. After merging R\u2081 and R\u2082, we have r\u0304\u2081 = r\u2081 + r\u2082, r\u0304\u2082 = r\u2083, r\u0304\u2083 = r\u2084. The next test in order is #2 (r\u0304\u2081 > r\u0304\u2083), which may fail. The following test is #3 (r\u0304\u2081 \u2265 r\u0304\u2082). Since r\u0304\u2081 = r\u2081 + r\u2082 \u2265 r\u2083 = r\u0304\u2082, #3 holds and a merge occurs. \n\nCase #5 triggers when r\u2082 + r\u2083 \u2265 r\u2084. After merging R\u2081 and R\u2082, we again have r\u0304\u2081 = r\u2081 + r\u2082, r\u0304\u2082 = r\u2083, r\u0304\u2083 = r\u2084. The next test #4 requires r\u0304\u2081 + r\u0304\u2082 \u2265 r\u0304\u2083, which holds because (r\u0304\u2081 + r\u0304\u2082) = (r\u2081 + r\u2082) + r\u2083 \u2265 r\u2084 = r\u0304\u2083 (using r\u2082 + r\u2083 \u2265 r\u2084). Hence #4 holds and a merge occurs. \u220e\n\nWhy useful here. This establishes that every s-token spent by elements of R\u2082 in a #4/#5 merge is refunded immediately at the next merge in the same ending sequence (height decreases), ensuring s-token balances never go negative.\n\n\n2) Explicit constant for starting sequences\n\nLemma (explicit \u03b3). Let \u03b3 := 2\u2211_{j\u22651} j\u00b72^{\u2212j/2}. Then \u03b3 has the closed form \u03b3 = 2\u00b7x/(1\u2212x)\u00b2 with x=2^{\u22121/2}. Numerically, x\u22480.70710678 and \u03b3\u224816.4853. \n\nProof. For |x|<1, \u2211_{j\u22651} j x^{j} = x/(1\u2212x)\u00b2. Set x=2^{\u22121/2} to get \u2211 j 2^{\u2212j/2} = x/(1\u2212x)\u00b2 and multiply by 2. \u220e\n\nWhy useful here. It gives an explicit universal constant bounding the total cost of each starting sequence by \u2264 \u03b3\u00b7r and hence total starting-sequence cost \u2264 \u03b3\u00b7n.\n\n\n3) Sentinel for final collapse (absorbing line-11 merges)\n\nClaim (sentinel absorption). Appending a fictitious terminal run of length n+1 to the run decomposition makes the final collapse merges occur within the main loop. The coarse O(n + nH) bound is unaffected.\n\nProof. With a terminal run T of length > n, every remaining stack merge is triggered by #3 (top run length \u2265 next), so the main loop performs exactly the merges of the final collapse. The sentinel contributes no comparisons beyond O(n) for merges already bounded, and we remove it analytically at the end. \u220e\n\nWhy useful here. It lets us bound all merges inside one loop, avoiding a separate end-phase analysis.\n\n\n4) Entropy identity used in the summation\n\nFact. \u2211_{i=1}^r \u2113_i log\u2082(n/\u2113_i) = n\u00b7H, where H = \u2211 (\u2113_i/n) log\u2082(n/\u2113_i).\n\nProof. Expand: \u2211 \u2113_i log\u2082(n/\u2113_i) = \u2211 \u2113_i( log\u2082 n \u2212 log\u2082 \u2113_i ) = (\u2211 \u2113_i) log\u2082 n \u2212 \u2211 \u2113_i log\u2082 \u2113_i = n log\u2082 n \u2212 \u2211 \u2113_i log\u2082 \u2113_i. On the other hand, n\u00b7H = n \u2211 (\u2113_i/n) log\u2082(n/\u2113_i) = \u2211 \u2113_i log\u2082(n/\u2113_i). \u220e\n\nWhy useful here. Converts the token-minted sum \u2211 \u2113_i\u00b7log(n/\u2113_i) into n\u00b7H.\n\n\nExamples / sanity checks\n- After a #4 merge of lengths (3,5,7,13), new top is (8,7,13); #3 (8\u22657) triggers immediately. After a #5 merge of (2,8,9,15) (since 8+9\u226515), new top is (10,9,15); #4 holds ((10+9)\u226515), so a merge follows.\n\n\nObstacles\n- The s-token proof requires case #5 to be present in TimSort; without it, the algorithm may not perform the #5 merge in the first place and the amortization structure differs (this is consistent with the original Java bug). Our target explicitly analyzes Python\u2019s corrected variant.\n\n\nNext steps\n- Incorporate these lemmas into proofs.md: (i) immediate follow-up after #4/#5; (ii) explicit \u03b3; (iii) sentinel absorption; (iv) entropy identity. This will complete the coarse O(n + nH) proof with all details accounted for. \n- In a subsequent round, we can formalize the \u201cforbidden patterns\u201d lemma (no #2#2, no XX#2) and the two-merge pairing inequality F(y)\u22650 for the sharp (3/2)\u00b7n\u00b7H + O(n) bound.\n"
}