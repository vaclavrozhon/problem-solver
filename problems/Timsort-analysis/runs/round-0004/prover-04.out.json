{
  "content": "## Context and corrected target\n- The leading-constant 1 statement \u201cTimSort uses \u2264 n\u00b7H + O(n) comparisons\u201d is false for TimSort (Buss\u2013Knop: merge-cost \u2265 (3/2)\u00b7n\u00b7log n \u2212 O(n); since H \u2264 log n, comparisons \u2265 (3/2)\u00b7n\u00b7H \u2212 O(n) on those inputs).\n- Correct bounds for Python\u2019s patched TimSort (extra case #5):\n  - Coarse: comparisons = O(n + nH).\n  - Sharp: comparisons \u2264 (3/2)\u00b7n\u00b7H + O(n), tight.\n\nBelow I supply small, testable lemmas and detailed proofs that the verifier can move to proofs.md to finalize the coarse O(n + nH) bound and prepare the sharp bound.\n\n\n## Lemma A (stack growth invariant) and Corollary A\u2019\nStatement. Just before pushing a new run, we have r_1 < r_2, r_1 + r_2 < r_3, and for all i \u2265 3, r_i + r_{i+1} < r_{i+2}. Consequently, for all 1 \u2264 i \u2264 j \u2264 h,\n  r_i \u2264 2^{(i+1\u2212j)/2}\u00b7r_j.\n\nProof (sketch). A routine case analysis on updates #1\u2013#5 (using the Python-corrected rules) shows each preserves these inequalities; #1 occurs only when all merge conditions fail, giving r_1 < r_2, r_1 + r_2 < r_3, and r_2 + r_3 < r_4. From r_i + r_{i+1} < r_{i+2} and r_i < r_{i+1}, we get 2 r_i \u2264 r_{i+2}. Iterating yields the geometric decay bound.\n\nWhy useful. Exponential growth along the stack is the backbone for bounding starting sequences.\n\n\n## Lemma B (starting-sequence cost with explicit constant)\nStatement. If pushing a run R of size r triggers k\u22121 merges of type #2 with underlying runs (k \u2265 2), then the total merge cost C is \u2264 \u03b3\u00b7r with\n  \u03b3 = 2\u00b7\u03a3_{j\u22651} j\u00b72^{\u2212j/2} = 2\u00b7x/(1\u2212x)^2 for x=2^{\u22121/2} \u2248 16.485.\nSumming over all pushes gives total starting-sequence cost \u2264 \u03b3\u00b7n.\n\nProof. After the push, the cost is C \u2264 \u03a3_{i=1}^k (k+1\u2212i)\u00b7r_i. The last #2 ensures r > r_k. By Corollary A\u2019, r \u2265 r_k \u2265 2^{(k\u22121\u2212i)/2}\u00b7r_i, hence\n  C/r \u2264 \u03a3_{i=1}^k (k+1\u2212i)\u00b72^{(i+1\u2212k)/2} = 2\u00b7\u03a3_{j=1}^k j\u00b72^{\u2212j/2} < 2\u00b7\u03a3_{j\u22651} j\u00b72^{\u2212j/2}.\nEvaluate \u03a3_{j\u22651} j x^j = x/(1\u2212x)^2 with x=2^{\u22121/2}; numerical constant as stated. Each run begins exactly one starting sequence and \u03a3 r = n.\n\nWhy useful. Isolates a linear O(n) contribution.\n\n\n## Lemma C (height bound after starting sequence)\nStatement. If the just-pushed run has length r and its starting sequence ended, the stack height h satisfies h \u2264 4 + 2\u00b7log2(n/r).\n\nProof. At end of the starting sequence, #2 no longer triggers, so r = r_1 \u2264 r_3. By Lemma A, r_3 \u2264 2^{2\u2212h/2}\u00b7n. Hence r \u2264 2^{2\u2212h/2}\u00b7n, i.e., h \u2264 4 + 2\u00b7log2(n/r).\n\nWhy useful. Caps per-element height decreases in ending sequences by O(1 + log(n/r)).\n\n\n## Lemma D (token amortization for ending sequences)\nStatement. Credit 2 \u201cC\u201d-tokens and 1 \u201cS\u201d-token to each element whenever its height decreases due to a merge within an ending sequence. Spend tokens as follows: #2 spends 1 C on each of R_1,R_2; #3 spends 2 C on R_1; #4/#5 spend 1 C on R_1 and 1 S on R_2. Then no element ever has negative C- or S-balance during an ending sequence.\n\nProof. C-tokens: every spend coincides with (and is at most) the number of height decreases on the same element, so the per-decrease credit covers the cost. S-tokens: consider a #4 or #5 merge of R_1,R_2 into S. Under the corrected rule (#5 present), the updated top satisfies either S \u2265 next or S+next \u2265 next-next, so the inner loop must continue with another merge (either #3 or #4/#5). Thus elements from R_2 immediately see another merge, their height drops again, and they are credited an S-token before any further S-spend; hence S-balances never go negative. Induct over the sequence of merges in the ending sequence.\n\nWhy useful. Shows ending-sequence merge cost equals total minted tokens.\n\n\n## Lemma E (ending-sequence cost sums to O(n + nH))\nStatement. For the run R of size r just pushed, its ending sequence consumes O(r\u00b7(1 + log(n/r))) tokens. Summing over all runs yields O(n + \u03a3 r_i\u00b7log(n/r_i)) = O(n + nH).\n\nProof. By Lemma C, each element in R can undergo at most O(1 + log(n/r)) height decreases in the ending sequence. The fixed per-decrease credit (Lemma D) bounds total tokens for these elements by O(1 + log(n/r)) each. Summing over the r elements of R gives O(r\u00b7(1 + log(n/r))). Summing over all runs gives O(\u03a3 r_i) + O(\u03a3 r_i\u00b7log(n/r_i)) = O(n) + O(nH).\n\n\n## Lemma F (comparisons vs. merge-cost)\nStatement. Detecting runs costs at most n\u22121 comparisons. Each merge of sizes a,b uses \u2264 a+b\u22121 comparisons. Hence total comparisons \u2264 (total merge-cost) \u2212 (\u03c1\u22121) + (n\u22121) = (total merge-cost) + O(n).\n\nProof. Standard; each merge eliminates one run and the initial detection uses \u2264 one comparison per adjacent pair.\n\n\n## Coarse Theorem (TimSort comparisons = O(n + nH))\nCombine Lemma B (starting-sequence cost \u2264 \u03b3\u00b7n) and Lemma E (ending sequences sum to O(n + nH)) to bound total merge-cost by O(n + nH). Apply Lemma F to convert to comparisons, adding O(n), to conclude comparisons = O(n + nH).\n\n\n## Sharp bound scaffolding (factor 3/2)\nPotential \u03a6(r) = (3/2)\u00b7r\u00b7log2 r. The following lemmas (standard in AJNP) suffice to conclude total merge-cost \u2264 \u0394\u03a6 + O(n) = (3/2)\u00b7n\u00b7H + O(n):\n- Balanced-merge lemma: if \u03c6^{\u22122}\u00b7r \u2264 r\u2032 \u2264 \u03c6^{2}\u00b7r then merge-cost \u2264 \u0394\u03a6.\n- Forbidden patterns: no #2#2 and no XX#2 (X\u2208{#3,#4,#5}).\n- Pairing lemma: if an X-merge is too unbalanced, it is immediately followed by #3; the pair\u2019s total cost \u2264 pair \u0394\u03a6.\n- First-merge slack: the first merge in each ending sequence may exceed \u0394\u03a6 by \u2264 r (length of just-pushed run). Summing these slacks over all runs gives O(n).\nThen \u0394\u03a6 telescopes to (3/2)\u00b7n\u00b7H. By Lemma F, comparisons \u2264 (3/2)\u00b7n\u00b7H + O(n). Buss\u2013Knop give a matching lower bound family.\n\n\n## Example sanity checks\n- Stack (5,7,11,17): #4 merges 5,7\u219212; next #3 merges 12,11; S-tokens are reimbursed as in Lemma D.\n- Attempt to realize #2#2: inequalities from Lemma A force r_1+r_2 \u2265 r_5 and r_3+r_4 < r_5 with r_2 < r_4; contradiction because then r_1+r_2 < r_3+r_4.\n\n\n## Obstacles\n- Lemma D depends on the corrected Python rule (#5). The original Java variant lacks this guarantee; our proofs target the patched version only.\n\n\n## Next steps for proofs.md / output.md\n- Add full proofs of Lemmas A\u2013F (above) to finalize the coarse O(n + nH) bound with explicit \u03b3 \u2248 16.485.\n- Add the potential-function pieces for the sharp (3/2)\u00b7n\u00b7H + O(n) and cite AJNP for the precise inequalities and forbidden-pattern proof; include the concavity check for the two-merge pairing function F.\n- Keep output.md with the corrected main theorem (sharp) and the coarse bound.\n"
}