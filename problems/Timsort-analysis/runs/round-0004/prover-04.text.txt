## Context and corrected target
- The leading-constant 1 statement “TimSort uses ≤ n·H + O(n) comparisons” is false for TimSort (Buss–Knop: merge-cost ≥ (3/2)·n·log n − O(n); since H ≤ log n, comparisons ≥ (3/2)·n·H − O(n) on those inputs).
- Correct bounds for Python’s patched TimSort (extra case #5):
  - Coarse: comparisons = O(n + nH).
  - Sharp: comparisons ≤ (3/2)·n·H + O(n), tight.

Below I supply small, testable lemmas and detailed proofs that the verifier can move to proofs.md to finalize the coarse O(n + nH) bound and prepare the sharp bound.


## Lemma A (stack growth invariant) and Corollary A’
Statement. Just before pushing a new run, we have r_1 < r_2, r_1 + r_2 < r_3, and for all i ≥ 3, r_i + r_{i+1} < r_{i+2}. Consequently, for all 1 ≤ i ≤ j ≤ h,
  r_i ≤ 2^{(i+1−j)/2}·r_j.

Proof (sketch). A routine case analysis on updates #1–#5 (using the Python-corrected rules) shows each preserves these inequalities; #1 occurs only when all merge conditions fail, giving r_1 < r_2, r_1 + r_2 < r_3, and r_2 + r_3 < r_4. From r_i + r_{i+1} < r_{i+2} and r_i < r_{i+1}, we get 2 r_i ≤ r_{i+2}. Iterating yields the geometric decay bound.

Why useful. Exponential growth along the stack is the backbone for bounding starting sequences.


## Lemma B (starting-sequence cost with explicit constant)
Statement. If pushing a run R of size r triggers k−1 merges of type #2 with underlying runs (k ≥ 2), then the total merge cost C is ≤ γ·r with
  γ = 2·Σ_{j≥1} j·2^{−j/2} = 2·x/(1−x)^2 for x=2^{−1/2} ≈ 16.485.
Summing over all pushes gives total starting-sequence cost ≤ γ·n.

Proof. After the push, the cost is C ≤ Σ_{i=1}^k (k+1−i)·r_i. The last #2 ensures r > r_k. By Corollary A’, r ≥ r_k ≥ 2^{(k−1−i)/2}·r_i, hence
  C/r ≤ Σ_{i=1}^k (k+1−i)·2^{(i+1−k)/2} = 2·Σ_{j=1}^k j·2^{−j/2} < 2·Σ_{j≥1} j·2^{−j/2}.
Evaluate Σ_{j≥1} j x^j = x/(1−x)^2 with x=2^{−1/2}; numerical constant as stated. Each run begins exactly one starting sequence and Σ r = n.

Why useful. Isolates a linear O(n) contribution.


## Lemma C (height bound after starting sequence)
Statement. If the just-pushed run has length r and its starting sequence ended, the stack height h satisfies h ≤ 4 + 2·log2(n/r).

Proof. At end of the starting sequence, #2 no longer triggers, so r = r_1 ≤ r_3. By Lemma A, r_3 ≤ 2^{2−h/2}·n. Hence r ≤ 2^{2−h/2}·n, i.e., h ≤ 4 + 2·log2(n/r).

Why useful. Caps per-element height decreases in ending sequences by O(1 + log(n/r)).


## Lemma D (token amortization for ending sequences)
Statement. Credit 2 “C”-tokens and 1 “S”-token to each element whenever its height decreases due to a merge within an ending sequence. Spend tokens as follows: #2 spends 1 C on each of R_1,R_2; #3 spends 2 C on R_1; #4/#5 spend 1 C on R_1 and 1 S on R_2. Then no element ever has negative C- or S-balance during an ending sequence.

Proof. C-tokens: every spend coincides with (and is at most) the number of height decreases on the same element, so the per-decrease credit covers the cost. S-tokens: consider a #4 or #5 merge of R_1,R_2 into S. Under the corrected rule (#5 present), the updated top satisfies either S ≥ next or S+next ≥ next-next, so the inner loop must continue with another merge (either #3 or #4/#5). Thus elements from R_2 immediately see another merge, their height drops again, and they are credited an S-token before any further S-spend; hence S-balances never go negative. Induct over the sequence of merges in the ending sequence.

Why useful. Shows ending-sequence merge cost equals total minted tokens.


## Lemma E (ending-sequence cost sums to O(n + nH))
Statement. For the run R of size r just pushed, its ending sequence consumes O(r·(1 + log(n/r))) tokens. Summing over all runs yields O(n + Σ r_i·log(n/r_i)) = O(n + nH).

Proof. By Lemma C, each element in R can undergo at most O(1 + log(n/r)) height decreases in the ending sequence. The fixed per-decrease credit (Lemma D) bounds total tokens for these elements by O(1 + log(n/r)) each. Summing over the r elements of R gives O(r·(1 + log(n/r))). Summing over all runs gives O(Σ r_i) + O(Σ r_i·log(n/r_i)) = O(n) + O(nH).


## Lemma F (comparisons vs. merge-cost)
Statement. Detecting runs costs at most n−1 comparisons. Each merge of sizes a,b uses ≤ a+b−1 comparisons. Hence total comparisons ≤ (total merge-cost) − (ρ−1) + (n−1) = (total merge-cost) + O(n).

Proof. Standard; each merge eliminates one run and the initial detection uses ≤ one comparison per adjacent pair.


## Coarse Theorem (TimSort comparisons = O(n + nH))
Combine Lemma B (starting-sequence cost ≤ γ·n) and Lemma E (ending sequences sum to O(n + nH)) to bound total merge-cost by O(n + nH). Apply Lemma F to convert to comparisons, adding O(n), to conclude comparisons = O(n + nH).


## Sharp bound scaffolding (factor 3/2)
Potential Φ(r) = (3/2)·r·log2 r. The following lemmas (standard in AJNP) suffice to conclude total merge-cost ≤ ΔΦ + O(n) = (3/2)·n·H + O(n):
- Balanced-merge lemma: if φ^{−2}·r ≤ r′ ≤ φ^{2}·r then merge-cost ≤ ΔΦ.
- Forbidden patterns: no #2#2 and no XX#2 (X∈{#3,#4,#5}).
- Pairing lemma: if an X-merge is too unbalanced, it is immediately followed by #3; the pair’s total cost ≤ pair ΔΦ.
- First-merge slack: the first merge in each ending sequence may exceed ΔΦ by ≤ r (length of just-pushed run). Summing these slacks over all runs gives O(n).
Then ΔΦ telescopes to (3/2)·n·H. By Lemma F, comparisons ≤ (3/2)·n·H + O(n). Buss–Knop give a matching lower bound family.


## Example sanity checks
- Stack (5,7,11,17): #4 merges 5,7→12; next #3 merges 12,11; S-tokens are reimbursed as in Lemma D.
- Attempt to realize #2#2: inequalities from Lemma A force r_1+r_2 ≥ r_5 and r_3+r_4 < r_5 with r_2 < r_4; contradiction because then r_1+r_2 < r_3+r_4.


## Obstacles
- Lemma D depends on the corrected Python rule (#5). The original Java variant lacks this guarantee; our proofs target the patched version only.


## Next steps for proofs.md / output.md
- Add full proofs of Lemmas A–F (above) to finalize the coarse O(n + nH) bound with explicit γ ≈ 16.485.
- Add the potential-function pieces for the sharp (3/2)·n·H + O(n) and cite AJNP for the precise inequalities and forbidden-pattern proof; include the concavity check for the two-merge pairing function F.
- Keep output.md with the corrected main theorem (sharp) and the coarse bound.
