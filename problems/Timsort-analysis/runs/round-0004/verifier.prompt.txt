=== SYSTEM ===
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md, proofs.md, and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (informal progress & exploratory work so far)
- proofs.md (rigorous proofs & detailed mathematics so far)
- output.md (main results summary so far)

**Three-tier file system guidelines**:
- **notes.md**: Readable running log of exploratory work, intuitions, failed attempts, ideas. Prefer appending. Replace only if old notes are clearly misleading. Should be self-contained.
- **proofs.md**: Complete rigorous mathematical proofs with full details. Contains proven lemmas, theorems, and detailed derivations. Only add mathematically verified content here.
- **output.md**: ONLY the main problem results. Think twice before adding anything. Should contain a concise summary of the most important theorems that directly advance the main problem. Extremely selective.

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (≥200 words). Include concrete next-step suggestions.",
  "summary_md": "Concise summary of this round's work for summarizer.",
  "verdict": "promising|uncertain|unlikely",
  "blocking_issues": ["List of issues preventing progress"],
  "per_prover": [{"prover_id": "01", "brief_feedback": "feedback", "score": "promising|uncertain|unlikely"}],
  "notes_update": {"action": "append|replace", "content": "Markdown for notes.md"},
  "proofs_update": {"action": "append|replace", "content": "Markdown for proofs.md"}, 
  "output_update": {"action": "append|replace", "content": "Markdown for output.md"}
}

**Verdict definitions**:
- **promising**: Significant mathematical progress, publishable results, or clear path to solution
- **uncertain**: Some progress but with unresolved issues or incomplete reasoning  
- **unlikely**: No meaningful progress, fundamentally flawed approaches, or just exploratory work

**Update guidelines**:
- Use null for any update field you don't want to modify
- notes_update: Include informal reasoning, failed attempts, intuitions, exploratory work
- proofs_update: Only include complete, rigorous proofs that you have verified
- output_update: Only include main problem results that directly advance toward the solution


=== USER ===
=== Task (txt) ===

prove that timsort adapts to the entropy of the distribution of run lengths. I.e.,  prove that it never uses more than <math> n\mathcal{H} +O(n) </math> comparisons, where <math>\mathcal{H} = \sum_{i=1}^{r} \frac{\ell_i}{n} \log_2\left({\frac n{\ell_i}}\right)</math>, for <math>\ell_1,\ldots,\ell_r</math> the lengths of the runs in the input.


=== Notes ===

# Research Notes



## Entropy-adaptivity of TimSort: corrected target and plan

- The target “comparisons ≤ n·H + O(n)” (leading constant 1) is false for TimSort. Buss–Knop construct run-length sequences yielding merge cost ≥ (3/2)·n·log n − O(n); since H ≤ log n, TimSort requires ≥ (3/2)·n·H − O(n) comparisons on those inputs. Hence we cannot prove the original claim.
- Correct bounds for Python’s patched TimSort (with the additional #5 condition):
  - Coarse: comparisons = O(n + n·H) via starting/ending-sequence decomposition and token accounting.
  - Sharp: comparisons ≤ (3/2)·n·H + O(n), tight (there are matching lower-bound inputs).

Sketch of the coarse O(n + nH) argument
- Model: merging runs of sizes a,b uses ≤ a+b−1 comparisons; run detection takes O(n) comparisons; so total comparisons ≤ total merge cost + O(n).
- Split each iteration into a starting sequence (#1 followed by maximal #2’s) and an ending sequence (merges #3/#4/#5, possibly with #2’s, until invariant restored).
- Invariant (after collapse): r_{i+2} > r_{i+1} + r_i and r_{i+1} > r_i; consequence: along the stack, r_{i+2} ≥ 2 r_i, giving exponential growth and a height bound.
- Starting sequences: cost O(n) in total, via geometric decay (last #2 implies r > r_k and r_k ≥ 2^{(k−1−i)/2} r_i; the weighted sum ∑(k+1−i) r_i ≤ γ·r for a constant γ).
- Ending sequences: tokens per element (2 c + 1 s) credited whenever its height decreases; spends per case #2/#3/#4/#5 are covered; s-token balances stay nonnegative because the patched #5 forces another merge. Each element encounters O(1 + log(n/r)) height levels (height after starting sequence ≤ 4 + 2 log2(n/r)), so total tokens minted sum to O(∑ r (1 + log(n/r))) = O(n + nH). This equals ending-sequence merge cost.
- Final collapse: handled by appending a sentinel run (> n) or charged O(n).

Plan for sharp (3/2)·nH + O(n)
- Use potential Φ(r) = (3/2) r log2 r. Balanced merges (sizes within a factor φ^2) satisfy cost ≤ ΔΦ. Group the remaining merges in each ending sequence into singletons or pairs so that each group’s cost ≤ ΔΦ(group), except possibly the first group which exceeds by ≤ r (length of the just-pushed run). These r-slacks sum to O(n). Hence total merge cost ≤ ΔΦ + O(n) = (3/2)·n·H + O(n). Lower bound: Buss–Knop family gives ≥ (3/2)·n·H − O(n).

Assumptions
- Python’s corrected TimSort (with case #5). Galloping only reduces comparisons. Converting merge cost to comparisons adds O(n).

Next
- Write up proofs in proofs.md (coarse and sharp bounds) and adjust output.md to state the corrected main theorem (3/2 factor).


=== Current Output ===

# Main Results



Main theorem (corrected). For an input of length n whose greedy run decomposition has lengths ℓ_1,…,ℓ_r and entropy H = ∑ (ℓ_i/n) log2(n/ℓ_i), Python’s corrected TimSort performs at most (3/2)·n·H + O(n) comparisons. This bound is tight: there are inputs requiring ≥ (3/2)·n·H − O(n) comparisons.

Coarse bound. TimSort uses O(n + n·H) comparisons (starting sequences cost O(n); ending sequences cost O(n + n·H) via token amortization).


=== Prover 1 Output ===

## Aim of this round
Provide auditable, explicit-constant bounds for the coarse entropy-adaptivity of Python’s patched TimSort (with case #5): comparisons = O(n + n·H). We isolate two pieces with full details: (i) starting-sequence cost with a closed-form constant γ, and (ii) an explicit constant bound for ending-sequence costs via token accounting and the stack-height lemma. This gives a concrete coarse bound comparisons ≤ 6 n H + C n for a universal constant C.

## Setting and notation
- Input of length n with greedy run decomposition lengths ℓ_1,…,ℓ_r (∑ℓ_i=n). Entropy H = ∑ (ℓ_i/n) log2(n/ℓ_i).
- Merge cost of merging lengths a,b is a+b; comparisons for a merge ≤ (a+b−1).
- Python’s corrected merge-cascade with cases #1–#5 (case #5 present). Galloping only decreases comparisons.
- We decompose updates into starting sequences (#1 then maximal #2’s) and ending sequences (beginning with #3/#4/#5, possibly interleaved with #2’s, but no #1).
- Stack invariant (proved by routine case analysis): r_{i+1}>r_i and r_{i+2}>r_{i+1}+r_i after each collapse; consequence: r_{i+2}≥2 r_i and, just before a push, r_i ≤ 2^{(i+1−j)/2} r_j for i≤j.

## 1) Explicit constant for starting sequences
Lemma (Geometric bound with constant). If a run R of length r begins a starting sequence of k≥2 steps (#1 then k−1 merges #2), the total merge cost within that sequence is ≤ γ·r, where
γ = 2 ∑_{j≥1} j·2^{−j/2} = 2·α/(1−α)^2 with α=2^{−1/2} ≈ 0.7071, thus γ ≈ 16.4925.
Proof. If the pre-push stack is S=(R_1,…,R_h), then the k−1 merges #2 are (R_1,R_2), …,(R_{k−1},R_k). Total cost C ≤ ∑_{i=1}^k (k+1−i) r_i. The last #2 implies r>r_k. By the pre-push exponential growth, r ≥ r_k ≥ 2^{(k−1−i)/2} r_i. Hence (k+1−i) r_i ≤ r·(k+1−i)·2^{(i+1−k)/2}. Summing over i gives
C/r ≤ 2∑_{j=1}^k j 2^{−j/2} ≤ 2∑_{j≥1} j 2^{−j/2} = γ.
Summing over all runs R (each begins exactly one starting sequence) yields StartingCost ≤ γ·n.

## 2) Explicit constant for ending sequences via tokens and height bound
Token scheme (patched Python, case #5 used): whenever an element’s height decreases within an ending sequence, credit it with 2 c-tokens and 1 s-token; spend tokens on merges as follows: #2: each element of R_1 and R_2 spends 1 c; #3: each element of R_1 spends 2 c; #4/#5: each element of R_1 spends 1 c and each element of R_2 spends 1 s. A standard argument shows balances never go negative; crucially, after #4/#5 there is necessarily a follow-up merge in the same ending sequence (case #5 guarantees immediate continuation), so s-tokens are re-credited on the next height decrease before they could be spent again. Thus, total ending-sequence merge cost equals total tokens minted in ending sequences.

Height bound after a starting sequence. If a run R of length r has just finished its starting sequence and the stack height is h, then h ≤ 4 + 2 log2(n/r). Proof: runs below index 3 were untouched; by exponential growth before the push, r_3 ≤ 2^{2−h/2} n; at end of the starting sequence, #2 is false, so r = r_1 ≤ r_3 ≤ 2^{2−h/2} n; rearrange.

Minted tokens bound. Each height decrease for an element mints (2 c + 1 s)=3 tokens; the number of decreases an element can undergo is at most the stack height when its starting sequence ends. Therefore the total tokens minted for elements of run i (length ℓ_i) is ≤ 3·(4 + 2 log2(n/ℓ_i))·ℓ_i. Summing over i,
EndingCost ≤ ∑_{i=1}^r 3(4 + 2 log2(n/ℓ_i)) ℓ_i = 12 n + 6 ∑ ℓ_i log2(n/ℓ_i) = 12 n + 6 n H.

## 3) Coarse explicit-constant bound on comparisons
Total merge cost ≤ StartingCost + EndingCost ≤ γ n + (12 n + 6 n H) = 6 n H + (γ+12) n.
The number of comparisons over all merges is at most (merge cost − (#merges)), but we can upper bound simply by the merge cost. Add O(n) for run detection and for the final collapse (or realize it via a sentinel run). Hence there exists an absolute constant C (e.g., C=γ+13 ≈ 29.5) such that
Comparisons(TimSort) ≤ 6 n H + C n.

This gives an explicit coarse entropy-adaptive bound (with a loose factor 6 on H) that is fully justified by the above lemmas. It matches the classical O(n + n H) form and is adequate for the coarse result.

## Examples and sanity checks
- One run (ℓ_1=n): H=0, bound gives ≤ C n comparisons, consistent: TimSort detects sorted input and performs no merges, O(n).
- All runs of length 1: H=log2 n, bound gives ≤ 6 n log2 n + C n.
- Two runs (a,b): H ≤ 1, bound ≤ 6 n + C n = O(n).

## Obstacles
- The constant factor 6 on H is not tight; improving to the sharp factor 3/2 requires the potential method with Φ(r)=(3/2) r log2 r, the balanced-merge lemma (sizes within φ²), forbidden patterns (no #2#2 and no XX#2), the pairing lemma for unbalanced merges, and grouping per ending sequence. Those ingredients are already outlined; a full write-up is the next step.
- The s-token nonnegativity critically uses the corrected #5 rule; the legacy Java variant needs different handling.

## Next steps
- Move the above explicit-constant coarse proof (γ and 12 constants, height lemma, token argument, case #5 reliance) into proofs.md.
- Add the refined potential-function proof to reach the sharp (3/2)·n·H + O(n) comparisons, citing or re-proving the functional inequality in the pairing lemma and the forbidden-pattern lemma.
- Keep output.md’s corrected main theorem and include the coarse bound as a secondary statement.



=== Prover 2 Output ===

# Focused progress toward the coarse O(n + nH) bound

I isolate three technical steps that are both standard and critical to the entropy-adaptivity proof for Python’s patched TimSort (with case #5). Each is stated and proven cleanly so they can be dropped into proofs.md.


1) Immediate follow-up merges after #4/#5 (s-token refund)

Lemma (follow-up after #4/#5). Consider the stack just after merging the top two runs R₁ and R₂ by one of the conditions #4 or #5. Denote new top runs by R̄₁, R̄₂, R̄₃ with lengths r̄₁, r̄₂, r̄₃. Then the very next loop iteration must perform another merge (either #3 or #4). In particular, the algorithm does not break between these two merges.

Proof. Case #4 triggers when r₁ + r₂ ≥ r₃. After merging R₁ and R₂, we have r̄₁ = r₁ + r₂, r̄₂ = r₃, r̄₃ = r₄. The next test in order is #2 (r̄₁ > r̄₃), which may fail. The following test is #3 (r̄₁ ≥ r̄₂). Since r̄₁ = r₁ + r₂ ≥ r₃ = r̄₂, #3 holds and a merge occurs. 

Case #5 triggers when r₂ + r₃ ≥ r₄. After merging R₁ and R₂, we again have r̄₁ = r₁ + r₂, r̄₂ = r₃, r̄₃ = r₄. The next test #4 requires r̄₁ + r̄₂ ≥ r̄₃, which holds because (r̄₁ + r̄₂) = (r₁ + r₂) + r₃ ≥ r₄ = r̄₃ (using r₂ + r₃ ≥ r₄). Hence #4 holds and a merge occurs. ∎

Why useful here. This establishes that every s-token spent by elements of R₂ in a #4/#5 merge is refunded immediately at the next merge in the same ending sequence (height decreases), ensuring s-token balances never go negative.


2) Explicit constant for starting sequences

Lemma (explicit γ). Let γ := 2∑_{j≥1} j·2^{−j/2}. Then γ has the closed form γ = 2·x/(1−x)² with x=2^{−1/2}. Numerically, x≈0.70710678 and γ≈16.4853. 

Proof. For |x|<1, ∑_{j≥1} j x^{j} = x/(1−x)². Set x=2^{−1/2} to get ∑ j 2^{−j/2} = x/(1−x)² and multiply by 2. ∎

Why useful here. It gives an explicit universal constant bounding the total cost of each starting sequence by ≤ γ·r and hence total starting-sequence cost ≤ γ·n.


3) Sentinel for final collapse (absorbing line-11 merges)

Claim (sentinel absorption). Appending a fictitious terminal run of length n+1 to the run decomposition makes the final collapse merges occur within the main loop. The coarse O(n + nH) bound is unaffected.

Proof. With a terminal run T of length > n, every remaining stack merge is triggered by #3 (top run length ≥ next), so the main loop performs exactly the merges of the final collapse. The sentinel contributes no comparisons beyond O(n) for merges already bounded, and we remove it analytically at the end. ∎

Why useful here. It lets us bound all merges inside one loop, avoiding a separate end-phase analysis.


4) Entropy identity used in the summation

Fact. ∑_{i=1}^r ℓ_i log₂(n/ℓ_i) = n·H, where H = ∑ (ℓ_i/n) log₂(n/ℓ_i).

Proof. Expand: ∑ ℓ_i log₂(n/ℓ_i) = ∑ ℓ_i( log₂ n − log₂ ℓ_i ) = (∑ ℓ_i) log₂ n − ∑ ℓ_i log₂ ℓ_i = n log₂ n − ∑ ℓ_i log₂ ℓ_i. On the other hand, n·H = n ∑ (ℓ_i/n) log₂(n/ℓ_i) = ∑ ℓ_i log₂(n/ℓ_i). ∎

Why useful here. Converts the token-minted sum ∑ ℓ_i·log(n/ℓ_i) into n·H.


Examples / sanity checks
- After a #4 merge of lengths (3,5,7,13), new top is (8,7,13); #3 (8≥7) triggers immediately. After a #5 merge of (2,8,9,15) (since 8+9≥15), new top is (10,9,15); #4 holds ((10+9)≥15), so a merge follows.


Obstacles
- The s-token proof requires case #5 to be present in TimSort; without it, the algorithm may not perform the #5 merge in the first place and the amortization structure differs (this is consistent with the original Java bug). Our target explicitly analyzes Python’s corrected variant.


Next steps
- Incorporate these lemmas into proofs.md: (i) immediate follow-up after #4/#5; (ii) explicit γ; (iii) sentinel absorption; (iv) entropy identity. This will complete the coarse O(n + nH) proof with all details accounted for. 
- In a subsequent round, we can formalize the “forbidden patterns” lemma (no #2#2, no XX#2) and the two-merge pairing inequality F(y)≥0 for the sharp (3/2)·n·H + O(n) bound.



=== Prover 3 Output ===

Ideas

- Scope: We aim for the coarse entropy-adaptivity bound for Python’s patched TimSort (with the extra collapse rule r_2 + r_3 ≥ r_4): comparisons = O(n + n H), H = ∑_i (ℓ_i/n) log_2(n/ℓ_i). This suffices to show adaptation to the entropy; sharp constant 3/2 can follow later.
- Strategy recap: comparisons ≤ merge cost + O(n). Decompose into starting vs. ending sequences. Prove (i) starting sequences contribute O(n) (with an explicit constant γ), (ii) ending sequences are paid by a token scheme because each element suffers only O(1 + log(n/ℓ)) height decreases (height bound), so total ≤ O(n + nH).

Small lemmas with proofs (to add to proofs.md)

1) Immediate continuation after #4/#5 (s-token safety)
- Claim. In the Python-patched TimSort, a merge by #4 or #5 can never end an ending sequence; the very next step is another merge.
- Proof. Suppose #4 triggers on top three lengths r_1, r_2, r_3 with r_1 + r_2 ≥ r_3 and merges R_1 and R_2, producing top r_1′ = r_1 + r_2, r_2′ = r_3. Then rule #3 (r_1′ ≥ r_2′) immediately holds, so another merge must follow. Similarly, suppose #5 triggers on top four lengths r_1, r_2, r_3, r_4 with r_2 + r_3 ≥ r_4 and merges R_1 and R_2, producing top three r_1′ = r_1 + r_2, r_2′ = r_3, r_3′ = r_4. Then r_1′ + r_2′ = (r_1 + r_2) + r_3 ≥ r_2 + r_3 ≥ r_4 = r_3′, so #4 holds, and another merge follows. ∎
- Why useful here. This alone ensures the s-token nonnegativity: any s-token spent in #4/#5 is immediately re-credited on the subsequent merge when the height decreases.

2) Starting sequences: explicit constant
- Claim. If a starting sequence begins by pushing a run of length r and performs k−1 merges #2 (merging R_2,…,R_k), then its merge cost C satisfies C ≤ γ r with γ = 2 ∑_{j≥1} j·2^{−j/2} = 2·q/(1−q)^2 and q = 2^{−1/2} ≈ 0.7071, so γ ≈ 16.4924.
- Proof. Let the pre-push stack be S, and after the push and k−1 merges #2 we merge runs R_1,…,R_k (excluding trivial k=1). Then C ≤ ∑_{i=1}^k (k+1−i) r_i. Since #2 applied k−1 times and then stopped, r > r_k. The invariant yields r_k ≥ 2^{(k−1−i)/2} r_i for all i, so C/r ≤ ∑_{i=1}^k (k+1−i) 2^{(i+1−k)/2} = 2 ∑_{j=1}^k j 2^{−j/2} < 2 ∑_{j≥1} j 2^{−j/2} = 2·q/(1−q)^2. ∎
- Why useful here. Summing over pushes (∑ r = n) gives total starting-sequence cost ≤ γ n = O(n).

3) Height bound after a starting sequence
- Claim. Let r be the length of the just-pushed run; when its starting sequence ends, the stack height h ≤ 4 + 2 log_2(n/r).
- Proof. Below the top two runs, none has been merged during the starting sequence, so by the growth corollary r_3 ≤ 2^{2−h/2} r_h ≤ 2^{2−h/2} n. Since #2 is no longer applicable, r ≤ r_3, hence r ≤ 2^{2−h/2} n and h ≤ 4 + 2 log_2(n/r). ∎
- Why useful here. Each element accrues credits only when its height decreases during ending sequences; this bounds the per-element budget by O(1 + log(n/r)).

4) Ending sequences: token accounting and summation
- Token scheme. Credit 2 c-tokens and 1 s-token to an element when its run is pushed, and whenever its height decreases due to a merge in an ending sequence. Spend as follows: #2: 1 c from each element of R_1 and R_2; #3: 2 c from each element of R_1; #4/#5: 1 c from each element of R_1 and 1 s from each element of R_2.
- Nonnegativity. For #2/#3/#4/#5, all charged elements’ heights decrease, so the fresh 2c credit covers c-spends. By Lemma 1, #4/#5 are immediately followed by another merge; on that merge, elements of the new top run (including former R_2) decrease height again and regain an s-token. Thus s-balances never go negative.
- Summation to O(n + nH). By Lemma 3, each element in a run of length r incurs at most O(1 + log(n/r)) height decreases in ending sequences, thus receives O(1 + log(n/r)) tokens. Summing over all runs gives O(∑ r (1 + log(n/r))) = O(n + nH).

5) Run detection overhead (comparisons)
- Claim. The greedy run decomposition scan uses ≤ 2(n−1) comparisons; hence O(n).
- Proof sketch. In a one-pass scan, each time we begin a new run we compare A[i] and A[i+1] to fix the direction; within a run, each adjacent pair is compared at most once until the monotonicity breaks. Each index participates in at most a constant number of such adjacency checks; overall O(n). ∎

Examples (sanity checks)

- After #4: r_1=5, r_2=6, r_3=10: #4 merges (5,6) → (11,10), and #3 immediately applies (11≥10); s-token spent at #4 is regained at the next step.
- Highly skewed runs: one run of size n/2, the rest tiny. Height bound for the big run is O(1), so its elements pay O(1) tokens; the total ending cost is dominated by smaller runs and sums to O(n + nH).

Obstacles

- The target with leading constant 1 (≤ nH + O(n)) is false for TimSort in general; Buss–Knop exhibit inputs with merge cost ≥ (3/2) n log n − O(n). Our coarse bound O(n + nH) is correct and sufficient for this task.
- The s-token argument hinges on the corrected #5 rule; the Java unpatched variant breaks the guarantee (immediate continuation may fail), so our proof is for the Python-patched TimSort.

Next steps

- Move Lemmas 1–5 and their proofs into proofs.md, with the explicit constant γ in Lemma 2 and the h-bound. Conclude comparisons ≤ O(n + nH) because merging a,b uses ≤ a+b−1 comparisons, so comparisons ≤ merge cost + O(n).
- Then add the sharp (3/2)·nH + O(n) bound via the potential Φ(r)=(3/2) r log_2 r: balanced-merge lemma (sizes within φ²), forbidding short patterns (#2#2, XX#2), pairing unbalanced merges, and grouping with O(r) slack per ending sequence; total slack O(n).


=== Prover 4 Output ===

## Context and corrected target
- The leading-constant 1 statement “TimSort uses ≤ n·H + O(n) comparisons” is false for TimSort (Buss–Knop: merge-cost ≥ (3/2)·n·log n − O(n); since H ≤ log n, comparisons ≥ (3/2)·n·H − O(n) on those inputs).
- Correct bounds for Python’s patched TimSort (extra case #5):
  - Coarse: comparisons = O(n + nH).
  - Sharp: comparisons ≤ (3/2)·n·H + O(n), tight.

Below I supply small, testable lemmas and detailed proofs that the verifier can move to proofs.md to finalize the coarse O(n + nH) bound and prepare the sharp bound.


## Lemma A (stack growth invariant) and Corollary A’
Statement. Just before pushing a new run, we have r_1 < r_2, r_1 + r_2 < r_3, and for all i ≥ 3, r_i + r_{i+1} < r_{i+2}. Consequently, for all 1 ≤ i ≤ j ≤ h,
  r_i ≤ 2^{(i+1−j)/2}·r_j.

Proof (sketch). A routine case analysis on updates #1–#5 (using the Python-corrected rules) shows each preserves these inequalities; #1 occurs only when all merge conditions fail, giving r_1 < r_2, r_1 + r_2 < r_3, and r_2 + r_3 < r_4. From r_i + r_{i+1} < r_{i+2} and r_i < r_{i+1}, we get 2 r_i ≤ r_{i+2}. Iterating yields the geometric decay bound.

Why useful. Exponential growth along the stack is the backbone for bounding starting sequences.


## Lemma B (starting-sequence cost with explicit constant)
Statement. If pushing a run R of size r triggers k−1 merges of type #2 with underlying runs (k ≥ 2), then the total merge cost C is ≤ γ·r with
  γ = 2·Σ_{j≥1} j·2^{−j/2} = 2·x/(1−x)^2 for x=2^{−1/2} ≈ 16.485.
Summing over all pushes gives total starting-sequence cost ≤ γ·n.

Proof. After the push, the cost is C ≤ Σ_{i=1}^k (k+1−i)·r_i. The last #2 ensures r > r_k. By Corollary A’, r ≥ r_k ≥ 2^{(k−1−i)/2}·r_i, hence
  C/r ≤ Σ_{i=1}^k (k+1−i)·2^{(i+1−k)/2} = 2·Σ_{j=1}^k j·2^{−j/2} < 2·Σ_{j≥1} j·2^{−j/2}.
Evaluate Σ_{j≥1} j x^j = x/(1−x)^2 with x=2^{−1/2}; numerical constant as stated. Each run begins exactly one starting sequence and Σ r = n.

Why useful. Isolates a linear O(n) contribution.


## Lemma C (height bound after starting sequence)
Statement. If the just-pushed run has length r and its starting sequence ended, the stack height h satisfies h ≤ 4 + 2·log2(n/r).

Proof. At end of the starting sequence, #2 no longer triggers, so r = r_1 ≤ r_3. By Lemma A, r_3 ≤ 2^{2−h/2}·n. Hence r ≤ 2^{2−h/2}·n, i.e., h ≤ 4 + 2·log2(n/r).

Why useful. Caps per-element height decreases in ending sequences by O(1 + log(n/r)).


## Lemma D (token amortization for ending sequences)
Statement. Credit 2 “C”-tokens and 1 “S”-token to each element whenever its height decreases due to a merge within an ending sequence. Spend tokens as follows: #2 spends 1 C on each of R_1,R_2; #3 spends 2 C on R_1; #4/#5 spend 1 C on R_1 and 1 S on R_2. Then no element ever has negative C- or S-balance during an ending sequence.

Proof. C-tokens: every spend coincides with (and is at most) the number of height decreases on the same element, so the per-decrease credit covers the cost. S-tokens: consider a #4 or #5 merge of R_1,R_2 into S. Under the corrected rule (#5 present), the updated top satisfies either S ≥ next or S+next ≥ next-next, so the inner loop must continue with another merge (either #3 or #4/#5). Thus elements from R_2 immediately see another merge, their height drops again, and they are credited an S-token before any further S-spend; hence S-balances never go negative. Induct over the sequence of merges in the ending sequence.

Why useful. Shows ending-sequence merge cost equals total minted tokens.


## Lemma E (ending-sequence cost sums to O(n + nH))
Statement. For the run R of size r just pushed, its ending sequence consumes O(r·(1 + log(n/r))) tokens. Summing over all runs yields O(n + Σ r_i·log(n/r_i)) = O(n + nH).

Proof. By Lemma C, each element in R can undergo at most O(1 + log(n/r)) height decreases in the ending sequence. The fixed per-decrease credit (Lemma D) bounds total tokens for these elements by O(1 + log(n/r)) each. Summing over the r elements of R gives O(r·(1 + log(n/r))). Summing over all runs gives O(Σ r_i) + O(Σ r_i·log(n/r_i)) = O(n) + O(nH).


## Lemma F (comparisons vs. merge-cost)
Statement. Detecting runs costs at most n−1 comparisons. Each merge of sizes a,b uses ≤ a+b−1 comparisons. Hence total comparisons ≤ (total merge-cost) − (ρ−1) + (n−1) = (total merge-cost) + O(n).

Proof. Standard; each merge eliminates one run and the initial detection uses ≤ one comparison per adjacent pair.


## Coarse Theorem (TimSort comparisons = O(n + nH))
Combine Lemma B (starting-sequence cost ≤ γ·n) and Lemma E (ending sequences sum to O(n + nH)) to bound total merge-cost by O(n + nH). Apply Lemma F to convert to comparisons, adding O(n), to conclude comparisons = O(n + nH).


## Sharp bound scaffolding (factor 3/2)
Potential Φ(r) = (3/2)·r·log2 r. The following lemmas (standard in AJNP) suffice to conclude total merge-cost ≤ ΔΦ + O(n) = (3/2)·n·H + O(n):
- Balanced-merge lemma: if φ^{−2}·r ≤ r′ ≤ φ^{2}·r then merge-cost ≤ ΔΦ.
- Forbidden patterns: no #2#2 and no XX#2 (X∈{#3,#4,#5}).
- Pairing lemma: if an X-merge is too unbalanced, it is immediately followed by #3; the pair’s total cost ≤ pair ΔΦ.
- First-merge slack: the first merge in each ending sequence may exceed ΔΦ by ≤ r (length of just-pushed run). Summing these slacks over all runs gives O(n).
Then ΔΦ telescopes to (3/2)·n·H. By Lemma F, comparisons ≤ (3/2)·n·H + O(n). Buss–Knop give a matching lower bound family.


## Example sanity checks
- Stack (5,7,11,17): #4 merges 5,7→12; next #3 merges 12,11; S-tokens are reimbursed as in Lemma D.
- Attempt to realize #2#2: inequalities from Lemma A force r_1+r_2 ≥ r_5 and r_3+r_4 < r_5 with r_2 < r_4; contradiction because then r_1+r_2 < r_3+r_4.


## Obstacles
- Lemma D depends on the corrected Python rule (#5). The original Java variant lacks this guarantee; our proofs target the patched version only.


## Next steps for proofs.md / output.md
- Add full proofs of Lemmas A–F (above) to finalize the coarse O(n + nH) bound with explicit γ ≈ 16.485.
- Add the potential-function pieces for the sharp (3/2)·n·H + O(n) and cite AJNP for the precise inequalities and forbidden-pattern proof; include the concavity check for the two-merge pairing function F.
- Keep output.md with the corrected main theorem (sharp) and the coarse bound.



=== Prover 5 Output ===

# Ideas
- Strengthen the coarse O(n + nH) analysis with two precise, checkable components:
  1) an explicit constant for total starting-sequence cost, γ = 6√2 + 8 ≈ 16.485;
  2) a clean conversion from merge-cost to comparisons (exactly ρ−1 merges).
- Isolate and prove the “follow-up merge” property that under the Python patch (#5), any #4/#5 merge is immediately followed by another merge in the same ending sequence (needed for s-token nonnegativity).

# Lemma A (Starting sequences: explicit constant)
Statement. Let a starting sequence (initiated by pushing a run of length r) perform k−1 ≥ 1 merges #2 of pre-existing runs with lengths r_1,…,r_k. Its total merge-cost C satisfies C ≤ γ r, with
γ = 2∑_{j≥1} j·2^{−j/2} = 2·x/(1−x)^2 for x=2^{−1/2} = 6√2 + 8 ≈ 16.4853.
Hence total starting-sequence cost over the whole algorithm is ≤ γ·n.
Proof. At the last #2, r > r_k. Corollary (exponential growth along stack) gives r ≥ r_k ≥ 2^{(k−1−i)/2} r_i. Thus
C ≤ ∑_{i=1}^k (k+1−i) r_i ≤ r∑_{i=1}^k (k+1−i)2^{(i+1−k)/2} = 2r∑_{j=1}^k j 2^{−j/2} < 2r∑_{j≥1} j 2^{−j/2}.
Since ∑_{j≥1} jx^j = x/(1−x)^2, with x=2^{−1/2},
2∑_{j≥1} j 2^{−j/2} = 2·x/(1−x)^2 = 2·(1/√2)/(( (√2−1)/√2 )^2) = 2·(1/√2)·(2/(√2−1)^2) = 6√2+8.
Summing over pushes (∑ r = n) gives ≤ γ n.

# Lemma B (Exact number of merges and comparison conversion)
Statement. If the greedy run decomposition has ρ runs, any execution of TimSort performs exactly ρ−1 merges, regardless of order.
Proof. Each merge reduces the stack size by 1; starting from ρ runs and ending at 1 run, exactly ρ−1 merges occur.
Corollary. With standard merging (no galloping), merging runs of sizes a,b uses ≤ a+b−1 comparisons; over all merges,
comparisons ≤ (total merge-cost) − (ρ−1).
Adding O(n) for run detection yields comparisons ≤ (merge-cost) + O(n).

# Lemma C (Height bound after starting sequence)
Statement. Let r be the length of the just-pushed run; let h be the stack height after its starting sequence. Then h ≤ 4 + 2 log_2(n/r).
Proof. Runs at depths ≥3 are untouched in the starting sequence; by exponential growth in the pre-push tail, r̄_3 ≤ 2^{2−h/2} n. At the end of the starting sequence, #2 no longer applies, so r̄_1=r ≤ r̄_3. Hence r ≤ 2^{2−h/2} n.

# Lemma D (Follow-up merge after #4/#5 under the patch)
Statement. In patched Python TimSort, any ending-sequence merge triggered by #4 or #5 must be followed by another merge (still in the ending sequence).
Proof. After #4 or #5, the top two runs merge into R̄_1 with length r̄_1 = r_1+r_2. Since the stack below is unchanged (R̄_i = R_{i+1} for i≥2), we have in case #4 (r_1+r_2 ≥ r_3) that r̄_1 ≥ r̄_2; in case #5 (r_2+r_3 ≥ r_4) that r̄_1+r̄_2 ≥ r̄_3. In either case, one of #3 or #4 is immediately true in the new stack, so the inner loop continues with another merge. Thus no ending sequence can terminate right after a #4/#5 merge.
Consequence. s-tokens spent by elements of R_2 in #4/#5 are replenished immediately at the next merge’s height drop, ensuring s-token nonnegativity.

# Consequence for O(n + nH)
- Starting sequences: ≤ γ n by Lemma A.
- Ending sequences: For an element in a run of length r, its height is nonincreasing and decreases at most O(1+log(n/r)) times (Lemma C). Each decrease credits (2 c + 1 s) tokens; by Lemma D and the spend rules, token balances never go negative. Hence total ending-sequence merge-cost ≤ C∑ r (1+log_2(n/r)) = O(n + nH).
- By Lemma B, comparisons ≤ merge-cost + O(n). Therefore total comparisons = O(n + nH).

# Examples
- Two runs (x, n−x): H ≤ 1; one merge; comparisons ≤ n = O(n + nH).
- Equal runs (ℓ_i = n/ρ): H = log_2 ρ; bound gives O(n log ρ) comparisons.

# Obstacles
- The target with leading constant 1 (nH + O(n)) is false for TimSort (Buss–Knop). The sharp, tight upper bound is (3/2)·n·H + O(n), proven via the potential Φ(r)=(3/2)r log_2 r and grouping; omitted here but aligns with AJNP.

# Next steps
- Insert Lemma A (with γ = 6√2+8), Lemma B, Lemma C, and Lemma D proofs into proofs.md, then conclude comparisons = O(n + nH).
- Add the potential-method pieces (balanced merges, forbidden patterns, pairing, grouping) to reach the sharp (3/2)·n·H + O(n) bound.


=== Papers (text) ===

=== Paper (papers/paper1.txt) ===
\documentclass[a4paper,USenglish]{lipics-v2019}

\usepackage{amsmath,amssymb,xspace}
\usepackage{graphicx}
\usepackage{url}
\usepackage{multirow}
\usepackage{wrapfig}
\usepackage[nodisplayskipstretch]{setspace} \setstretch{1}
\usepackage{comment}
\usepackage[boxruled,vlined,linesnumbered]{algorithm2e}
\usepackage{tikz,tikz-qtree}
\usetikzlibrary{matrix,fit}
\usetikzlibrary{arrows,decorations.pathreplacing,calc}
\usepackage{graphicx}
\usepackage[nomessages]{fp}

\usepackage{lipsum}

\usepackage{listings,xcolor}

\usepackage{breakurl}
\usepackage{pdfpages}
\usepackage{float,xspace}
\usepackage{hyperref}

\usepackage{microtype}

% \usepackage{minted}

\usepackage{marginnote}
\renewcommand*{\marginfont}{\scriptsize\color{gray}}

\nolinenumbers


% \usepackage{caption}
% \usepackage{subcaption}
% \usepackage{subfig} 


%\renewcommand{\algorithmicrequire}{\textbf{Input:}}
%\renewcommand{\algorithmicensure}{\textbf{Output:}}
%\algrenewcomment[1]{\(\triangleright\) \textit{#1}}

%declarations de macro
\newcommand{\HS}{\textsc{HuffmanSort}\xspace}
\newcommand{\NMS}{\textsc{NaturalMergeSort}\xspace}
\newcommand{\MS}{\textsc{MergeSort}\xspace}
\newcommand{\MinS}{\textsc{MinimalSort}\xspace}
\newcommand{\TS}{\textsc{TimSort}\xspace}
\newcommand{\STS}{\textsc{TimSort}\xspace}
\newcommand{\QS}{\textsc{QuickSort}\xspace}
\newcommand{\CR}{\textsc{countRuns}\xspace}
\newcommand{\CS}{\textsc{CountingSort}\xspace}
\newcommand{\GMS}{\textsc{Greedy\-Merge\-Sort}\xspace}
\renewcommand{\SS}{$\alpha$-\textsc{StackSort}\xspace}
\newcommand{\caseX}{$\#$\textsc{X}\xspace}
\newcommand{\kleene}{\rlap{\phantom{\caseX}}^\ast}

\newcommand{\Python}{{Python}\xspace}
\newcommand{\Java}{{Java}\xspace}

\DeclareMathOperator{\sort}{\textbf{sort}}
\DeclareMathOperator{\runs}{\textbf{runs}}
\DeclareMathOperator{\timruns}{\textbf{timRuns}}
\DeclareMathOperator{\merge}{\textbf{merge}}
\DeclareMathOperator{\update}{\textbf{update}}
\DeclareMathOperator{\optimal}{\textbf{Opt}}
\DeclareMathOperator{\lengths}{\textbf{L}}

\renewcommand{\H}{\mathcal{H}}
\renewcommand{\O}{\mathcal{O}}
\renewcommand{\S}{\mathcal{S}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\B}{\mathcal{B}}
\newcommand{\C}{\mathcal{C}}
\newcommand{\R}{\mathcal{R}}
\newcommand{\rs}{\mathsf{r}}
\newcommand{\T}{\mathcal{T}}

\newcommand{\cost}{\textbf{c}}
\newcommand{\vcost}{\textbf{cost}}
\newcommand{\finishproof}{\vspace{-\baselineskip}}

\DeclareMathOperator{\pop}{\text{pop}}
\DeclareMathOperator{\push}{\text{push}}
\DeclareMathOperator{\height}{\texttt{height}}
\DeclareMathOperator{\rundecomp}{\texttt{runs}}
\DeclareMathOperator{\runstack}{\R}


\newcommand{\cSTS}{$\alpha$-\STS}
\newcommand{\stack}{\mathcal{X}}
\newcommand{\true}{\textbf{true}}
\newcommand{\pot}{\mathsf{pot}}
\newcommand{\false}{\textbf{false}}
\newcommand{\strat}{\mathfrak{S}}

\newcommand{\who}[1]{\noindent {\color{blue}\fbox{Who?~#1}}}
\newcommand{\rmk}[1]{\noindent {\color{red}\centerline{\fbox{\begin{minipage}{.8\textwidth}Rmk:~#1\end{minipage}}}}}

\newcommand{\carine}[1]{{\textbf{\color{blue} -- #1 -- }}}
\newcommand{\capi}[1]{{\color{blue} #1}}
\newcommand{\cyril}[1]{{\textbf{\color{green!50!black} -- #1 -- }}}
\newcommand{\nicolas}[1]{{\textbf{\color{purple} -- #1 -- }}}
\newcommand{\vincent}[1]{{\textbf{\color{pink!50!red!90!gray} -- #1 -- }}}
\newcommand{\juge}[1]{{\color{gray}#1}}

\newcommand{\ctok}{$\diamondsuit$\xspace}
\newcommand{\stok}{$\heartsuit$\xspace}
\newcommand{\ptok}{$\clubsuit$\xspace}

\renewcommand{\gets}{\ensuremath{\leftarrow}}
\newenvironment{disjunction}{\begin{itemize}}{\vspace{-\baselineskip}\end{itemize}}
\setlength{\itemsep}{\smallskipamount}

\theoremstyle{plain}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{claim}[theorem]{Claim}

\theoremstyle{definition}
\newtheorem{remark2}[theorem]{Remark}


% Author macros::begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{On the Worst-Case Complexity of TimSort} 

\bibliographystyle{plainurl}% the recommnded bibstyle

%\author{Nicolas Auger}{Universit\'e Paris-Est, LIGM (UMR 8049), CNRS, ENPC, ESIEE Paris, UPEM, F-77454 Marne-la-Vall\'ee, France}{}{}{}

\author{Nicolas Auger, Vincent Jugé, Cyril Nicaud, and Carine Pivoteau}{Universit\'e Paris-Est, LIGM (UMR 8049), UPEM, F77454 Marne-la-Vall\'ee, France}{}{}{}

\authorrunning{N. Auger, V. Jugé, C. Nicaud, and C. Pivoteau} %mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et. al.'

\Copyright{Nicolas Auger, Vincent Jugé, Cyril Nicaud, and Carine Pivoteau}%mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\subjclass{\ccsdesc[100]{Theory of computation~Sorting and searching}}% mandatory: Please choose ACM 2012 classifications from https://www.acm.org/publications/class-2012 or https://dl.acm.org/ccs/ccs_flat.cfm . E.g., cite as "General and reference $\rightarrow$ General literature" or \ccsdesc[100]{General and reference~General literature}. 

\keywords{Sorting algorithms, Merge sorting algorithms, TimSort, Analysis of algorithms}% mandatory: Please provide 1-5 keywords

% Author macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\EventEditors{}%Yossi Azar, Hannah Bast, and Grzegorz Herman}
\EventNoEds{1}
\EventLongTitle{}%26th Annual European Symposium on Algorithms (ESA 2018)}
\EventShortTitle{}%ESA 2018}
\EventAcronym{}%ESA}
\EventYear{}%2018}
\EventDate{}%August 20--22, 2018}
\EventLocation{}%Helsinki, Finland}
\EventLogo{}
\SeriesVolume{}%112}
\ArticleNo{} % “new number” (=<article-no>) goes here! 
\begin{document}

\maketitle

\begin{abstract}
\TS is an intriguing sorting algorithm designed in 2002 for Python, 
whose worst-case complexity was announced, but not proved until our recent preprint.
In fact, there are two slightly different versions of \TS that are currently implemented in Python and in Java respectively. 
We propose a pedagogical and insightful proof that the Python version runs in time~$\O(n \log n)$. 
The approach we use in the analysis also applies to the Java version, although not without very involved technical details. 
As a byproduct of our study, we uncover a bug in the Java implementation that can cause the sorting method to fail during the execution. 
We also give a proof that Python's \TS running time is in $\O(n + n \H)$,
where $\H$ is the entropy of the distribution of runs (i.e. maximal monotonic sequences), which is quite a natural parameter here and part of the explanation for the good behavior of \TS on partially sorted inputs. Finally, we evaluate precisely the worst-case running time of Python's \TS,
and prove that it is equal to $1.5 n \H + \mathcal{O}(n)$.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}\label{intro}
\TS is a sorting algorithm designed in 2002 by Tim Peters~\cite{Peters2015},
for use in the \Python programming language. It was thereafter implemented in
other well-known programming languages such as \Java. The algorithm includes many implementation optimizations, a few heuristics and some refined tuning, but its high-level principle is rather simple:
The sequence $S$ to be sorted is first decomposed greedily into monotonic runs (i.e. 
nonincreasing or nondecreasing subsequences of~$S$ as depicted on Figure~\ref{fig:runs}), which are then merged pairwise according to some specific rules.

\begin{figure}[h]
\centerline{$
S=(~\underbrace{12,10,7,5}_{\text{first run}},
~\underbrace{7,10,14,25,36}_{\text{second run}},
~\underbrace{3,5,11,14,15,21,22}_{\text{third run}},
~\underbrace{20,15,10,8,5,1}_{\text{fourth run}}~)
$}
\caption{A sequence and its {\em run decomposition} computed by \TS: for each run, the first two elements determine if it is increasing or decreasing, then it continues with the maximum number of consecutive elements that preserves the monotonicity.\label{fig:runs}}
\end{figure}

The idea of starting with a decomposition into runs is not new, and already appears in Knuth's \NMS~\cite{Knuth98}, where increasing runs are sorted using the same mechanism as in \MS. 
Other merging strategies combined with decomposition into runs appear in the literature, such as the \MinS of~\cite{Ta09} (see also~\cite{BaNa13} for other considerations on the same topic). 
All of them have nice properties: they run in $\O(n\log n)$ and even $\O(n+n\log\rho)$, where $\rho$ is the number of runs, which is optimal in the model of sorting by comparisons~\cite{Mannila1985}, using the classical counting argument for lower bounds. 
And yet, among all these merge-based algorithms, \TS was favored in several very popular programming languages, which suggests that it performs quite well in practice. 

\TS running time was implicitly assumed to be $\O(n\log n)$, but our unpublished preprint~\cite{AuNiPi15} contains, to our knowledge, the first proof of it. This was more than ten years after \TS started being used instead of \QS in several major programming languages. 
The growing popularity of this algorithm invites for a careful theoretical investigation. In the present paper, we make a thorough analysis which provides a better understanding of the inherent qualities of the merging strategy of \TS. 
Indeed, it reveals that, even without its refined heuristics,\footnote{These heuristics are useful in practice, but do not improve the worst-case complexity of the algorithm.} this is an effective sorting algorithm, computing and merging runs on the fly, using only local properties to make its decisions. 

% As the analysis we made in~\cite{AuNiPi15} was a bit involved and clumsy, w
We first propose in Section~\ref{sec:analysis1} a new pedagogical and self-contained exposition that \TS runs in time $\O(n + n \log n)$, which we want both clear and insightful.
In fact, we prove a stronger statement: on an input consisting of $\rho$ runs
of respective lengths $r_1,\ldots,r_\rho$, we establish that \TS runs
in $\O(n + n \H) \subseteq \O(n + n \log \rho) \subseteq \O(n + n \log n)$,
where $\H = H(r_1/n,\ldots,r_\rho/n)$ and
$H(p_1,\ldots,p_\rho) = - \sum_{i=1}^\rho p_i \log_2(p_i)$ is the binary Shannon entropy.

We then refine this approach, in Section~\ref{sec:analysis2},
to derive precise bounds on the worst-case running time of \TS,
and we prove that it is equal to $1.5 n \H + \mathcal{O}(n)$.
This answers positively a conjecture of~\cite{BuKno18}.
% 
% 
% 
% 
% Using the same approach, we also establish in Section~\ref{sec:analysis2} that it runs in $\O(n+n\log \rho)$, a question left open in our preprint and also in a recent work\footnote{In~\cite{BuKno18}, the authors refined the analysis of~\cite{AuNiPi15} to obtain very precise bounds for the complexity of \TS and of similar algorithms.} on \TS~\cite{BuKno18}.
Of course, the first result follows from the second, but since we believe that each one is interesting on its own, we devote one section to each of them.
% Besides, 
% the second result provides with an explanation to why \TS is a very good sorting algorithm, worth considering in most situations where in-place sorting is not needed.

To introduce our last contribution, we need to look into the evolution of the algorithm: there are actually not one, but two main versions of \TS. The first version of the algorithm contained a flaw, which was spotted in~\cite{GoRoBoBuHa15}: while the input was correctly sorted, the algorithm did not behave as announced (because of a broken invariant).
This was discovered by De Gouw and his co-authors while trying to prove formally the correctness of \TS. 
They proposed a simple way to patch the algorithm, which was quickly adopted in Python, leading to what we consider to be the real \TS. This is the one we analyze in Sections~\ref{sec:analysis1} and~\ref{sec:analysis2}. 
On the contrary, Java developers chose to stick with the first version of \TS, and adjusted some tuning values (which depend on the broken invariant; this is explained in Sections~\ref{presentation} and~\ref{sec:java}) to prevent the bug exposed by~\cite{GoRoBoBuHa15}. Motivated by its use in Java, we explain in Section~\ref{sec:java} how, at the expense of very complicated technical details, the elegant proofs of the Python version can be twisted to prove the same results for this older version. While working on this analysis, we discovered yet another error in the correction made in~Java. Thus, we compute yet another patch, even if we strongly agree that the algorithm proposed and formally proved in~\cite{GoRoBoBuHa15} (the one currently implemented in Python) is a better option.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{TimSort core algorithm}\label{presentation}


\begin{algorithm}[t]
\begin{small}
\SetArgSty{texttt}
\DontPrintSemicolon
\SetKwInOut{Input}{Input}
\Input{A sequence $S$ to sort}
\KwResult{The sequence $S$ is sorted into a single run, which  remains on the 
stack.}
\BlankLine
\SetKwInput{KwData}{Note}
\KwData{The function {\tt merge\_force\_collapse} repeatedly pops the last two runs on the stack~$\runstack$, merges them and pushes the resulting run back on the stack.}
\BlankLine
$\rundecomp \gets $ a run decomposition of $S$\;
$\runstack \gets $ an empty stack\;
\While(\tcp*[f]{main loop of \TS}){$\rundecomp\neq \emptyset$\label{algline:begin_loop}}{
  remove a run $r$ from $\rundecomp$ and push $r$ onto $\runstack$\;
  {\tt merge\_collapse}($\runstack$)\;\label{algline:end_loop}
}
\If(\tcp*[f]{the height of $\runstack$ is its number of runs}){$\height(\runstack) \neq 1$}{
  {\tt merge\_force\_collapse}($\runstack$)
}
\end{small}
\caption{\TS \hfill(Python 3.6.5) \label{alg:TimSortMainLoop}}
\end{algorithm}

The idea of \TS is to design a merge sort that can exploit the possible  
``non randomness'' of the data, without having to detect it beforehand and 
without damaging the performances on random-looking data. This follows the ideas 
of adaptive sorting (see~\cite{Mannila1985} for a survey on taking presortedness 
into account when designing and analyzing sorting algorithms).

The first feature of \TS is to work on the natural decomposition of the input  
sequence into maximal runs. In order to get larger subsequences, \TS allows both 
nondecreasing and decreasing runs, unlike most merge sort algorithms. 

Then, the merging strategy of \TS~(Algorithm~\ref{alg:TimSortMainLoop}) is quite simple yet very efficient. The runs are considered in the order  
given by the run decomposition and successively pushed onto a stack. 
If some conditions on the size of the topmost runs of the stack are not satisfied after a new run has been pushed, this can trigger a series of merges between pairs of runs at the top or right under. 
And at the end, when all the runs in the initial decomposition 
have been pushed, the last operation is to merge the remaining runs two by two, starting
at the top of the stack, to get a sorted sequence.
The conditions on the stack and the merging rules are implemented in the  
subroutine called~{\tt merge\_collapse} detailed in Algorithm~\ref{alg:merge_collapse}. 
This is what we consider to be \TS core mechanism and this is the main focus of our analysis. 

\begin{algorithm}[t]
\begin{small}
\SetArgSty{texttt}
\DontPrintSemicolon
\SetKwInOut{Input}{Input}
\Input{A stack of runs $\runstack$}
\KwResult{The invariant of Equations~\eqref{eq:inv1} and~\eqref{eq:inv2} is established.}
\BlankLine
\SetKwInput{KwData}{Note}
\KwData{The runs on the stack are denoted by $\runstack[1]\dots\runstack[\height(\runstack)]$, from top to bottom. The length of run $\runstack$[i] is denoted by $\rs_i$. The blue highlight indicates that the condition was not present in the original version of \TS (this will be discussed in section~\ref{sec:java}).}
\BlankLine
\While{$\height(\runstack)>1$}{
  $n \gets \height(\runstack) - 2$ 
    \BlankLine
  \If{
  ($n > 0$ and $\rs_{3}\leqslant \rs_{2} + \rs_{1}$)
  \textcolor{blue}{ or ($n > 1$ and $\rs_{4} \leqslant \rs_{3} + \rs_{2}$)}\,\label{algline:new_cond}}{
    \If{$\rs_{3} < \rs_{1}$}{
      merge runs $\runstack$[2] and $\runstack$[3] on the stack\;
    }
    \lElse{merge runs $\runstack$[1] and $\runstack$[2] on the stack}
  }
  \ElseIf{$\rs_{2} \leqslant \rs_{1}$}{
    merge runs $\runstack$[1] and $\runstack$[2] on the stack
  }
  \lElse{
    break
  }
}
\end{small}
\caption{The {\tt merge\_collapse} procedure \hfill(Python 3.6.5)\label{alg:merge_collapse}}
\end{algorithm}

Another strength of \TS is the use of many effective heuristics to save
time, such as ensuring that the initial runs are not to small thanks to an insertion sort 
or using a special technique called ``galloping'' to optimize the merges. 
However, this does not interfere with our analysis and we will not discuss this matter any further.

Let us have a closer look at Algorithm~\ref{alg:merge_collapse} which is a pseudo-code transcription
of the {\tt merge\_collapse} procedure found in the latest version of Python (3.6.5). 
To illustrate its mechanism, an example of execution of the main loop of \TS (lines~\ref*{algline:begin_loop}-\ref*{algline:end_loop} of Algorithm~\ref{alg:TimSortMainLoop}) is given in Figure~\ref{fig:ts-python-exec}. 
As stated in its note~\cite{Peters2015}, Tim Peter's idea was that: 
\begin{quote}
``The thrust of these rules when they trigger merging is to balance the run
lengths as closely as possible, while keeping a low bound on the number of
runs we have to remember.''    
\end{quote}
To achieve this, the merging conditions of {\tt merge\_collapse} are designed  
to ensure that the following invariant\footnote{Actually, in~\cite{Peters2015}, the invariant is only stated for the 3 topmost runs of the stack.} is true at the end of the procedure:
\begin{eqnarray}
    \rs_{i+2}&>&\rs_{i+1}+\rs_{i}, \label{eq:inv1}\\
    \rs_{i+1}&>&\rs_{i}.\label{eq:inv2}
\end{eqnarray}
This means that the runs lengths $\rs_i$ 
on the  stack grow at least as fast as the Fibonacci numbers and, therefore, 
that the height of the stack stays logarithmic (see Lemma~\ref{lm:h-is-small}, section~\ref{sec:analysis1}). 

Note that the bound on the height of the stack is not enough to justify the $\O(n\log n)$ running time of \TS. Indeed, without the smart strategy used to merge the runs ``on the fly'', it is easy to build an example using a stack containing at most two runs and that gives a $\Theta(n^2)$ complexity: just assume that all runs have size two, push them one by one onto a stack and perform a merge each time there are two runs in the stack. 

We are now ready to proceed with the analysis of \TS complexity. As mentioned earlier, Algorithm~\ref{alg:merge_collapse} does not correspond to the first implementation of \TS in Python, nor to the current one in Java, but to the latest Python version. The original version will be discussed in details later, in Section~\ref{sec:java}.   

\begin{figure}[t]
\begin{center}
\begin{small}
\setlength{\tabcolsep}{1pt}
\begin{tabular}{ccccccccccccccc}
\begin{tikzpicture}[every node/.style={align=center,text width=1em}]
\matrix (A) [matrix of nodes,nodes={draw}] { {\bf 24}\\ };
\node [above] at (A.north) {$\#1$};
\end{tikzpicture}
&
\begin{tikzpicture}[every node/.style={align=center,text width=1em}]
\matrix (A) [matrix of nodes,nodes={draw}] { {\bf 18}\\24\\ };
\node [above] at (A.north) {$\#1$};
\end{tikzpicture}
&
\begin{tikzpicture}[every node/.style={align=center,text width=1em}]
\matrix (A) [matrix of nodes,nodes={draw}] { {\bf 50}\\18\\24\\ };
\node [above] at (A.north) {$\#1$};
\end{tikzpicture}
&
\begin{tikzpicture}[every node/.style={align=center,text width=1em}]
\matrix (A) [matrix of nodes,nodes={draw}] { 50\\42\\ };
\node [above] at (A.north) {$\#2$};
\end{tikzpicture}
&
\begin{tikzpicture}[every node/.style={align=center,text width=1em}]
\matrix (A) [matrix of nodes,nodes={draw}] { 92\\ };
\node [above] at (A.north) {$\#3$};
\end{tikzpicture}
&
\begin{tikzpicture}[every node/.style={align=center,text width=1em}]
\matrix (A) [matrix of nodes,nodes={draw}] { {\bf 28}\\92\\ };
\node [above] at (A.north) {$\#1$};
\end{tikzpicture}
&
\begin{tikzpicture}[every node/.style={align=center,text width=1em}]
\matrix (A) [matrix of nodes,nodes={draw}] { {\bf 20}\\28\\92\\ };
\node [above] at (A.north) {$\#1$};
\end{tikzpicture}
&
\begin{tikzpicture}[every node/.style={align=center,text width=1em}]
\matrix (A) [matrix of nodes,nodes={draw}] { {\bf 6}\\20\\28\\92\\ };
\node [above] at (A.north) {$\#1$};
\end{tikzpicture}
&
\begin{tikzpicture}[every node/.style={align=center,text width=1em}]
\matrix (A) [matrix of nodes,nodes={draw}] { {\bf 4}\\6\\20\\28\\92\\ };
\node [above] at (A.north) {$\#1$};
\end{tikzpicture}
&
\begin{tikzpicture}[every node/.style={align=center,text width=1em}]
\matrix (A) [matrix of nodes,nodes={draw}] { {\bf 8}\\4\\6\\20\\28\\92\\ };
\node [above] at (A.north) {$\#1$};
\end{tikzpicture}
&
\begin{tikzpicture}[every node/.style={align=center,text width=1em}]
\matrix (A) [matrix of nodes,nodes={draw}] { 8\\10\\20\\28\\92\\ };
\node [above] at (A.north) {$\#2$};
\end{tikzpicture}
&
\begin{tikzpicture}[every node/.style={align=center,text width=1em}]
\matrix (A) [matrix of nodes,nodes={draw}] { 18\\20\\28\\92\\ };
\node [above] at (A.north) {$\#5$};
\end{tikzpicture}
&
\begin{tikzpicture}[every node/.style={align=center,text width=1em}]
\matrix (A) [matrix of nodes,nodes={draw}] { 38\\28\\92\\ };
\node [above] at (A.north) {$\#4$};
\end{tikzpicture}
&
\begin{tikzpicture}[every node/.style={align=center,text width=1em}]
\matrix (A) [matrix of nodes,nodes={draw}] { 66\\92\\ };
\node [above] at (A.north) {$\#3$};
\end{tikzpicture}
&
\begin{tikzpicture}[every node/.style={align=center,text width=1em}]
\matrix (A) [matrix of nodes,nodes={draw}] { {\bf 1}\\66\\92\\ };
\node [above] at (A.north) {$\#1$};
\end{tikzpicture}
\end{tabular}
\begin{tikzpicture}
\draw[decorate,thick,decoration={brace,amplitude=4pt,mirror}] (-3.8,0.2) -- (-2.3,0.2); 
\draw[decorate,thick,decoration={brace,amplitude=4pt,mirror}] (2.0,0.2) -- (5.3,0.2); 
\draw (-3.05,-0.1) node{\scriptsize {\tt merge\_collapse}};
\draw (3.65,-0.1) node{\scriptsize {\tt merge\_collapse}};
\node[text width=\textwidth]{};
\end{tikzpicture}
\end{small}
\end{center}
\vspace{-6mm}
\caption{ The successive states of the stack~$\runstack$ (the values are the  
lengths of the runs) during an execution of the main loop of \TS 
(Algorithm~\ref{alg:TimSortMainLoop}), with the lengths of the runs in 
$\rundecomp$ being $(24, 18, 50, 28, 20, 6, 4, 8, 1)$. 
The label $\#1$ indicates that a run has just been pushed onto the stack. 
The other labels refer to the different merges cases of {\tt merge\_collapse} as translated in Algorithm~\ref{alg:TS translated}.
\label{fig:ts-python-exec}}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{TimSort runs in \texorpdfstring{$\O(n\log n)$}{Lg}}\label{sec:analysis1}

At the first release of \TS~\cite{Peters2015}, a time complexity of $\O(n\log n)$ was 
announced with no element of proof given. It seemed to remain unproved until 
our recent preprint~\cite{AuNiPi15}, where we provide a confirmation of this fact, using 
a proof which is not difficult but a bit tedious. This result was  refined later in~\cite{BuKno18}, where the authors provide lower and upper bounds, including explicit multiplicative constants, for different merge sort algorithms.

Our main concern is to provide an insightful proof of the complexity of \TS, in order to highlight how well designed is the strategy used to choose the order in which the merges are performed.
The present section is more detailed than the following ones as we want it to be
self-contained once \TS has been translated into Algorithm~\ref{alg:TS translated} (see below).

\begin{algorithm}[t]
\begin{small}
\SetArgSty{texttt}
\DontPrintSemicolon
\SetKwInOut{Input}{Input}
\Input{A sequence to $S$ to sort}
\KwResult{The sequence $S$ is sorted into a single run,  which remains on the 
stack.}
\SetKwInput{KwData}{Note}
\KwData{At any time, we denote the height of the stack $\runstack$ by $h$
and its $i$\textsuperscript{th} top-most run (for $1 \leqslant i 
\leqslant h$)  
by $R_i$. The size of this run is denoted by $r_i$.}
\BlankLine
\BlankLine
$\rundecomp \gets $ the run decomposition of $S$\;
$\runstack \gets $ an empty stack\;
\While(\tcp*[f]{main loop of \TS}){$\rundecomp\neq \emptyset$}{
  remove a run $r$ from $\rundecomp$ and push $r$ onto 
$\runstack$\tcp*[r]{\#1$\;$} 
  \While{\true}{\label{algline:inner_while_translated}
    \lIf{$h \geqslant 3$ and $r_1 > r_3$}{
        merge the runs $R_2$ and $R_3$ \tcp*[f]{\#2}
    }
    \lElseIf{$h \geqslant 2$ and $r_1 \geqslant r_2$}{
        merge the runs $R_1$ and $R_2$ \tcp*[f]{\#3}
    }
    \lElseIf{$h \geqslant 3$ and $r_1+r_2 \geqslant r_3$}{
        merge the runs $R_1$ and $R_2$ \tcp*[f]{\#4}
    }
    \textcolor{blue}{\lElseIf{$h \geqslant 4$ and $r_2+r_3 \geqslant r_4$}{ \label{algline:new_cond_translated}
        merge the runs $R_1$ and $R_2$ \tcp*[f]{\#5}
    }}
    \lElse{break}
  }
}
\lWhile{$h \neq 1$}{
  merge the runs $R_1$ and $R_2$%two top-most runs on the stack $\runstack$
}
\end{small}
\caption{TimSort: translation of Algorithm~\ref{alg:TimSortMainLoop} and Algorithm~\ref{alg:merge_collapse}\label{alg:TS translated}}
\end{algorithm}

As our analysis is about to demonstrate, in terms of worst-case complexity, the good performances of \TS do not rely on the way merges are performed. 
Thus we choose to ignore their many optimizations and consider that merging two runs of lengths~$r$ and~$r'$ requires both $r+r'$ element moves and $r+r'$ element comparisons.
Therefore, to quantify the running time of \TS, we only take into account the number of comparisons performed.

In particular, aiming at computing precise bounds on the running time of \TS, we
follow~\cite{golin1993queue,AuNiPi15,BuKno18,munro2018nearly} and define the
\emph{merge cost} for merging two runs of lengths $r$ and $r'$ as $r + r'$,
i.e., the length of the resulting run. Henceforth, we will identify the time spent for
merging two runs with the merge cost of this merge.

\vfill

\begin{theorem}\label{thm:complexity n + n H}
Let $\C$ be the class of arrays of length $n$, whose run decompositions
consist of $\rho$ monotonic runs of
respective lengths $r_1,\ldots,r_\rho$.
Let $H(p_1,\ldots,p_\rho) = - \sum_{i=1}^\rho p_i \log_2(p_i)$ be the binary Shannon entropy,
and let $\H = H(r_1/n,\ldots,r_\rho/n)$.

The running time of \TS on arrays in $\C$ is
$\mathcal{O}(n + n \H)$. 
\end{theorem}

From this result, we easily deduce the following complexity bound on \TS,
which is less precise but more simple.

\begin{theorem}\label{thm:complexity n log n}
The running time of \TS on arrays of length $n$ that consist of $\rho$ monotonic runs is
$\O(n + n\log \rho)$, and therefore $\O(n \log n)$.
\end{theorem}

\begin{proof}
The function $f : x \mapsto - x \ln(x)$ is concave on the interval $\mathbb{R}_{>0}$ of positive real numbers,
since its second derivative is $f''(x) = - 1/x$. Hence, when $p_1,\ldots,p_\rho$ are
positive real numbers that sum up to one, we have
$H(p_1,\ldots,p_\rho) = {\textstyle\sum_{i=1}^\rho f(p_i)/\ln(2)} \leqslant \rho f(1/\rho)/\ln(2) = \log_2(\rho)$.
In particular, this means that $\H \leqslant \log_2(\rho)$, and therefore that
\TS runs in time $\O(n + n\log \rho)$.
Since $\rho \leqslant n$, it further follows that $\O(n + n\log \rho) \subseteq \O(n + n\log n) = \O(n \log n)$, which completes the proof.
\end{proof}

Before proving Theorem~\ref{thm:complexity n + n H},
we first show that it is optimal up to a multiplicative constant,
by recalling the following variant of a result from~\cite[Theorem~2]{BaNa13}.

\begin{proposition}\label{proposition:optimality}
For every algorithm comparing only pairs of elements,
there exists an array in the class $\C$ whose sorting
requires at least $n \H - 3 n$ element comparisons.
\end{proposition}

\begin{proof}
In the comparison model, at least $\log_2(|\C|)$ element comparisons
are required for sorting all arrays in $\C$.
Hence, we prove below that $\log_2(|\C|) \geqslant n \H - 3 n$.

Let $\pi = (\pi_1,\ldots,\pi_\rho)$ be a partition of the set $\{1,\ldots,n\}$
into $\rho$ subsets of respective sizes $r_1,\ldots,r_\rho$;
we say that $\pi$ is \emph{nice} if $\max \pi_i > \min \pi_{i+1}$ for all $i \leqslant \rho-1$.
Let us denote by $\mathcal{P}$ the set of partitions $\pi$ of $\{1,\ldots,n\}$ such that $|\pi_i| = r_i$
for all $i \leqslant \rho$, and by $\mathcal{N}$ the set of nice partitions.

Let us transform every partition $\pi \in \mathcal{P}$ into a nice partition as follows.
First, by construction of the run decomposition of an array, we know that $r_1,\ldots,r_{\rho-1} \geqslant 2$,
and therefore that $\min \pi_i < \max \pi_i$ for all $i \leqslant \rho-1$.
Then, for all $i \leqslant \rho-1$, if $\max \pi_i < \min \pi_{i+1}$, we exchange the partitions to which belong $\max \pi_i$ and $\min \pi_{i+1}$, i.e., we move $\max \pi_i$ from the set $\pi_i$ to $\pi_{i+1}$,
and $\min \pi_{i+1}$ from $\pi_{i+1}$ to $\pi_i$. Let $\pi^\ast$ be the partition obtained after
these exchanges have been performed.

Observe that $\pi^\ast$ is nice, and that at most $2^{\rho-1}$ partitions $\pi \in \mathcal{P}$
can be transformed into $\pi^\ast$. This proves that $2^{\rho-1}|\mathcal{N}| \geqslant |\mathcal{P}|$.
Let us further identify every nice partition $\pi^\ast$ with an array in $\C$,
which starts with the elements of $\pi^\ast_1$ (listed in increasing order),
then of $\pi^\ast_2, \ldots, \pi^\ast_\rho$.
We thereby define an injective map from $\mathcal{N}$ to $\C$,
which proves that $|\C| \geqslant |\mathcal{N}|$.

Finally, variants of the Stirling formula indicate that
$(k/e)^k \leqslant k! \leqslant e \sqrt{k} (k/e)^k$ for all $k \geqslant 1$.
This proves that
\begin{align*}
\log_2(|\C|) & \geqslant \log_2(|\C|) \geqslant (1 - \rho) + \log_2(|\mathcal{P}|) \\
& \geqslant (1 - \rho) + n \log_2(n) - \rho \log_2(e) - {\textstyle\sum_{i=1}^\rho} (r_i+1/2) \log_2(r_i) \\
& \geqslant n \H + (1 - \rho - \rho \log_2(e)) - 1/2 {\textstyle\sum_{i=1}^\rho} \log_2(r_i).
\end{align*}
By concavity of the function $x \mapsto \log_2(x)$, it follows that
$\textstyle\sum_{i=1}^\rho \log_2(r_i) \leqslant \rho \log_2(n/\rho)$.
One checks easily that the function $x \mapsto x \log_2(n/x)$ takes its maximum value at $x = n/e$,
and since $n \geqslant \rho$, we conclude that
$\log_2(|\C|) \geqslant n \H - (1+\log_2(e)+\log_2(e)/e) n \geqslant n \H - 3 n$.
\end{proof}

We focus now on proving Theorem~\ref{thm:complexity n + n H}.
The first step consists in rewriting Algorithm~\ref{alg:TimSortMainLoop} and 
Algorithm~\ref{alg:merge_collapse} in a form that is easier to deal with. This is done in Algorithm~\ref{alg:TS translated}. 

\begin{claim}
For any input, Algorithms~\ref{alg:TimSortMainLoop} and~\ref{alg:TS translated} perform the same comparisons. 
\end{claim}

\begin{proof}
The only difference is that Algorithm~\ref{alg:merge_collapse} was changed into the \texttt{while} loop of lines~5 to~10 in Algorithm~\ref{alg:TS translated}.
Observing the different cases, it is straightforward to verify that merges involving the same runs take place in the same order in both algorithms.
Indeed, if $r_3 < r_1$, then $r_3 \leqslant r_1 + r_2$, and therefore line 5 is triggered in Algorithm~\ref{alg:merge_collapse}, so that
both algorithms merge the $2$\textsuperscript{nd} and $3$\textsuperscript{rd} runs.
On the contrary, if $r_3 \geqslant r_1$, then both algorithms merge the $1$\textsuperscript{st} and $2$\textsuperscript{nd} runs if and only if
$r_2 \leqslant r_1$ or $r_3 \leqslant r_1 + r_2$ ({\color{blue}or $r_4 \leqslant r_2 + r_3$}).
\end{proof}

\begin{remark2}\label{rem:main-loop}
Proving Theorem~\ref{thm:complexity n log n} only requires
analyzing the \emph{main loop} of the algorithm (lines~3 to 10).
Indeed, computing the run decomposition (line~1) can be done on the fly,
by a greedy algorithm, in time linear in $n$, and the \emph{final loop} (line~11) might be performed in the main loop by adding a fictitious run of length $n+1$ at the end of the decomposition.

In the sequel, for the sake of readability, we also omit
checking that $h$ is large enough to trigger the cases \#2 to \#5.
Once again, such omissions are benign, since
adding fictitious runs of respective lengths $8n$, $4n$, $2n$ and $n$
(in this order) at the beginning of the decomposition
would ensure that $h \geqslant 4$ during the whole loop.
\end{remark2}

% In Algorithm~\ref{alg:TS translated}, we can see that the merges performed during Case \#2 allow a very large run to be pushed and ``absorbed'' onto the stack without being merged all the way down, but by collapsing the stack under this run instead. Meanwhile, the purpose of Cases \#3--\#5 is mainly to re-establish the invariant~\eqref{eq:inv1} and~\eqref{eq:inv2}, ensuring an exponential growth of the run lengths within the stack.
% Along this process, the cost of keeping the stack in good shape is compensated by the absorption of these large runs which naturally calls for an \emph{amortized complexity} analysis.

We sketch now the main steps of our proof, i.e., the amortized analysis of the main loop.
A first step is to establish the invariant~\eqref{eq:inv1} and~\eqref{eq:inv2},
ensuring an exponential growth of the run lengths within the stack.

Elements of the input array are easily identified by their starting position in the array, so we consider them as well-defined and distinct entities (even if they have the same value). 
The \emph{height} of an element in the stack of runs is the number of runs that are
below it in the stack: the elements belonging to the run~$R_i$ in the stack
$\S = (R_1,\ldots, R_h)$ have height $h-i$, and we recall that the length of the run $R_i$ is denoted
by $r_i$.
% To simplify the presentation, we also distinguish two kinds of tokens, the \ctok-tokens and the \stok-tokens, which can both be used to pay for comparisons.

\begin{lemma}\label{lm:invariant I}
At any step during the main loop of \TS, we have~$r_i+r_{i+1}<r_{i+2}$ for all $i \in \{3,\ldots,h-2\}$.
\end{lemma}

\begin{proof}
We proceed by induction. The proof consists in verifying that, if the
invariant holds at some point, then it still holds when an update of the stack occurs in one of the five situations labeled \#1 to \#5 in the algorithm.
This can be done by a straightforward case analysis.
We denote by $\overline{\S}=(\overline{R}_1,\ldots, \overline{R}_{\overline{h}})$ the new state of the stack after the update:
\begin{disjunction}
  \item If Case \#1 just occurred, a new run $\overline{R}_1$ was pushed.
  This implies that none of the conditions of Cases \#2 to \#5 hold in $\S$, otherwise merges would have continued.  In particular, we have $r_2+r_3<r_4$.
  As $\overline{r}_i=r_{i-1}$ for all $i\geqslant 2$, and since the invariant holds for $\S$, it also
  holds for $\overline{\S}$.
  
  \item If one of the Cases \#2 to \#5 just occurred, $\overline{r}_i=r_{i+1}$ for all $i\geqslant 3$. Since the invariant holds for $\S$, it must also hold for $\overline{\S}$.
\end{disjunction}
\end{proof}

\begin{corollary}\label{cor:invariant I'}
During the main loop of \TS, whenever a run is about to be pushed onto the stack, we have
$r_i \leqslant 2^{(i+1-j)/2} r_j$ for all integers $i \leqslant j \leqslant h$.
\end{corollary}

\begin{proof}
Since a run is about to be pushed, none of the conditions of Cases \#2 to \#5 hold in the stack $\S$.
Hence, we have $r_1 < r_2$, $r_1 + r_2 < r_3$ and $r_2 + r_3 < r_4$, and Lemma~\ref{lm:invariant I}
further proves that $r_i + r_{i+1} < r_{i+2}$ for all $i \in \{3,\ldots,h-2\}$.
In particular, for all $i \leqslant h-2$, we have $r_i < r_{i+1}$, and thus
$2 r_i \leqslant r_i + r_{i+1} \leqslant r_{i+2}$.
It follows immediately that $r_i \leqslant 2^{-k} r_{i+2k} \leqslant 2^{-k} r_{i+2k+1}$
for all integers $k \geqslant 0$, which is exactly the statement of Corollary~\ref{cor:invariant I'}.
\end{proof}

Corollary~\ref{cor:invariant I'} will be crucial in proving that the main loop of \TS can be performed
for a merge cost $\O(n + n \H)$. However, we do not prove this upper bound directly.
Instead, we need to distinguish several situations that may occur within the main loop.

Consider the sequence of Cases \#1 to \#5 triggered during the execution of the main loop of \TS.
It can be seen as a word on the alphabet $\{\#1,\ldots,\#5\}$ that starts with \#1, which completely encodes the execution of the algorithm. 
We split this word at every \#1, so that each piece corresponds to an iteration of the main loop. 
Those pieces are in turn split into two parts, at the first occurrence of a symbol \#3, \#4 or \#5.
The first half is called a \emph{starting sequence} and is made of a \#1 followed by the maximal number of \#2's. 
The second half is called an \emph{ending sequence}, it starts with \#3, \#4 or \#5 (or is empty) and it contains no occurrence of \#1 (see Figure~\ref{fig:sequence} for an example).

\begin{figure}[H]
\smallskip
\centerline{$
\underbrace{\#1\;\#2\;\#2\;\#2}_{\text{starting seq.}}
~~\underbrace{\#3\;\#2\;\#5\;\#2\;\#4\;\#2}_{\text{ending seq.}}
~~~\underbrace{\#1\;\#2\;\#2\;\#2\;\#2\;\#2}_{\text{starting seq.}}
~~\underbrace{\#5\;\#2\;\#3\;\#3\;\#4\;\#2}_{\text{ending seq.}}
$}
\caption{The decomposition of the encoding of an execution into starting and ending sequences.\label{fig:sequence}}
\end{figure}

We bound the merge cost of starting sequences first, and will deal with ending sequences afterwards.

\begin{lemma}\label{lm:starting}
The cost of all merges performed during the starting sequences is~$\O(n)$.
\end{lemma}

\begin{proof}
More precisely, for a stack $\S=(R_1,\ldots,R_h)$, we prove that a starting sequence beginning with a push of a run~$R$ of size $r$ onto $\S$ uses at most $\gamma r$ comparisons in total,
where~$\gamma$ is the real constant $2 \sum_{j \geqslant 1} j / 2^{j/2}$. 
After the push, the stack is $\overline{\S} = (R,R_1,\ldots,R_h)$ and,
if the starting sequence contains $k \geqslant 1$ letters, i.e. $k-1$ occurrences of \#2, 
then this sequence amounts to merging the runs $R_1$, $R_2$, \ldots, $R_k$.
Since no merge is performed if $k = 1$, we assume below that $k \geqslant 2$.

More precisely, the total cost of these merges is
\[
C = (k-1)r_1+(k-1)r_2 + (k-2)r_3+\ldots + r_k \leqslant {\textstyle\sum_{i=1}^k} (k+1-i)r_i.
\]
The last occurrence of Case \#2 ensures that $r > r_k$,
hence applying Corollary~\ref{cor:invariant I'} to the stack $\S = (R_1,\ldots,R_h)$ shows that
$r \geqslant r_k \geqslant 2^{(k-1-i)/2} r_i$ for all $i = 1,\ldots,k$.
It follows that
\[
C / r \leqslant {\textstyle\sum_{i=1}^k} (k+1-i)2^{(i+1-k)/2} =
2 {\textstyle\sum_{j=1}^k} j 2^{-j/2} < \gamma.
\]

This concludes the proof, since each run is the beginning of exactly one starting sequence, and the sum of their lengths is $n$.
\end{proof}

Now, we must take care of run merges that take place during ending sequences.
The cost of merging two runs will be taken care of by making run elements pay tokens:
whenever two runs of lengths $r$ and $r'$ are merged, $r+r'$ tokens are paid
(not necessarily by the elements of those runs that are merged).
In order to do so, and to simplify the presentation, we also distinguish two kinds of tokens,
the \ctok-tokens and the \stok-tokens, which can both be used to pay for comparisons.

Two \ctok-tokens and one \stok-token are credited to an element when its run is pushed onto the stack
or when its height later decreases \emph{because of a merge that took place during an ending sequence}:
in the latter case, all the elements of $R_1$ are credited when $R_1$ and $R_2$ are merged, and
all the elements of $R_1$ and $R_2$ are credited when $R_2$ and $R_3$ are merged.
% 
Tokens are spent to pay for comparisons, depending on % \juge{which case of Algorithm~\ref{alg:TS translated} is triggered:}
the case triggered:
\begin{itemize}
\item Case \#2: every element of $R_1$ and $R_2$ pays 1 \ctok.
This is enough to cover the cost of merging $R_2$ and $R_3$, 
because $r_1 > r_3$ in this case, and therefore $r_2+r_1 \geqslant r_2 + r_3$.
\item Case \#3: every element of $R_1$ pays 2 \ctok. In this case $r_1\geqslant r_2$, and the cost is $r_1+r_2 \leqslant 2r_1$.
\item Cases \#4 and \#5: every element of $R_1$ pays 1 \ctok
and every element of $R_2$ pays 1 \stok. The cost $r_1+r_2$ is exactly the number of tokens spent.
\end{itemize}

\begin{lemma}\label{lm:balance}
The balances of \ctok-tokens and \stok-tokens of each element remain non-negative throughout  the main loop of \TS.
\end{lemma}

\begin{proof}
In all four cases \#2 to \#5, because the height of the elements of $R_1$ and possibly the height of those of $R_2$ decrease,
the number of credited \ctok-tokens after the merge is at least the number of \ctok-tokens spent.
The \stok-tokens are spent in Cases \#4 and \#5 only: every element of $R_2$ pays one \stok-token, and then belongs to the topmost run $\overline{R}_1$ of the new stack $\overline{\S}=(\overline{R}_1,\ldots, \overline{R}_{h-1})$ obtained after  merging $R_1$ and $R_2$. Since 
$\overline{R}_{i} = R_{i+1}$ for $i\geqslant 2$, the condition of Case~\#4 implies that $\overline{r}_1\geqslant \overline{r}_2$ and
the condition of Case~\#5 implies that $\overline{r}_1+\overline{r}_2\geqslant \overline{r}_3$: in both cases, the next modification of the stack $\overline{\S}$ is another merge, which belongs to the same ending sequence.

This merge decreases the height of $\overline{R}_1$, and therefore decreases the height of the elements of $R_2$, who will regain one \stok-token without losing any, since the topmost run of the stack never
pays with \stok-tokens. This proves that, whenever an element pay one \stok-token, the next modification is another merge during which it regains its \stok-token. This concludes the proof by direct induction.
\end{proof}

Finally, consider some element belonging to a run $R$.
Let $\S$ be the stack just before pushing the run $R$, and let
$\overline{S} = (\overline{R}_1,\ldots,\overline{R}_h)$ be the
stack just after the starting sequence of the run $R$
(i.e., the starting sequence initiated when $R$ is pushed onto $\S$) is over.
Every element of $R$ will be given at most $2h$ \ctok-tokens and $h$ \stok-tokens during the main loop
of the algorithm.

\begin{lemma}\label{lm:h-is-small}
The height of the stack when the starting sequence of the run $R$ is over
satisfies the inequality $h \leqslant 4 + 2 \log_2(n/r)$.
\end{lemma}

\begin{proof}
Since none of the runs $\overline{R}_3,\ldots,\overline{R}_h$
has been merged during the starting sequence of $R$,
applying Corollary~\ref{cor:invariant I'} to the stack $\S$ proves that
$\overline{r}_3 \leqslant 2^{2-h/2} \overline{r}_h \leqslant 2^{2-h/2} n$.
The run $R$ has not yet been merged either, which means that $r = \overline{r}_1$.
Moreover, at the end of this starting sequence, the conditions of case \#2 do not hold anymore,
which means that $\overline{r}_1 \leqslant \overline{r}_3$.
It follows that $r = \overline{r}_1 \leqslant \overline{r}_3 \leqslant 2^{2-h/2} n$,
which entails the desired inequality.
\end{proof}

Collecting all the above results is enough to prove Theorem~\ref{thm:complexity n + n H}.
First, as mentioned in Remark~\ref{rem:main-loop},
computing the run decomposition can be done in linear time. Then, we proved
that the starting sequences of the main loop have a merge cost $\O(n)$,
and that the ending sequences have a merge cost
$\O(\sum_{i=1}^\rho (1+\log(n/r_i))r_i) = \O(n + n \H)$.
Finally, the additional
merges of line~11 may be taken care of by Remark~\ref{rem:main-loop}.
This concludes the proof of the theorem.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Refined analysis and precise worst-case complexity}\label{sec:analysis2}

The analysis performed in Section~\ref{sec:analysis1} proves that \TS sorts arrays in time
$\O(n + n \H)$. Looking more closely at the constants hidden in the $\O$ notation,
we may in fact prove that the cost of merges performed during an execution of \TS
is never greater than $6 n \H + \O(n)$.
However, the lower bound provided by Proposition~\ref{proposition:optimality}
only proves that the cost of these merges must be at least $n \H + \O(n)$.
In addition, there exist sorting algorithms~\cite{munro2018nearly}
whose merge cost is exactly $n \H + \O(n)$.

Hence, \TS is optimal only up to a multiplicative constant.
We focus now on finding the least real constant $\kappa$ such that
the merge cost of \TS is at most $\kappa n \H + \O(n)$,
thereby proving a conjecture of~\cite{BuKno18}.

\begin{theorem}\label{thm:complexity 1.5 n + n H}
The merge cost of \TS on arrays in $\C$ is at most $\kappa n \H + \O(n)$,
where $\kappa = 3/2$. Furthermore, $\kappa = 3/2$ is the least real constant
with this property.
\end{theorem}

The rest of this Section is devoted to proving Theorem~\ref{thm:complexity 1.5 n + n H}.
The theorem can be divided into two statements: one that states that \TS is asymptotically
optimal up to a multiplicative constant of $\kappa = 3/2$, and one that states that $\kappa$ is optimal.
The latter statement was proved in~\cite{BuKno18}. Here, we borrow their proof for the sake of completeness.

\begin{proposition}\label{pro:kappa-optimal-BuKno18}
There exist arrays of length $n$ on which the merge cost of \TS is at least $3/2 n \log_2(n) + \O(n)$.
\end{proposition}

\begin{proof}
The dynamics of \TS when sorting an array involves only the lengths of the monotonic runs in which
the array is split, not the actual array values. Hence, we identify every array with the sequence
of its run lengths. Therefore, every sequence of run lengths $\langle r_1,\ldots,r_\rho \rangle$ such that
$r_1,\ldots,r_{\rho-1} \geqslant 2$, $r_\rho \geqslant 1$ and $r_1+\ldots+r_\rho = n$ represents
at least one possible array of length $n$.

We define inductively a sequence of run lengths $\R(n)$ as follows:
\[\R(n) = \begin{cases}\langle n \rangle & \text{if } 1 \leqslant n \leqslant 6, \\
\R(k) \cdot \R(k-2) \cdot \langle 2\rangle & \text{if } n = 2k \text{ for some } k \geqslant 4, \\
\R(k) \cdot \R(k-1) \cdot \langle 2\rangle & \text{if } n = 2k+1 \text{ for some } k \geqslant 3,
\end{cases}\]
where the concanetation of two sequences $s$ and $t$ is denoted by $s \cdot t$.

Then, let us apply the main loop of TimSort
on an array whose associated monotonic runs
have lengths $\mathbf{r} = \langle r_1,\ldots,r_\rho \rangle$,
starting with an empty stack.
We denote the associated merge cost by $c(\mathbf{r})$ and,
if $\overline{\S} = (\overline{R}_1,\ldots,
\overline{R}_{\overline{h}})$ is the stack obtained
after the main loop has been applied,
we denote by $s(\mathbf{r})$ the sequence
$\langle \overline{r}_1,\ldots,\overline{r}_{\overline{h}}\rangle$.

An immediate induction shows that, if
$r_1 \geqslant r_2+\ldots+r_\rho+1$, then
$c(\mathbf{r}) = c(\langle r_2,\ldots,r_\rho\rangle)$ and
$s(\mathbf{r}) = \langle r_1 \rangle \cdot s(\langle r_2,\ldots,r_\rho\rangle)$. Similarly, if $r_1 \geqslant r_2+\ldots+r_\rho+1$ and
$r_2 \geqslant r_3+\ldots+r_\rho+1$, then
$c(\mathbf{r}) = c(\langle r_3,\ldots,r_\rho\rangle)$ and
$s(\mathbf{r}) = \langle r_1,r_2 \rangle \cdot s(\langle r_3,\ldots,r_\rho\rangle)$.

Consequently, and by another induction on $n$, it holds that
$s(\R(n)) = \langle n \rangle$ and that
\[c(\R(n)) = \begin{cases} 0 & \text{if } 1 \leqslant n \leqslant 6, \\
c(\R(k)) + c(\R(k-2)) + 3k & \text{if } n = 2k \text{ for some } k \geqslant 4, \\
c(\R(k)) + c(\R(k-1)) + 3k+2 & \text{if } n = 2k+1 \text{ for some } k \geqslant 3.
\end{cases}\]

Let $u_x = c(\R(\lfloor x \rfloor))$
and $v_x = (u_{x-4} - 15/2)/x - 3 \log_2(x) / 2$.
An immediate induction shows that $c(\R(n)) \geqslant c(\R(n+1))$
for all integers $n \geqslant 0$, which means that $x \mapsto u_x$
is non-decreasing. Then, we have 
$u_n = u_{n/2} + u_{(n-3)/2} + \lceil 3n/2 \rceil$
for all integers $n \geqslant 6$, and therefore
$u_x \geqslant 2 u_{x/2-2} + 3(x-1)/2$ for all real numbers $x \geqslant 6$. Consequently, for $x \geqslant 11$, it holds that
\[x v_x = u_{x-4} - 3 x \log_2(x) / 2 - 15/2 \geqslant
2 u_{x/2-4} + 3(x-5)/2 - 3 x \log_2(x) / 2 - 15/2 = x v_{x/2}.\]
This proves that $v_x \geqslant v_{x/2}$, from which it follows
that $v_x \geqslant \inf\{v_t \,:\, 11/2 \leqslant t < 11\}$.
Since $v_t = -15/(2t) -3 \log_2(t)/2 \geqslant -15/11 - 3 \log_2(11)/2 \geqslant -7$ for all $t \in [11/2,11)$,
we conclude that
$v_x \geqslant -7$ for all $x \geqslant 11$, and thus that
\[c(\R(n)) = u_n \geqslant (n+4) v_{n+4} + 3 (n+4) \log_2(n+4) / 2 \geqslant 3 n \log_2(n) / 2 - 7 (n+4),\] thereby proving
Proposition~\ref{pro:kappa-optimal-BuKno18}.
\end{proof}

It remains to prove the first statement of Theorem~\ref{thm:complexity 1.5 n + n H}. Our initial step towards
this statement consists in refining Lemma~\ref{lm:invariant I}.
This is the essence of Lemmas~\ref{lm:invariant II} to~\ref{lm:invariant IV}.

\begin{lemma}\label{lm:invariant II}
At any step during the main loop of \TS, if $h \geqslant 4$,
we have~$r_2<r_4$ and~$r_3<r_4$.
\end{lemma}

\begin{proof}
We proceed by induction. The proof consists in verifying that, if the
invariant holds at some point, then it still holds when an update of the stack occurs in one of the five situations labeled \#1 to \#5 in the algorithm.
This can be done by a straightforward case analysis.
We denote by $\S=(R_1,\ldots, R_h)$ the stack just before
the update, and by
$\overline{\S}=(\overline{R}_1,\ldots, \overline{R}_{\overline{h}})$ 
the new state of the stack after the update:
\begin{disjunction}
  \item If Case \#1 just occurred, a new run $\overline{R}_1$ was pushed.
  This implies that the conditions of Cases \#2 and \#4 did not hold in $\S$, otherwise merges would have continued. In particular, we have $\overline{r}_2=r_1<r_3=\overline{r}_4$ and
  $\overline{r}_3=r_2<r_1+r_2<r_3=\overline{r}_4$.
  
  \item If one of the Cases \#2 to \#5 just occurred, it holds that $\overline{r}_2 \leqslant r_2+r_3$, that $\overline{r}_3=r_4$ and that $\overline{r}_4=r_5$. Since Lemma~\ref{lm:invariant I} proves that $r_3+r_4<r_5$, it follows that
  $\overline{r}_2 \leqslant r_2+r_3 < r_3+r_4 < r_5 = \overline{r}_4$
  and that $\overline{r}_3 = r_4<r_3+r_4<r_5 = \overline{r}_4$.
\end{disjunction}
\end{proof}

\begin{lemma}\label{lm:invariant III}
At any step during the main loop of \TS, and for all
$i \in \{3,\ldots,h\}$, it holds that
$r_2+\ldots+r_{i-1} < \phi \, r_i$.
\end{lemma}

\begin{proof}
Like for Lemmas~\ref{lm:invariant I} and~\ref{lm:invariant II},
we proceed by induction and verify that, if the
invariant holds at some point, then it still holds when an update of the stack occurs in one of the five situations labeled \#1 to \#5 in the algorithm.
Let us denote by $\S=(R_1,\ldots, R_h)$ the stack just before
the update, and by
$\overline{\S}=(\overline{R}_1,\ldots, \overline{R}_{\overline{h}})$ 
the new state of the stack after the update:
\begin{disjunction}
  \item If Case \#1 just occurred, then we proceed by induction on
  $i \geqslant 3$. First, for $i = 3$,  since the conditions for Cases \#3 and \#4 do not hold in $\S$, we know that $\overline{r}_2 = r_1 < r_2 = \overline{r}_3$ and that
  $\overline{r}_2 + \overline{r}_3 = r_1+r_2 < r_3 = \overline{r}_4$.
  Then, for $i \geqslant 5$, Lemma~\ref{lm:invariant I} states that $r_{i-2}+r_{i-1} < r_i$, and therefore
  \begin{enumerate}[(i)]
   \item if $\overline{r}_{i-1} \leqslant \phi^{-1} \, \overline{r}_i$, then
  $\overline{r}_2+\ldots+\overline{r}_{i-1} < (\phi + 1) \overline{r}_{i-1} = \phi^2 \overline{r}_{i-1} \leqslant \phi \overline{r}_i$, and
  \item if $\overline{r}_{i-1} \geqslant \phi^{-1} \, \overline{r}_i$, then
  $\overline{r}_{i-2} \leqslant (1-\phi^{-1}) \ \overline{r}_i = \phi^{-2} \, \overline{r}_i$, and thus
  $\overline{r}_2+\ldots+\overline{r}_{i-1} < (\phi+1) \, \overline{r}_{i-2} + \overline{r}_{i-1} \leqslant
  \phi \, \overline{r}_{i-2} + \overline{r}_i \leqslant (\phi^{-1} + 1) \overline{r}_i = \phi \, \overline{r}_i$.
  \end{enumerate}
  Hence, in that case, it holds that $\overline{r}_2+\ldots+\overline{r}_{i-1} < \phi \, \overline{r}_i$ for all $i \in \{3,\ldots,h\}$.
  
  \item If one of the Cases \#2 to \#5 just occurred, it holds that $\overline{r}_2 \leqslant r_2+r_3$ and that $\overline{r}_j = r_{j+1}$ for all $j \geqslant 3$. It follows that
  $\overline{r}_2+\ldots+\overline{r}_{i-1} \leqslant
  r_2+\ldots+r_i < \phi \, r_{i+1} = \overline{r}_i$.
\end{disjunction}
\end{proof}

\begin{remark}
We could also have derived directly Lemma~\ref{lm:invariant II} from
Lemma~\ref{lm:invariant III}, by noting that
$\phi^2 \, r_2 = (\phi+1) r_2 < \phi \, r_2 + \phi \, r_3 < \phi^2 \, r_4$.
\end{remark}

\begin{lemma}\label{lm:invariant IV}
After every merge that occurred during an ending sequence,
we have~$r_1 < \phi^2 r_2$.
\end{lemma}

\begin{proof}
Once again, we proceed by induction.
We denote by $\S=(R_1,\ldots, R_h)$ the stack just before an update occurs, and by
$\overline{\S}=(\overline{R}_1,\ldots, \overline{R}_{\overline{h}})$ 
the new state of the stack after after the update:
\begin{disjunction}
  \item If Case \#2 just occurred, then
  this update is not the first one within the ending sequence,
  hence~$\overline{r}_1 = r_1 < \phi^2 \, r_2 < \phi^2 (r_2 + r_3) = \phi^2 \, \overline{r}_2$.
  
  \item If one of the Cases \#2 to \#5 just occurred,
  then $r_1 \leqslant r_3$ and Lemma~\ref{lm:invariant III} proves that
  $r_2 < \phi \, r_3$, which proves that
  $\overline{r}_1 = r_1 + r_2 < (\phi+1) r_3 = \phi^2 \, \overline{r}_2$.
\end{disjunction}
\end{proof}

\begin{lemma}\label{lm:invariant V}
After every merge triggered by Case $\#2$,
we have~$r_2 < \phi^2 r_1$.
\end{lemma}

\begin{proof}
We denote by $\S=(R_1,\ldots, R_h)$ the stack just before an update triggered by Case \#2 occurs, and by
$\overline{\S}=(\overline{R}_1,\ldots, \overline{R}_{\overline{h}})$
the new state of the stack after after the update.
It must hold that $r_1 > r_3$ and
Lemma~\ref{lm:invariant III} proves that $r_2 < \phi \, r_3$. It follows that
$\overline{r}_2 = r_2 + r_3 < (\phi+1) r_3 = \phi^2 \, r_3 < \phi^2 \, r_1 = \phi^2 \, \overline{r}_1$.
\end{proof}

Our second step towards proving the first statement of
Theorem~\ref{thm:complexity 1.5 n + n H}
consists in identifying which sequences of merges
an ending sequence may be made of.
More precisely, in the proof of Lemma~\ref{lm:balance},
we proved that every merge triggered by a case
$\#4$ or $\#5$ must be followed
by another merge, i.e.,
it cannot be the final merge of an ending sequence.

We present now a variant of this result,
which involves distinguishing between merges triggered
by a case $\#2$ and those triggered by a case $\#3$, $\#4$ or $\#5$.
Hence, we denote by $\caseX$ every $\#3$, $\#4$ or $\#5$.

\begin{lemma}\label{lm:(X2)*X*}
No ending sequence contains two conscutive $\#2$'s,
nor does it contain a subsequence of the form \caseX \caseX $\#2$.
\end{lemma}

\begin{proof}
Every ending sequence starts with an update \caseX,
where \caseX is equal to \#3, \#4 or \#5. Hence,
it suffices to prove that no ending sequence
contains a subsequence $\mathbf{t}$ of the form 
\caseX\caseX\#2 or \caseX\#2\;\#2.

Indeed, for the sake of contradiction, assume that it does,
and let $\S = (R_1,\ldots,R_h)$ be the stack just before
$\mathbf{t}$ starts.
We distinguish two cases, depending on the value of $\mathbf{t}$:
\begin{disjunction}
\item If $\mathbf{t}$ is the sequence $\caseX\;\caseX\;\#2$,
it must hold that $r_1+r_2 < r_4$ and that
$r_1+r_2+r_3 \geqslant r_5$, as illustrated in Figure~\ref{fig:XX2}~(top).
Since Lemma~\ref{lm:invariant I} proves that $r_3 + r_4 < r_5$,
it follows that $r_1+r_2+r_3 \geqslant r_5 > r_3+r_4 > r_1+r_2+r_3$,
which is impossible.
 
\item If $\mathbf{t}$ is the sequence $\caseX\;\#2\;\#2$, it must hold that
$r_1 < r_3$ and that
$r_1+r_2 \geqslant r_5$, as illustrated in Figure~\ref{fig:XX2}~(bottom).
Since Lemmas~\ref{lm:invariant I} and~\ref{lm:invariant II} prove that $r_3+r_4 < r_5$ and that $r_2 < r_4$,
it comes that
$r_1+r_2 \geqslant r_5 > r_3+r_4 > r_1+r_2$,
which is also impossible.\vspace{-0.2mm}
\end{disjunction}
\end{proof}

\begin{figure}[ht]
\begin{center}
\vspace{-2mm}
\begin{small}
\begin{tikzpicture}[scale=0.45]
\foreach \i in {0,...,3}{
 \draw[thick] (9*\i,0) -- (9*\i+2,0) -- (9*\i+2,5) -- (9*\i,5) -- cycle;
 \foreach \j in {1,...,5}{
   \node[anchor=south] at (9*\i+1,5-\j-0.05) {$r_\j$};
 }
}
\foreach \i in {0,...,2}{
 \FPeval{\k}{clip(4-\i)}
 \foreach \j in {1,...,\k}{
   \draw[thick] (9*\i,\j) -- (9*\i+2,\j);
 }
}
\draw[thick] (9*3,2) -- (9*3+2,2);

\draw[very thick,->,>=stealth] (2.1,2.5) -- (8.9,2.5);
\draw[very thick,->,>=stealth] (11.1,2.5) -- (17.9,2.5);
\draw[very thick,->,>=stealth] (20.1,2.5) -- (26.9,2.5);
% \node[anchor=north] at (5.5,2.5+0.05) {$r_1<r_3$};
\node[anchor=south] at (5.5,2.5-0.05) {merge \caseX};
\node[anchor=north] at (14.5,2.5+0.05) {$r_1+r_2<r_4$};
\node[anchor=south] at (14.5,2.5-0.05) {merge \caseX};
\node[anchor=north] at (23.5,2.5+0.05) {$r_1+r_2+r_3 \geqslant r_5$};
\node[anchor=south] at (23.5,2.5-0.05) {merge $\#2$};

\node[anchor=south] at (10,3.5) {\tiny+};
\node[anchor=south] at (19,3.5) {\tiny+};
\node[anchor=south] at (19,2.5) {\tiny+};
\node[anchor=south] at (28,3.5) {\tiny+};
\node[anchor=south] at (28,2.5) {\tiny+};
\node[anchor=south] at (28,0.5) {\tiny+};
\end{tikzpicture}

\bigskip\bigskip

\begin{tikzpicture}[scale=0.45]
\foreach \i in {0,...,3}{
 \draw[thick] (9*\i,0) -- (9*\i+2,0) -- (9*\i+2,5) -- (9*\i,5) -- cycle;
 \foreach \j in {1,...,5}{
   \node[anchor=south] at (9*\i+1,5-\j-0.05) {$r_\j$};
 }
}
\foreach \i in {0,...,1}{
 \FPeval{\k}{clip(4-\i)}
 \foreach \j in {1,...,\k}{
   \draw[thick] (9*\i,\j) -- (9*\i+2,\j);
 }
}
\draw[thick] (9*2,1) -- (9*2+2,1);
\draw[thick] (9*2,3) -- (9*2+2,3);
\draw[thick] (9*3,3) -- (9*3+2,3);

\draw[very thick,->,>=stealth] (2.1,2.5) -- (9*1-0.1,2.5);
\draw[very thick,->,>=stealth] (9*1+2.1,2.5) -- (9*2-0.1,2.5);
\draw[very thick,->,>=stealth] (9*2+2.1,2.5) -- (9*3-0.1,2.5);
\node[anchor=north] at (9*0.5+1,2.5+0.05) {$r_1 \leqslant r_3$};
\node[anchor=south] at (9*0.5+1,2.5-0.05) {merge \caseX};
\node[anchor=south] at (9*1+9*0.5+1,2.5-0.05) {merge $\#2$};
\node[anchor=north] at (9*2+9*0.5+1,2.5+0.05) {$r_1+r_2 \geqslant r_5$};
\node[anchor=south] at (9*2+9*0.5+1,2.5-0.05) {merge $\#2$};

\node[anchor=south] at (9*1+1,3.5) {\tiny+};
\node[anchor=south] at (9*2+1,3.5) {\tiny+};
\node[anchor=south] at (9*2+1,1.5) {\tiny+};
\node[anchor=south] at (9*3+1,3.5) {\tiny+};
\node[anchor=south] at (9*3+1,1.5) {\tiny+};
\node[anchor=south] at (9*3+1,0.5) {\tiny+};
\end{tikzpicture}
\end{small}
\end{center}
\vspace{-2mm}
\caption{Applying successively merges
\caseX\#2\;\#2
or \caseX\caseX\#2
to a stack is impossible.}
\label{fig:XX2}
\end{figure}

Our third step consists in modifying the cost allocation
we had chosen in Section~\ref{sec:analysis1}, which
is not sufficient to prove Theorem~\ref{thm:complexity 1.5 n + n H}.
Instead, we associate to
every run $R$ its \emph{potential}, which depends only on the length
$r$ of the run, and is defined as
$\pot(r) = 3 r \log_2(r) / 2$. We also call \emph{potential} of a
set of runs the sum of the potentials of the runs it is formed of,
and \emph{potential variation} of a (sequence of) merges
the increase in potential caused by these merge(s).

We shall prove that the potential variation of every ending
sequence dominates its merge cost, up to a small error term.
In order to do this, let us study more precisely individual merges.
Below, we respectively denote by $\Delta_{\pot}(\mathbf{m})$
and $\cost(\mathbf{m})$ the potential variation and the
merge cost of a merge $\mathbf{m}$. Then, we say that
$\mathbf{m}$ is a \emph{balanced} merge if
$\cost(\mathbf{m}) \leqslant \Delta_{\pot}(\mathbf{m})$.

In the next Lemmas, we prove that most merges are balanced
or can be grouped into sequences of merges that are balanced
overall.

\begin{lemma}\label{lm:delta-cost I}
Let $\mathbf{m}$ be a merge between two runs $R$ and $R'$.
If $\phi^{-2} \, r \leqslant r' \leqslant \phi^2 \, r$,
then $\mathbf{m}$ is balanced.
\end{lemma}

\begin{proof}
Let $x = r / (r+r')$: we have~$\Phi < x < 1-\Phi$, where $\Phi = 1/(1+\phi^2)$.
Then, observe that $\Delta(\mathbf{m}) = 3 (r+r') H(x) / 2$,
where $H(x) = - x \log_2(x) - (1-x) \log_2(x)$
is the binary Shannon entropy of a Bernoulli law of parameter $x$.
Moreover, the function $z \mapsto H(z) = H(1-z)$
is increasing on $[0,1/2]$. It follows that $H(x) \geqslant
H(\Phi) \approx 0.85 > 2/3$, and therefore that $\Delta(\mathbf{m}) > r+r' = \cost(\mathbf{m})$. 
\end{proof}

\begin{lemma}\label{lm:delta-cost II}
Let $\mathbf{m}$ be a merge that belongs to some ending sequence.
If $\mathbf{m}$ is a merge $\#2$, then $\mathbf{m}$ is balanced and,
if $\mathbf{m}$ is followed by another merge $\mathbf{m}'$,
then $\mathbf{m}'$ is also balanced.
\end{lemma}

\begin{proof}
Lemma~\ref{lm:(X2)*X*} ensures that
$\mathbf{m}$ was preceded by another merge $\mathbf{m}^\star$,
which must be a merge \caseX.
Denoting by $\S = (R_1,\ldots,R_h)$ the stack just before the merge
$\mathbf{m}^\star$ occurs,
the update $\mathbf{m}$ consists in merging
the runs $R_3$ and $R_4$.
Then, it comes that $r_1 \leqslant r_3$ and that $r_1+r_2 > r_4$,
while Lemma~\ref{lm:invariant II} and~\ref{lm:invariant III} respectively
prove that $r_3 < r_4$ and that $r_2 < \phi \, r_3$.
Hence, we both have $r_3 < r_4$ and
$r_4 < r_1 + r_2 < (1 + \phi) r_3 = \phi^2 \, r_3$, and Lemma~\ref{lm:delta-cost II} proves that $\mathbf{m}$ is balanced.

Then, if $\mathbf{m}$ is followed by another merge $\mathbf{m}'$,
Lemma~\ref{lm:(X2)*X*} proves that $\mathbf{m}'$ is also a merge \caseX, between runs of respective lengths $r_1+r_2$ and $r_3+r_4$.
Note that $r_1 \leqslant r_3$ and that $r_1+r_2 > r_4$. Since
Lemma~\ref{lm:invariant II} proves that $r_2 < r_4$ and that $r_3 < r_4$, it follows that
$2(r_1+r_2) > 2 r_4 > r_3 + r_4 > r_1+r_2$ and,
using the fact that $2 < 1 + \phi = \phi^2$,
Lemma~\ref{lm:delta-cost II} therefore proves that $\mathbf{m}$ is balanced.
\end{proof}

\begin{lemma}\label{lm:delta-cost III}
Let $\mathbf{m}$ be a merge \caseX
between two runs $R_1$ and $R_2$ such that $r_1 < \phi^{-2} \, r_2$.
Then, $\mathbf{m}$ is followed by another merge $\mathbf{m}'$, and
$\cost(\mathbf{m}) + \cost(\mathbf{m}') \leqslant \Delta_{\pot}(\mathbf{m}) + \Delta_{\pot}(\mathbf{m}')$.
\end{lemma}

\begin{proof}
Let $\mathbf{m}^\star$ be the update the immediately precedes
$\mathbf{m}$. Let also $\S^\star = (R^\star_1,\ldots,R^\star_{h^\star})$, $\S = (R_1,\ldots,R_h)$ and
$\S' = (R'_1,\ldots,R'_{h'})$ be the respective states
of the stack just before $\mathbf{m}^\star$ occurs,
just before $\mathbf{m}$ occurs and just after $\mathbf{m}$ occurs.

Since $r_1 < \phi^{-2} \, r_2$,
Lemma~\ref{lm:invariant V} proves that
$\mathbf{m}^\star$ is either an update \#1 or a merge \caseX.
In both cases, it follows that $r_2 < r_3$ and that $r_2+r_3 < r_4$.
Indeed, if $\mathbf{m}^\star$ is an update \#1, then we must have
$r_2 = r^\star_1 < r^\star_2 = r_3$ and
$r_2+r_3 = r^\star_1+r^\star_2 < r^\star_3 = r_4$, and if
$\mathbf{m}'$ is a merge \caseX, then Lemmas~\ref{lm:invariant I} and~\ref{lm:invariant II}
respectively prove that $r_2+r_3 = r^\star_3+r^\star_4 < r^\star_5 = r_4$ and that $r_2 = r^\star_3 < r^\star_4 = r_3$.

Then, since $\mathbf{m}$ is a merge \caseX, we also know that
$r_1 \leqslant r_3$. Since $r_1 < \phi^{-2} \, r_2$ and $r_2+r_3 < r_4$, this means that $r_1 + r_2 \geqslant r_3$.
It follows that
$r'_2 = r_3 \leqslant r_1+ r_2 = r'_1$ and that
$r'_1 = r_1 + r_2 \leqslant r_2 + r_3 < r_4 = r'_3$.
Consequently, the merge $\mathbf{m}$ must be followed by a merge
$\mathbf{m}'$, which is triggered by case \#3.

Finally, let $x = r_1 / (r_1+r_2)$ and $y = (r_1+r_2) / (r_1+r_2+r_3)$.
It comes that $\cost(\mathbf{m})+\cost(\mathbf{m}') = (r_1+r_2+r_3)(1+y)$ and that
$\Delta_{\pot}(\mathbf{m}) + \Delta_{\pot}(\mathbf{m}') = 3 (r_1+r_2+r_3) \left(y H(x) + H(y)\right)\!/ 2$, where
we recall that $H$ is the binary Shannon entropy function, with
$H(t) = - t \log_2(t) - (1-t) \log_2(t)$.
The above inequalities about $r_1$, $r_2$ and $r_3$ prove that $0 \leqslant 2 - 1/y \leqslant x \leqslant 1/(1+\phi^2)$.
Since $H$ is increasing on the interval $[0,1/2]$, and since
$1+\phi^2 \geqslant 2$, it follows that
$\Delta_{\pot}(\mathbf{m}) + \Delta_{\pot}(\mathbf{m}') \geqslant 3 (r_1+r_2+r_3) \left(y H(2 - 1/y) + H(y)\right)\!/ 2$.

Hence, let $F(y) = 3 \left(y H(2 - 1/y) + H(y)\right)\!/2 - (1+y)$.
We shall prove that $F(y) \geqslant 0$ for all $y \geqslant 0$
such that
$0 \leqslant 2 - 1/y \leqslant 1/(1+\phi^2)$, i.e., such that
$1/2 \leqslant y \leqslant 
(1+\phi^2)/(1+2\phi^2)$.
To that mean, observe that
$F''(y) = 3 /\!\left((1-y)(1-2y) \ln(2)\right) < 0$
for all $y \in (1/2,1)$. Thus, $F$ is concave on
$(1/2,1)$.
Since $F(1/2) = 0$ and $F(3/4) = 1/2$, it follows that
$F(y) \geqslant 0$ for all $y \in [1/2,3/4]$.
Checking that $(1+\phi^2)/(1+2\phi^2) < 3/4$ completes the proof.
\end{proof}

\begin{lemma}\label{lm:delta-cost IV}
Let $\mathbf{m}$ be the first merge of the ending sequence
associated with a run $R$. Let $R_1$ and $R_2$ be the runs
that $\mathbf{m}$ merges together.
If $r_1 > \phi^2 \, r_2$, it holds that
$\cost(\mathbf{m}) \leqslant \Delta_{\pot}(\mathbf{m}) + r$.
\end{lemma}

\begin{proof}
By definition of $\mathbf{m}$,
we have~$R = R_1$, and thus $r = r_1 \geqslant r_2$.
Hence, it follows that
$\Delta_{\pot}(\mathbf{m}) = r \log((r+r_2)/r) +
r_2 \log((r+r_2)/r_2) \geqslant r_2 \log((r+r_2)/r_2) \geqslant
r_2 = \cost(\mathbf{m}) - r$.
\end{proof}

\begin{proposition}\label{pro:delta-cost}
Let $\mathbf{s}$ be the ending sequence associated with a run $R$,
and let $\Delta_{\pot}(\mathbf{s})$ and $\cost(\mathbf{s})$
be its potential variation and its merge cost.
It holds that~$\cost(\mathbf{s}) \leqslant \Delta_{\pot}(\mathbf{s}) + r$.
\end{proposition}

\begin{proof}
Let us group the merges of $\mathbf{s}$ as follows:
\begin{enumerate}[(i)]
 \item if $\mathbf{m}$ is an unbalanced merge \caseX between two runs $R_1$ and $R_2$ such that $r_1 < r_2$, then $\mathbf{m}$ is followed by another merge $\mathbf{m}'$, and we group $\mathbf{m}$
 and $\mathbf{m}'$ together;\label{delta-cost:case:1}
 \item otherwise, and if $\mathbf{m}$ has not been grouped
 with its predecessor, it forms its own group.
\end{enumerate}
In case~\eqref{delta-cost:case:1}, Lemma~\ref{lm:delta-cost IV} ensures that $\mathbf{m}'$ itself cannot be grouped with another merge.
This means that our grouping is unambiguous.

Then, let $\mathbf{g}$ be such a group,
with potential variation $\Delta_{\pot}(\mathbf{g})$ and
merge cost $\cost(\mathbf{g})$.
Lemmas~\ref{lm:delta-cost I} to~\ref{lm:delta-cost IV}
prove that $\cost(\mathbf{g}) \leqslant \Delta_{\pot}(\mathbf{g}) + r$ if $\mathbf{g}$ is formed of the first merge of $\mathbf{s}$ only,
and that $\cost(\mathbf{g}) \leqslant \Delta_{\pot}(\mathbf{g})$
in all other cases. Proposition~\ref{pro:delta-cost} follows.
\end{proof}

Collecting all the above results is enough to prove Theorem~\ref{thm:complexity 1.5 n + n H}.
First, like in Section~\ref{sec:analysis1},
computing the run decomposition and merging runs in
starting sequences has a cost $\O(n)$,
and the final merges of line~11 may be taken care of by Remark~\ref{rem:main-loop}.
Second, by Proposition~\ref{pro:delta-cost},
ending sequences have a merge cost dominated by
$\Delta_{\pot} + n$, where $\Delta_{\pot}$
is the total variation of potential during the algorithm.
Observing that
$\Delta_{\pot} = -3/2 \sum_{i=1}^\rho r_i \log_2(r_i/n) = - 3 n \H / 2$
concludes the proof of the theorem.



=== Paper (papers/paper2.txt) ===
%
\def\version{arxiv}
\def\draftmode{false}

\documentclass[a4paper,USenglish]{lipics-v2018}
%
%
%
%
%


\usepackage{microtype}%if unwanted, comment out or use option "draft"


\input{preamble}


%
	\hideLIPIcs
	\nolinenumbers
%




%

\bibliographystyle{plainurl}% the recommnded bibstyle

\title{%
	Nearly-Optimal Mergesorts: \protect\\ 
%
	Fast, Practical Sorting Methods That \protect\\ Optimally Adapt to Existing Runs%
}

\titlerunning{Nearly-Optimal Mergesort}%optional, please use if title is longer than one line

\author{J.\ Ian Munro}{University of Waterloo, Canada}{imunro@uwaterloo.ca}{https://orcid.org/0000-0002-7165-7988}{}%mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty.

\author{Sebastian Wild}{University of Waterloo, Canada}{wild@uwaterloo.ca}{https://orcid.org/0000-0002-6061-9177}{}

\authorrunning{J.\,I.\ Munro and S. Wild}%mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{J.\ Ian Munro and Sebastian Wild}%mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\subjclass{\ccsdesc[500]{Theory of computation~Sorting and searching}}% mandatory: Please choose ACM 2012 classifications from https://www.acm.org/publications/class-2012 or https://dl.acm.org/ccs/ccs_flat.cfm . E.g., cite as "General and reference $\rightarrow$ General literature" or \ccsdesc[100]{General and reference~General literature}. 

\keywords{adaptive sorting, nearly-optimal binary search trees, Timsort}%mandatory
%\keywords{sorting, mergesort, adaptive sorting, nearly-optimal binary search trees, alphabetic trees}%mandatory

%\category{}%optional, e.g. invited paper

%\relatedversion{}%optional, e.g. full version hosted on arXiv, HAL, or other respository/website

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...

\funding{%
	This work was supported by the 
	Natural Sciences and Engineering Research Council of Canada 
	and the Canada Research Chairs Programme.
}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

%\acknowledgements{I want to thank \dots}%optional





%
%
%
%
%
%
%
%
%
%
%
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\maketitle

\begin{abstract}
We present two stable mergesort variants, ``peeksort'' and ``powersort'', 
that exploit existing runs and find nearly-optimal merging orders with 
negligible overhead.
Previous methods either require substantial effort for determining the merging order
(Takaoka 2009\ifarxiv{~\cite{Takaoka2009}}{}; Barbay \& Navarro 2013\ifarxiv{~\cite{BarbayNavarro2013}}{}) 
or do not have an optimal worst-case guarantee 
(Peters 2002\ifarxiv{~\cite{Peters2002}}{}; Auger, Nicaud \& Pivoteau 2015\ifarxiv{~\cite{AugerNicaudPivoteau2015}}{}; 
Buss \& Knop 2018\ifarxiv{~\cite{BussKnop2018}}{})\@.
We demonstrate that our methods are competitive in terms of running time with state-of-the-art implementations
of stable sorting methods.
\end{abstract}


\section{Introduction}

Sorting is a fundamental building block for numerous tasks and 
ubiquitous in both the theory and practice of computing.
While practical and theoretically (close-to) optimal 
comparison-based sorting methods are known,
\emph{instance-optimal sorting,} \ie, methods that \emph{adapt} to the actual input
and exploit specific structural properties if present,
is still an area of active research. We survey some recent developments in \wref{sec:related}.

Many different structural properties have been investigated in theory.
Two of them have also found wide adoption in practice, \eg, in Oracle's Java runtime library:
adapting to the presence of duplicate keys 
and using existing sorted segments, called \emph{runs}.
The former is achieved by a so-called fat-pivot partitioning variant of 
quicksort~\cite{BentleyMcIlroy1993},
which is also used in the GNU implementation of \texttt{std::sort} from the 
{C\raisebox{.25ex}{\textsmaller[2]{++}}} STL\@.
It is an \emph{unstable} sorting method, though, \ie, the relative order of 
elements with equal keys might be destroyed in the process.
It is hence used in Java solely for primitive-type arrays.

Making use of existing runs in the input is a well-known option in mergesort; 
\eg, Knuth~\cite{Knuth1998} discusses a bottom-up mergesort variant that does this.
He calls it ``natural mergesort'' and we will use this as an umbrella term for
any mergesort variant that picks up existing
runs in the input (instead of starting blindly with runs of size~$1$).
The Java library uses Timsort~\cite{Peters2002,java2009timsort} 
which is such a natural mergesort originally developed as Python's new library sort.

While fat-pivot quicksort provably adapts
to the \emph{entropy of the multiplicities} of keys~\cite{Wild2018}~--
it is optimal up to a factor of $1.088$ on average with pseudo\-median-of-9 (``ninther'') pivots%
\footnote{%
	The median of three elements is chosen as the pivot, 
	each of which is a median of three other elements.
	This is a good approximation of the median of 9 elements
	and often used as pivot selection rule in library implementations.%
}%
~-- 
Timsort is much more heuristic in nature.
It picks up existing runs and tries to perform merges in a favorable order
(\ie, avoiding merges of runs with very different lengths),
but many desirable guarantees are missing:
%
Although it was announced as an $O(n\log n)$ worst-case method
with its introduction in Python in 2002~\cite{Peters2002mailinglist},
a rigorous proof of this bound was only given in 2015 by Auger, Nicaud, and Pivoteau~\cite{AugerNicaudPivoteau2015}
and required a rather sophisticated amortization argument.%
\footnote{%
\label{fn:wrong-timsort}%
	A further manifestation of the complexity of Timsort 
	was reported by de~Gouw et al.~\cite{DeGouwBoerBubelHaehnleRotSteinhoefel2017}:
	The original rules to maintain the desired invariant 
	for run lengths on the stack was not sufficient in some cases.
	This (algorithmic!) bug had remained unnoticed until their attempt to formally
	verify the correctness of the Java implementation of Timsort failed because of it.
}
The core complication is that~--
unlike for standard mergesort variants~-- a given element might participate
in more than a logarithmic number of merges.
Indeed, Buss and Knop~\cite{BussKnop2018} have very recently shown 
that for some family of inputs, the average number of merges a single element participates in 
is at least $\bigl(\frac32-o(1)\bigr)\cdot \lg n$.
So in the worst case, Timsort does, \eg, 
(at least) \emph{1.5 times as many element moves as standard mergesort.}

In terms of adapting to existing order, the only proven guarantee for Timsort's running time 
is a trivial $O(n r)$ bound when the input consists of $r$ runs. 
Proving an informative upper bound like $O(n+n \log r )$ has remained elusive,
(although it is conjectured to hold in~\cite{AugerNicaudPivoteau2015} and~\cite{BussKnop2018}).
%
This is in sharp contrast to available alternatives:
%
%
Takaoka~\cite{Takaoka1998,Takaoka2009} and Barbay and Navarro~\cite{BarbayNavarro2013}
independently discovered a sorting method that adapts to the 
\emph{entropy of the distribution of run lengths:}
they sort an input consisting of $r$ runs with respective lengths $L_1,\ldots,L_r$
in time $O\bigl( (\mathcal H(\frac{L_1}n,\ldots,\frac{L_r}n) +1) n \bigr) \subseteq O(n + n\lg r)$,
where $\mathcal H(p_1,\ldots,p_r) = \sum_{i=1}^r p_i \lg(1/p_i)$ is the binary Shannon entropy.
Since $\mathcal H(\frac{L_1}n,\ldots,\frac{L_r}n) n - \Oh(n)$ comparisons are 
necessary for distinct keys, this is optimal up to linear terms.
%
%
%
%
Their algorithms are also conceptually simple:
find runs in a linear scan, determine an optimal merging order
using a Huffman tree of the run lengths, and execute those merges bottom-up in the tree.
We will refer to this algorithm to determine an optimal merging order 
as \emph{Huffman-Merge}.

Straight-forward implementations of Huffman-Merge
add significant overhead in terms of time and 
%
%
%
	space;
	(finding the Huffman tree requires storing and sorting the run lengths).
	This 
%
renders these methods uncompetitive to
(reasonable implementations of) elementary sorting methods.
%
%
Moreover, Huffman-Merge leads to an \emph{unstable} sorting method
since it merges non-adjacent runs.
The main motivation for the invention of Timsort was 
to find a fast general-purpose sorting method that is \emph{stable}~\cite{Peters2002mailinglist},
and the Java library even dictates the sorting method used for objects to be stable.
We remark that while stability is a much desired feature, 
practical, stable sorting methods do not try to \emph{exploit} the presence of 
duplicate elements to speed up sorting,
and we will focus on the performance for distinct keys in this article.

It is conceptually easy to modify the idea of Takaoka resp.\ Barbay-Navarro 
to sort stably: 
replace the Huffman tree by
an \emph{optimal binary search tree} 
and otherwise proceed 
%
%
%
	as before (using a stable merging procedure).
%
Since we only have weights at the leaves of the tree, 
%
we can compute this tree in $O(n + r\log r)$ time using the Hu-Tucker- or Garsia-Wachs-algorithm,
but $r$ can be $\Theta(n)$ and the algorithms are fairly sophisticated,
so this idea seems not very appealing for practical use.

In this paper,
we present two new natural mergesort variants that have the same optimal asymptotic 
running time $O\bigl( (\mathcal H(\frac{L_1}n,\ldots,\frac{L_r}n) +1) n \bigr)$ as Huffman-merge,
but incur much less overhead.
For that, we build upon classic algorithms for computing \emph{nearly-optimal binary search trees}~
\cite{Mehlhorn1984};
but the vital twist for practical methods is to neither explicitly store
the full tree, nor the lengths of all runs at any point in time.
In particular~-- much like Timsort~-- we only store a \emph{logarithmic} number of runs
at any point in time 
(in fact reducing their number from roughly $\log_\varphi \approx1.44 \lg n$ in Timsort to $\lg n$), 
but~-- much \emph{un}like Timsort~-- we retain the guarantee of an optimal merging order up to linear terms.
Our methods require at most $n \lg n + O(n)$ comparison in the worst case
and $\mathcal H(\frac{L_1}n,\ldots,\frac{L_r}n)n +3n$ for an input with runs of lengths $L_1,\ldots, L_r$.

We demonstrate in a running-time study that our methods achieve guaranteed 
(leading-term) optimal adaptive sorting in practice with negligible overhead 
to compute the merge order: 
unlike Timsort, our methods are \emph{not} slower than standard mergesort 
when no existing runs can be exploited.
If existing runs are present, mergesort and quicksort are outperformed by far.
Finally, we show that Timsort is slower than standard mergesort and our new methods
on certain inputs that do have existing runs, but whose lengths pattern hits a weak point
of Timsort's heuristic merging-order rule.




\smallskip\noindent
\textbf{\textsf{Outline:}} The rest of this paper is organized as follows.
In the remainder of this section we survey related work.
\wref{sec:preliminaries} contains notation and 
known results on optimal binary search trees that our work builds on.
The new algorithms and their analytical guarantees are presented in \wref{sec:algorithms}.
\wref{sec:experiments} reports on our running-time study, comparing
the the new methods to state-of-the-art sorting methods.
Finally, \wref{sec:conclusion} summarizes our findings.

\subsection{Adaptive Sorting}
\label{sec:related}

The idea to exploit existing ``structure'' in the input to speed up sorting
dates (at least) back to methods from the 1970s~\cite{Mehlhorn1979} that 
sort faster when the number of inversions is small.
A systematic treatment of this and many further measures of presortedness
(\eg, the number of inversions, the number of runs, and the number of shuffled up-sequences), 
their relation and how to sort \emph{adaptively} \wrt these measures 
are discussed by Estivill-Castro and Wood~\cite{EstivillCastroWood1992}.
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
While the focus of earlier works is mostly on combinatorial properties of permutations, 
a more recent trend is to consider more fine-grained statistical quantities.
For example, the above mentioned Huffman-Merge adapts to the
\emph{entropy} of the vector of run lengths~\cite{Takaoka1998,Takaoka2009,BarbayNavarro2013}.
%
%
%
%
%
Other similar measures are the entropy of the lengths of shuffled up-sequences~\cite{BarbayNavarro2013}
%
%
%
%
%
and the entropy of lengths of an LRM-partition~\cite{BarbayFischerNavarro2012}, 
a novel measure that lies between runs and shuffled up-sequences.

For multiset sorting, the fine-grained measure, the \emph{entropy of the multiplicities}, 
has been considered instead of the \emph{number} of unique values already in early work 
in the field (\eg~\cite{MunroSpira1976,Sedgewick1977equals}).
%
A more recent endeavor has been to find sorting methods that optimally adapt to
\emph{both presortedness and repeated values}.
Barbay, Ochoa, and Satti refer to this as \emph{synergistic sorting}~\cite{BarbayOchoaSatti2017}
and present an algorithm based on quicksort that is optimal up to a constant factor.
The method's practical performance is unclear.

%
%
%
%
%

We remark that (unstable) multiset sorting is the \emph{only} problem from the above list
for which a theoretically optimal algorithm has found wide-spread adoption in
programming libraries:
quicksort is known to almost optimally adapt to the entropy of multiplicities 
on average~\cite{Wegner1985,SedgewickBentley2002,Wild2018},
when elements equal to the pivot are excluded from recursive calls (fat-pivot partitioning).
Supposedly, sorting is so fast to start with that further improvements from
exploiting specific input characteristics are only fruitful if they can be realized
with minimal additional overhead.
Indeed, for algorithms that adapt to the number of inversions, 
Elmasry and Hammad~\cite{ElmasryHammad2009} found that 
the adaptive methods could only compete with good implementations of elementary sorting algorithms 
in terms of running time
for inputs with extremely few inversions (fewer than 1.5\%).
Translating the theoretical guarantees of adaptive sorting
into practical, efficient methods is an ongoing challenge.



\subsection{Lower bound}
\label{sec:lower-bound}

How much does it help for sorting an array $A[1..n]$ to
know that it contains $r$ runs of respective sizes $L_1,\ldots,L_r$,
\ie, to know the relative order of $A[1..L_1]$, $A[L_1+1..L_1+L_2]$ etc.?
If we assume distinct elements, a simple counting argument shows that there
are $\binom n{L_1,\ldots,L_r}$ permutations that are compatible with this setup.
(the number of ways to partition $n$ keys into $r$ subsets of given sizes.)
We thus need $\lg(n!) - \sum_{i=1}^r \lg (L_i!) = \mathcal H(\frac{L_1}n,\ldots,\frac{L_r}n) n - O(n)$ 
comparisons to sort such an input.
A formal argument for this lower bound is given by Barbay and Navarro~\cite{BarbayNavarro2013} 
in the proof of their Theorem~2. 
%
%
%
%
%


\subsection{Results on Timsort and stack-based mergesort}

Its good performance in running-time studies especially on partially sorted inputs
have lead to the adoption of Timsort in several programming libraries,
but as mentioned in the introduction, 
the complexity of the algorithm has precluded researchers from proving 
interesting adaptivity guarantees.
To make progress towards these, simplified variations of Timsort have been 
considered~\cite{AugerNicaudPivoteau2015,BussKnop2018}.
All of those methods work by maintaining a stack of runs yet to be merged
and proceed as follows: 
They find the next run in the input and push it onto the stack.
Then they consider the top $k$ elements on the stack (for $k$ a small constant like 3 or 4)
and decide based on these if any pair of them is to be merged.
If so, the two runs in the stack are replaced with the merged result and the rule is applied
repeatedly until the stack satisfies some invariant.
The invariant is chosen so as to keep the height of the stack small (logarithmic in $n$).

The simplest version, ``$\alpha$-stack sort''~\cite{AugerNicaudPivoteau2015}, 
merges the topmost two runs until the run lengths in the stack grow at least by a factor of $\alpha$,
(\eg, $\alpha=2$).
This method can lead to imbalanced merges (and hence runtime $\omega(n\log r)$~\cite{BussKnop2018};
the authors of~\cite{AugerNicaudPivoteau2015} also point this out in their conclusion):
if the next run is much larger than what is on the stack, a much more balanced
merging order results from first merging stack elements until they are at least as big
as the new run.
This modification is called ``$\alpha$-merge sort'', which achieves a worst-case 
guarantee of $O(n + n \log r)$, but the constant is provably not optimal~\cite{BussKnop2018}
(for any $\alpha>1$).

Timsort is quite similar to $\alpha$-merge sort for $\alpha=\varphi$ (the golden ratio)
by forcing the run lengths to grow at least like Fibonacci numbers.
The details of the rule are given in~\cite{AugerNicaudPivoteau2015} or~\cite{BussKnop2018} and
are quite intricate~-- 
and were indeed wrong in the first (widely-used) version of Timsort 
(see \wtpref{fn:wrong-timsort}).
While it is open if Timsort always runs in $O(n+n \log r)$ time,
Buss and Knop gave a family of inputs for which Timsort does asymptotically at least $1.5$ times
the required effort (in terms of merge costs, see \wref{sec:merge-costs}), and hence
proved that Timsort~-- like $\alpha$-merge sort~-- is \emph{not} optimally adaptive
even to the \emph{number} of runs $r$, not to speak of the entropy of the run lengths.

%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%



\section{Preliminaries}
\label{sec:preliminaries}

%
%

We implicitly assume that we are sorting an array $A[1..n]$ of $n$ elements.
By $\mathcal H$, we denote the binary Shannon entropy, \ie,
for $p_1,\ldots,p_m\in[0,1]$ with $p_1+\cdots+p_m = 1$ we let
$\mathcal H(p_1,\ldots,p_m) = \sum p_i \lg(1/p_i)$, where
$\lg=\log_2$.


We will always let $r$ denote the \emph{number of runs} in the input and 
$L_1,\ldots,L_r$ their respective lengths with $L_1+\cdots+L_r = n$.
In the literature, a \emph{run} usually means a maximal (contiguous) 
%
%
%
	weakly increasing%
	\footnote{%
		We use ``weakly increasing'' to mean ``nondecreasing''.\\
		\textsmaller[2]{(Isn't it better to say what we mean instead of not saying what we don't mean?)}
	}
	region,
%
but we adopt the convention from Timsort in this paper: a run is either
a maximal \emph{weakly increasing} region \emph{or} a \emph{strictly decreasing} region.
Decreasing runs are immediately reversed;
allowing only strict decreasing runs makes their \emph{stable} reversal trivial.
The algorithms are not directly affected by different conventions for what a ``run'' is;
they only rely on a unique partition of the input into sorted segments that can be found
by sequential scans.

\subsection{Nearly-Optimal Binary Search Trees}
\label{sec:optimal-BSTs}

In the \emph{optimal binary search tree problem,} 
we are given probabilities $\beta_1,\ldots,\beta_m$ to access the $m$
keys $K_1<\cdots<K_m$ (internal nodes) and probabilities
$\alpha_0,\ldots,\alpha_m$ to access the gaps (leaves) between these keys 
(setting $K_0 = -\infty$ and $K_{m+1}=+\infty$)
and we are interested in the binary search tree that minimizes the expected
search cost $C$, \ie, 
the expected number of (ternary) comparisons when access follow the given distribution.%
\footnote{%
	We deviate from the literature convention and use $m$ to denote the number of 
	keys to avoid confusion with $n$, the length of the arrays to sort,
	in the rest of the paper.
}
Nagaraj~\cite{Nagaraj1997} surveys various versions of the problem.
We confine ourselves to \emph{approximation algorithms} here.
Moreover, we only need the special case of \emph{alphabetic trees}
where all $\beta_j = 0$.

The following methods apply to the general problem, but we 
present them for the case of \emph{nearly-optimal alphabetic trees.}
So in the following let $\alpha_0,\ldots,\alpha_m$ with $\sum_{i=0}^m \alpha_i = 1$ be given.
If the details are done right, a greedy top-down approach produces provably good 
search trees~\cite{Bayer1975,Mehlhorn1977}:
choose the boundary closest to $\frac12$ as the bisection at the root 
(\emph{``weight-balancing heuristic''}).
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
Mehlhorn~\cite[\S III.4.2]{Mehlhorn1984} discusses two algorithms for 
nearly-optimal binary search trees that follow this scheme:
``Method 1'' is the straight-forward recursive application of the above rule,
whereas ``Method 2'' (\emph{``bisection heuristic''}) 
continues by strictly halving the \emph{original} interval in the recursive calls;
see \wref{fig:nearly-optimal-trees}.

\begin{figure}[tbph]
	\begin{center}
	\begin{tikzpicture}[
			yscale=.27,
			xscale=.2,
			every node/.style={inner sep=2pt,font=\footnotesize},
			tree/.style={
				circle,draw,black!50,thick,minimum size=6pt,inner sep=0pt,fill=black!10,fill opacity=.5
			},
			orgrun/.style={pattern=crosshatch dots,pattern color=black!30},
	]
		\def\delta{0.2}
		\def\intskip{2}
		\useasboundingbox (-.5,4) rectangle (67.5,-11);
		
		\draw[fill=black!10] (0,0) coordinate (l)
			\foreach \d/\i in {5,3,3,14,1,2} {
				rectangle 
				++(\d,1) ++(\delta,-1) 
			}
			++(-\delta,0) coordinate (r)
		;
		\coordinate (m) at ($(l)!.5!(r)$);
		\draw[|-|] ($(l)+(0,\intskip)$) node[above=3pt] {0} -- ($(m)+(0,\intskip)$) node[above=3pt] {\nicefrac12} ;
		\draw[|-|] ($(r)+(0,\intskip)$) node[above=3pt] {1} -- ($(m)+(0,\intskip)$) ;
		\node[tree] (n0) at (5+3+3+2.5*\delta,.5) {};
		\draw[thick,densely dotted] (m) ++ (0,-.1) -- ++(0,2) ;
		\draw[->] ($(l)!.5!(r)$) ++(0,.5) -- (n0) ;
		
		\begin{scope}[shift={(-.25,-5)}]
			\draw[fill=black!10] (0,0) coordinate (l)
				\foreach \d/\i in {5,3,3} {
					rectangle 
					++(\d,1) ++(\delta,-1) 
				}
				++(-\delta,0) coordinate (r)
			;
			\coordinate (m) at ($(l)!.5!(r)$);
			\draw[|-|] ($(l)+(0,\intskip)$) node[above=3pt] {0} -- ($(m)+(0,\intskip)$) node[above=3pt] {\nicefrac12} ;
			\draw[|-|] ($(r)+(0,\intskip)$) node[above=3pt] {1~~} -- ($(m)+(0,\intskip)$) ;
			\node[tree] (n00) at (5+0.5*\delta,.5) {};
			\draw[thick,densely dotted] (m) ++ (0,-.1) -- ++(0,2) ;
			\draw[->] ($(l)!.5!(r)$) ++(0,.5) -- (n00) ;
			\draw[black!50,very thick,opacity=.5] (n0) to (n00);
		\end{scope}
		
		\begin{scope}[shift={(-.5,-8)}]
			\draw[fill=black!10,orgrun] (0,0) coordinate (l)
				\foreach \d/\i in {5} {
					rectangle node (n000) {}
					++(\d,1) ++(\delta,-1) 
				}
				++(-\delta,0) coordinate (r)
			;
			\draw[black!50,very thick,opacity=.5] (n00) to (n000);
		\end{scope}
		
		\begin{scope}[shift={(-.5+.5+5,-8)}]
			\draw[fill=black!10] (0,0) coordinate (l)
				\foreach \d/\i in {3,3} {
					rectangle node (n000) {}
					++(\d,1) ++(\delta,-1) 
				}
				++(-\delta,0) coordinate (r)
			;
			\node[tree] (n001) at (3+0.5*\delta,.5) {};
			\draw[black!50,very thick,opacity=.5] (n00) to (n001);
		\end{scope}
		\begin{scope}[shift={(+5,-12)}]
			\draw[fill=black!10,orgrun] (0,0) coordinate (l)
				\foreach \d/\i in {3} {
					rectangle node (n0010) {}
					++(\d,1) ++(\delta,-1) 
				}
				++(-\delta,0) coordinate (r)
			;
			\draw[black!50,very thick,opacity=.5] (n001) to (n0010);
		\end{scope}
		\begin{scope}[shift={(+5+3+\delta,-12)}]
			\draw[fill=black!10,orgrun] (0,0) coordinate (l)
				\foreach \d/\i in {3} {
					rectangle node (n0011) {}
					++(\d,1) ++(\delta,-1) 
				}
				++(-\delta,0) coordinate (r)
			;
			\draw[black!50,very thick,opacity=.5] (n001) to (n0011);
		\end{scope}
	
		\begin{scope}[shift={(0.25+5+3+3+3.5*\delta,-5)}]
			\draw[fill=black!10] (0,0) coordinate (l)
				\foreach \d/\i in {14,1,2} {
					rectangle 
					++(\d,1) ++(\delta,-1) 
				}
				++(-\delta,0) coordinate (r)
			;
			\coordinate (m) at ($(l)!.5!(r)$);
			\draw[|-|] ($(l)+(0,\intskip)$) node[above=3pt] {~0} -- ($(m)+(0,\intskip)$) node[above=3pt] {\nicefrac12} ;
			\draw[|-|] ($(r)+(0,\intskip)$) node[above=3pt] {1} -- ($(m)+(0,\intskip)$) ;
			\node[tree] (n01) at (14+0.5*\delta,.5) {};
			\draw[thick,densely dotted] (m) ++ (0,-.1) -- ++(0,2) ;
			\draw[->] ($(l)!.5!(r)$) ++(0,.5) -- (n01) ;
			\draw[black!50,very thick,opacity=.5] (n0) to (n01);
		\end{scope}	
		
		\begin{scope}[shift={(.125+5+3+3+3.5*\delta,-8)}]
			\draw[fill=black!10,orgrun] (0,0) coordinate (l)
				\foreach \d/\i in {14} {
					rectangle node (n010) {}
					++(\d,1) ++(\delta,-1) 
				}
				++(-\delta,0) coordinate (r)
			;
			\draw[black!50,very thick,opacity=.5] (n01) to (n010);
		\end{scope}
		
		\begin{scope}[shift={(.25+5+3+3+14+5.5*\delta,-8)}]
			\draw[fill=black!10] (0,0) coordinate (l)
				\foreach \d/\i in {1,2} {
					rectangle node (n000) {}
					++(\d,1) ++(\delta,-1) 
				}
				++(-\delta,0) coordinate (r)
			;
			\node[tree] (n011) at (1+0.5*\delta,.5) {};
			\draw[black!50,very thick,opacity=.5] (n01) to (n011);
		\end{scope}
		\begin{scope}[shift={(5+3+3+14+6.5*\delta,-12)}]
			\draw[fill=black!10,orgrun] (0,0) coordinate (l)
				\foreach \d/\i in {1} {
					rectangle node (n0110) {}
					++(\d,1) ++(\delta,-1) 
				}
				++(-\delta,0) coordinate (r)
			;
			\draw[black!50,very thick,opacity=.5] (n011) to (n0110);
		\end{scope}
		\begin{scope}[shift={(5+3+3+14+1+7.5*\delta,-12)}]
			\draw[fill=black!10,orgrun] (0,0) coordinate (l)
				\foreach \d/\i in {2} {
					rectangle node (n0111) {}
					++(\d,1) ++(\delta,-1) 
				}
				++(-\delta,0) coordinate (r)
			;
			\draw[black!50,very thick,opacity=.5] (n011) to (n0111);
		\end{scope}
	
	
	
	
	\begin{scope}[shift={(38,0)}]
	
		\draw[fill=black!10] (0,0) coordinate (l)
			\foreach \d/\i in {5,3,3,14,1,2} {
				rectangle 
				++(\d,1) ++(\delta,-1) 
			}
			++(-\delta,0) coordinate (r)
		;
		\coordinate (m) at ($(l)!.5!(r)$);
		\coordinate (MM) at ($(l)!.5!(r)$);
		\draw[|-|] ($(l)+(0,\intskip)$) node[above=3pt] {0} -- ($(m)+(0,\intskip)$) node[above=3pt] {\nicefrac12} ;
		\draw[|-|] ($(r)+(0,\intskip)$) node[above=3pt] {1} -- ($(m)+(0,\intskip)$) ;
		\node[tree] (n0) at (5+3+3+2.5*\delta,.5) {}; 
		\draw[thick,densely dotted] (m) ++ (0,-.1) -- ++(0,2) ;
		\draw[->] ($(l)!.5!(r)$) ++(0,.5) -- (n0) ;
		
		\begin{scope}[shift={(-.1,-5)}]
			\draw[fill=black!10] (0,0) coordinate (l)
				\foreach \d/\i in {5,3,3} {
					rectangle 
					++(\d,1) ++(\delta,-1) 
				}
				++(-\delta,0) coordinate (rr)
			;
			\coordinate (r) at ($(MM)+(-.1,-5)$) ;
			\coordinate (m) at ($(l)!.5!(r)$);
			\draw[|-|] ($(l)+(0,\intskip)$) node[above=3pt] {0} -- ($(m)+(0,\intskip)$) node[above=3pt] {\nicefrac14} ;
			\draw[|-|] ($(r)+(0,\intskip)$) node[above=3pt] {\nicefrac12} -- ($(m)+(0,\intskip)$) ;
			\node[tree] (n00) at (5+3+1.5*\delta,.5) {};
			\draw[thick,densely dotted] (m) ++ (0,-.1) -- ++(0,2) ;
			\draw[->] ($(l)!.5!(r)$) ++(0,.5) -- (n00) ;
			\draw[black!50,very thick,opacity=.5] (n0) to (n00);
		\end{scope}
		
		\begin{scope}[shift={(-.2,-8)}]
			\draw[fill=black!10] (0,0) coordinate (l)
				\foreach \d/\i in {5,3} {
					rectangle 
					++(\d,1) ++(\delta,-1) 
				}
				++(-\delta,0) coordinate (r)
			;
			\node[tree] (n000) at (5+0.5*\delta,.5) {};
			\draw[black!50,very thick,opacity=.5] (n00) to (n000);
		\end{scope}
		
		\begin{scope}[shift={(-.25+.5+5+3,-8)}]
			\draw[fill=black!10,orgrun] (0,0) coordinate (l)
				\foreach \d/\i in {3} {
					rectangle node (n001) {}
					++(\d,1) ++(\delta,-1) 
				}
				++(-\delta,0) coordinate (r)
			;
			\draw[black!50,very thick,opacity=.5] (n00) to (n001);
		\end{scope}
		\begin{scope}[shift={(0,-12)}]
			\draw[fill=black!10,orgrun] (0,0) coordinate (l)
				\foreach \d/\i in {5} {
					rectangle node (n0010) {}
					++(\d,1) ++(\delta,-1) 
				}
				++(-\delta,0) coordinate (r)
			;
			\draw[black!50,very thick,opacity=.5] (n000) to (n0010);
		\end{scope}
		\begin{scope}[shift={(+5+\delta,-12)}]
			\draw[fill=black!10,orgrun] (0,0) coordinate (l)
				\foreach \d/\i in {3} {
					rectangle node (n0011) {}
					++(\d,1) ++(\delta,-1) 
				}
				++(-\delta,0) coordinate (r)
			;
			\draw[black!50,very thick,opacity=.5] (n000) to (n0011);
		\end{scope}
	
		\begin{scope}[shift={(0.1+5+4+2+3.5*\delta,-5)}]
	%
			\draw[fill=black!10] (0,0) coordinate (ll)
				\foreach \d/\i in {14,1,2} {
					rectangle 
					++(\d,1) ++(\delta,-1) 
				}
				++(-\delta,0) coordinate (r)
			;
			\coordinate (l) at ($(MM)+(.1,-5)$);
			\coordinate (m) at ($(l)!.5!(r)$);
			\draw[|-|] ($(l)+(0,\intskip)$) node[above=3pt] {} -- ($(m)+(0,\intskip)$) node[above=3pt] {\nicefrac34} ;
			\draw[|-|] ($(r)+(0,\intskip)$) node[above=3pt] {1} -- ($(m)+(0,\intskip)$) ;
			\node[tree] (n01) at (14+0.5*\delta,.5) {};
			\draw[thick,densely dotted] (m) ++ (0,-.1) -- ++(0,2) ;
			\draw[->] ($(l)!.5!(r)$) ++(0,.5) -- (n01) ;
			\draw[black!50,very thick,opacity=.5] (n0) to (n01);
		\end{scope}	
		
		\begin{scope}[shift={(.125+5+4+2+3.5*\delta,-8)}]
			\draw[fill=black!10,orgrun] (0,0) coordinate (l)
				\foreach \d/\i in {14} {
					rectangle node (n010) {}
					++(\d,1) ++(\delta,-1) 
				}
				++(-\delta,0) coordinate (r)
			;
			\draw[black!50,very thick,opacity=.5] (n01) to (n010);
		\end{scope}
		
		\begin{scope}[shift={(.25+5+4+2+14+5.5*\delta,-8)}]
			\draw[fill=black!10] (0,0) coordinate (l)
				\foreach \d/\i in {1,2} {
					rectangle node (n0111) {}
					++(\d,1) ++(\delta,-1) 
				}
				++(-\delta,0) coordinate (r)
			;
			\node[tree] (n011) at (1+0.5*\delta,.5) {};
			\draw[black!50,very thick,opacity=.5] (n01) to (n011);
		\end{scope}
		\begin{scope}[shift={(5+4+2+14+6.5*\delta,-12)}]
			\draw[fill=black!10,orgrun] (0,0) coordinate (l)
				\foreach \d/\i in {1} {
					rectangle node (n0110) {}
					++(\d,1) ++(\delta,-1) 
				}
				++(-\delta,0) coordinate (r)
			;
			\draw[black!50,very thick,opacity=.5] (n011) to (n0110);
		\end{scope}
		\begin{scope}[shift={(5+4+2+14+1+7.5*\delta,-12)}]
			\draw[fill=black!10,orgrun] (0,0) coordinate (l)
				\foreach \d/\i in {2} {
					rectangle node (n0111) {}
					++(\d,1) ++(\delta,-1) 
				}
				++(-\delta,0) coordinate (r)
			;
			\draw[black!50,very thick,opacity=.5] (n011) to (n0111);
		\end{scope}
		
		\node[yshift=-2ex,xshift=-.2ex] at (n000) {\smaller[2]\itshape 3};
		\node[yshift=-2ex,xshift=-.2ex] at (n00)  {\smaller[2]\itshape 2};
		\node[yshift=-2ex] at (n0)   {\smaller[2]\itshape 1};
		\node[yshift=-2ex,xshift=-.2ex] at (n01)  {\smaller[2]\itshape 2};
		\node[yshift=-2ex,xshift=.8ex] at (n011) {\smaller[2]\itshape 4};
		
	\end{scope}
	
	\end{tikzpicture}
	\end{center}
	\caption{%
		The two versions of weight-balancing for computing nearly-optimal alphabetic trees.
		The gap probabilities are proportional to $5,3,3,14,1,2$.
%
		\textbf{\sffamily Left:} Mehlhorn's ``Method~1'' chooses the split closest to the midpoint of the 
		subtree's actual weights ($\nicefrac12$ after renormalizing).
		\textbf{\sffamily Right:} ``Method~2'' continues to cut the original interval in half, irrespective
		of the total weight of the subtrees.
		The italic numbers are the powers of the nodes (see \wtpref{def:node-power}).
		%
	}
\label{fig:nearly-optimal-trees}
\end{figure}

Method~1 was proposed in~\cite{WalkerGotlieb1972} and analyzed in \cite{Mehlhorn1975,Bayer1975};
Method~2 is discussed in~\cite{Mehlhorn1977}.
While Method~1 is arguably more natural, Method~2 has the advantage to yield
splits that are predictable without going through all steps of the recursion.
Both methods can be implemented to run in time $O(m)$ and yield very good trees.
(Recall that in the case $\beta_j = 0$ the classic information-theoretic 
argument dictates $C\ge \mathcal H$; 
Bayer~\cite{Bayer1975} gives lower bounds in the general case.)


\begin{theorem}[Nearly-Optimal BSTs]
\label{thm:nearly-opt-trees}
	Let $\alpha_0,\beta_1,\alpha_1,\ldots,\beta_m,\alpha_m \in [0,1]$ with $\sum \alpha_i+\sum\beta_j = 1$ 
	be given and let $\mathcal H = \sum_{i=0}^m \alpha_i \lg(1/\alpha_i) + \sum_{j=1}^m \beta_j \lg(1/\beta_j)$.
\begin{enumerate}[(i)]
\item 
	Method~1 yields a tree with search cost 
	$C \le \mathcal H + 2$.
	\cite[Thm\,4.8]{Bayer1975}
\item 
	If all $\beta_j = 0$,
	Method~1 yields a tree with search cost 
	$C \le \mathcal H + 2 - (m+3) \alpha_{\mathrm{min}}$,\\
	where $\alpha_{\mathrm{min}} = \min \{\alpha_0,\ldots,\alpha_m\}$.
	\cite{Horibe1977}
\item 
	Method~2 yields a tree with search cost
	$C \le \mathcal H + 1 + \sum \alpha_i$.
	\cite{Mehlhorn1977}
\end{enumerate}
\end{theorem}


\subsection{Merge Costs}
\label{sec:merge-costs}

%
%
%
%

In this paper, we are primarily concerned with finding a good \emph{order} of binary merges 
for the existing runs in the input.
Following \cite{AugerNicaudPivoteau2015} and \cite{BussKnop2018},
we will define the \emph{merge cost} $M$ for merging two runs of lengths $m$ resp.\ $n$ 
as $M = m+n$, \ie, the size of the result.
This quantity has been studied earlier by 
Golin and Sedgewick~\cite{GolinSedgewick1993} without giving it a name.

Merge costs abstract away from key comparisons and element moves
and simplify computations (see next subsection).
Since any merge has to move most elements (except for rare lucky cases),
and the average number of comparisons using standard merge routines
is $m+n - \bigl(\frac m{n+1} + \frac{n}{m+1}\bigr)$, 
merge costs are a reasonable approximation,
in particular when $m$ and $n$ are roughly equal.
They always yield an upper bound for both the number of comparisons and moves.

%
%
%
%
%
%
%





\subsection{Merge Trees}
\label{sec:merge-trees}

Let $L_1,\ldots, L_r$ with $\sum L_i = n$ be the lengths of the runs in the input.
Any natural mergesort can be described as a rule to select some of the remaining runs, 
which are then merged and replaced by the merge result. If we always merge \emph{two} runs
this corresponds to a binary tree with the original runs at leaves $\leafnode1,\ldots,\leafnode{\like1r}$. 
Internal nodes correspond to the result of merging their children.
If we assign to internal node \internalnode j
the size $M_j$ of the (intermediate) merge result it represents,
then the overall merge cost is exactly $M = \sum_{\internalnodescript j} M_j$ (summing
over all internal nodes).
\wref{fig:nearly-optimal-trees} shows two examples of merge trees;
the merge costs are given by adding up all gray areas,%
\footnote{%
	The left tree is obviously better here
	and this is a typical outcome.
	But there are also inputs where Method 2 yields a 
	better tree than Method 1.
}
(ignoring the dotted leaves).

Let $d_i$ be the \emph{depth} of leaf \leafnode i (corresponding to the run of length $L_i$),
where depth is the number of edges on the path to the root.
Every element in the $i$th run is counted exactly $d_i$ times in $\sum_{\internalnodescript j} M_j$,
so we have $M = \sum_{i=1}^r d_i\cdot L_i$.
Dividing by $n$ yields $M/n = \sum_{i=1}^r d_i\cdot \alpha_i$ for $\alpha_i = L_i / n$, 
which happens to be the expected search time $C$ in the merge tree
if \leafnode i is requested with probability $\alpha_i$ for $i=1,\ldots,r$.
So the minimal-cost merge tree for given run lengths $L_1,\ldots,L_r$ 
is the optimal alphabetic tree for leaf probabilities $\frac{L_1}n,\ldots,\frac{L_r}n$
and it holds
$M \ge \mathcal H(\frac{L_1}n,\ldots,\frac{L_m}n) n$.
For distinct keys, the lower bound on comparisons (\wref{sec:lower-bound}) 
coincides up to linear terms 
with this lower bound.


Combining this fact with the linear-time methods for nearly-optimal binary search trees 
from \wref{sec:optimal-BSTs}
immediately gives a stable sorting method that adapts optimally to existing runs
up to an $O(n)$ term.
We call such a method a \emph{nearly-optimal (natural) mergesort}.
%
	A~direct implementation of this idea needs $\Theta(r)$ space to store $L_1,\ldots,L_r$ 
	and the merge tree and does an extraneous pass over the data 
	just to determine the run lengths.
	The purpose of this paper is to show that we can make the overhead 
	for finding a nearly-optimal merging order
	negligible in time and space.
%



\section{Nearly-Optimal Merging Orders}
\label{sec:algorithms}

We now describe two sorting methods that simulate nearly-optimal search tree algorithms
to compute nearly-optimal merging orders, but do so without ever storing the full merge tree 
or even the run lengths.

\subsection{Peeksort: A Simple Top-Down Method}

The first method is similar to standard top-down mergesort
in that it implicitly constructs a merge tree on the call stack.
Instead of blindly cutting the input in half, however, we mimic Mehlhorn's Method~1.
For that we need the \emph{run boundary closest to the middle} of the input: 
this will become the root of the merge tree.
Since we want to detect existing runs anyway at some point, 
we start by finding the run that contains the middle position.
The end point closer to the middle determines the top-level cut and 
we recursively sort the parts left and right of it.
A final merge completes the sort.

To avoid redundant scans, we pass on the information about already detected runs.
In the general case, we are sorting a range $A[\ell..r]$ whose 
prefix $A[\ell..e]$ and suffix $A[s..r]$ are runs.
Depending on whether the middle is contained in one of those runs, 
we have one of four different cases; apart from that
the overall procedure (\wref{alg:peeksort}) is quite straight-forward.

\begin{algorithm}[tbph]
\vspace*{-2ex}
\small
\tikzset{every node/.style={font=\scriptsize}}
	\begin{codebox}
		\Procname{$\proc{PeekSort}(A[\ell..r],e,s)$}
		\li \kw{if} $e \isequal r $ or $s \isequal \ell$ \kw{then} \Return
		\li $m \gets \ell + \bigl\lfloor \frac{r-\ell}2 \bigr\rfloor$
		\li \If $m \le e$   
			\>\>\>\>\>\Comment
			\begin{tikzpicture}[scale=.35,baseline=.3ex]
				\draw[fill=black!10] (0,0) rectangle (13,1) ;
				\draw[fill=black!10] (18,0) rectangle (20,1) ;
				\draw (0,0) rectangle (10,1) rectangle (20,0) ;
				\node[anchor=base] at ( 0.5,.25) {$\ell$} ;
				\node[anchor=base] at (19.5,.25) {$r$} ;
				\node[anchor=base] at (12.5,.25) {$e$} ;
				\node[anchor=base] at (18.5,.25) {$s$} ;
				\node[overlay] at (10,1.3) {$m$} ;
			\end{tikzpicture}
		\Then
			\li $\proc{PeekSort}(A[e+1..r],e+1,s)$
			\li $\proc{Merge}(A[\ell..e],A[e+1..r])$
		\li \Else \kw{if} $m \ge s$
			\>\>\>\>\Comment
			\begin{tikzpicture}[scale=.35,baseline=.3ex]
				\draw[fill=black!10] (0,0) rectangle (3,1) ;
				\draw[fill=black!10] (8,0) rectangle (20,1) ;
				\draw (0,0) rectangle (10,1) rectangle (20,0) ;
				\node[anchor=base] at ( 0.5,.25) {$\ell$} ;
				\node[anchor=base] at (19.5,.25) {$r$} ;
				\node[anchor=base] at (2.5,.25) {$e$} ;
				\node[anchor=base] at (8.5,.25) {$s$} ;
				\node[overlay] at (10,1.3) {$m$} ;
			\end{tikzpicture}
			\li $\proc{PeekSort}(A[\ell..s-1], e,s-1)$
			\li $\proc{Merge}(A[\ell..s-1],A[s..r])$
		\li \Else
			\zi \Comment Find existing run $A[i..j]$ containing position $m$
			\li $i \gets \proc{ExtendRunLeft}(A[m], \ell)$; \quad
				$j \gets \proc{ExtendRunRight}(A[m], r)$
			\li \kw{if} $i\isequal \ell$ and $j\isequal r$ \Return
			\li \If $m - i < j - m$
			\>\>\>\>\Comment
			\begin{tikzpicture}[scale=.35,baseline=.3ex]
				\draw[fill=black!10] (0,0) rectangle (3,1) ;
				\draw[fill=black!10] (18,0) rectangle (20,1) ;
				\draw[fill=black!10] (8.5,0) rectangle (16,1) ;
				\draw (0,0) rectangle (10,1) rectangle (20,0) ;
				\node[anchor=base] at ( 0.5,.25) {$\ell$} ;
				\node[anchor=base] at (19.5,.25) {$r$} ;
				\node[anchor=base] at (2.5,.25) {$e$} ;
				\node[anchor=base] at (18.5,.25) {$s$} ;
				\node[anchor=base] at (9.0,.25) {$i$} ;
				\node[anchor=base] at (15.5,.25) {$j$} ;
				\node[overlay] at (10,1.3) {$m$} ;
			\end{tikzpicture}
			\Then
				\li $\proc{PeekSort}(A[\ell..i-1],e,i-1)$
				\li $\proc{PeekSort}(A[i..r],j,s)$
				\li $\proc{Merge}(A[\ell..i-1],A[i..r])$
			\li \Else
			\>\>\>\Comment
			\begin{tikzpicture}[scale=.35,baseline=.3ex]
				\draw[fill=black!10] (0,0) rectangle (3,1) ;
				\draw[fill=black!10] (18,0) rectangle (20,1) ;
				\draw[fill=black!10] (5.5,0) rectangle (12,1) ;
				\draw (0,0) rectangle (10,1) rectangle (20,0) ;
				\node[anchor=base] at ( 0.5,.25) {$\ell$} ;
				\node[anchor=base] at (19.5,.25) {$r$} ;
				\node[anchor=base] at (2.5,.25) {$e$} ;
				\node[anchor=base] at (18.5,.25) {$s$} ;
				\node[anchor=base] at (6,.25) {$i$} ;
				\node[anchor=base] at (11.5,.25) {$j$} ;
				\node[overlay] at (10,1.3) {$m$} ;
			\end{tikzpicture}
				\li $\proc{PeekSort}(A[\ell..j],e,i)$
				\li $\proc{PeekSort}(A[j+1..r],j+1,s)$
				\li $\proc{Merge}(A[\ell..j],A[j+1..r])$
	\end{codebox}
	\vspace*{-1ex}
	\caption{%
		Peeksort: A simple top-down version of nearly-optimal natural mergesort.
		The initial call is $\proc{PeekSort}(A[1..n],1,n)$.
		Procedures \proc{ExtendRunLeft} (-\proc{Right}) scan left (right) starting at $A[m]$
		as long as the run continues (and we did not cross the second parameter).%
	}
	\label{alg:peeksort}
	\vspace*{-3ex}
\end{algorithm}



The following theorem shows that \proc{PeekSort} is indeed a nearly-optimal mergesort.
Unlike previous such methods, its code has very little overhead
(in terms of both time and space) in comparison
with a standard top-down mergesort,
so it is a promising method for a practical nearly-optimal mergesort.


\begin{theorem}
\label{thm:peeksort}
	The merge cost of \proc{PeekSort} on an input consisting of $r$ runs with 
	respective lengths $L_1,\ldots,L_r$ is at most $\mathcal H(\frac{L_1}n,\ldots,\frac{L_m}n)n + 2n - (r+2)$,
	the number of comparisons is at most $\mathcal H(\frac{L_1}n,\ldots,\frac{L_m}n)+3n - (2r+3)$.
	Both is optimal up to $O(n)$ terms (in the worst case).
\end{theorem}

\begin{proof}
	The recursive calls of \wref{alg:peeksort} produce the same tree as Mehlhorn's Method~1
	with input $(\alpha_0,\ldots,\alpha_m) = (\frac{L_1}n,\ldots,\frac{L_r}n)$ (\ie, $m=r-1$)
	and $\beta_j=0$.
	By \wref{thm:nearly-opt-trees}--(ii), the search costs in this tree are 
	$C \le \mathcal H+2 - (m+3)\alpha_{\mathrm{min}}$ with $\mathcal H = \mathcal H(\frac{L_1}n,\ldots,\frac{L_m}n)$.
	Since $L_j \ge 1$, we have $\alpha_{\mathrm{min}} \ge\frac1n$.
	As argued in \wref{sec:merge-trees}, the overall merge costs are then given by
	$M = C n \le \mathcal H n + 2n - (r+2)$, which is within $O(n)$ of the lower bound for $M$.
	
	We save at least one comparison per merge since merging runs of lengths $m$ and $n$ 
	requires at most $n+m-1$ comparisons. In total, we do exactly $r-1$ merge operations. 
	Apart from merging, we need a total of $n-1$ additional comparisons to detect the existing runs
	in the input.
	Barbay and Navarro~\cite[Thm.\,2]{BarbayNavarro2013} argued that $\mathcal H n - O(n)$ 
	comparisons are necessary if the elements in the input are all distinct.
\end{proof}


%
%
%

\subsection{Powersort: A Single-Pass Stack-Based Method}

One little blemish remains in \proc{PeekSort}: we have to use ``random accesses'' into the
middle of the array to decide how to proceed. 
Even though we only use cache-friendly sequential scans, 
the I/O operations to load the middle run are effectively wasted, 
since it will often be merged only much later (after further recursive calls).
Timsort and the other stack-based variants from~\cite{AugerNicaudPivoteau2015,BussKnop2018}
proceed in one left-to-right scan over the input and merge the top runs 
on their stack. 
This increases the likelihood to still have (parts of) the most recently detected run 
in cache when it is merged subsequently.



\subsubsection{The power of top-down in a bottom-up method}

Method~2 to construct nearly-optimal search trees suggests the following definition:
%
\begin{definition}[Node Power]
\label{def:node-power}
	Let $\alpha_0,\ldots,\alpha_m$, $\sum \alpha_j=1$ be leaf probabilities. 
	For $1\le j\le m$,
	let \internalnode j be the internal node separating the $(j-1)$st and $j$th leaf.
	The \emph{power} of (the split at) node \internalnode j is
	\begin{align*}\SwapAboveDisplaySkip
			P_j
		&\wrel=
			\min \Biggl\{ 
				\ell\in\N : \biggl\lfloor \frac a{2^{-\ell}} \biggr\rfloor 
					< \biggl\lfloor \frac b{2^{-\ell}} \biggr\rfloor  
			\Biggr\},\;
%
	\text{where }
			a
		\wrel=
			\sum_{i=0}^{j-1} \alpha_i - \tfrac12 \alpha_{j-1},\;
			b
		\wrel=
			\sum_{i=0}^{j-1} \alpha_i + \tfrac12 \alpha_{j}.
	\end{align*}
	($P_j$ is the index of the first bit where the (binary) fractional parts of $a$ and $b$ differ.)
\end{definition}
%
Intuitively, $P_j$ is the ``intended'' depth of \internalnode j, but 
nodes occasionally end up higher in 
the tree if some leaf has a large weight relative to the current subtree,
(see the rightmost branch in \wref{fig:nearly-optimal-trees}).
%
Mehlhorn's~\cite{Mehlhorn1977,Mehlhorn1984} 
original implementation of Method~2, procedure \emph{construct-tree},
does not single out the case that the next desired cut point lies
\emph{outside} the range of a subtree.
This reduces the number of cases, but for our application, it is more convenient 
to explicitly check for this out-of-range case, and if it occurs to
directly proceed to the next cut point.
We refer to the modified algorithm as \emph{Method~2\/${}'$};
\wref{app:method-2-prime} gives the details and shows that the changes do not affect
the guarantee for Method~2 in  \wref{thm:nearly-opt-trees}.
In fact Method~2${}'$ seems to typically yield slightly \emph{better} trees 
than Method~2, but there are also counterexamples.

The core benefit of Method~2${}'$, however, is that the resulting tree is 
characterized by local information, namely the node powers,
without requiring any coordination of a top-down recursive procedure.
%
\begin{lemma}[Path power monotonicity]
\label{lem:path-monotonicity}
	Consider the tree constructed by Method~2\/${}'$.
	The powers of internal nodes along any root-to-leaf path is strictly increasing.
\end{lemma}
%
The proof is given in \wref{app:method-2-prime}.
\begin{corollary}
\label{cor:cartesian-tree}
	The tree constructed by Method~2\/${}'$ for leaf probabilities $\alpha_0,\ldots,\alpha_m$
	is the (min-oriented) Cartesian tree for the sequence of node powers $P_1,\ldots,P_m$.
	It can thus be constructed iteratively (left to right) by the algorithm of 
	Gabow, Bentley, and Tarjan~\cite{GabowBentleyTarjan1984}.
\end{corollary}


\subsubsection{Merging on-the-fly}

We implicitly use the observation from \wref{cor:cartesian-tree} in our algorithm ``powersort''
to construct the tree from left to right.
Whenever the next internal node has a smaller power than the preceding one, 
we are following an edge from a left child 
up to its parent. 
That means that this subtree does not change anymore and we can execute any pending merges 
in it before continuing.
If we are instead following an edge down to a right child of a node, that subtree is still ``open''
and we push the corresponding run on the stack.
\wref{alg:powersort} shows the detailed code.

\begin{algorithm}[tbph]
\vspace*{-2ex}
\small
\tikzset{every node/.style={font=\scriptsize}}
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
	\begin{codebox}
		\Procname{$\proc{PowerSort}(A[1..n])$}
		\li $X \gets $ stack of runs   \>\>\>\>\>\>\textsmaller{(capacity $\lfloor\lg(n)\rfloor+1$)}
		\li $P \gets $ stack of powers \>\>\>\>\>\>\textsmaller{(capacity $\lfloor\lg(n)\rfloor+1$)}
		\li $s_1 \gets 1$; \; 
			$e_1 = \proc{ExtendRunRight}(A[1],n)$
			\quad\Comment $A[s_1..e_1]$ is leftmost run
		\li \While $e_1 < n$
		\Do
			\li $s_2 \gets e_1+1$; \;
				$e_2 \gets \proc{ExtendRunRight}(A[s_2],n)$
				\quad\Comment $A[s_2..e_2]$ next run
			\li $p \gets \proc{NodePower}(s_1,e_1,s_2,e_2,n)$ 
			\quad \Comment $P_j$ for node \internalnode j between $A[s_1..e_1]$ and $A[s_2..e_2]$
			\li \While $P.top() > p$ \>\>\>\>\quad\Comment previous merge deeper in tree than current
			\Do
				\li $P.pop()$
					\>\>\>\quad\Comment $\leadsto$ merge and replace run~$A[s_1..e_1]$ by result
				\li $(s_1,e_1) \gets \proc{Merge}(X.\id{pop}(), \, A[s_1..e_1])$
			\End
			\li $X.\id{push}(A[s_1,e_1])$; \; $P.\id{push}(p)$
			\li $s_1 \gets s_2$; \; $e_1 \gets e_2$
		\EndWhile
		\Comment Now $A[s_1..e_1]$ is the rightmost run
		\li \While $\neg X.\id{empty}()$
		\Do
			\li $(s_1,e_1) \gets \proc{Merge}(X.\id{pop}(), \, A[s_1..e_1])$
		\End
	\end{codebox}
	\vspace*{-5ex}
	\begin{codebox}
		\Procname{$\proc{NodePower}(s_1,e_1,s_2,e_2,n)$}
		\li $n_1 \gets e_1-s_1 + 1$; \; 
			$n_2 \gets e_2 - s_2 + 1$; \; $\ell \gets 0$
		\li $a \gets ( s_1 + n_1/2 - 1 ) / n$; \;
			$b \gets ( s_2 + n_2/2 - 1 ) / n$
%
		\li \kw{while} $\lfloor a\cdot 2^\ell \rfloor \isequal \lfloor b\cdot 2^\ell \rfloor$ 
			\kw{do} $\ell\gets\ell+1$ \kw{end while}
		\li \Return$(\ell)$
	\end{codebox}
	\vspace*{-1ex}
	\caption{%
		Powersort: A one-pass stack-based nearly-optimal natural mergesort.
		Procedure \proc{ExtendRunRight} scans right as long as the run continues.
	}
	\label{alg:powersort}
	\vspace*{-3ex}
\end{algorithm}

The runs on the stack correspond to nodes with strictly increasing powers,
so we can bound the stack height by the maximal $P_j$.
Since our leaf probabilities here are $\alpha_j = \frac{L_j}n\ge \frac1n$, 
we have $P_j \le \lfloor \lg n\rfloor + 1$.



\begin{theorem}
\label{thm:powersort}
	The merge cost of \proc{PowerSort} is at most $\mathcal H(\frac{L_1}n,\ldots,\frac{L_m}n)+2n$,
	the number of comparisons is at most $\mathcal H(\frac{L_1}n,\ldots,\frac{L_m}n)+3n-r$.
	Moreover, (apart from buffers for merging) only $O(\log n)$ words of extra space 
	are required.
\end{theorem}
\begin{proof}
	The merge tree of \proc{PowerSort} is exactly the search tree constructed by Method~2${}'$
	on leaf probabilities $(\alpha_0,\ldots,\alpha_m) = (\frac{L_1}n,\ldots,\frac{L_r}n)$
	and $\beta_j=0$.
	By \wref{thm:nearly-opt-trees}--(iii), the search costs are 
	$C \le \mathcal H+2$ with $\mathcal H = \mathcal H(\frac{L_1}n,\ldots,\frac{L_m}n)$, so
	the overall merge costs are 
	$M = C n \le \mathcal H n + 2n$, which is within $O(n)$ of the lower bound for $M$.
	The comparisons follow as for \wref{thm:peeksort}.
\end{proof}











\section{Running-Time Study}
\label{sec:experiments}


We conducted a running-time study comparing the
two new nearly-optimal mergesorts with 
current state-of-the-art implementations and
elementary mergesort variants.
The code is available on github~\cite{githubCode}.

\needspace{3\baselineskip}
\smallskip\noindent
The goal of this study is to show that
\begin{enumerate}
\item 
	peeksort and powersort have very little overhead compared to standard (non-natural)
	mergesort variants (\ie, they are never (much) slower), and at the same time
\item
	peeksort and powersort outperform other mergesort variants on
	partially presorted inputs.
\end{enumerate}
Timsort is arguably the most used adaptive sorting method;
even though analytical guarantees are still to be found,
its efficiency in particular for partially sorted inputs has been 
demonstrated empirically~\cite{Peters2002}.
A secondary goal is hence to
\begin{enumerate}
\setcounter{enumi}{2}
\item
	investigate the typical merge costs of Timsort on different inputs.
\end{enumerate}

%
\subsection{Setup}
Oracle's Java runtime library includes a highly tuned Timsort implementation;
to be able to directly compare with it, we chose to implement our algorithms in Java.
The Timsort implementation is used for \texttt{Object[]}, \ie,
arrays of \emph{references} to objects;
since the location of objects on the heap is hard to control and likely to produce
more or less cache misses from run to run, we chose to sort \texttt{int[]}s instead
to obtain more reproducible results.
We thus modified the library implementation of Timsort accordingly.
This scenario makes key comparisons and element moves relatively cheap and thereby 
emphasizes the remaining overhead of the methods,
which is in line with
our primary goal 
%
%
%
	1) to study the impact of the additional bookkeeping
	required by the adaptive methods.
%

%
We compare our methods with simple top-down and bottom-up mergesort implementations.
We use the code given by Sedgewick~\cite[Programs~8.3 and~8.5]{Sedgewick2003}
with his simple merge method (Program~8.2) as its basis;
in both cases, we add a check before calling merge to detect if the runs happen 
to be already in sorted order, and we use insertionsort for base cases of size $n\le w = 24$.
(For bottom-up mergesort, we start by sorting chunks of size $w=24$.)
%
%
%
%
%
%
%
Our Java implementations of peeksort and powersort are described in more detail in \wref{app:java-code}.
Apart from a mildly optimized version of the pseudocode, we added the same cutoff / minimal run length 
($w=24$) as above.

All our methods call the same merge procedure, whereas
the library Timsort contains a modified merge method
that tries to save key comparisons:
when only elements from the same run are selected for the output repeatedly,
Timsort enters a \emph{``galloping mode''} and uses exponential searches 
(instead of the conventional sequential search) to find
the insertion position of the next element. Details are described by Peters~\cite{Peters2002}.
Since saving comparisons is not of utmost importance in our scenario of sorting \texttt{int}s,
we also added a version of Timsort, called ``trotsort'', that uses our plain merge method instead
of galloping, but is otherwise identical to the library Timsort.

%
Our hard- and software setup is listed in
\wref{app:setup}.
We use the following inputs types:
\begin{itemize}
\item
	\emph{random permutations} are a case where no long runs are present to exploit;
\item
	\emph{``random-runs'' inputs} are constructed from a random permutation by sorting 
	segments of random lengths,
	where the lengths are chosen independently according to a geometric distribution with a 
	given mean $\ell$;
	since the geometric distribution has large variance, 
	these inputs tend to have runs whose sizes vary a lot;
\item
	\emph{``Timsort-drag'' inputs} are special instances of random-runs inputs 
	where the run lengths are chosen as $\mathcal R_{\mathrm{tim}}$,
	the bad-case example for Timsort from~\cite[Thm.\,3]{BussKnop2018}.
\end{itemize}


\subsection{Overhead of Nearly-Optimal Merge Order}

We first consider random permutations as inputs.
Since random permutations contain (with high probability) no long runs 
that can be exploited, the adaptive methods will not find anything 
that would compensate for their additional efforts to identify runs.
(This is confirmed by the fact that the total merge costs of all methods, 
including Timsort, are within 1.5\% of each other in this scenario.)
\wref{fig:times-normalized-rp} shows average running times
for inputs sizes from $100\,000$ to $100$ million ints.
(Measurements for $n=10\,000$ were too noisy to draw meaningful conclusions.)

\begin{figure}[tbh]
	\begin{minipage}[c]{0.6\textwidth}
		\hspace*{-.5em}\includegraphics[width=\textwidth]{pics/times-normalized-rp-means-over-log10n}%
  	\end{minipage}\hfill
  	\begin{minipage}[c]{.38\textwidth}
		\caption{%
			Normalized running times on random permutations. 
			The $x$-axis shows $\log_{10}(n)$, the $y$-axis show average and standard deviation (as error bars)
			of $t/(n \lg n)$ where $t$ is the running time in ms.
			We plot averages over 1000 repetitions (resp.\ 200 and 20 for the largest sizes).
		%
		}
	\label{fig:times-normalized-rp}
	\end{minipage}
\end{figure}

The relative ranking is clearly stable across different input sizes.
\texttt{Arrays.sort(int[])} (dual-pivot quicksort) is the fastest method,
but is not a stable sort and only serves as a baseline.
The timings of top-down and bottom-up mergesort, 
peeksort and powersort are 20--30\% slower than dual-pivot quicksort.
Comparing the four to each other, no large differences
are visible; if anything, bottom-up mergesort was a bit slower for large inputs.
Since the sorting cutoff / minimal run length $w=24$ exceeded the length of \emph{all} 
runs in all inputs, we are effectively presented with a case of all-equal run lengths.
Merging them blindly from left to right (as in bottom-up mergesort) then performs just fine,
and top-down mergesort finds a close-to-optimal merging order in this case.
%
%
%
%
%
%
That peek- and powersort perform essentially \emph{as good as} elementary mergesorts
on random permutations thus clearly indicates that their overhead 
for determining a nearly-optimal merging order is negligible.

The library Timsort performs surprisingly bad on \texttt{int[]}s,
probably due to the relatively cheap comparisons.
Replacing the galloping merge with the ordinary merge alleviates this
(see ``trotsort''), 
but Timsort remains inferior on random permutations by a fair margin
(10--20\%).


%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%

\subsection{Practical speedups by adaptivity}

%
	\begin{figure}[tbh]
		\plaincenter{
			\includegraphics[width=.8\linewidth]{pics/runs20-500-example}
		}
		\caption{%
			A random-runs input with $n=500$ and $\ell=20\approx\sqrt n$. The $x$-axis is the index in the array,
			the $y$-axis the value. Runs are emphasized by color.%
		}
		\label{fig:typical-random-runs}
	\end{figure}
%
After demonstrating that we do not lose much by using our adaptive methods
when there is nothing to adapt to,
we next investigate how much can be gained if there is.
We consider random-runs inputs as described above.
This input model instills a good dose of presortedness, but
not in a way that gives any of the tested methods an obvious
advantage or disadvantage over the others.
We choose a representative size of $n=10^7$ and an expected run length $\ell = 3\,000$,
so that we expect roughly $\sqrt n$ runs of length $\sqrt n$.


\begin{figure}[tbh]
	\plaincenter{%
%
%
%
%
			\includegraphics[height=10\baselineskip]{pics/times-runs3k-10m}\qquad%
			\includegraphics[height=10\baselineskip]{pics/mergecost-runs3k-10m}%
%
	}
	\vspace{-1ex}
	\caption{%
		Average running times (left) and normalized merge cost (right) on 
		random-runs inputs with $n=10^7$ and $\ell=3\,000\approx \sqrt n$.
		The merge costs have been divided by $n\lg(n/w)\approx1.87\cdot 10^8$, 
		which is the merge cost a (hypothetical) optimal mergesort that does 
		not pick up existing runs, but starts merging with runs of length $w=24$.
	}
\label{fig:times-mergecost-random-runs}
\end{figure}


If this was a random permutation, we would expect merge costs of 
roughly $n \lg(n/w) \approx 1.87 \cdot10^8$ (indeed a bit above this).
The right chart in \wref{fig:times-mergecost-random-runs} shows 
that the adaptive methods can bring the merge cost down to a little over 60\%
of this number.
%
%
%
	Note the run lengths vary considerably~-- 
	to give some intuitive feel for this volatility, \wref{fig:typical-random-runs} 
	shows a stereotypical (but smaller) random-runs input.
%
Powersort achieved average merge costs of 
$1.14\cdot10^8 < n \lg r \approx 1.17 \cdot 10^8$, \ie,
less than a method would that
only adapts to the \emph{number} of runs $r$.

In terms of running time, powersort is again among the fastest stable methods,
and indeed 20\% \emph{faster} than \texttt{Arrays.sort(int[])}.
The best adaptive methods are also 10\% faster than top-down mergesort.
(The latter is ``slightly adaptive'', 
by omitting merges if the runs happen to already be in order.)
This supports the statement that significant speedups can be realized
by adaptive sorting on inputs with existing order, and 
$\sqrt n$ runs suffice for that.
If we increase $\ell$ to $100\,000$, so that we expect only roughly $100$ long runs,
the library quicksort becomes twice as slow as powersort and Timsort (trotsort).

Timsort's running time is a bit anomalous again. 
Even though it occasionally incurs 10\% more merge costs on a given input than
powersort, the running times were within 1\% of each other 
(considering the trotsort variant;
the original galloping version was again uncompetitive).



\subsection{Non-optimality of Timsort}

Finally, we consider ``Timsort-drag'' inputs, a sequence
of run lengths $\mathcal R_{\mathrm{tim}}(n)$ 
specifically crafted by Buss and Knop~\cite{BussKnop2018}
to generate unbalanced merges (and hence large merge cost) in Timsort.
Since actual Timsort implementations employ minimal run lengths of up to $32$ elements
we multiplied the run lengths by $32$.
\wref{fig:times-mergecost-timdrag} shows running time and merge cost for all
methods on a characteristic Timsort-drag input of length $2^{24}\approx 1.6 \cdot 10^7$.

\begin{figure}[tbh]
	\plaincenter{%
%
%
%
%
			\includegraphics[height=10\baselineskip]{pics/times-timdrag-16m}\qquad%
			\includegraphics[height=10\baselineskip]{pics/mergecost-timdrag-16m}%
%
	}
	\vspace{-1ex}
	\caption{%
		Average running times (left) and normalized merge cost (right) on 
		``Timsort-drag'' inputs with $n=2^{24}$ and run lengths 
		$\mathcal R_{\mathrm{tim}}(2^{24}/32)$ multiplied by $32$.
		Merge costs have been divided by $n \lg(n/w) \approx 3.26\cdot10^8$.
	}
\label{fig:times-mergecost-timdrag}
\end{figure}


In terms of merge costs, Timsort now pays 30\% more than even a simple non-adaptive
mergesort, whereas peeksort and powersort obviously retain their proven nearly-optimal
behavior.
Also in terms of running time, Timsort is a bit slower than top-down mergesort,
and 10\% slower than powersort on these inputs.
It is remarkable that the dramatically larger merge cost does not lead to 
a similarly drastic slow down in practice.
Nevertheless, it must be noted that Timsort's merging strategy has weaknesses,
and it is unclear if more dramatic examples are yet to be found.



%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%





\section{Conclusion}
\label{sec:conclusion}

In this paper, we have demonstrated that provably good merging orders for natural mergesort 
can be found with negligible overhead.
The proposed algorithms, peeksort and powersort offer more reliable performance than
the widely used Timsort, and at the same time, are arguably simpler.

Powersort builds on a modified bisection heuristic for computing nearly-optimal binary search trees
that might be independent interest.
It has the same quality guarantees as Mehlhorn's original formulation, but
allows the tree to be built ``bottom-up'' as a Cartesian tree over a certain sequence, the ``node powers''.
It is the only such method for nearly-optimal search trees to our knowledge.

Buss and Knop conclude with the question
whether there exists a $k$-aware algorithm 
(a stack-based natural mergesort that only considers the top $k$ runs in the stack)
with merge cost $(1+o_r(1))$ times the optimal merge cost~\cite[Question~37]{BussKnop2018}.
Powersort effectively answers this question in the affirmative with $k=3$.%
\footnote{%
	Strictly speaking, powersort needs a relaxation of the model of Buss and Knop.
	They require decisions to be made solely based on the \emph{lengths} of runs, 
	whereas node power takes the location of the runs within the array into account.
	Since the location of a run must be stored anyway, this appears reasonable to us.
}

\subsection{Extensions and future work}

Timsort's ``galloping merge'' procedure saves comparisons when we consistently consume 
elements from one run, but in ``well-mixed'' merges, it does not help (much).
It would be interesting to compare this method with other comparison-efficient
merge methods.

Another line of future research is to explore ways to profit from duplicate keys in the input.
The ultimate goal would be a ``synergistic'' sorting method
(in the terminology of~\cite{BarbayOchoaSatti2017}) that has practically no overhead for detecting
existing runs and equals and yet exploits their \emph{combined} presence optimally.


\clearpage
\appendix

\section{Method~2${}'$ for nearly-optimal search trees}
\label{app:method-2-prime}

This section uses Mehlhorn's~\cite{Mehlhorn1977,Mehlhorn1984} original notation,
in particular, it handles the general optimal binary search tree setting.
We add the following two ``out-of-range'' cases to Mehlhorn's procedure 
$\mathit{construct\text-tree}(i,j,\mathit{cut},\ell)$, at the very beginning:

\begin{itemize}
\item (Case L) If $s_j < \mathit{cut} + 2^{-\ell}$, return
	$\mathit{construct\text-tree}(i,j,\mathit{cut},\ell+1)$
\item (Case R) If $\mathit{cut} + 2^{-\ell} < s_i$, return
	$\mathit{construct\text-tree}(i,j,\mathit{cut} + 2^{-\ell},\ell+1)$
\end{itemize}

The original procedure would end up in case C instead of L resp.\ 
case D instead of R and choose a right- resp.\ leftmost key as the
root node.
But if the desired cut point $\mathit{cut}+2^{-\ell}$ lies completely
outside the range of bisection $[s_i,s_j]$, this produces an unnecessarily
unbalanced split.
This case can only happen if the neighboring leaf has a probability
larger than $\frac12$ relative to the previous subtree, so that the current split point
still lies within the range corresponding to the previously chosen root.
Our cases L and R thus ``skip'' this void cut point $\mathit{cut}+2^{-\ell}$
and increment $\ell$ without generating a node.

Given that the invariants (1)--(4) are fulfilled for the current parameters
of \emph{construct-tree}, they will also be fulfilled in the recursive calls
issued in cases L and R.
Therefore, Mehlhorn's analysis remains valid for our modified procedure:
In his Fact~3, we have $b_h+1 \le \ell$ and $a_h \le \ell$ (instead of equality),
but this is all that is needed to establish Fact~4 and hence the bound on the search costs.


\subsection{Proof of \wref{lem:path-monotonicity}}

\textbf{\textsf{Claim:}} 	
In the tree constructed by Method~2\/${}'$,
the powers of internal nodes along any root-to-leaf path are strictly increasing.


%
\begin{proof}
Consider the recursive procedure \emph{construct-tree}
as described by Mehlhorn~\cite{Mehlhorn1977,Mehlhorn1984}, 
but with the additional cases from above.
We prove that whenever a recursive call 
$\textit{construct\text-tree}(i,j,\mathit{cut},\ell)$ creates
an internal node \internalnode k, we have $P_k = \ell$.
Since $\ell$ is incremented in all recursive calls, the claim follows.

%
%
%
%
Only cases A, B, C or D create new nodes, so assume we are not in case L or R.
Then we actually have the stronger version of invariant~(4):
$\mathit{cut} \le s_i\le \mathit{cut} + 2^{-\ell}\le s_j \le \mathit{cut}+2^{-\ell+1}$
and hence will always find a $k$ with $i<k\le j$ and 
\[\mathit{cut} \wrel\le s_{k-1} \wrel< \mathit{cut}+2^{-\ell} \wrel\le s_k \wrel\le \mathit{cut}+2^{-(\ell-1)}\]
for which we now create the node \internalnode k.
Dividing by $2^{-\ell}$ shows that $P_k = \ell$ (we have $a = s_{k-1}$ and $b = s_k$).
\end{proof}



\section{Java Code}
\label{app:java-code}
\lstset{
	tabsize=3,
	basewidth=.55em,
	language=Java,
	numbers=left,
	numberstyle=\tiny\sffamily,
	numbersep=-.8em,
	basicstyle=\footnotesize\ttfamily,
}

\bigskip\noindent
In this appendix, we give the core methods of a Java implementation of
\wref{alg:peeksort} and \wref{alg:powersort} that form the basis of our running-time
study.
The goal is to document (and comment on) a few design decisions and optimizations
that have been included in the running time study.
The full code, including the main routines to reproduce the running time studies
exactly as used for this paper,
is available on github~\cite{githubCode}.

\subsection{Merging}

All our mergesort variants (except for the original library implementation of Timsort)
use the following straight-forward ``bitonic'' merge procedure that
merges two adjacent runs.
It is taken from \cite[Program~8.2]{Sedgewick2003}

\begin{lstlisting}
	/** merges A[l..m-1] and A[m..r] */
	static void mergeRuns(int[] A, int l, int m, int r, int[] aux) {
		--m; // accounts for different convention in Sedgewick's book
		int i, j;
		for (i = m+1; i > l; --i) aux[i-1] = A[i-1];
		for (j = m; j < r; ++j) aux[r+m-j] = A[j+1];
		for (int k = l; k <= r; ++k)
			A[k] = aux[j] < aux[i] ? aux[j--] : aux[i++];
	}
\end{lstlisting}

Merging offers some potential for improvements in particular \wrt the number
of used key comparisons.
Since we operate on integers, comparisons are cheap and more sophisticated
merging strategies will not be needed here.

\subsection{Peeksort}

The pseudocode for Peeksort can be translated to Java almost verbatim.
Since the recursion is costly for small input sizes,
we switch to insertionsort when the subproblem size
is small. 
Values for \texttt{INSERTION\_SORT\_THRESHOLD} of $10$--$32$ yielded good 
results in the experiments; we ultimately set it to $24$ to approximate
the choice in the library implementation of Timsort.
(The latter chooses the minimal run length between $16$ and $32$ 
depending on $n$ by a heuristic that tries to avoid imbalanced merges.
We did not use this adaptive choice in our methods.)

\begin{lstlisting}[language=Java]
	static void peeksort(int[] A, int left, int right, 
	                     int leftRunEnd, int rightRunStart, int[] B) {
		if (leftRunEnd == right || rightRunStart == left) return;
		if (right - left + 1 <= INSERTION_SORT_THRESHOLD) {
			insertionsort(A, left, right, leftRunEnd - left + 1); return;
		}
		int mid = left + ((right - left) >> 1);
		if (mid <= leftRunEnd) {            // |XXXXXXXX|XX     X|
			peeksort(A, leftRunEnd+1, right, leftRunEnd+1,rightRunStart, B);
			mergeRuns(A, left, leftRunEnd+1, right, B);
		} else if (mid >= rightRunStart) {  // |XX     X|XXXXXXXX|
			peeksort(A, left, rightRunStart-1, leftRunEnd, rightRunStart-1, B);
			mergeRuns(A, left, rightRunStart, right, B);
		} else { // find middle run
			int i, j;
			if (A[mid] <= A[mid+1]) {
				i = extendIncreasingRunLeft(A, mid, leftRunEnd + 1);
				j = mid+1 == rightRunStart ? mid : 
					extendIncreasingRunRight(A, mid+1, rightRunStart - 1);
			} else {
				i = extendDecreasingRunLeft(A, mid, leftRunEnd + 1);
				j = mid+1 == rightRunStart ? mid : 
					extendStrictlyDecreasingRunRight(A, mid+1,rightRunStart - 1);
				reverseRange(A, i, j);
			}
			if (i == left && j == right) return;
			if (mid - i < j - mid) {         // |XX     x|xxxx   X|
				peeksort(A, left, i-1, leftRunEnd, i-1, B);
				peeksort(A, i, right, j, rightRunStart, B);
				mergeRuns(A,left, i, right, B);
			} else {                         // |XX   xxx|x      X|
				peeksort(A, left, j, leftRunEnd, i, B);
				peeksort(A, j+1, right, j+1, rightRunStart, B);
				mergeRuns(A,left, j+1, right, B);
			}
		}
	}
\end{lstlisting}

\subsection{Insertionsort to extend runs}

Here (and in the following code), we use a straight insertionsort
variant that accepts the length of a sorted prefix as an additional parameter.
A similar method is also used in Timsort to extend runs to a forced minimal
length.
The library Timsort uses binary insertionsort instead, 
but unless comparisons are expensive, a straight sequential-search variant is sufficient.

\begin{lstlisting}
	static void insertionsort(int[] A, int left, int right, int nPresorted) {
		assert right >= left;
		assert right - left + 1 >= nPresorted;
		for (int i = left + nPresorted; i <= right ; ++i) {
			int j = i - 1,  v = A[i];
			while (v < A[j]) {
				A[j+1] = A[j];
				--j;
				if (j < left) break;
			}
			A[j+1] = v;
		}
	}
\end{lstlisting}


\subsection{Powersort}

For powersort, we implement the stack as an array that is indexed by the node power.
Thereby, we avoid explicit stack operations and to store powers explicitly.
On the other hand, we have to check for empty entries since powers are not always consecutive.

\begin{lstlisting}[language=Java]
	static void powersort(int[] A, int left, int right) {
		int n = right - left + 1;
		int lgnPlus2 = log2(n) + 2;
		int[] leftRunStart = new int[lgnPlus2], leftRunEnd = new int[lgnPlus2];
		Arrays.fill(leftRunStart, -1);
		int top = 0;
		int[] buffer = new int[n >> 1];
	
		int startA = left, endA = extendRunRight(A, startA, right);
		int lenA = endA - startA + 1;
		if (lenA < minRunLen) { // extend to minRunLen
			endA = Math.min(right, startA + minRunLen-1);
			insertionsort(A, startA, endA, lenA);
		}
		while (endA < right) {
			int startB = endA + 1, endB = extendRunRight(A, startB, right);
			int lenB = endB - startB + 1;
			if (lenB < minRunLen) { // extend to minRunLen
				endB = Math.min(right, startB + minRunLen-1);
				insertionsort(A, startB, endB, lenB);
			}
			int k = nodePower(left, right, startA, startB, endB);
			assert k != top;
			for (int l = top; l > k; --l) { // clear left subtree bottom-up
				if (leftRunStart[l] == -1) continue;
				mergeRuns(A, leftRunStart[l], leftRunEnd[l]+1, endA, buffer);
				startA = leftRunStart[l];
				leftRunStart[l] = -1;
			}
			// store left half of merge between A and B on stack
			leftRunStart[k] = startA; leftRunEnd[k] = endA;
			top = k;
			startA = startB; endA = endB;
		}
		assert endA == right;
		for (int l = top; l > 0; --l) {
			if (leftRunStart[l] == -1) continue;
			mergeRuns(A, leftRunStart[l], leftRunEnd[l]+1, right, buffer);
		}
	}
\end{lstlisting}

The computation of the node powers can be done in many different ways and offers a lot
of potential for low-level bitwise optimizations; some care is needed to prevent overflows.
In our experiments, the following loop-less version was a tiny bit faster than
other tried alternatives.

\begin{lstlisting}
	static int nodePower(int left, int right, int startA, int startB, int endB) {
		int twoN = (right - left + 1) << 1; // 2*n
		long l = startA + startB - (left << 1);
		long r = startB + endB + 1 - (left << 1);
		int a = (int) ((l << 31) / twoN);
		int b = (int) ((r << 31) / twoN);
		return Integer.numberOfLeadingZeros(a ^ b);
	}
\end{lstlisting}



\section{Experimental Setup}
\label{app:setup}

All experiments were run on a Lenovo Thinkpad X230 Tablet
running Ubuntu 16.04.01 with Linux kernel 4.13.0-38-generic.
The CPU is an Intel Core i7-3520M CPU with 2.90GHz, the system has 8GB of main memory.

The Java compiler was from the Oracle Java JDK version 1.8.0\_161,
the JVM is Java HotSpot 64-Bit Server VM (build 25.161-b12, mixed mode).
All experiments were run with disabled X server from the TTY,
the java process was bound to one core (with the \texttt{taskset} utility).
They started with a warmup phase to trigger just-in-time (JIT) compilation
before measuring individual sorting operations.
The inputs were generated outside the timing window and reused the same array for all
repetitions.
%
The following flags were used for the JVM:
\texttt{-XX:+UnlockDiagnosticVMOptions}, \texttt{-XX:-TieredCompilation} and  \texttt{-XX:+PrintCompilation}.
Tiered compilation was disabled to avoid multiple passes of just-in-time compilation
to occur during the timed experiments; the print-compilation flag was used to
monitor whether relevant methods are subjected to recompilation or deoptimization
during the experiments.





\bibliography{mergesort.bib}


\end{document}
