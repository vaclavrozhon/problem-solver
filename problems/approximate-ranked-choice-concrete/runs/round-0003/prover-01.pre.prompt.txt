=== SYSTEM ===
You are a research mathematician. 

You are being run in a loop with a verifier that checks rigor. Your goal is to make **incremental, auditable progress**. You are not expected to solve the problem at once, but to generate new, testable ideas.

Inputs: 
- task statement 
- notes.md (informal progress & exploratory work; optional) 
- proofs.md (rigorously proven results & detailed proofs; optional) 
- output.md (main results summary only; optional) 
- summary of past rounds (optional) 
- possibly some reference papers.

What counts as progress:
- Extract small lemmas/heuristics from literature and state them cleanly with one-line "why useful here".
- Explore small examples & try to break your own claims with toy counterexamples.
- Prove special cases or nontrivial bounds.
- If an approach fails, explain crisply why.
- Point out flaws in notes.md, proofs.md, or output.md (but do not rewrite these files yourself).

**Discipline.** 
- Read notes, outputs, summaries carefully before proposing new work. 
- Reference papers if relevant, but focus on *incremental, checkable steps*. 
- Do not output Markdown code fences, only raw JSON. 
- Length: at least ~200 words. 
- Organize your reasoning with short headings (Ideas, Examples, Obstacles, Next steps), make clear what your claims are and how they are supported. 
- Remember: the verifier curates notes and outputs, you only suggest.

**Output**: Write your analysis as Markdown that includes both informal reasoning and any rigorous proofs. The verifier will decide what goes into notes.md, proofs.md, and output.md.

**Return strictly JSON**:
{
  "content": "Your complete analysis in Markdown (KaTeX allowed). Include reasoning, examples, proofs, failed attempts, intuitions - everything for the verifier to review."
}


=== USER ===
=== Task (txt) ===

# Problem Statement

We consider the problem of estimating the winner in an election run under **Ranked Choice Voting** (also known as *Instant-Runoff Voting*).  

Suppose there are \(K\) candidates. Each voter submits a complete ranking of these candidates. The voting rule proceeds in rounds: in each round, every ballot is assigned to the top-ranked candidate who is still in contention. The candidate with the smallest number of votes is eliminated (with ties broken according to a fixed deterministic rule), and this candidate is crossed out from all ballots. The process repeats until only one candidate remains, who is declared the winner.

Our goal is not to compute the exact winner from the full set of ballots, but rather to estimate a *robust* winner from a random sample of ballots. To make this precise, we introduce the notion of an **ε-winner**. A candidate \(c\) is called an ε-winner of an election profile if it is possible to add at most an ε-fraction of additional ballots to the election so that \(c\) becomes the winner under Ranked Choice Voting. In other words, \(c\) is “close” to being the true winner, in the sense that a small perturbation of the electorate would make \(c\) win. There may be more ε-winners. The real winner is ε-winner for any ε. 

The sampling model is as follows. We assume there is a large population of voters, each ballot drawn independently from the empirical distribution of this population. The algorithm does not see all the ballots; instead, it may sample ballots at random, with replacement. The task of the algorithm is: given parameters \(\varepsilon\) and \(\delta\), and access to at most \(m\) random ballots, output a candidate \(\hat{c}\) such that with probability at least \(1-\delta\), the candidate \(\hat{c}\) is an ε-winner of the true election.

There is a natural algorithm for this problem: Sample a subset of votes and run the ranked-choice algorithm on them; output the winner. How many samples are needed for this algorithm to succeed? We seek the best possible upper and lower bound. 



=== Notes ===

# Research Notes



# Certificates and sampling for IRV ε-winners

- Notation: For S⊆C, a∈S, p_a(S)=Pr[top_S(ballot)=a]. Adding ε mass of c-first ballots increases c’s tallies by ε for every S containing c and leaves others’ tallies unchanged (compare absolute counts; normalization is irrelevant for elimination).

- Correct sufficient certificate (uniform): If for every nonempty S⊇{c} we have p_c(S) ≥ min_{a∈S\{c}} p_a(S) − ε (with tie-breaking known and either strict margins or reserved slack), then after adding ε mass of c-first ballots, c is never strictly below the minimum and hence cannot be eliminated; thus c wins.

- Caveat on single-chain certificates: Verifying inequalities only along one elimination chain of opponents is insufficient for K≥4, because the actual post-augmentation elimination path may visit sets not on the chosen chain. Therefore the earlier Lemma 1 (single-chain witness) is not a valid sufficient condition in general.

- K=3 case: There are only two relevant sets containing c (C and {c,x}). A union bound over the 9 quantities {p_a(S)}_{a∈S} yields uniform deviation, and adding ε mass to the sample winner ĉ suffices with ε=2α.

- Adaptivity: For sample-run IRV, one can control all top-of-set frequencies uniformly by a union bound over K·2^{K−1} indicators; this is exponential computationally but only linear in K in the sample size via the log term.

- Two-phase certification idea: Use a holdout sample to compute B̃(c)=max_{S⊇{c}}(min_{a∈S\{c}} p̃_a(S)−p̃_c(S)). If B̃(c)≤ε/2 (and uniform deviation ≤ε/4), then c is an ε-winner. This avoids chain-dependence but may be computationally heavy.

- Lower bounds: K=2 needs m=Ω((1/ε^2)·log(1/δ)). A Fano construction suggests m=Ω((log K)/ε^2) for identifying a unique ε/4-winner among K candidates; to be formalized with explicit IRV distributions.

- Next steps: (i) Provide a minimal counterexample demonstrating failure of single-chain certificates for K≥4 (or a proof that extra conditions suffice). (ii) Finalize the K=3 theorem with corrected constants and full tie handling. (iii) Either analyze the one-phase algorithm via a uniform bound that implies ε-winning, or switch to a two-phase max-deficit certificate. (iv) Complete the Fano lower bound.


## Refinements and validations

- Single-chain certificates fail (explicit K=4 counterexample). Ballot types and weights:
  T1: c>a>d>b (0.34), T2: a>d>c>b (0.29), T3: d>c>a>b (0.34), T4: b>a>d>c (0.03). First round eliminates b; then on {a,c,d} eliminate a; final pair {c,d} with c losing 0.34 vs 0.66. Chain checks against b then a and the pair {c,a} all pass (even with ε=0), yet c does not win. Hence chain-only witnesses are unsound for K≥4.

- Uniform max-deficit certificate. Define B(c)=max_{S⊇{c}} (min_{a∈S\{c}} p_a(S) − p_c(S)). If B(c) < ε, then adding ε mass of c-first ballots makes c safe in every S and thus an ε-winner. If only B(c) ≤ ε, either assume the tie-breaking never eliminates c on equality or require a strict slack.

- Two-phase holdout certification. Phase 1: pick ĉ by running IRV on m1 samples. Phase 2: estimate all p_a(S) for S⊇{ĉ} and a∈S on an independent holdout of size m2. With Hoeffding + union bound over M = (K−1)·2^{K−2} (others) plus 2^{K−1} (ĉ) indicators, uniform deviation ≤ ε/4 holds if m2 ≥ (2/ε^2)·ln(2M/δ). If B̃(ĉ) ≤ ε/2 − ξ, then B(ĉ) ≤ ε − ξ and ĉ is an ε-winner. Threshold ε/2 without slack requires favorable tie-breaking on equality.

- K=3 with separation. If |p_a(C) − p_b(C)| ≥ γ and m ≥ (8/ε^2)·ln(18/δ) with γ ≥ ε/2 (so α ≤ ε/4 ≤ γ/2), then the sample more-popular opponent x̂ equals the true x*, and the sample winner ĉ is an ε-winner with probability ≥ 1−δ by verifying safety at C and a head-to-head win versus x*.

- Open directions: (i) Reduce the family of S needed for certification (are worst-case S IRV-reachable?). (ii) One-phase analysis via uniform deviations that imply B̂(ĉ) small. (iii) Complete the Fano Ω((log K)/ε^2) lower bound with an explicit IRV family.



=== Current Output ===

Main results to date:

- K=3 (natural algorithm, with separation). If |p_a(C)−p_b(C)| ≥ ε/2 and m ≥ (8/ε^2)·ln(18/δ), then with probability at least 1−δ the sample IRV winner ĉ is an ε-winner.

- Two-phase holdout certification (general K). Draw m1 ballots to select ĉ by running IRV; then on an independent holdout of size m2 ≥ (2/ε^2)·ln(2M/δ), with M=(K−1)·2^{K−2}+2^{K−1}, compute B̃(ĉ)=max_{S⊇{ĉ}}(min_{a∈S\{ĉ}} p̃_a(S)−p̃_{ĉ}(S)). If B̃(ĉ) ≤ ε/2 − ξ (for any ξ>0), then with probability at least 1−δ, ĉ is an ε-winner.

- Baseline lower bound (K=2). Any algorithm needs m = Ω((1/ε^2)·log(1/δ)).

Open: Tight guarantees for the one-phase natural algorithm when K≥4 without separation assumptions.


=== Round 1 Summary ===

This round analyzed sample complexity and certificates for finding an ε-winner under IRV. Main positive result: for K=3, running IRV on m ≥ (2/ε^2)·ln(18/δ) i.i.d. ballots yields the sample winner ĉ which is an ε-winner with probability ≥1−δ (Hoeffding + union bound over 9 top-of-set events). We proved a correct uniform sufficient certificate: if for every S⊇{c}, p_c(S) ≥ min_{a∈S\{c}} p_a(S) − ε then c is an ε-winner. We also found the previously proposed single-chain certificate is unsound for K≥4 (the elimination path after augmentation can visit sets off the chosen chain). Lower bounds: K=2 requires m = Ω((1/ε^2)·log(1/δ)); a Fano-type construction suggests m = Ω((log K)/ε^2) to identify a unique ε-winner among K (to be formalized). Two practical approaches were proposed—(i) one-phase uniform control (union bound over K·2^{K−1} top-of-set indicators, computationally exponential but adds only Θ(K) in the log factor of m), and (ii) a two-phase holdout max-deficit certificate (correct but computationally heavy). Citations: Research Notes; Current Proofs.


=== Round 2 Summary ===

This round corrected a flawed ‘‘single-chain’’ certificate and developed sound certificates and sample bounds for estimating IRV ε-winners from samples. Main advances: an explicit K=4 counterexample showing chain-only checks can fail; a correct uniform max-deficit certificate B(c)=max_{S⊇{c}}(min_{a∈S\{c}} p_a(S)−p_c(S)) (B(c)<ε ⇒ c is an ε-winner, equality needs tie-handling); a two-phase holdout certification with m2 ≥ (2/ε^2)·ln(2M/δ) (M=(K−1)·2^{K−2}+2^{K−1}); and a K=3 positive result under a separation assumption (m ≥ (8/ε^2)·ln(18/δ), γ ≥ ε/2). Lower bound K=2: m = Ω((1/ε^2)·ln(1/δ)); a Fano-type Ω((log K)/ε^2) lower bound is outlined but not yet formalized. Citations: Research Notes; Current Proofs.


=== Previous Round Feedback ===

Strong progress. You correctly abandoned the single-chain witness and replaced it with a uniform max-deficit certificate B(c). That certificate (when used with strict slack) is sound and neatly captures the ε-winner notion. Your K≥4 counterexample is convincing and directly refutes chain-only checks; note it is even stronger than stated: in your instance the chain inequalities hold with ε=0, yet c still loses, so single-chain certifications can fail catastrophically.

The two-phase (holdout) certification algorithm is on solid footing. Minor refinements: (i) count the functions more tightly as M = (K−1)·2^{K−2} (for others) plus 2^{K−1} (for c), so M ≤ (K+1)·2^{K−2}; (ii) state the guarantee with a strict threshold to avoid tie-handling issues: if uniform deviation ≤ ε/4 and B̃(ĉ) ≤ ε/2 − ξ, then B(ĉ) ≤ ε − ξ and ĉ is an ε-winner. If you want to use the threshold ε/2 exactly, you must additionally assume the tie-breaking rule will not eliminate ĉ when equality occurs after adding ε.

Your K=3 result with separation is well-motivated: correctly identifying the final opponent x* is needed if you only verify the sample’s final pair. The constant m ≥ (8/ε^2)·ln(18/δ) follows from enforcing α ≤ ε/4; the logic that x* is the true final opponent if c survives the first round is correct. The proof cleanly yields strict margins, so tie issues are avoided.

Lower bounds: K=2 (Le Cam) is fine. The Fano Ω((log K)/ε^2) plan is promising but needs a concrete IRV-compatible family and a uniqueness proof for the ε/4-winner.

Next steps:
- Formalize the holdout theorem with the tightened M and explicit strict-threshold tie handling.
- Move the K=3-with-separation theorem into proofs; remove the earlier unconditional K=3 bound.
- Either analyze the one-phase algorithm via a uniform-over-all-S deviation argument that implies B̂(ĉ) small, or design a computationally lighter certificate family than all S (e.g., prove B(c) is attained on an IRV-reachable S).
- Complete the Fano construction.
