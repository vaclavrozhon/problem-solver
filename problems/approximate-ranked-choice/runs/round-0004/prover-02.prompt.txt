=== SYSTEM ===
You are a research mathematician. 

You are being run in a loop with a verifier that checks rigor. Your goal is to make **incremental, auditable progress**. You are not expected to solve the problem at once, but to generate new, testable ideas.

Inputs: 
- task statement 
- notes.md (informal progress & exploratory work; optional) 
- proofs.md (rigorously proven results & detailed proofs; optional) 
- output.md (main results summary only; optional) 
- summary of past rounds (optional) 
- possibly some reference papers.

What counts as progress:
- Extract small lemmas/heuristics from literature and state them cleanly with one-line "why useful here".
- Explore small examples & try to break your own claims with toy counterexamples.
- Prove special cases or nontrivial bounds.
- If an approach fails, explain crisply why.
- Point out flaws in notes.md, proofs.md, or output.md (but do not rewrite these files yourself).

**Discipline.** 
- Read notes, outputs, summaries carefully before proposing new work. 
- Reference papers if relevant, but focus on *incremental, checkable steps*. 
- Do not output Markdown code fences, only raw JSON. 
- Length: at least ~200 words. 
- Organize your reasoning with short headings (Ideas, Examples, Obstacles, Next steps), make clear what your claims are and how they are supported. 
- Remember: the verifier curates notes and outputs, you only suggest.

**Output**: Write your analysis as Markdown that includes both informal reasoning and any rigorous proofs. The verifier will decide what goes into notes.md, proofs.md, and output.md.

**Return strictly JSON**:
{
  "content": "Your complete analysis in Markdown (KaTeX allowed). Include reasoning, examples, proofs, failed attempts, intuitions - everything for the verifier to review."
}


=== USER ===
=== Task (txt) ===

# Problem Statement

We consider the problem of estimating the winner in an election run under **Ranked Choice Voting** (also known as *Instant-Runoff Voting*).  

Suppose there are \(K\) candidates. Each voter submits a complete ranking of these candidates. The voting rule proceeds in rounds: in each round, every ballot is assigned to the top-ranked candidate who is still in contention. The candidate with the smallest number of votes is eliminated (with ties broken according to a fixed deterministic rule), and this candidate is crossed out from all ballots. The process repeats until only one candidate remains, who is declared the winner.

Our goal is not to compute the exact winner from the full set of ballots, but rather to estimate a *robust* winner from a random sample of ballots. To make this precise, we introduce the notion of an **ε-winner**. A candidate \(c\) is called an ε-winner of an election profile if it is possible to add at most an ε-fraction of additional ballots to the election so that \(c\) becomes the winner under Ranked Choice Voting. In other words, \(c\) is “close” to being the true winner, in the sense that a small perturbation of the electorate would make \(c\) win. There may be more ε-winners. The real winner is ε-winner for any ε. 

The sampling model is as follows. We assume there is a large population of voters, each ballot drawn independently from the empirical distribution of this population. The algorithm does not see all the ballots; instead, it may sample ballots at random, with replacement. The task of the algorithm is: given parameters \(\varepsilon\) and \(\delta\), and access to at most \(m\) random ballots, output a candidate \(\hat{c}\) such that with probability at least \(1-\delta\), the candidate \(\hat{c}\) is an ε-winner of the true election.

The central question is: **what is the sample complexity of this problem?**  
That is, how many samples \(m\) are sufficient (and necessary) in order for an algorithm to reliably identify an ε-winner with probability at least \(1-\delta\)? We seek both upper bounds, by designing sampling algorithms and analyzing their guarantees, and lower bounds, by proving that no algorithm can succeed with significantly fewer than a certain number of samples. 



=== Notes ===

# Notes



# Corrected certificate and counterexample for K = 3

Notation: For a candidate set C with |C| = K and any nonempty S ⊆ C with c ∈ S and |S| ≥ 2, define t_a(S) = Pr[top among S is a] under the population distribution P over full rankings.

Corrected c-first certificate: Define

M_c(P) := max_{S ⊆ C, c ∈ S, |S| ≥ 2} [ min_{a ∈ S \ {c}} t_a(S) − t_c(S) ]_+.

If ε > M_c(P), then adding ε' (with 0 < ε' ≤ ε) mass of c-first ballots ensures that in every subset S encountered along any IRV elimination path, c's tally strictly exceeds the minimum among S \ {c}, so c cannot be eliminated and is the eventual winner. This yields a sound, distribution-free sufficient condition. Note the strict inequality requirement; in algorithmic use we maintain a margin so that ε' < ε and ties do not involve c.

Uniform estimation: The family {1[top_S(r) = a]} over all (a, S) has size K · 2^{K-1}. Hoeffding + union bound gives uniform estimation of all t_a(S) within ±τ using m = O((log(K · 2^{K-1}) + log(1/δ))/τ^2) samples. The plug-in estimate \hat M_c satisfies |\hat M_c − M_c| ≤ 2τ.

Counterexample to "K = 3 exactness" of c-first certificate: Let first-place shares be a = 0.38, b = 0.35, c = 0.27. Suppose c beats b head-to-head by margin m = 0.10 but loses to a by margin 0.20. The c-first certificate f_c requires ε ≥ max{0.35 − 0.27, 0.20, 0} = 0.20. However, adding α = 0.11 of c-first ballots and β = 0.03 of b-first ballots yields new first-place tallies c' = 0.38, b' = 0.38, a' = 0.38 (with tiny extra slack to make a uniquely minimal). Then a is eliminated first; in the final, the c vs b margin is m + α − β = 0.10 + 0.11 − 0.03 = 0.18 > 0, so c wins. Total added mass ≈ 0.14 < 0.20. Thus, for K = 3, the minimal augmentation need not equal the c-first-only threshold. A full characterization must allow mixed additions.

LP approach (status and caveats): For a fixed elimination order π, the condition that π(j) is eliminated at round j can be written linearly in terms of the baseline tallies t_a(S_j) and the additive contributions of the added mass y(r) via indicators 1[top_{S_j}(r) = a]. This leads to a linear program minimizing total added mass. To be rigorous one must encode the fixed tie-breaking rule (e.g., by strict inequalities or lexicographic tie constraints). Sensitivity of the LP optimum to perturbations in the t_a(S) (estimated from samples) is the key technical step for a polynomial-in-K sample bound using this approach; deriving an explicit O(poly(K)) Lipschitz constant remains open.

Lower bounds: The Ω((1/ε^2) log(1/δ)) dependence is necessary even for K = 2 (majority). Stronger K-dependent lower bounds (Ω((log K)/ε^2) or Ω(K/ε^2)) are plausible but require explicit constructions.

Next steps summary:
- Formalize LP with tie-breaking and derive sensitivity bounds.
- Provide a correct, closed-form minimal-augmentation characterization for K = 3 allowing mixed additions (compare two strategies: avoid facing a losing opponent by flipping the first-round loser vs. directly fixing the head-to-head deficit).
- Explore whether the worst-case S for the c-first certificate can be restricted by |S| ≤ r for a constant r.
- Build K-dependent lower bounds via Fano/packing constructions over top-of-S events.


## K = 3: exact minimal augmentation via two-type reduction

Let C = {a,b,c} and fix target winner c. Denote first-round shares p_x := t_x({a,b,c}) and pairwise shares t_x({b,c}), t_x({a,c}). To remove dependence on tie-breaking, introduce a slack γ > 0 and require strict separations in all inequalities.

Targeting elimination of a in round 1 and a c vs b final, it suffices to consider only two added ballot types: c-first (amount α ≥ 0) and b-first (amount β ≥ 0). These induce the linear constraints
- First round: p_a + 0 ≤ p_b + β − γ and p_a + 0 ≤ p_c + α − γ, i.e.,
  β ≥ B_γ := [p_a − p_b + γ]_+ and α ≥ A_γ := [p_a − p_c + γ]_+.
- Final: t'_c({b,c}) ≥ t'_b({b,c}) + γ, i.e., α − β ≥ D_γ := t_b({b,c}) − t_c({b,c}) + γ.
The minimum total mass is then
  ε_a^*(γ) = min_{α,β≥0} {α+β : α ≥ A_γ, β ≥ B_γ, α − β ≥ D_γ} = B_γ + max{A_γ, B_γ + D_γ}.
By a dominance argument, a-first additions are never optimal for this targeted strategy: if an a-first ballot ranks c ≻ b, it is dominated by a c-first ballot (strictly improves both elimination inequalities and matches the bc margin); if it ranks b ≻ c, it is dominated by a b-first ballot (improves the relevant elimination inequality and matches the bc margin). The symmetric expression ε_b^*(γ) is obtained by swapping a and b. The exact minimal augmentation to make c win is
  ε^*(γ; c) = min{ε_a^*(γ), ε_b^*(γ)}, and ε^*(c) = lim_{γ→0^+} ε^*(γ; c).
This matches the counterexample in the notes (a=0.38, b=0.35, c=0.27 with c beating b head-to-head): A_0=0.11, B_0=0.03, D_0=−0.10, hence ε_a^*(0) = 0.03 + max{0.11, −0.07} = 0.14.

Sampling for K = 3: Computing ε^*(γ; c) requires only five tallies: p_a, p_b, p_c, t_c({b,c}), t_c({a,c}). A Hoeffding + union bound over these five quantities gives m = Θ((log(1/δ))/ε^2) samples to decide whether ε^*(c) ≤ ε with probability ≥ 1 − δ.

## LP approach: primal/dual and sensitivity status (general K)

For a fixed elimination order π with remaining sets S_j = {π(j),...,π(K)}, add slack γ > 0 and consider variables y(r) ≥ 0 over rankings r. The primal is
- Minimize ∥y∥_1 subject to, for each j and a ∈ S_j \ {π(j)}:
  (t_a(S_j) − t_{π(j)}(S_j)) + ∑_r y(r)(1[top_{S_j}(r)=a] − 1[top_{S_j}(r)=π(j)]) ≥ γ.
Moving baseline tallies to the RHS gives constraints Ay ≥ b, with b_{j,a} = γ − (t_a(S_j) − t_{π(j)}(S_j)). The dual is
- Maximize ∑_{j}∑_{a≠π(j)} λ_{j,a}·(γ − (t_a(S_j) − t_{π(j)}(S_j))) subject to, for every ranking r,
  ∑_{j}∑_{a≠π(j)} λ_{j,a}(1[top_{S_j}(r)=a] − 1[top_{S_j}(r)=π(j)]) ≤ 1, and λ ≥ 0.
Sensitivity: v(b) = max_{λ∈Λ} b^T λ is 1-Lipschitz in the dual norm: |v(b+Δ) − v(b)| ≤ (sup_{λ∈Λ} ∥λ∥_1) ∥Δ∥_∞. Bounding R_K := sup_{λ∈Λ} ∥λ∥_1 by poly(K) would yield a polynomial-in-K sample bound for certifying a fixed π. For K = 3, the two-type reduction collapses Λ to two variables, giving R_3 ≤ 2. For general K, obtaining a good bound on R_K remains open; the per-constraint additive mass approach is invalid because a single added ranking can decrease other constraints when it tops the round-j loser.

## Checklist / next steps
- Formalize the K = 3 theorem and sampling corollary in output.md.
- Keep general c-first certifier and uniform convergence in output.md; use the K = 3 exact result when K = 3.
- Pursue a dual-based sensitivity bound sup_{λ∈Λ} ∥λ∥_1 = poly(K) or an approximate scheme with provable stability.
- Investigate few-type reductions for K ≥ 4 when targeting specific first eliminations.

Updates (verifier audit)

- Invalid general-K two-type claim (first-round-based). It is not enough to compare only first-round shares p_x. Later-round tallies t_w(S) can substantially exceed p_w after transfers. Counterexample sketch (K=4): Let p=(0.26,0.26,0.23,0.25) for (a,b,c,y). Suppose after removing a the tallies on S={b,c,y} are (t_b,t_c,t_y)=(0.40,0.25,0.35). A two-type bound computed only from p would take A*≈0.03 and B*≈0.01, which does not keep c,y above b in S: c would still be the round-2 loser. Any sound certificate must use the relevant subset tallies t_w(S).

- Dual sensitivity (fixed-order LP): prior attempts to bound sup_{λ} ||λ||_1 by K or K−1 dropped the negative term at j=pos_π(x) in the dual constraints. Including it makes the ‘sum over x’ argument cancel, giving no bound. The sensitivity constant remains open.

- Sound general-K two-type (chain) certificate. For target c and pivot b, let S_1=C and iteratively remove e_j = argmin_{e∈S_j\{b,c}} t_e(S_j), with the same deterministic tie-breaking as the election, forming S_{j+1}=S_j\{e_j}. Define
  A_b(γ)=max_j [t_{e_j}(S_j)−t_c(S_j)+γ]_+,
  B_b(γ)=max_j [t_{e_j}(S_j)−t_b(S_j)+γ]_+,
  D_{b,c}(γ)=t_b({b,c})−t_c({b,c})+γ.
Adding α≥A_b(γ) of c-first and β≥B_b(γ) of b-first ballots ensures elimination of e_1,…,e_{K−2} in order and a strict c-over-b final if α−β≥D_{b,c}(γ). The minimal two-type mass is B_b+max{A_b, B_b+D_{b,c}}. This is a sufficient, efficiently checkable condition depending on O(K) subset tallies (those on the chain sets S_j and the final pair).

- K=3 exact formula. The minimal augmentation to make c win is ε^*(γ;c)=min{ε_a^*(γ), ε_b^*(γ)}, where for first-eliminate a: A_γ=[p_a−p_c+γ]_+, B_γ=[p_a−p_b+γ]_+, D_γ=t_b({b,c})−t_c({b,c})+γ, and ε_a^*(γ)=B_γ+max{A_γ, B_γ+D_γ}. This matches the earlier counterexample and strictly improves the c-first certificate. A safe plug-in Lipschitz constant is 6 under sup-norm perturbations of the five required tallies.

Next steps
- Formalize the chain-based certificate (statement and proof) and add it to proofs.md; keep the K=3 exact theorem and the c-first certificate with sampling.
- Construct a K≥4 instance where adding a third ballot type strictly reduces the required mass relative to the two-type bound.
- Pursue a correct dual-norm bound for the fixed-order LP (retain negative contributions); explore alternative dual test rankings or decompositions by rounds.
- Lower bounds: formalize a Fano/packing family showing Ω((log K)/ε^2) for identifying a favorable opponent y among K−1 possibilities.



=== Current Output ===

Main results on sampling ε-winners under IRV

- Sufficient certificate (all K): Define M_c:=max_{S⊆C, c∈S, |S|≥2} [min_{a∈S\{c}} t_a(S) − t_c(S)]_+. If ε > M_c, adding ε of c-first ballots makes c win. With m = Θ((K + log(1/δ))/ε^2) random ballots, we can uniformly estimate all required tallies and soundly certify any c with high probability.

- Exact characterization for K = 3: For C={a,b,c}, the minimal added mass to make c win is ε^*(c)=min{ε_a^*, ε_b^*}, where for eliminating a first,
  ε_a^* = [p_a−p_b]_+ + max{ [p_a−p_c]_+, [p_a−p_b]_+ + (t_b({b,c})−t_c({b,c})) },
with p_x = t_x({a,b,c}). Symmetrically for ε_b^*. Estimating the five needed tallies to accuracy Θ(ε) with m = Θ((log(1/δ))/ε^2) samples suffices to decide whether ε^*(c) ≤ ε with probability ≥ 1−δ.

- Lower bound: Any algorithm requires m = Ω((1/ε^2) log(1/δ)) samples even for K = 2 (majority).



=== Round 1 Summary ===

This round compared two parallel approaches for certifying that candidate c can be made an IRV winner by adding ≤ε mass: (i) a simple, conservative "c‑first" certificate M_c / f_c based on top-within-S tallies (sufficient only), and (ii) an LP that, for a fixed elimination order, exactly characterizes the minimal added mass. Both provers proved uniform convergence for the top-within-S indicators (union bound over ≤K·2^{K-1} functions) giving a plug-in estimator with additive error control (≤2τ). Sample complexity for the certifier is sound but exponential in K (≈O(K·2^{K-1}/ε^2)). The verifier corrected key issues: the deficit must compare c to other candidates in S (typo), tie-breaking requires strict inequalities or explicit encoding in the LP, and the claimed K=3 exactness (for arbitrary added ballots) is not generally true. Solid lower bound: Ω((log(1/δ))/ε^2) via K=2 holds; K-dependent lower bounds remain conjectural. (Sources: prover-01, prover-02, verifier-feedback.)


=== Round 2 Summary ===

This round resolved the K=3 gaps and clarified the LP sensitivity issue. Prover-02 gave a rigorous two-type reduction (c-first and one opponent-first) with γ-slack that yields an exact closed-form cost for forcing a given first elimination; combined symmetrically this gives the exact minimal added mass to make target c win in K=3. The fixed-π LP was written down with the correct dual; the crude Lemma 2 Lipschitz argument from Prover-01 was rejected by the verifier as incorrect. Instead, sensitivity must be handled via the dual-norm bound |Δv| ≤ (sup_{λ∈Λ} ||λ||_1) ||Δb||_∞, and bounding R_K := sup_{λ∈Λ} ||λ||_1 by poly(K) is left open. As a consequence, the K=3 certifier is tight and sample-efficient (Θ((log(1/δ))/ε^2) samples using five tallies), while the general fixed-π LP approach is sound but its polynomial-sample guarantee depends on the open problem of bounding sup ||λ||_1. Verifier action items: add the rigorous K=3 theorem with γ→0 limits; keep the c-first certificate; record the LP primal/dual and mark the general sensitivity bound open.


=== Round 3 Summary ===

This round formalized sound sampling certificates and exact/sufficient augmentation formulas for IRV ε-winners. Key results: a distribution-free c-first sufficient certificate M_c with uniform-convergence sampling (m = Θ((K + log(1/δ))/ε^2)); an exact K=3 closed-form two-type minimal-augmentation ε^*(c) computable from five tallies with m = Θ((log(1/δ))/ε^2); a sound general-K chain-based two-type certificate (pivot b) depending on O(K) subset tallies; and an LP fixed-order formulation that exactly characterizes minimal augmentation but whose dual-sensitivity constant R_K (sup ||λ||_1) is open, blocking a proven polynomial-in-K sample bound. The universal lower bound Ω((1/ε^2) log(1/δ)) holds. Citations: notes (round), proofs.md, output.md.


=== Previous Round Feedback ===

Overall: Good progress on sound sufficient conditions and K=3 exactness, but two major issues surfaced: (i) a flawed general-K “two-type” reduction that only looks at first-round shares, and (ii) incorrect dual-norm bounds for the fixed-order LP. We can safely advance by recording the K=3 exact formula and a sound general-K chain-based two-type certificate; the dual sensitivity bound remains open.

Prover 1: Your general-K two-type theorem is unsound. You replace all round-j tallies t_w(S) by first-round shares p_w, concluding that nonfinal candidates are eliminated in ascending order of p_w. In IRV, t_w(S) can be much larger than p_w after transfers. Minimal counterexample (K=4): Take p = (p_a, p_b, p_c, p_y) = (0.26, 0.26, 0.23, 0.25). Suppose after eliminating a, the round-2 tallies on S={b,c,y} are (t_b(S), t_c(S), t_y(S)) = (0.40, 0.25, 0.35). Your bounds give A* = max_w(p_w − p_c)_+ = 0.03 and B* = max_w(p_w − p_y)_+ = 0.01, but they do not ensure c and y beat b in S since b’s tally is 0.40. Any proof must use t_w(S) for the actual S, not just p_w.

Prover 2 and 3: The dual 1-norm bounds (≤K and ≤K−1) are incorrect. In the dual constraint for the ranking r_x that places x first, there is a negative term at j = pos_π(x): −∑_{a∈S_j\{x}} λ_{j,a}. Dropping this term yields ∑_{j<pos(x)} λ_{j,x} ≤ 1, from which summing over x wrongly gives ||λ||_1 ≤ K (or K−1). Including the negative term, the sum over x cancels and yields 0 ≤ K, providing no bound. Hence the claimed Lipschitz sensitivity constants do not follow. Also, the K=3 Lipschitz constant L=3 asserted by Prover 3 is too small: A, B, D each have sup-norm Lipschitz constant 2, so a safe bound is L ≤ 6.

Prover 4: Your chain-based two-type certificate is sound and aligns with IRV mechanics: fix b, follow the baseline minimal-of-others chain e_1,…,e_{K−2} (with the election’s tie-breaking), and require α ≥ max_j[t_{e_j}(S_j) − t_c(S_j) + γ]_+ and β ≥ max_j[t_{e_j}(S_j) − t_b(S_j) + γ]_+, plus α − β ≥ t_b({b,c}) − t_c({b,c}) + γ. This ensures elimination along that chain and a strict c-over-b final; the optimal two-type mass is B + max{A, B + D}. Minor fix: when stating dominance, note that rankings with top_{S_j} = e_j harm constraints and are excluded at optimum, but they do not contribute zero.

Next steps:
- Formalize and add the chain-based two-type certificate (general K) and the K=3 exact formula to proofs.md; keep the c-first certificate and its sampling guarantee.
- Attempt a separation example for K≥4 where two-type is suboptimal (requires a third type).
- Revisit the LP dual bound with the negative terms intact; explore alternative dual test rankings or structural decompositions to bound sup||λ||_1.
- Lower bounds: formalize a Fano/packing instance yielding Ω((log K)/ε^2) for any certificate that must identify a favorable opponent among K−1.
