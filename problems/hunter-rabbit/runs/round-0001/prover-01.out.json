{
  "content": "Ideas\n- Formalize the forward dynamics. If P_i is the set of all possible rabbit positions just before round i, and hunters shoot S_i (|S_i|\u2264k) at round i, then the survivors move to neighbors and we get\n  P_{i+1} = N(P_i \\ S_i).\n  A length-n schedule S_1,\u2026,S_n is winning iff P_{n+1}=\u2205 starting from P_1=V(G).\n- Treating the evasion number h(G) as the minimum k for which there is some finite winning schedule (equivalently: there exists a schedule that makes P_t=\u2205 at some t; this then solves all horizons by truncation).\n- Two immediate bounds that can be checked and used algorithmically:\n  1) Lower bound: h(G) \u2265 \u03c9(G)\u22121 (\u03c9 = clique number). Proof: with k \u2264 \u03c9\u22122 shooters and an \u03c9-clique, at each round \u22652 clique-vertices remain unshot; the rabbit can stay within the clique and at each step choose a neighbor unshot next round.\n  2) Upper bound: h(G) \u2264 \u03c4(G) (minimum vertex cover). Proof: let S be a vertex cover. Play S at round 1 and again at round 2. Then P_2 = N(V\\S) \u2286 S (since V\\S is independent), so P_2 \u2286 S and shooting S again yields P_3=\u2205.\n- Exact values on basic families (to calibrate):\n  \u2022 Cliques: h(K_r)=r\u22121 (LB=\u03c9\u22121, UB=\u03c4=r\u22121 match).\n  \u2022 Cycles: h(C_n)=2 (n\u22653). One shooter never wins on a cycle because from any vertex there are two neighbors; at step i+1 the rabbit can always move to the neighbor that is not s_{i+1}. Two shooters win by playing two antipodal vertices every round: from any position the rabbit\u2019s unique move next round enters the shot set.\n  \u2022 Paths: h(P_n)=1 (n\u22652). We verified explicitly for n=3,4 by writing a short schedule; a general \u201c1-shooter sweep\u201d exists (induction on n; see Next steps for a proof plan). This already shows h can be strictly smaller than \u03c4 and smaller than pathwidth+1.\n\nExamples (toy computations via P_{i+1}=N(P_i\\S_i))\n- P4 with order 1\u20132\u20133\u20134 and k=1: a winning 6-step schedule is S=(3,2,4,1,2,3). Forward sets: P1={1,2,3,4}, P2={1,2,3}, P3={2,4}, P4={1,3}, P5={2,4}, P6={3}, P7=\u2205.\n- C5 with k=2: S1={1,3} \u21d2 P2={1,3,4,5}; S2={4,5} \u21d2 P3={2,4}; S3={2,4} \u21d2 P4=\u2205.\n\nObstacles / what fails\n- Attempting to equate h(G) with pathwidth or treewidth runs into counterexamples immediately: for trees (pathwidth=1) we have h=1 (consistent), for cycles (pathwidth=2) we have h=2 (consistent), but for many graphs h < pathwidth+1 (e.g., C5: pw=2 but h=2<3; paths: pw=1 yet often h=1<<2 upper bound from bags). The direct \u201cboundary-of-ordering\u201d schedule proof does not mesh with the exact timing P_{i+1}=N(P_i\\S_i). So equality with pathwidth/treewidth remains unproven and likely false as an identity.\n- A naive state-search on subsets P_i is exponential (2^n states). We need structure to get n^{O(k)}.\n\nCheckable lemmas (to move to proofs.md)\n- Lemma 1 (Dynamics): A schedule S_1,\u2026,S_n is winning iff the forward recursion P_{i+1}=N(P_i\\S_i), P_1=V, yields P_{n+1}=\u2205.\n- Lemma 2 (Clique LB): h(G) \u2265 \u03c9(G)\u22121. Proof sketch above.\n- Lemma 3 (Vertex-cover UB): h(G) \u2264 \u03c4(G). Proof sketch above. Corollary: h is FPT-approximable from above by k=\u03c4 (and test \u03c4\u2264k in n^{O(k)} time via standard VC-FPT).\n- Lemma 4 (Cycles need 2): h(C_n)=2 for n\u22653. Proof: k=1 fails as argued; k=2 wins by fixing two opposite vertices each round.\n- Lemma 5 (Paths need only 1): h(P_n)=1 for all n\u22652. Constructive schedules exist; see P4 example. A clean general inductive \u201cleaf-sweep\u201d proof is plausible: under P_{i+1}=N(P_i\\{v}), playing a leaf in a suitable back-and-forth traversal shrinks the possible-interval on the path until a singleton is reached; then one more shot empties P.\n\nAlgorithmic consequences so far\n- Quick FPT certificates for NO/YES in many cases:\n  \u2022 If \u03c9(G) \u2265 k+2 we can immediately answer NO (h(G) > k). Decidable in O(n^{k+2}).\n  \u2022 If \u03c4(G) \u2264 k we can immediately answer YES (h(G) \u2264 k) and even output a 2-round winning schedule S,S.\n- These two tests run in n^{O(k)} and already recognize a large fraction of instances.\n- On chordal graphs, h(G)=\u03c9(G)\u22121 holds (conjectured; consistent with all examples), hence recognition reduces to \u03c9\u2264k+1 which is n^{O(k)}. This gives a concrete, verifiable target class.\n\nNext steps (towards n^{O(k)} in general)\n1) Prove h(T)=1 for all trees T. Formalize the interval-shrinking invariant for paths and generalize via centroid/leaf pruning to trees. This will supply a nontrivial exact computation on a broad class and a critical structural insight (forests vs cycles for k=1), with a poly-time recognizer for k=1 (acyclic \u21d4 YES).\n2) Seek a tighter combinatorial characterization of h in terms of standard parameters. We already have \u03c9\u22121 \u2264 h \u2264 \u03c4. Check whether h \u2264 tw and/or h \u2264 pw holds in general, and whether h is sandwiched between tw and \u03c9\u22121 on more classes (chordal, series-parallel, outerplanar). If h \u2264 tw, then treewidth \u2264 k would imply a winning schedule with k shooters; since tw\u2264k is testable in linear time for fixed k, this would answer the main question positively.\n3) DP on small separators: Although arbitrary P-states blow up, an optimal step tends to use S_i that is a vertex cover of G[P_i] (making P_{i+1} \u2286 N(P_i\\S_i) as small as possible). Explore a DP whose states are (H,S) where H is an induced subgraph determined by a small separator S (|S|\u2264k), and that simulates P-evolution across S using only the cut-structure. A plausible outcome is an n^{O(k)}-time recognition.\n4) Verify and then elevate: h(C_n)=2; h(K_r)=r\u22121; h on block graphs equals \u03c9\u22121; h on cactus graphs is max over blocks; these are checkable and give more exact cases.\n\nSummary answer (current status)\n- We can already recognize many YES/NO cases in n^{O(k)} time via the sandwich \u03c9\u22121 \u2264 h \u2264 \u03c4; in particular, \u03c4(G)\u2264k implies YES and \u03c9(G)\u2265k+2 implies NO.\n- For k=1, strong evidence suggests a complete polynomial characterization (forests) is within reach; we supply an explicit winning schedule on paths and a general cycle-based obstruction.\n- Establishing an n^{O(k)} algorithm in full generality likely hinges on relating h to standard width parameters (treewidth/pathwidth) or on a separator-based DP; both are realistic next steps. Pending a precise equivalence, the \u201cYes, via treewidth\u201d path remains an attractive route: proving h \u2264 tw would immediately yield polynomial recognition for each fixed k."
}