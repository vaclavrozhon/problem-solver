{
  "content": "Ideas\n\n- Formalize the game as a \u201ctime-expanded\u201d hitting problem on a layered DAG. This gives an NP certificate and a dynamic-programming verifier.\n- Extract easy but useful bounds: a general upper bound via vertex cover; a general lower bound via complete bipartite subgraphs; exact values for K_n and K_{p,q}.\n- Give a clean state-evolution identity Q_{i+1} = N(Q_i) \\ S_{i+1} (where Q_i are the possible rabbit positions at time i), which is both necessary and sufficient for correctness of a schedule. This gives a concise target for future dynamic-programming or hardness proofs.\n- Work out small examples (paths, stars) to calibrate intuition and to disprove over-optimistic claims about k=1.\n- Provide a necessary obstruction detectable in n^{O(k)} time: the presence of K_{k+1,k+1} as a subgraph implies h(G) \u2265 k+1. This gives a quick rejection test for h(G) \u2264 k.\n\nRigorous statements and proofs\n\nNotation. For a (simple) graph G=(V,E), let N(X) := {v \u2208 V : \u2203 x\u2208X with vx\u2208E} denote the (open) neighborhood of X.\n\nLemma 1 (Layered-DAG formulation and verifier). Fix k. A schedule S = (S_1,\u2026,S_n) with |S_i| \u2264 k is winning iff the layered directed acyclic graph H with layers L_1,\u2026,L_n (each a copy of V), and arcs (u,i)\u2192(v,i+1) whenever uv \u2208 E, contains no L_1\u2013L_n path avoiding the set C := \u22c3_{i=1}^n (S_i \u00d7{i}). Equivalently, if we define Q_1 := V \\ S_1 and for i\u22651,\n- Q_{i+1} := N(Q_i) \\ S_{i+1},\nthen S is winning iff Q_t = \u2205 for some t \u2264 n. Moreover, given S, this can be checked in O(nm) time.\n\nProof. A length-n rabbit walk v_1,\u2026,v_n maps to a path (v_1,1)\u2192\u2026\u2192(v_n,n) in H and is uncaught iff v_i \u2209 S_i for all i; i.e., the path avoids C. Dynamic programming on H detects such a path in O(nm) time by propagating reachable sets: R_1 := V\\S_1; R_{i+1} := (neighbors of R_i) \\ S_{i+1}. This equals the stated Q_{i+1}.\n\nLemma 2 (Monotonicity under subgraphs). If H is a subgraph of G, then h(H) \u2264 h(G).\n\nProof. Any rabbit walk in H is also a rabbit walk in G. If k hunters win on G with schedule S, the same S wins on H.\n\nProposition 3 (Upper bound via vertex cover). Let \u03c4(G) be the size of a minimum vertex cover. Then h(G) \u2264 \u03c4(G).\n\nProof. Fix a minimum vertex cover C. Use S_1 = C and S_2 = C (and arbitrary afterwards). If the rabbit starts in C, it is caught at time 1. Otherwise it starts in V\\C and must move into C at time 2, where it is caught.\n\nProposition 4 (Lower bound via complete bipartite subgraphs). If G contains K_{s,t} as a (not necessarily induced) subgraph, then h(G) \u2265 min{s,t}.\n\nProof. The rabbit can confine itself to the K_{s,t}. At each step it is on one side and must move to the other side. With fewer than min{s,t} hunters, the hunters cannot shoot all vertices on the destination side at that time step; the rabbit always moves to a non-shot neighbor. Hence no schedule of size < min{s,t} can be winning.\n\nCorollary 5 (Exact value on complete bipartite graphs). For G = K_{p,q}, h(G) = min{p,q}.\n\nProof. Lower bound is Proposition 4. Upper bound: shoot the smaller side at every step; the rabbit is caught by time 1 or 2.\n\nProposition 6 (Complete graphs). For G = K_n, h(K_n) = n.\n\nProof. If k < n, at each time the rabbit picks any vertex outside S_i; since all vertices are mutually adjacent, this can be maintained for all steps, so no schedule of size < n can win. With k = n, shoot all vertices at time 1.\n\nConsequences and quick tests\n\n- Necessary obstruction. If G contains K_{k+1,k+1} as a subgraph, then h(G) \u2265 k+1 (Proposition 4). Thus h(G) \u2264 k implies G is K_{k+1,k+1}-free. Detecting a K_{k+1,k+1} subgraph is doable in n^{O(k)} time (e.g., brute force over (k+1)-tuples on each side), giving a quick rejection test consistent with the requested n^{O(k)} regime.\n- Coarse upper bound. h(G) \u2264 \u03c4(G). This is often loose (e.g. paths), but is tight on K_{p,q} and K_n.\n\nExamples and small cases\n\n- Stars K_{1,m}. Here h(K_{1,m}) = 1. Upper bound by \u03c4=1; lower bound by K_{1,m}.\n- Paths P_n. For n \u2265 4, one hunter does not suffice (e.g., P_4 with S = (2,3,2,3) fails; a surviving walk is 3,2,3,4). Two hunters suffice for all n \u2265 2 by taking S_i to be the two middle vertices at every step: any rabbit at a leaf must step into one of these in at most 2 steps.\n- Cycles. C_3 = K_3 has h=3. C_4 = K_{2,2} has h=2. For odd cycles \u2265 5, the exact value needs careful analysis; the \u03c4 upper bound gives h(C_{2r+1}) \u2264 r+1.\n\nObstacles and failure modes\n\n- Non-adaptivity matters. The operator Q_{i+1} = N(Q_i) \\ S_{i+1} is not monotone decreasing in general because of the neighborhood expansion; this prevents a straightforward DP over subsets Q_i.\n- Hitting all length-n walks with per-layer budgets is a \u201cgrouped hitting set\u201d in a layered DAG. While verification is polynomial (Lemma 1), the existence of a schedule seems to encode a nontrivial covering problem. A naive search over schedules is exponential in n, and a naive DP over states Q_i is exponential in |V|.\n- The natural backward DP: define F_1 = {X \u2286 V : |N(X)| \u2264 k} and iteratively F_{j+1} = {X : \u2203Y\u2208F_j with Y \u2286 N(X) and |N(X) \\ Y| \u2264 k}. Then h(G) \u2264 k iff V \u2208 F_t for some t \u2264 n and additionally |V \\ Q_1| \u2264 k. Although exact, F_j can be exponentially large in general.\n\nNext steps (concrete, testable)\n\n1) Hardness for fixed k. Try to reduce from a canonical NP-hard problem to the special case k=1 (or k=2) of the \u201clayered per-layer-bounded cut\u201d in the time-expanded graph H. A promising target is to encode a SAT instance by variable gadgets arranged along layers, so that choosing one vertex per layer to delete blocks all length-n paths iff the formula is unsatisfiable. Establishing NP-completeness for k=1 would give a negative answer to the question; establishing W[1]-hardness parameterized by k via gadgets that force K_{k,k} choices would argue against n^{f(k)} algorithms.\n\n2) FPT on structural parameters. The Q_{i+1} operator only depends on adjacency; graphs of bounded treewidth or bounded neighborhood diversity may admit polynomial-time algorithms for fixed k via type-compression. Concretely, on graphs of neighborhood diversity d, attempt a DP over layer-indexed type-subsets Y_i \u2286 [d], with branching bounded by O(d^k) per layer and an automaton of size O(d). This should be implementable and checkable.\n\n3) Tighten bounds. The general bounds h(G) \u2265 max_{K_{s,t}\u2286G} min{s,t} and h(G) \u2264 \u03c4(G) are crude. Investigate improved lower bounds via vertex expansion: if |N(X)| \u2265 k+1 for all nonempty X \u2286 V, then the last-step emptiness is impossible, so h(G) \u2265 k+1. Formalize this and test on expanders.\n\n4) Exact values on basic families. Complete a systematic study of h on:\n- paths P_n (prove h(P_n)=2 for n\u22654); trees of bounded degree (bounds in terms of leaves or height);\n- cycles C_n (determine h(C_n) for all n);\n- grids and hypercubes (use K_{s,t} obstructions vs \u03c4 upper bounds).\n\n5) ILP-with-separation approach. Formulate the decision as 0\u20131 variables x_{i,v} with constraints |{v: x_{i,v}=1}| \u2264 k and requiring that every length-n walk has some i with x_{i,v_i}=1. The separation oracle is exactly the DP of Lemma 1. Even if the ILP is hard, this may yield exact algorithms for small n and heuristics; if integrality gaps are small on some classes, it could lead to polynomial-time recognition there.\n\nSummary\n\n- The decision problem \u201ch(G) \u2264 k?\u201d is in NP with a simple O(nm) verifier (Lemma 1).\n- We proved h(K_n)=n; h(K_{p,q})=min{p,q}; h(G) \u2264 \u03c4(G) and h(G) \u2265 max_{K_{s,t}\u2286G} min{s,t}.\n- There is a necessary, easily checkable obstruction for h(G) \u2264 k: the presence of K_{k+1,k+1} (rejectable in n^{O(k)} time).\n- For small families (stars, small paths), we computed h exactly; notably, one hunter already fails on P_4.\n- The central recursion Q_{i+1} = N(Q_i) \\ S_{i+1} precisely characterizes schedules and is a natural pivot for both algorithmic (type-compression DP) and hardness (layered cut) directions.\n\nThese provide multiple auditable avenues: immediate experiments on cycles/trees; implementing the type-compression DP on bounded neighborhood diversity graphs; and attempting a k=1 hardness reduction via layered gadgets in H."
}