Ideas

- Formalize the game as a “time-expanded” hitting problem on a layered DAG. This gives an NP certificate and a dynamic-programming verifier.
- Extract easy but useful bounds: a general upper bound via vertex cover; a general lower bound via complete bipartite subgraphs; exact values for K_n and K_{p,q}.
- Give a clean state-evolution identity Q_{i+1} = N(Q_i) \ S_{i+1} (where Q_i are the possible rabbit positions at time i), which is both necessary and sufficient for correctness of a schedule. This gives a concise target for future dynamic-programming or hardness proofs.
- Work out small examples (paths, stars) to calibrate intuition and to disprove over-optimistic claims about k=1.
- Provide a necessary obstruction detectable in n^{O(k)} time: the presence of K_{k+1,k+1} as a subgraph implies h(G) ≥ k+1. This gives a quick rejection test for h(G) ≤ k.

Rigorous statements and proofs

Notation. For a (simple) graph G=(V,E), let N(X) := {v ∈ V : ∃ x∈X with vx∈E} denote the (open) neighborhood of X.

Lemma 1 (Layered-DAG formulation and verifier). Fix k. A schedule S = (S_1,…,S_n) with |S_i| ≤ k is winning iff the layered directed acyclic graph H with layers L_1,…,L_n (each a copy of V), and arcs (u,i)→(v,i+1) whenever uv ∈ E, contains no L_1–L_n path avoiding the set C := ⋃_{i=1}^n (S_i ×{i}). Equivalently, if we define Q_1 := V \ S_1 and for i≥1,
- Q_{i+1} := N(Q_i) \ S_{i+1},
then S is winning iff Q_t = ∅ for some t ≤ n. Moreover, given S, this can be checked in O(nm) time.

Proof. A length-n rabbit walk v_1,…,v_n maps to a path (v_1,1)→…→(v_n,n) in H and is uncaught iff v_i ∉ S_i for all i; i.e., the path avoids C. Dynamic programming on H detects such a path in O(nm) time by propagating reachable sets: R_1 := V\S_1; R_{i+1} := (neighbors of R_i) \ S_{i+1}. This equals the stated Q_{i+1}.

Lemma 2 (Monotonicity under subgraphs). If H is a subgraph of G, then h(H) ≤ h(G).

Proof. Any rabbit walk in H is also a rabbit walk in G. If k hunters win on G with schedule S, the same S wins on H.

Proposition 3 (Upper bound via vertex cover). Let τ(G) be the size of a minimum vertex cover. Then h(G) ≤ τ(G).

Proof. Fix a minimum vertex cover C. Use S_1 = C and S_2 = C (and arbitrary afterwards). If the rabbit starts in C, it is caught at time 1. Otherwise it starts in V\C and must move into C at time 2, where it is caught.

Proposition 4 (Lower bound via complete bipartite subgraphs). If G contains K_{s,t} as a (not necessarily induced) subgraph, then h(G) ≥ min{s,t}.

Proof. The rabbit can confine itself to the K_{s,t}. At each step it is on one side and must move to the other side. With fewer than min{s,t} hunters, the hunters cannot shoot all vertices on the destination side at that time step; the rabbit always moves to a non-shot neighbor. Hence no schedule of size < min{s,t} can be winning.

Corollary 5 (Exact value on complete bipartite graphs). For G = K_{p,q}, h(G) = min{p,q}.

Proof. Lower bound is Proposition 4. Upper bound: shoot the smaller side at every step; the rabbit is caught by time 1 or 2.

Proposition 6 (Complete graphs). For G = K_n, h(K_n) = n.

Proof. If k < n, at each time the rabbit picks any vertex outside S_i; since all vertices are mutually adjacent, this can be maintained for all steps, so no schedule of size < n can win. With k = n, shoot all vertices at time 1.

Consequences and quick tests

- Necessary obstruction. If G contains K_{k+1,k+1} as a subgraph, then h(G) ≥ k+1 (Proposition 4). Thus h(G) ≤ k implies G is K_{k+1,k+1}-free. Detecting a K_{k+1,k+1} subgraph is doable in n^{O(k)} time (e.g., brute force over (k+1)-tuples on each side), giving a quick rejection test consistent with the requested n^{O(k)} regime.
- Coarse upper bound. h(G) ≤ τ(G). This is often loose (e.g. paths), but is tight on K_{p,q} and K_n.

Examples and small cases

- Stars K_{1,m}. Here h(K_{1,m}) = 1. Upper bound by τ=1; lower bound by K_{1,m}.
- Paths P_n. For n ≥ 4, one hunter does not suffice (e.g., P_4 with S = (2,3,2,3) fails; a surviving walk is 3,2,3,4). Two hunters suffice for all n ≥ 2 by taking S_i to be the two middle vertices at every step: any rabbit at a leaf must step into one of these in at most 2 steps.
- Cycles. C_3 = K_3 has h=3. C_4 = K_{2,2} has h=2. For odd cycles ≥ 5, the exact value needs careful analysis; the τ upper bound gives h(C_{2r+1}) ≤ r+1.

Obstacles and failure modes

- Non-adaptivity matters. The operator Q_{i+1} = N(Q_i) \ S_{i+1} is not monotone decreasing in general because of the neighborhood expansion; this prevents a straightforward DP over subsets Q_i.
- Hitting all length-n walks with per-layer budgets is a “grouped hitting set” in a layered DAG. While verification is polynomial (Lemma 1), the existence of a schedule seems to encode a nontrivial covering problem. A naive search over schedules is exponential in n, and a naive DP over states Q_i is exponential in |V|.
- The natural backward DP: define F_1 = {X ⊆ V : |N(X)| ≤ k} and iteratively F_{j+1} = {X : ∃Y∈F_j with Y ⊆ N(X) and |N(X) \ Y| ≤ k}. Then h(G) ≤ k iff V ∈ F_t for some t ≤ n and additionally |V \ Q_1| ≤ k. Although exact, F_j can be exponentially large in general.

Next steps (concrete, testable)

1) Hardness for fixed k. Try to reduce from a canonical NP-hard problem to the special case k=1 (or k=2) of the “layered per-layer-bounded cut” in the time-expanded graph H. A promising target is to encode a SAT instance by variable gadgets arranged along layers, so that choosing one vertex per layer to delete blocks all length-n paths iff the formula is unsatisfiable. Establishing NP-completeness for k=1 would give a negative answer to the question; establishing W[1]-hardness parameterized by k via gadgets that force K_{k,k} choices would argue against n^{f(k)} algorithms.

2) FPT on structural parameters. The Q_{i+1} operator only depends on adjacency; graphs of bounded treewidth or bounded neighborhood diversity may admit polynomial-time algorithms for fixed k via type-compression. Concretely, on graphs of neighborhood diversity d, attempt a DP over layer-indexed type-subsets Y_i ⊆ [d], with branching bounded by O(d^k) per layer and an automaton of size O(d). This should be implementable and checkable.

3) Tighten bounds. The general bounds h(G) ≥ max_{K_{s,t}⊆G} min{s,t} and h(G) ≤ τ(G) are crude. Investigate improved lower bounds via vertex expansion: if |N(X)| ≥ k+1 for all nonempty X ⊆ V, then the last-step emptiness is impossible, so h(G) ≥ k+1. Formalize this and test on expanders.

4) Exact values on basic families. Complete a systematic study of h on:
- paths P_n (prove h(P_n)=2 for n≥4); trees of bounded degree (bounds in terms of leaves or height);
- cycles C_n (determine h(C_n) for all n);
- grids and hypercubes (use K_{s,t} obstructions vs τ upper bounds).

5) ILP-with-separation approach. Formulate the decision as 0–1 variables x_{i,v} with constraints |{v: x_{i,v}=1}| ≤ k and requiring that every length-n walk has some i with x_{i,v_i}=1. The separation oracle is exactly the DP of Lemma 1. Even if the ILP is hard, this may yield exact algorithms for small n and heuristics; if integrality gaps are small on some classes, it could lead to polynomial-time recognition there.

Summary

- The decision problem “h(G) ≤ k?” is in NP with a simple O(nm) verifier (Lemma 1).
- We proved h(K_n)=n; h(K_{p,q})=min{p,q}; h(G) ≤ τ(G) and h(G) ≥ max_{K_{s,t}⊆G} min{s,t}.
- There is a necessary, easily checkable obstruction for h(G) ≤ k: the presence of K_{k+1,k+1} (rejectable in n^{O(k)} time).
- For small families (stars, small paths), we computed h exactly; notably, one hunter already fails on P_4.
- The central recursion Q_{i+1} = N(Q_i) \ S_{i+1} precisely characterizes schedules and is a natural pivot for both algorithmic (type-compression DP) and hardness (layered cut) directions.

These provide multiple auditable avenues: immediate experiments on cycles/trees; implementing the type-compression DP on bounded neighborhood diversity graphs; and attempting a k=1 hardness reduction via layered gadgets in H.