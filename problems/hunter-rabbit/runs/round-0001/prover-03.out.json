{
  "content": "Ideas\n- Recast the game as a deterministic \u201cpossible positions\u201d evolution. For a fixed sequence of shots S1,\u2026,Sn (Si\u2286V, |Si|\u2264k), define P1:=V\\S1 and, for i\u22651,\n  Pi+1 := N(Pi) \\ Si+1, where N(X):=\u22c3_{x\u2208X} N(x). A schedule is winning iff Pn=\u2205. Thus deciding h(G)\u2264k is equivalent to the existence of some length-n sequence of size-k shots driving this recurrence to \u2205.\n- This yields a state graph on 2^V with transitions X \u2192 Y iff Y\u2286N(X) and |N(X)\\Y|\u2264k. We want \u2203 path from V to \u2205. Two immediate properties:\n  (i) Monotonicity: If X\u2286X\u2032 then Pi(X)\u2286Pi(X\u2032) for any fixed schedule S. In particular, the family Good_k of sets X from which the hunters can force \u2205 is downward-closed.\n  (ii) End condition: If |N(X)|\u2264k then one more step can make the next state empty by taking S=N(X).\n\nBasic bounds (easy, rigorous)\n- Lower bound: h(G) \u2265 \u03c9(G) (clique number). Indeed, if k<\u03c9(G), the rabbit can restrict to a K_{\u03c9(G)} and move inside it (complete adjacency), always finding an unshot neighbor.\n- Upper bound: h(G) \u2264 \u03c4(G) (vertex cover number). Strategy: Fix a minimum vertex cover D, |D|=\u03c4. Shoot S_i:=D for all i. Any walk enters D in at most one step (since V\\D is independent), hence capture occurs by time 2.\n- Consequences: For K_n, h(K_n)=n\u22121 (both bounds give n\u22121). For C_m with m\u22654, 2\u2264h(C_m)\u2264\u03c4(C_m)=\u230am/2\u230b, and in fact h(C_m)=2 (explicit schedules exist; see examples below). For paths P_n, h(P_n)=1.\n\nExact classification for k=1\nTheorem. h(G)=1 iff G is a forest.\n\nProof.\n(\u21d2) If G contains a cycle C, then no 1-hunter schedule wins. Let S1,\u2026,Sn be any sequence of single vertices. Define P1=V\\{S1}. We claim inductively that for each i, Pi\u2229V(C)=V(C)\\{Si\u2229V(C)}. Indeed, if Pi contains all cycle vertices except possibly one, then every vertex of C has a neighbor in Pi (a cycle is 2-regular), hence V(C)\u2286N(Pi) and so Pi+1\u2229V(C)=V(C)\\{Si+1\u2229V(C)}. Thus Pi never empties. So h(G)>1.\n(\u21d0) Suppose G is a forest. We use the \u201cdouble-hit support\u201d rule: For any current state P (induced forest), and any vertex u adjacent to at least one leaf of the induced forest G[P], two consecutive shots at u transform P to P\u2032:=P \\ ( {u} \u222a Leaves_{G[P]}(u) ). This follows from the identity P\u2032 = N( N(P)\\{u} )\\{u} and the fact that a vertex x\u2208P is removed iff all its neighbors in G[P] lie in {u}. Starting from P0=V, repeatedly pick any vertex u adjacent to a leaf of the current induced forest and shoot u twice; each such pair strictly decreases |P|. The forest becomes empty after finitely many iterations. Therefore h(G)=1. \u220e\n\nWorked examples (small families)\n- P_n: h(P_n)=1 by the forest theorem. E.g., on P_5, shots 2,2,4,4 suffice (two pairs pruning neighbors of 2 then 4).\n- C_m (m\u22654): h(C_m)=2. One explicit pattern for C_5: shoot {1,3},{1,3},{1,4},{1,4},{3,5} to drive P to \u2205 (short variants exist). For C_4: {1,3},{1,3} already wins.\n- K_n: h(K_n)=n\u22121. With k=n\u22121, shoot the (n\u22121)-set D every round; the unique unshot vertex u cannot be used twice consecutively, so the rabbit enters D at step 2 and is captured. For k\u2264n\u22122, the rabbit alternates within the \u22652 unshot vertices.\n\nAlgorithmic corollaries (provable now)\n- Recognizing h(G)=1 is linear-time: G is a forest iff acyclic; by the theorem.\n- Quick filters for general k:\n  \u2022 If \u03c9(G)>k then h(G)>k (reject).\n  \u2022 If \u03c4(G)\u2264k then h(G)\u2264k (accept). Both \u03c9 and \u03c4 are poly-time computable (\u03c4 via bipartite reduction is only for bipartite graphs; in general \u03c4 is NP-hard to compute exactly but has good approximations; nevertheless \u03c4\u2264k is a sufficient, not necessary, certificate for h\u2264k).\n\nState-graph formulation (for experimentation and small n)\n- Exact decision h(G)\u2264k is equivalent to reachability from V to \u2205 in the state graph whose vertices are subsets X\u2286V and with edges X\u2192Y whenever Y\u2286N(X) and |N(X)\\Y|\u2264k. Out-degree per state is \u03a3_{i=0}^k C(|N(X)|,i)=n^{O(k)}. This is immediately implementable and yields an exact solver for graphs up to moderate size, suitable for generating data and conjectures (e.g., all minimal obstructions for k=2 up to, say, 10 vertices).\n\nWhy the general recognition is nontrivial\n- The state space is 2^n in the worst case; although the per-state branching is n^{O(k)}, a priori the number of reachable states may still be exponential. A generic n^{O(k)} bound thus requires a structural argument bounding (for winning instances) the length of any successful chain and/or the number of distinct reachable states by n^{O(k)}. We currently lack such a bound.\n- The view \u201clayered temporal cut with per-layer budget k\u201d (choose at most k vertices per time layer to hit all layer-respecting walks) suggests hardness: cut problems with partition matroid constraints are typically NP-hard. Our game is a very special such cut (the layer graph is repeatedly the same base graph), so a careful reduction might show NP-hardness already for k=2. This remains to be established.\n\nObstacles\n- Bounding the number of relevant states for general graphs (beyond forests) under the transition Y\u2286N(X), |N(X)\\Y|\u2264k is the main barrier to a general n^{O(k)} algorithm.\n- Simple parameters (treewidth/pathwidth) do not immediately characterize h: e.g., pw(C_5)=2 but h(C_5)=2<\u03c4(C_5)=3; K_3 has pw 2 but h=2; paths have pw 1 but h=1. We do have \u03c9(G)\u2264h(G)\u2264\u03c4(G), but \u03c4 can be much larger than h.\n\nNext steps (concrete, testable)\n1) k=2 classification for sparse families.\n   - Compute h on all graphs up to 10 vertices via the state-graph DP to enumerate minimal obstructions for h\u22642. Expect K_3 as one obstruction; look for others (e.g., K_{2,3}? ladders? small grids?).\n2) Prove that 1-hunter fails on any graph containing a cycle (done) and extend to: if G contains an induced subgraph H with \u03b4(H)\u22652, then h(G)\u22652 (trivial from the 1-hunter impossibility). Seek analogous necessary conditions for h\u22653.\n3) FPT on bounded treewidth: Formulate a DP over a tree decomposition that carries as state the set of \u201cpossible positions\u201d restricted to the bag and k-shot history to propagate the P-recursion. This should yield an algorithm deciding h(G)\u2264k in time f(k,tw)\u00b7n, and is a good intermediate milestone.\n4) Hardness for constant k\u22652: Attempt a reduction from SAT/Vertex Separation/Temporal Cut to our reachability with per-layer budget on a fixed base graph, by encoding time layers via gadgets that reuse vertices. If successful, this would imply that, for some constant k, recognizing h(G)\u2264k is NP-hard, answering the original question in the negative.\n\nSummary of main rigorously proven contributions here\n- Exact characterization for k=1: h(G)=1 iff G is a forest, with a constructive schedule (double-shot supports) and a simple impossibility proof for cycles.\n- General bounds: \u03c9(G) \u2264 h(G) \u2264 \u03c4(G).\n- State-graph equivalence suitable for exact computation on small instances and for generating data for k=2.\n- Concrete plan to attack k=2 (both empirically and structurally) and to pursue either an n^{O(k)} algorithm (via structural bounds/DP over decompositions) or hardness (via tailored reductions)."
}