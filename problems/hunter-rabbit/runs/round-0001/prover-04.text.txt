# Ideas

- Reformulate the game as a deterministic recurrence on sets of possible rabbit positions. This produces a crisp necessary-and-sufficient condition for a schedule to be winning and is easy to check for any fixed schedule. It also reframes the recognition problem as the existence of a layer-wise hitting set in a time-expanded graph, a structure amenable to min–max reasoning and LP-duality heuristics.
- Extract general lower bounds (minimum degree, degeneracy), monotonicity under subgraphs, and compute the evasion number exactly on key families (complete graphs, complete bipartite graphs, cycles). These give nontrivial certificates and guide what an XP algorithm must handle.
- Conjecture: the evasion number equals the degeneracy. This matches all examples we can prove and offers an immediate linear-time recognition if true. Outline of a proof strategy is given. This is a testable claim for the verifier via brute force on small graphs.

# Formal reformulation (rigorous)

Let G = (V,E) be a simple undirected graph on n = |V| ≥ 1. For a schedule s = (s_1, …, s_n) with s_i ⊆ V, |s_i| = k, define
- R_1 := V \ s_1,
- R_{i+1} := N(R_i) \ s_{i+1} for i = 1, …, n-1.

Proposition 1 (equivalence). The schedule s is winning (i.e., for every walk v_1,…,v_n with v_{i+1} ∼ v_i there exists i with v_i ∈ s_i) if and only if R_n = ∅.

Proof. Induct on i that R_i is exactly the set of vertices v such that there exists a length-i walk v_1,…,v_i with v_j ∉ s_j for all j. For i=1 this is R_1 = V \ s_1. If the claim holds for i, then v ∈ R_{i+1} iff v ∈ N(R_i) and v ∉ s_{i+1}, i.e., there exists u ∈ R_i with u ∼ v and v ∉ s_{i+1}; by IH, this is equivalent to the existence of a walk of length i+1 avoiding shots up to time i+1. Thus R_n = ∅ iff no length-n avoiding walk exists, i.e., s is winning. ∎

Interpretation: Given s, the evader’s possible positions at time i are R_i; capture by time n is equivalent to R_n = ∅.

# General bounds and monotonicity (rigorous)

Lemma 2 (minimum-degree lower bound). If k < δ(G), then no schedule with k hunters is winning.

Proof. Let δ := δ(G). Fix any schedule s. Choose v_1 ∈ V \ s_1. Suppose v_i chosen with v_i ∉ s_i. Since deg(v_i) ≥ δ > k, at most k neighbors are in s_{i+1}, hence there exists v_{i+1} ∈ N(v_i) \ s_{i+1}. This constructs an avoiding walk of any prescribed length, contradicting winning. ∎

Corollary 3 (subgraph monotonicity). If H ⊆ G is a subgraph then e(H) ≤ e(G).

Proof. Any schedule that is winning on G is also winning against walks confined to H. ∎

Corollary 4 (degeneracy lower bound). If d(G) denotes the degeneracy of G (maximum minimum degree over all subgraphs), then e(G) ≥ d(G).

Proof. By definition there is a subgraph H with δ(H) = d(G); apply Lemma 2 and Corollary 3. ∎

# Exact values for key families (rigorous)

Theorem 5 (complete graphs). e(K_n) = n − 1.

Proof. Lower bound: δ(K_n) = n − 1, so e(K_n) ≥ n − 1 by Lemma 2. Upper bound: with k = n − 1, take s_i = V \ {x} for a fixed x and all i. Then R_1 = {x}, R_2 = N({x}) \ s_2 = (V \ {x}) \ (V \ {x}) = ∅. ∎

Theorem 6 (complete bipartite). For K_{a,b} with a ≤ b, e(K_{a,b}) = a.

Proof. Lower bound: δ = a. Upper bound: take s_i = A (the size-a side) for all i. Then R_1 = B, R_2 = N(B) \ A = A \ A = ∅. ∎

Theorem 7 (cycles). For m ≥ 3, e(C_m) = 2.

Proof. Lower bound: δ(C_m) = 2. Upper bound: let u,v be antipodal if m even (or any two nonadjacent vertices if m odd). Take s_i = {u,v} for all i. Then R_1 = V \ {u,v}. In a cycle, N(V \ {u,v}) = {u,v}, so R_2 = {u,v} \ {u,v} = ∅. ∎

Example 8 (paths). On P_4 with vertices 1–2–3–4, k=1 suffices; e(P_4)=1. For instance s=(1,3,2,3) yields
- R_1={2,3,4},
- R_2=N(R_1)\{3}={1,2,4},
- R_3=N(R_2)\{2}={4},
- R_4=N({4})\{3}=∅.

# Layered-graph (time expansion) viewpoint

Let H be the layered DAG with vertex set V×{1,…,n} and edges (u,i)→(v,i+1) iff uv∈E(G). A schedule s with k picks defines S = ⋃_i (s_i×{i}). Proposition 1 is equivalent to: s is winning iff S intersects every layer-respecting (layer-1 to layer-n) path in H. Thus e(G) is the minimum k such that there exists a per-layer hitting set S with |S∩(V×{i})| ≤ k intersecting all such paths. This is a “layer-budget path hitting” problem.

Simple packing obstructions: if H contains k+1 vertex-disjoint layer-respecting paths, then clearly no S with per-layer budget k can hit them all (every layer would need ≥k+1 shots). The converse is false in general (because leaving ≤k vertices per layer does not guarantee a surviving path unless the surviving vertices align into a walk). Still, this provides a polynomial-time (max-flow) certificate that e(G) > k whenever such a packing exists.

# Conjecture and consequences

Conjecture 9. e(G) = d(G) (degeneracy) for all finite graphs G.

Evidence:
- K_n: e = n−1 = d.
- K_{a,b}: e = min(a,b) = d.
- Cycles C_m: e = 2 = d.
- Forests: d = 1; consistent with all tested small trees (paths, stars, small caterpillars) where k=1 schedules exist (Example 8). A systematic proof for all forests remains open here.

If Conjecture 9 holds, then recognition for fixed k is linear-time: compute d(G) (via standard peeling) and check d(G)=k. Even without equality, Corollary 4 provides a fast NO-certificate: if d(G)>k then e(G)>k.

# Obstacles / why naive approaches fail

- Pure packing (Menger) is insufficient: e.g., K_n has n vertex-disjoint layer paths in the time-expanded graph, yet k=n−1 shots per layer suffice by choosing the same n−1 vertices every round to force an impossible “stay put” at the unique survivor.
- Greedy minimization of |R_i| at each step need not be globally optimal (the identity of which k vertices are removed affects future neighborhoods). The state space of R_i is exponential.

# Toward algorithms for fixed k

- Layered cut with per-layer budgets: For fixed k, one can work in H and ask if there exists S of size ≤k per layer hitting all L1–Ln paths. This is a hitting set with special structure. Even though a direct min–max characterization is unclear, the following are tractable checks:
  - NO-certificate: find k+1 vertex-disjoint layer paths (max-flow in H) – immediate.
  - YES-heuristic: attempt to build S layer-by-layer using minimum vertex cuts between layer 1 and layer i with the extra constraint that we use ≤k per layer. This suggests an LP with exponentially many path constraints; separation reduces to shortest path in H with vertex weights. Investigate integrality for this very special layered case.
- Parameterized by k: a bounded-branching DP over layers that keeps only the “relevant” part B_i := N(R_i) and guesses S_{i+1} ⊆ B_i (|S_{i+1}|=k). From B_i there are at most O(n^k) transitions to B_{i+1}. The challenge is to bound the number of distinct B_i encountered; identifying a compressed state space (e.g., via neighborhood equivalence modulo k) could lead to an n^{O(k)} algorithm.

# Next steps (auditable work)

1) Verification by computation for small n: Exhaustively compute e(G) for all graphs up to n=8 (or all trees up to n=12) and compare with degeneracy. This directly tests Conjecture 9 and will likely suggest a proof strategy or counterexample.

2) Trees and forests: either prove e(T)=1 for all trees T (which, combined with cycles⇒e≥2, would fit degeneracy) or find a counterexample. A promising approach is to construct a schedule from an Euler traversal with carefully chosen repetitions (as in Example 8) and prove R_n=∅ by induction on the number of leaves.

3) Layered LP/flow duality: Formalize the LP for layer-budget path hitting and analyze integrality on layered DAGs. Even a constant-factor integrality bound might yield an XP recognition via iterative rounding for fixed k.

4) Obstruction theory beyond disjoint paths: Characterize minimal sets of layer paths that force e(G)≥k+1 (robust packings that survive any ≤k per-layer deletions). If these obstructions admit polynomial-time detection for fixed k, we obtain an n^{O(k)} recognition.

# Summary of provable content for inclusion

- Proposition 1: R-recursion equivalence.
- Lemma 2 and Corollaries 3–4: lower bounds via min degree and degeneracy; monotonicity under subgraphs.
- Exact values: e(K_n)=n−1; e(K_{a,b})=min(a,b); e(C_m)=2 (m≥3). Worked example e(P_4)=1.
- Practical NO-test: if d(G)>k then e(G)>k (linear time).
- Conjecture: e(G)=d(G). If true, recognition is linear time. Otherwise, the above layered-graph framework and parameterized DP outline suggest a path toward n^{O(k)} or at least FPT-time recognition.
