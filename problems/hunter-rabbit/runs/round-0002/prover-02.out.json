{
  "content": "Ideas\n\n- Solidify the dynamics R_{i+1}=N(R_i)\\S_{i+1} and use it to compute/verify schedules. Provide exact values on basic families and structural identities that the verifier can port to proofs.md.\n- Settle the path family: prove h(P_n)=1 for all n with an explicit 1-hunter schedule. This is a significant special case and supports the conjecture that trees might also satisfy h(T)=1.\n- Record a decomposition rule: h respects disjoint unions, allowing reduction to connected components.\n\nRigorous results and proofs\n\nLemma (Disjoint unions). For graphs G,H on disjoint vertex sets, h(G \u2294 H) = max{h(G), h(H)}.\nProof. Any walk lies entirely in one component. If k \u2265 max{h(G),h(H)}, concatenate winning schedules for G and H (placing empty shots on the other component) to catch all walks. Conversely, if k < h(G), then even restricting to G, no k-schedule wins; thus h(G \u2294 H) \u2265 h(G). Symmetrically for H.\n\nProposition (Complete graphs). h(K_n)=n\u22121.\nProof. Lower bound: \u03b4(K_n)=n\u22121 implies h\u2265n\u22121. Upper bound: fix x\u2208V and shoot S_1=S_2=V\\{x}. Any surviving walk begins at x (to avoid S_1) and must move to some y\u2260x at step 2, where y\u2208S_2, so it is caught.\n\nProposition (Complete bipartite graphs). For K_{p,q}, h= min{p,q}.\nProof. Lower bound by the K_{s,t} subgraph argument. Upper bound: shoot the smaller side every round.\n\nTheorem (Paths). For every n\u22652, h(P_n)=1.\nProof. Label P_n by 1\u20132\u2013\u2026\u2013n. Consider the 1-hunter schedule of length 2n\u22123:\n- Forward pass: S_i={i} for i=1,2,\u2026,n\u22121.\n- Backward pass: S_{n\u22121+r}={n\u2212r} for r=1,2,\u2026,n\u22122.\nLet R_1=V\\S_1 and R_{i+1}=N(R_i)\\S_{i+1}. We prove two phase invariants.\nPhase I (forward). For 1\u2264j\u2264n\u22121,\nR_j = {i: i>j} \u222a {i: 1\u2264i\u2264j and i\u2261j+1 (mod 2)}.  (\u2217)\nWe argue by induction on j. For j=1: R_1=V\\{1}={2,3,\u2026,n}, which matches (\u2217). Suppose (\u2217) holds. Then N({i>j})=[j,\u2026,n] and N({i\u2264j, i\u2261j+1})={i: 1\u2264i\u2264j+1, i\u2261j (mod 2)}. Removing S_{j+1}={j+1} yields\nR_{j+1}={i>j+1} \u222a {i: 1\u2264i\u2264j+1, i\u2261j (mod 2)}, which is (\u2217) with j+1. In particular, at the end of Phase I we have\nR_{n\u22121} = {i: i\u2261n (mod 2)}.\nPhase II (backward). For 1\u2264r\u2264n\u22122, set i=n\u22121+r. We claim:\n- If n is even, then R_i equals {odd j: 1\u2264j\u2264n\u2212r\u22122} for odd r and {even j: 2\u2264j\u2264n\u2212r\u22122} for even r.\n- If n is odd, then R_i equals {even j: 2\u2264j\u2264n\u2212r\u22122} for odd r and {odd j: 1\u2264j\u2264n\u2212r\u22122} for even r.\nThis is verified by induction on r. The base r=1 follows from R_{n\u22121} being the parity class of n and S_n={n\u22121}, which deletes the largest element of the opposite parity, leaving all vertices of the opposite parity up to n\u22123. For the step r\u2192r+1, R_{i} is an arithmetic progression of a fixed parity ending at m:=n\u2212r\u22122. Its neighborhood is the opposite parity progression up to m+1. Removing S_{i+1}={n\u2212(r+1)}={m+1} trims the top element, leaving the opposite parity progression up to m\u22121=n\u2212(r+1)\u22122, as claimed. When r=n\u22122 the claimed set is empty, so R_{2n\u22123}=\u2205 and the schedule wins. Since \u03b4(P_n)=1, this is optimal: h(P_n)=1.\n\nCorollary (Stars). For K_{1,m}, h=1 (immediate from the path theorem or shooting the center twice).\n\nExamples (cycles; partial). We verified h(C_3)=2 and h(C_4)=2. For C_5, the 2-hunter 4-round schedule S_1={1,3}, S_2={4,5}, S_3={2,4}, S_4={1,4} yields R_4=\u2205 under R_{i+1}=N(R_i)\\S_{i+1}. This supports the conjecture h(C_n)=2 for all n\u22653, but a general proof remains open here.\n\nAlgorithmic implications\n\n- For k=1, the necessary condition \u201cG is a forest\u201d follows from the degeneracy lower bound (any cycle forces degeneracy\u22652 and h\u22652). The path result proves h(T)=1 for all paths and stars; extending to all trees would yield a linear-time recognition for k=1 (check acyclicity). This is a prime next target.\n- Quick filters for general k: if degeneracy(G)>k (or equivalently, G has a subgraph of minimum degree \u2265k+1), then h(G)>k. If \u03c4(G)\u2264k then h(G)\u2264k. Both are n^{O(k)} computable.\n- Caution on NP-membership: a priori winning schedules may require super-polynomial length; the certificate length issue remains unresolved.\n\nObstacles\n\n- Extending the 1-hunter path schedule to arbitrary trees requires controlling N(R_i) through branching; naive \u201cleaf peels stay peeled\u201d arguments are false because neighbors inside R_i can reintroduce vertices via N.\n- For cycles, time-invariant pairs of shots fail on odd n; an invariant or automaton capturing all C_n in one pattern is needed.\n\nNext steps (checkable)\n\n1) Generalize the path schedule to trees: attempt the \u201cdiameter spine\u201d schedule S along a longest path (forward then backward). Verify on all trees up to n\u226412 by explicit R-propagation; prove correctness via an inductive decomposition at attachments to the spine.\n2) Prove h(C_n)=2 for all n with a uniform schedule family; or isolate the minimal counterexample if any. Start with constructing periodic schedules for C_{2r+1} and verify R_t=\u2205 symbolically.\n3) Structural DP: prove h(G)\u2264k on bounded treewidth graphs in n^{O(k)} time by propagating R_i over separators. Formalize a bag-state that records which boundary vertices are \u201creachable at this parity,\u201d with transitions matching R_{i+1}=N(R_i)\\S_{i+1} and |S_{i+1}|\u2264k.\n4) Hardness probe: Attempt a reduction to show W[1]-hardness parameterized by k (or NP-hardness for fixed k\u22652) via layered gadgets encoding a per-layer hitting set.\n\nSummary\n\n- We proved h(K_n)=n\u22121 and h(K_{p,q})=min{p,q}, established h(G \u2294 H)=max, and gave a complete, verifiable proof that h(P_n)=1 with an explicit schedule of length 2n\u22123.\n- This advances the k=1 classification: trees are plausible candidates for h=1; paths and stars confirm this. Completing the tree case would deliver a polynomial-time recognition for k=1.\n- For cycles we have consistent evidence for h(C_n)=2 but no general proof yet.\n- The separator/DP direction and hardness probes remain viable routes toward the main recognizability question for fixed k."
}