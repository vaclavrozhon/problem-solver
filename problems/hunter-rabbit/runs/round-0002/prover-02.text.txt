Ideas

- Solidify the dynamics R_{i+1}=N(R_i)\S_{i+1} and use it to compute/verify schedules. Provide exact values on basic families and structural identities that the verifier can port to proofs.md.
- Settle the path family: prove h(P_n)=1 for all n with an explicit 1-hunter schedule. This is a significant special case and supports the conjecture that trees might also satisfy h(T)=1.
- Record a decomposition rule: h respects disjoint unions, allowing reduction to connected components.

Rigorous results and proofs

Lemma (Disjoint unions). For graphs G,H on disjoint vertex sets, h(G ⊔ H) = max{h(G), h(H)}.
Proof. Any walk lies entirely in one component. If k ≥ max{h(G),h(H)}, concatenate winning schedules for G and H (placing empty shots on the other component) to catch all walks. Conversely, if k < h(G), then even restricting to G, no k-schedule wins; thus h(G ⊔ H) ≥ h(G). Symmetrically for H.

Proposition (Complete graphs). h(K_n)=n−1.
Proof. Lower bound: δ(K_n)=n−1 implies h≥n−1. Upper bound: fix x∈V and shoot S_1=S_2=V\{x}. Any surviving walk begins at x (to avoid S_1) and must move to some y≠x at step 2, where y∈S_2, so it is caught.

Proposition (Complete bipartite graphs). For K_{p,q}, h= min{p,q}.
Proof. Lower bound by the K_{s,t} subgraph argument. Upper bound: shoot the smaller side every round.

Theorem (Paths). For every n≥2, h(P_n)=1.
Proof. Label P_n by 1–2–…–n. Consider the 1-hunter schedule of length 2n−3:
- Forward pass: S_i={i} for i=1,2,…,n−1.
- Backward pass: S_{n−1+r}={n−r} for r=1,2,…,n−2.
Let R_1=V\S_1 and R_{i+1}=N(R_i)\S_{i+1}. We prove two phase invariants.
Phase I (forward). For 1≤j≤n−1,
R_j = {i: i>j} ∪ {i: 1≤i≤j and i≡j+1 (mod 2)}.  (∗)
We argue by induction on j. For j=1: R_1=V\{1}={2,3,…,n}, which matches (∗). Suppose (∗) holds. Then N({i>j})=[j,…,n] and N({i≤j, i≡j+1})={i: 1≤i≤j+1, i≡j (mod 2)}. Removing S_{j+1}={j+1} yields
R_{j+1}={i>j+1} ∪ {i: 1≤i≤j+1, i≡j (mod 2)}, which is (∗) with j+1. In particular, at the end of Phase I we have
R_{n−1} = {i: i≡n (mod 2)}.
Phase II (backward). For 1≤r≤n−2, set i=n−1+r. We claim:
- If n is even, then R_i equals {odd j: 1≤j≤n−r−2} for odd r and {even j: 2≤j≤n−r−2} for even r.
- If n is odd, then R_i equals {even j: 2≤j≤n−r−2} for odd r and {odd j: 1≤j≤n−r−2} for even r.
This is verified by induction on r. The base r=1 follows from R_{n−1} being the parity class of n and S_n={n−1}, which deletes the largest element of the opposite parity, leaving all vertices of the opposite parity up to n−3. For the step r→r+1, R_{i} is an arithmetic progression of a fixed parity ending at m:=n−r−2. Its neighborhood is the opposite parity progression up to m+1. Removing S_{i+1}={n−(r+1)}={m+1} trims the top element, leaving the opposite parity progression up to m−1=n−(r+1)−2, as claimed. When r=n−2 the claimed set is empty, so R_{2n−3}=∅ and the schedule wins. Since δ(P_n)=1, this is optimal: h(P_n)=1.

Corollary (Stars). For K_{1,m}, h=1 (immediate from the path theorem or shooting the center twice).

Examples (cycles; partial). We verified h(C_3)=2 and h(C_4)=2. For C_5, the 2-hunter 4-round schedule S_1={1,3}, S_2={4,5}, S_3={2,4}, S_4={1,4} yields R_4=∅ under R_{i+1}=N(R_i)\S_{i+1}. This supports the conjecture h(C_n)=2 for all n≥3, but a general proof remains open here.

Algorithmic implications

- For k=1, the necessary condition “G is a forest” follows from the degeneracy lower bound (any cycle forces degeneracy≥2 and h≥2). The path result proves h(T)=1 for all paths and stars; extending to all trees would yield a linear-time recognition for k=1 (check acyclicity). This is a prime next target.
- Quick filters for general k: if degeneracy(G)>k (or equivalently, G has a subgraph of minimum degree ≥k+1), then h(G)>k. If τ(G)≤k then h(G)≤k. Both are n^{O(k)} computable.
- Caution on NP-membership: a priori winning schedules may require super-polynomial length; the certificate length issue remains unresolved.

Obstacles

- Extending the 1-hunter path schedule to arbitrary trees requires controlling N(R_i) through branching; naive “leaf peels stay peeled” arguments are false because neighbors inside R_i can reintroduce vertices via N.
- For cycles, time-invariant pairs of shots fail on odd n; an invariant or automaton capturing all C_n in one pattern is needed.

Next steps (checkable)

1) Generalize the path schedule to trees: attempt the “diameter spine” schedule S along a longest path (forward then backward). Verify on all trees up to n≤12 by explicit R-propagation; prove correctness via an inductive decomposition at attachments to the spine.
2) Prove h(C_n)=2 for all n with a uniform schedule family; or isolate the minimal counterexample if any. Start with constructing periodic schedules for C_{2r+1} and verify R_t=∅ symbolically.
3) Structural DP: prove h(G)≤k on bounded treewidth graphs in n^{O(k)} time by propagating R_i over separators. Formalize a bag-state that records which boundary vertices are “reachable at this parity,” with transitions matching R_{i+1}=N(R_i)\S_{i+1} and |S_{i+1}|≤k.
4) Hardness probe: Attempt a reduction to show W[1]-hardness parameterized by k (or NP-hardness for fixed k≥2) via layered gadgets encoding a per-layer hitting set.

Summary

- We proved h(K_n)=n−1 and h(K_{p,q})=min{p,q}, established h(G ⊔ H)=max, and gave a complete, verifiable proof that h(P_n)=1 with an explicit schedule of length 2n−3.
- This advances the k=1 classification: trees are plausible candidates for h=1; paths and stars confirm this. Completing the tree case would deliver a polynomial-time recognition for k=1.
- For cycles we have consistent evidence for h(C_n)=2 but no general proof yet.
- The separator/DP direction and hardness probes remain viable routes toward the main recognizability question for fixed k.