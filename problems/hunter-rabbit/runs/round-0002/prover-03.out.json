{
  "content": "Ideas\n- Solidify the state-evolution model R_{1}=V\\S_{1}, R_{i+1}=N(R_i)\\S_{i+1}. A schedule S_1,\u2026,S_t wins up to horizon t iff R_t=\u2205. This will be our verification engine.\n- Settle k=1 exactly. We give a correct pruning-by-leaves inductive proof that forests admit a 1-hunter winning schedule of length \u22642|V|\u22121, and any graph with a cycle needs \u22652 hunters.\n- Record exact values for complete bipartite graphs and basic bounds rigorously. These become quick filters and calibration tests.\n\nRigorous proofs\nLemma 1 (Lower bound via minimum degree). For any graph G and any k<\u03b4(G), the evader can avoid capture for arbitrarily long. Hence h(G)\u2265\u03b4(G), and by subgraph monotonicity h(G)\u2265degeneracy(G).\nProof. Fix k<\u03b4(G). Let (S_i) be any schedule with |S_i|\u2264k. Choose v_1\u2209S_1. Given v_i\u2209S_i and deg(v_i)\u2265k+1, pick v_{i+1}\u2208N(v_i)\\S_{i+1} (nonempty since |S_{i+1}|\u2264k). Then v_i\u2209S_i for all i, so no capture. For any subgraph H\u2286G, h(H)\u2264h(G). Since a degeneracy-d subgraph has minimum degree d, h(G)\u2265d. \u220e\n\nLemma 2 (Subgraph monotonicity). If H\u2286G, then h(H)\u2264h(G).\nProof. Any schedule for G restricts to H; walks in H are walks in G. \u220e\n\nProposition 3 (Complete bipartite graphs). For K_{p,q}, h(K_{p,q})=min{p,q}.\nProof. Lower bound: \u03b4(K_{p,q})=min{p,q} and Lemma 1. Upper bound: let B be the bipartition side of size b=min{p,q}. Shooting S_i:=B for all i ensures R_1\u2286A, R_2\u2286B\\B=\u2205. \u220e\n\nTheorem 4 (Exact k=1: forests). For a graph G, h(G)=1 iff G is a forest.\nProof.\n(\u21d2) If G contains a cycle C, then h(C)\u2265\u03b4(C)=2 by Lemma 1; by Lemma 2, h(G)\u22652. So h(G)\u22601.\n(\u21d0) Suppose G is a forest. We construct a 1-hunter schedule of length at most 2|V(G)|\u22121 by iteratively deleting leaves. We work with the R-recurrence. We need a simple two-shot observation:\nClaim. Let T be any graph (we will use T a forest), let \u2113 be a leaf of T with unique neighbor u. For any subset X\u2286V(T), N(N(X)\\{u}) contains no \u2113. In particular, for any schedule whose next two shots are u,u, if the current possible-position set is R, then \u2113\u2209N(N(R)\\{u}). Proof: \u2113 has only neighbor u, so any z adjacent to \u2113 must be z=u. Since u is removed before taking N(\u00b7), \u2113 cannot be reached in two steps.\nConstruction. Define a schedule S on T by recursion on n=|V(T)|.\n- Base n=1: Take S=(v). Then R_1=V\\{v}=\u2205.\n- Step n\u22652: Pick any leaf \u2113 with neighbor u. Let T\u2032:=T\u2212\u2113. Let S\u2032 be the (inductively constructed) schedule on T\u2032 of length 2|V(T\u2032)|\u22121 that wins on T\u2032. Define S on T as the concatenation (u,u) followed by S\u2032.\nWe prove that S wins on T and its length L satisfies L=2n\u22121. Length: L=2+(2(n\u22121)\u22121)=2n\u22121. Correctness: Let R^T_i be the R-sets for T under S, and R^{T\u2032}_j those for T\u2032 under S\u2032. We show by induction on j\u22651 that\n(\u2217) R^T_{j+2} \u2286 R^{T\u2032}_j.\nBasis j=1: R^T_2=N(V(T)\\{u})\\{u} does not contain \u2113 (since \u2113\u2019s only neighbor is u\u2209V(T)\\{u}). Hence \u2113\u2209N(R^T_2), so R^T_3=N(R^T_2)\\{S\u2032_1}\u2286V(T\u2032)\\{S\u2032_1}=R^{T\u2032}_1.\nInductive step: if R^T_{j+2}\u2286R^{T\u2032}_j, then R^T_{j+3}=N(R^T_{j+2})\\{S\u2032_{j+1}} \u2286 N(R^{T\u2032}_j)\\{S\u2032_{j+1}}=R^{T\u2032}_{j+1}.\nFinally, since S\u2032 wins on T\u2032, R^{T\u2032}_{2|V(T\u2032)|\u22121}=\u2205. By (\u2217), R^T_{2+(2|V(T\u2032)|\u22121)}=R^T_{2n\u22121}\u2286\u2205, so R^T_{2n\u22121}=\u2205. Thus S wins. \u220e\n\nCorollaries and checks for k=1\n- Recognizing h(G)=1 is linear-time: h(G)=1 iff G is a forest (Theorem 4), and acyclicity can be tested in O(n+m).\n- Small example: P_4 with vertices 1\u20132\u20133\u20134 is captured by S=(2,2,3,3,2). Computation: R_1={1,3,4}; R_2={3,4}; R_3={2,4}; R_4={1}; R_5=\u2205.\n\nState-graph perspective (for exact solvers on small n)\n- Define a directed graph on 2^V with edges X\u2192Y iff Y\u2286N(X) and |N(X)\\Y|\u2264k. Then h(G)\u2264k iff there exists a path V\u2192\u2205. This yields an exact algorithm by BFS/DFS on reachable states starting from V. Per-state branching is \u2264\u03a3_{i=0}^k C(|N(X)|,i)=n^{O(k)}; total states may be exponential, but this is practical for small n and for generating data and conjectures (e.g., minimal obstructions for k=2).\n\nAlgorithmic consequences (current)\n- Fast NO: If degeneracy(G)>k (or \u03c9(G)\u2265k+2), then h(G)>k.\n- Fast YES: If \u03c4(G)\u2264k (vertex cover), then h(G)\u2264k by shooting the cover every round (capture by time 2). For general graphs, \u03c4 is NP-hard to compute exactly but FPT in k and well-approximable; \u03c4\u2264k serves as a polynomially checkable certificate for h(G)\u2264k.\n\nObstacles\n- For general k\u22652, bounding the number of reachable states from V in the 2^V state graph by n^{O(k)} is open. Without such a bound, a general n^{O(k)} algorithm is not immediate.\n- The relationship between h(G) and standard width parameters (treewidth/pathwidth) is unclear. A DP over a tree decomposition seems plausible but requires a careful state summarization of possible-position evolution across bags.\n\nNext steps (testable)\n1) Cycles: Prove h(C_n)=2 for all n\u22653. We have explicit schedules for C_3,C_4 and a 4-round schedule for C_5; generalizing to all n (with a simple O(n)-length pattern) is a concrete target.\n2) Treewidth-FPT: Design a DP on a nice tree decomposition that encodes, per bag, the set of possible positions intersected with the bag after each step modulo small lookback, and transitions constrained by at most k deletions per step. Aim for time f(k,tw)\u00b7n.\n3) Enumeration: Implement the state-graph search to compute h(G) on all graphs up to n=10 and extract minimal obstructions for h\u22642. These data can guide structure lemmas.\n4) Hardness (k fixed): Attempt a reduction (e.g., from SAT or temporal cut) to show that recognizing h(G)\u22642 is NP-hard, which would answer the main question in the negative for some k\u22652.\n\nSummary of new contributions here\n- Exact characterization for k=1: h(G)=1 iff G is a forest, with a correct inductive proof and explicit schedule length \u22642|V|\u22121 (Theorem 4).\n- Consolidated rigorous bounds: h(G)\u2265\u03b4(G)\u22650 and thus \u2265 degeneracy(G); h(K_{p,q})=min{p,q} with proof.\n- Concrete small example schedules and a precise state-graph formulation for experimentation and verification."
}