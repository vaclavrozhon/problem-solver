=== SYSTEM ===
You are a research mathematician. 

You are being run in a loop with a verifier that checks rigor. Your goal is to make **incremental, auditable progress**. You are not expected to solve the problem at once, but to generate new, testable ideas.

Inputs: 
- task statement 
- notes.md (informal progress & exploratory work; optional) 
- proofs.md (rigorously proven results & detailed proofs; optional) 
- output.md (main results, rigorously presented; optional) 
- summary of past rounds (optional) 
- possibly some reference papers.

What counts as progress:
- Extract lemmas/heuristics from literature. Generalize them for current task, or explain why they could be helpful. 
- Explore small examples & try to break your own claims with toy counterexamples.
- Prove special cases or nontrivial bounds.
- If an approach fails, explain crisply why.
- Point out flaws in notes.md, proofs.md, or output.md (you are not rewriting these files yourself, that's verifier's job).

**Discipline.** 
- Read notes, outputs, summaries carefully before proposing new work. 
- Reference papers if relevant, but focus on *incremental, checkable steps*. 
- Do not output Markdown code fences, only raw JSON. 
- Length: at least ~200 words. 
- Organize your reasoning with short headings (Ideas, Examples, Obstacles, Next steps), make clear what your claims are and how they are supported. 

**Output**: Write your analysis as Markdown that includes both informal reasoning and any rigorous proofs. The verifier will decide what goes into notes.md, proofs.md, and output.md.

**Return strictly JSON**:
{
  "content": "Your complete analysis in Markdown (KaTeX allowed). Include reasoning, examples, proofs, failed attempts, intuitions - everything for the verifier to review."
}


=== USER ===
=== Task (txt) ===

Definitions.
• The hunters and rabbit problem is a pursuit-evasion game played
on an undirected graph. A strategy for k hunters is a sequence
s1, s2, · · · , sn of subsets of k vertices. A strategy is winning if, for
every walk v1, v2, · · · , vn in the graph (not necessarily simple), there
is i such that vi ∈ si. Intuitively, the evader is walking on the graph
(it has to move at each turn by following exactly one edge) and must
avoid the k vertices that the pursuers examine at each time step.

• The evasion number of a graph G is the smallest k for which there
is a winning strategy with k hunters.

Question: Is it the case that, for any constant k , we can recognize
the graphs of the evasion number k in polynomial time? (E.g. n^{O(k)})


=== Notes ===

# Research Notes



Working definitions and dynamics
- We fix the open-neighborhood operator N(X)=⋃_{x∈X}N(x). For a schedule S_1, …, S_t (|S_i|≤k), define R_1:=V\S_1 and R_{i+1}:=N(R_i)\S_{i+1}. The schedule is winning up to horizon t iff R_t=∅. Equivalently, using P_1:=V and P_{i+1}:=N(P_i\S_i), the schedule wins iff P_{t+1}=∅. These are equivalent formulations under an index shift.

Verified results we will use
- Subgraph monotonicity: If H⊆G then h(H)≤h(G).
- Upper bound: h(G)≤τ(G) by shooting a minimum vertex cover twice (capture by time 2).
- Lower bounds: h(G)≥δ(G); therefore h(G)≥degeneracy(G). Also, if G contains K_{s,t} as a subgraph then h(G)≥min{s,t}.
- Exact values: h(K_n)=n−1; h(K_{p,q})=min{p,q}. For cycles, h(C_3)=2 (clique), h(C_4)=2; for C_5 a concrete 4-round schedule with k=2 succeeds (see proofs.md). The claim that two fixed antipodal shots per round win on all cycles is false for odd n.

Corrections to earlier claims
- The statement h(K_n)=n is incorrect; n−1 hunters suffice (and are necessary by δ(K_n)=n−1).
- The 1-hunter impossibility on P_n for n≥4 is false; e.g., P_4 has an explicit 1-hunter winning schedule. A general proof that h(P_n)=1 appears feasible but is not yet written.
- The assertion that the decision problem is in NP lacks a bound on schedule length; a priori, a winning schedule may require exponentially many rounds.

Concrete example (cycles)
- C_5 with k=2: S_1={1,3}, S_2={4,5}, S_3={2,4}, S_4={1,4} yields R_1={2,4,5}, R_2={1,3}, R_3={5}, R_4=∅. Thus h(C_5)≤2. For odd cycles, fixed pairs per round do not suffice; schedules must change over time.

Algorithmic consequences (current)
- Fast NO: if degeneracy(G)>k or ω(G)≥k+2 then h(G)>k.
- Fast YES: if τ(G)≤k then h(G)≤k (via FPT vertex-cover).
- These give n^{O(k)} filters but do not settle all instances.

Open targets and next steps
1) Prove h(C_n)=2 for all n≥3 (and record a general schedule). 2) Settle k=1: prove or refute “h(G)=1 iff G is a forest.” 3) Investigate structural upper bounds: does h(G)≤tw(G)? A positive answer implies polynomial recognition for fixed k. 4) Design a separator-based DP that simulates R-evolution with states depending only on boundary sets of size ≤k. 5) Empirically compute h on small graphs (n≤10) and all trees up to n≈12 to test the degeneracy-equality conjecture and discover obstructions.


=== Current Output ===

# Main Results




=== Round 1 Summary ===

Recorded and verified core definitions and elementary bounds for the hunters–rabbit evasion number h(G). Proved schedule verification equivalence (S_1..S_t wins iff R_t=∅ with R_{i+1}=N(R_i)\S_{i+1}), subgraph monotonicity, lower bounds h(G)≥δ(G) and hence ≥ degeneracy(G), and the upper bound h(G)≤τ(G) (capture by shooting a minimum vertex cover twice). Determined exact values h(K_n)=n−1 and h(K_{p,q})=min{p,q}; cycles: C_3,C_4 have h=2 and an explicit 4-round 2-hunter schedule shows h(C_5)≤2 (odd cycles require time-varying schedules). Algorithmically: fast NO filters (degeneracy>k or ω(G)≥k+2) and fast YES via τ(G)≤k, but NP-membership is unresolved because winning schedules may need unbounded length. Open targets: prove h(C_n)=2, classify h(G)=1, and investigate h(G)≤tw(G) or an n^{O(k)} separator DP. Citations: proofs.md; research notes.


=== Previous Round Feedback ===

Overall: good formalization progress, but multiple factual errors and unproven claims remain. We can extract several rigorous lemmas (state-evolution equivalence; subgraph monotonicity; vertex-cover upper bound; lower bounds via minimum degree/degeneracy; exact values for K_n and K_{p,q}). Claims about cycles and k=1 need correction and full proofs.

Key issues per prover
- P1: The dynamics P_{i+1}=N(P_i \ S_i) is correct, and the bounds h ≥ ω−1 and h ≤ τ are valid. However, the claim “cycles: two antipodal vertices every round” is false for odd cycles (e.g., on C_5, {1,3} each round fails: the walk 4,5,4,5,… survives). Your worked C_5 schedule has a computation mistake under the P-recursion; with the R-recursion (R_1=V\S_1; R_{i+1}=N(R_i)\S_{i+1}), a correct 4-round 2-hunter schedule exists (see proofs.md Example). The path P_4 example is consistent. Keep cycle results as conjectural until fully proved for all n.
- P2: Several incorrect claims: h(K_n)=n is false; the correct value is n−1 (schedule S_i=V\{x} captures by time 2). Also, “1 hunter fails on P_n for n≥4” is false (P_4 has a 1-hunter winning schedule; see P1). The “in NP” assertion is unjustified: a winning schedule may require exponentially many rounds a priori; no polynomially bounded certificate is known for general k. Good contributions: layered-DAG verification for a fixed schedule; K_{s,t} lower bound; K_{p,q} exact; subgraph monotonicity; vertex-cover upper bound.
- P3: The theorem “h(G)=1 iff G is a forest” is attractive but the provided proof is flawed: the identity P′=N(N(P)\{u})\{u} after two shots at u is not generally valid, and the permanence of leaf deletions does not follow. The direction “cycle ⇒ 1 hunter fails” does hold by subgraph monotonicity plus δ(C_m)=2. Keep this as a research target; either supply a correct inductive proof or find a counterexample.
- P4: Degeneracy lower bound and exact values for K_n, K_{a,b}, and cycles’ lower bound are correct. The proof that fixed {u,v} on cycles gives R_2=∅ is wrong (for odd m, N(V\{u,v})=V, so R_2=V\{u,v}≠∅). The conjecture e(G)=degeneracy is plausible but unproven; prioritize searching for a counterexample or a proof strategy.

Concrete next steps
1) Solidify core facts (now in proofs.md). 2) Prove h(C_n)=2 for all n≥3 (we included a correct C_5 schedule). 3) Settle k=1: prove or refute “h(G)=1 iff G is a forest.” 4) Explore whether h ≤ treewidth holds (would imply n^{O(k)} recognition). 5) Develop a separator-based DP for deciding h(G)≤k in n^{O(k)} time. 6) Empirically compute h on all graphs up to n=10 (and all trees up to n=12) to test the degeneracy-equality conjecture and guide proofs.