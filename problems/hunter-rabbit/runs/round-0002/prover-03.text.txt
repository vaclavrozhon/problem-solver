Ideas
- Solidify the state-evolution model R_{1}=V\S_{1}, R_{i+1}=N(R_i)\S_{i+1}. A schedule S_1,…,S_t wins up to horizon t iff R_t=∅. This will be our verification engine.
- Settle k=1 exactly. We give a correct pruning-by-leaves inductive proof that forests admit a 1-hunter winning schedule of length ≤2|V|−1, and any graph with a cycle needs ≥2 hunters.
- Record exact values for complete bipartite graphs and basic bounds rigorously. These become quick filters and calibration tests.

Rigorous proofs
Lemma 1 (Lower bound via minimum degree). For any graph G and any k<δ(G), the evader can avoid capture for arbitrarily long. Hence h(G)≥δ(G), and by subgraph monotonicity h(G)≥degeneracy(G).
Proof. Fix k<δ(G). Let (S_i) be any schedule with |S_i|≤k. Choose v_1∉S_1. Given v_i∉S_i and deg(v_i)≥k+1, pick v_{i+1}∈N(v_i)\S_{i+1} (nonempty since |S_{i+1}|≤k). Then v_i∉S_i for all i, so no capture. For any subgraph H⊆G, h(H)≤h(G). Since a degeneracy-d subgraph has minimum degree d, h(G)≥d. ∎

Lemma 2 (Subgraph monotonicity). If H⊆G, then h(H)≤h(G).
Proof. Any schedule for G restricts to H; walks in H are walks in G. ∎

Proposition 3 (Complete bipartite graphs). For K_{p,q}, h(K_{p,q})=min{p,q}.
Proof. Lower bound: δ(K_{p,q})=min{p,q} and Lemma 1. Upper bound: let B be the bipartition side of size b=min{p,q}. Shooting S_i:=B for all i ensures R_1⊆A, R_2⊆B\B=∅. ∎

Theorem 4 (Exact k=1: forests). For a graph G, h(G)=1 iff G is a forest.
Proof.
(⇒) If G contains a cycle C, then h(C)≥δ(C)=2 by Lemma 1; by Lemma 2, h(G)≥2. So h(G)≠1.
(⇐) Suppose G is a forest. We construct a 1-hunter schedule of length at most 2|V(G)|−1 by iteratively deleting leaves. We work with the R-recurrence. We need a simple two-shot observation:
Claim. Let T be any graph (we will use T a forest), let ℓ be a leaf of T with unique neighbor u. For any subset X⊆V(T), N(N(X)\{u}) contains no ℓ. In particular, for any schedule whose next two shots are u,u, if the current possible-position set is R, then ℓ∉N(N(R)\{u}). Proof: ℓ has only neighbor u, so any z adjacent to ℓ must be z=u. Since u is removed before taking N(·), ℓ cannot be reached in two steps.
Construction. Define a schedule S on T by recursion on n=|V(T)|.
- Base n=1: Take S=(v). Then R_1=V\{v}=∅.
- Step n≥2: Pick any leaf ℓ with neighbor u. Let T′:=T−ℓ. Let S′ be the (inductively constructed) schedule on T′ of length 2|V(T′)|−1 that wins on T′. Define S on T as the concatenation (u,u) followed by S′.
We prove that S wins on T and its length L satisfies L=2n−1. Length: L=2+(2(n−1)−1)=2n−1. Correctness: Let R^T_i be the R-sets for T under S, and R^{T′}_j those for T′ under S′. We show by induction on j≥1 that
(∗) R^T_{j+2} ⊆ R^{T′}_j.
Basis j=1: R^T_2=N(V(T)\{u})\{u} does not contain ℓ (since ℓ’s only neighbor is u∉V(T)\{u}). Hence ℓ∉N(R^T_2), so R^T_3=N(R^T_2)\{S′_1}⊆V(T′)\{S′_1}=R^{T′}_1.
Inductive step: if R^T_{j+2}⊆R^{T′}_j, then R^T_{j+3}=N(R^T_{j+2})\{S′_{j+1}} ⊆ N(R^{T′}_j)\{S′_{j+1}}=R^{T′}_{j+1}.
Finally, since S′ wins on T′, R^{T′}_{2|V(T′)|−1}=∅. By (∗), R^T_{2+(2|V(T′)|−1)}=R^T_{2n−1}⊆∅, so R^T_{2n−1}=∅. Thus S wins. ∎

Corollaries and checks for k=1
- Recognizing h(G)=1 is linear-time: h(G)=1 iff G is a forest (Theorem 4), and acyclicity can be tested in O(n+m).
- Small example: P_4 with vertices 1–2–3–4 is captured by S=(2,2,3,3,2). Computation: R_1={1,3,4}; R_2={3,4}; R_3={2,4}; R_4={1}; R_5=∅.

State-graph perspective (for exact solvers on small n)
- Define a directed graph on 2^V with edges X→Y iff Y⊆N(X) and |N(X)\Y|≤k. Then h(G)≤k iff there exists a path V→∅. This yields an exact algorithm by BFS/DFS on reachable states starting from V. Per-state branching is ≤Σ_{i=0}^k C(|N(X)|,i)=n^{O(k)}; total states may be exponential, but this is practical for small n and for generating data and conjectures (e.g., minimal obstructions for k=2).

Algorithmic consequences (current)
- Fast NO: If degeneracy(G)>k (or ω(G)≥k+2), then h(G)>k.
- Fast YES: If τ(G)≤k (vertex cover), then h(G)≤k by shooting the cover every round (capture by time 2). For general graphs, τ is NP-hard to compute exactly but FPT in k and well-approximable; τ≤k serves as a polynomially checkable certificate for h(G)≤k.

Obstacles
- For general k≥2, bounding the number of reachable states from V in the 2^V state graph by n^{O(k)} is open. Without such a bound, a general n^{O(k)} algorithm is not immediate.
- The relationship between h(G) and standard width parameters (treewidth/pathwidth) is unclear. A DP over a tree decomposition seems plausible but requires a careful state summarization of possible-position evolution across bags.

Next steps (testable)
1) Cycles: Prove h(C_n)=2 for all n≥3. We have explicit schedules for C_3,C_4 and a 4-round schedule for C_5; generalizing to all n (with a simple O(n)-length pattern) is a concrete target.
2) Treewidth-FPT: Design a DP on a nice tree decomposition that encodes, per bag, the set of possible positions intersected with the bag after each step modulo small lookback, and transitions constrained by at most k deletions per step. Aim for time f(k,tw)·n.
3) Enumeration: Implement the state-graph search to compute h(G) on all graphs up to n=10 and extract minimal obstructions for h≤2. These data can guide structure lemmas.
4) Hardness (k fixed): Attempt a reduction (e.g., from SAT or temporal cut) to show that recognizing h(G)≤2 is NP-hard, which would answer the main question in the negative for some k≥2.

Summary of new contributions here
- Exact characterization for k=1: h(G)=1 iff G is a forest, with a correct inductive proof and explicit schedule length ≤2|V|−1 (Theorem 4).
- Consolidated rigorous bounds: h(G)≥δ(G)≥0 and thus ≥ degeneracy(G); h(K_{p,q})=min{p,q} with proof.
- Concrete small example schedules and a precise state-graph formulation for experimentation and verification.