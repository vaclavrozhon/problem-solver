{
  "content": "# Ideas\n- Introduce a monotone \u201cpermanent elimination\u201d process Z_i that captures exactly which vertices can never again be reached by any avoiding walk. This yields a closed-form evolution R_i = V \\ (Z_i \u222a S_i).\n- Use a degeneracy ordering to design a schedule with k = degeneracy(G) hunters that adds one vertex to Z per round, culminating in Z_n covering all vertices by round n (with a final choice of S_n ensuring R_n=\u2205). This proves h(G)=degeneracy(G).\n- Immediate consequences: linear-time recognition of h(G) for any fixed k; exact values on cycles and forests follow as corollaries.\n\n# Formal evolution via permanent elimination\nLet G=(V,E), k\u22650, and a schedule S_1,\u2026,S_n with |S_i|\u2264k.\nDefine R_1:=V\\S_1 and R_{i+1}:=N(R_i)\\S_{i+1}.\nDefine Z_1:=\u2205 and for i\u22651 set\nZ_{i+1} := { v\u2208V : N(v) \u2286 Z_i \u222a S_i }.\n\nLemma 1 (exact evolution). For all i\u22651,\nR_i = V \\ (Z_i \u222a S_i).\nProof. By induction. For i=1: R_1=V\\S_1=V\\(Z_1\u222aS_1). Suppose R_i=V\\(Z_i\u222aS_i). Then\nR_{i+1} = N(V\\(Z_i\u222aS_i)) \\ S_{i+1}.\nFor any A\u2286V and any graph, N(V\\A) = V \\ {x : N(x)\u2286A}. Hence\nR_{i+1} = V \\ ( {x : N(x)\u2286Z_i\u222aS_i} \u222a S_{i+1} ) = V \\ (Z_{i+1} \u222a S_{i+1}). \u220e\n\nInterpretation: Z_{i+1} collects vertices v whose entire neighborhood lies in Z_i\u222aS_i; by degree-2 on cycles this means \u201cboth neighbors,\u201d in general it means \u201call neighbors.\u201d The process Z_i is monotone increasing.\n\n# Main theorem: equality with degeneracy\nRecall degeneracy d(G) is the maximum, over all subgraphs H, of \u03b4(H), equivalently the least d such that there exists an ordering v_1,\u2026,v_n with each v_i having at most d neighbors among {v_1,\u2026,v_{i-1}}.\n\nProposition 2 (lower bound; known). h(G) \u2265 d(G).\nSketch. If H\u2286G has minimum degree \u03b4(H)=d, then with k<d a rabbit can always move to an unshot neighbor within H forever (standard). Thus h(G)\u2265d(G).\n\nTheorem 3. h(G) = d(G) for all finite graphs G.\nProof. Let d:=d(G). Fix a d-degenerate ordering v_1,\u2026,v_n (each v_i has \u2264d neighbors among earlier vertices). Define targets w_t := v_{n+1\u2212t} for t=1,\u2026,n. Choose the schedule as follows:\n- For t=1,\u2026,n\u22121 set S_t := N(w_t) \u2229 {v_1,\u2026,v_{index(w_t)\u22121} } (all earlier neighbors of w_t). Clearly |S_t| \u2264 d.\n- Set S_n := {v_1} (or \u2205 if preferred and v_1 is already excluded; we use {v_1} to ensure capture by time n).\nWe claim by induction that for t=1,\u2026,n\u22121, w_t \u2208 Z_{t+1}. For t=1, w_1=v_n has no later neighbors, hence N(w_1)\u2286S_1 and so w_1\u2208Z_2. Suppose true up to t\u22121. At step t, all later neighbors of w_t (i.e., among {v_{index(w_t)+1},\u2026,v_n}) lie in Z_t by the induction hypothesis; all earlier neighbors lie in S_t by construction. Hence N(w_t)\u2286Z_t\u222aS_t and w_t\u2208Z_{t+1}. Therefore Z_n \u2287 {v_2,\u2026,v_n}. By Lemma 1 at time n,\nR_n = V \\ (Z_n \u222a S_n) \u2286 V \\ ( {v_2,\u2026,v_n} \u222a {v_1} ) = \u2205.\nThus the schedule with k=d wins in n rounds, i.e., h(G)\u2264d. Combined with Proposition 2, h(G)=d. \u220e\n\n# Consequences and examples\n- Linear-time recognition. Since degeneracy d(G) is computable in O(n+m) via k-core peeling, h(G) can be recognized in linear time; for fixed k, recognizing h(G)=k is immediate.\n- Forests. d(G)=1 for any forest G, hence h(G)=1. This resolves the k=1 target. The proof above gives a concrete schedule: root each tree, list vertices in postorder excluding the root, and at step i shoot the parent of v_i; finally shoot the root.\n- Cycles. d(C_n)=2 so h(C_n)=2 for all n\u22653. The construction specializes to the well-known \u201cexpanding block\u201d 2-hunter strategy; e.g., on C_5 one may take S_1={2,4}, S_2={1,5}, S_3={2,4}, S_4={3,?} (many choices) to achieve R_4=\u2205; the degeneracy-based construction gives a uniform n-round schedule as well.\n- Complete graphs. d(K_n)=n\u22121, agreeing with h(K_n)=n\u22121.\n- Complete bipartite. d(K_{a,b})=min{a,b}, agreeing with h(K_{a,b}).\n\n# Obstacles resolved\n- Prior doubts about schedule length are moot: the degeneracy strategy yields capture within n rounds, so certification is polynomial and the decision problem lies in P (indeed linear time).\n- Packing-based obstructions in the time-expanded graph are subsumed by the degeneracy lower bound.\n\n# Next steps\n- Time\u2013hunter tradeoff: Given k\u2265h(G), minimize the number of rounds T to capture. Complexity status and approximability are open; even for k=h(G) our proof gives T\u2264n, but optimal T can be much smaller (e.g., T=2 on K_n).\n- Structural throttling: characterize graphs where T with k=h(G) is O(log n), O(\u221an), etc.\n- Robustness: Extensions to directed graphs and weighted/latency variants of movement or shot latency.\n\n# Summary of provable content for inclusion\n- Lemma 1: R_i = V \\ (Z_i \u222a S_i) with Z_{i+1}={v:N(v)\u2286Z_i\u222aS_i}.\n- Theorem 3: h(G)=degeneracy(G), with an explicit schedule derived from a d-degenerate ordering; recognition in O(n+m).\n- Corollaries: h(F)=1 for forests; h(C_n)=2 for all n\u22653; consistency with K_n and K_{a,b}.\n"
}