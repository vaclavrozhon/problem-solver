# Ideas
- Introduce a monotone “permanent elimination” process Z_i that captures exactly which vertices can never again be reached by any avoiding walk. This yields a closed-form evolution R_i = V \ (Z_i ∪ S_i).
- Use a degeneracy ordering to design a schedule with k = degeneracy(G) hunters that adds one vertex to Z per round, culminating in Z_n covering all vertices by round n (with a final choice of S_n ensuring R_n=∅). This proves h(G)=degeneracy(G).
- Immediate consequences: linear-time recognition of h(G) for any fixed k; exact values on cycles and forests follow as corollaries.

# Formal evolution via permanent elimination
Let G=(V,E), k≥0, and a schedule S_1,…,S_n with |S_i|≤k.
Define R_1:=V\S_1 and R_{i+1}:=N(R_i)\S_{i+1}.
Define Z_1:=∅ and for i≥1 set
Z_{i+1} := { v∈V : N(v) ⊆ Z_i ∪ S_i }.

Lemma 1 (exact evolution). For all i≥1,
R_i = V \ (Z_i ∪ S_i).
Proof. By induction. For i=1: R_1=V\S_1=V\(Z_1∪S_1). Suppose R_i=V\(Z_i∪S_i). Then
R_{i+1} = N(V\(Z_i∪S_i)) \ S_{i+1}.
For any A⊆V and any graph, N(V\A) = V \ {x : N(x)⊆A}. Hence
R_{i+1} = V \ ( {x : N(x)⊆Z_i∪S_i} ∪ S_{i+1} ) = V \ (Z_{i+1} ∪ S_{i+1}). ∎

Interpretation: Z_{i+1} collects vertices v whose entire neighborhood lies in Z_i∪S_i; by degree-2 on cycles this means “both neighbors,” in general it means “all neighbors.” The process Z_i is monotone increasing.

# Main theorem: equality with degeneracy
Recall degeneracy d(G) is the maximum, over all subgraphs H, of δ(H), equivalently the least d such that there exists an ordering v_1,…,v_n with each v_i having at most d neighbors among {v_1,…,v_{i-1}}.

Proposition 2 (lower bound; known). h(G) ≥ d(G).
Sketch. If H⊆G has minimum degree δ(H)=d, then with k<d a rabbit can always move to an unshot neighbor within H forever (standard). Thus h(G)≥d(G).

Theorem 3. h(G) = d(G) for all finite graphs G.
Proof. Let d:=d(G). Fix a d-degenerate ordering v_1,…,v_n (each v_i has ≤d neighbors among earlier vertices). Define targets w_t := v_{n+1−t} for t=1,…,n. Choose the schedule as follows:
- For t=1,…,n−1 set S_t := N(w_t) ∩ {v_1,…,v_{index(w_t)−1} } (all earlier neighbors of w_t). Clearly |S_t| ≤ d.
- Set S_n := {v_1} (or ∅ if preferred and v_1 is already excluded; we use {v_1} to ensure capture by time n).
We claim by induction that for t=1,…,n−1, w_t ∈ Z_{t+1}. For t=1, w_1=v_n has no later neighbors, hence N(w_1)⊆S_1 and so w_1∈Z_2. Suppose true up to t−1. At step t, all later neighbors of w_t (i.e., among {v_{index(w_t)+1},…,v_n}) lie in Z_t by the induction hypothesis; all earlier neighbors lie in S_t by construction. Hence N(w_t)⊆Z_t∪S_t and w_t∈Z_{t+1}. Therefore Z_n ⊇ {v_2,…,v_n}. By Lemma 1 at time n,
R_n = V \ (Z_n ∪ S_n) ⊆ V \ ( {v_2,…,v_n} ∪ {v_1} ) = ∅.
Thus the schedule with k=d wins in n rounds, i.e., h(G)≤d. Combined with Proposition 2, h(G)=d. ∎

# Consequences and examples
- Linear-time recognition. Since degeneracy d(G) is computable in O(n+m) via k-core peeling, h(G) can be recognized in linear time; for fixed k, recognizing h(G)=k is immediate.
- Forests. d(G)=1 for any forest G, hence h(G)=1. This resolves the k=1 target. The proof above gives a concrete schedule: root each tree, list vertices in postorder excluding the root, and at step i shoot the parent of v_i; finally shoot the root.
- Cycles. d(C_n)=2 so h(C_n)=2 for all n≥3. The construction specializes to the well-known “expanding block” 2-hunter strategy; e.g., on C_5 one may take S_1={2,4}, S_2={1,5}, S_3={2,4}, S_4={3,?} (many choices) to achieve R_4=∅; the degeneracy-based construction gives a uniform n-round schedule as well.
- Complete graphs. d(K_n)=n−1, agreeing with h(K_n)=n−1.
- Complete bipartite. d(K_{a,b})=min{a,b}, agreeing with h(K_{a,b}).

# Obstacles resolved
- Prior doubts about schedule length are moot: the degeneracy strategy yields capture within n rounds, so certification is polynomial and the decision problem lies in P (indeed linear time).
- Packing-based obstructions in the time-expanded graph are subsumed by the degeneracy lower bound.

# Next steps
- Time–hunter tradeoff: Given k≥h(G), minimize the number of rounds T to capture. Complexity status and approximability are open; even for k=h(G) our proof gives T≤n, but optimal T can be much smaller (e.g., T=2 on K_n).
- Structural throttling: characterize graphs where T with k=h(G) is O(log n), O(√n), etc.
- Robustness: Extensions to directed graphs and weighted/latency variants of movement or shot latency.

# Summary of provable content for inclusion
- Lemma 1: R_i = V \ (Z_i ∪ S_i) with Z_{i+1}={v:N(v)⊆Z_i∪S_i}.
- Theorem 3: h(G)=degeneracy(G), with an explicit schedule derived from a d-degenerate ordering; recognition in O(n+m).
- Corollaries: h(F)=1 for forests; h(C_n)=2 for all n≥3; consistency with K_n and K_{a,b}.
