{"feedback_md":"Strong progress this round with several rigorously provable statements and useful corrections. However, a major proposed equivalence (h(G)=degeneracy(G)) remains unproven and the provided proof is flawed. We also still lack a general n^{O(k)}-time recognition algorithm or a contrary hardness result for fixed k≥2.\n\nPer prover assessment:\n- Prover 1: The “permanent blockers” lemma is correct and valuable: fixing U every round confines the evader to G−U and yields h(G) ≤ |U|+h(G−U). Your explicit 4-round captures on C_5 and C_6 check out under the R-recursion. The separator/feedback-vertex-set program is a promising concrete FPT direction. Keep the odd-cycle analysis cautious; do not assert fixed antipodal shots on odd cycles (false), and proceed with the proposed BFS on C_7 to settle h(C_7).\n- Prover 2: The disjoint-union identity h(G⊔H)=max{h(G),h(H)} is correct. Your theorem h(P_n)=1 with the 2n−3 “forward/backward sweep” and parity invariants is solid; we verified on small n and the inductive structure is sound. This is worth elevating to proofs.md. The caution on NP-membership is appropriate.\n- Prover 3: The k=1 classification h(G)=1 iff G is a forest now has a correct proof. The two-shot-at-a-neighbor-of-a-leaf lemma is applied properly to establish an inductive embedding R^T_{j+2}⊆R^{T′}_j; the overall schedule length ≤2|V|−1 is explicit. This closes the k=1 case and should go to proofs.md.\n- Prover 4: The Z-evolution identity R_i=V\\(Z_i∪S_i) with Z_{i+1}={v: N(v)⊆Z_i∪S_i} is correct. But Z_i is not monotone in i (counterexample: P_4 with shots S_1={3}, S_2={2} gives 4∈Z_2 but 4∉Z_3). The proof of h(G)=degeneracy(G) relies on monotonicity and is invalid. Moreover, the proposed degeneracy-based schedule fails on P_4 (explicit computation yields R_4≠∅). The conjecture remains open; please either repair the argument or find a counterexample.\n\nConcrete next steps:\n1) Finalize cycles: prove h(C_n)=2 for all n≥3 or produce a counterexample (settle C_7 via exhaustive R-set BFS). 2) Leverage the forest result and Lemma A to get exact n^{O(k)} recognition on graphs with feedback vertex set ≤k−1 (enumerate U and run k=1 test). 3) Develop a DP over small separators/treewidth; formalize bag states matching R_{i+1}=N(R_i)\\S_{i+1}. 4) Either prove h≤tw or pursue hardness for k=2 via layered gadgets. 5) Systematically compute h on n≤10 to stress-test the degeneracy-equality conjecture.\n","summary_md":"We added rigor: (i) disjoint-union law h(G⊔H)=max; (ii) explicit proof that h(P_n)=1 via a 2n−3 “sweep” schedule; (iii) full k=1 classification h(G)=1 iff G is a forest with an inductive two-shot leaf argument; (iv) permanent blockers lemma h(G)≤|U|+h(G−U). Verified exact values: h(K_n)=n−1, h(K_{p,q})=min{p,q}; cycles C_5 and C_6 have 2-hunter schedules. The proposed equality h(G)=degeneracy(G) remains unproven; the given proof is flawed (Z_i not monotone; degeneracy-schedule fails on P_4). Next: settle h(C_n)=2, exploit small feedback vertex sets for n^{O(k)} recognition, and build a separator-based DP or hardness for k=2.","verdict":"uncertain","blocking_issues":["No general n^{O(k)} recognition algorithm or hardness for fixed k≥2","Degeneracy equality h(G)=degeneracy(G) unproven; provided proof is invalid (Z_i not monotone)","Cycles unresolved in general: h(C_n)=2 lacks a uniform proof","Separator-based DP not yet formalized or analyzed","Certificate length (NP-membership) for general k remains unclear"],"per_prover":[{"prover_id":"01","brief_feedback":"Permanent blockers lemma is correct and useful; C_5/C_6 schedules verified; separator/FVS plan is solid. Proceed with C_7 BFS and formal separator DP sketches.","score":"promising"},{"prover_id":"02","brief_feedback":"Good rigor: h(G⊔H)=max and a clean, correct proof that h(P_n)=1 with explicit schedule. Keep pushing tree/generalizations and cycle proof.","score":"promising"},{"prover_id":"03","brief_feedback":"The k=1 characterization (forests) now has a correct inductive proof with explicit schedule length; elevate to proofs.md. Consider extending to trees for constructive schedules with length bounds.","score":"promising"},{"prover_id":"04","brief_feedback":"Z-evolution identity is fine, but Z_i is not monotone; the degeneracy equality proof fails and the constructed schedule can fail (e.g., P_4). Rework or find counterexamples.","score":"unlikely"}],"notes_update":{"action":"append","content":"New validated tools and results\n- Permanent blockers. If U⊆V is shot every round, any avoiding walk stays in G−U, hence h(G) ≤ |U|+h(G−U). This enables reductions via feedback vertex sets and other separators.\n- Disjoint unions. For graphs on disjoint vertex sets, h(G ⊔ H)=max{h(G),h(H)}. A concatenation of winning schedules for components suffices.\n- Paths. A 1-hunter “forward/backward sweep” of length 2n−3 (shots 1,2,…,n−1,n−1,n−2,…,2) wins on P_n; a parity-invariant proof verifies R_{2n−3}=∅.\n- k=1 classification. h(G)=1 iff G is a forest. Proof: cycles force ≥2 by δ=2; for forests, an inductive schedule repeatedly shoots a neighbor u of a leaf ℓ twice, then recurses on T−ℓ. A key fact: for any X and leaf ℓ with neighbor u, ℓ∉N(N(X)\\{u}). This ensures ℓ never reappears in R after the double-shot.\n- Cycles. Explicit 2-hunter captures verified on C_5 and C_6; odd cycles require time-varying shots. A uniform proof h(C_n)=2 for all n remains open.\n\nCorrections and cautions\n- The “Z-process” identity R_i=V\\(Z_i∪S_i) with Z_{i+1}={v:N(v)⊆Z_i∪S_i} holds, but Z_i need not be monotone. Arguments relying on Z-monotonicity (e.g., h=degeneracy proof) are invalid.\n\nAlgorithmic implications (current)\n- Exact k=1 recognition in linear time via acyclicity. For general k, fast filters: if degeneracy(G)>k (or ω(G)≥k+2), then NO; if τ(G)≤k, then YES (2-round capture using a vertex cover).\n- Permanent blockers yield: if fvs(G)≤k−1 and h(forest)=1 (proved), then h(G)≤k, giving an n^{O(k)} recognition on that subclass by enumerating U (|U|≤k−1).\n\nNext steps\n1) Settle cycles: prove h(C_n)=2 for all n (start with exhaustive R-set BFS on C_7). 2) Formalize a separator-based DP that simulates R_{i+1}=N(R_i)\\S_{i+1} across small boundaries (treewidth/FVS). 3) Evaluate the degeneracy-equality conjecture empirically on n≤10 and either prove or refute it. 4) Pursue either h≤tw (positive algorithmic route) or hardness for k=2 (layered gadgets) as a decisive direction on the main question."},"proofs_update":{"action":"append","content":"Further rigorous results on the evasion number\n\nNotation. For a graph G=(V,E), define N(X):=\\bigcup_{x\\in X} N(x). For a schedule (S_1,\\dots,S_t), set R_1:=V\\setminus S_1 and R_{i+1}:=N(R_i)\\setminus S_{i+1}.\n\nLemma 10 (Disjoint unions). If G and H have disjoint vertex sets, then h(G \\sqcup H)=\\max\\{h(G),h(H)\\}.\nProof. Any walk lies within one component. If k\\ge\\max\\{h(G),h(H)\\}, take a winning schedule for G (using only vertices of G) followed by a winning schedule for H (using only vertices of H), and repeat. Each component’s R-set becomes empty during its respective block and remains empty thereafter (since N(\\emptyset)=\\emptyset). Conversely, if k<h(G) then restricting to walks in G shows h(G\\sqcup H)\\ge h(G); similarly h(G\\sqcup H)\\ge h(H). ∎\n\nLemma 11 (Permanent blockers). For any U\\subseteq V, if U\\subseteq S_i for all i, then any avoiding walk stays in G-U. Consequently, h(G) \\le |U| + h(G-U).\nProof. If a walk visits u\\in U at time t, then v_t\\in S_t, a contradiction; hence all avoiding walks stay in V\\setminus U. Using |U| blockers each round and an additional h(G-U) hunters to follow a winning schedule on G-U yields a winning schedule on G with per-round budget |U|+h(G-U). ∎\n\nTheorem 12 (Paths). For every n\\ge 2, h(P_n)=1.\nProof. Label P_n by 1,2,\\dots,n along the path. Consider the 1-hunter schedule of length 2n−3:\nS_1=\\{1\\}, S_2=\\{2\\},\\dots,S_{n-1}=\\{n-1\\}, then S_n=\\{n-1\\}, S_{n+1}=\\{n-2\\},\\dots,S_{2n-3}=\\{2\\}.\nPhase I (forward). For 1\\le j\\le n−1,\nR_j = \\{i: i>j\\} \\cup \\{ i: 1\\le i\\le j and i\\equiv j+1 \\pmod 2\\}.\nThis holds by induction: R_1=\\{2,\\dots,n\\}; if it holds for j, then N(\\{i>j\\})=[j,\\dots,n] and N(\\{i\\le j,\\ i\\equiv j+1\\})=\\{i:1\\le i\\le j+1,\\ i\\equiv j\\}, and removing S_{j+1}=\\{j+1\\} gives the claimed R_{j+1}. In particular, R_{n−1}=\\{i: i\\equiv n \\pmod 2\\}.\nPhase II (backward). Let r\\in\\{1,\\dots,n−2\\}. One checks by induction on r that after S_{n−1+r}=\\{n−r\\}, R_{n−1+r} is the arithmetic progression of the parity opposite to R_{n−1}, truncated to its largest element m:=n−r−2. Its neighborhood before removing S_{n+r}=\\{m+1\\} is the complementary parity up to m+1; removing S_{n+r} deletes the top element, leaving the opposite parity up to m−1. When r=n−2 this set is empty, so R_{2n−3}=\\emptyset. Thus the schedule wins, and since \\delta(P_n)=1, this is optimal: h(P_n)=1. ∎\n\nTheorem 13 (k=1 classification). A graph G satisfies h(G)=1 if and only if G is a forest.\nProof. (⇒) If G contains a cycle C, then h(C)\\ge \\delta(C)=2; by subgraph monotonicity, h(G)\\ge 2.\n(⇐) Suppose G is a forest T. We build a 1-hunter schedule of length at most 2|V(T)|−1 by iteratively removing leaves. Fix a leaf \\ell with neighbor u. For any X\\subseteq V(T), since \\ell has only neighbor u, we have \\ell\\notin N\\big(N(X)\\setminus\\{u\\}\\big). Consider the schedule formed by two shots at u followed by the inductively constructed schedule S′ on T′:=T−\\ell. Let R^T_i (resp. R^{T′}_j) denote the R-sets under these schedules. We claim by induction on j\\ge 1 that R^T_{j+2} \\subseteq R^{T′}_j. For j=1, R^T_2=N(V(T)\\setminus\\{u\\})\\setminus\\{u\\} and \\ell\\notin N(R^T_2), so R^T_3\\subseteq V(T′)\\setminus S′_1=R^{T′}_1. If R^T_{j+2}\\subseteq R^{T′}_j then R^T_{j+3}=N(R^T_{j+2})\\setminus S′_{j+1}\\subseteq N(R^{T′}_j)\\setminus S′_{j+1}=R^{T′}_{j+1}. Since S′ empties T′ after 2|V(T′)|−1 steps, we have R^T_{2+(2|V(T′)|−1)}=\\emptyset, i.e., after at most 2|V(T)|−1 steps. Hence h(T)=1. ∎"},"output_update":null}