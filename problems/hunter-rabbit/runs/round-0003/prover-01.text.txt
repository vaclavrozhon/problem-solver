Ideas
- Close the cycle case using the already-proved k=1 classification (h(forest)=1) and the permanent blockers lemma. This settles h(C_n) exactly and gives a clean template for many “almost-acyclic” graphs.
- Extract immediate corollaries: all unicyclic graphs have h=2. Provide explicit schedules and bounds on schedule length.
- Formalize a block-cut reduction with one permanent blocker at a cut vertex; this yields compositional upper bounds and a dynamic-programming skeleton on block–cut trees.

New theorems and proofs
- Theorem 1 (Cycles). For every n≥3, h(C_n)=2.
  Proof. Lower bound: δ(C_n)=2 implies h(C_n)≥2. Upper bound: Fix any vertex u of C_n and shoot u every round (permanent blocker). By the permanent blockers lemma, any surviving walk stays in C_n−{u}≅P_{n−1}. Since h(P_{n−1})=1 (proved previously), a second hunter can run the 1-hunter path schedule on P_{n−1}, yielding capture. Hence h(C_n)≤2, and equality follows.
  Explicit schedule and length: label C_n as 1–2–…–n–1 with 1 fixed as the blocked vertex. The second hunter plays the P_{n−1} sweep on 2–3–…–n, e.g., shots 2,3,…,n−1,n−1,n−2,…,3 (length 2(n−1)−3=2n−5); the combined shots are {1,2},{1,3},…,{1,n−1},{1,n−1},{1,n−2},…,{1,3}.

- Corollary 2 (Unicyclic graphs). If G is connected and has exactly one cycle, then h(G)=2.
  Proof. G contains a cycle, so h(G)≥2 by the k=1 classification. Pick any vertex u on the unique cycle and shoot u every round. Then G−{u} is a forest, and h(G−{u})=1. By the permanent blockers lemma, h(G)≤1+h(G−{u})=2.

- Lemma 3 (Cut-vertex reduction). Let a be a cut vertex of G, and let the components of G−a induce subgraphs H_1,…,H_m with vertex sets V_i∪{a}. Then h(G) ≤ 1 + max_i h(H_i−a).
  Proof. Permanently shoot a. Any avoiding walk remains in G−{a} and hence in some single component H_i−a. The remaining hunter budget applies within that component, so one additional hunter suffices if h(H_i−a)=1, more generally max_i h(H_i−a) hunters suffice. Adding the permanent blocker gives the bound.
  Remarks. This is tight on classical families: for a bouquet of t cycles meeting at a, the bound gives 1+max_i h(C_{n_i}−a)=1+1=2, which equals h of the bouquet by Theorem 1 and the k=1 classification.

- Lemma 4 (Disjoint union). For graphs on disjoint vertex sets, h(G ⊔ H)=max{h(G),h(H)}.
  Proof. Lower bound by subgraph monotonicity. For the upper bound, interleave winning schedules of G and H (padding with idle shots on the other component if needed); R-evolution factorizes over components.

Examples (sanity checks)
- C_7: Using Theorem 1 with u=1 yields a 2-hunter schedule of length 9: {1,2},{1,3},{1,4},{1,5},{1,6},{1,6},{1,5},{1,4},{1,3}. Verification via the R-recursion matches the general path-sweep argument.
- Unicyclic “lollipop” graph: a cycle of length 5 with a long tail; h=2 by Corollary 2. A 2-hunter schedule is: block a chosen cycle vertex; with the second hunter, first clear the tail (path-sweep), then clear the cycle (path-sweep on the cycle minus the blocked vertex).

Algorithmic consequences
- Exact recognition for k=1 is linear (acyclicity). Theorem 1 adds exact recognition on cycles and all unicyclic graphs (again linear-time by cycle detection).
- General sufficient condition: h(G) ≤ fvs(G)+1 (permanent blockers + h(forest)=1). Thus if fvs(G)≤k−1 we can certify YES for h(G)≤k in n^{O(k)} time by enumerating the ≤n^{k−1} candidate blocker sets U and verifying acyclicity of G−U.
- Block–cut skeleton (Lemma 3): For graphs with small “interface budget,” choose a small set of permanently blocked cut vertices and solve independently in components. This yields exact algorithms on classes where components are easy (e.g., forests and cycles), producing n^{O(k)} recognition on graphs whose block–cut tree can be guarded by ≤k permanent blockers.

Clarifications and corrections
- Our earlier plan to settle cycles by “fixed antipodal shots” is false on odd cycles; Theorem 1 uses a single permanent blocker plus a 1-hunter path sweep and works uniformly for all n.
- The inequality h(G) ≤ fvs(G)+1 does not imply h ≤ tw+1, since fvs can exceed tw on disjoint unions of cycles (tw=2, fvs arbitrarily large). Hence a direct reduction from treewidth is not immediate.

Obstacles
- Moving beyond unicyclic/cycle classes, cactus graphs pose a subtle scheduling issue: a single permanent blocker at one articulation confines movement locally, but cycles may attach at multiple cut vertices, so clearing one block while preventing leakage into others may require careful coordination. A global 2-hunter strategy for all cactus graphs is plausible but unproven.
- A general n^{O(k)} algorithm remains open. The time horizon for optimal schedules is not a priori bounded by a polynomial in n for k≥2, and the semigroup of maps R↦N(R)\S has 2^n states, making naive searches infeasible.

Next steps
1) Elevate Theorem 1 and Corollary 2 (with full proofs) into proofs.md; add explicit schedules (parameterized by n) to output.md for reproducibility.
2) Develop a DP on block–cut trees using Lemma 3: states carry (B,t), where B is the subset of cut vertices in the current fringe permanently blocked (|B|≤k), and t the remaining mobile hunters. For components that are cycles or trees, resolve exactly; aggregate up the tree under the budget constraint.
3) Explore cactus graphs with 2 hunters: attempt a depth-first strategy that always blocks the parent cut vertex while using the second hunter to clear the current block (cycle becomes a path). Identify and resolve the leakage issue at child cut vertices; either produce a proof or a counterexample.
4) Broaden sufficient conditions: if the cyclomatic number (|E|−|V|+cc) ≤ k−1 then fvs ≤ k−1 and thus h≤k. Implement this polynomial-time filter and test its tightness empirically on n≤10 to stress the degeneracy-equality conjecture.

Summary
- We proved h(C_n)=2 for all n≥3, via a permanent blocker reducing C_n to a path and the 1-hunter path sweep. As a corollary, all unicyclic graphs have h=2. We formalized a cut-vertex reduction and reaffirmed the disjoint-union identity. These results extend exact recognition to cycles and unicyclic graphs and provide a concrete DP skeleton over block–cut structures, advancing toward n^{O(k)} recognition for broader classes.