{
  "content": "Ideas\n\n- Prove h(C_n)=2 for all n\u22653 using the permanent-blocker lemma plus the 1-hunter path sweep. This settles a central family and provides a reusable design pattern (anchor + local sweep).\n- Generalize the anchor idea via feedback vertex sets: permanently shoot a feedback vertex set F and use one more hunter to sweep each tree component of G\u2212F. This yields an explicit, constructive bound h(G) \u2264 fvs(G)+1 and an n^{O(k)} YES-recognizer on the subclass fvs(G)\u2264k\u22121.\n- Isolate a backward-operator characterization Pre(T):= {R\u2286V : |N(R)\\T|\u2264k}. This gives an exact fixpoint formulation for h(G)\u2264k and suggests compression directions (e.g., focusing on neighborhoods), even if direct iteration over 2^V is infeasible.\n\nNew results (rigorous)\n\nTheorem 1 (Cycles are 2-hunter). For every n\u22653, h(C_n)=2.\nProof. Lower bound: \u03b4(C_n)=2 implies h(C_n)\u22652. Upper bound: Fix a vertex u of the cycle, and shoot u at every round. Any walk avoiding the shots is confined to C_n\u2212{u}=P_{n\u22121}. By the path result h(P_{n\u22121})=1, there exists a 1-hunter schedule X_1,\u2026,X_{2(n\u22121)\u22123} (X_i are singletons) such that the R-evolution R_1:=V\\{u,X_1}, R_{i+1}:=N(R_i)\\{u,X_{i+1}} reaches \u2205. Using two hunters, play S_i={u}\u222aX_i for i=1,\u2026,2(n\u22121)\u22123. If the rabbit starts at u, it is caught at i=1; otherwise it remains in P_{n\u22121} and is caught by the path sweep. Hence h(C_n)\u22642, completing the proof.\n\nProposition 2 (Feedback-vertex-set bound and constructive schedule). Let F\u2286V be a feedback vertex set (G\u2212F is a forest). Then h(G) \u2264 |F|+1. Moreover, there is an explicit schedule of length \u2264 2|V\\F|\u22123\u00b7cc(G\u2212F)+1 that wins.\nProof. Permanently shoot all vertices of F (|F| hunters). The rabbit is then confined to G\u2212F (if it ever occupies F, it is caught immediately). Each component of G\u2212F is a tree. By the h(T)=1 theorem, for each tree component T we have a 1-hunter schedule of length \u2264 2|V(T)|\u22123 that captures any walk within T. Using the remaining one hunter, concatenate these per-component schedules in any order while continuing to shoot F every round. If the rabbit starts in component T_j, it cannot leave T_j without stepping on F (shot every round); thus it is caught during the T_j-phase of the concatenation. Summing the lengths over components and adding the initial round where F is shot yields the claimed total length. Therefore h(G) \u2264 |F|+1.\n\nCorollary 3 (n^{O(k)} YES on small-FVS subclass). If fvs(G) \u2264 k\u22121, then h(G) \u2264 k. This is witnessed by taking F as a feedback vertex set of size \u2264 k\u22121 and applying Proposition 2. In n^{O(k)} time, we can detect such an F by brute-force guessing F (O(n^{k}) subsets) and checking acyclicity of G\u2212F.\n\nPre-operator and fixpoint characterization\n\n- Define Pre_k(T):={R\u2286V: |N(R)\\T|\u2264k}. For any schedule S_1,\u2026,S_t with |S_i|\u2264k, the R-evolution satisfies R_{i+1} \u2208 Pre_k(R_{i+1}) with T=R_{i+1} and R_i arbitrary; conversely, R_{i+1}\u2286T is enforced in one step from R iff R\u2208Pre_k(T).\n- Let F_0={\u2205}, and F_{j+1}:=F_j \u222a Pre_k(F_j), where Pre_k(F):=\u22c3_{T\u2208F} Pre_k(T). Then there exists a winning schedule with k hunters iff \u2203R\u2208F_* and |V\\R|\u2264k, where F_* is the least fixpoint of F\u21a6F \u222a Pre_k(F). This exact formulation isolates the difficulty (state explosion) and suggests compressions by grouping R with identical neighborhoods.\n\nExamples and sanity checks\n\n- Cycles: Theorem 1 resolves all C_n. For n=5, the anchor-at-1 schedule yields a 4-round capture: S_i={1}\u222a{2,3,4,4,3,2}\u2019s path sweep on P_4.\n- Cactus graphs: Choosing one anchor per cycle gives an upper bound, but need not be tight; the 2-hunter cycle schedule shows time-varying shots can beat static anchoring.\n\nObstacles and cautions\n\n- While Pre_k enables a correct fixpoint, a naive implementation is exponential; identifying an n^{O(k)}-sized canonical representative family (e.g., via neighborhoods or important separators) remains open.\n- Extending the anchor+sweep paradigm to prove h(G) \u2264 tw(G)+1 is plausible (maintain adhesion sets as barriers and use one extra hunter to sweep) but nontrivial: safe transitions between separators without exceeding the budget require careful two-step invariants. We leave this as a conjecture/direction.\n\nNext steps (auditable)\n\n1) Elevate Theorem 1 and Proposition 2 to proofs.md with explicit schedules. Implement a verifier that, given F and a per-tree 1-hunter sweep, checks correctness via R_{i+1}=N(R_i)\\S_{i+1}.\n2) n^{O(k)} recognizer on small-FVS subclass: code the brute-force F-search (|F|\u2264k\u22121) and certify YES with the constructed schedule; otherwise fall back to degeneracy/\u03c4 filters.\n3) Pre_k fixpoint compression: attempt to prove that the set of inclusion-minimal elements of F_* has size n^{O(k)} by classifying R via the family N(R) and bounding the number of distinct N(R) that matter. Start with k=2.\n4) Treewidth route: formalize and test the h \u2264 tw+1 conjecture on series\u2013parallel graphs (tw\u22642). Try to construct a 3-hunter schedule via separator barriers and local sweeps; seek a refinement to 2 if possible.\n\nSummary\n\n- We proved h(C_n)=2 for all n\u22653 using a permanent anchor plus the 1-hunter path sweep, closing the cycle family.\n- We established the constructive bound h(G) \u2264 fvs(G)+1 and derived an n^{O(k)} YES-recognizer for graphs with feedback vertex set \u2264 k\u22121.\n- We formulated an exact backward fixpoint characterization via Pre_k(T), a platform for future n^{O(k)} compressions.\n- Immediate, checkable follow-ups: implement/verifiy the cycle schedules and the FVS-based recognizer; explore Pre_k compression for k=2 and separator-based schedules for tw\u22642."
}