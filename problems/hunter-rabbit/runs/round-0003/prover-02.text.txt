Ideas

- Prove h(C_n)=2 for all n≥3 using the permanent-blocker lemma plus the 1-hunter path sweep. This settles a central family and provides a reusable design pattern (anchor + local sweep).
- Generalize the anchor idea via feedback vertex sets: permanently shoot a feedback vertex set F and use one more hunter to sweep each tree component of G−F. This yields an explicit, constructive bound h(G) ≤ fvs(G)+1 and an n^{O(k)} YES-recognizer on the subclass fvs(G)≤k−1.
- Isolate a backward-operator characterization Pre(T):= {R⊆V : |N(R)\T|≤k}. This gives an exact fixpoint formulation for h(G)≤k and suggests compression directions (e.g., focusing on neighborhoods), even if direct iteration over 2^V is infeasible.

New results (rigorous)

Theorem 1 (Cycles are 2-hunter). For every n≥3, h(C_n)=2.
Proof. Lower bound: δ(C_n)=2 implies h(C_n)≥2. Upper bound: Fix a vertex u of the cycle, and shoot u at every round. Any walk avoiding the shots is confined to C_n−{u}=P_{n−1}. By the path result h(P_{n−1})=1, there exists a 1-hunter schedule X_1,…,X_{2(n−1)−3} (X_i are singletons) such that the R-evolution R_1:=V\{u,X_1}, R_{i+1}:=N(R_i)\{u,X_{i+1}} reaches ∅. Using two hunters, play S_i={u}∪X_i for i=1,…,2(n−1)−3. If the rabbit starts at u, it is caught at i=1; otherwise it remains in P_{n−1} and is caught by the path sweep. Hence h(C_n)≤2, completing the proof.

Proposition 2 (Feedback-vertex-set bound and constructive schedule). Let F⊆V be a feedback vertex set (G−F is a forest). Then h(G) ≤ |F|+1. Moreover, there is an explicit schedule of length ≤ 2|V\F|−3·cc(G−F)+1 that wins.
Proof. Permanently shoot all vertices of F (|F| hunters). The rabbit is then confined to G−F (if it ever occupies F, it is caught immediately). Each component of G−F is a tree. By the h(T)=1 theorem, for each tree component T we have a 1-hunter schedule of length ≤ 2|V(T)|−3 that captures any walk within T. Using the remaining one hunter, concatenate these per-component schedules in any order while continuing to shoot F every round. If the rabbit starts in component T_j, it cannot leave T_j without stepping on F (shot every round); thus it is caught during the T_j-phase of the concatenation. Summing the lengths over components and adding the initial round where F is shot yields the claimed total length. Therefore h(G) ≤ |F|+1.

Corollary 3 (n^{O(k)} YES on small-FVS subclass). If fvs(G) ≤ k−1, then h(G) ≤ k. This is witnessed by taking F as a feedback vertex set of size ≤ k−1 and applying Proposition 2. In n^{O(k)} time, we can detect such an F by brute-force guessing F (O(n^{k}) subsets) and checking acyclicity of G−F.

Pre-operator and fixpoint characterization

- Define Pre_k(T):={R⊆V: |N(R)\T|≤k}. For any schedule S_1,…,S_t with |S_i|≤k, the R-evolution satisfies R_{i+1} ∈ Pre_k(R_{i+1}) with T=R_{i+1} and R_i arbitrary; conversely, R_{i+1}⊆T is enforced in one step from R iff R∈Pre_k(T).
- Let F_0={∅}, and F_{j+1}:=F_j ∪ Pre_k(F_j), where Pre_k(F):=⋃_{T∈F} Pre_k(T). Then there exists a winning schedule with k hunters iff ∃R∈F_* and |V\R|≤k, where F_* is the least fixpoint of F↦F ∪ Pre_k(F). This exact formulation isolates the difficulty (state explosion) and suggests compressions by grouping R with identical neighborhoods.

Examples and sanity checks

- Cycles: Theorem 1 resolves all C_n. For n=5, the anchor-at-1 schedule yields a 4-round capture: S_i={1}∪{2,3,4,4,3,2}’s path sweep on P_4.
- Cactus graphs: Choosing one anchor per cycle gives an upper bound, but need not be tight; the 2-hunter cycle schedule shows time-varying shots can beat static anchoring.

Obstacles and cautions

- While Pre_k enables a correct fixpoint, a naive implementation is exponential; identifying an n^{O(k)}-sized canonical representative family (e.g., via neighborhoods or important separators) remains open.
- Extending the anchor+sweep paradigm to prove h(G) ≤ tw(G)+1 is plausible (maintain adhesion sets as barriers and use one extra hunter to sweep) but nontrivial: safe transitions between separators without exceeding the budget require careful two-step invariants. We leave this as a conjecture/direction.

Next steps (auditable)

1) Elevate Theorem 1 and Proposition 2 to proofs.md with explicit schedules. Implement a verifier that, given F and a per-tree 1-hunter sweep, checks correctness via R_{i+1}=N(R_i)\S_{i+1}.
2) n^{O(k)} recognizer on small-FVS subclass: code the brute-force F-search (|F|≤k−1) and certify YES with the constructed schedule; otherwise fall back to degeneracy/τ filters.
3) Pre_k fixpoint compression: attempt to prove that the set of inclusion-minimal elements of F_* has size n^{O(k)} by classifying R via the family N(R) and bounding the number of distinct N(R) that matter. Start with k=2.
4) Treewidth route: formalize and test the h ≤ tw+1 conjecture on series–parallel graphs (tw≤2). Try to construct a 3-hunter schedule via separator barriers and local sweeps; seek a refinement to 2 if possible.

Summary

- We proved h(C_n)=2 for all n≥3 using a permanent anchor plus the 1-hunter path sweep, closing the cycle family.
- We established the constructive bound h(G) ≤ fvs(G)+1 and derived an n^{O(k)} YES-recognizer for graphs with feedback vertex set ≤ k−1.
- We formulated an exact backward fixpoint characterization via Pre_k(T), a platform for future n^{O(k)} compressions.
- Immediate, checkable follow-ups: implement/verifiy the cycle schedules and the FVS-based recognizer; explore Pre_k compression for k=2 and separator-based schedules for tw≤2.