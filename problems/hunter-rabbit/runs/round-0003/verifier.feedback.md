Good progress: several claims can now be considered settled and promotable to proofs.md. Specifically, cycles are resolved (h(C_n)=2) via the permanent-blocker lemma plus the k=1 forest classification; unicyclic graphs consequently have h=2; disjoint unions behave as h(⊔)=max; and a clean cut-vertex reduction follows from permanent blockers + disjoint union. These are consistent with the R-recursion and with our earlier path result h(P_n)=1.

Targeted critiques and fixes:
- Prover 1: The cycle proof via a permanent blocker plus the path sweep is correct. The cut-vertex lemma h(G) ≤ 1 + max_i h(component) is right (formally: block the cut vertex; h on the disjoint union of components is the max). Avoid embedding extra schedule-length claims in formal statements; keep them in notes unless proven for all trees. The block–cut DP idea is promising; specify states and transitions next.
- Prover 2: The cycle theorem is correct. The FVS bound h(G) ≤ fvs(G)+1 with an explicit constructive schedule is sound; however, your length bound (2|V\F|−3·cc + 1) is not yet justified for arbitrary trees (we only proved a 2|T|−1 bound for trees, and 2|T|−3 for paths). Please either prove the stronger bound for trees or state the weaker bound formally. The Pre_k fixpoint is a useful exact characterization; keep it in notes until a compressed representation is proved.
- Prover 3: Excellent: permanent-blockers lemma is now fully formal, and the cycle theorem leverages the k=1 classification rigorously. Keep explicit schedule templates in notes, not in proofs, unless fully parameterized and checked.
- Prover 4: The formalizations this round align with the accepted arguments; crucially, you no longer rely on the (false) monotonicity of the Z-process. The unicyclic theorem is correct as stated.

Next steps:
1) Implement and analyze an n^{O(k)} recognizer on graphs with fvs ≤ k−1 (enumerate U, block U, and run the 1-hunter forest schedule). 2) Formalize a block–cut DP with permanent blockers on chosen cut vertices and exact solvers on tree/cycle blocks. 3) Tackle cactus graphs for k=2 (prove h(G)=2 or find counterexamples). 4) Explore separator-based DP toward general n^{O(k)} or prove hardness for k=2. 5) Validate Pre_k compression for k=2 by bounding the number of distinct relevant neighborhoods.