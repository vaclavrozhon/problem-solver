{
  "content": "Ideas\n- Extend our 2-hunter toolkit beyond cycles by introducing an anchor-transfer lemma and a targeted funneling lemma on trees. Use them to solve a nontrivial cactus subclass: necklaces (block\u2013cut tree is a path, each block is a cycle; pendant trees are allowed). This yields explicit schedules and linear-time recognition for h\u22642 on that class.\n- Provide a rigorous proof of the periodic-lift criterion for repeated schedules (useful for verifying families of periodic strategies by finite acyclicity checks).\n\nLemmas and proofs\n- Lemma 1 (Targeted funneling on trees with one hunter). Let T be a tree and v\u2208V(T) a designated target. There exists a 1\u2011hunter schedule S (dependent on v) such that, starting from R_1=V\\S_1 and R_{i+1}=N(R_i)\\S_{i+1}, one reaches a time t with R_t\u2286{v} (hence one more shot at v captures).\n  Proof. Root T at v. Iteratively delete leaves \u2113\u2260v by shooting their parent u twice in consecutive rounds. The key invariant (proved and used in the forest classification) is: for any leaf \u2113 with neighbor u and any set X, one has \u2113\u2209N(N(X)\\{u}); thus after two shots at u, \u2113 is excluded and never reappears. By repeating this for all leaves distinct from v, we obtain a schedule of length 2(|V(T)|\u22121) that maps the dynamics on T to the dynamics on the single vertex {v}, i.e., R_t\u2286{v}. One additional shot at v captures. This construction specializes to paths and yields steering to any chosen vertex.\n\n- Lemma 2 (Anchor transfer). Let a be a cut vertex in G, and let H be the component of G\u2212{a} that contains a neighbor b of a. Suppose at some time i we have R_i\u2286H\u222a{a}. Then the round i+1 shot S_{i+1}={a,b} enforces R_{i+1}\u2286H\u2032, where H\u2032 is the component of G\u2212{b} that contains H (i.e., we may thereafter treat b as the new anchor and regard the \u201cleft of a\u201d side as sealed). In particular, nothing can cross from H to G\u2212H in that round, and no survivor remains at a or b.\n  Proof. By definition, R_{i+1}=N(R_i)\\{a,b}. Since R_i\u2286H\u222a{a} and all edges from H to G\u2212H go through a, any move from H to G\u2212H must pass through a, which is shot. Hence no vertex outside H\u222a{a} is reached. Within H, every neighbor of b that enters b is eliminated (b\u2208S_{i+1}). Thus R_{i+1}\u2286H\\{b}, the component of G\u2212{b} that contains H, establishing the transfer. Symmetrically, one can transfer back by a shot {a,b} when R is confined to the appropriate side relative to b.\n\n- Lemma 3 (Periodic lift criterion). Fix p\u22651 and a period\u2011p schedule (S_1,\u2026,S_p) repeated indefinitely. Form the time\u2011lift L_p with vertex set V\u00d7{1,\u2026,p} and directed edges (x,t)\u2192(y,t+1 mod p) whenever xy\u2208E(G), and remove all (v,t) with v\u2208S_t. The repeated schedule is winning (i.e., for some T, R_T=\u2205 starting from R_1=V\\S_1) if and only if the surviving directed graph L_p is acyclic.\n  Proof. Forward: If L_p has a directed cycle, then by mapping cycles to time\u2011labels, there exists an infinite biinfinite walk respecting the shots; projecting layer indices gives an infinite rabbit walk avoiding capture, contradicting winning. Backward: If L_p is acyclic, topologically sort its vertices and note that along R_{i+1}=N(R_i)\\S_{i+1}, the maximum topological level of any member of R strictly decreases every round (levels are considered modulo p via layer indices). Since the level set is finite, after at most |V|\u00b7p steps R becomes empty. Equivalently, there is no infinite allowable walk.\n\nMain theorem (new class solved)\n- Theorem 4 (Two hunters suffice on necklaces). Let G be a cactus whose block\u2013cut tree is a path; i.e., G consists of cycles C_1,\u2026,C_m arranged linearly (neighbors share a single articulation vertex), possibly with pendant trees attached to cycle vertices. Then h(G)=2.\n  Proof. Lower bound: If m\u22651 then G contains a cycle, so h(G)\u22652 by the k=1 classification. For the upper bound, root the block\u2013cut path at C_1 and let x_i denote the unique articulation between C_i and C_{i+1} (for i=1,\u2026,m\u22121). We construct a 2\u2011hunter schedule using an invariant \u201canchored side\u201d and Lemmas 1\u20132.\n  Initialization: Choose a_1 to be any vertex of C_1 if m=1; otherwise choose a_1 to be any neighbor of x_1 on C_1. Hunter A shoots a_1 every round until instructed otherwise. Hunter B is mobile.\n  Inductive invariant at block i (1\u2264i\u2264m): Before processing C_i, (I1) A is anchored at a_i\u2208V(C_i) that lies on the articulation side toward C_{i\u22121} (for i=1 take a_1 as above), and (I2) R is contained in the suffix subgraph consisting of C_i together with C_{i+1},\u2026,C_m and all their pendant trees. The base case holds trivially for i=1.\n  Processing C_i:\n  \u2022 Consider the path P_i:=C_i\u2212{a_i}. Choose a target y_i\u2208V(P_i) as follows: if i<m, set y_i:=x_i (the articulation to C_{i+1}); if i=m, choose any y_m\u2208V(P_m).\n  \u2022 While A keeps shooting a_i, have B run the 1\u2011hunter targeted funneling schedule from Lemma 1 on P_i toward y_i (interpreting pendant trees attached to P_i as part of a tree; funneling ignores branches by leaf deletions). After finitely many rounds, R\u2229V(P_i)\u2286{y_i}. In particular, no survivor in C_i lies outside {a_i,y_i}.\n  \u2022 If i<m, perform one anchor\u2011transfer round with S={a_i,y_i} (Lemma 2), thereby moving the anchor to a_{i+1}:=y_i and preserving the suffix invariant (I2) with i replaced by i+1. If i=m, shoot y_m; this captures all survivors in C_m\u2212{a_m}, and any survivor at a_m must move (with A shooting a_m every round) into C_m\u2212{a_m} where it is then funneled to y_m and captured. Thus the process terminates.\n  Correctness: By induction, after processing C_i we maintain (I1)\u2013(I2) for i+1 until i=m, when capture occurs. Pendant trees do not obstruct funneling because Lemma 1 holds on trees and we never allow passage to the left of the current anchor (Lemma 2 guarantees safe transfers). Hence two hunters suffice. Together with the lower bound, h(G)=2.\n  Schedule length: Each funneling step on P_i takes O(|P_i|+size of pendant trees incident to C_i) rounds, and each transfer costs one round. Total length is O(|V|).\n\nCorollaries and algorithmic consequences\n- Corollary 5 (Linear-time recognition and schedules on necklaces). Given a necklace G, h(G)=2 if and only if G contains a cycle (else h=1). The above constructive proof yields an O(n)-length 2\u2011hunter schedule computable in O(n) time by traversing the block\u2013cut path.\n- The targeted funneling lemma (Lemma 1) also yields a simple proof that h(C_n)=2 (choose any anchor a and target either neighbor on C_n\u2212{a}) and generalizes our earlier unicyclic h=2 proof in a unified way.\n\nExamples (sanity checks)\n- Two cycles in series. Let C_1 share x_1 with C_2. Anchor at a_1 adjacent to x_1 in C_1. Funnel C_1\u2212{a_1} to y_1=x_1, transfer with S={a_1,x_1} to anchor at x_1, then funnel C_2\u2212{x_1} to some y_2 and shoot y_2. Hunters and set\u2011evolution computations on small instances (e.g., two C_5\u2019s) match the general argument.\n- Pendant trees. A C_6 with paths attached to two distinct vertices is cleared by anchoring at a_1 and applying the tree\u2011aware funnel on P_1=C_6\u2212{a_1}: pendant branches are peeled by double\u2011shots at their attachment neighbors as part of the funnel to the chosen y_1, consistent with Lemma 1.\n\nObstacles and limits\n- General cactus graphs (block\u2013cut tree a tree) are subtler: processing a child cycle while preserving a barrier at the parent articulation seems to require temporary dual anchoring; our 2\u2011hunter method uses a one\u2011round double\u2011shot {parent,child} to transfer the anchor but cannot keep both anchored while sweeping the entirety of a child subgraph. Extending the necklace proof to general cactus requires a more global invariant or a refined steering that ensures the state R resides entirely in the child side at transfer times and does not \u201cleak back\u201d during recursive clears of siblings; this remains open.\n- For block graphs with large cliques, two hunters are insufficient in general (h(K_r)=r\u22121), so different composition principles are needed; exploring whether h(G)=\u03c9(G)\u22121 holds for block graphs (or more generally chordal) remains a promising, tractable subproblem.\n\nNext steps\n- Formalize and add to proofs.md: Lemma 1 (targeted funneling), Lemma 2 (anchor transfer), Lemma 3 (periodic lift), and Theorem 4 (necklaces h=2) with detailed inductive invariants.\n- Extend from necklaces to all cactus graphs: develop a DFS schedule that uses anchor transfers at carefully chosen times when R is provably confined to the processed subtree; either supply the steering invariants or identify a counterexample.\n- Implement a linear\u2011time recognizer for h\u22642 on necklaces and unicyclic graphs (already implied), and a generator of the explicit schedules.\n- Use the periodic\u2011lift criterion to search for bounded\u2011period winning schedules for small k on broader classes (outerplanar, series\u2011parallel), which may yield n^{O(k)} recognizers by checking acyclicity on a finite lift.\n- Explore block graphs: attempt a proof that h(G)=\u03c9(G)\u22121 for block graphs via \u201cpush\u2011to\u2011parent\u201d shots within cliques, or produce a minimal counterexample.\n\nSummary of progress\n- Introduced and proved two key tools: targeted funneling on trees with one hunter and the anchor\u2011transfer round. Using these, proved that two hunters suffice for all necklace cacti (cycles in series with pendant trees), with explicit O(n) schedules and linear\u2011time recognition. Also provided a rigorous periodic\u2011lift criterion for periodic schedules. This extends the exact landscape beyond cycles/unicyclic to a broader class, and clarifies the structural requirements for managing separators with two hunters."
}