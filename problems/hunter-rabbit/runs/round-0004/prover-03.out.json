{
  "content": "Ideas\n- Establish an upper bound h(G) \u2264 pw(G)+1 via a coupling to classical node-search. This yields immediate n^{O(1)} recognition for fixed k on graphs with pathwidth \u2264 k\u22121, and more generally an FPT acceptance test in k.\n- Strengthen bounds for sparse classes: prove that every cactus graph satisfies h(G) \u2264 3 by a constructive DFS-style schedule using two \u201canchors\u201d plus one sweeper. This improves over the generic fvs+1 bound when the number of cycles is large.\n- Formalize the least-fixpoint characterization of \u201cwinnable\u201d state sets and prove downward-closure; this supports DP designs (over decompositions) that carry only antichains of boundary states.\n\nFixpoint view and downward-closure\nDefine the one-step successor operator on subsets R\u2286V by Succ_k(R):={ N(R)\\S : S\u2286V, |S|\u2264k }. Let Good_k be the least set family containing \u2205 and closed under the rule X\u2208Good_k if \u2203S with |S|\u2264k and N(X)\\S \u2208 Good_k. Equivalently, Good_k = \u22c3_{t\u22650} G_t where G_0={\u2205} and G_{t+1}={ X : \u2203S, |S|\u2264k, N(X)\\S \u2208 G_t }.\n- Lemma 1 (Downward-closure). Good_k is downward-closed: if X\u2208Good_k and Y\u2286X then Y\u2208Good_k.\nProof. By induction on the level t where X\u2208G_t. For t=0, X=\u2205 and the claim is trivial. For t>0, X\u2208G_t means \u2203S s.t. N(X)\\S \u2208 G_{t\u22121}. For Y\u2286X we have N(Y)\u2286N(X), so N(Y)\\S \u2286 N(X)\\S. By IH and downward-closure of G_{t\u22121}, N(Y)\\S \u2208 G_{t\u22121}, hence Y\u2208G_t. \u220e\n- Observation. h(G)\u2264k iff V\u2208Good_k.\nThis recasts decision into membership of V in the least fixpoint of a monotone operator; the downward-closure supports antichain-based DP representations on decompositions (next steps).\n\nUpper bound via node-search and pathwidth\nWe use the classical invisible fast robber node-search game: at each discrete time i, a set S_i of occupied vertices is chosen (|S_i| bounded by s), and the robber, moving arbitrarily fast along paths avoiding S_i, must eventually be placed upon by a searcher. Let C_i be the set of vertices the robber might occupy at time i under schedule S_1,\u2026,S_i. One standard formulation yields C_1=V\\S_1 and C_{i+1} = reach_{G\\S_{i+1}}(C_i), where reach takes the union of connected components intersecting C_i.\n- Lemma 2 (Coupling). Given any node-search schedule (S_i) with |S_i|\u2264s and C_T=\u2205, the same sequence (S_i) is a winning hunters schedule with k=s: defining R_1=V\\S_1 and R_{i+1}=N(R_i)\\S_{i+1}, we have R_i\u2286C_i for all i, hence R_T=\u2205.\nProof. Induction: R_1=C_1. If R_i\u2286C_i, then R_{i+1}=N(R_i)\\S_{i+1} \u2286 N(C_i)\\S_{i+1} \u2286 reach_{G\\S_{i+1}}(C_i)=C_{i+1}. \u220e\n- Theorem 3 (Pathwidth bound). h(G) \u2264 pw(G)+1.\nProof. It is known that the node-search number equals pw(G)+1 and that there is a monotone capturing schedule with s=pw(G)+1 searchers (see, e.g., Kinnersley (1992), Fomin\u2013Thilikos (2008)). Apply Lemma 2. \u220e\nCorollaries.\n- Series\u2013parallel graphs (tw\u22642 \u21d2 pw\u22642): h(G) \u2264 3. Outerplanar graphs also have pw\u22642, hence h\u22643.\n- For fixed k, deciding h(G)\u2264k is polynomial-time on the class pw(G)\u2264k\u22121 (use any FPT test for pw\u2264k\u22121 and accept).\n\nCactus graphs: a constructive 3-hunter strategy\nLet G be a connected cactus graph (each block is a cycle or an edge; blocks form a tree via articulation vertices).\n- Theorem 4. h(G) \u2264 3.\nProof (constructive; invariant-based). Root the block\u2013cut tree at an arbitrary articulation r. We maintain a DFS invariant: at any time we keep two \u201canchors\u201d a,b (both shot every round), which are articulation vertices lying in the current block B on the DFS path (for the root, set a=r and choose b an articulation of the root block; if the root block is an edge {r,b}, pick its other endpoint). The third hunter (the sweeper) operates within B\\{a,b} and possibly within child subtrees when descending. We use two primitives:\n(1) Block cleaning. For an edge-block B={x,y}, if {x,y} are the two anchors, nothing remains to clean. For a cycle-block B containing anchors a,b, the subgraph B\\{a,b} is a disjoint union of two paths P_1,P_2 whose endpoints are a,b. Keeping a and b permanently shot, the third hunter performs a 1-hunter sweep on P_1 then on P_2 (forests admit 1-hunter capture). During this, any evasion flow between B\u2019s \u201cparent side\u201d and \u201cchild sides\u201d must traverse a or b, which are blocked each round, preventing recontamination across these cuts.\n(2) Anchor handover. Suppose B has been cleaned. To descend into a child block B\u2032 attached at articulation b, pick an articulation b\u2032\u2208B\u2032 adjacent to b (if B\u2032 is an edge, take its other endpoint; if B\u2032 is a cycle, pick any neighbor of b along the cycle). In the next rounds, we switch anchors from {a,b} to {b,b\u2032}: since b lies on every path from below B\u2032 to above a, maintaining b blocked preserves separation; therefore releasing a is safe once b\u2032 is established as the second anchor. The sweeper is idle during the single round when anchors change; no contamination can bypass b.\nProceed by DFS: at each block, perform (1); then for each child block, perform (2) to descend, and recurse. On backtracking from a child subtree rooted at b\u2032, reverse the handover to re-establish anchors {a,b} in B (again safe by the same separator argument). Since the block\u2013cut tree is finite, this process terminates; at leaves, after block cleaning no child remains, and recursive returns propagate. Because at every stage any movement between already processed parts and unprocessed parts is cut by currently shot anchors, no recontamination reaches cleaned areas. Eventually the sweeper clears the unique subtree containing the evader, and capture occurs. \u220e\nRemarks. The proof makes essential use of the cactus property (blocks are cycles/edges; separators are single articulations). We do not claim tightness of 3; whether all cactus graphs satisfy h(G)=2 remains open. The DFS scheme above immediately yields h(G)\u22643\u00b7cc(BCT) in schedule length O(n).\n\nCut-vertex composition (tight bounds)\nLet a be a cut vertex of G and C_1,\u2026,C_m the vertex sets of the components of G\u2212a.\n- Lemma 5. max_i h(G[C_i\u222a{a}]) \u2264 h(G) \u2264 1 + max_i h(G[C_i\u222a{a}]).\nProof. Lower bound by subgraph monotonicity. Upper bound: permanently shoot a and run, component by component, a winning schedule inside G[C_i] (1-hunter suffices for trees; use appropriate k for general), which is independent across components since a blocks traversal. \u220e\n\nExamples\n- Series\u2013parallel ladder L_n: pw(L_n)=2, hence h(L_n)\u22643. Degeneracy=2, so 2\u2264h(L_n)\u22643.\n- \u201cDumbbell\u201d C_\u2113\u2014P_m\u2014C_r: By Theorem 3, h\u22643. Our 2-hunter attempt with a moving anchor may recontaminate; enumerating minimal obstructions for h\u22642 on small n will clarify whether some dumbbells require 3.\n\nObstacles\n- Exact DP for h\u2264k on general tw-bounded graphs: while Good_k is downward-closed and amenable to antichain compression on a bag, we still need a clean interface condition to compose subgraphs across introduce/forget/join nodes. A precise state, likely a family of \u201clocally winnable\u201d boundary subsets closed under one-step Pre_k, must be designed and its width bounded by a function of (k,tw).\n- Tightness on cactus and outerplanar graphs: whether h\u22642 always (or characterize when h=3) remains unsettled.\n\nNext steps\n1) Promote Theorem 3 (h\u2264pw+1) and Lemma 2 (coupling) to proofs.md with citations; add corollaries for pw\u22642 classes.\n2) Formalize Theorem 4\u2019s DFS invariant with explicit R-evolution inequalities at handover rounds, and test on generated cactus instances up to n=14; search for a cactus with h=3 to probe tightness.\n3) Design a DP state for nice tree decompositions: per bag B, carry an antichain F_B\u22862^B such that X\u2208F_B iff X is \u201cgood\u201d for the partial graph with boundary B under k; derive introduce/forget/join transitions using the Good_k one-step rule and prove F_B sizes bounded by f(k,|B|).\n4) Enumerate minimal obstructions for h\u22642 up to n=10 via the 2^V-state BFS to guide cactus/outerplanar conjectures.\n\nSummary of new rigor\n- Good_k fixpoint with downward-closure (Lemma 1).\n- Coupling to node-search implies h(G) \u2264 pw(G)+1 (Theorem 3) and yields polynomial-time recognition for fixed k on pw\u2264k\u22121 classes.\n- Constructive schedule showing every cactus graph satisfies h(G)\u22643 (Theorem 4) via two permanent anchors plus a 1-hunter sweeper and safe anchor handovers.\n- Cut-vertex composition bounds (Lemma 5) provide tight local reductions and support a block\u2013cut DP agenda."
}