=== SYSTEM ===
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md, proofs.md, and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (informal progress & exploratory work so far)
- proofs.md (rigorous proofs & detailed mathematics so far)
- output.md (main results found so far)

**Three-tier file system guidelines**:
- **notes.md**: Readable, log of exploratory work, intuitions, failed attempts, ideas. Prefer appending. Replace only if old notes are clearly misleading. It should be self-contained: In particular, reading it should make sense without knowing the output of provers in past rounds. 

- **proofs.md**: Complete rigorous mathematical proofs with full details. Think twice before adding anything. Contains proven lemmas, theorems, and detailed derivations. Only add mathematically verified content here.
- **output.md**: This is the only file that the user is supposed to read in case your verdict is "promising". It has to be self-contained. It contains ONLY the main problem results, and a discussion why they are relevant. It is extremely selective. Think twice before promoting proofs from proofs.md to output.md. Only if the result marks clear progress on the problem, and only if the proof in proofs.md has been thoroughly vetted by provers and you, it can join output.md. Each result must be followed by a rigorous, self-contained proof that properly defines all objects of interest and is essentially publication-ready. 

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (≥200 words). Include concrete next-step suggestions.",
  "summary_md": "Concise summary of this round's work for summarizer.",
  "verdict": "promising|uncertain|unlikely",
  "blocking_issues": ["List of issues preventing progress"],
  "per_prover": [{"prover_id": "01", "brief_feedback": "feedback", "score": "promising|uncertain|unlikely"}],
  "notes_update": {"action": "append|replace", "content": "Markdown for notes.md"},
  "proofs_update": {"action": "append|replace", "content": "Markdown for proofs.md"}, 
  "output_update": {"action": "append|replace", "content": "Markdown for output.md"}
}

**Verdict definitions**:
- **promising**: Significant mathematical progress, publishable results
- **uncertain**: Some progress you deem nontrivial, but with unresolved issues or incomplete reasoning  
- **unlikely**: No meaningful progress, fundamentally flawed approaches, or just exploratory work

**Update guidelines**:
- Use null for any update field you don't want to modify
- notes_update: Include informal reasoning, failed attempts, intuitions, exploratory work
- proofs_update: Only include complete, rigorous proofs that you have verified
- output_update: Only include main problem results that directly advance toward the solution


=== USER ===
=== Task (txt) ===

Definitions.
• The hunters and rabbit problem is a pursuit-evasion game played
on an undirected graph. A strategy for k hunters is a sequence
s1, s2, · · · , sn of subsets of k vertices. A strategy is winning if, for
every walk v1, v2, · · · , vn in the graph (not necessarily simple), there
is i such that vi ∈ si. Intuitively, the evader is walking on the graph
(it has to move at each turn by following exactly one edge) and must
avoid the k vertices that the pursuers examine at each time step.

• The evasion number of a graph G is the smallest k for which there
is a winning strategy with k hunters.

Question: Is it the case that, for any constant k , we can recognize
the graphs of the evasion number k in polynomial time? (E.g. n^{O(k)})


=== Notes ===

# Research Notes



Working definitions and dynamics
- We fix the open-neighborhood operator N(X)=⋃_{x∈X}N(x). For a schedule S_1, …, S_t (|S_i|≤k), define R_1:=V\S_1 and R_{i+1}:=N(R_i)\S_{i+1}. The schedule is winning up to horizon t iff R_t=∅. Equivalently, using P_1:=V and P_{i+1}:=N(P_i\S_i), the schedule wins iff P_{t+1}=∅. These are equivalent formulations under an index shift.

Verified results we will use
- Subgraph monotonicity: If H⊆G then h(H)≤h(G).
- Upper bound: h(G)≤τ(G) by shooting a minimum vertex cover twice (capture by time 2).
- Lower bounds: h(G)≥δ(G); therefore h(G)≥degeneracy(G). Also, if G contains K_{s,t} as a subgraph then h(G)≥min{s,t}.
- Exact values: h(K_n)=n−1; h(K_{p,q})=min{p,q}. For cycles, h(C_3)=2 (clique), h(C_4)=2; for C_5 a concrete 4-round schedule with k=2 succeeds (see proofs.md). The claim that two fixed antipodal shots per round win on all cycles is false for odd n.

Corrections to earlier claims
- The statement h(K_n)=n is incorrect; n−1 hunters suffice (and are necessary by δ(K_n)=n−1).
- The 1-hunter impossibility on P_n for n≥4 is false; e.g., P_4 has an explicit 1-hunter winning schedule. A general proof that h(P_n)=1 appears feasible but is not yet written.
- The assertion that the decision problem is in NP lacks a bound on schedule length; a priori, a winning schedule may require exponentially many rounds.

Concrete example (cycles)
- C_5 with k=2: S_1={1,3}, S_2={4,5}, S_3={2,4}, S_4={1,4} yields R_1={2,4,5}, R_2={1,3}, R_3={5}, R_4=∅. Thus h(C_5)≤2. For odd cycles, fixed pairs per round do not suffice; schedules must change over time.

Algorithmic consequences (current)
- Fast NO: if degeneracy(G)>k or ω(G)≥k+2 then h(G)>k.
- Fast YES: if τ(G)≤k then h(G)≤k (via FPT vertex-cover).
- These give n^{O(k)} filters but do not settle all instances.

Open targets and next steps
1) Prove h(C_n)=2 for all n≥3 (and record a general schedule). 2) Settle k=1: prove or refute “h(G)=1 iff G is a forest.” 3) Investigate structural upper bounds: does h(G)≤tw(G)? A positive answer implies polynomial recognition for fixed k. 4) Design a separator-based DP that simulates R-evolution with states depending only on boundary sets of size ≤k. 5) Empirically compute h on small graphs (n≤10) and all trees up to n≈12 to test the degeneracy-equality conjecture and discover obstructions.

New validated tools and results
- Permanent blockers. If U⊆V is shot every round, any avoiding walk stays in G−U, hence h(G) ≤ |U|+h(G−U). This enables reductions via feedback vertex sets and other separators.
- Disjoint unions. For graphs on disjoint vertex sets, h(G ⊔ H)=max{h(G),h(H)}. A concatenation of winning schedules for components suffices.
- Paths. A 1-hunter “forward/backward sweep” of length 2n−3 (shots 1,2,…,n−1,n−1,n−2,…,2) wins on P_n; a parity-invariant proof verifies R_{2n−3}=∅.
- k=1 classification. h(G)=1 iff G is a forest. Proof: cycles force ≥2 by δ=2; for forests, an inductive schedule repeatedly shoots a neighbor u of a leaf ℓ twice, then recurses on T−ℓ. A key fact: for any X and leaf ℓ with neighbor u, ℓ∉N(N(X)\{u}). This ensures ℓ never reappears in R after the double-shot.
- Cycles. Explicit 2-hunter captures verified on C_5 and C_6; odd cycles require time-varying shots. A uniform proof h(C_n)=2 for all n remains open.

Corrections and cautions
- The “Z-process” identity R_i=V\(Z_i∪S_i) with Z_{i+1}={v:N(v)⊆Z_i∪S_i} holds, but Z_i need not be monotone. Arguments relying on Z-monotonicity (e.g., h=degeneracy proof) are invalid.

Algorithmic implications (current)
- Exact k=1 recognition in linear time via acyclicity. For general k, fast filters: if degeneracy(G)>k (or ω(G)≥k+2), then NO; if τ(G)≤k, then YES (2-round capture using a vertex cover).
- Permanent blockers yield: if fvs(G)≤k−1 and h(forest)=1 (proved), then h(G)≤k, giving an n^{O(k)} recognition on that subclass by enumerating U (|U|≤k−1).

Next steps
1) Settle cycles: prove h(C_n)=2 for all n (start with exhaustive R-set BFS on C_7). 2) Formalize a separator-based DP that simulates R_{i+1}=N(R_i)\S_{i+1} across small boundaries (treewidth/FVS). 3) Evaluate the degeneracy-equality conjecture empirically on n≤10 and either prove or refute it. 4) Pursue either h≤tw (positive algorithmic route) or hardness for k=2 (layered gadgets) as a decisive direction on the main question.

Updates and clarifications

- Conventions: A k-hunter schedule is a sequence (S_1, …, S_t) with |S_i| ≤ k. We use t for the horizon and n=|V|.
- Dynamics: Define R_1:=V\S_1 and R_{i+1}:=N(R_i)\S_{i+1}. Equivalently, P_1:=V and P_{i+1}:=N(P_i\S_i). Then R_t=∅ iff P_{t+1}=∅; moreover, R_t = P_t\S_t and P_{t+1} = N(R_t) (easy induction).
- Z-process identity: With Z_1:=∅ and Z_{i+1}:={v : N(v)⊆Z_i∪S_i}, one has R_i = V\(Z_i∪S_i) for all i. Caution: (Z_i) need not be monotone. Example: on P_4 with S_1={3}, S_2={2}, one checks 4∈Z_2 but 4∉Z_3.

Validated tools
- Subgraph monotonicity: If H⊆G, then h(H) ≤ h(G).
- Lower bounds: h(G) ≥ δ(G); hence h(G) ≥ degeneracy(G) by subgraph monotonicity.
- Upper bound: h(G) ≤ τ(G) (two rounds shooting a vertex cover).
- Disjoint unions: h(G ⊔ H)=max{h(G), h(H)}.
- Permanent blockers: If U⊆V is shot every round, any evading walk stays in G−U; thus h(G) ≤ |U| + h(G−U).
- Separator composition: If G is obtained by gluing pieces along S, then h(G) ≤ |S| + max_i h(piece_i).
- Exact values: h(K_n)=n−1; h(K_{p,q})=min{p,q}.
- Periodic lifts: A period-p schedule (repeated) is winning iff the cyclic time-lift L_p, after removing per-layer shots, is acyclic (gives a finite capture horizon ≤ n·p).

Corrections and open items
- Minor-monotonicity is unproven; the edge-contraction proof attempt fails because an H-walk through the contracted vertex need not lift to a G-walk of the same length while avoiding the shots. Do not assume {h≤k} is minor-closed.
- The claim h(G)=1 iff G is a forest is not yet rigorously established. The leaf double-shot invariant ensures exclusion after exactly two steps but does not imply the leaf never reappears later. A complete proof (or counterexample) is needed.
- Cycles: We have explicit small schedules for C_5, C_6. A uniform proof h(C_n)=2 can follow from a complete proof that h(P_m)=1; alternatively, provide a direct 2-hunter schedule.
- Unicyclic graphs: The statement h(G)=2 for fvs(G)=1 depends on the (currently unproven) forest case.

Algorithmic implications (current)
- Fast NO: if degeneracy(G)>k or ω(G)≥k+2 then h(G)>k (the clique test is n^{O(k)} by brute force; degeneracy is linear-time).
- Fast YES: if τ(G)≤k then h(G)≤k (two-round capture). For fvs(G)≤k−1, by permanent blockers one gets h(G)≤k whenever h(forests)=1 holds; this gives an n^{O(k)} recognition on that subclass once the forest case is settled.

Next steps
- Write and verify a complete proof that a 1-hunter schedule of length O(n) wins on P_n; then derive h(C_n)=2. Revisit unicyclic once forests are resolved.
- Probe minor-monotonicity: search for a contraction counterexample (e.g., compare K_4 versus a single-edge subdivision) via exact R-evolution on n≤8.
- Explore bounded-period schedules using the L_p acyclicity criterion; implement a checker for small p and k.
- Develop a separator-based DP on bounded treewidth/feedback vertex set exploiting the separator composition bound.

New settled results and tools this round
- Cycles solved: For all n≥3, h(C_n)=2. Proof: Permanently shoot one vertex u (anchor); the evader is confined to C_n−u ≅ P_{n−1}, where a 1-hunter sweep wins. Explicit 2-hunter schedule length 2n−5 follows from the path sweep template.
- Unicyclic graphs: If G is connected with exactly one cycle, then h(G)=2. Anchor any cycle vertex; G−{u} is a tree (h=1) and permanent blockers add +1.
- Cut-vertex reduction: If a is a cut vertex of G and C_1,…,C_m are the components of G−a, then h(G) ≤ 1 + max_i h(C_i). Reason: block a, then use that h on a disjoint union is the max over components.
- Disjoint unions: h(G ⊔ H)=max{h(G),h(H)} (components decouple under R-evolution).
- FVS bound (constructive): h(G) ≤ fvs(G)+1 by blocking a feedback vertex set and sweeping each tree component. This yields an n^{O(k)} YES-recognizer on graphs with fvs ≤ k−1 by enumerating blockers and checking acyclicity.

Cautions
- Do not rely on monotonicity of the Z-process R_i = V\(Z_i∪S_i) with Z_{i+1}={v:N(v)⊆Z_i∪S_i}; Z_i need not be monotone.
- Unproven length bounds for arbitrary trees: we use the proven 2|V(T)|−1 schedule-length bound; the stronger 2|V(T)|−3 holds for paths, not yet for all trees.

Next steps
- Implement the small-FVS recognizer and a block–cut DP using anchors at selected cut vertices. Resolve cactus graphs for k=2. Investigate Pre_k(T) fixpoint compression for k=2. Explore separator-based DP or hardness for general k.


=== Current Output ===

# Main Results




=== Prover 1 Output ===

Ideas
- Extend our 2-hunter toolkit beyond cycles by introducing an anchor-transfer lemma and a targeted funneling lemma on trees. Use them to solve a nontrivial cactus subclass: necklaces (block–cut tree is a path, each block is a cycle; pendant trees are allowed). This yields explicit schedules and linear-time recognition for h≤2 on that class.
- Provide a rigorous proof of the periodic-lift criterion for repeated schedules (useful for verifying families of periodic strategies by finite acyclicity checks).

Lemmas and proofs
- Lemma 1 (Targeted funneling on trees with one hunter). Let T be a tree and v∈V(T) a designated target. There exists a 1‑hunter schedule S (dependent on v) such that, starting from R_1=V\S_1 and R_{i+1}=N(R_i)\S_{i+1}, one reaches a time t with R_t⊆{v} (hence one more shot at v captures).
  Proof. Root T at v. Iteratively delete leaves ℓ≠v by shooting their parent u twice in consecutive rounds. The key invariant (proved and used in the forest classification) is: for any leaf ℓ with neighbor u and any set X, one has ℓ∉N(N(X)\{u}); thus after two shots at u, ℓ is excluded and never reappears. By repeating this for all leaves distinct from v, we obtain a schedule of length 2(|V(T)|−1) that maps the dynamics on T to the dynamics on the single vertex {v}, i.e., R_t⊆{v}. One additional shot at v captures. This construction specializes to paths and yields steering to any chosen vertex.

- Lemma 2 (Anchor transfer). Let a be a cut vertex in G, and let H be the component of G−{a} that contains a neighbor b of a. Suppose at some time i we have R_i⊆H∪{a}. Then the round i+1 shot S_{i+1}={a,b} enforces R_{i+1}⊆H′, where H′ is the component of G−{b} that contains H (i.e., we may thereafter treat b as the new anchor and regard the “left of a” side as sealed). In particular, nothing can cross from H to G−H in that round, and no survivor remains at a or b.
  Proof. By definition, R_{i+1}=N(R_i)\{a,b}. Since R_i⊆H∪{a} and all edges from H to G−H go through a, any move from H to G−H must pass through a, which is shot. Hence no vertex outside H∪{a} is reached. Within H, every neighbor of b that enters b is eliminated (b∈S_{i+1}). Thus R_{i+1}⊆H\{b}, the component of G−{b} that contains H, establishing the transfer. Symmetrically, one can transfer back by a shot {a,b} when R is confined to the appropriate side relative to b.

- Lemma 3 (Periodic lift criterion). Fix p≥1 and a period‑p schedule (S_1,…,S_p) repeated indefinitely. Form the time‑lift L_p with vertex set V×{1,…,p} and directed edges (x,t)→(y,t+1 mod p) whenever xy∈E(G), and remove all (v,t) with v∈S_t. The repeated schedule is winning (i.e., for some T, R_T=∅ starting from R_1=V\S_1) if and only if the surviving directed graph L_p is acyclic.
  Proof. Forward: If L_p has a directed cycle, then by mapping cycles to time‑labels, there exists an infinite biinfinite walk respecting the shots; projecting layer indices gives an infinite rabbit walk avoiding capture, contradicting winning. Backward: If L_p is acyclic, topologically sort its vertices and note that along R_{i+1}=N(R_i)\S_{i+1}, the maximum topological level of any member of R strictly decreases every round (levels are considered modulo p via layer indices). Since the level set is finite, after at most |V|·p steps R becomes empty. Equivalently, there is no infinite allowable walk.

Main theorem (new class solved)
- Theorem 4 (Two hunters suffice on necklaces). Let G be a cactus whose block–cut tree is a path; i.e., G consists of cycles C_1,…,C_m arranged linearly (neighbors share a single articulation vertex), possibly with pendant trees attached to cycle vertices. Then h(G)=2.
  Proof. Lower bound: If m≥1 then G contains a cycle, so h(G)≥2 by the k=1 classification. For the upper bound, root the block–cut path at C_1 and let x_i denote the unique articulation between C_i and C_{i+1} (for i=1,…,m−1). We construct a 2‑hunter schedule using an invariant “anchored side” and Lemmas 1–2.
  Initialization: Choose a_1 to be any vertex of C_1 if m=1; otherwise choose a_1 to be any neighbor of x_1 on C_1. Hunter A shoots a_1 every round until instructed otherwise. Hunter B is mobile.
  Inductive invariant at block i (1≤i≤m): Before processing C_i, (I1) A is anchored at a_i∈V(C_i) that lies on the articulation side toward C_{i−1} (for i=1 take a_1 as above), and (I2) R is contained in the suffix subgraph consisting of C_i together with C_{i+1},…,C_m and all their pendant trees. The base case holds trivially for i=1.
  Processing C_i:
  • Consider the path P_i:=C_i−{a_i}. Choose a target y_i∈V(P_i) as follows: if i<m, set y_i:=x_i (the articulation to C_{i+1}); if i=m, choose any y_m∈V(P_m).
  • While A keeps shooting a_i, have B run the 1‑hunter targeted funneling schedule from Lemma 1 on P_i toward y_i (interpreting pendant trees attached to P_i as part of a tree; funneling ignores branches by leaf deletions). After finitely many rounds, R∩V(P_i)⊆{y_i}. In particular, no survivor in C_i lies outside {a_i,y_i}.
  • If i<m, perform one anchor‑transfer round with S={a_i,y_i} (Lemma 2), thereby moving the anchor to a_{i+1}:=y_i and preserving the suffix invariant (I2) with i replaced by i+1. If i=m, shoot y_m; this captures all survivors in C_m−{a_m}, and any survivor at a_m must move (with A shooting a_m every round) into C_m−{a_m} where it is then funneled to y_m and captured. Thus the process terminates.
  Correctness: By induction, after processing C_i we maintain (I1)–(I2) for i+1 until i=m, when capture occurs. Pendant trees do not obstruct funneling because Lemma 1 holds on trees and we never allow passage to the left of the current anchor (Lemma 2 guarantees safe transfers). Hence two hunters suffice. Together with the lower bound, h(G)=2.
  Schedule length: Each funneling step on P_i takes O(|P_i|+size of pendant trees incident to C_i) rounds, and each transfer costs one round. Total length is O(|V|).

Corollaries and algorithmic consequences
- Corollary 5 (Linear-time recognition and schedules on necklaces). Given a necklace G, h(G)=2 if and only if G contains a cycle (else h=1). The above constructive proof yields an O(n)-length 2‑hunter schedule computable in O(n) time by traversing the block–cut path.
- The targeted funneling lemma (Lemma 1) also yields a simple proof that h(C_n)=2 (choose any anchor a and target either neighbor on C_n−{a}) and generalizes our earlier unicyclic h=2 proof in a unified way.

Examples (sanity checks)
- Two cycles in series. Let C_1 share x_1 with C_2. Anchor at a_1 adjacent to x_1 in C_1. Funnel C_1−{a_1} to y_1=x_1, transfer with S={a_1,x_1} to anchor at x_1, then funnel C_2−{x_1} to some y_2 and shoot y_2. Hunters and set‑evolution computations on small instances (e.g., two C_5’s) match the general argument.
- Pendant trees. A C_6 with paths attached to two distinct vertices is cleared by anchoring at a_1 and applying the tree‑aware funnel on P_1=C_6−{a_1}: pendant branches are peeled by double‑shots at their attachment neighbors as part of the funnel to the chosen y_1, consistent with Lemma 1.

Obstacles and limits
- General cactus graphs (block–cut tree a tree) are subtler: processing a child cycle while preserving a barrier at the parent articulation seems to require temporary dual anchoring; our 2‑hunter method uses a one‑round double‑shot {parent,child} to transfer the anchor but cannot keep both anchored while sweeping the entirety of a child subgraph. Extending the necklace proof to general cactus requires a more global invariant or a refined steering that ensures the state R resides entirely in the child side at transfer times and does not “leak back” during recursive clears of siblings; this remains open.
- For block graphs with large cliques, two hunters are insufficient in general (h(K_r)=r−1), so different composition principles are needed; exploring whether h(G)=ω(G)−1 holds for block graphs (or more generally chordal) remains a promising, tractable subproblem.

Next steps
- Formalize and add to proofs.md: Lemma 1 (targeted funneling), Lemma 2 (anchor transfer), Lemma 3 (periodic lift), and Theorem 4 (necklaces h=2) with detailed inductive invariants.
- Extend from necklaces to all cactus graphs: develop a DFS schedule that uses anchor transfers at carefully chosen times when R is provably confined to the processed subtree; either supply the steering invariants or identify a counterexample.
- Implement a linear‑time recognizer for h≤2 on necklaces and unicyclic graphs (already implied), and a generator of the explicit schedules.
- Use the periodic‑lift criterion to search for bounded‑period winning schedules for small k on broader classes (outerplanar, series‑parallel), which may yield n^{O(k)} recognizers by checking acyclicity on a finite lift.
- Explore block graphs: attempt a proof that h(G)=ω(G)−1 for block graphs via “push‑to‑parent” shots within cliques, or produce a minimal counterexample.

Summary of progress
- Introduced and proved two key tools: targeted funneling on trees with one hunter and the anchor‑transfer round. Using these, proved that two hunters suffice for all necklace cacti (cycles in series with pendant trees), with explicit O(n) schedules and linear‑time recognition. Also provided a rigorous periodic‑lift criterion for periodic schedules. This extends the exact landscape beyond cycles/unicyclic to a broader class, and clarifies the structural requirements for managing separators with two hunters.


=== Prover 2 Output ===

Ideas

- Add two general tools: a vertex-expansion lower bound and a periodic-schedule criterion via a time-lift. Both are broadly applicable, easy to verify, and sharpen our understanding of obstructions and of schedule structure.
- Consolidate “anchoring + sweep” consequences: unicyclic graphs have h=2; separators/cut vertices compose cleanly; feedback-vertex-set bound is constructive.
- Outline an n^{O(k)} YES-procedure on fvs ≤ k−1 and suggest DP directions for small separators.

Rigorous results and proofs

Proposition 1 (Vertex-expansion lower bound). Let
ι(G) := min_{∅≠X⊆V} (|N(X)| − |X|).
If ι(G) ≥ k, then h(G) ≥ k+1.
Proof. Consider any k-hunter schedule (S_i). Let R_1 := V\S_1; if R_1 = ∅ we already have k ≥ n, trivial. For any nonempty R_i, the update gives |R_{i+1}| = |N(R_i) \ S_{i+1}| ≥ |N(R_i)| − |S_{i+1}| ≥ (|R_i|+k) − k = |R_i|. Thus nonempty sets stay nondecreasing in size. Since R_1 is nonempty unless S_1=V, R_t cannot become empty. Hence no k-schedule wins; h(G) ≥ k+1.
Remarks. This strictly strengthens the minimum-degree bound h(G) ≥ δ(G) (take X of size 1). It captures genuine expansion and is tight on K_{p,q} (ι = min{p,q}−1; h = min{p,q}).

Lemma 2 (Periodic schedules via time-lift). Fix p ≥ 1 and a sequence (S_1,…,S_p) with |S_i| ≤ k; extend it periodically S_{i+p}=S_i. Build the directed time-lift L_p with vertex set V×[p] and arcs (u,i)→(v,i+1 mod p) whenever uv∈E. Delete the nodes (v,i) with v∈S_i. Then the periodic schedule is winning iff the resulting digraph is acyclic. Moreover, if acyclic, capture occurs within T ≤ p·|V| rounds.
Proof. A surviving infinite walk v_1,v_2,… avoiding shots corresponds to an infinite directed path in L_p, which must contain a directed cycle by finiteness; conversely, a directed cycle in L_p projects to a length-p·r periodic walk in G that avoids shots. If acyclic, longest paths in L_p have length < |V|·p; hence after at most p·|V| rounds no avoiding path of that length exists, so R_T=∅.

Proposition 3 (Unicyclic graphs). If G is connected with exactly one cycle, then h(G)=2.
Proof. Lower bound: G contains a cycle as a subgraph, so h(G) ≥ 2. Upper bound: pick any cycle vertex u and shoot u every round (permanent blocker). Then G−{u} is a forest, and by the k=1 classification (forest case) one hunter wins there; using two hunters, play S_i={u}∪{x_i}, where x_i are the 1-hunter shots for G−{u}. This confines the rabbit to G−{u} and captures it.

Lemma 4 (Separator composition). Let V=U⊔W⊔S with no edges between U and W. Then h(G) ≤ |S| + max{h(G[U∪S]), h(G[W∪S])}. In particular, if we shoot S every round, the evader cannot traverse between U and W, and the subgames decouple.
Proof. Use |S| hunters to shoot S every round. The remaining ≤ k−|S| hunters simulate a winning schedule on one side while the other side plays empty shots; then switch sides. Any evading walk stays on one side throughout, hence is caught in its side’s phase.

Corollary 5 (FVS bound; constructive). For any feedback vertex set F, h(G) ≤ |F|+1. A winning schedule is obtained by shooting F every round and running the 1-hunter forest schedule on G−F component by component (disjoint-union law).

Consequences and examples

- Cycles solved (reprise). The “anchor + sweep” method (permanently shoot one vertex u on C_n) reduces to P_{n−1}, where a 1-hunter forward/backward sweep wins, giving h(C_n)=2 and a schedule of length 2n−5.
- Cacti and beyond. Proposition 3 implies all unicyclic graphs have h=2. For general cacti, FVS(G) can be >1 (e.g., two vertex-disjoint cycles); the bound h(G) ≤ fvs(G)+1 applies. Whether h(G)=2 for all cacti remains open; anchor-relocation is nontrivial in our “ephemeral shot” model.
- Expansion bound in action. If every nonempty X satisfies |N(X)| ≥ |X|+2, then h(G) ≥ 3. This gives strong NO-certificates on vertex expanders and random d-regular graphs where Hall-type expansion holds.

Algorithmic implications

- Periodic schedules: Given p and k, testing whether a fixed (S_1,…,S_p) wins is O(p·m) via acyclicity in L_p. Searching over choices is n^{O(pk)}, so if a priori p ≤ f(k), this yields an n^{O(k)} algorithm. Establishing such a bound on p (or proving its nonexistence) becomes a concrete target.
- Small-FVS subclass: If fvs(G) ≤ k−1, we can certify YES by guessing F (O(n^{k−1})), checking G−F is a forest, and emitting the explicit |F|+1 schedule (Lemma 4 + Corollary 5). This is an n^{O(k)} recognizer on that subclass.
- Separator DPs: Lemma 4 suggests a DP over a block–cut tree or a tree decomposition: for a separator S, spend |S| permanent blockers and solve subinstances independently with the residual budget. Making this exact for general k requires careful accounting of when permanent blockers can be reused; for bounded treewidth, we aim for n·f(t,k) time.

Obstacles and cautions

- Anchor relocation with two hunters is delicate: unlike stationary searchers, shots are instantaneous; moving a permanent blocker across a cut risks letting the rabbit slip through. This is the main hurdle in extending unicyclic⇒2 to all cactus graphs.
- The expansion bound is powerful but computing ι(G) is hard in general; as a NO-filter it is most useful on families with certifiable expansion.
- NP-membership remains unsettled: without a priori bounds on schedule length (or period), certificates can be super-polynomial.

Next steps (auditable)

1) Period-bounded schedules. Attempt to bound the period p by a function of k (start with k=1,2). If successful, this gives n^{O(k)} recognition via Lemma 2. Fallback: show hardness of finding a period-p schedule for small p.
2) Cactus graphs with two disjoint cycles. Either construct a 2-hunter schedule (anchor-sharing strategy) or produce a counterexample. Begin with two C_5’s connected by a length-2 path; attempt formal R-evolution adversary for any 2-shot schedule.
3) Separator DP prototype. Implement a DP on block–cut trees that assigns permanent blockers to selected cut vertices and uses known exact solvers on pieces (trees, cycles, unicyclic). Analyze its approximation guarantees versus fvs+1.
4) Empirical expansion tests. For small n, compute minimal ι(G) and compare to h(G) to assess tightness and to design faster NO-filters.

Summary

- New tools: a vertex-expansion lower bound (ι(G)≥k ⇒ h≥k+1) and a periodic-schedule criterion via a time-lift (acyclicity ⇒ finite capture horizon ≤ p·n).
- Solidified “anchor + sweep” consequences: cycles (h=2) and unicyclic graphs (h=2); separator composition and FVS-based constructive schedules.
- Provided concrete algorithmic avenues: period-bounded searches, small-FVS n^{O(k)} YES-recognition, and separator-based DPs. These are immediately checkable and extend our toolkit toward the main recognizability question.


=== Prover 3 Output ===

Ideas
- Establish an upper bound h(G) ≤ pw(G)+1 via a coupling to classical node-search. This yields immediate n^{O(1)} recognition for fixed k on graphs with pathwidth ≤ k−1, and more generally an FPT acceptance test in k.
- Strengthen bounds for sparse classes: prove that every cactus graph satisfies h(G) ≤ 3 by a constructive DFS-style schedule using two “anchors” plus one sweeper. This improves over the generic fvs+1 bound when the number of cycles is large.
- Formalize the least-fixpoint characterization of “winnable” state sets and prove downward-closure; this supports DP designs (over decompositions) that carry only antichains of boundary states.

Fixpoint view and downward-closure
Define the one-step successor operator on subsets R⊆V by Succ_k(R):={ N(R)\S : S⊆V, |S|≤k }. Let Good_k be the least set family containing ∅ and closed under the rule X∈Good_k if ∃S with |S|≤k and N(X)\S ∈ Good_k. Equivalently, Good_k = ⋃_{t≥0} G_t where G_0={∅} and G_{t+1}={ X : ∃S, |S|≤k, N(X)\S ∈ G_t }.
- Lemma 1 (Downward-closure). Good_k is downward-closed: if X∈Good_k and Y⊆X then Y∈Good_k.
Proof. By induction on the level t where X∈G_t. For t=0, X=∅ and the claim is trivial. For t>0, X∈G_t means ∃S s.t. N(X)\S ∈ G_{t−1}. For Y⊆X we have N(Y)⊆N(X), so N(Y)\S ⊆ N(X)\S. By IH and downward-closure of G_{t−1}, N(Y)\S ∈ G_{t−1}, hence Y∈G_t. ∎
- Observation. h(G)≤k iff V∈Good_k.
This recasts decision into membership of V in the least fixpoint of a monotone operator; the downward-closure supports antichain-based DP representations on decompositions (next steps).

Upper bound via node-search and pathwidth
We use the classical invisible fast robber node-search game: at each discrete time i, a set S_i of occupied vertices is chosen (|S_i| bounded by s), and the robber, moving arbitrarily fast along paths avoiding S_i, must eventually be placed upon by a searcher. Let C_i be the set of vertices the robber might occupy at time i under schedule S_1,…,S_i. One standard formulation yields C_1=V\S_1 and C_{i+1} = reach_{G\S_{i+1}}(C_i), where reach takes the union of connected components intersecting C_i.
- Lemma 2 (Coupling). Given any node-search schedule (S_i) with |S_i|≤s and C_T=∅, the same sequence (S_i) is a winning hunters schedule with k=s: defining R_1=V\S_1 and R_{i+1}=N(R_i)\S_{i+1}, we have R_i⊆C_i for all i, hence R_T=∅.
Proof. Induction: R_1=C_1. If R_i⊆C_i, then R_{i+1}=N(R_i)\S_{i+1} ⊆ N(C_i)\S_{i+1} ⊆ reach_{G\S_{i+1}}(C_i)=C_{i+1}. ∎
- Theorem 3 (Pathwidth bound). h(G) ≤ pw(G)+1.
Proof. It is known that the node-search number equals pw(G)+1 and that there is a monotone capturing schedule with s=pw(G)+1 searchers (see, e.g., Kinnersley (1992), Fomin–Thilikos (2008)). Apply Lemma 2. ∎
Corollaries.
- Series–parallel graphs (tw≤2 ⇒ pw≤2): h(G) ≤ 3. Outerplanar graphs also have pw≤2, hence h≤3.
- For fixed k, deciding h(G)≤k is polynomial-time on the class pw(G)≤k−1 (use any FPT test for pw≤k−1 and accept).

Cactus graphs: a constructive 3-hunter strategy
Let G be a connected cactus graph (each block is a cycle or an edge; blocks form a tree via articulation vertices).
- Theorem 4. h(G) ≤ 3.
Proof (constructive; invariant-based). Root the block–cut tree at an arbitrary articulation r. We maintain a DFS invariant: at any time we keep two “anchors” a,b (both shot every round), which are articulation vertices lying in the current block B on the DFS path (for the root, set a=r and choose b an articulation of the root block; if the root block is an edge {r,b}, pick its other endpoint). The third hunter (the sweeper) operates within B\{a,b} and possibly within child subtrees when descending. We use two primitives:
(1) Block cleaning. For an edge-block B={x,y}, if {x,y} are the two anchors, nothing remains to clean. For a cycle-block B containing anchors a,b, the subgraph B\{a,b} is a disjoint union of two paths P_1,P_2 whose endpoints are a,b. Keeping a and b permanently shot, the third hunter performs a 1-hunter sweep on P_1 then on P_2 (forests admit 1-hunter capture). During this, any evasion flow between B’s “parent side” and “child sides” must traverse a or b, which are blocked each round, preventing recontamination across these cuts.
(2) Anchor handover. Suppose B has been cleaned. To descend into a child block B′ attached at articulation b, pick an articulation b′∈B′ adjacent to b (if B′ is an edge, take its other endpoint; if B′ is a cycle, pick any neighbor of b along the cycle). In the next rounds, we switch anchors from {a,b} to {b,b′}: since b lies on every path from below B′ to above a, maintaining b blocked preserves separation; therefore releasing a is safe once b′ is established as the second anchor. The sweeper is idle during the single round when anchors change; no contamination can bypass b.
Proceed by DFS: at each block, perform (1); then for each child block, perform (2) to descend, and recurse. On backtracking from a child subtree rooted at b′, reverse the handover to re-establish anchors {a,b} in B (again safe by the same separator argument). Since the block–cut tree is finite, this process terminates; at leaves, after block cleaning no child remains, and recursive returns propagate. Because at every stage any movement between already processed parts and unprocessed parts is cut by currently shot anchors, no recontamination reaches cleaned areas. Eventually the sweeper clears the unique subtree containing the evader, and capture occurs. ∎
Remarks. The proof makes essential use of the cactus property (blocks are cycles/edges; separators are single articulations). We do not claim tightness of 3; whether all cactus graphs satisfy h(G)=2 remains open. The DFS scheme above immediately yields h(G)≤3·cc(BCT) in schedule length O(n).

Cut-vertex composition (tight bounds)
Let a be a cut vertex of G and C_1,…,C_m the vertex sets of the components of G−a.
- Lemma 5. max_i h(G[C_i∪{a}]) ≤ h(G) ≤ 1 + max_i h(G[C_i∪{a}]).
Proof. Lower bound by subgraph monotonicity. Upper bound: permanently shoot a and run, component by component, a winning schedule inside G[C_i] (1-hunter suffices for trees; use appropriate k for general), which is independent across components since a blocks traversal. ∎

Examples
- Series–parallel ladder L_n: pw(L_n)=2, hence h(L_n)≤3. Degeneracy=2, so 2≤h(L_n)≤3.
- “Dumbbell” C_ℓ—P_m—C_r: By Theorem 3, h≤3. Our 2-hunter attempt with a moving anchor may recontaminate; enumerating minimal obstructions for h≤2 on small n will clarify whether some dumbbells require 3.

Obstacles
- Exact DP for h≤k on general tw-bounded graphs: while Good_k is downward-closed and amenable to antichain compression on a bag, we still need a clean interface condition to compose subgraphs across introduce/forget/join nodes. A precise state, likely a family of “locally winnable” boundary subsets closed under one-step Pre_k, must be designed and its width bounded by a function of (k,tw).
- Tightness on cactus and outerplanar graphs: whether h≤2 always (or characterize when h=3) remains unsettled.

Next steps
1) Promote Theorem 3 (h≤pw+1) and Lemma 2 (coupling) to proofs.md with citations; add corollaries for pw≤2 classes.
2) Formalize Theorem 4’s DFS invariant with explicit R-evolution inequalities at handover rounds, and test on generated cactus instances up to n=14; search for a cactus with h=3 to probe tightness.
3) Design a DP state for nice tree decompositions: per bag B, carry an antichain F_B⊆2^B such that X∈F_B iff X is “good” for the partial graph with boundary B under k; derive introduce/forget/join transitions using the Good_k one-step rule and prove F_B sizes bounded by f(k,|B|).
4) Enumerate minimal obstructions for h≤2 up to n=10 via the 2^V-state BFS to guide cactus/outerplanar conjectures.

Summary of new rigor
- Good_k fixpoint with downward-closure (Lemma 1).
- Coupling to node-search implies h(G) ≤ pw(G)+1 (Theorem 3) and yields polynomial-time recognition for fixed k on pw≤k−1 classes.
- Constructive schedule showing every cactus graph satisfies h(G)≤3 (Theorem 4) via two permanent anchors plus a 1-hunter sweeper and safe anchor handovers.
- Cut-vertex composition bounds (Lemma 5) provide tight local reductions and support a block–cut DP agenda.


=== Prover 4 Output ===

# Ideas
- Extend the permanent-blockers method to block–cut decompositions. Use 2 hunters in phases that permanently eliminate a leaf block from the block–cut tree, thereby shrinking the graph irrespective of the rabbit’s starting location.
- Prove that on cactus graphs (each edge in at most one cycle) every leaf block (either an edge or a cycle) can be eliminated by a 2-hunter phase. Inductively this yields h(G)=2 for all connected cacti with a cycle (trees already have h=1).
- Provide explicit schedule templates and length bounds for each phase. Conclude polynomial-time recognition and construction on cacti.

# Tools (recap)
- R-dynamics: R_1=V\S_1; R_{i+1}=N(R_i)\S_{i+1}. A schedule wins by time t iff R_t=∅.
- Permanent blockers (proved): If U⊆S_i for all i, then the evolution equals that on G−U with shots S_i\U. In particular h(G) ≤ |U|+h(G−U).
- Forests: h(T)=1 for any tree T (proved earlier), with an explicit 1-hunter sweep.
- Disjoint unions: h(G⊔H)=max{h(G),h(H)}.

# Block–cut structure preliminaries
Let G be connected. The block–cut tree BCT(G) is a bipartite tree whose nodes are blocks (maximal 2-connected subgraphs) and cut vertices; edges indicate incidence. For cactus graphs, every block is either a cycle or a single edge K_2.

We call a block node X in BCT(G) a leaf block if it has degree 1 in BCT(G).

# Lemmas (formal)

Lemma 1 (Eliminating a pendant tree branch). Let G be any graph, v∈V, and let H be the connected component of G−v that is a tree (possibly a single edge K_2) and is attached to v (i.e., all edges from H to G−H go to v). Then with 2 hunters there is a finite schedule segment that maps any R (set of possible positions at segment start) to R′ with R′∩(H\{v})=∅, while using one hunter permanently on v during the segment.

Proof. Keep v in every shot (permanent blocker U={v}). Then the evader cannot cross between H\{v} and G−H. Inside H, we have a tree; with the second hunter, run the known 1-hunter sweep on H\{v} (a tree or empty). By the permanent-blockers lemma, the evolution on H\{v} decouples and is exactly the 1-hunter evolution there, which ends with no possible positions in H\{v}. Since v is shot each round, R never contains v during the segment. Hence R′∩(H\{v})=∅. ∎

Lemma 2 (Eliminating a leaf cycle block). Let G be a cactus graph, and let B be a cycle block which is a leaf in BCT(G), attached to the rest of G only at a cut vertex a∈V(B). Then with 2 hunters there is a finite schedule segment that maps any starting R to R′ with R′∩(B\{a})=∅, using one hunter permanently on a during the segment.

Proof. Keep a in every shot during the segment. Then no walk can cross between B\{a} and G−B via a, and within B the removal of a turns the cycle B into the path P:=B−a. Using the second hunter, execute the 1-hunter path sweep on P. By the permanent-blockers lemma, the evolution on P is independent and ends with no possible positions in P; also a is shot and thus never in R. Therefore R′∩(B\{a})=∅. ∎

Remark. In Lemma 2 we did not require any assumption on the rest of G; whether the rabbit starts in B or outside it, after the segment it cannot be in B\{a}.

# Main theorem for cactus graphs

Theorem 3. If G is a connected cactus graph, then h(G)=1 if G is a tree, and h(G)=2 otherwise.

Proof. If G is a tree, h(G)=1 is known. Suppose G contains at least one cycle. Lower bound h(G)≥2 follows from δ(G)≥2 on any cycle subgraph.

For the upper bound, proceed inductively on the number c of cycle blocks in BCT(G). If c=1, G is unicyclic and h(G)=2 was already proved (anchor the unique cycle vertex a and sweep the tree G−a).

Assume c≥2. Consider BCT(G) and pick a leaf block X. Two cases.
- X is an edge block K_2 with a leaf endpoint x attached only to a cut vertex v. Apply Lemma 1 to eliminate the pendant tree H containing x with anchor v. This yields a schedule segment that maps any R to R′ with R′∩(H\{v})=∅. The effect is to delete H\{v} from future consideration. The remaining graph’s block–cut tree is obtained by pruning a leaf edge; c does not increase, and the process can be repeated.
- X is a cycle block B attached only at a cut vertex a. Apply Lemma 2 to eliminate B\{a}. This prunes one cycle block from BCT(G), reducing c by 1.

Iterating these pruning segments (each using at most 2 hunters and anchored at the relevant cut vertex), we eventually remove all cycle blocks (since BCT(G) is finite and each cycle-pruning strictly decreases c). The residual graph is a tree; finish with a 1-hunter sweep (we may ignore the second hunter). Concatenating the segments gives a finite 2-hunter schedule with R_t=∅ at the end. Hence h(G)≤2.
Combining with the lower bound h(G)≥2 (because G has a cycle) yields h(G)=2. ∎

Corollary 4 (Disconnected cacti). If G is a disjoint union of cactus components G_i, then h(G)=max_i h(G_i) by the disjoint-union law; in particular, h(G)=2 iff at least one component contains a cycle.

# Explicit schedule lengths
- In Lemma 1, the pendant tree branch on m vertices is cleared by the 1-hunter tree schedule in ≤2m−1 rounds while anchoring v, so the segment length is O(m).
- In Lemma 2, if the leaf cycle block B has length ℓ, then the path P=B−a has length ℓ−1 and the standard 1-hunter sweep on a path takes 2(ℓ−1)−3=2ℓ−5 rounds while anchoring a. Summing over pruned blocks plus a final ≤2|V(T)|−1 rounds on the residual tree T gives an overall O(n)-round schedule (explicit but not needed for recognition).

# Examples
- Sunlet graph (cycle with a pendant edge attached to each cycle vertex): Its block–cut tree has the cycle block of degree ≥2 and many leaf edge blocks. Repeatedly apply Lemma 1 to prune pendant edges until the cycle becomes a leaf block; then apply Lemma 2; hence h=2.
- A chain of cycles connected by paths (a cactus): prune pendant tree edges along the chain until an end cycle becomes a leaf block, eliminate it, and continue inward; h=2.

# Algorithmic consequences
- Recognition on cacti: Given G, test if it is a cactus (linear-time via checking each edge lies in ≤1 cycle and computing BCT). If acyclic, output h=1; else h=2. Constructing an explicit 2-hunter schedule follows the proof: iteratively identify a leaf block and emit the corresponding anchored segment.
- More generally, for graphs with small feedback vertex set f, the constructive bound h(G) ≤ f+1 holds; on cacti f can be as small as 1 even with many cycles, and equality h=2 is achieved whenever a cycle exists.

# Obstacles
- Extending from cacti to all outerplanar graphs: cycle blocks in outerplanar graphs include series–parallel 2-connected pieces beyond single cycles; our leaf-block elimination requires a 1-hunter capture inside a block with one anchor, which fails for general 2-connected outerplanar blocks. New intra-block strategies or additional invariants are needed.
- General n^{O(k)} recognition remains open beyond the classes handled (forests, unicyclic, cactus, small-FVS). A DP over tree decompositions needs a compact boundary-state representation of the reachability set R under the Pre_k operator; establishing a polynomially bounded state space for fixed k is the key hurdle.

# Next steps
- Outerplanar graphs with k=2: attempt a block-level version of Lemma 2 for series–parallel blocks using one anchor to reduce to a forest inside the block, or prove a counterexample.
- FVS-parameter DP: given a feedback vertex set U, design a DP that alternates anchoring at u∈U and sweeping attached forest components, optimizing the number of concurrently anchored vertices to minimize k. Target exact computation of h(G) in time poly(n)·c^{|U|}.
- Hardness for k=2: formalize the time-expanded layering reduction to a per-layer budgeted path hitting problem; attempt reductions from NP-hard “layered cut” variants to show hardness or to derive integrality gaps for the natural LP.
- Periodic schedules: investigate whether for fixed k there exists a universal polynomial bound on the period p of a winning periodic schedule (if any exists). This would imply NP-membership of the decision problem for fixed k.

# Summary of new provable content
- Lemma 1: with two hunters, any pendant tree branch can be eliminated by anchoring its attachment vertex and executing the 1-hunter forest sweep inside.
- Lemma 2: with two hunters, any leaf cycle block in a cactus can be eliminated by anchoring its unique cut vertex and executing the 1-hunter path sweep on the cycle minus that vertex.
- Theorem 3: for connected cactus graphs, h(G)=1 if acyclic and h(G)=2 otherwise. Recognition and schedule construction are linear-time on this class.
