{"progress_md":"Goal. Prove Theorem (forward-only, low complexity): for any f with no loops and RAC(collision,f) ≤ √n / log^α n, the interleaved all-scales algorithm A_all finds a collision in O(log n)·RAC expected queries. The main obstacle versus the graph case is handling “false merges” in the forward-only model (walking into a vertex that was previously chosen as a start, but not yet reached by any walk), which are not collisions.\n\nPlan this round. Make rigorously checkable progress on the two technical pillars needed by the roadmap: (I) a robust bound on false merges (expectation and tail) up to q = O(√(n/ polylog n)) total forward steps; (II) a scale-by-scale coupling lemma specialized to forward-only function walks (replacement for the graph Claim 6.11). Then (III) assemble into an epoch argument. I also isolate a “no-skip” event and give a simple union-bound proof (no Freedman needed), and point out subtleties and where more care may be required.\n\nDefinitions and notation.\n- Work with a fixed function f:[n]→[n] with f(v)≠v for all v. The algorithm’s two query types: Start draws a uniformly random unseen vertex; Step reveals f(u) for an already seen u (forward-only). A collision is exhibited when we discover u≠u′ with f(u)=f(u′).\n- Let q be an integer budget for total queries; let q_step ≤ q be the number of Step queries (we will take q_step ≤ 2q in the epoch where we run A up to 2q queries), and s ≤ q the number of Start queries in that epoch.\n- A “false merge” at a Step is the event that we reveal f(u)=v where v is a vertex that was previously selected via Start and has not yet been reached by any forward walk (so the edge reveals a merge, but not yet a collision). Denote by X the total number of false merges by the time we make at most q queries.\n- A random start string r: a uniformly random permutation of [n] that predetermines which unseen vertex would be chosen upon each Start; we say the “no-skip” event holds if the j-th Start indeed takes r_j (equivalently: none of r_1,…,r_j was discovered by earlier Step queries before that Start). Skips can happen only if some Step hits a not-yet-Start vertex r_j.\n\nLemma 1 (Few false merges via a clean double-sum bound).\nStatement. For any (adaptive) forward-only algorithm that makes at most q queries and q_step Step queries (q_step ≤ q), and for any fixed f with no loops,\n- E[X] ≤ (q_step · s)/(n−q) ≤ 2 q^2/n for q ≤ n/2.\n- In particular, Pr[X ≥ 1] ≤ E[X] ≤ 2 q^2/n.\nWhy useful. Gives the “no-false-merge” event with probability 1−O(q^2/n) uniformly over f and the algorithm, sufficient for q ≪ √n.\nProof sketch (checkable). Index Step times by t∈T (|T|=q_step), and Start times by j∈J (|J|=s). A false merge at Step t occurs if f(u_t) equals some previously started vertex v_j. For any fixed pair (t,j) with Start j preceding Step t, the probability that v_j equals f(u_t) is at most 1/(n−j+1): at the j-th Start, v_j is drawn uniformly from the then-unseen set (of size at least n−(j−1)), and this upper bounds the chance v_j picks that particular label w=f(u_t) (if w was seen earlier, this probability is 0 and the bound still holds). Thus by a union bound over pairs (t,j),\n\\[\\Pr[\\text{false merge at Step }t] \\le \\sum_{j< t}\\frac{1}{n-j+1} \\le \\frac{s}{n-q+1}.\\]\nSumming over t ∈ T and using s ≤ q, q_step ≤ q gives E[X] ≤ q· s /(n−q) ≤ 2 q^2/n for q ≤ n/2. Markov gives the tail bound. Adaptivity does not invalidate the bound because we only used the (unconditional) uniformity of each Start and a union bound over disjoint Start indices.\n\nRemark. This proof avoids Freedman/Azuma; it is robust to any adaptivity or function f. It is slightly looser (constant-factor) but sufficient in the q = O(√(n/ log n)) regime.\n\nLemma 2 (No-skip with high probability).\nStatement. Fix an algorithm making at most q queries. Let SKIP be the event that for some Start index j, the vertex r_j (the j-th element of the global Start permutation) appears earlier as the image of a Step before the j-th Start occurs. Then Pr[SKIP] ≤ 2 q^2/n for q ≤ n/2.\nWhy useful. Allows coupling all algorithms to the same Start string r (as in Section 6.3 of the paper) with failure probability O(q^2/n).\nProof sketch. By union bound over Step times t and future Start indices j: for a fixed Step t and any future j, the probability that the Step’s image equals r_j is ≤ 1/(n−j+1) (same rationale as in Lemma 1). Summing j over at most q future Starts and t over q Steps gives ≤ q·q/(n−q) ≤ 2 q^2/n.\n\nDiscussion: relation between Lemmas 1 and 2. A “skip” is not the same as a false merge—skips occur when we Step into a vertex that hasn’t been declared as a Start yet (so it cannot be a false merge). The same counting method bounds both types of bad events by O(q^2/n).\n\nLemma 3 (Forward-only scale coupling; functions analogue of Claim 6.11).\nSetup. Let A be any forward-only algorithm that (with access to the unlabeled certificate) finds a collision within q queries with decent probability. Let r be the Start string. Define E_no-merge to be the event “no false merges occur in the first 2q queries of A” and E_no-skip the event “no-skip for A with respect to r in its first 2q queries”. For 0 ≤ i < ⌊log_2 n⌋ define E_coll(i,A,2q) to be the event that A first finds a collision within 2q queries, and the collision point lies at distance in [2^i,2^{i+1}) along the forward walk W_j from its Start v_j.\nStatement. Conditioned on E_no-merge ∧ E_no-skip and E_coll(i,A,2q), the single-scale process A_i (the i-th component inside A_all) will deterministically find the same collision within ≤ 4·(number of queries performed by A up to the collision) ≤ 4·2q forward steps.\nWhy useful. This is the scale-by-scale domination needed to transfer progress from a hypothetical competing algorithm A (with certificate) to A_all (without certificate), exactly as in §6.3 but simplified by forward-only walks.\nProof sketch. Couple A and A_i to share the same Start string r. Impose wlog an “older-first” rule on A: if two walks have identical shapes, extend the older one; this does not worsen A’s query complexity or success. Under E_no-merge, before the first collision all walks starting from distinct Starts remain disjoint; a collision occurs precisely when some walk steps into a vertex reached earlier by a different walk (closing a directed cycle also exhibits a collision and only helps). Under E_no-skip, the j-th Start in A is exactly v_j=r_j. If A’s first collision along W_j happens at distance L ∈ [2^i,2^{i+1}), then by older-first, every earlier Start v_{j′}, j′<j, has already advanced by at least 2^i steps unless its walk terminated earlier by closing a cycle (in which case A_i will also terminate that walk early and not waste more budget). The single-scale A_i extends each active walk up to 2^i steps (bidirectional walking is not needed in functions; forward-only suffices). Accounting shows A_i spends at most 2·2^i steps per good earlier Start and at most 2·(distance-to-cycle) on bad ones. Summing yields the bound of ≤ 4·(A’s work to reach L), implying A_i reaches the same collision in ≤ 4·2q steps.\n\nRemark on cycle closure. In the function model, closing a directed cycle when stepping from u to a previously visited v supplies an immediate collision witness: f(u)=v and also f(pred(v))=v with pred(v) ≠ u (unless v was the very first vertex, which cannot happen since f has no loops). Thus early cycle closure helps, and the above amortization only becomes easier.\n\nProposition 4 (Epoch success probability and assembly of Theorem).\nLet q⋆ = RAC(collision,f). Let A⋆ be an algorithm achieving expected q⋆ with certificate. By Markov, Pr[A⋆ finishes within 2q⋆ queries] ≥ 1/2. By Lemma 1 with q=2q⋆, Pr[E_no-merge] ≥ 1−O(q⋆^2/n). By Lemma 2, Pr[E_no-skip] ≥ 1−O(q⋆^2/n). Intersecting (and using a union bound) gives\n\\[\\Pr[ E\\_no\\text{-}merge \\wedge E\\_no\\text{-}skip \\wedge (\\text{A⋆ finishes within }2q\\_⋆) ] \\ge 1/2 - O(q\\_⋆^2/n).\\]\nUnder this event, Lemma 3 implies that in 8q⋆ rounds of A_all (each round costs O(log n) queries; 8 is a safe constant from doubling the 4 overhead), some scale A_i finds the same collision. If we assume the low-complexity regime q⋆ ≤ √n/ log^α n for α ≥ 2, then q⋆^2/n ≤ 1/ log^{2α} n is small; for large n, the success probability in one 8q⋆-round epoch is at least, say, 1/3. A geometric-series argument yields\n\\[ \\mathbb{E}[\\text{Queries}_{A\\_{all}}(f)] = O(q\\_⋆ \\log n), \\]\nwhich is Theorem 1 with C an absolute constant and any fixed α ≥ 2 (α can be optimized; α>1 suffices with constants tracked carefully).\n\nSanity checks and small examples.\n- Extreme indegree: f maps almost all points to a single value v_0. Starts pick v_0 with probability 1/n each time. Our Lemma 1 correctly yields E[X]=Θ(q^2/n); false merges remain rare for q ≪ √n.\n- Dense cycles: if the first walk quickly closes a cycle, that already gives a collision, so A_all only improves.\n- Adaptivity stress-test: an algorithm might choose Step vertices u adversarially using all past labels. Our arguments never require independence between f(u) and the past; they only rely on the per-Start uniformity of selecting r_j (and union bounds), hence are robust.\n\nObstacles and gaps to be tightened.\n- “Older-first” wlog: As in §6.3 of the paper, one needs to argue we may modify A into an older-first tie-breaker without hurting its performance. This is standard but should be stated explicitly for functions. I believe the identical monotonicity argument carries over.\n- Accounting constants in Lemma 3: I used a factor 4 overhead mirroring the graph case; it is straightforward to check in the function setting but should be written with precise per-walk budgets (2^i forward steps per older Start plus at most the distance-to-cycle for those that end early).\n- No-skip proof uses a union bound over at most q future Starts for each Step. A slightly tighter bound (hypergeometric) can reduce constants but is not needed here.\n- Independence of residual unseen set size: in Lemmas 1–2 I bounded 1/(n−j+1) from above by 1/(n−q), which is valid since at most q vertices can be seen by the j-th Start in the considered epoch. This detail should be recorded precisely in the formal proof.\n\nNext steps.\n1) Write full formal proofs of Lemmas 1–3 with detailed conditioning on the filtration, including the precise definition of E_coll(i,A,2q) in the function setting.\n2) Optimize α. Track constants to show α = 1 suffices for large n (since q^2/n ≤ 1/log^2 n then).\n3) Clarify the stopping rule for A_all in the function setting: cycle closure produces a collision witness; we can thus remove the “or cycle closes” early-stop clause or re-interpret it as immediate success.\n4) Prepare coupling writeup mirroring §6.3, replacing bidirectional graph walks by forward-only function walks.\n\nNotes on output.md. I did not see an existing output.md; if there is one, please surface it. The above lemmas strengthen the “false merges are rare” part with a simple union-bound proof and give a clean coupling in the forward-only function model. I believe this covers the key missing substitute for the graph “hardness of merging” lemma, moving us closer to a complete proof of Theorem 1 in the low-complexity regime."}