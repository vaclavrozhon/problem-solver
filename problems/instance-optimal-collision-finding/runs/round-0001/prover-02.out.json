{
  "progress_md": "Ideas\n\n- We isolate a precise, forward-only \u201cfalse merges\u201d lemma that bounds the expected number of times a forward edge lands on a vertex previously sampled only as a start. The bound is uniform over adaptive algorithms and fixed f, with randomness only from the uniform new-start oracle and the algorithm\u2019s coins.\n- We then state a clean coupling lemma for functions (forward-only) that is a faithful, simplified analogue of Claim 6.11 in the paper, replacing merging-hardness by conditioning on no false merges. This gives the scale-by-scale amortization without backward queries.\n- Finally we assemble the epoch argument in the low-complexity regime q \u2264 \u221a(n)/log^\u03b1 n, showing that A_all needs O(q log n) queries in expectation.\n\nDefinitions\n\n- We consider an arbitrary (adaptive) algorithm interacting with a fixed function f:[n]\u2192[n] (no loops). There are two operations: Start (uniform unseen vertex) and Step (query f(u) for a previously encountered u). Let S be the total number of Start operations and F the total number of Step operations in a given time window. Let X be the number of false merges in that window, i.e., the number of rounds t in which the operation is Step on u and the revealed f(u) equals a vertex v that had been obtained earlier by a Start (and v has not been reached by any Step before that time). Note that counting all hits to previously started vertices overcounts false merges, hence yields an upper bound.\n\nLemma A (Uniform-subset view of starts; expectation bound for false merges)\n\n- Statement.\nFor any fixed function f and any adaptive algorithm, condition on a time window in which the algorithm performs exactly S starts and F forward steps. Let I be the set of images revealed by the F Step operations in the window. Then, for the randomness of the Start oracle and the internal randomness of the algorithm, the expected number of hits of Step targets into the set of started vertices is bounded by\n  E[X] \u2264 F\u00b7S / (n \u2212 F).\nIn particular E[X] \u2264 F\u00b7S / n.\n- Why useful here.\nSetting S,F \u2264 2q in an epoch of length 2q total queries, we obtain E[X] \u2264 4 q^2/(n\u22122q) = O(q^2/n), hence Pr[X\u22651] = O(q^2/n) by Markov. This gives \u201cno false merges\u201d with high probability when q \u226a \u221an.\n- Proof sketch (fully rigorous with the permutation coupling).\nExpose in advance a uniformly random permutation \u03c0 of [n]. Implement each Start as returning the unseen vertex with the smallest \u03c0-rank among currently unseen vertices; this exactly realizes the uniform new-start oracle and yields exchangeability. Let I_{t} be the set of images revealed by Step operations before time t, and let s_{t} be the number of Starts before t. Then, conditional on I_{t}, the set of started vertices S_{t} is the set of the s_{t} smallest-\u03c0 elements of W_{t}:=[n]\\I_{t}; in particular S_{t} is uniform among all s_{t}-subsets of W_{t}. For a Step at time t with target y=f(u), if y \u2208 I_{t} then no false merge occurs; otherwise\n  Pr[y \u2208 S_{t} | history up to t] = s_{t} / |W_{t}| \u2264 s_{t}/(n\u2212F).\nSumming over all F steps yields E[X] \u2264 \u03a3_t s_{t}/(n\u2212F) \u2264 F\u00b7S/(n\u2212F). This bound does not assume independence between steps and starts beyond the uniformity of each Start.\n\nCorollary A.1 (Low-complexity regime, no-false-merge w.h.p.).\nLet q \u2265 1, and let the algorithm perform at most 2q queries within an epoch, of which at most 2q are Step and at most 2q are Start. Then E[X] \u2264 4q^2/(n\u22122q). If q \u2264 \u221an/ log^\u03b1 n and n is large enough, then E[X] \u2264 5/log^{2\u03b1}n, hence Pr[X\u22651] \u2264 5/log^{2\u03b1}n.\n\nComment on \u201cno-skip\u201d. In our forward-only model, a \u201cskip\u201d (the j-th new start in the random order having already been seen before it is started) is exactly a false merge. Thus, a separate \u201cno-skip\u201d event is unnecessary once we control X.\n\nCoupling to a single scale in the forward-only model\n\n- Setup.\nFix any algorithm A that, given the unlabeled certificate, finds a collision in expected q queries. As in the paper, fix in advance the random permutation r listing new-start vertices, and condition on the event that A finishes within 2q queries. Additionally, condition on X=0 (no false merges) in these 2q queries. We also adopt the standard \u201colder-first tie-break\u201d w.l.o.g.: whenever two active walks have isomorphic revealed shapes, advance the older one. The usual symmetry/exchangeability argument under the random-start permutation permits this tie-break without harming success probability or increasing expected query complexity (we only use it for analysis).\n\n- Single-scale amortization (functions version of Claim 6.11).\nLet i be such that A\u2019s first collision arises from a walk W_j whose distance (number of forward steps from its start v_j to the colliding image) lies in [2^i, 2^{i+1}). Under X=0 and older-first tie-break, at that time all older starts j\u2032<j that have not terminated earlier have been advanced to at least 2^i steps, and all others have been advanced up to their own termination threshold (cycle or collision). Therefore, the single-scale process A_i that repeatedly:\n  - starts at fresh random vertices and advances each active walk forward up to 2^i steps (stopping earlier upon cycle/termination/collision),\nwill deterministically find a collision after at most a factor-4 overhead in forward steps relative to A\u2019s 2q steps up to the first collision. The factor 4 arises from at most doubling the budget per older active start and at most doubling for incomplete walks; as in the paper\u2019s amortization, this constant is independent of f and i.\n\nAssembling the bound\n\n- Epoch definition.\nRun A_all for T=8q rounds; each round performs O(log n) queries, one interleaved step for each scale i. We declare success if any scale detects a collision.\n- Success probability per epoch.\nBy Markov, A succeeds within 2q queries with probability \u2265 1/2. By Corollary A.1 with S,F \u2264 2q, the event X=0 holds with probability \u2265 1 \u2212 O(q^2/n). Under these two events, the single-scale coupling implies that some scale i in A_all finds a collision within 8q rounds (constant-factor overhead), so the epoch succeeds. Therefore a single epoch succeeds with probability at least 1/2 \u2212 O(q^2/n). In the target regime q \u2264 \u221an/log^\u03b1 n, this is \u2265 1/3 for \u03b1 large enough (e.g., any \u03b1 > 1/2 suffices; choosing \u03b1 as in the theorem statement gives a clean bound).\n- Expected query complexity.\nEach epoch costs O(q log n) queries. A geometric bound with constant success probability per epoch implies\n  E[Queries_{A_all}(f)] = O(q log n) = O(log n)\u00b7RAC(collision,f),\nproving Theorem (forward-only, low complexity) with appropriate absolute constants.\n\nExamples and sanity checks\n\n- Worst-case f with many short cycles: our Lemma A is independent of f\u2019s structure; it upper-bounds false merges in terms of S and F only, so short cycles do not hurt the argument.\n- Algorithm that starts aggressively: X scales with S\u00b7F/n, so to increase false merges substantially one must also increase S, which costs queries; in the epoch we cap S,F by O(q), keeping X small.\n\nObstacles / gaps to be handled next\n\n- Older-first tie-break justification: We used the standard symmetry argument (exchangeability of unseen starting vertices under the random permutation coupling) to assume older-first without loss. It would be good to add a crisp lemma: \u201cAmong algorithms that differ only by tie-breaking between isomorphic walks, older-first does not increase the hitting time to the first collision.\u201d This follows from considering an automorphism that swaps the two walks and averaging.\n- Concentration beyond Markov: For completeness, one can promote Corollary A.1 from Markov to Freedman/Bernstein for martingales. The increments of X_t are bounded by 1 and the predictable quadratic variation is \u2264 E[X], yielding tail P[X \u2265 (1+\u03b4)E[X] + \u03bb] with exp(\u2212\u03a9(min{\u03bb,\u03bb^2/E[X]})) bounds. This is not needed for the theorem, but could tighten constants.\n- Bookkeeping for A_all: We implicitly assumed collision checks across scales are free. In the query model, only oracle queries to f are counted; set/dictionary checks are paid in time but not in queries; hence the analysis is consistent.\n\nConcrete claims to curate into output.md\n\n- Lemma A (E[X] \u2264 F\u00b7S/(n\u2212F)) with its permutation-coupling proof.\n- Corollary A.1 (Pr[X\u22651] = O(q^2/n) for S,F \u2264 2q).\n- Functions-analogue of Claim 6.11 (single-scale amortization under no false merges).\n- Epoch assembly yielding E[Queries_{A_all}] = O(q log n) when RAC \u2264 \u221an/log^\u03b1 n.\n\nNo output.md was provided; hence no contradictions detected there yet. I recommend adding Lemma A and the functions coupling claim as the next curated steps."
}