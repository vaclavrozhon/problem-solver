--- SYSTEM ---
You are a research **summarizer**. Summarize this *last round only* for a human log.

Include:
- 3–7 bullet **Highlights** (facts learned, reductions, counterexamples, partial bounds).
- 1–3 **Open questions / TODOs** for the next round.
- 1–3 **Citations to files** you relied on (e.g. round files or papers by name).

**Return strictly JSON**:
{
  "summary_md": "Readable summary of the round (≤200 words)",
  "highlights": [],
  "next_questions": []
}

--- USER ---
=== prover-01.out.json (progress_md) ===
Goal. Prove Theorem (forward-only, low complexity): for any f with no loops and RAC(collision,f) ≤ √n / log^α n, the interleaved all-scales algorithm A_all finds a collision in O(log n)·RAC expected queries. The main obstacle versus the graph case is handling “false merges” in the forward-only model (walking into a vertex that was previously chosen as a start, but not yet reached by any walk), which are not collisions.

Plan this round. Make rigorously checkable progress on the two technical pillars needed by the roadmap: (I) a robust bound on false merges (expectation and tail) up to q = O(√(n/ polylog n)) total forward steps; (II) a scale-by-scale coupling lemma specialized to forward-only function walks (replacement for the graph Claim 6.11). Then (III) assemble into an epoch argument. I also isolate a “no-skip” event and give a simple union-bound proof (no Freedman needed), and point out subtleties and where more care may be required.

Definitions and notation.
- Work with a fixed function f:[n]→[n] with f(v)≠v for all v. The algorithm’s two query types: Start draws a uniformly random unseen vertex; Step reveals f(u) for an already seen u (forward-only). A collision is exhibited when we discover u≠u′ with f(u)=f(u′).
- Let q be an integer budget for total queries; let q_step ≤ q be the number of Step queries (we will take q_step ≤ 2q in the epoch where we run A up to 2q queries), and s ≤ q the number of Start queries in that epoch.
- A “false merge” at a Step is the event that we reveal f(u)=v where v is a vertex that was previously selected via Start and has not yet been reached by any forward walk (so the edge reveals a merge, but not yet a collision). Denote by X the total number of false merges by the time we make at most q queries.
- A random start string r: a uniformly random permutation of [n] that predetermines which unseen vertex would be chosen upon each Start; we say the “no-skip” event holds if the j-th Start indeed takes r_j (equivalently: none of r_1,…,r_j was discovered by earlier Step queries before that Start). Skips can happen only if some Step hits a not-yet-Start vertex r_j.

Lemma 1 (Few false merges via a clean double-sum bound).
Statement. For any (adaptive) forward-only algorithm that makes at most q queries and q_step Step queries (q_step ≤ q), and for any fixed f with no loops,
- E[X] ≤ (q_step · s)/(n−q) ≤ 2 q^2/n for q ≤ n/2.
- In particular, Pr[X ≥ 1] ≤ E[X] ≤ 2 q^2/n.
Why useful. Gives the “no-false-merge” event with probability 1−O(q^2/n) uniformly over f and the algorithm, sufficient for q ≪ √n.
Proof sketch (checkable). Index Step times by t∈T (|T|=q_step), and Start times by j∈J (|J|=s). A false merge at Step t occurs if f(u_t) equals some previously started vertex v_j. For any fixed pair (t,j) with Start j preceding Step t, the probability that v_j equals f(u_t) is at most 1/(n−j+1): at the j-th Start, v_j is drawn uniformly from the then-unseen set (of size at least n−(j−1)), and this upper bounds the chance v_j picks that particular label w=f(u_t) (if w was seen earlier, this probability is 0 and the bound still holds). Thus by a union bound over pairs (t,j),
\[\Pr[\text{false merge at Step }t] \le \sum_{j< t}\frac{1}{n-j+1} \le \frac{s}{n-q+1}.\]
Summing over t ∈ T and using s ≤ q, q_step ≤ q gives E[X] ≤ q· s /(n−q) ≤ 2 q^2/n for q ≤ n/2. Markov gives the tail bound. Adaptivity does not invalidate the bound because we only used the (unconditional) uniformity of each Start and a union bound over disjoint Start indices.

Remark. This proof avoids Freedman/Azuma; it is robust to any adaptivity or function f. It is slightly looser (constant-factor) but sufficient in the q = O(√(n/ log n)) regime.

Lemma 2 (No-skip with high probability).
Statement. Fix an algorithm making at most q queries. Let SKIP be the event that for some Start index j, the vertex r_j (the j-th element of the global Start permutation) appears earlier as the image of a Step before the j-th Start occurs. Then Pr[SKIP] ≤ 2 q^2/n for q ≤ n/2.
Why useful. Allows coupling all algorithms to the same Start string r (as in Section 6.3 of the paper) with failure probability O(q^2/n).
Proof sketch. By union bound over Step times t and future Start indices j: for a fixed Step t and any future j, the probability that the Step’s image equals r_j is ≤ 1/(n−j+1) (same rationale as in Lemma 1). Summing j over at most q future Starts and t over q Steps gives ≤ q·q/(n−q) ≤ 2 q^2/n.

Discussion: relation between Lemmas 1 and 2. A “skip” is not the same as a false merge—skips occur when we Step into a vertex that hasn’t been declared as a Start yet (so it cannot be a false merge). The same counting method bounds both types of bad events by O(q^2/n).

Lemma 3 (Forward-only scale coupling; functions analogue of Claim 6.11).
Setup. Let A be any forward-only algorithm that (with access to the unlabeled certificate) finds a collision within q queries with decent probability. Let r be the Start string. Define E_no-merge to be the event “no false merges occur in the first 2q queries of A” and E_no-skip the event “no-skip for A with respect to r in its first 2q queries”. For 0 ≤ i < ⌊log_2 n⌋ define E_coll(i,A,2q) to be the event that A first finds a collision within 2q queries, and the collision point lies at distance in [2^i,2^{i+1}) along the forward walk W_j from its Start v_j.
Statement. Conditioned on E_no-merge ∧ E_no-skip and E_coll(i,A,2q), the single-scale process A_i (the i-th component inside A_all) will deterministically find the same collision within ≤ 4·(number of queries performed by A up to the collision) ≤ 4·2q forward steps.
Why useful. This is the scale-by-scale domination needed to transfer progress from a hypothetical competing algorithm A (with certificate) to A_all (without certificate), exactly as in §6.3 but simplified by forward-only walks.
Proof sketch. Couple A and A_i to share the same Start string r. Impose wlog an “older-first” rule on A: if two walks have identical shapes, extend the older one; this does not worsen A’s query complexity or success. Under E_no-merge, before the first collision all walks starting from distinct Starts remain disjoint; a collision occurs precisely when some walk steps into a vertex reached earlier by a different walk (closing a directed cycle also exhibits a collision and only helps). Under E_no-skip, the j-th Start in A is exactly v_j=r_j. If A’s first collision along W_j happens at distance L ∈ [2^i,2^{i+1}), then by older-first, every earlier Start v_{j′}, j′<j, has already advanced by at least 2^i steps unless its walk terminated earlier by closing a cycle (in which case A_i will also terminate that walk early and not waste more budget). The single-scale A_i extends each active walk up to 2^i steps (bidirectional walking is not needed in functions; forward-only suffices). Accounting shows A_i spends at most 2·2^i steps per good earlier Start and at most 2·(distance-to-cycle) on bad ones. Summing yields the bound of ≤ 4·(A’s work to reach L), implying A_i reaches the same collision in ≤ 4·2q steps.

Remark on cycle closure. In the function model, closing a directed cycle when stepping from u to a previously visited v supplies an immediate collision witness: f(u)=v and also f(pred(v))=v with pred(v) ≠ u (unless v was the very first vertex, which cannot happen since f has no loops). Thus early cycle closure helps, and the above amortization only becomes easier.

Proposition 4 (Epoch success probability and assembly of Theorem).
Let q⋆ = RAC(collision,f). Let A⋆ be an algorithm achieving expected q⋆ with certificate. By Markov, Pr[A⋆ finishes within 2q⋆ queries] ≥ 1/2. By Lemma 1 with q=2q⋆, Pr[E_no-merge] ≥ 1−O(q⋆^2/n). By Lemma 2, Pr[E_no-skip] ≥ 1−O(q⋆^2/n). Intersecting (and using a union bound) gives
\[\Pr[ E\_no\text{-}merge \wedge E\_no\text{-}skip \wedge (\text{A⋆ finishes within }2q\_⋆) ] \ge 1/2 - O(q\_⋆^2/n).\]
Under this event, Lemma 3 implies that in 8q⋆ rounds of A_all (each round costs O(log n) queries; 8 is a safe constant from doubling the 4 overhead), some scale A_i finds the same collision. If we assume the low-complexity regime q⋆ ≤ √n/ log^α n for α ≥ 2, then q⋆^2/n ≤ 1/ log^{2α} n is small; for large n, the success probability in one 8q⋆-round epoch is at least, say, 1/3. A geometric-series argument yields
\[ \mathbb{E}[\text{Queries}_{A\_{all}}(f)] = O(q\_⋆ \log n), \]
which is Theorem 1 with C an absolute constant and any fixed α ≥ 2 (α can be optimized; α>1 suffices with constants tracked carefully).

Sanity checks and small examples.
- Extreme indegree: f maps almost all points to a single value v_0. Starts pick v_0 with probability 1/n each time. Our Lemma 1 correctly yields E[X]=Θ(q^2/n); false merges remain rare for q ≪ √n.
- Dense cycles: if the first walk quickly closes a cycle, that already gives a collision, so A_all only improves.
- Adaptivity stress-test: an algorithm might choose Step vertices u adversarially using all past labels. Our arguments never require independence between f(u) and the past; they only rely on the per-Start uniformity of selecting r_j (and union bounds), hence are robust.

Obstacles and gaps to be tightened.
- “Older-first” wlog: As in §6.3 of the paper, one needs to argue we may modify A into an older-first tie-breaker without hurting its performance. This is standard but should be stated explicitly for functions. I believe the identical monotonicity argument carries over.
- Accounting constants in Lemma 3: I used a factor 4 overhead mirroring the graph case; it is straightforward to check in the function setting but should be written with precise per-walk budgets (2^i forward steps per older Start plus at most the distance-to-cycle for those that end early).
- No-skip proof uses a union bound over at most q future Starts for each Step. A slightly tighter bound (hypergeometric) can reduce constants but is not needed here.
- Independence of residual unseen set size: in Lemmas 1–2 I bounded 1/(n−j+1) from above by 1/(n−q), which is valid since at most q vertices can be seen by the j-th Start in the considered epoch. This detail should be recorded precisely in the formal proof.

Next steps.
1) Write full formal proofs of Lemmas 1–3 with detailed conditioning on the filtration, including the precise definition of E_coll(i,A,2q) in the function setting.
2) Optimize α. Track constants to show α = 1 suffices for large n (since q^2/n ≤ 1/log^2 n then).
3) Clarify the stopping rule for A_all in the function setting: cycle closure produces a collision witness; we can thus remove the “or cycle closes” early-stop clause or re-interpret it as immediate success.
4) Prepare coupling writeup mirroring §6.3, replacing bidirectional graph walks by forward-only function walks.

Notes on output.md. I did not see an existing output.md; if there is one, please surface it. The above lemmas strengthen the “false merges are rare” part with a simple union-bound proof and give a clean coupling in the forward-only function model. I believe this covers the key missing substitute for the graph “hardness of merging” lemma, moving us closer to a complete proof of Theorem 1 in the low-complexity regime.

=== prover-02.out.json (progress_md) ===
Ideas

- We isolate a precise, forward-only “false merges” lemma that bounds the expected number of times a forward edge lands on a vertex previously sampled only as a start. The bound is uniform over adaptive algorithms and fixed f, with randomness only from the uniform new-start oracle and the algorithm’s coins.
- We then state a clean coupling lemma for functions (forward-only) that is a faithful, simplified analogue of Claim 6.11 in the paper, replacing merging-hardness by conditioning on no false merges. This gives the scale-by-scale amortization without backward queries.
- Finally we assemble the epoch argument in the low-complexity regime q ≤ √(n)/log^α n, showing that A_all needs O(q log n) queries in expectation.

Definitions

- We consider an arbitrary (adaptive) algorithm interacting with a fixed function f:[n]→[n] (no loops). There are two operations: Start (uniform unseen vertex) and Step (query f(u) for a previously encountered u). Let S be the total number of Start operations and F the total number of Step operations in a given time window. Let X be the number of false merges in that window, i.e., the number of rounds t in which the operation is Step on u and the revealed f(u) equals a vertex v that had been obtained earlier by a Start (and v has not been reached by any Step before that time). Note that counting all hits to previously started vertices overcounts false merges, hence yields an upper bound.

Lemma A (Uniform-subset view of starts; expectation bound for false merges)

- Statement.
For any fixed function f and any adaptive algorithm, condition on a time window in which the algorithm performs exactly S starts and F forward steps. Let I be the set of images revealed by the F Step operations in the window. Then, for the randomness of the Start oracle and the internal randomness of the algorithm, the expected number of hits of Step targets into the set of started vertices is bounded by
  E[X] ≤ F·S / (n − F).
In particular E[X] ≤ F·S / n.
- Why useful here.
Setting S,F ≤ 2q in an epoch of length 2q total queries, we obtain E[X] ≤ 4 q^2/(n−2q) = O(q^2/n), hence Pr[X≥1] = O(q^2/n) by Markov. This gives “no false merges” with high probability when q ≪ √n.
- Proof sketch (fully rigorous with the permutation coupling).
Expose in advance a uniformly random permutation π of [n]. Implement each Start as returning the unseen vertex with the smallest π-rank among currently unseen vertices; this exactly realizes the uniform new-start oracle and yields exchangeability. Let I_{t} be the set of images revealed by Step operations before time t, and let s_{t} be the number of Starts before t. Then, conditional on I_{t}, the set of started vertices S_{t} is the set of the s_{t} smallest-π elements of W_{t}:=[n]\I_{t}; in particular S_{t} is uniform among all s_{t}-subsets of W_{t}. For a Step at time t with target y=f(u), if y ∈ I_{t} then no false merge occurs; otherwise
  Pr[y ∈ S_{t} | history up to t] = s_{t} / |W_{t}| ≤ s_{t}/(n−F).
Summing over all F steps yields E[X] ≤ Σ_t s_{t}/(n−F) ≤ F·S/(n−F). This bound does not assume independence between steps and starts beyond the uniformity of each Start.

Corollary A.1 (Low-complexity regime, no-false-merge w.h.p.).
Let q ≥ 1, and let the algorithm perform at most 2q queries within an epoch, of which at most 2q are Step and at most 2q are Start. Then E[X] ≤ 4q^2/(n−2q). If q ≤ √n/ log^α n and n is large enough, then E[X] ≤ 5/log^{2α}n, hence Pr[X≥1] ≤ 5/log^{2α}n.

Comment on “no-skip”. In our forward-only model, a “skip” (the j-th new start in the random order having already been seen before it is started) is exactly a false merge. Thus, a separate “no-skip” event is unnecessary once we control X.

Coupling to a single scale in the forward-only model

- Setup.
Fix any algorithm A that, given the unlabeled certificate, finds a collision in expected q queries. As in the paper, fix in advance the random permutation r listing new-start vertices, and condition on the event that A finishes within 2q queries. Additionally, condition on X=0 (no false merges) in these 2q queries. We also adopt the standard “older-first tie-break” w.l.o.g.: whenever two active walks have isomorphic revealed shapes, advance the older one. The usual symmetry/exchangeability argument under the random-start permutation permits this tie-break without harming success probability or increasing expected query complexity (we only use it for analysis).

- Single-scale amortization (functions version of Claim 6.11).
Let i be such that A’s first collision arises from a walk W_j whose distance (number of forward steps from its start v_j to the colliding image) lies in [2^i, 2^{i+1}). Under X=0 and older-first tie-break, at that time all older starts j′<j that have not terminated earlier have been advanced to at least 2^i steps, and all others have been advanced up to their own termination threshold (cycle or collision). Therefore, the single-scale process A_i that repeatedly:
  - starts at fresh random vertices and advances each active walk forward up to 2^i steps (stopping earlier upon cycle/termination/collision),
will deterministically find a collision after at most a factor-4 overhead in forward steps relative to A’s 2q steps up to the first collision. The factor 4 arises from at most doubling the budget per older active start and at most doubling for incomplete walks; as in the paper’s amortization, this constant is independent of f and i.

Assembling the bound

- Epoch definition.
Run A_all for T=8q rounds; each round performs O(log n) queries, one interleaved step for each scale i. We declare success if any scale detects a collision.
- Success probability per epoch.
By Markov, A succeeds within 2q queries with probability ≥ 1/2. By Corollary A.1 with S,F ≤ 2q, the event X=0 holds with probability ≥ 1 − O(q^2/n). Under these two events, the single-scale coupling implies that some scale i in A_all finds a collision within 8q rounds (constant-factor overhead), so the epoch succeeds. Therefore a single epoch succeeds with probability at least 1/2 − O(q^2/n). In the target regime q ≤ √n/log^α n, this is ≥ 1/3 for α large enough (e.g., any α > 1/2 suffices; choosing α as in the theorem statement gives a clean bound).
- Expected query complexity.
Each epoch costs O(q log n) queries. A geometric bound with constant success probability per epoch implies
  E[Queries_{A_all}(f)] = O(q log n) = O(log n)·RAC(collision,f),
proving Theorem (forward-only, low complexity) with appropriate absolute constants.

Examples and sanity checks

- Worst-case f with many short cycles: our Lemma A is independent of f’s structure; it upper-bounds false merges in terms of S and F only, so short cycles do not hurt the argument.
- Algorithm that starts aggressively: X scales with S·F/n, so to increase false merges substantially one must also increase S, which costs queries; in the epoch we cap S,F by O(q), keeping X small.

Obstacles / gaps to be handled next

- Older-first tie-break justification: We used the standard symmetry argument (exchangeability of unseen starting vertices under the random permutation coupling) to assume older-first without loss. It would be good to add a crisp lemma: “Among algorithms that differ only by tie-breaking between isomorphic walks, older-first does not increase the hitting time to the first collision.” This follows from considering an automorphism that swaps the two walks and averaging.
- Concentration beyond Markov: For completeness, one can promote Corollary A.1 from Markov to Freedman/Bernstein for martingales. The increments of X_t are bounded by 1 and the predictable quadratic variation is ≤ E[X], yielding tail P[X ≥ (1+δ)E[X] + λ] with exp(−Ω(min{λ,λ^2/E[X]})) bounds. This is not needed for the theorem, but could tighten constants.
- Bookkeeping for A_all: We implicitly assumed collision checks across scales are free. In the query model, only oracle queries to f are counted; set/dictionary checks are paid in time but not in queries; hence the analysis is consistent.

Concrete claims to curate into output.md

- Lemma A (E[X] ≤ F·S/(n−F)) with its permutation-coupling proof.
- Corollary A.1 (Pr[X≥1] = O(q^2/n) for S,F ≤ 2q).
- Functions-analogue of Claim 6.11 (single-scale amortization under no false merges).
- Epoch assembly yielding E[Queries_{A_all}] = O(q log n) when RAC ≤ √n/log^α n.

No output.md was provided; hence no contradictions detected there yet. I recommend adding Lemma A and the functions coupling claim as the next curated steps.

=== Verifier (summary_md) ===

=== Verifier (verdict) ===
success

