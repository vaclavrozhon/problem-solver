--- SYSTEM ---
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (summary so far)
- output.md (rigorously proven results so far)

Guidelines:
- notes.md: should be a readable running log of interesting work. Prefer appending. Replace only if old notes are clearly misleading. Remember -- notes should be self-contained and should make sense even without seeing outputs of past provers. 
- output.md: should be concise and rigorous. It should contain only fully proven theorems that are clearly an interesting step towards the solution (or the solution itself). The beginning of the file is a clear list of interesting theorems you can prove. From the statement of the theorem it has to be clear that this constitutes nontrivial progress towards solution. The rest of the file contains a fully rigorous list of the proofs of the theorems. Keep only proven theorems with clear proofs. If a statement is flawed and you cannot fix it, remove it from output.md and instead add it to notes.md with explanation.
- Be careful with the booleans `new_notes_append` and `new_outputs_append`: default is True (append). Use False only when deliberately rewriting everything.

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (â‰¥200 words). Include concrete next-step suggestions. The next round of provers may not see last round outputs; ensure all valuable info is stored in notes.",
  "new_notes_md": "Markdown (KaTeX allowed). Usually appended to notes.",
  "new_notes_append": "True|False",
  "new_outputs_md": "Markdown (KaTeX allowed). Usually appended to output.md.",
  "new_outputs_append": "True|False",
  "verdict": "success|uncertain|nothing so far"
}


--- USER ---
You receive multiple prover reports. Evaluate correctness, value, and pick promising directions. Update notes.md (append/replace) with useful ideas and update output.md (append/replace) ONLY with rigorously verified results.

Prover reports (JSON):
[{"prover_id": "01", "progress_md": "Goal. Prove Theorem (forward-only, low complexity): for any f with no loops and RAC(collision,f) \u2264 \u221an / log^\u03b1 n, the interleaved all-scales algorithm A_all finds a collision in O(log n)\u00b7RAC expected queries. The main obstacle versus the graph case is handling \u201cfalse merges\u201d in the forward-only model (walking into a vertex that was previously chosen as a start, but not yet reached by any walk), which are not collisions.\n\nPlan this round. Make rigorously checkable progress on the two technical pillars needed by the roadmap: (I) a robust bound on false merges (expectation and tail) up to q = O(\u221a(n/ polylog n)) total forward steps; (II) a scale-by-scale coupling lemma specialized to forward-only function walks (replacement for the graph Claim 6.11). Then (III) assemble into an epoch argument. I also isolate a \u201cno-skip\u201d event and give a simple union-bound proof (no Freedman needed), and point out subtleties and where more care may be required.\n\nDefinitions and notation.\n- Work with a fixed function f:[n]\u2192[n] with f(v)\u2260v for all v. The algorithm\u2019s two query types: Start draws a uniformly random unseen vertex; Step reveals f(u) for an already seen u (forward-only). A collision is exhibited when we discover u\u2260u\u2032 with f(u)=f(u\u2032).\n- Let q be an integer budget for total queries; let q_step \u2264 q be the number of Step queries (we will take q_step \u2264 2q in the epoch where we run A up to 2q queries), and s \u2264 q the number of Start queries in that epoch.\n- A \u201cfalse merge\u201d at a Step is the event that we reveal f(u)=v where v is a vertex that was previously selected via Start and has not yet been reached by any forward walk (so the edge reveals a merge, but not yet a collision). Denote by X the total number of false merges by the time we make at most q queries.\n- A random start string r: a uniformly random permutation of [n] that predetermines which unseen vertex would be chosen upon each Start; we say the \u201cno-skip\u201d event holds if the j-th Start indeed takes r_j (equivalently: none of r_1,\u2026,r_j was discovered by earlier Step queries before that Start). Skips can happen only if some Step hits a not-yet-Start vertex r_j.\n\nLemma 1 (Few false merges via a clean double-sum bound).\nStatement. For any (adaptive) forward-only algorithm that makes at most q queries and q_step Step queries (q_step \u2264 q), and for any fixed f with no loops,\n- E[X] \u2264 (q_step \u00b7 s)/(n\u2212q) \u2264 2 q^2/n for q \u2264 n/2.\n- In particular, Pr[X \u2265 1] \u2264 E[X] \u2264 2 q^2/n.\nWhy useful. Gives the \u201cno-false-merge\u201d event with probability 1\u2212O(q^2/n) uniformly over f and the algorithm, sufficient for q \u226a \u221an.\nProof sketch (checkable). Index Step times by t\u2208T (|T|=q_step), and Start times by j\u2208J (|J|=s). A false merge at Step t occurs if f(u_t) equals some previously started vertex v_j. For any fixed pair (t,j) with Start j preceding Step t, the probability that v_j equals f(u_t) is at most 1/(n\u2212j+1): at the j-th Start, v_j is drawn uniformly from the then-unseen set (of size at least n\u2212(j\u22121)), and this upper bounds the chance v_j picks that particular label w=f(u_t) (if w was seen earlier, this probability is 0 and the bound still holds). Thus by a union bound over pairs (t,j),\n\\[\\Pr[\\text{false merge at Step }t] \\le \\sum_{j< t}\\frac{1}{n-j+1} \\le \\frac{s}{n-q+1}.\\]\nSumming over t \u2208 T and using s \u2264 q, q_step \u2264 q gives E[X] \u2264 q\u00b7 s /(n\u2212q) \u2264 2 q^2/n for q \u2264 n/2. Markov gives the tail bound. Adaptivity does not invalidate the bound because we only used the (unconditional) uniformity of each Start and a union bound over disjoint Start indices.\n\nRemark. This proof avoids Freedman/Azuma; it is robust to any adaptivity or function f. It is slightly looser (constant-factor) but sufficient in the q = O(\u221a(n/ log n)) regime.\n\nLemma 2 (No-skip with high probability).\nStatement. Fix an algorithm making at most q queries. Let SKIP be the event that for some Start index j, the vertex r_j (the j-th element of the global Start permutation) appears earlier as the image of a Step before the j-th Start occurs. Then Pr[SKIP] \u2264 2 q^2/n for q \u2264 n/2.\nWhy useful. Allows coupling all algorithms to the same Start string r (as in Section 6.3 of the paper) with failure probability O(q^2/n).\nProof sketch. By union bound over Step times t and future Start indices j: for a fixed Step t and any future j, the probability that the Step\u2019s image equals r_j is \u2264 1/(n\u2212j+1) (same rationale as in Lemma 1). Summing j over at most q future Starts and t over q Steps gives \u2264 q\u00b7q/(n\u2212q) \u2264 2 q^2/n.\n\nDiscussion: relation between Lemmas 1 and 2. A \u201cskip\u201d is not the same as a false merge\u2014skips occur when we Step into a vertex that hasn\u2019t been declared as a Start yet (so it cannot be a false merge). The same counting method bounds both types of bad events by O(q^2/n).\n\nLemma 3 (Forward-only scale coupling; functions analogue of Claim 6.11).\nSetup. Let A be any forward-only algorithm that (with access to the unlabeled certificate) finds a collision within q queries with decent probability. Let r be the Start string. Define E_no-merge to be the event \u201cno false merges occur in the first 2q queries of A\u201d and E_no-skip the event \u201cno-skip for A with respect to r in its first 2q queries\u201d. For 0 \u2264 i < \u230alog_2 n\u230b define E_coll(i,A,2q) to be the event that A first finds a collision within 2q queries, and the collision point lies at distance in [2^i,2^{i+1}) along the forward walk W_j from its Start v_j.\nStatement. Conditioned on E_no-merge \u2227 E_no-skip and E_coll(i,A,2q), the single-scale process A_i (the i-th component inside A_all) will deterministically find the same collision within \u2264 4\u00b7(number of queries performed by A up to the collision) \u2264 4\u00b72q forward steps.\nWhy useful. This is the scale-by-scale domination needed to transfer progress from a hypothetical competing algorithm A (with certificate) to A_all (without certificate), exactly as in \u00a76.3 but simplified by forward-only walks.\nProof sketch. Couple A and A_i to share the same Start string r. Impose wlog an \u201colder-first\u201d rule on A: if two walks have identical shapes, extend the older one; this does not worsen A\u2019s query complexity or success. Under E_no-merge, before the first collision all walks starting from distinct Starts remain disjoint; a collision occurs precisely when some walk steps into a vertex reached earlier by a different walk (closing a directed cycle also exhibits a collision and only helps). Under E_no-skip, the j-th Start in A is exactly v_j=r_j. If A\u2019s first collision along W_j happens at distance L \u2208 [2^i,2^{i+1}), then by older-first, every earlier Start v_{j\u2032}, j\u2032<j, has already advanced by at least 2^i steps unless its walk terminated earlier by closing a cycle (in which case A_i will also terminate that walk early and not waste more budget). The single-scale A_i extends each active walk up to 2^i steps (bidirectional walking is not needed in functions; forward-only suffices). Accounting shows A_i spends at most 2\u00b72^i steps per good earlier Start and at most 2\u00b7(distance-to-cycle) on bad ones. Summing yields the bound of \u2264 4\u00b7(A\u2019s work to reach L), implying A_i reaches the same collision in \u2264 4\u00b72q steps.\n\nRemark on cycle closure. In the function model, closing a directed cycle when stepping from u to a previously visited v supplies an immediate collision witness: f(u)=v and also f(pred(v))=v with pred(v) \u2260 u (unless v was the very first vertex, which cannot happen since f has no loops). Thus early cycle closure helps, and the above amortization only becomes easier.\n\nProposition 4 (Epoch success probability and assembly of Theorem).\nLet q\u22c6 = RAC(collision,f). Let A\u22c6 be an algorithm achieving expected q\u22c6 with certificate. By Markov, Pr[A\u22c6 finishes within 2q\u22c6 queries] \u2265 1/2. By Lemma 1 with q=2q\u22c6, Pr[E_no-merge] \u2265 1\u2212O(q\u22c6^2/n). By Lemma 2, Pr[E_no-skip] \u2265 1\u2212O(q\u22c6^2/n). Intersecting (and using a union bound) gives\n\\[\\Pr[ E\\_no\\text{-}merge \\wedge E\\_no\\text{-}skip \\wedge (\\text{A\u22c6 finishes within }2q\\_\u22c6) ] \\ge 1/2 - O(q\\_\u22c6^2/n).\\]\nUnder this event, Lemma 3 implies that in 8q\u22c6 rounds of A_all (each round costs O(log n) queries; 8 is a safe constant from doubling the 4 overhead), some scale A_i finds the same collision. If we assume the low-complexity regime q\u22c6 \u2264 \u221an/ log^\u03b1 n for \u03b1 \u2265 2, then q\u22c6^2/n \u2264 1/ log^{2\u03b1} n is small; for large n, the success probability in one 8q\u22c6-round epoch is at least, say, 1/3. A geometric-series argument yields\n\\[ \\mathbb{E}[\\text{Queries}_{A\\_{all}}(f)] = O(q\\_\u22c6 \\log n), \\]\nwhich is Theorem 1 with C an absolute constant and any fixed \u03b1 \u2265 2 (\u03b1 can be optimized; \u03b1>1 suffices with constants tracked carefully).\n\nSanity checks and small examples.\n- Extreme indegree: f maps almost all points to a single value v_0. Starts pick v_0 with probability 1/n each time. Our Lemma 1 correctly yields E[X]=\u0398(q^2/n); false merges remain rare for q \u226a \u221an.\n- Dense cycles: if the first walk quickly closes a cycle, that already gives a collision, so A_all only improves.\n- Adaptivity stress-test: an algorithm might choose Step vertices u adversarially using all past labels. Our arguments never require independence between f(u) and the past; they only rely on the per-Start uniformity of selecting r_j (and union bounds), hence are robust.\n\nObstacles and gaps to be tightened.\n- \u201cOlder-first\u201d wlog: As in \u00a76.3 of the paper, one needs to argue we may modify A into an older-first tie-breaker without hurting its performance. This is standard but should be stated explicitly for functions. I believe the identical monotonicity argument carries over.\n- Accounting constants in Lemma 3: I used a factor 4 overhead mirroring the graph case; it is straightforward to check in the function setting but should be written with precise per-walk budgets (2^i forward steps per older Start plus at most the distance-to-cycle for those that end early).\n- No-skip proof uses a union bound over at most q future Starts for each Step. A slightly tighter bound (hypergeometric) can reduce constants but is not needed here.\n- Independence of residual unseen set size: in Lemmas 1\u20132 I bounded 1/(n\u2212j+1) from above by 1/(n\u2212q), which is valid since at most q vertices can be seen by the j-th Start in the considered epoch. This detail should be recorded precisely in the formal proof.\n\nNext steps.\n1) Write full formal proofs of Lemmas 1\u20133 with detailed conditioning on the filtration, including the precise definition of E_coll(i,A,2q) in the function setting.\n2) Optimize \u03b1. Track constants to show \u03b1 = 1 suffices for large n (since q^2/n \u2264 1/log^2 n then).\n3) Clarify the stopping rule for A_all in the function setting: cycle closure produces a collision witness; we can thus remove the \u201cor cycle closes\u201d early-stop clause or re-interpret it as immediate success.\n4) Prepare coupling writeup mirroring \u00a76.3, replacing bidirectional graph walks by forward-only function walks.\n\nNotes on output.md. I did not see an existing output.md; if there is one, please surface it. The above lemmas strengthen the \u201cfalse merges are rare\u201d part with a simple union-bound proof and give a clean coupling in the forward-only function model. I believe this covers the key missing substitute for the graph \u201chardness of merging\u201d lemma, moving us closer to a complete proof of Theorem 1 in the low-complexity regime."}, {"prover_id": "02", "progress_md": "Ideas\n\n- We isolate a precise, forward-only \u201cfalse merges\u201d lemma that bounds the expected number of times a forward edge lands on a vertex previously sampled only as a start. The bound is uniform over adaptive algorithms and fixed f, with randomness only from the uniform new-start oracle and the algorithm\u2019s coins.\n- We then state a clean coupling lemma for functions (forward-only) that is a faithful, simplified analogue of Claim 6.11 in the paper, replacing merging-hardness by conditioning on no false merges. This gives the scale-by-scale amortization without backward queries.\n- Finally we assemble the epoch argument in the low-complexity regime q \u2264 \u221a(n)/log^\u03b1 n, showing that A_all needs O(q log n) queries in expectation.\n\nDefinitions\n\n- We consider an arbitrary (adaptive) algorithm interacting with a fixed function f:[n]\u2192[n] (no loops). There are two operations: Start (uniform unseen vertex) and Step (query f(u) for a previously encountered u). Let S be the total number of Start operations and F the total number of Step operations in a given time window. Let X be the number of false merges in that window, i.e., the number of rounds t in which the operation is Step on u and the revealed f(u) equals a vertex v that had been obtained earlier by a Start (and v has not been reached by any Step before that time). Note that counting all hits to previously started vertices overcounts false merges, hence yields an upper bound.\n\nLemma A (Uniform-subset view of starts; expectation bound for false merges)\n\n- Statement.\nFor any fixed function f and any adaptive algorithm, condition on a time window in which the algorithm performs exactly S starts and F forward steps. Let I be the set of images revealed by the F Step operations in the window. Then, for the randomness of the Start oracle and the internal randomness of the algorithm, the expected number of hits of Step targets into the set of started vertices is bounded by\n  E[X] \u2264 F\u00b7S / (n \u2212 F).\nIn particular E[X] \u2264 F\u00b7S / n.\n- Why useful here.\nSetting S,F \u2264 2q in an epoch of length 2q total queries, we obtain E[X] \u2264 4 q^2/(n\u22122q) = O(q^2/n), hence Pr[X\u22651] = O(q^2/n) by Markov. This gives \u201cno false merges\u201d with high probability when q \u226a \u221an.\n- Proof sketch (fully rigorous with the permutation coupling).\nExpose in advance a uniformly random permutation \u03c0 of [n]. Implement each Start as returning the unseen vertex with the smallest \u03c0-rank among currently unseen vertices; this exactly realizes the uniform new-start oracle and yields exchangeability. Let I_{t} be the set of images revealed by Step operations before time t, and let s_{t} be the number of Starts before t. Then, conditional on I_{t}, the set of started vertices S_{t} is the set of the s_{t} smallest-\u03c0 elements of W_{t}:=[n]\\I_{t}; in particular S_{t} is uniform among all s_{t}-subsets of W_{t}. For a Step at time t with target y=f(u), if y \u2208 I_{t} then no false merge occurs; otherwise\n  Pr[y \u2208 S_{t} | history up to t] = s_{t} / |W_{t}| \u2264 s_{t}/(n\u2212F).\nSumming over all F steps yields E[X] \u2264 \u03a3_t s_{t}/(n\u2212F) \u2264 F\u00b7S/(n\u2212F). This bound does not assume independence between steps and starts beyond the uniformity of each Start.\n\nCorollary A.1 (Low-complexity regime, no-false-merge w.h.p.).\nLet q \u2265 1, and let the algorithm perform at most 2q queries within an epoch, of which at most 2q are Step and at most 2q are Start. Then E[X] \u2264 4q^2/(n\u22122q). If q \u2264 \u221an/ log^\u03b1 n and n is large enough, then E[X] \u2264 5/log^{2\u03b1}n, hence Pr[X\u22651] \u2264 5/log^{2\u03b1}n.\n\nComment on \u201cno-skip\u201d. In our forward-only model, a \u201cskip\u201d (the j-th new start in the random order having already been seen before it is started) is exactly a false merge. Thus, a separate \u201cno-skip\u201d event is unnecessary once we control X.\n\nCoupling to a single scale in the forward-only model\n\n- Setup.\nFix any algorithm A that, given the unlabeled certificate, finds a collision in expected q queries. As in the paper, fix in advance the random permutation r listing new-start vertices, and condition on the event that A finishes within 2q queries. Additionally, condition on X=0 (no false merges) in these 2q queries. We also adopt the standard \u201colder-first tie-break\u201d w.l.o.g.: whenever two active walks have isomorphic revealed shapes, advance the older one. The usual symmetry/exchangeability argument under the random-start permutation permits this tie-break without harming success probability or increasing expected query complexity (we only use it for analysis).\n\n- Single-scale amortization (functions version of Claim 6.11).\nLet i be such that A\u2019s first collision arises from a walk W_j whose distance (number of forward steps from its start v_j to the colliding image) lies in [2^i, 2^{i+1}). Under X=0 and older-first tie-break, at that time all older starts j\u2032<j that have not terminated earlier have been advanced to at least 2^i steps, and all others have been advanced up to their own termination threshold (cycle or collision). Therefore, the single-scale process A_i that repeatedly:\n  - starts at fresh random vertices and advances each active walk forward up to 2^i steps (stopping earlier upon cycle/termination/collision),\nwill deterministically find a collision after at most a factor-4 overhead in forward steps relative to A\u2019s 2q steps up to the first collision. The factor 4 arises from at most doubling the budget per older active start and at most doubling for incomplete walks; as in the paper\u2019s amortization, this constant is independent of f and i.\n\nAssembling the bound\n\n- Epoch definition.\nRun A_all for T=8q rounds; each round performs O(log n) queries, one interleaved step for each scale i. We declare success if any scale detects a collision.\n- Success probability per epoch.\nBy Markov, A succeeds within 2q queries with probability \u2265 1/2. By Corollary A.1 with S,F \u2264 2q, the event X=0 holds with probability \u2265 1 \u2212 O(q^2/n). Under these two events, the single-scale coupling implies that some scale i in A_all finds a collision within 8q rounds (constant-factor overhead), so the epoch succeeds. Therefore a single epoch succeeds with probability at least 1/2 \u2212 O(q^2/n). In the target regime q \u2264 \u221an/log^\u03b1 n, this is \u2265 1/3 for \u03b1 large enough (e.g., any \u03b1 > 1/2 suffices; choosing \u03b1 as in the theorem statement gives a clean bound).\n- Expected query complexity.\nEach epoch costs O(q log n) queries. A geometric bound with constant success probability per epoch implies\n  E[Queries_{A_all}(f)] = O(q log n) = O(log n)\u00b7RAC(collision,f),\nproving Theorem (forward-only, low complexity) with appropriate absolute constants.\n\nExamples and sanity checks\n\n- Worst-case f with many short cycles: our Lemma A is independent of f\u2019s structure; it upper-bounds false merges in terms of S and F only, so short cycles do not hurt the argument.\n- Algorithm that starts aggressively: X scales with S\u00b7F/n, so to increase false merges substantially one must also increase S, which costs queries; in the epoch we cap S,F by O(q), keeping X small.\n\nObstacles / gaps to be handled next\n\n- Older-first tie-break justification: We used the standard symmetry argument (exchangeability of unseen starting vertices under the random permutation coupling) to assume older-first without loss. It would be good to add a crisp lemma: \u201cAmong algorithms that differ only by tie-breaking between isomorphic walks, older-first does not increase the hitting time to the first collision.\u201d This follows from considering an automorphism that swaps the two walks and averaging.\n- Concentration beyond Markov: For completeness, one can promote Corollary A.1 from Markov to Freedman/Bernstein for martingales. The increments of X_t are bounded by 1 and the predictable quadratic variation is \u2264 E[X], yielding tail P[X \u2265 (1+\u03b4)E[X] + \u03bb] with exp(\u2212\u03a9(min{\u03bb,\u03bb^2/E[X]})) bounds. This is not needed for the theorem, but could tighten constants.\n- Bookkeeping for A_all: We implicitly assumed collision checks across scales are free. In the query model, only oracle queries to f are counted; set/dictionary checks are paid in time but not in queries; hence the analysis is consistent.\n\nConcrete claims to curate into output.md\n\n- Lemma A (E[X] \u2264 F\u00b7S/(n\u2212F)) with its permutation-coupling proof.\n- Corollary A.1 (Pr[X\u22651] = O(q^2/n) for S,F \u2264 2q).\n- Functions-analogue of Claim 6.11 (single-scale amortization under no false merges).\n- Epoch assembly yielding E[Queries_{A_all}] = O(q log n) when RAC \u2264 \u221an/log^\u03b1 n.\n\nNo output.md was provided; hence no contradictions detected there yet. I recommend adding Lemma A and the functions coupling claim as the next curated steps."}]

Current notes.md:


Current output.md (if any):

