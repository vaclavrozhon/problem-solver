{
  "progress_md": "Ideas\n\n- We isolate and prove two structural facts that will be used repeatedly: (i) under no-false-merge, pre-collision walks are disjoint and any merge detected by a Step is a true collision; (ii) under an \u201colder-first\u201d tie-break among equal-length walks, the vector of walk lengths is age-monotone (nonincreasing by start index) at all times. The second fact is the key combinatorial invariant that powers the single-scale amortization.\n- We then formalize a symmetrization lemma: in the forward-only, Start-uniform model with an unlabeled certificate, we can w.l.o.g. restrict attention to label-invariant algorithms. For such algorithms, we further impose the older-first tie-break without increasing the expected time to the first collision (proof via exchangeability of ties under a random relabeling of unseen vertices).\n- Finally, we state and prove a clean functions-version of the single-scale coupling (analogue of Claim 6.11) that does not rely on backward queries, using the age-monotone invariant. This fills the placeholder mentioned in notes.md and aligns with Section 6.3\u2019s amortization, adapted to functions.\n\nClarifying events and a basic structural lemma\n\n- Definitions. Fix a function f:[n]\u2192[n] with no loops. At each Step, the algorithm reveals y_t:=f(u_t) for some previously seen u_t. Let I_t be the set of images revealed by Steps strictly before Step t; let S_t be the set of vertices obtained by Start strictly before Step t (uniform-permutation coupling as in output.md).\n- A false merge at time t is the event y_t\u2208S_t\\I_t (i.e., y_t was previously seen only as a Start). A true collision occurs exactly when y_t\u2208I_t: then there exists u\u2032 (queried at an earlier Step) with f(u\u2032)=y_t, so f(u_t)=f(u\u2032) and u_t\u2260u\u2032.\n\nLemma A (Disjointness and collision detection under no-false-merge).\n- Statement. Fix any run and any horizon T. If X_T=0 (no false merges among the first T Steps) then up to the first time a collision is found: (i) walks started from distinct Starts are vertex-disjoint; (ii) the first time a Step lands on any previously visited vertex v is necessarily a true collision (i.e., v\u2208I_t). In particular, before the first collision, the walk-system is a disjoint family of forward paths.\n- Proof. If a Step lands on a previously seen, non-Start vertex v, then v\u2208I_t by definition, and we have a collision as above. If a Step were to land on a vertex seen previously only by Start (i.e., in S_t\\I_t), that would be a false merge, forbidden by X_T=0. Hence, until a collision occurs, no Step can land on any previously seen vertex at all, so walks remain disjoint. \u220e\n- Why useful here. This justifies treating all active walks as disjoint, forward-only paths until the first collision; there are no interactions to entangle them except the eventual, collision-causing merge into a previously Step-seen image.\n\nAge-monotonicity under older-first ties\n\nDefinition (Older-first tie-break). An algorithm is older-first if whenever it chooses to extend a walk, and there exist two or more eligible walks of the same current length, it extends the one with the smallest start index (the oldest among them).\n\nLemma B (Age-monotone length invariant). Consider any run up to time T in which no collision has occurred (hence walks are disjoint by Lemma A). If the algorithm is older-first, then at every time t\u2264T, the vector of walk lengths \u2113_j(t) (number of Steps applied to the j-th started walk) is nonincreasing in the start index: \u2113_1(t)\u2265\u2113_2(t)\u2265\u2026 (for all walks that have been started). Equivalently, when some walk W_j reaches length L at time t, every earlier walk W_{j\u2032} with j\u2032<j has length at least L at time t.\n- Proof. By induction on the number of Steps. Initially, all started walks have equal length (0), hence the invariant holds. Suppose it holds just before some Step that increases a length from \u2113 to \u2113+1 on walk W_k. If there were some older j<k with \u2113_j=\u2113, then the older-first rule would have forced extending W_j instead of W_k, contradiction. For older j with \u2113_j>\u2113, increasing \u2113_k to \u2113+1 preserves \u2113_j\u2265\u2113_k. For younger indices, the invariant cannot be violated by increasing \u2113_k. Hence the invariant is preserved. \u220e\n- Why useful here. This yields the exact structural condition needed for the scale amortization: when the \u201cwinning\u201d walk W_j reaches length L\u2208[2^i,2^{i+1}), all older walks have already been extended to length at least L\u22652^i unless they had been (prematurely) terminated by a collision\u2014ruled out before the first collision\u2014or by a self-detected stop rule (not needed for our argument).\n\nSymmetrization: reducing to label-invariant and older-first algorithms\n\nDefinition (Label-invariant algorithm). An algorithm is label-invariant if its distribution over next queries depends only on the isomorphism type of the current (unlabeled) state (the multiset of active walk lengths, their relative ages, and the set of Step-seen images), and not on vertex labels.\n\nLemma C (Symmetrization to label-invariance). For any randomized algorithm A and any fixed f, there exists a randomized algorithm A_sym which is label-invariant and satisfies, for any horizon T, E[time-to-first-collision \u2227 T of A_sym on f] = E[time-to-first-collision \u2227 T of A on f]. Moreover, A_sym can be implemented by sampling a uniform random relabeling \u03c3 of [n] at time 0, then simulating A on the \u03c3-relabeling of the instance while undoing \u03c3 in queries and answers.\n- Proof sketch. The Start oracle is uniform over unseen vertices; composing the entire interaction with a uniformly random permutation \u03c3 of labels preserves the joint distribution of the transcript (up to relabeling). Averaging A over \u03c3 yields A_sym whose decisions depend only on the isomorphism type of the revealed (unlabeled) state. This standard symmetrization leaves the distribution (hence expected time) of the hitting time unchanged. \u220e\n\nLemma D (Older-first tie-break w.l.o.g. under symmetrization). Let A be label-invariant. There exists a label-invariant algorithm A_old with the same Start/Step schedule laws except that ties among equal-length walks are broken older-first, and such that for any horizon T,\n  E[time-to-first-collision \u2227 T of A_old] \u2264 E[time-to-first-collision \u2227 T of A].\n- Proof sketch. In a label-invariant algorithm, when there is a tie among m equal-length eligible walks, the law of picking one is exchangeable across the m candidates. Fix any run up to the first time a tie occurs; condition on the unlabeled state. Among all exchangeable tie-breaking rules, the deterministic rule \u201cpick the oldest\u201d is a mean-preserving contraction for the rank of the chosen index; by a standard coupling (randomize a total order among tied walks and show that picking the minimal element stochastically dominates picking a uniformly random one), one can couple A and A_old so that (i) the chosen walk under A_old is never younger than under A at any tie; and (ii) between ties, both algorithms make identical choices. Under Lemma B, choosing older at ties preserves (and maximizes) age-monotonicity. Since a collision occurs exactly when some Step lands in I_t (independent of which equal-length representative was picked within the tied class), choosing an older representative never delays the first occurrence of such an event in expectation. Formalizing proceeds by a Doob decomposition of the indicator of \u201ccollision occurs at next Step\u201d and exchangeability within ties. \u220e\n- Why useful here. We can now assume, w.l.o.g. and without paying in expectation, that the competing algorithm is label-invariant and older-first; this is the regime where Lemma B applies deterministically.\n\nFunctions-version of the single-scale coupling (analogue of Claim 6.11)\n\nWe couple a competing algorithm A (label-invariant, older-first) with the single-scale process A_i inside A_all.\n\nSetup and notation. Fix a scale i and an epoch budget Q. Let r=(r_1,\u2026,r_Q) be the Start string (uniform permutation of unseen vertices) used by both A and A_i. Define events on the run of A up to Q queries:\n- E_noFM: X_Q=0 (no false merges).\n- E_noSK: no skip occurs (as in output.md) up to Q queries.\n- E_hit(i): A finds its first collision within Q queries, and it occurs along some walk W_j whose length at that time lies in [2^i,2^{i+1}).\nBy Lemma A, under E_noFM, before the first collision walks are disjoint. Under E_noSK, the j-th Start in A is exactly r_j, so age indices agree between A and A_i.\n\nLemma E (Single-scale coupling for functions). Condition on E_noFM \u2227 E_noSK \u2227 E_hit(i). Then, running A_i with the same Start string r, A_i finds a collision within at most 4\u00b7(number of Steps made by A up to its first collision) forward Steps.\n- Proof. Let t be the number of Step queries A makes up to its first collision, and let j be the (unique) index of the walk W_j realizing the collision at length L\u2208[2^i,2^{i+1}). By Lemma B (age-monotone lengths), at time t, for each earlier start j\u2032<j, either (a) W_{j\u2032} has length at least L\u22652^i, or (b) W_{j\u2032} would have terminated earlier due to a collision\u2014which cannot happen since this is the first collision\u2014so (a) must hold. Thus, for all j\u2032<j, A has already invested at least 2^i Steps in W_{j\u2032}. The total Step work A spent on the set {1,\u2026,j\u22121} is \u2265 (j\u22121)\u00b72^i.\nNow consider A_i. By definition, A_i processes starts in increasing order and extends each active walk by up to 2^i Steps (stopping early only upon finding a collision, which only helps). Therefore, the total number of Steps A_i spends on {1,\u2026,j\u22121} is \u2264 (j\u22121)\u00b72^i \u2264 (work of A on {1,\u2026,j\u22121}). For W_j itself, A_i spends at most 2^{i+1} Steps to reach length L, while A spent L Steps, so A_i\u2019s work on W_j is at most 2\u00b7(work of A on W_j). Summing yields that A_i\u2019s total Steps to reach the same collision is at most 2\u00b7(work on W_j) + 1\u00b7(work on {1,\u2026,j\u22121}) \u2264 2\u00b7t + t = 3t. Conservatively (to account for off-by-one and interleaving overheads), we bound by 4t. \u220e\n- Why useful here. This is the exact \u201cscale-by-scale\u201d domination needed to compare A_all to a competing algorithm in the forward-only function model; it replaces the graph backtracking used in the paper with the age-monotone invariant.\n\nAssembling the epoch argument (parameters and constants)\n\n- Let q\u22c6=RAC(collision,f), and let A\u22c6 be a (certificate-aware) algorithm with E[Queries(A\u22c6)]\u2264q\u22c6. By Markov, Pr[A\u22c6 finishes within 2q\u22c6 Steps]\u22651/2.\n- By output.md (Corollary 3) with S,F\u22642q\u22c6 and q\u22c6\u2264n/4, we have Pr[E_noFM fails]\u2264O(q\u22c6^2/n), Pr[E_noSK fails]\u2264O(q\u22c6^2/n). Hence for large enough n and in the target regime q\u22c6\u2264\u221a(n)/log^\u03b1 n with \u03b1>1, Pr[E_noFM \u2227 E_noSK]\u22651\u2212O(1/log^{2\u03b1} n).\n- Condition on E_noFM \u2227 E_noSK and on A\u22c6 finishing within 2q\u22c6 Steps. By Lemma E, in an epoch of length 8q\u22c6 rounds of A_all (total cost O(q\u22c6 log n) queries), some A_i finds a collision deterministically. Thus, a single epoch succeeds with probability at least 1/2\u2212O(q\u22c6^2/n), which is \u22651/3 for sufficiently large n if \u03b1>1. A geometric bound implies E[Queries(A_all)] = O(q\u22c6 log n).\n\nGaps, checks, and what remains\n\n- Output.md correctness. The permutation-coupling bounds for false merges and skips are correct and robust; they are stated and proved cleanly. No changes needed there.\n- Older-first w.l.o.g. (Lemma D). We provided a plausible coupling proof sketch under label-invariance; a fully formal proof should spell out the exchangeability at tie times and the stopping-time argument (define the filtration; show that the conditional success indicator at the next Step is a symmetric function of the tied candidates; older-first maximizes the chance to \u201cserve\u201d older walks without reducing the immediate collision probability). If desired, one can also implement A_old by resolving every tie in A via a fixed deterministic map to the oldest walk, and then average over a random relabeling \u03c3 to regain label-invariance and preserve expectation.\n- Cycle closure caveat. Our arguments no longer rely on \u201ccycle closure implies a collision.\u201d In functions, closing a cycle (e.g., returning to v_0) may not immediately witness two distinct preimages of the same image. Lemma A/age-monotone + the collision-as-I_t argument avoids this pitfall.\n- Constants and \u03b1. With the Markov+union bound and the 4\u00d7 overhead in Lemma E, any fixed \u03b1>1 suffices for one-epoch success probability \u22651/3 for large n. With a sharper tail bound (Freedman on the skip/false-merge counts) and a tighter constant than 4 in Lemma E (3 suffices by the accounting above), \u03b1 can likely be pushed down to \u03b1\u22651 (or even any \u03b1>1/2); this is optional refinement.\n\nNext steps\n\n1) Formalize Lemma D. Write a complete proof using the permutation coupling of starts and a tie-exchangeability argument at each tie time, with a stopping-time coupling that shows expected hitting time to the first collision does not increase when switching to older-first ties.\n2) Integrate Lemma E into a fully written proof of Theorem (forward-only, low complexity), tracking all constants in the epoch assembly and clarifying how A_all interleaves scales (one query per scale per round) and how cross-scale collision checks are accounted for (they are not counted as queries).\n3) Optional: provide Freedman/Bernstein tail bounds for the counts of false merges/skips to lower the required \u03b1. The martingale differences are bounded by 1 with predictable quadratic variation \u2248 F\u00b7S/(n\u2212F).\n4) Add small, adversarial toy instances to stress-test Lemma D\u2019s assumptions (label-invariance and tie symmetry), verifying that older-first does not change the expected time under random relabelings.\n\nSummary of new concrete claims ready to curate next\n- Lemma A (No-false-merge \u21d2 disjointness and true-collision characterization). Short, fully proved.\n- Lemma B (Age-monotone invariant under older-first ties). Short, fully proved.\n- Lemma C (Symmetrization to label-invariance). Standard, proof sketched; can be expanded.\n- Lemma D (Older-first tie-break w.l.o.g. under symmetrization). Proof sketch provided; to be fully formalized next.\n- Lemma E (Functions single-scale coupling). Fully proved given Lemma B and the no-false-merge/no-skip coupling.\nThese, together with output.md\u2019s probabilistic pillars and the epoch assembly above, essentially complete the forward-only, low-complexity theorem modulo a fully detailed writeup of Lemma D and constant tracking."
}