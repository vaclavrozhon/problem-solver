--- SYSTEM ---
You are a research **summarizer**. Summarize this *last round only* for a human log.

Include:
- 3–7 bullet **Highlights** (facts learned, reductions, counterexamples, partial bounds).
- 1–3 **Open questions / TODOs** for the next round.
- 1–3 **Citations to files** you relied on (e.g. round files or papers by name).

**Return strictly JSON**:
{
  "summary_md": "Readable summary of the round (≤200 words)",
  "highlights": [],
  "next_questions": []
}

--- USER ---
=== prover-01.out.json (progress_md) ===
Ideas

- We isolate and prove two structural facts that will be used repeatedly: (i) under no-false-merge, pre-collision walks are disjoint and any merge detected by a Step is a true collision; (ii) under an “older-first” tie-break among equal-length walks, the vector of walk lengths is age-monotone (nonincreasing by start index) at all times. The second fact is the key combinatorial invariant that powers the single-scale amortization.
- We then formalize a symmetrization lemma: in the forward-only, Start-uniform model with an unlabeled certificate, we can w.l.o.g. restrict attention to label-invariant algorithms. For such algorithms, we further impose the older-first tie-break without increasing the expected time to the first collision (proof via exchangeability of ties under a random relabeling of unseen vertices).
- Finally, we state and prove a clean functions-version of the single-scale coupling (analogue of Claim 6.11) that does not rely on backward queries, using the age-monotone invariant. This fills the placeholder mentioned in notes.md and aligns with Section 6.3’s amortization, adapted to functions.

Clarifying events and a basic structural lemma

- Definitions. Fix a function f:[n]→[n] with no loops. At each Step, the algorithm reveals y_t:=f(u_t) for some previously seen u_t. Let I_t be the set of images revealed by Steps strictly before Step t; let S_t be the set of vertices obtained by Start strictly before Step t (uniform-permutation coupling as in output.md).
- A false merge at time t is the event y_t∈S_t\I_t (i.e., y_t was previously seen only as a Start). A true collision occurs exactly when y_t∈I_t: then there exists u′ (queried at an earlier Step) with f(u′)=y_t, so f(u_t)=f(u′) and u_t≠u′.

Lemma A (Disjointness and collision detection under no-false-merge).
- Statement. Fix any run and any horizon T. If X_T=0 (no false merges among the first T Steps) then up to the first time a collision is found: (i) walks started from distinct Starts are vertex-disjoint; (ii) the first time a Step lands on any previously visited vertex v is necessarily a true collision (i.e., v∈I_t). In particular, before the first collision, the walk-system is a disjoint family of forward paths.
- Proof. If a Step lands on a previously seen, non-Start vertex v, then v∈I_t by definition, and we have a collision as above. If a Step were to land on a vertex seen previously only by Start (i.e., in S_t\I_t), that would be a false merge, forbidden by X_T=0. Hence, until a collision occurs, no Step can land on any previously seen vertex at all, so walks remain disjoint. ∎
- Why useful here. This justifies treating all active walks as disjoint, forward-only paths until the first collision; there are no interactions to entangle them except the eventual, collision-causing merge into a previously Step-seen image.

Age-monotonicity under older-first ties

Definition (Older-first tie-break). An algorithm is older-first if whenever it chooses to extend a walk, and there exist two or more eligible walks of the same current length, it extends the one with the smallest start index (the oldest among them).

Lemma B (Age-monotone length invariant). Consider any run up to time T in which no collision has occurred (hence walks are disjoint by Lemma A). If the algorithm is older-first, then at every time t≤T, the vector of walk lengths ℓ_j(t) (number of Steps applied to the j-th started walk) is nonincreasing in the start index: ℓ_1(t)≥ℓ_2(t)≥… (for all walks that have been started). Equivalently, when some walk W_j reaches length L at time t, every earlier walk W_{j′} with j′<j has length at least L at time t.
- Proof. By induction on the number of Steps. Initially, all started walks have equal length (0), hence the invariant holds. Suppose it holds just before some Step that increases a length from ℓ to ℓ+1 on walk W_k. If there were some older j<k with ℓ_j=ℓ, then the older-first rule would have forced extending W_j instead of W_k, contradiction. For older j with ℓ_j>ℓ, increasing ℓ_k to ℓ+1 preserves ℓ_j≥ℓ_k. For younger indices, the invariant cannot be violated by increasing ℓ_k. Hence the invariant is preserved. ∎
- Why useful here. This yields the exact structural condition needed for the scale amortization: when the “winning” walk W_j reaches length L∈[2^i,2^{i+1}), all older walks have already been extended to length at least L≥2^i unless they had been (prematurely) terminated by a collision—ruled out before the first collision—or by a self-detected stop rule (not needed for our argument).

Symmetrization: reducing to label-invariant and older-first algorithms

Definition (Label-invariant algorithm). An algorithm is label-invariant if its distribution over next queries depends only on the isomorphism type of the current (unlabeled) state (the multiset of active walk lengths, their relative ages, and the set of Step-seen images), and not on vertex labels.

Lemma C (Symmetrization to label-invariance). For any randomized algorithm A and any fixed f, there exists a randomized algorithm A_sym which is label-invariant and satisfies, for any horizon T, E[time-to-first-collision ∧ T of A_sym on f] = E[time-to-first-collision ∧ T of A on f]. Moreover, A_sym can be implemented by sampling a uniform random relabeling σ of [n] at time 0, then simulating A on the σ-relabeling of the instance while undoing σ in queries and answers.
- Proof sketch. The Start oracle is uniform over unseen vertices; composing the entire interaction with a uniformly random permutation σ of labels preserves the joint distribution of the transcript (up to relabeling). Averaging A over σ yields A_sym whose decisions depend only on the isomorphism type of the revealed (unlabeled) state. This standard symmetrization leaves the distribution (hence expected time) of the hitting time unchanged. ∎

Lemma D (Older-first tie-break w.l.o.g. under symmetrization). Let A be label-invariant. There exists a label-invariant algorithm A_old with the same Start/Step schedule laws except that ties among equal-length walks are broken older-first, and such that for any horizon T,
  E[time-to-first-collision ∧ T of A_old] ≤ E[time-to-first-collision ∧ T of A].
- Proof sketch. In a label-invariant algorithm, when there is a tie among m equal-length eligible walks, the law of picking one is exchangeable across the m candidates. Fix any run up to the first time a tie occurs; condition on the unlabeled state. Among all exchangeable tie-breaking rules, the deterministic rule “pick the oldest” is a mean-preserving contraction for the rank of the chosen index; by a standard coupling (randomize a total order among tied walks and show that picking the minimal element stochastically dominates picking a uniformly random one), one can couple A and A_old so that (i) the chosen walk under A_old is never younger than under A at any tie; and (ii) between ties, both algorithms make identical choices. Under Lemma B, choosing older at ties preserves (and maximizes) age-monotonicity. Since a collision occurs exactly when some Step lands in I_t (independent of which equal-length representative was picked within the tied class), choosing an older representative never delays the first occurrence of such an event in expectation. Formalizing proceeds by a Doob decomposition of the indicator of “collision occurs at next Step” and exchangeability within ties. ∎
- Why useful here. We can now assume, w.l.o.g. and without paying in expectation, that the competing algorithm is label-invariant and older-first; this is the regime where Lemma B applies deterministically.

Functions-version of the single-scale coupling (analogue of Claim 6.11)

We couple a competing algorithm A (label-invariant, older-first) with the single-scale process A_i inside A_all.

Setup and notation. Fix a scale i and an epoch budget Q. Let r=(r_1,…,r_Q) be the Start string (uniform permutation of unseen vertices) used by both A and A_i. Define events on the run of A up to Q queries:
- E_noFM: X_Q=0 (no false merges).
- E_noSK: no skip occurs (as in output.md) up to Q queries.
- E_hit(i): A finds its first collision within Q queries, and it occurs along some walk W_j whose length at that time lies in [2^i,2^{i+1}).
By Lemma A, under E_noFM, before the first collision walks are disjoint. Under E_noSK, the j-th Start in A is exactly r_j, so age indices agree between A and A_i.

Lemma E (Single-scale coupling for functions). Condition on E_noFM ∧ E_noSK ∧ E_hit(i). Then, running A_i with the same Start string r, A_i finds a collision within at most 4·(number of Steps made by A up to its first collision) forward Steps.
- Proof. Let t be the number of Step queries A makes up to its first collision, and let j be the (unique) index of the walk W_j realizing the collision at length L∈[2^i,2^{i+1}). By Lemma B (age-monotone lengths), at time t, for each earlier start j′<j, either (a) W_{j′} has length at least L≥2^i, or (b) W_{j′} would have terminated earlier due to a collision—which cannot happen since this is the first collision—so (a) must hold. Thus, for all j′<j, A has already invested at least 2^i Steps in W_{j′}. The total Step work A spent on the set {1,…,j−1} is ≥ (j−1)·2^i.
Now consider A_i. By definition, A_i processes starts in increasing order and extends each active walk by up to 2^i Steps (stopping early only upon finding a collision, which only helps). Therefore, the total number of Steps A_i spends on {1,…,j−1} is ≤ (j−1)·2^i ≤ (work of A on {1,…,j−1}). For W_j itself, A_i spends at most 2^{i+1} Steps to reach length L, while A spent L Steps, so A_i’s work on W_j is at most 2·(work of A on W_j). Summing yields that A_i’s total Steps to reach the same collision is at most 2·(work on W_j) + 1·(work on {1,…,j−1}) ≤ 2·t + t = 3t. Conservatively (to account for off-by-one and interleaving overheads), we bound by 4t. ∎
- Why useful here. This is the exact “scale-by-scale” domination needed to compare A_all to a competing algorithm in the forward-only function model; it replaces the graph backtracking used in the paper with the age-monotone invariant.

Assembling the epoch argument (parameters and constants)

- Let q⋆=RAC(collision,f), and let A⋆ be a (certificate-aware) algorithm with E[Queries(A⋆)]≤q⋆. By Markov, Pr[A⋆ finishes within 2q⋆ Steps]≥1/2.
- By output.md (Corollary 3) with S,F≤2q⋆ and q⋆≤n/4, we have Pr[E_noFM fails]≤O(q⋆^2/n), Pr[E_noSK fails]≤O(q⋆^2/n). Hence for large enough n and in the target regime q⋆≤√(n)/log^α n with α>1, Pr[E_noFM ∧ E_noSK]≥1−O(1/log^{2α} n).
- Condition on E_noFM ∧ E_noSK and on A⋆ finishing within 2q⋆ Steps. By Lemma E, in an epoch of length 8q⋆ rounds of A_all (total cost O(q⋆ log n) queries), some A_i finds a collision deterministically. Thus, a single epoch succeeds with probability at least 1/2−O(q⋆^2/n), which is ≥1/3 for sufficiently large n if α>1. A geometric bound implies E[Queries(A_all)] = O(q⋆ log n).

Gaps, checks, and what remains

- Output.md correctness. The permutation-coupling bounds for false merges and skips are correct and robust; they are stated and proved cleanly. No changes needed there.
- Older-first w.l.o.g. (Lemma D). We provided a plausible coupling proof sketch under label-invariance; a fully formal proof should spell out the exchangeability at tie times and the stopping-time argument (define the filtration; show that the conditional success indicator at the next Step is a symmetric function of the tied candidates; older-first maximizes the chance to “serve” older walks without reducing the immediate collision probability). If desired, one can also implement A_old by resolving every tie in A via a fixed deterministic map to the oldest walk, and then average over a random relabeling σ to regain label-invariance and preserve expectation.
- Cycle closure caveat. Our arguments no longer rely on “cycle closure implies a collision.” In functions, closing a cycle (e.g., returning to v_0) may not immediately witness two distinct preimages of the same image. Lemma A/age-monotone + the collision-as-I_t argument avoids this pitfall.
- Constants and α. With the Markov+union bound and the 4× overhead in Lemma E, any fixed α>1 suffices for one-epoch success probability ≥1/3 for large n. With a sharper tail bound (Freedman on the skip/false-merge counts) and a tighter constant than 4 in Lemma E (3 suffices by the accounting above), α can likely be pushed down to α≥1 (or even any α>1/2); this is optional refinement.

Next steps

1) Formalize Lemma D. Write a complete proof using the permutation coupling of starts and a tie-exchangeability argument at each tie time, with a stopping-time coupling that shows expected hitting time to the first collision does not increase when switching to older-first ties.
2) Integrate Lemma E into a fully written proof of Theorem (forward-only, low complexity), tracking all constants in the epoch assembly and clarifying how A_all interleaves scales (one query per scale per round) and how cross-scale collision checks are accounted for (they are not counted as queries).
3) Optional: provide Freedman/Bernstein tail bounds for the counts of false merges/skips to lower the required α. The martingale differences are bounded by 1 with predictable quadratic variation ≈ F·S/(n−F).
4) Add small, adversarial toy instances to stress-test Lemma D’s assumptions (label-invariance and tie symmetry), verifying that older-first does not change the expected time under random relabelings.

Summary of new concrete claims ready to curate next
- Lemma A (No-false-merge ⇒ disjointness and true-collision characterization). Short, fully proved.
- Lemma B (Age-monotone invariant under older-first ties). Short, fully proved.
- Lemma C (Symmetrization to label-invariance). Standard, proof sketched; can be expanded.
- Lemma D (Older-first tie-break w.l.o.g. under symmetrization). Proof sketch provided; to be fully formalized next.
- Lemma E (Functions single-scale coupling). Fully proved given Lemma B and the no-false-merge/no-skip coupling.
These, together with output.md’s probabilistic pillars and the epoch assembly above, essentially complete the forward-only, low-complexity theorem modulo a fully detailed writeup of Lemma D and constant tracking.

=== prover-02.out.json (progress_md) ===
## Round 0002 — Forward-only coupling: older-first pacing and single-scale domination

Summary of what is already curated (output.md)
- The permutation-coupling bounds for both false merges and skips are correct and robust: for an epoch with S starts and F steps, E[#false merges] ≤ F·S/(n−F) and E[#skips] ≤ F·S/(n−F), hence each occurs with probability O(q^2/n) in 2q-query epochs. These are uniform over f and over fully adaptive algorithms. No changes needed.

Gaps remaining toward the target theorem
- We still need a precise, checkable coupling from an arbitrary (certificate-aided) algorithm A to a single-scale process A_i in the forward-only model. The sticking point is “older-first” tie-breaking. Rather than claim w.l.o.g. directly, we propose and prove a pacing wrapper that enforces an older-first discipline with at most a constant-factor overhead. We then prove a clean single-scale domination lemma under the two rare-event conditions (no false merges, no skips).

Definitions to fix notation
- We work with a fixed f:[n]→[n] (no loops). A Start returns a uniformly random unseen vertex (unseen means neither returned by Start before nor revealed as an image of any Step). A Step on u reveals y=f(u).
- Let r be the global random start-permutation (as in output.md). For a time window of at most T total queries, define SKIP(A,T,r) and FM(A,T,r) to be the events that A incurs at least one skip or false merge, respectively, within that window relative to r (as in the curated lemmas).
- For a run of A up to its first collision, let W_j be the walk (indexed by the j-th Start of A under r) on which the first collision is found, and let L be the distance from its start to the colliding image at that moment.

Lemma OF (older-first pacing wrapper; forward-only, deterministic statement).
- Statement. Fix f, a (possibly adaptive) algorithm A, a start permutation r, and an integer i≥0. There exists a wrapper algorithm B=B[A,i] that, given the same f and r, makes only forward queries and satisfies: for any integer T≥1, if A finds a collision within ≤T queries, then B finds a collision within ≤2T queries. Moreover, in the run of B up to the moment when W_j first reaches length ≥2^i (or terminates), B enforces the following discipline: whenever A attempts to advance some walk W_ℓ of current length <2^i while there exists an older (ℓ′<ℓ) active walk of length <2^i, B advances one such older walk instead; otherwise B advances as A does.
- Why useful here. This provides an “older-first up to 2^i” property sufficient for the single-scale amortization, without assuming any stochastic optimality of older-first. The overhead is at most a factor two in query count to the first collision.
- Proof sketch (checkable). B simulates A step-by-step but with the scheduling rule in the statement: in each simulated A-step, if A’s choice respects the discipline, B issues the same Step/Start; if not, B issues one Step on an older active walk with current length <2^i (arbitrarily breaking ties), then in the next B-move carries out A’s planned Step. Thus, each simulated A-step causes either one or two B-steps; hence if A halts by time T, B halts by time ≤2T. That B does not delay the existence of a collision follows because B never undoes revealed information: by the time B completes the first T simulated A-steps (in possibly different order, interleaved with at most T catch-up steps), it has revealed a superset of the images revealed by A up to its collision time; revealing more edges cannot preclude a collision that A witnessed, so B must witness a (possibly earlier) collision by then. The rule ensures that prior to any W_ℓ exceeding 2^i, all older active walks have been advanced to min{2^i, their termination distance}.

Lemma SC (single-scale domination; forward-only functions, analogue of Claim 6.11).
- Setup. Fix f, a certificate-aided algorithm A that finds a collision within q queries with probability ≥1/2, a start permutation r, and scale i with 2^i ≤n. Run the pacing wrapper B=B[A,i]. Define the events:
  • E1:= ¬FM(A,2q,r) ∧ ¬SKIP(A,2q,r) (no false merges, no skips for A within 2q queries).
  • E2(i):= ¬FM(A_i,4q,r) ∧ ¬SKIP(A_i,4q,r) (no false merges, no skips for the single-scale process A_i within 4q queries; A_i uses starts from r and extends each active walk forward up to 2^i steps, stopping earlier if it revisits a seen vertex or closes a directed cycle).
  • Ecoll(i): the first collision of A occurs on W_j at distance L∈[2^i,2^{i+1}).
- Statement. Conditioned on E1 ∧ E2(i) ∧ Ecoll(i), the process A_i (with start order r) deterministically finds a collision within at most 4q forward queries.
- Why useful here. This is the scale-by-scale coupling needed to transfer progress from an optimal certificate algorithm to the all-scales strategy.
- Proof (detailed charging). Throughout, couple A_i and B to share the start order r (E2(i) guarantees A_i’s j-th Start equals r_j; E1 guarantees A’s j-th Start equals r_j and that before the first collision, any step into a previously seen vertex is a true collision, never a false merge). Consider the run of B up to the first collision of A; by Lemma OF, this takes ≤2q queries and, by construction, enforces that for any active walk with index ≤j−1 (older than W_j), its length at the time W_j first reaches 2^i is at least min{2^i, its termination distance}.
  Define the “budget” that A_i must spend before it reaches the same collision as A:
  • For each older start ℓ<j whose walk does not terminate earlier, A_i must advance it to length exactly 2^i (it resets or freezes thereafter). For each older start that terminates earlier (by hitting a previously seen vertex or closing a cycle), A_i must advance it up to that termination length.
  • For the colliding walk W_j, A_i must advance it to distance L (≤2^{i+1}−1).
  All other work A_i may do (e.g., advancing younger starts or beyond-2^i work on older ones) only delays success and can be charged to the above items by truncating the schedule, so it suffices to bound this budget.
  By the enforced discipline of B, for each ℓ<j either B has already spent ≥2^i steps on W_ℓ (if it remained active), or B has spent at least its termination length advancing W_ℓ to termination. Thus, summing over ℓ<j, A_i’s total budget on older starts is upper bounded by B’s total steps spent on older starts up to the time W_j reaches length 2^i. Similarly, A_i’s work on W_j up to length L is at most B’s work on W_j up to that moment (since B follows A’s choices on W_j except for interleaving catch-ups). Therefore, the total budget A_i needs is ≤ (B’s steps on older starts) + (B’s steps on W_j) ≤ (total steps of B up to A’s collision time) ≤ 2q by Lemma OF.
  Finally, A_i may incur at most a constant-factor overhead due to interleaving and possible partial restarts across attempts; a standard doubling/truncation argument (identical to the graphs case) shows that simulating the above budget with A_i costs at most a factor 2 in queries, because each active older walk is extended forward in disjoint prefixes up to its own cap (2^i or termination), and work on W_j is in addition. Hence A_i finds the collision within ≤4q steps. Determinism follows because, under E1 and E2(i), the relative order of starts is aligned by r and no skip/false-merge alters it.

Epoch assembly (quantitative bound and α)
- Let q⋆:=RAC(collision,f). Choose A to be a certificate-aided algorithm with E[queries]≤q⋆. By Markov, Pr[A finishes within 2q⋆] ≥ 1/2. For a fixed scale i, the curated bounds yield:
  • Pr[FM(A,2q⋆,r) ∪ SKIP(A,2q⋆,r)] ≤ c·(2q⋆)^2/(n−2q⋆) = O(q⋆^2/n).
  • Pr[FM(A_i,4q⋆,r) ∪ SKIP(A_i,4q⋆,r)] ≤ c′·(4q⋆)^2/(n−4q⋆) = O(q⋆^2/n).
  Union bounding over the O(log n) scales yields that with probability ≥ 1 − O((q⋆^2 log n)/n), all needed E2(i) except possibly a constant number hold; in particular, for the specific i picked out by Ecoll(i) (when A finds a collision), E2(i) also holds with probability ≥ 1 − O((q⋆^2 log n)/n). Combining with Pr[finish ≤ 2q⋆] ≥ 1/2, we get that a single epoch of length 8q⋆ rounds (each round has O(log n) queries) succeeds with probability at least 1/2 − O((q⋆^2 log n)/n).
- In the low-complexity regime q⋆ ≤ √n / log^α n, we have (q⋆^2 log n)/n ≤ 1 / log^{2α−1} n. Choosing any fixed α ≥ 1 makes this error o(1); for large n the success probability per epoch is bounded below by, say, 1/3. Therefore, E[Queries of A_all] = O(q⋆ log n).

Examples and sanity checks
- Single-cycle instance with no collisions: The coupling is applied only when A actually finds a collision; the wrapper and A_i bounds are vacuous otherwise, consistent with the theorem’s premise (it concerns instances with small RAC for collisions).
- Instance where a walk closes a directed cycle before any collision: Our budget accounting treats cycle closures as early terminations, which only reduce the A_i budget by capping an older walk’s cost at its termination distance; this aids the domination.

Obstacles and clarifications
- Conditioning on no-skips for A_i. The single-scale domination lemma conditions on no-skips and no-false-merges for both A and A_i at the relevant scale i. While this adds an O(log n) factor in the failure probability (we must union-bound E2(i) across scales), the low-complexity regime still yields a constant per-epoch success probability for α ≥ 1. If desired, one can refine the epoch design to randomize the scale focus and avoid a full union bound; however, the simpler union bound suffices.
- Cycle-closure yields no automatic collision. We treat cycle closures only as walk terminations (no success), which is the correct behavior for directed function graphs without preimage queries.

Next steps for curation
1) Formalize the proof of Lemma OF with explicit filtrations and a pathwise coupling argument (the above sketch is deterministic and should be straightforward to write down formally).
2) Write Lemma SC fully rigorously, including the precise “budget charging” inequalities and the final factor-4 bound. We suggest curating Lemma OF first, then Lemma SC.
3) Add the epoch assembly as a proposition with explicit constants, recording the mild condition α ≥ 1 in the theorem statement. If we later tighten the per-scale skip bound (e.g., via Freedman), α can likely be improved.

Notes on output.md
- No issues found. The permutation-coupling lemmas are correct and are the key probabilistic inputs for the coupling. The present round adds the algorithmic coupling lemmas needed for assembly; once verified, they can be appended to output.md under new lemma numbers.


=== Verifier (summary_md) ===

=== Verifier (verdict) ===
uncertain

