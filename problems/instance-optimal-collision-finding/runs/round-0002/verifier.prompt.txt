--- SYSTEM ---
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (summary so far)
- output.md (rigorously proven results so far)

Guidelines:
- notes.md: should be a readable running log of interesting work. Prefer appending. Replace only if old notes are clearly misleading. Remember -- notes should be self-contained and should make sense even without seeing outputs of past provers. 
- output.md: should be concise and rigorous. It should contain only fully proven theorems that are clearly an interesting step towards the solution (or the solution itself). The beginning of the file is a clear list of interesting theorems you can prove. From the statement of the theorem it has to be clear that this constitutes nontrivial progress towards solution. The rest of the file contains a fully rigorous list of the proofs of the theorems. Keep only proven theorems with clear proofs. If a statement is flawed and you cannot fix it, remove it from output.md and instead add it to notes.md with explanation.
- Be careful with the booleans `new_notes_append` and `new_outputs_append`: default is True (append). Use False only when deliberately rewriting everything.

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (≥200 words). Include concrete next-step suggestions. The next round of provers may not see last round outputs; ensure all valuable info is stored in notes.",
  "new_notes_md": "Markdown (KaTeX allowed). Usually appended to notes.",
  "new_notes_append": "True|False",
  "new_outputs_md": "Markdown (KaTeX allowed). Usually appended to output.md.",
  "new_outputs_append": "True|False",
  "verdict": "success|uncertain|nothing so far"
}


--- USER ---
You receive multiple prover reports. Evaluate correctness, value, and pick promising directions. Update notes.md (append/replace) with useful ideas and update output.md (append/replace) ONLY with rigorously verified results.

Prover reports (JSON):
[{"prover_id": "01", "progress_md": "Ideas\n\n- We isolate and prove two structural facts that will be used repeatedly: (i) under no-false-merge, pre-collision walks are disjoint and any merge detected by a Step is a true collision; (ii) under an \u201colder-first\u201d tie-break among equal-length walks, the vector of walk lengths is age-monotone (nonincreasing by start index) at all times. The second fact is the key combinatorial invariant that powers the single-scale amortization.\n- We then formalize a symmetrization lemma: in the forward-only, Start-uniform model with an unlabeled certificate, we can w.l.o.g. restrict attention to label-invariant algorithms. For such algorithms, we further impose the older-first tie-break without increasing the expected time to the first collision (proof via exchangeability of ties under a random relabeling of unseen vertices).\n- Finally, we state and prove a clean functions-version of the single-scale coupling (analogue of Claim 6.11) that does not rely on backward queries, using the age-monotone invariant. This fills the placeholder mentioned in notes.md and aligns with Section 6.3\u2019s amortization, adapted to functions.\n\nClarifying events and a basic structural lemma\n\n- Definitions. Fix a function f:[n]\u2192[n] with no loops. At each Step, the algorithm reveals y_t:=f(u_t) for some previously seen u_t. Let I_t be the set of images revealed by Steps strictly before Step t; let S_t be the set of vertices obtained by Start strictly before Step t (uniform-permutation coupling as in output.md).\n- A false merge at time t is the event y_t\u2208S_t\\I_t (i.e., y_t was previously seen only as a Start). A true collision occurs exactly when y_t\u2208I_t: then there exists u\u2032 (queried at an earlier Step) with f(u\u2032)=y_t, so f(u_t)=f(u\u2032) and u_t\u2260u\u2032.\n\nLemma A (Disjointness and collision detection under no-false-merge).\n- Statement. Fix any run and any horizon T. If X_T=0 (no false merges among the first T Steps) then up to the first time a collision is found: (i) walks started from distinct Starts are vertex-disjoint; (ii) the first time a Step lands on any previously visited vertex v is necessarily a true collision (i.e., v\u2208I_t). In particular, before the first collision, the walk-system is a disjoint family of forward paths.\n- Proof. If a Step lands on a previously seen, non-Start vertex v, then v\u2208I_t by definition, and we have a collision as above. If a Step were to land on a vertex seen previously only by Start (i.e., in S_t\\I_t), that would be a false merge, forbidden by X_T=0. Hence, until a collision occurs, no Step can land on any previously seen vertex at all, so walks remain disjoint. \u220e\n- Why useful here. This justifies treating all active walks as disjoint, forward-only paths until the first collision; there are no interactions to entangle them except the eventual, collision-causing merge into a previously Step-seen image.\n\nAge-monotonicity under older-first ties\n\nDefinition (Older-first tie-break). An algorithm is older-first if whenever it chooses to extend a walk, and there exist two or more eligible walks of the same current length, it extends the one with the smallest start index (the oldest among them).\n\nLemma B (Age-monotone length invariant). Consider any run up to time T in which no collision has occurred (hence walks are disjoint by Lemma A). If the algorithm is older-first, then at every time t\u2264T, the vector of walk lengths \u2113_j(t) (number of Steps applied to the j-th started walk) is nonincreasing in the start index: \u2113_1(t)\u2265\u2113_2(t)\u2265\u2026 (for all walks that have been started). Equivalently, when some walk W_j reaches length L at time t, every earlier walk W_{j\u2032} with j\u2032<j has length at least L at time t.\n- Proof. By induction on the number of Steps. Initially, all started walks have equal length (0), hence the invariant holds. Suppose it holds just before some Step that increases a length from \u2113 to \u2113+1 on walk W_k. If there were some older j<k with \u2113_j=\u2113, then the older-first rule would have forced extending W_j instead of W_k, contradiction. For older j with \u2113_j>\u2113, increasing \u2113_k to \u2113+1 preserves \u2113_j\u2265\u2113_k. For younger indices, the invariant cannot be violated by increasing \u2113_k. Hence the invariant is preserved. \u220e\n- Why useful here. This yields the exact structural condition needed for the scale amortization: when the \u201cwinning\u201d walk W_j reaches length L\u2208[2^i,2^{i+1}), all older walks have already been extended to length at least L\u22652^i unless they had been (prematurely) terminated by a collision\u2014ruled out before the first collision\u2014or by a self-detected stop rule (not needed for our argument).\n\nSymmetrization: reducing to label-invariant and older-first algorithms\n\nDefinition (Label-invariant algorithm). An algorithm is label-invariant if its distribution over next queries depends only on the isomorphism type of the current (unlabeled) state (the multiset of active walk lengths, their relative ages, and the set of Step-seen images), and not on vertex labels.\n\nLemma C (Symmetrization to label-invariance). For any randomized algorithm A and any fixed f, there exists a randomized algorithm A_sym which is label-invariant and satisfies, for any horizon T, E[time-to-first-collision \u2227 T of A_sym on f] = E[time-to-first-collision \u2227 T of A on f]. Moreover, A_sym can be implemented by sampling a uniform random relabeling \u03c3 of [n] at time 0, then simulating A on the \u03c3-relabeling of the instance while undoing \u03c3 in queries and answers.\n- Proof sketch. The Start oracle is uniform over unseen vertices; composing the entire interaction with a uniformly random permutation \u03c3 of labels preserves the joint distribution of the transcript (up to relabeling). Averaging A over \u03c3 yields A_sym whose decisions depend only on the isomorphism type of the revealed (unlabeled) state. This standard symmetrization leaves the distribution (hence expected time) of the hitting time unchanged. \u220e\n\nLemma D (Older-first tie-break w.l.o.g. under symmetrization). Let A be label-invariant. There exists a label-invariant algorithm A_old with the same Start/Step schedule laws except that ties among equal-length walks are broken older-first, and such that for any horizon T,\n  E[time-to-first-collision \u2227 T of A_old] \u2264 E[time-to-first-collision \u2227 T of A].\n- Proof sketch. In a label-invariant algorithm, when there is a tie among m equal-length eligible walks, the law of picking one is exchangeable across the m candidates. Fix any run up to the first time a tie occurs; condition on the unlabeled state. Among all exchangeable tie-breaking rules, the deterministic rule \u201cpick the oldest\u201d is a mean-preserving contraction for the rank of the chosen index; by a standard coupling (randomize a total order among tied walks and show that picking the minimal element stochastically dominates picking a uniformly random one), one can couple A and A_old so that (i) the chosen walk under A_old is never younger than under A at any tie; and (ii) between ties, both algorithms make identical choices. Under Lemma B, choosing older at ties preserves (and maximizes) age-monotonicity. Since a collision occurs exactly when some Step lands in I_t (independent of which equal-length representative was picked within the tied class), choosing an older representative never delays the first occurrence of such an event in expectation. Formalizing proceeds by a Doob decomposition of the indicator of \u201ccollision occurs at next Step\u201d and exchangeability within ties. \u220e\n- Why useful here. We can now assume, w.l.o.g. and without paying in expectation, that the competing algorithm is label-invariant and older-first; this is the regime where Lemma B applies deterministically.\n\nFunctions-version of the single-scale coupling (analogue of Claim 6.11)\n\nWe couple a competing algorithm A (label-invariant, older-first) with the single-scale process A_i inside A_all.\n\nSetup and notation. Fix a scale i and an epoch budget Q. Let r=(r_1,\u2026,r_Q) be the Start string (uniform permutation of unseen vertices) used by both A and A_i. Define events on the run of A up to Q queries:\n- E_noFM: X_Q=0 (no false merges).\n- E_noSK: no skip occurs (as in output.md) up to Q queries.\n- E_hit(i): A finds its first collision within Q queries, and it occurs along some walk W_j whose length at that time lies in [2^i,2^{i+1}).\nBy Lemma A, under E_noFM, before the first collision walks are disjoint. Under E_noSK, the j-th Start in A is exactly r_j, so age indices agree between A and A_i.\n\nLemma E (Single-scale coupling for functions). Condition on E_noFM \u2227 E_noSK \u2227 E_hit(i). Then, running A_i with the same Start string r, A_i finds a collision within at most 4\u00b7(number of Steps made by A up to its first collision) forward Steps.\n- Proof. Let t be the number of Step queries A makes up to its first collision, and let j be the (unique) index of the walk W_j realizing the collision at length L\u2208[2^i,2^{i+1}). By Lemma B (age-monotone lengths), at time t, for each earlier start j\u2032<j, either (a) W_{j\u2032} has length at least L\u22652^i, or (b) W_{j\u2032} would have terminated earlier due to a collision\u2014which cannot happen since this is the first collision\u2014so (a) must hold. Thus, for all j\u2032<j, A has already invested at least 2^i Steps in W_{j\u2032}. The total Step work A spent on the set {1,\u2026,j\u22121} is \u2265 (j\u22121)\u00b72^i.\nNow consider A_i. By definition, A_i processes starts in increasing order and extends each active walk by up to 2^i Steps (stopping early only upon finding a collision, which only helps). Therefore, the total number of Steps A_i spends on {1,\u2026,j\u22121} is \u2264 (j\u22121)\u00b72^i \u2264 (work of A on {1,\u2026,j\u22121}). For W_j itself, A_i spends at most 2^{i+1} Steps to reach length L, while A spent L Steps, so A_i\u2019s work on W_j is at most 2\u00b7(work of A on W_j). Summing yields that A_i\u2019s total Steps to reach the same collision is at most 2\u00b7(work on W_j) + 1\u00b7(work on {1,\u2026,j\u22121}) \u2264 2\u00b7t + t = 3t. Conservatively (to account for off-by-one and interleaving overheads), we bound by 4t. \u220e\n- Why useful here. This is the exact \u201cscale-by-scale\u201d domination needed to compare A_all to a competing algorithm in the forward-only function model; it replaces the graph backtracking used in the paper with the age-monotone invariant.\n\nAssembling the epoch argument (parameters and constants)\n\n- Let q\u22c6=RAC(collision,f), and let A\u22c6 be a (certificate-aware) algorithm with E[Queries(A\u22c6)]\u2264q\u22c6. By Markov, Pr[A\u22c6 finishes within 2q\u22c6 Steps]\u22651/2.\n- By output.md (Corollary 3) with S,F\u22642q\u22c6 and q\u22c6\u2264n/4, we have Pr[E_noFM fails]\u2264O(q\u22c6^2/n), Pr[E_noSK fails]\u2264O(q\u22c6^2/n). Hence for large enough n and in the target regime q\u22c6\u2264\u221a(n)/log^\u03b1 n with \u03b1>1, Pr[E_noFM \u2227 E_noSK]\u22651\u2212O(1/log^{2\u03b1} n).\n- Condition on E_noFM \u2227 E_noSK and on A\u22c6 finishing within 2q\u22c6 Steps. By Lemma E, in an epoch of length 8q\u22c6 rounds of A_all (total cost O(q\u22c6 log n) queries), some A_i finds a collision deterministically. Thus, a single epoch succeeds with probability at least 1/2\u2212O(q\u22c6^2/n), which is \u22651/3 for sufficiently large n if \u03b1>1. A geometric bound implies E[Queries(A_all)] = O(q\u22c6 log n).\n\nGaps, checks, and what remains\n\n- Output.md correctness. The permutation-coupling bounds for false merges and skips are correct and robust; they are stated and proved cleanly. No changes needed there.\n- Older-first w.l.o.g. (Lemma D). We provided a plausible coupling proof sketch under label-invariance; a fully formal proof should spell out the exchangeability at tie times and the stopping-time argument (define the filtration; show that the conditional success indicator at the next Step is a symmetric function of the tied candidates; older-first maximizes the chance to \u201cserve\u201d older walks without reducing the immediate collision probability). If desired, one can also implement A_old by resolving every tie in A via a fixed deterministic map to the oldest walk, and then average over a random relabeling \u03c3 to regain label-invariance and preserve expectation.\n- Cycle closure caveat. Our arguments no longer rely on \u201ccycle closure implies a collision.\u201d In functions, closing a cycle (e.g., returning to v_0) may not immediately witness two distinct preimages of the same image. Lemma A/age-monotone + the collision-as-I_t argument avoids this pitfall.\n- Constants and \u03b1. With the Markov+union bound and the 4\u00d7 overhead in Lemma E, any fixed \u03b1>1 suffices for one-epoch success probability \u22651/3 for large n. With a sharper tail bound (Freedman on the skip/false-merge counts) and a tighter constant than 4 in Lemma E (3 suffices by the accounting above), \u03b1 can likely be pushed down to \u03b1\u22651 (or even any \u03b1>1/2); this is optional refinement.\n\nNext steps\n\n1) Formalize Lemma D. Write a complete proof using the permutation coupling of starts and a tie-exchangeability argument at each tie time, with a stopping-time coupling that shows expected hitting time to the first collision does not increase when switching to older-first ties.\n2) Integrate Lemma E into a fully written proof of Theorem (forward-only, low complexity), tracking all constants in the epoch assembly and clarifying how A_all interleaves scales (one query per scale per round) and how cross-scale collision checks are accounted for (they are not counted as queries).\n3) Optional: provide Freedman/Bernstein tail bounds for the counts of false merges/skips to lower the required \u03b1. The martingale differences are bounded by 1 with predictable quadratic variation \u2248 F\u00b7S/(n\u2212F).\n4) Add small, adversarial toy instances to stress-test Lemma D\u2019s assumptions (label-invariance and tie symmetry), verifying that older-first does not change the expected time under random relabelings.\n\nSummary of new concrete claims ready to curate next\n- Lemma A (No-false-merge \u21d2 disjointness and true-collision characterization). Short, fully proved.\n- Lemma B (Age-monotone invariant under older-first ties). Short, fully proved.\n- Lemma C (Symmetrization to label-invariance). Standard, proof sketched; can be expanded.\n- Lemma D (Older-first tie-break w.l.o.g. under symmetrization). Proof sketch provided; to be fully formalized next.\n- Lemma E (Functions single-scale coupling). Fully proved given Lemma B and the no-false-merge/no-skip coupling.\nThese, together with output.md\u2019s probabilistic pillars and the epoch assembly above, essentially complete the forward-only, low-complexity theorem modulo a fully detailed writeup of Lemma D and constant tracking."}, {"prover_id": "02", "progress_md": "## Round 0002 \u2014 Forward-only coupling: older-first pacing and single-scale domination\n\nSummary of what is already curated (output.md)\n- The permutation-coupling bounds for both false merges and skips are correct and robust: for an epoch with S starts and F steps, E[#false merges] \u2264 F\u00b7S/(n\u2212F) and E[#skips] \u2264 F\u00b7S/(n\u2212F), hence each occurs with probability O(q^2/n) in 2q-query epochs. These are uniform over f and over fully adaptive algorithms. No changes needed.\n\nGaps remaining toward the target theorem\n- We still need a precise, checkable coupling from an arbitrary (certificate-aided) algorithm A to a single-scale process A_i in the forward-only model. The sticking point is \u201colder-first\u201d tie-breaking. Rather than claim w.l.o.g. directly, we propose and prove a pacing wrapper that enforces an older-first discipline with at most a constant-factor overhead. We then prove a clean single-scale domination lemma under the two rare-event conditions (no false merges, no skips).\n\nDefinitions to fix notation\n- We work with a fixed f:[n]\u2192[n] (no loops). A Start returns a uniformly random unseen vertex (unseen means neither returned by Start before nor revealed as an image of any Step). A Step on u reveals y=f(u).\n- Let r be the global random start-permutation (as in output.md). For a time window of at most T total queries, define SKIP(A,T,r) and FM(A,T,r) to be the events that A incurs at least one skip or false merge, respectively, within that window relative to r (as in the curated lemmas).\n- For a run of A up to its first collision, let W_j be the walk (indexed by the j-th Start of A under r) on which the first collision is found, and let L be the distance from its start to the colliding image at that moment.\n\nLemma OF (older-first pacing wrapper; forward-only, deterministic statement).\n- Statement. Fix f, a (possibly adaptive) algorithm A, a start permutation r, and an integer i\u22650. There exists a wrapper algorithm B=B[A,i] that, given the same f and r, makes only forward queries and satisfies: for any integer T\u22651, if A finds a collision within \u2264T queries, then B finds a collision within \u22642T queries. Moreover, in the run of B up to the moment when W_j first reaches length \u22652^i (or terminates), B enforces the following discipline: whenever A attempts to advance some walk W_\u2113 of current length <2^i while there exists an older (\u2113\u2032<\u2113) active walk of length <2^i, B advances one such older walk instead; otherwise B advances as A does.\n- Why useful here. This provides an \u201colder-first up to 2^i\u201d property sufficient for the single-scale amortization, without assuming any stochastic optimality of older-first. The overhead is at most a factor two in query count to the first collision.\n- Proof sketch (checkable). B simulates A step-by-step but with the scheduling rule in the statement: in each simulated A-step, if A\u2019s choice respects the discipline, B issues the same Step/Start; if not, B issues one Step on an older active walk with current length <2^i (arbitrarily breaking ties), then in the next B-move carries out A\u2019s planned Step. Thus, each simulated A-step causes either one or two B-steps; hence if A halts by time T, B halts by time \u22642T. That B does not delay the existence of a collision follows because B never undoes revealed information: by the time B completes the first T simulated A-steps (in possibly different order, interleaved with at most T catch-up steps), it has revealed a superset of the images revealed by A up to its collision time; revealing more edges cannot preclude a collision that A witnessed, so B must witness a (possibly earlier) collision by then. The rule ensures that prior to any W_\u2113 exceeding 2^i, all older active walks have been advanced to min{2^i, their termination distance}.\n\nLemma SC (single-scale domination; forward-only functions, analogue of Claim 6.11).\n- Setup. Fix f, a certificate-aided algorithm A that finds a collision within q queries with probability \u22651/2, a start permutation r, and scale i with 2^i \u2264n. Run the pacing wrapper B=B[A,i]. Define the events:\n  \u2022 E1:= \u00acFM(A,2q,r) \u2227 \u00acSKIP(A,2q,r) (no false merges, no skips for A within 2q queries).\n  \u2022 E2(i):= \u00acFM(A_i,4q,r) \u2227 \u00acSKIP(A_i,4q,r) (no false merges, no skips for the single-scale process A_i within 4q queries; A_i uses starts from r and extends each active walk forward up to 2^i steps, stopping earlier if it revisits a seen vertex or closes a directed cycle).\n  \u2022 Ecoll(i): the first collision of A occurs on W_j at distance L\u2208[2^i,2^{i+1}).\n- Statement. Conditioned on E1 \u2227 E2(i) \u2227 Ecoll(i), the process A_i (with start order r) deterministically finds a collision within at most 4q forward queries.\n- Why useful here. This is the scale-by-scale coupling needed to transfer progress from an optimal certificate algorithm to the all-scales strategy.\n- Proof (detailed charging). Throughout, couple A_i and B to share the start order r (E2(i) guarantees A_i\u2019s j-th Start equals r_j; E1 guarantees A\u2019s j-th Start equals r_j and that before the first collision, any step into a previously seen vertex is a true collision, never a false merge). Consider the run of B up to the first collision of A; by Lemma OF, this takes \u22642q queries and, by construction, enforces that for any active walk with index \u2264j\u22121 (older than W_j), its length at the time W_j first reaches 2^i is at least min{2^i, its termination distance}.\n  Define the \u201cbudget\u201d that A_i must spend before it reaches the same collision as A:\n  \u2022 For each older start \u2113<j whose walk does not terminate earlier, A_i must advance it to length exactly 2^i (it resets or freezes thereafter). For each older start that terminates earlier (by hitting a previously seen vertex or closing a cycle), A_i must advance it up to that termination length.\n  \u2022 For the colliding walk W_j, A_i must advance it to distance L (\u22642^{i+1}\u22121).\n  All other work A_i may do (e.g., advancing younger starts or beyond-2^i work on older ones) only delays success and can be charged to the above items by truncating the schedule, so it suffices to bound this budget.\n  By the enforced discipline of B, for each \u2113<j either B has already spent \u22652^i steps on W_\u2113 (if it remained active), or B has spent at least its termination length advancing W_\u2113 to termination. Thus, summing over \u2113<j, A_i\u2019s total budget on older starts is upper bounded by B\u2019s total steps spent on older starts up to the time W_j reaches length 2^i. Similarly, A_i\u2019s work on W_j up to length L is at most B\u2019s work on W_j up to that moment (since B follows A\u2019s choices on W_j except for interleaving catch-ups). Therefore, the total budget A_i needs is \u2264 (B\u2019s steps on older starts) + (B\u2019s steps on W_j) \u2264 (total steps of B up to A\u2019s collision time) \u2264 2q by Lemma OF.\n  Finally, A_i may incur at most a constant-factor overhead due to interleaving and possible partial restarts across attempts; a standard doubling/truncation argument (identical to the graphs case) shows that simulating the above budget with A_i costs at most a factor 2 in queries, because each active older walk is extended forward in disjoint prefixes up to its own cap (2^i or termination), and work on W_j is in addition. Hence A_i finds the collision within \u22644q steps. Determinism follows because, under E1 and E2(i), the relative order of starts is aligned by r and no skip/false-merge alters it.\n\nEpoch assembly (quantitative bound and \u03b1)\n- Let q\u22c6:=RAC(collision,f). Choose A to be a certificate-aided algorithm with E[queries]\u2264q\u22c6. By Markov, Pr[A finishes within 2q\u22c6] \u2265 1/2. For a fixed scale i, the curated bounds yield:\n  \u2022 Pr[FM(A,2q\u22c6,r) \u222a SKIP(A,2q\u22c6,r)] \u2264 c\u00b7(2q\u22c6)^2/(n\u22122q\u22c6) = O(q\u22c6^2/n).\n  \u2022 Pr[FM(A_i,4q\u22c6,r) \u222a SKIP(A_i,4q\u22c6,r)] \u2264 c\u2032\u00b7(4q\u22c6)^2/(n\u22124q\u22c6) = O(q\u22c6^2/n).\n  Union bounding over the O(log n) scales yields that with probability \u2265 1 \u2212 O((q\u22c6^2 log n)/n), all needed E2(i) except possibly a constant number hold; in particular, for the specific i picked out by Ecoll(i) (when A finds a collision), E2(i) also holds with probability \u2265 1 \u2212 O((q\u22c6^2 log n)/n). Combining with Pr[finish \u2264 2q\u22c6] \u2265 1/2, we get that a single epoch of length 8q\u22c6 rounds (each round has O(log n) queries) succeeds with probability at least 1/2 \u2212 O((q\u22c6^2 log n)/n).\n- In the low-complexity regime q\u22c6 \u2264 \u221an / log^\u03b1 n, we have (q\u22c6^2 log n)/n \u2264 1 / log^{2\u03b1\u22121} n. Choosing any fixed \u03b1 \u2265 1 makes this error o(1); for large n the success probability per epoch is bounded below by, say, 1/3. Therefore, E[Queries of A_all] = O(q\u22c6 log n).\n\nExamples and sanity checks\n- Single-cycle instance with no collisions: The coupling is applied only when A actually finds a collision; the wrapper and A_i bounds are vacuous otherwise, consistent with the theorem\u2019s premise (it concerns instances with small RAC for collisions).\n- Instance where a walk closes a directed cycle before any collision: Our budget accounting treats cycle closures as early terminations, which only reduce the A_i budget by capping an older walk\u2019s cost at its termination distance; this aids the domination.\n\nObstacles and clarifications\n- Conditioning on no-skips for A_i. The single-scale domination lemma conditions on no-skips and no-false-merges for both A and A_i at the relevant scale i. While this adds an O(log n) factor in the failure probability (we must union-bound E2(i) across scales), the low-complexity regime still yields a constant per-epoch success probability for \u03b1 \u2265 1. If desired, one can refine the epoch design to randomize the scale focus and avoid a full union bound; however, the simpler union bound suffices.\n- Cycle-closure yields no automatic collision. We treat cycle closures only as walk terminations (no success), which is the correct behavior for directed function graphs without preimage queries.\n\nNext steps for curation\n1) Formalize the proof of Lemma OF with explicit filtrations and a pathwise coupling argument (the above sketch is deterministic and should be straightforward to write down formally).\n2) Write Lemma SC fully rigorously, including the precise \u201cbudget charging\u201d inequalities and the final factor-4 bound. We suggest curating Lemma OF first, then Lemma SC.\n3) Add the epoch assembly as a proposition with explicit constants, recording the mild condition \u03b1 \u2265 1 in the theorem statement. If we later tighten the per-scale skip bound (e.g., via Freedman), \u03b1 can likely be improved.\n\nNotes on output.md\n- No issues found. The permutation-coupling lemmas are correct and are the key probabilistic inputs for the coupling. The present round adds the algorithmic coupling lemmas needed for assembly; once verified, they can be appended to output.md under new lemma numbers.\n"}]

Current notes.md:
Setting and goals.
- We study forward-only oracle access to a fixed function f:[n]→[n] with no loops (f(v)≠v). The algorithm issues two kinds of queries: Start (returns a uniformly random unseen vertex) and Step (for a previously seen u, reveal f(u)). A collision is found when we have distinct u≠u′ with f(u)=f(u′).
- In the forward-only model, a Step may land on a vertex selected earlier by Start but not yet reached by any walk; this is a “false merge” (not a collision). Also, a Step may land on a vertex that would have been selected by a future Start; this is a “skip,” which disrupts coupling to a pre-sampled Start order.
- Target theorem (informal): If RAC(collision,f)≤√n / log^α n (low-complexity regime), then the interleaved all-scales algorithm A_all finds a collision in O(log n)·RAC expected queries. We need (i) robust bounds that false merges and skips are rare up to O(√n/polylog n) queries, and (ii) a functions-version of the scale-coupling lemma (analogue of Claim 6.11) plus an epoch assembly argument.

Key probabilistic tool: permutation coupling of starts.
- Fix an epoch (a time window) in which the algorithm performs S Start operations and F Step operations (S,F arbitrary, adaptive, but finite). Expose a uniform random permutation π of [n]. Implement the Start oracle by always returning the unseen vertex of smallest π-rank. This realizes the uniform new-start oracle and implies that, conditioning on the set I_t of images revealed by steps before time t, the set of started vertices S_t is uniform among all s_t-subsets of W_t:=[n]\I_t, where s_t is the number of starts before t.
- For a step at time t with target y:=f(u_t), the conditional probability that y is in the previously-started set is s_t/|W_t| if y∉I_t (and 0 if y∈I_t). Similarly, the conditional probability that y equals one of the vertices that would be selected by future Starts within the epoch is (S−s_t)/|W_t| if y∉I_t (and 0 otherwise). Since |W_t|≥n−F for all t, these yield simple, uniform bounds.

Consequences (rigorous; curated into output.md):
- Expected number of false merges in the epoch ≤ F·S/(n−F); hence Pr[at least one false merge] ≤ F·S/(n−F).
- Expected number of skip events in the epoch ≤ F·S/(n−F); hence Pr[SKIP] ≤ F·S/(n−F).
- In particular, for an epoch of ≤2q total queries, with S,F≤2q and q≤n/4, both probabilities are O(q^2/n). This is uniform over f and any adaptive strategy.

Caveats and corrections to prior reports.
- The union-bound attempt that upper-bounds Pr[v_j=f(u_t)] by 1/(n−j+1) is incorrect, because the unseen pool at the j-th start can be substantially smaller than n−j+1 after many steps, making the true probability larger. The permutation-coupling analysis above addresses this correctly.
- Skips are not the same as false merges. A skip occurs when a step lands on a vertex slated to be chosen by a future Start; false merges require landing on a previously started vertex that has not yet been reached by any walk. Both are rare, but they are distinct events and must be bounded separately (both bounds follow from the same coupling).
- “Cycle closure always gives an immediate collision” needs a qualification: stepping into the very first start vertex v_0 does not automatically produce two distinct known preimages of v_0. The analysis should not rely on this shortcut.

What remains to prove for the main theorem.
- Older-first tie-breaking w.l.o.g.: State and prove a lemma that among algorithms that differ only by how they choose between isomorphic active walks, choosing the oldest cannot increase the number of queries to the first collision. Use the permutation-coupling to justify exchangeability of unseen start vertices.
- Functions-version of the single-scale coupling (analogue of Claim 6.11): Under the joint event {no false merges}∧{no skips}, and conditioning on the first collision occurring along W_j at distance L∈[2^i,2^{i+1}), show that the single-scale process at scale i finds the same collision within a constant-factor (e.g., ≤4×) number of forward steps relative to A’s cost up to the collision. Provide a precise amortization argument that charges A_i’s work to A’s work, carefully accounting for walks that terminate early (due to merging into already-reached vertices or cycle closure).
- Epoch assembly: With Markov (Pr[T_A*≤2q*]≥1/2) and the O(q^2/n) bounds above, a single 8q*-round epoch of A_all succeeds with probability ≥1/2−O(q*^2/n); in the regime q*≤√n/log^α n, this is a positive constant. Then a geometric bound yields E[Queries_A_all]=O(q* log n).

Pointers for future rounds.
- Write the older-first lemma and the single-scale coupling with full filtrations and stopping times. Consider a potential equal to the total “budgeted” remaining steps at scale i, and show it decreases at each step of A while A_i lags by at most a constant factor.
- If tighter constants are desired, upgrade the Markov control of the no-false-merge/no-skip counts to a Freedman/Bernstein tail bound (increments ≤1, predictable quadratic variation ≈ E[count]).

Current output.md (if any):
Proved statements so far
- Lemma 1 (False merges are rare via permutation coupling). In any forward-only epoch with S starts and F steps, the expected number of false merges is at most F·S/(n−F), and hence Pr[at least one false merge] ≤ F·S/(n−F).
- Lemma 2 (Skips are also rare via permutation coupling). In the same epoch, the expected number of skip events is at most F·S/(n−F), and hence Pr[SKIP] ≤ F·S/(n−F).
- Corollary 3 (Uniform O(q^2/n) bound in 2q-query epochs). In any epoch with at most 2q total queries (so S,F≤2q) and q≤n/4, both Pr[at least one false merge] and Pr[SKIP] are O(q^2/n), more precisely ≤ 4q^2/(n−2q).

Proofs

Preliminaries and setup. Fix n≥1 and a function f:[n]→[n]. Consider an arbitrary (possibly adaptive) algorithm that issues two types of oracle interactions:
- Start: return a uniformly random vertex from the set of unseen vertices; here "unseen" means not yet returned by any Start and not yet revealed as the image of any Step.
- Step(u): for a previously seen vertex u, reveal y=f(u); now y becomes seen (if it was not already).
Fix an arbitrary epoch (time window) during which exactly S Start operations and F Step operations occur (S,F finite; they may be adapted to the history). Write the Step times as t=1,2,…,F in their chronological order within the epoch. Let I_t denote the set of images revealed by Steps strictly before the t-th Step, and let s_t be the number of Starts that occurred strictly before the t-th Step. Let W_t:=[n]\I_t be the set of vertices that have not yet been revealed as images before Step t.

We use the standard permutation coupling for the Start oracle: sample a uniform random permutation π of [n] at the beginning. At each Start, return the unseen vertex with smallest π-rank. This realizes exactly the uniform new-start rule and yields the following fact.

Fact (Uniform-subset view). Conditional on the history up to just before Step t, in particular on I_t, the set S_t of vertices returned by the s_t Starts so far is distributed as the set of the s_t smallest-π elements of W_t. Equivalently, S_t is uniform among all s_t-subsets of W_t.

Lemma 1 (False merges are rare).
Definition. A false merge at Step t occurs iff the revealed image y_t:=f(u_t) satisfies y_t∉I_t and y_t∈S_t (i.e., it is a newly revealed image that coincides with a previously started vertex).
Claim. E[#false merges in the epoch] ≤ F·S/(n−F). In particular, Pr[at least one false merge] ≤ F·S/(n−F).
Proof. Fix t. Conditional on the history up to Step t, either y_t∈I_t (then the indicator for a false merge at t is 0) or y_t∉I_t (then y_t∈W_t). By the Uniform-subset view, Pr[y_t∈S_t | history] = s_t/|W_t|. Since |W_t| ≥ n−F for all t (at most F images can be revealed in the entire epoch), we have
  Pr[false merge at t | history] ≤ s_t/(n−F).
Taking expectations and summing over t=1,…,F gives
  E[#false merges] ≤ ∑_{t=1}^F E[s_t/(n−F)] ≤ (1/(n−F)) ∑_{t=1}^F E[s_t] ≤ F·S/(n−F),
because s_t ≤ S for all t. Finally, Pr[#false merges ≥ 1] ≤ E[#false merges]. This bound holds uniformly over f and over the algorithm’s adaptivity.

Lemma 2 (Skips are rare).
Definition. Let r_1,r_2,… be the (random) Start sequence defined by the π-coupling: within the epoch, the j-th Start returns r_j. A skip event occurs at Step t if y_t:=f(u_t) satisfies y_t∉I_t and y_t equals one of the vertices that would be returned by a future Start within the epoch, i.e., y_t ∈ R_t where R_t is the set of the next S−s_t smallest-π elements of W_t.
Claim. E[#skip events in the epoch] ≤ F·S/(n−F). In particular, Pr[SKIP] ≤ F·S/(n−F).
Proof. Fix t. Conditional on the history up to Step t, if y_t∈I_t the indicator is 0. Otherwise y_t∈W_t. By symmetry of π, the probability that a fixed y_t lies among the next S−s_t smallest-π elements of W_t equals (S−s_t)/|W_t|. Hence
  Pr[skip at t | history] = (S−s_t)/|W_t| ≤ (S−s_t)/(n−F) ≤ S/(n−F).
Taking expectations and summing over t yields
  E[#skips] ≤ ∑_{t=1}^F E[(S−s_t)/(n−F)] = (1/(n−F)) ∑_{t=1}^F (S−E[s_t]) ≤ F·S/(n−F).
Finally, Pr[SKIP] ≤ E[#skips]. This bound is uniform over f and adaptive choices.

Corollary 3 (Bounds for 2q-query epochs).
Suppose an epoch performs at most 2q total queries, so S,F≤2q, and assume q≤n/4 (so n−2q≥n/2>0). Then Lemmas 1 and 2 give
  Pr[at least one false merge] ≤ 4q^2/(n−2q) ≤ 8q^2/n,
  Pr[SKIP] ≤ 4q^2/(n−2q) ≤ 8q^2/n.
Thus, in the low-complexity regime q≪√n, both events occur with vanishing probability O(q^2/n).

Remarks.
- These bounds require no assumptions on f beyond being a function; they are robust to algorithmic adaptivity and hold for any fixed f.
- The same permutation-coupling framework can be used to obtain martingale concentration (e.g., via Freedman) for the counts of false merges and skips if tighter tails are needed; the above expectation/Markov bounds suffice for the intended √n/polylog n regime.

