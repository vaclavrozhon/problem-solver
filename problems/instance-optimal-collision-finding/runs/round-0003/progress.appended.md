## Round 0003 — Symmetrization and older-first tie-breaking formalization; assembling the epoch bound

In this round I address two gaps flagged by the verifier and needed to complete the forward-only, low-complexity theorem: (1) a correct symmetrization statement that justifies focusing on label-invariant algorithms in the unlabeled-certificate setting; (2) a rigorous “older-first w.l.o.g.” lemma based on exchangeability at tie times under random relabelings. I then outline the epoch assembly with explicit constants. I also point out what to append to output.md and what remains open.

### Corrections and clarifications about output.md
- Symmetrization (missing): output.md does not yet include the correct symmetrization lemma. The earlier Round 0002 notes claimed an equality E[T(A_sym on f)] = E[T(A on f)], which is generally false for a fixed labeled instance f. The correct statement averages over a random relabeling (conjugacy) of f. I give a precise formulation below (Lemma S).
- Older-first w.l.o.g.: output.md uses older-first in Lemma 6 but lacks a formal reduction showing that we can restrict attention to older-first tie-breaking among label-invariant algorithms without increasing expected time (in the conjugacy-averaged sense). I provide Lemma D below, resolving this gap.
- Pacing wrapper: As the verifier noted, a wrapper that “inserts catch-up steps” is not implementable in our online oracle model. I do not use it. The route via Lemma D suffices.

### New Lemma S (Averaged symmetrization to label-invariant algorithms)
Statement.
- Let P be the collision property. For any randomized algorithm A (possibly label-dependent) and any fixed f:[n]→[n], define A_sym that samples a uniform σ∈S_n and simulates A on σ∘f∘σ^{-1}, undoing σ when issuing queries/processing answers. For any horizon T,
  E[T_hit∧T(A_sym on f)] = E_σ[E[T_hit∧T(A on σ∘f∘σ^{-1})]].
- Consequently, RAC(P,f) = inf_A max_π E[T_hit(A on π∘f)] = inf_A′ E_σ[E[T_hit(A′ on σ∘f∘σ^{-1})]], where the infimum can be taken over label-invariant algorithms A′ (those whose decisions depend only on the unlabeled state). In particular, there exists a sequence of label-invariant algorithms attaining RAC(P,f) up to arbitrarily small additive ε.
Why useful here.
- Reduces the competitor to be label-invariant without loss for the unlabeled-certificate benchmark, allowing us to reason about tie-breaking via exchangeability under random conjugacy.
Sketch of proof.
- The first identity is by construction. For the second, observe that RAC(P,σ∘f∘σ^{-1})=RAC(P,f) for all σ, so the maximum over conjugates equals the average over conjugates; then apply the first identity and note that averaging A over σ yields a label-invariant algorithm achieving the same averaged cost.

### New Lemma D (Tie-breaking invariance under conjugacy; older-first w.l.o.g.)
Setup/definitions.
- Work in the forward-only model on a fixed f. Let A_base be a label-invariant randomized policy that, at any state, specifies whether to Start or Step, and if Step, specifies a target length (e.g., “extend one of the longest eligible walks”). When at some step the policy mandates “extend a walk among a set U of eligible walks that share the same current length,” we call this a tie.
- A tie-breaker is a measurable rule that, given the unlabeled state and the set U (with their age indices), selects one element of U to extend. Let φ and ψ be two tie-breakers (e.g., φ = older-first; ψ = any other label-independent tie-breaker), and let A_φ, A_ψ denote the corresponding algorithms. Let T_hit denote the time to first collision.
Statement.
- Consider the experiment that first samples a uniform random σ∈S_n, then runs A_φ (resp. A_ψ) on the conjugate instance σ∘f∘σ^{-1}, stopping at the first collision. Then for any horizon T,
  E_σ[E[T_hit∧T(A_φ on σ∘f∘σ^{-1})]] = E_σ[E[T_hit∧T(A_ψ on σ∘f∘σ^{-1})]].
- In particular, in the unlabeled-certificate benchmark (which is invariant under conjugacy), tie-breaking does not affect the expected query complexity; hence, we may assume w.l.o.g. that the competitor resolves ties older-first.
Why useful here.
- This justifies the use of Lemma 5 (age-monotone invariant) and Lemma 6 (single-scale domination) for the competitor, closing a key gap.
Proof idea (filtration and exchangeability at ties).
- Let (F_t) be the filtration of the labeled process up to t Steps. Define the unlabeled abstraction U_t: it contains the multiset of active walk lengths (ordered by age), whether a walk is terminated, and the count |I_t| of Step-seen images. A label-invariant policy A_base ensures that, pre-collision and under “no false merges,” the decision to Step vs Start and the targeted length depend only on U_t.
- Consider the first tie time τ (a stopping time with respect to the unlabeled filtration) where there are m≥2 eligible walks U_τ={W_{j_1},…,W_{j_m}} of equal length L. Condition on U_τ and on the sigma-field generated by U_s for s≤τ, and on the internal randomness of A_base up to τ. Under a uniform random conjugacy σ, the joint distribution of the labeled endpoints (u_{j_1},…,u_{j_m}) at time τ is exchangeable: it is invariant under any permutation of {j_1,…,j_m}, because σ induces a uniform random relabeling across the still-unseen vertices, and (by no false merges up to τ) the ℓ=L forward endpoints arise from disjoint, unlabeled tails that are symmetric under conjugation. Similarly, the Step-seen image set I_τ is (conditionally) uniformly distributed among |I_τ|-subsets of the revealed images and independent of the labels of the u_{j_r}’s beyond U_τ.
- Hence, the conditional hazard at τ, Pr[f(u_{j_r})∈I_τ | U_τ, F_{τ−}], is the same for all r (exchangeability across the tied endpoints). Therefore the one-step success probability (at the next Step) is identical under any tie-breaker.
- To extend beyond the first tie, define recursively the sequence of tie times τ_1<τ_2<⋯ (up to T). At each τ_k, given the unlabeled history up to τ_k, the conditional joint law of the labels on the tied endpoints remains exchangeable; this uses that relabeling by right composition with a permutation that acts within the (unseen) labels of the tied walks preserves the uniform distribution over σ. One can formalize a measure-preserving bijection Φ_k on the relabelings σ (compose with a transposition within the tied endpoints’ labels) that maps the run of A_φ to a run of A_ψ while preserving the unlabeled history up to τ_k and the distribution of future randomness. Inductively, the distributions of the entire labeled transcripts (up to T or to collision) under A_φ and under A_ψ coincide after averaging over σ. Taking expectations yields the claim.
- Remark on “no false merges”: The exchangeability argument at ties uses that, pre-collision, the tied endpoints correspond to disjoint, unseen regions of the function graph (Lemma 4), so a conjugacy that swaps their label-sets leaves the unlabeled state unaffected while preserving the uniform measure on σ. This is exactly the regime we condition on in Lemma 6 and in the epoch assembly.

### Consequence: older-first w.l.o.g. and completion of the single-scale comparison
- By Lemma S we can assume the competitor is label-invariant without changing the RAC benchmark. By Lemma D, we can also assume the tie-breaker is older-first with no change to the conjugacy-averaged expected time. Therefore Lemma 5 (age-monotone invariant) and Lemma 6 (single-scale domination, 2× overhead in Steps) apply to the competitor A.
- This completes the missing justification for using older-first in output.md’s Lemma 6. I recommend curating Lemma S and Lemma D next to make the chain airtight.

### Epoch assembly (explicit constants and α)
Let q⋆=RAC(collision,f). Let A⋆ be a certificate-aided algorithm with E[Queries]≤q⋆.
- Success within 2q⋆. By Markov, Pr[A⋆ finishes within 2q⋆] ≥ 1/2.
- No false merges/skips with high probability.
  • For A⋆ over 2q⋆ queries, Lemmas 1–2 and Corollary 3 (with S,F≤2q⋆) give Pr[FM(A⋆)∪SKIP(A⋆)] ≤ 8·(2q⋆)^2/n ≤ 32·q⋆^2/n.
  • For the single-scale A_i over 4q⋆ queries, the same bound yields Pr[FM(A_i)∪SKIP(A_i)] ≤ 8·(4q⋆)^2/n ≤ 128·q⋆^2/n for a fixed i.
  • We only need the latter for the specific i at which A⋆ finds the first collision. To upper bound the probability that this fails at that i, we can union bound over all i∈{0,…,⌊log_2 n⌋}; this gives an additional factor O(log n). Thus the combined failure probability across both processes is O((q⋆^2 log n)/n).
- Coupling to a winning scale. Condition on the intersection of: (i) A⋆ finishes within 2q⋆; (ii) no false merges/skips for A⋆; and (iii) no false merges/skips for A_i at the relevant i. By Lemma 6 (using older-first per Lemma D), A_i deterministically finds a collision within ≤ 2·(2q⋆)=4q⋆ Steps. Interleaving scales as in A_all costs O(log n) queries per round, so 8q⋆ rounds suffice per epoch.
- Per-epoch success probability and expectation. For large n and in the regime q⋆ ≤ √n / log^α n with α≥1, we have (q⋆^2 log n)/n ≤ 1/log^{2α−1} n = o(1). Picking n large enough, the per-epoch success probability is at least 1/2 − c·(q⋆^2 log n)/n ≥ 1/3 for a fixed absolute c. Therefore, by a geometric bound, E[Queries(A_all on f)] ≤ C·q⋆·log n for an absolute C.
- Note on α: The simple union bound across O(log n) scales requires α≥1 for a clean constant success probability. If desired, Freedman’s inequality for the martingale of increments of skip/false-merge indicators (bounded by 1 with predictable variance ≲ F·S/(n−F)) can improve constants/tails but does not evidently reduce the α-threshold below 1 without further refinements to the epoch design.

### Why the Lemma D proof conditions match our usage
- Lemma 6 and the epoch assembly condition on “no false merges” for both A and A_i. This guarantees disjointness of active walks up to the first collision (Lemma 4), which is the regime where the tie-exchangeability argument applies. Thus, applying Lemma D exactly in this conditional world is legitimate and sufficient for Lemma 6.

### What to curate next into output.md
- Lemma S (Averaged symmetrization to label-invariant algorithms) with the proof sketch above.
- Lemma D (Tie-breaking invariance under conjugacy) with the exchangeability-at-tie proof. It would be good to state explicitly the tie times τ_k as stopping times, and the construction of measure-preserving maps σ↦τ_k∘σ that swap the labels of tied endpoints without affecting the unlabeled process.
- Proposition (Epoch assembly). Given Lemma 6 and the permutation-coupling bounds (Lemmas 1–2), this yields the target theorem in the regime q⋆ ≤ √n / log^α n with α≥1, with explicit constants as above.

### Obstacles and remaining items
- Full formalization of Lemma D: I presented a detailed, checkable route via stopping times and exchangeability, but the measure-preserving map “compose σ by a transposition within the label-set of tied endpoints” constructed adaptively over ties should be written explicitly (induction over tie events). The key invariant is that the unlabeled state is fixed while the distribution of labels remains uniform under conjugacy; no-false-merge ensures the tied endpoints’ future tails are disjoint/unseen, so these local conjugacies are well-defined.
- Freedman tails: optional improvement for the per-epoch failure probability. Define the Doob martingale for X_t (cumulative skips/false merges) with bounded increments and predictable quadratic variation V_t ≤ E[X_T]; Freedman then yields exp(−Ω(min{λ^2/(E[X_T]+λ),λ})) tails. Not crucial for α≥1.
- Final theorem statement and constants: After curating Lemma S and Lemma D, we can add the theorem “Forward-only, low complexity” with α≥1 and some explicit C.

### Next steps
1) Write Lemma S and Lemma D as formal statements in output.md with proofs organized by filtrations and tie times, as outlined. This closes the main correctness gaps.
2) Add a short proposition assembling the epoch argument: quantify per-epoch success and conclude E[Queries(A_all)] ≤ C·q⋆·log n in the regime q⋆ ≤ √n / log^α n with α≥1.
3) Optional: include a Freedman tail lemma for skips/false merges (under the permutation coupling) to strengthen high-probability bounds.

