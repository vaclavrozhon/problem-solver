{
  "progress_md": "## Round 0003 \u2014 Symmetrization and older-first tie-breaking formalization; assembling the epoch bound\n\nIn this round I address two gaps flagged by the verifier and needed to complete the forward-only, low-complexity theorem: (1) a correct symmetrization statement that justifies focusing on label-invariant algorithms in the unlabeled-certificate setting; (2) a rigorous \u201colder-first w.l.o.g.\u201d lemma based on exchangeability at tie times under random relabelings. I then outline the epoch assembly with explicit constants. I also point out what to append to output.md and what remains open.\n\n### Corrections and clarifications about output.md\n- Symmetrization (missing): output.md does not yet include the correct symmetrization lemma. The earlier Round 0002 notes claimed an equality E[T(A_sym on f)] = E[T(A on f)], which is generally false for a fixed labeled instance f. The correct statement averages over a random relabeling (conjugacy) of f. I give a precise formulation below (Lemma S).\n- Older-first w.l.o.g.: output.md uses older-first in Lemma 6 but lacks a formal reduction showing that we can restrict attention to older-first tie-breaking among label-invariant algorithms without increasing expected time (in the conjugacy-averaged sense). I provide Lemma D below, resolving this gap.\n- Pacing wrapper: As the verifier noted, a wrapper that \u201cinserts catch-up steps\u201d is not implementable in our online oracle model. I do not use it. The route via Lemma D suffices.\n\n### New Lemma S (Averaged symmetrization to label-invariant algorithms)\nStatement.\n- Let P be the collision property. For any randomized algorithm A (possibly label-dependent) and any fixed f:[n]\u2192[n], define A_sym that samples a uniform \u03c3\u2208S_n and simulates A on \u03c3\u2218f\u2218\u03c3^{-1}, undoing \u03c3 when issuing queries/processing answers. For any horizon T,\n  E[T_hit\u2227T(A_sym on f)] = E_\u03c3[E[T_hit\u2227T(A on \u03c3\u2218f\u2218\u03c3^{-1})]].\n- Consequently, RAC(P,f) = inf_A max_\u03c0 E[T_hit(A on \u03c0\u2218f)] = inf_A\u2032 E_\u03c3[E[T_hit(A\u2032 on \u03c3\u2218f\u2218\u03c3^{-1})]], where the infimum can be taken over label-invariant algorithms A\u2032 (those whose decisions depend only on the unlabeled state). In particular, there exists a sequence of label-invariant algorithms attaining RAC(P,f) up to arbitrarily small additive \u03b5.\nWhy useful here.\n- Reduces the competitor to be label-invariant without loss for the unlabeled-certificate benchmark, allowing us to reason about tie-breaking via exchangeability under random conjugacy.\nSketch of proof.\n- The first identity is by construction. For the second, observe that RAC(P,\u03c3\u2218f\u2218\u03c3^{-1})=RAC(P,f) for all \u03c3, so the maximum over conjugates equals the average over conjugates; then apply the first identity and note that averaging A over \u03c3 yields a label-invariant algorithm achieving the same averaged cost.\n\n### New Lemma D (Tie-breaking invariance under conjugacy; older-first w.l.o.g.)\nSetup/definitions.\n- Work in the forward-only model on a fixed f. Let A_base be a label-invariant randomized policy that, at any state, specifies whether to Start or Step, and if Step, specifies a target length (e.g., \u201cextend one of the longest eligible walks\u201d). When at some step the policy mandates \u201cextend a walk among a set U of eligible walks that share the same current length,\u201d we call this a tie.\n- A tie-breaker is a measurable rule that, given the unlabeled state and the set U (with their age indices), selects one element of U to extend. Let \u03c6 and \u03c8 be two tie-breakers (e.g., \u03c6 = older-first; \u03c8 = any other label-independent tie-breaker), and let A_\u03c6, A_\u03c8 denote the corresponding algorithms. Let T_hit denote the time to first collision.\nStatement.\n- Consider the experiment that first samples a uniform random \u03c3\u2208S_n, then runs A_\u03c6 (resp. A_\u03c8) on the conjugate instance \u03c3\u2218f\u2218\u03c3^{-1}, stopping at the first collision. Then for any horizon T,\n  E_\u03c3[E[T_hit\u2227T(A_\u03c6 on \u03c3\u2218f\u2218\u03c3^{-1})]] = E_\u03c3[E[T_hit\u2227T(A_\u03c8 on \u03c3\u2218f\u2218\u03c3^{-1})]].\n- In particular, in the unlabeled-certificate benchmark (which is invariant under conjugacy), tie-breaking does not affect the expected query complexity; hence, we may assume w.l.o.g. that the competitor resolves ties older-first.\nWhy useful here.\n- This justifies the use of Lemma 5 (age-monotone invariant) and Lemma 6 (single-scale domination) for the competitor, closing a key gap.\nProof idea (filtration and exchangeability at ties).\n- Let (F_t) be the filtration of the labeled process up to t Steps. Define the unlabeled abstraction U_t: it contains the multiset of active walk lengths (ordered by age), whether a walk is terminated, and the count |I_t| of Step-seen images. A label-invariant policy A_base ensures that, pre-collision and under \u201cno false merges,\u201d the decision to Step vs Start and the targeted length depend only on U_t.\n- Consider the first tie time \u03c4 (a stopping time with respect to the unlabeled filtration) where there are m\u22652 eligible walks U_\u03c4={W_{j_1},\u2026,W_{j_m}} of equal length L. Condition on U_\u03c4 and on the sigma-field generated by U_s for s\u2264\u03c4, and on the internal randomness of A_base up to \u03c4. Under a uniform random conjugacy \u03c3, the joint distribution of the labeled endpoints (u_{j_1},\u2026,u_{j_m}) at time \u03c4 is exchangeable: it is invariant under any permutation of {j_1,\u2026,j_m}, because \u03c3 induces a uniform random relabeling across the still-unseen vertices, and (by no false merges up to \u03c4) the \u2113=L forward endpoints arise from disjoint, unlabeled tails that are symmetric under conjugation. Similarly, the Step-seen image set I_\u03c4 is (conditionally) uniformly distributed among |I_\u03c4|-subsets of the revealed images and independent of the labels of the u_{j_r}\u2019s beyond U_\u03c4.\n- Hence, the conditional hazard at \u03c4, Pr[f(u_{j_r})\u2208I_\u03c4 | U_\u03c4, F_{\u03c4\u2212}], is the same for all r (exchangeability across the tied endpoints). Therefore the one-step success probability (at the next Step) is identical under any tie-breaker.\n- To extend beyond the first tie, define recursively the sequence of tie times \u03c4_1<\u03c4_2<\u22ef (up to T). At each \u03c4_k, given the unlabeled history up to \u03c4_k, the conditional joint law of the labels on the tied endpoints remains exchangeable; this uses that relabeling by right composition with a permutation that acts within the (unseen) labels of the tied walks preserves the uniform distribution over \u03c3. One can formalize a measure-preserving bijection \u03a6_k on the relabelings \u03c3 (compose with a transposition within the tied endpoints\u2019 labels) that maps the run of A_\u03c6 to a run of A_\u03c8 while preserving the unlabeled history up to \u03c4_k and the distribution of future randomness. Inductively, the distributions of the entire labeled transcripts (up to T or to collision) under A_\u03c6 and under A_\u03c8 coincide after averaging over \u03c3. Taking expectations yields the claim.\n- Remark on \u201cno false merges\u201d: The exchangeability argument at ties uses that, pre-collision, the tied endpoints correspond to disjoint, unseen regions of the function graph (Lemma 4), so a conjugacy that swaps their label-sets leaves the unlabeled state unaffected while preserving the uniform measure on \u03c3. This is exactly the regime we condition on in Lemma 6 and in the epoch assembly.\n\n### Consequence: older-first w.l.o.g. and completion of the single-scale comparison\n- By Lemma S we can assume the competitor is label-invariant without changing the RAC benchmark. By Lemma D, we can also assume the tie-breaker is older-first with no change to the conjugacy-averaged expected time. Therefore Lemma 5 (age-monotone invariant) and Lemma 6 (single-scale domination, 2\u00d7 overhead in Steps) apply to the competitor A.\n- This completes the missing justification for using older-first in output.md\u2019s Lemma 6. I recommend curating Lemma S and Lemma D next to make the chain airtight.\n\n### Epoch assembly (explicit constants and \u03b1)\nLet q\u22c6=RAC(collision,f). Let A\u22c6 be a certificate-aided algorithm with E[Queries]\u2264q\u22c6.\n- Success within 2q\u22c6. By Markov, Pr[A\u22c6 finishes within 2q\u22c6] \u2265 1/2.\n- No false merges/skips with high probability.\n  \u2022 For A\u22c6 over 2q\u22c6 queries, Lemmas 1\u20132 and Corollary 3 (with S,F\u22642q\u22c6) give Pr[FM(A\u22c6)\u222aSKIP(A\u22c6)] \u2264 8\u00b7(2q\u22c6)^2/n \u2264 32\u00b7q\u22c6^2/n.\n  \u2022 For the single-scale A_i over 4q\u22c6 queries, the same bound yields Pr[FM(A_i)\u222aSKIP(A_i)] \u2264 8\u00b7(4q\u22c6)^2/n \u2264 128\u00b7q\u22c6^2/n for a fixed i.\n  \u2022 We only need the latter for the specific i at which A\u22c6 finds the first collision. To upper bound the probability that this fails at that i, we can union bound over all i\u2208{0,\u2026,\u230alog_2 n\u230b}; this gives an additional factor O(log n). Thus the combined failure probability across both processes is O((q\u22c6^2 log n)/n).\n- Coupling to a winning scale. Condition on the intersection of: (i) A\u22c6 finishes within 2q\u22c6; (ii) no false merges/skips for A\u22c6; and (iii) no false merges/skips for A_i at the relevant i. By Lemma 6 (using older-first per Lemma D), A_i deterministically finds a collision within \u2264 2\u00b7(2q\u22c6)=4q\u22c6 Steps. Interleaving scales as in A_all costs O(log n) queries per round, so 8q\u22c6 rounds suffice per epoch.\n- Per-epoch success probability and expectation. For large n and in the regime q\u22c6 \u2264 \u221an / log^\u03b1 n with \u03b1\u22651, we have (q\u22c6^2 log n)/n \u2264 1/log^{2\u03b1\u22121} n = o(1). Picking n large enough, the per-epoch success probability is at least 1/2 \u2212 c\u00b7(q\u22c6^2 log n)/n \u2265 1/3 for a fixed absolute c. Therefore, by a geometric bound, E[Queries(A_all on f)] \u2264 C\u00b7q\u22c6\u00b7log n for an absolute C.\n- Note on \u03b1: The simple union bound across O(log n) scales requires \u03b1\u22651 for a clean constant success probability. If desired, Freedman\u2019s inequality for the martingale of increments of skip/false-merge indicators (bounded by 1 with predictable variance \u2272 F\u00b7S/(n\u2212F)) can improve constants/tails but does not evidently reduce the \u03b1-threshold below 1 without further refinements to the epoch design.\n\n### Why the Lemma D proof conditions match our usage\n- Lemma 6 and the epoch assembly condition on \u201cno false merges\u201d for both A and A_i. This guarantees disjointness of active walks up to the first collision (Lemma 4), which is the regime where the tie-exchangeability argument applies. Thus, applying Lemma D exactly in this conditional world is legitimate and sufficient for Lemma 6.\n\n### What to curate next into output.md\n- Lemma S (Averaged symmetrization to label-invariant algorithms) with the proof sketch above.\n- Lemma D (Tie-breaking invariance under conjugacy) with the exchangeability-at-tie proof. It would be good to state explicitly the tie times \u03c4_k as stopping times, and the construction of measure-preserving maps \u03c3\u21a6\u03c4_k\u2218\u03c3 that swap the labels of tied endpoints without affecting the unlabeled process.\n- Proposition (Epoch assembly). Given Lemma 6 and the permutation-coupling bounds (Lemmas 1\u20132), this yields the target theorem in the regime q\u22c6 \u2264 \u221an / log^\u03b1 n with \u03b1\u22651, with explicit constants as above.\n\n### Obstacles and remaining items\n- Full formalization of Lemma D: I presented a detailed, checkable route via stopping times and exchangeability, but the measure-preserving map \u201ccompose \u03c3 by a transposition within the label-set of tied endpoints\u201d constructed adaptively over ties should be written explicitly (induction over tie events). The key invariant is that the unlabeled state is fixed while the distribution of labels remains uniform under conjugacy; no-false-merge ensures the tied endpoints\u2019 future tails are disjoint/unseen, so these local conjugacies are well-defined.\n- Freedman tails: optional improvement for the per-epoch failure probability. Define the Doob martingale for X_t (cumulative skips/false merges) with bounded increments and predictable quadratic variation V_t \u2264 E[X_T]; Freedman then yields exp(\u2212\u03a9(min{\u03bb^2/(E[X_T]+\u03bb),\u03bb})) tails. Not crucial for \u03b1\u22651.\n- Final theorem statement and constants: After curating Lemma S and Lemma D, we can add the theorem \u201cForward-only, low complexity\u201d with \u03b1\u22651 and some explicit C.\n\n### Next steps\n1) Write Lemma S and Lemma D as formal statements in output.md with proofs organized by filtrations and tie times, as outlined. This closes the main correctness gaps.\n2) Add a short proposition assembling the epoch argument: quantify per-epoch success and conclude E[Queries(A_all)] \u2264 C\u00b7q\u22c6\u00b7log n in the regime q\u22c6 \u2264 \u221an / log^\u03b1 n with \u03b1\u22651.\n3) Optional: include a Freedman tail lemma for skips/false merges (under the permutation coupling) to strengthen high-probability bounds.\n"
}