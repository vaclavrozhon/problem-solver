--- SYSTEM ---
You are a research **summarizer**. Summarize this *last round only* for a human log.

Include:
- 3–7 bullet **Highlights** (facts learned, reductions, counterexamples, partial bounds).
- 1–3 **Open questions / TODOs** for the next round.
- 1–3 **Citations to files** you relied on (e.g. round files or papers by name).

**Return strictly JSON**:
{
  "summary_md": "Readable summary of the round (≤200 words)",
  "highlights": [],
  "next_questions": []
}

--- USER ---
=== prover-01.out.json (progress_md) ===
## Round 0003 — Consolidating prerequisites; symmetrization fix; roadmap to older-first w.l.o.g.

### What is already solid (recap of curated pieces)
- False merges and skips are rare up to 2q queries: E[#false merges] ≤ F·S/(n−F) and E[#skips] ≤ F·S/(n−F); hence Pr[bad] = O(q^2/n) in 2q-query epochs (curated Lemmas 1–2 and Corollary 3). This is uniform over f and adaptivity.
- Structural consequences under no-false-merge: before the first collision the active walks are disjoint forward paths, and any step landing in the previously Step-seen image set I_t is a true collision (curated Lemma 4).
- Age-monotone invariant: under older-first tie-breaking, the length vector (by start age) is nonincreasing at all times prior to the first collision (curated Lemma 5).
- Single-scale domination under older-first: conditioned on no-skips/no-false-merge for both processes, if A’s first collision occurs along W_j at length L ∈ [2^i,2^{i+1}), then the single-scale process A_i finds a collision within ≤ 2·t steps where t is the number of Step queries A used up to that moment (curated Lemma 6).

These ingredients are the forward-only analogue of the graph-side amortization in §6.3 of BGN, contingent on the older-first assumption.

### Corrections and clarifications relative to output.md
- No changes required to curated Lemmas 1–2–3–4–5–6. They are consistent and correctly conditioned on no-false-merge and no-skip for both A and A_i.
- Remaining gap: we still need a rigorous reduction “older-first w.l.o.g.” for the certificate-aided competitor. Until that is in place, the epoch assembly towards Theorem (forward-only, low complexity) uses Lemma 6 only for algorithms that already tie-break older-first.

### New clean lemma (ready to curate next): Symmetrization to label-invariant algorithms
Statement (precise averaged form). For any randomized algorithm A and any fixed f:[n]→[n], define the symmetrized algorithm A_sym that samples a uniform permutation σ of [n] at time 0 and simulates A on σ∘f∘σ^{-1}, undoing σ in queries/answers. Then for any finite horizon T,
\[ \E[T_{hit}\wedge T\;\text{of}\;A_{sym}\;\text{on}\;f] \;=\; \E_{\sigma}\,\E[ T_{hit}\wedge T\;\text{of}\;A\;\text{on}\;\sigma\circ f\circ\sigma^{-1}]. \]
Consequently, since RAC(collision,σ∘f∘σ^{−1}) = RAC(collision,f) for all σ, the infimum defining RAC can be achieved (or arbitrarily approached) within the class of label-invariant algorithms (i.e., those whose decision distribution depends only on the unlabeled state). This is the safe replacement for the incorrect equality “E[T(A_sym on f)] = E[T(A on f)]” (which need not hold for a fixed f).
Why useful here. It allows us to restrict attention to label-invariant competitors before addressing tie-breaking, without loss for RAC.
Sketch of proof. Standard: composing with a uniform σ makes the transcript distribution depend only on unlabeled states; averaging preserves the optimal value since the max over permutations in RAC is invariant under conjugation.

### Toward the older-first w.l.o.g.: a precise plan and a key sub-lemma
Goal. Show that among label-invariant algorithms, resolving ties older-first does not increase the expected time to the first collision. We outline a filtration-based, exchangeability-driven argument and isolate a checkable sub-lemma.

- Setup. Work under the event E_noFM that no false merges occur before the first collision; by Lemma 4, the walk-system is a disjoint family of forward paths until the first collision. Fix a pre-sampled start order r and condition on E_noSK (for coupling to r). Consider a label-invariant algorithm A; ties occur at stopping times τ when there are at least two eligible walks with identical current length.

- Exchangeability at ties. Under the symmetrized setting (averaging over σ), conditioned on the unlabeled state just before τ, the multiset of labels assigned to the tied walks is in uniform random order (by label-invariance and σ-randomness). Therefore, the immediate success hazard at the next step (probability that the next Step lands in I_t) is identical for all choices among the tied walks.

- Monotone coupling of tie choices. Define A_old to be A with the sole modification that at each tie it picks the smallest start index among tied walks (“older-first”). We couple A and A_old to share all randomness except at tie indices. At a tie time τ with tied set T, the conditional law of the immediate success indicator 1{hit at next Step} is the same under both choices. If no success occurs at that step, we progress to the next state. The crucial quantitative direction is to show that, for each fixed scale i, the capped-sum potential
  Φ_i(t) := ∑_j min{ℓ_j(t), 2^i}
 stochastically dominates under A_old compared to A at all times t prior to the first collision. Intuitively, older-first greedily fills earlier coordinates up to the cap 2^i before advancing younger ones (Lemma 5 guarantees coordinatewise age-monotonicity), so by an exchange argument Φ_i cannot decrease when switching a tie choice to the older index. This gives a pathwise (with respect to σ) inequality Φ_i^{old}(t) ≥ Φ_i^{A}(t) for all t, and all i.

Sub-lemma S (capped-sum dominance at ties). Fix a tie time τ and a scale i. Let the current equal length be L<2^i (the only interesting case; if L≥2^i the cap is inactive). Consider two next-step choices: extend the oldest tied index a or a younger tied index b. Denote the capped-sum after this step by Φ_i^{(a)} and Φ_i^{(b)} respectively. Then Φ_i^{(a)} ≥ Φ_i^{(b)} deterministically. Moreover, iterating such local improvements shows that after any finite sequence of tie resolutions, Φ_i under older-first dominates Φ_i under any other tie-breaking policy, for all i and all times.
Sketch of proof. At a single tie where all tied walks have the same current length L<2^i, incrementing the older one increases the same coordinate that appears earlier in the sum over j ordered by start age; with the cap min(·,2^i), the increment contribution is 1 regardless of which tied walk is chosen, but future opportunities to accrue additional units before hitting the cap are better preserved on the older indices under older-first. A standard adjacent-swap exchange (bubble-sort) argument formalizes that repeatedly moving mass to older coordinates (without changing total mass and while respecting that increments occur one unit at a time) never decreases the capped sum. We will write this carefully by induction on steps and via adjacent transpositions in the next round.

Why S helps. Given S, for the particular scale i picked out by A’s first collision, we have for every time t prior to that collision
  Φ_i^{old}(t) ≥ Φ_i^A(t),
 pathwise (for a fixed σ,r). Using the fact that the total number of Step queries of A up to that moment equals ∑_j ℓ_j(t), we obtain the bound from Lemma 6 for A_old. Thus A_old meets the single-scale overhead guarantee, which is sufficient for the epoch analysis. Combined with the exchangeability of immediate hazards at ties, this shows that E[time-to-first-collision(A_old)] ≤ E[time-to-first-collision(A)].

Status. The sub-lemma S is the remaining formal piece; its single-tie version is straightforward, and the multi-step cumulative dominance follows by an adjacent-transposition argument. I will supply the full proof in the next round with a clearly defined partial order and a rigorous exchange.

### Freedman-style tails for skips and false merges (optional refinement)
Lemma (Freedman tail for X). In an epoch with S starts and F steps, define X_false as the false-merge count and X_skip as the skip count. Under the permutation coupling, each increment is a [0,1]-bounded martingale difference with predictable quadratic variation V ≤ F·S/(n−F). Therefore, for any λ>0,
- Pr[X_false − E X_false ≥ λ] ≤ exp(− λ^2 / (2(V + λ/3))).
- The same bound holds for X_skip.
Why useful. This yields exponentially small tails in the regime F·S ≪ n, enabling (if needed) a simultaneous high-probability control over all O(log n) scales in a single epoch. It does not change the asymptotic α-threshold of 1/2 for the union bound over scales (since the union is over O(log n) events), but it tightens constants.
Sketch. Standard application of Freedman’s inequality for martingales with bounded increments. The Doob martingale is obtained by revealing the step-by-step history; the indicator at each Step has bounded conditional variance ≤ s_t/|W_t|(1−s_t/|W_t|), summing to ≤ E X_false.

### Parameter check for the epoch assembly (assuming older-first)
- Let q⋆=RAC(collision,f). Picking an optimal certificate-aided older-first, label-invariant competitor A⋆, Markov gives Pr[A⋆ finishes within 2q⋆] ≥ 1/2.
- Intersect with no-skip/no-false-merge for A⋆ over 2q⋆ queries: Pr ≥ 1 − O(q⋆^2/n).
- For the particular scale i at which A⋆ first collides, require no-skip/no-false-merge for A_i over 4q⋆ queries: Pr ≥ 1 − O(q⋆^2/n). Union over O(log n) scales contributes an additive O((q⋆^2 log n)/n).
- Thus a single 8q⋆-round epoch of A_all succeeds with probability at least 1/2 − O((q⋆^2 log n)/n). In the regime q⋆ ≤ √n / log^α n, this is ≥ 1/3 for large n when α > 1/2. Hence E[Queries_{A_all}(f)] = O(q⋆ log n).
Remark. With only the coarser two-event union bound (not unioning over scales), α ≥ 1 suffices; with the refined per-scale union bound as above, α > 1/2 suffices.

### Small examples and sanity checks
- Necessity of older-first for the deterministic 2× bound. Construct a toy where A starts many walks but advances only the youngest to length L while keeping older ones at length 0. Then (j−1)·2^i can greatly exceed t, showing Lemma 6’s amortization fails without older-first.
- Symmetry of tie hazards. Under the symmetrized setting, at a tie the probability that the chosen step lands in I_t is the same no matter which tied walk is extended; this uses only exchangeability of labels among tied indices.

### Obstacles remaining
- The rigorous proof of the multi-step capped-sum dominance (Sub-lemma S) and the consequent “older-first w.l.o.g.” Lemma are pending. The plan is to formalize an adjacent-transposition exchange at ties and demonstrate that Φ_i is nondecreasing under replacement of any non-oldest tie choice by the oldest, iterated to convergence (older-first).
- We must keep conditioning consistently on no-skips/no-false-merges for both A and A_i in the single-scale coupling and reflect the O(log n) union bound (already addressed in the parameter check above).

### Next steps
1) Write the full proof of Sub-lemma S (capped-sum dominance) and the older-first w.l.o.g. Lemma, with explicit filtrations: define tie stopping times τ_k, prove exchangeability at τ_k, and carry out the adjacent-swap argument to show Φ_i^{old}(t) ≥ Φ_i^A(t) for all i,t.
2) Curate the symmetrization lemma (averaged form) into output.md and connect it to the “older-first w.l.o.g.” reduction for RAC.
3) Finalize the epoch assembly, explicitly quantifying the per-epoch success probability with α > 1/2 and constants C in Theorem (forward-only, low complexity).
4) Optionally, add Freedman tails for skip/false-merge counts to improve constants and support a simultaneous control across all scales in a single epoch.


=== prover-02.out.json (progress_md) ===
## Round 0003 — Symmetrization and older-first tie-breaking formalization; assembling the epoch bound

In this round I address two gaps flagged by the verifier and needed to complete the forward-only, low-complexity theorem: (1) a correct symmetrization statement that justifies focusing on label-invariant algorithms in the unlabeled-certificate setting; (2) a rigorous “older-first w.l.o.g.” lemma based on exchangeability at tie times under random relabelings. I then outline the epoch assembly with explicit constants. I also point out what to append to output.md and what remains open.

### Corrections and clarifications about output.md
- Symmetrization (missing): output.md does not yet include the correct symmetrization lemma. The earlier Round 0002 notes claimed an equality E[T(A_sym on f)] = E[T(A on f)], which is generally false for a fixed labeled instance f. The correct statement averages over a random relabeling (conjugacy) of f. I give a precise formulation below (Lemma S).
- Older-first w.l.o.g.: output.md uses older-first in Lemma 6 but lacks a formal reduction showing that we can restrict attention to older-first tie-breaking among label-invariant algorithms without increasing expected time (in the conjugacy-averaged sense). I provide Lemma D below, resolving this gap.
- Pacing wrapper: As the verifier noted, a wrapper that “inserts catch-up steps” is not implementable in our online oracle model. I do not use it. The route via Lemma D suffices.

### New Lemma S (Averaged symmetrization to label-invariant algorithms)
Statement.
- Let P be the collision property. For any randomized algorithm A (possibly label-dependent) and any fixed f:[n]→[n], define A_sym that samples a uniform σ∈S_n and simulates A on σ∘f∘σ^{-1}, undoing σ when issuing queries/processing answers. For any horizon T,
  E[T_hit∧T(A_sym on f)] = E_σ[E[T_hit∧T(A on σ∘f∘σ^{-1})]].
- Consequently, RAC(P,f) = inf_A max_π E[T_hit(A on π∘f)] = inf_A′ E_σ[E[T_hit(A′ on σ∘f∘σ^{-1})]], where the infimum can be taken over label-invariant algorithms A′ (those whose decisions depend only on the unlabeled state). In particular, there exists a sequence of label-invariant algorithms attaining RAC(P,f) up to arbitrarily small additive ε.
Why useful here.
- Reduces the competitor to be label-invariant without loss for the unlabeled-certificate benchmark, allowing us to reason about tie-breaking via exchangeability under random conjugacy.
Sketch of proof.
- The first identity is by construction. For the second, observe that RAC(P,σ∘f∘σ^{-1})=RAC(P,f) for all σ, so the maximum over conjugates equals the average over conjugates; then apply the first identity and note that averaging A over σ yields a label-invariant algorithm achieving the same averaged cost.

### New Lemma D (Tie-breaking invariance under conjugacy; older-first w.l.o.g.)
Setup/definitions.
- Work in the forward-only model on a fixed f. Let A_base be a label-invariant randomized policy that, at any state, specifies whether to Start or Step, and if Step, specifies a target length (e.g., “extend one of the longest eligible walks”). When at some step the policy mandates “extend a walk among a set U of eligible walks that share the same current length,” we call this a tie.
- A tie-breaker is a measurable rule that, given the unlabeled state and the set U (with their age indices), selects one element of U to extend. Let φ and ψ be two tie-breakers (e.g., φ = older-first; ψ = any other label-independent tie-breaker), and let A_φ, A_ψ denote the corresponding algorithms. Let T_hit denote the time to first collision.
Statement.
- Consider the experiment that first samples a uniform random σ∈S_n, then runs A_φ (resp. A_ψ) on the conjugate instance σ∘f∘σ^{-1}, stopping at the first collision. Then for any horizon T,
  E_σ[E[T_hit∧T(A_φ on σ∘f∘σ^{-1})]] = E_σ[E[T_hit∧T(A_ψ on σ∘f∘σ^{-1})]].
- In particular, in the unlabeled-certificate benchmark (which is invariant under conjugacy), tie-breaking does not affect the expected query complexity; hence, we may assume w.l.o.g. that the competitor resolves ties older-first.
Why useful here.
- This justifies the use of Lemma 5 (age-monotone invariant) and Lemma 6 (single-scale domination) for the competitor, closing a key gap.
Proof idea (filtration and exchangeability at ties).
- Let (F_t) be the filtration of the labeled process up to t Steps. Define the unlabeled abstraction U_t: it contains the multiset of active walk lengths (ordered by age), whether a walk is terminated, and the count |I_t| of Step-seen images. A label-invariant policy A_base ensures that, pre-collision and under “no false merges,” the decision to Step vs Start and the targeted length depend only on U_t.
- Consider the first tie time τ (a stopping time with respect to the unlabeled filtration) where there are m≥2 eligible walks U_τ={W_{j_1},…,W_{j_m}} of equal length L. Condition on U_τ and on the sigma-field generated by U_s for s≤τ, and on the internal randomness of A_base up to τ. Under a uniform random conjugacy σ, the joint distribution of the labeled endpoints (u_{j_1},…,u_{j_m}) at time τ is exchangeable: it is invariant under any permutation of {j_1,…,j_m}, because σ induces a uniform random relabeling across the still-unseen vertices, and (by no false merges up to τ) the ℓ=L forward endpoints arise from disjoint, unlabeled tails that are symmetric under conjugation. Similarly, the Step-seen image set I_τ is (conditionally) uniformly distributed among |I_τ|-subsets of the revealed images and independent of the labels of the u_{j_r}’s beyond U_τ.
- Hence, the conditional hazard at τ, Pr[f(u_{j_r})∈I_τ | U_τ, F_{τ−}], is the same for all r (exchangeability across the tied endpoints). Therefore the one-step success probability (at the next Step) is identical under any tie-breaker.
- To extend beyond the first tie, define recursively the sequence of tie times τ_1<τ_2<⋯ (up to T). At each τ_k, given the unlabeled history up to τ_k, the conditional joint law of the labels on the tied endpoints remains exchangeable; this uses that relabeling by right composition with a permutation that acts within the (unseen) labels of the tied walks preserves the uniform distribution over σ. One can formalize a measure-preserving bijection Φ_k on the relabelings σ (compose with a transposition within the tied endpoints’ labels) that maps the run of A_φ to a run of A_ψ while preserving the unlabeled history up to τ_k and the distribution of future randomness. Inductively, the distributions of the entire labeled transcripts (up to T or to collision) under A_φ and under A_ψ coincide after averaging over σ. Taking expectations yields the claim.
- Remark on “no false merges”: The exchangeability argument at ties uses that, pre-collision, the tied endpoints correspond to disjoint, unseen regions of the function graph (Lemma 4), so a conjugacy that swaps their label-sets leaves the unlabeled state unaffected while preserving the uniform measure on σ. This is exactly the regime we condition on in Lemma 6 and in the epoch assembly.

### Consequence: older-first w.l.o.g. and completion of the single-scale comparison
- By Lemma S we can assume the competitor is label-invariant without changing the RAC benchmark. By Lemma D, we can also assume the tie-breaker is older-first with no change to the conjugacy-averaged expected time. Therefore Lemma 5 (age-monotone invariant) and Lemma 6 (single-scale domination, 2× overhead in Steps) apply to the competitor A.
- This completes the missing justification for using older-first in output.md’s Lemma 6. I recommend curating Lemma S and Lemma D next to make the chain airtight.

### Epoch assembly (explicit constants and α)
Let q⋆=RAC(collision,f). Let A⋆ be a certificate-aided algorithm with E[Queries]≤q⋆.
- Success within 2q⋆. By Markov, Pr[A⋆ finishes within 2q⋆] ≥ 1/2.
- No false merges/skips with high probability.
  • For A⋆ over 2q⋆ queries, Lemmas 1–2 and Corollary 3 (with S,F≤2q⋆) give Pr[FM(A⋆)∪SKIP(A⋆)] ≤ 8·(2q⋆)^2/n ≤ 32·q⋆^2/n.
  • For the single-scale A_i over 4q⋆ queries, the same bound yields Pr[FM(A_i)∪SKIP(A_i)] ≤ 8·(4q⋆)^2/n ≤ 128·q⋆^2/n for a fixed i.
  • We only need the latter for the specific i at which A⋆ finds the first collision. To upper bound the probability that this fails at that i, we can union bound over all i∈{0,…,⌊log_2 n⌋}; this gives an additional factor O(log n). Thus the combined failure probability across both processes is O((q⋆^2 log n)/n).
- Coupling to a winning scale. Condition on the intersection of: (i) A⋆ finishes within 2q⋆; (ii) no false merges/skips for A⋆; and (iii) no false merges/skips for A_i at the relevant i. By Lemma 6 (using older-first per Lemma D), A_i deterministically finds a collision within ≤ 2·(2q⋆)=4q⋆ Steps. Interleaving scales as in A_all costs O(log n) queries per round, so 8q⋆ rounds suffice per epoch.
- Per-epoch success probability and expectation. For large n and in the regime q⋆ ≤ √n / log^α n with α≥1, we have (q⋆^2 log n)/n ≤ 1/log^{2α−1} n = o(1). Picking n large enough, the per-epoch success probability is at least 1/2 − c·(q⋆^2 log n)/n ≥ 1/3 for a fixed absolute c. Therefore, by a geometric bound, E[Queries(A_all on f)] ≤ C·q⋆·log n for an absolute C.
- Note on α: The simple union bound across O(log n) scales requires α≥1 for a clean constant success probability. If desired, Freedman’s inequality for the martingale of increments of skip/false-merge indicators (bounded by 1 with predictable variance ≲ F·S/(n−F)) can improve constants/tails but does not evidently reduce the α-threshold below 1 without further refinements to the epoch design.

### Why the Lemma D proof conditions match our usage
- Lemma 6 and the epoch assembly condition on “no false merges” for both A and A_i. This guarantees disjointness of active walks up to the first collision (Lemma 4), which is the regime where the tie-exchangeability argument applies. Thus, applying Lemma D exactly in this conditional world is legitimate and sufficient for Lemma 6.

### What to curate next into output.md
- Lemma S (Averaged symmetrization to label-invariant algorithms) with the proof sketch above.
- Lemma D (Tie-breaking invariance under conjugacy) with the exchangeability-at-tie proof. It would be good to state explicitly the tie times τ_k as stopping times, and the construction of measure-preserving maps σ↦τ_k∘σ that swap the labels of tied endpoints without affecting the unlabeled process.
- Proposition (Epoch assembly). Given Lemma 6 and the permutation-coupling bounds (Lemmas 1–2), this yields the target theorem in the regime q⋆ ≤ √n / log^α n with α≥1, with explicit constants as above.

### Obstacles and remaining items
- Full formalization of Lemma D: I presented a detailed, checkable route via stopping times and exchangeability, but the measure-preserving map “compose σ by a transposition within the label-set of tied endpoints” constructed adaptively over ties should be written explicitly (induction over tie events). The key invariant is that the unlabeled state is fixed while the distribution of labels remains uniform under conjugacy; no-false-merge ensures the tied endpoints’ future tails are disjoint/unseen, so these local conjugacies are well-defined.
- Freedman tails: optional improvement for the per-epoch failure probability. Define the Doob martingale for X_t (cumulative skips/false merges) with bounded increments and predictable quadratic variation V_t ≤ E[X_T]; Freedman then yields exp(−Ω(min{λ^2/(E[X_T]+λ),λ})) tails. Not crucial for α≥1.
- Final theorem statement and constants: After curating Lemma S and Lemma D, we can add the theorem “Forward-only, low complexity” with α≥1 and some explicit C.

### Next steps
1) Write Lemma S and Lemma D as formal statements in output.md with proofs organized by filtrations and tie times, as outlined. This closes the main correctness gaps.
2) Add a short proposition assembling the epoch argument: quantify per-epoch success and conclude E[Queries(A_all)] ≤ C·q⋆·log n in the regime q⋆ ≤ √n / log^α n with α≥1.
3) Optional: include a Freedman tail lemma for skips/false merges (under the permutation coupling) to strengthen high-probability bounds.


=== Verifier (summary_md) ===

=== Verifier (verdict) ===
partial success

