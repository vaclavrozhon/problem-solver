--- SYSTEM ---
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (summary so far)
- output.md (rigorously proven results so far)

Guidelines:
- notes.md: should be a readable running log of interesting work. Prefer appending. Replace only if old notes are clearly misleading. Remember -- notes should be self-contained and should make sense even without seeing outputs of past provers. 
- output.md: should be concise and rigorous. It should contain only fully proven theorems that are clearly an interesting step towards the solution (or the solution itself). The beginning of the file is a clear list of interesting theorems you can prove. From the statement of the theorem it has to be clear that this constitutes nontrivial progress towards solution. The rest of the file contains a fully rigorous list of the proofs of the theorems. Keep only proven theorems with clear proofs. If a statement is flawed and you cannot fix it, remove it from output.md and instead add it to notes.md with explanation.
- Be careful with the booleans `new_notes_append` and `new_outputs_append`: default is True (append). Use False only when deliberately rewriting everything.

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (≥200 words). Include concrete next-step suggestions. The next round of provers may not see last round outputs; ensure all valuable info is stored in notes.",
  "new_notes_md": "Markdown (KaTeX allowed). Usually appended to notes.",
  "new_notes_append": "True|False",
  "new_outputs_md": "Markdown (KaTeX allowed). Usually appended to output.md.",
  "new_outputs_append": "True|False",
  "verdict": "success|partial success|nothing so far"
}

**Verdict definitions**:
- **success**: Something that one could publish, even if it is not the full solution (e.g., significant theorem, key lemma, novel technique, partial solution with clear path forward)
- **partial success**: Something worthy enough to write into output.md (e.g., correct but preliminary results, useful technical lemmas, validated approaches that advance understanding)
- **nothing so far**: No meaningful mathematical progress or only exploratory work


--- USER ---
You receive multiple prover reports. Evaluate correctness, value, and pick promising directions. Update notes.md (append/replace) with useful ideas and update output.md (append/replace) ONLY with rigorously verified results.

Prover reports (JSON):
[{"prover_id": "01", "progress_md": "## Round 0003 \u2014 Consolidating prerequisites; symmetrization fix; roadmap to older-first w.l.o.g.\n\n### What is already solid (recap of curated pieces)\n- False merges and skips are rare up to 2q queries: E[#false merges] \u2264 F\u00b7S/(n\u2212F) and E[#skips] \u2264 F\u00b7S/(n\u2212F); hence Pr[bad] = O(q^2/n) in 2q-query epochs (curated Lemmas 1\u20132 and Corollary 3). This is uniform over f and adaptivity.\n- Structural consequences under no-false-merge: before the first collision the active walks are disjoint forward paths, and any step landing in the previously Step-seen image set I_t is a true collision (curated Lemma 4).\n- Age-monotone invariant: under older-first tie-breaking, the length vector (by start age) is nonincreasing at all times prior to the first collision (curated Lemma 5).\n- Single-scale domination under older-first: conditioned on no-skips/no-false-merge for both processes, if A\u2019s first collision occurs along W_j at length L \u2208 [2^i,2^{i+1}), then the single-scale process A_i finds a collision within \u2264 2\u00b7t steps where t is the number of Step queries A used up to that moment (curated Lemma 6).\n\nThese ingredients are the forward-only analogue of the graph-side amortization in \u00a76.3 of BGN, contingent on the older-first assumption.\n\n### Corrections and clarifications relative to output.md\n- No changes required to curated Lemmas 1\u20132\u20133\u20134\u20135\u20136. They are consistent and correctly conditioned on no-false-merge and no-skip for both A and A_i.\n- Remaining gap: we still need a rigorous reduction \u201colder-first w.l.o.g.\u201d for the certificate-aided competitor. Until that is in place, the epoch assembly towards Theorem (forward-only, low complexity) uses Lemma 6 only for algorithms that already tie-break older-first.\n\n### New clean lemma (ready to curate next): Symmetrization to label-invariant algorithms\nStatement (precise averaged form). For any randomized algorithm A and any fixed f:[n]\u2192[n], define the symmetrized algorithm A_sym that samples a uniform permutation \u03c3 of [n] at time 0 and simulates A on \u03c3\u2218f\u2218\u03c3^{-1}, undoing \u03c3 in queries/answers. Then for any finite horizon T,\n\\[ \\E[T_{hit}\\wedge T\\;\\text{of}\\;A_{sym}\\;\\text{on}\\;f] \\;=\\; \\E_{\\sigma}\\,\\E[ T_{hit}\\wedge T\\;\\text{of}\\;A\\;\\text{on}\\;\\sigma\\circ f\\circ\\sigma^{-1}]. \\]\nConsequently, since RAC(collision,\u03c3\u2218f\u2218\u03c3^{\u22121}) = RAC(collision,f) for all \u03c3, the infimum defining RAC can be achieved (or arbitrarily approached) within the class of label-invariant algorithms (i.e., those whose decision distribution depends only on the unlabeled state). This is the safe replacement for the incorrect equality \u201cE[T(A_sym on f)] = E[T(A on f)]\u201d (which need not hold for a fixed f).\nWhy useful here. It allows us to restrict attention to label-invariant competitors before addressing tie-breaking, without loss for RAC.\nSketch of proof. Standard: composing with a uniform \u03c3 makes the transcript distribution depend only on unlabeled states; averaging preserves the optimal value since the max over permutations in RAC is invariant under conjugation.\n\n### Toward the older-first w.l.o.g.: a precise plan and a key sub-lemma\nGoal. Show that among label-invariant algorithms, resolving ties older-first does not increase the expected time to the first collision. We outline a filtration-based, exchangeability-driven argument and isolate a checkable sub-lemma.\n\n- Setup. Work under the event E_noFM that no false merges occur before the first collision; by Lemma 4, the walk-system is a disjoint family of forward paths until the first collision. Fix a pre-sampled start order r and condition on E_noSK (for coupling to r). Consider a label-invariant algorithm A; ties occur at stopping times \u03c4 when there are at least two eligible walks with identical current length.\n\n- Exchangeability at ties. Under the symmetrized setting (averaging over \u03c3), conditioned on the unlabeled state just before \u03c4, the multiset of labels assigned to the tied walks is in uniform random order (by label-invariance and \u03c3-randomness). Therefore, the immediate success hazard at the next step (probability that the next Step lands in I_t) is identical for all choices among the tied walks.\n\n- Monotone coupling of tie choices. Define A_old to be A with the sole modification that at each tie it picks the smallest start index among tied walks (\u201colder-first\u201d). We couple A and A_old to share all randomness except at tie indices. At a tie time \u03c4 with tied set T, the conditional law of the immediate success indicator 1{hit at next Step} is the same under both choices. If no success occurs at that step, we progress to the next state. The crucial quantitative direction is to show that, for each fixed scale i, the capped-sum potential\n  \u03a6_i(t) := \u2211_j min{\u2113_j(t), 2^i}\n stochastically dominates under A_old compared to A at all times t prior to the first collision. Intuitively, older-first greedily fills earlier coordinates up to the cap 2^i before advancing younger ones (Lemma 5 guarantees coordinatewise age-monotonicity), so by an exchange argument \u03a6_i cannot decrease when switching a tie choice to the older index. This gives a pathwise (with respect to \u03c3) inequality \u03a6_i^{old}(t) \u2265 \u03a6_i^{A}(t) for all t, and all i.\n\nSub-lemma S (capped-sum dominance at ties). Fix a tie time \u03c4 and a scale i. Let the current equal length be L<2^i (the only interesting case; if L\u22652^i the cap is inactive). Consider two next-step choices: extend the oldest tied index a or a younger tied index b. Denote the capped-sum after this step by \u03a6_i^{(a)} and \u03a6_i^{(b)} respectively. Then \u03a6_i^{(a)} \u2265 \u03a6_i^{(b)} deterministically. Moreover, iterating such local improvements shows that after any finite sequence of tie resolutions, \u03a6_i under older-first dominates \u03a6_i under any other tie-breaking policy, for all i and all times.\nSketch of proof. At a single tie where all tied walks have the same current length L<2^i, incrementing the older one increases the same coordinate that appears earlier in the sum over j ordered by start age; with the cap min(\u00b7,2^i), the increment contribution is 1 regardless of which tied walk is chosen, but future opportunities to accrue additional units before hitting the cap are better preserved on the older indices under older-first. A standard adjacent-swap exchange (bubble-sort) argument formalizes that repeatedly moving mass to older coordinates (without changing total mass and while respecting that increments occur one unit at a time) never decreases the capped sum. We will write this carefully by induction on steps and via adjacent transpositions in the next round.\n\nWhy S helps. Given S, for the particular scale i picked out by A\u2019s first collision, we have for every time t prior to that collision\n  \u03a6_i^{old}(t) \u2265 \u03a6_i^A(t),\n pathwise (for a fixed \u03c3,r). Using the fact that the total number of Step queries of A up to that moment equals \u2211_j \u2113_j(t), we obtain the bound from Lemma 6 for A_old. Thus A_old meets the single-scale overhead guarantee, which is sufficient for the epoch analysis. Combined with the exchangeability of immediate hazards at ties, this shows that E[time-to-first-collision(A_old)] \u2264 E[time-to-first-collision(A)].\n\nStatus. The sub-lemma S is the remaining formal piece; its single-tie version is straightforward, and the multi-step cumulative dominance follows by an adjacent-transposition argument. I will supply the full proof in the next round with a clearly defined partial order and a rigorous exchange.\n\n### Freedman-style tails for skips and false merges (optional refinement)\nLemma (Freedman tail for X). In an epoch with S starts and F steps, define X_false as the false-merge count and X_skip as the skip count. Under the permutation coupling, each increment is a [0,1]-bounded martingale difference with predictable quadratic variation V \u2264 F\u00b7S/(n\u2212F). Therefore, for any \u03bb>0,\n- Pr[X_false \u2212 E X_false \u2265 \u03bb] \u2264 exp(\u2212 \u03bb^2 / (2(V + \u03bb/3))).\n- The same bound holds for X_skip.\nWhy useful. This yields exponentially small tails in the regime F\u00b7S \u226a n, enabling (if needed) a simultaneous high-probability control over all O(log n) scales in a single epoch. It does not change the asymptotic \u03b1-threshold of 1/2 for the union bound over scales (since the union is over O(log n) events), but it tightens constants.\nSketch. Standard application of Freedman\u2019s inequality for martingales with bounded increments. The Doob martingale is obtained by revealing the step-by-step history; the indicator at each Step has bounded conditional variance \u2264 s_t/|W_t|(1\u2212s_t/|W_t|), summing to \u2264 E X_false.\n\n### Parameter check for the epoch assembly (assuming older-first)\n- Let q\u22c6=RAC(collision,f). Picking an optimal certificate-aided older-first, label-invariant competitor A\u22c6, Markov gives Pr[A\u22c6 finishes within 2q\u22c6] \u2265 1/2.\n- Intersect with no-skip/no-false-merge for A\u22c6 over 2q\u22c6 queries: Pr \u2265 1 \u2212 O(q\u22c6^2/n).\n- For the particular scale i at which A\u22c6 first collides, require no-skip/no-false-merge for A_i over 4q\u22c6 queries: Pr \u2265 1 \u2212 O(q\u22c6^2/n). Union over O(log n) scales contributes an additive O((q\u22c6^2 log n)/n).\n- Thus a single 8q\u22c6-round epoch of A_all succeeds with probability at least 1/2 \u2212 O((q\u22c6^2 log n)/n). In the regime q\u22c6 \u2264 \u221an / log^\u03b1 n, this is \u2265 1/3 for large n when \u03b1 > 1/2. Hence E[Queries_{A_all}(f)] = O(q\u22c6 log n).\nRemark. With only the coarser two-event union bound (not unioning over scales), \u03b1 \u2265 1 suffices; with the refined per-scale union bound as above, \u03b1 > 1/2 suffices.\n\n### Small examples and sanity checks\n- Necessity of older-first for the deterministic 2\u00d7 bound. Construct a toy where A starts many walks but advances only the youngest to length L while keeping older ones at length 0. Then (j\u22121)\u00b72^i can greatly exceed t, showing Lemma 6\u2019s amortization fails without older-first.\n- Symmetry of tie hazards. Under the symmetrized setting, at a tie the probability that the chosen step lands in I_t is the same no matter which tied walk is extended; this uses only exchangeability of labels among tied indices.\n\n### Obstacles remaining\n- The rigorous proof of the multi-step capped-sum dominance (Sub-lemma S) and the consequent \u201colder-first w.l.o.g.\u201d Lemma are pending. The plan is to formalize an adjacent-transposition exchange at ties and demonstrate that \u03a6_i is nondecreasing under replacement of any non-oldest tie choice by the oldest, iterated to convergence (older-first).\n- We must keep conditioning consistently on no-skips/no-false-merges for both A and A_i in the single-scale coupling and reflect the O(log n) union bound (already addressed in the parameter check above).\n\n### Next steps\n1) Write the full proof of Sub-lemma S (capped-sum dominance) and the older-first w.l.o.g. Lemma, with explicit filtrations: define tie stopping times \u03c4_k, prove exchangeability at \u03c4_k, and carry out the adjacent-swap argument to show \u03a6_i^{old}(t) \u2265 \u03a6_i^A(t) for all i,t.\n2) Curate the symmetrization lemma (averaged form) into output.md and connect it to the \u201colder-first w.l.o.g.\u201d reduction for RAC.\n3) Finalize the epoch assembly, explicitly quantifying the per-epoch success probability with \u03b1 > 1/2 and constants C in Theorem (forward-only, low complexity).\n4) Optionally, add Freedman tails for skip/false-merge counts to improve constants and support a simultaneous control across all scales in a single epoch.\n"}, {"prover_id": "02", "progress_md": "## Round 0003 \u2014 Symmetrization and older-first tie-breaking formalization; assembling the epoch bound\n\nIn this round I address two gaps flagged by the verifier and needed to complete the forward-only, low-complexity theorem: (1) a correct symmetrization statement that justifies focusing on label-invariant algorithms in the unlabeled-certificate setting; (2) a rigorous \u201colder-first w.l.o.g.\u201d lemma based on exchangeability at tie times under random relabelings. I then outline the epoch assembly with explicit constants. I also point out what to append to output.md and what remains open.\n\n### Corrections and clarifications about output.md\n- Symmetrization (missing): output.md does not yet include the correct symmetrization lemma. The earlier Round 0002 notes claimed an equality E[T(A_sym on f)] = E[T(A on f)], which is generally false for a fixed labeled instance f. The correct statement averages over a random relabeling (conjugacy) of f. I give a precise formulation below (Lemma S).\n- Older-first w.l.o.g.: output.md uses older-first in Lemma 6 but lacks a formal reduction showing that we can restrict attention to older-first tie-breaking among label-invariant algorithms without increasing expected time (in the conjugacy-averaged sense). I provide Lemma D below, resolving this gap.\n- Pacing wrapper: As the verifier noted, a wrapper that \u201cinserts catch-up steps\u201d is not implementable in our online oracle model. I do not use it. The route via Lemma D suffices.\n\n### New Lemma S (Averaged symmetrization to label-invariant algorithms)\nStatement.\n- Let P be the collision property. For any randomized algorithm A (possibly label-dependent) and any fixed f:[n]\u2192[n], define A_sym that samples a uniform \u03c3\u2208S_n and simulates A on \u03c3\u2218f\u2218\u03c3^{-1}, undoing \u03c3 when issuing queries/processing answers. For any horizon T,\n  E[T_hit\u2227T(A_sym on f)] = E_\u03c3[E[T_hit\u2227T(A on \u03c3\u2218f\u2218\u03c3^{-1})]].\n- Consequently, RAC(P,f) = inf_A max_\u03c0 E[T_hit(A on \u03c0\u2218f)] = inf_A\u2032 E_\u03c3[E[T_hit(A\u2032 on \u03c3\u2218f\u2218\u03c3^{-1})]], where the infimum can be taken over label-invariant algorithms A\u2032 (those whose decisions depend only on the unlabeled state). In particular, there exists a sequence of label-invariant algorithms attaining RAC(P,f) up to arbitrarily small additive \u03b5.\nWhy useful here.\n- Reduces the competitor to be label-invariant without loss for the unlabeled-certificate benchmark, allowing us to reason about tie-breaking via exchangeability under random conjugacy.\nSketch of proof.\n- The first identity is by construction. For the second, observe that RAC(P,\u03c3\u2218f\u2218\u03c3^{-1})=RAC(P,f) for all \u03c3, so the maximum over conjugates equals the average over conjugates; then apply the first identity and note that averaging A over \u03c3 yields a label-invariant algorithm achieving the same averaged cost.\n\n### New Lemma D (Tie-breaking invariance under conjugacy; older-first w.l.o.g.)\nSetup/definitions.\n- Work in the forward-only model on a fixed f. Let A_base be a label-invariant randomized policy that, at any state, specifies whether to Start or Step, and if Step, specifies a target length (e.g., \u201cextend one of the longest eligible walks\u201d). When at some step the policy mandates \u201cextend a walk among a set U of eligible walks that share the same current length,\u201d we call this a tie.\n- A tie-breaker is a measurable rule that, given the unlabeled state and the set U (with their age indices), selects one element of U to extend. Let \u03c6 and \u03c8 be two tie-breakers (e.g., \u03c6 = older-first; \u03c8 = any other label-independent tie-breaker), and let A_\u03c6, A_\u03c8 denote the corresponding algorithms. Let T_hit denote the time to first collision.\nStatement.\n- Consider the experiment that first samples a uniform random \u03c3\u2208S_n, then runs A_\u03c6 (resp. A_\u03c8) on the conjugate instance \u03c3\u2218f\u2218\u03c3^{-1}, stopping at the first collision. Then for any horizon T,\n  E_\u03c3[E[T_hit\u2227T(A_\u03c6 on \u03c3\u2218f\u2218\u03c3^{-1})]] = E_\u03c3[E[T_hit\u2227T(A_\u03c8 on \u03c3\u2218f\u2218\u03c3^{-1})]].\n- In particular, in the unlabeled-certificate benchmark (which is invariant under conjugacy), tie-breaking does not affect the expected query complexity; hence, we may assume w.l.o.g. that the competitor resolves ties older-first.\nWhy useful here.\n- This justifies the use of Lemma 5 (age-monotone invariant) and Lemma 6 (single-scale domination) for the competitor, closing a key gap.\nProof idea (filtration and exchangeability at ties).\n- Let (F_t) be the filtration of the labeled process up to t Steps. Define the unlabeled abstraction U_t: it contains the multiset of active walk lengths (ordered by age), whether a walk is terminated, and the count |I_t| of Step-seen images. A label-invariant policy A_base ensures that, pre-collision and under \u201cno false merges,\u201d the decision to Step vs Start and the targeted length depend only on U_t.\n- Consider the first tie time \u03c4 (a stopping time with respect to the unlabeled filtration) where there are m\u22652 eligible walks U_\u03c4={W_{j_1},\u2026,W_{j_m}} of equal length L. Condition on U_\u03c4 and on the sigma-field generated by U_s for s\u2264\u03c4, and on the internal randomness of A_base up to \u03c4. Under a uniform random conjugacy \u03c3, the joint distribution of the labeled endpoints (u_{j_1},\u2026,u_{j_m}) at time \u03c4 is exchangeable: it is invariant under any permutation of {j_1,\u2026,j_m}, because \u03c3 induces a uniform random relabeling across the still-unseen vertices, and (by no false merges up to \u03c4) the \u2113=L forward endpoints arise from disjoint, unlabeled tails that are symmetric under conjugation. Similarly, the Step-seen image set I_\u03c4 is (conditionally) uniformly distributed among |I_\u03c4|-subsets of the revealed images and independent of the labels of the u_{j_r}\u2019s beyond U_\u03c4.\n- Hence, the conditional hazard at \u03c4, Pr[f(u_{j_r})\u2208I_\u03c4 | U_\u03c4, F_{\u03c4\u2212}], is the same for all r (exchangeability across the tied endpoints). Therefore the one-step success probability (at the next Step) is identical under any tie-breaker.\n- To extend beyond the first tie, define recursively the sequence of tie times \u03c4_1<\u03c4_2<\u22ef (up to T). At each \u03c4_k, given the unlabeled history up to \u03c4_k, the conditional joint law of the labels on the tied endpoints remains exchangeable; this uses that relabeling by right composition with a permutation that acts within the (unseen) labels of the tied walks preserves the uniform distribution over \u03c3. One can formalize a measure-preserving bijection \u03a6_k on the relabelings \u03c3 (compose with a transposition within the tied endpoints\u2019 labels) that maps the run of A_\u03c6 to a run of A_\u03c8 while preserving the unlabeled history up to \u03c4_k and the distribution of future randomness. Inductively, the distributions of the entire labeled transcripts (up to T or to collision) under A_\u03c6 and under A_\u03c8 coincide after averaging over \u03c3. Taking expectations yields the claim.\n- Remark on \u201cno false merges\u201d: The exchangeability argument at ties uses that, pre-collision, the tied endpoints correspond to disjoint, unseen regions of the function graph (Lemma 4), so a conjugacy that swaps their label-sets leaves the unlabeled state unaffected while preserving the uniform measure on \u03c3. This is exactly the regime we condition on in Lemma 6 and in the epoch assembly.\n\n### Consequence: older-first w.l.o.g. and completion of the single-scale comparison\n- By Lemma S we can assume the competitor is label-invariant without changing the RAC benchmark. By Lemma D, we can also assume the tie-breaker is older-first with no change to the conjugacy-averaged expected time. Therefore Lemma 5 (age-monotone invariant) and Lemma 6 (single-scale domination, 2\u00d7 overhead in Steps) apply to the competitor A.\n- This completes the missing justification for using older-first in output.md\u2019s Lemma 6. I recommend curating Lemma S and Lemma D next to make the chain airtight.\n\n### Epoch assembly (explicit constants and \u03b1)\nLet q\u22c6=RAC(collision,f). Let A\u22c6 be a certificate-aided algorithm with E[Queries]\u2264q\u22c6.\n- Success within 2q\u22c6. By Markov, Pr[A\u22c6 finishes within 2q\u22c6] \u2265 1/2.\n- No false merges/skips with high probability.\n  \u2022 For A\u22c6 over 2q\u22c6 queries, Lemmas 1\u20132 and Corollary 3 (with S,F\u22642q\u22c6) give Pr[FM(A\u22c6)\u222aSKIP(A\u22c6)] \u2264 8\u00b7(2q\u22c6)^2/n \u2264 32\u00b7q\u22c6^2/n.\n  \u2022 For the single-scale A_i over 4q\u22c6 queries, the same bound yields Pr[FM(A_i)\u222aSKIP(A_i)] \u2264 8\u00b7(4q\u22c6)^2/n \u2264 128\u00b7q\u22c6^2/n for a fixed i.\n  \u2022 We only need the latter for the specific i at which A\u22c6 finds the first collision. To upper bound the probability that this fails at that i, we can union bound over all i\u2208{0,\u2026,\u230alog_2 n\u230b}; this gives an additional factor O(log n). Thus the combined failure probability across both processes is O((q\u22c6^2 log n)/n).\n- Coupling to a winning scale. Condition on the intersection of: (i) A\u22c6 finishes within 2q\u22c6; (ii) no false merges/skips for A\u22c6; and (iii) no false merges/skips for A_i at the relevant i. By Lemma 6 (using older-first per Lemma D), A_i deterministically finds a collision within \u2264 2\u00b7(2q\u22c6)=4q\u22c6 Steps. Interleaving scales as in A_all costs O(log n) queries per round, so 8q\u22c6 rounds suffice per epoch.\n- Per-epoch success probability and expectation. For large n and in the regime q\u22c6 \u2264 \u221an / log^\u03b1 n with \u03b1\u22651, we have (q\u22c6^2 log n)/n \u2264 1/log^{2\u03b1\u22121} n = o(1). Picking n large enough, the per-epoch success probability is at least 1/2 \u2212 c\u00b7(q\u22c6^2 log n)/n \u2265 1/3 for a fixed absolute c. Therefore, by a geometric bound, E[Queries(A_all on f)] \u2264 C\u00b7q\u22c6\u00b7log n for an absolute C.\n- Note on \u03b1: The simple union bound across O(log n) scales requires \u03b1\u22651 for a clean constant success probability. If desired, Freedman\u2019s inequality for the martingale of increments of skip/false-merge indicators (bounded by 1 with predictable variance \u2272 F\u00b7S/(n\u2212F)) can improve constants/tails but does not evidently reduce the \u03b1-threshold below 1 without further refinements to the epoch design.\n\n### Why the Lemma D proof conditions match our usage\n- Lemma 6 and the epoch assembly condition on \u201cno false merges\u201d for both A and A_i. This guarantees disjointness of active walks up to the first collision (Lemma 4), which is the regime where the tie-exchangeability argument applies. Thus, applying Lemma D exactly in this conditional world is legitimate and sufficient for Lemma 6.\n\n### What to curate next into output.md\n- Lemma S (Averaged symmetrization to label-invariant algorithms) with the proof sketch above.\n- Lemma D (Tie-breaking invariance under conjugacy) with the exchangeability-at-tie proof. It would be good to state explicitly the tie times \u03c4_k as stopping times, and the construction of measure-preserving maps \u03c3\u21a6\u03c4_k\u2218\u03c3 that swap the labels of tied endpoints without affecting the unlabeled process.\n- Proposition (Epoch assembly). Given Lemma 6 and the permutation-coupling bounds (Lemmas 1\u20132), this yields the target theorem in the regime q\u22c6 \u2264 \u221an / log^\u03b1 n with \u03b1\u22651, with explicit constants as above.\n\n### Obstacles and remaining items\n- Full formalization of Lemma D: I presented a detailed, checkable route via stopping times and exchangeability, but the measure-preserving map \u201ccompose \u03c3 by a transposition within the label-set of tied endpoints\u201d constructed adaptively over ties should be written explicitly (induction over tie events). The key invariant is that the unlabeled state is fixed while the distribution of labels remains uniform under conjugacy; no-false-merge ensures the tied endpoints\u2019 future tails are disjoint/unseen, so these local conjugacies are well-defined.\n- Freedman tails: optional improvement for the per-epoch failure probability. Define the Doob martingale for X_t (cumulative skips/false merges) with bounded increments and predictable quadratic variation V_t \u2264 E[X_T]; Freedman then yields exp(\u2212\u03a9(min{\u03bb^2/(E[X_T]+\u03bb),\u03bb})) tails. Not crucial for \u03b1\u22651.\n- Final theorem statement and constants: After curating Lemma S and Lemma D, we can add the theorem \u201cForward-only, low complexity\u201d with \u03b1\u22651 and some explicit C.\n\n### Next steps\n1) Write Lemma S and Lemma D as formal statements in output.md with proofs organized by filtrations and tie times, as outlined. This closes the main correctness gaps.\n2) Add a short proposition assembling the epoch argument: quantify per-epoch success and conclude E[Queries(A_all)] \u2264 C\u00b7q\u22c6\u00b7log n in the regime q\u22c6 \u2264 \u221an / log^\u03b1 n with \u03b1\u22651.\n3) Optional: include a Freedman tail lemma for skips/false merges (under the permutation coupling) to strengthen high-probability bounds.\n"}]

Current notes.md:
Setting and goals.
- We study forward-only oracle access to a fixed function f:[n]→[n] with no loops (f(v)≠v). The algorithm issues two kinds of queries: Start (returns a uniformly random unseen vertex) and Step (for a previously seen u, reveal f(u)). A collision is found when we have distinct u≠u′ with f(u)=f(u′).
- In the forward-only model, a Step may land on a vertex selected earlier by Start but not yet reached by any walk; this is a “false merge” (not a collision). Also, a Step may land on a vertex that would have been selected by a future Start; this is a “skip,” which disrupts coupling to a pre-sampled Start order.
- Target theorem (informal): If RAC(collision,f)≤√n / log^α n (low-complexity regime), then the interleaved all-scales algorithm A_all finds a collision in O(log n)·RAC expected queries. We need (i) robust bounds that false merges and skips are rare up to O(√n/polylog n) queries, and (ii) a functions-version of the scale-coupling lemma (analogue of Claim 6.11) plus an epoch assembly argument.

Key probabilistic tool: permutation coupling of starts.
- Fix an epoch (a time window) in which the algorithm performs S Start operations and F Step operations (S,F arbitrary, adaptive, but finite). Expose a uniform random permutation π of [n]. Implement the Start oracle by always returning the unseen vertex of smallest π-rank. This realizes the uniform new-start oracle and implies that, conditioning on the set I_t of images revealed by steps before time t, the set of started vertices S_t is uniform among all s_t-subsets of W_t:=[n]\I_t, where s_t is the number of starts before t.
- For a step at time t with target y:=f(u_t), the conditional probability that y is in the previously-started set is s_t/|W_t| if y∉I_t (and 0 if y∈I_t). Similarly, the conditional probability that y equals one of the vertices that would be selected by future Starts within the epoch is (S−s_t)/|W_t| if y∉I_t (and 0 otherwise). Since |W_t|≥n−F for all t, these yield simple, uniform bounds.

Consequences (rigorous; curated into output.md):
- Expected number of false merges in the epoch ≤ F·S/(n−F); hence Pr[at least one false merge] ≤ F·S/(n−F).
- Expected number of skip events in the epoch ≤ F·S/(n−F); hence Pr[SKIP] ≤ F·S/(n−F).
- In particular, for an epoch of ≤2q total queries, with S,F≤2q and q≤n/4, both probabilities are O(q^2/n). This is uniform over f and any adaptive strategy.

Caveats and corrections to prior reports.
- The union-bound attempt that upper-bounds Pr[v_j=f(u_t)] by 1/(n−j+1) is incorrect, because the unseen pool at the j-th start can be substantially smaller than n−j+1 after many steps, making the true probability larger. The permutation-coupling analysis above addresses this correctly.
- Skips are not the same as false merges. A skip occurs when a step lands on a vertex slated to be chosen by a future Start; false merges require landing on a previously started vertex that has not yet been reached by any walk. Both are rare, but they are distinct events and must be bounded separately (both bounds follow from the same coupling).
- “Cycle closure always gives an immediate collision” needs a qualification: stepping into the very first start vertex v_0 does not automatically produce two distinct known preimages of v_0. The analysis should not rely on this shortcut.

What remains to prove for the main theorem.
- Older-first tie-breaking w.l.o.g.: State and prove a lemma that among algorithms that differ only by how they choose between isomorphic active walks, choosing the oldest cannot increase the number of queries to the first collision. Use the permutation-coupling to justify exchangeability of unseen start vertices.
- Functions-version of the single-scale coupling (analogue of Claim 6.11): Under the joint event {no false merges}∧{no skips}, and conditioning on the first collision occurring along W_j at distance L∈[2^i,2^{i+1}), show that the single-scale process at scale i finds the same collision within a constant-factor (e.g., ≤4×) number of forward steps relative to A’s cost up to the collision. Provide a precise amortization argument that charges A_i’s work to A’s work, carefully accounting for walks that terminate early (due to merging into already-reached vertices or cycle closure).
- Epoch assembly: With Markov (Pr[T_A*≤2q*]≥1/2) and the O(q^2/n) bounds above, a single 8q*-round epoch of A_all succeeds with probability ≥1/2−O(q*^2/n); in the regime q*≤√n/log^α n, this is a positive constant. Then a geometric bound yields E[Queries_A_all]=O(q* log n).

Pointers for future rounds.
- Write the older-first lemma and the single-scale coupling with full filtrations and stopping times. Consider a potential equal to the total “budgeted” remaining steps at scale i, and show it decreases at each step of A while A_i lags by at most a constant factor.
- If tighter constants are desired, upgrade the Markov control of the no-false-merge/no-skip counts to a Freedman/Bernstein tail bound (increments ≤1, predictable quadratic variation ≈ E[count]).
New structural invariants and the single-scale comparison (functions, forward-only)

Definitions and events.
- For a run, let I_t be the set of images revealed by Steps strictly before the t-th Step; let S_t be the set of vertices returned by Starts strictly before the t-th Step; and let W_t := [n] \ I_t.
- A false merge at Step t means y_t := f(u_t) ∈ S_t \ I_t. A skip at t means y_t ∈ W_t lies among vertices that would be chosen by future Starts within the epoch (relative to the pre-sampled start order).
- Older-first tie-break: whenever the algorithm chooses to extend a walk and there are at least two eligible walks of the same current length, it extends the one with smallest start index (the “oldest”).

Basic structural lemma (proved and curated as Lemma 4 in output.md).
- Under the event “no false merges up to T Steps”, before the first collision, any Step landing on a previously seen vertex would necessarily be a false merge, hence cannot occur; therefore the active walks are disjoint simple forward paths. Conversely, when a Step does land in the previously Step-seen set I_t, this is a true collision witness.

Age-monotone invariant under older-first (proved and curated as Lemma 5).
- If ties are resolved older-first, then at every time before the first collision, the vector of lengths (by start index) is nonincreasing. In particular, when the j-th walk reaches length L, every earlier walk has length at least L.

Single-scale process and domination (proved and curated as Lemma 6; step-count form).
- Define the single-scale process A_i: it uses the (pre-sampled) start order r, processes starts in increasing index, and for each started walk advances it forward up to 2^i steps (or stops earlier if a collision is detected), then proceeds to the next start.
- Conditioning on (i) no false merges and no skips for both the competitor A and A_i up to the relevant horizon, and (ii) the first collision of A occurring on W_j at length L ∈ [2^i, 2^{i+1}), the process A_i (with the same start order) finds a collision within at most 2·(#Steps used by A up to its first collision) steps. The proof is a direct charge: by age-monotonicity, A already invested ≥ 2^i steps into each older walk (j′ < j), and invested L steps into W_j; so (j−1)·2^i + L ≤ (#Steps of A). Since A_i spends at most (j−1)·2^i on older walks and at most 2^{i+1}−1 ≤ 2L on W_j, it succeeds within ≤ 2·(#Steps of A).

On symmetrization.
- Correct form: for any algorithm A, let A_sym be the algorithm that samples a uniform permutation σ and simulates A on the relabeled instance, undoing σ in queries/answers. Then for any f and horizon T,
  E[T_hit∧T(A_sym on f)] = E_σ[E[T_hit∧T(A on σ∘f∘σ^{−1})]].
  In particular, since RAC(collision, σ∘f∘σ^{−1}) = RAC(collision, f) for all σ, the infimum over all algorithms equals the infimum over label-invariant algorithms. The stronger claim “E[T(A_sym on f)] = E[T(A on f)]” need not hold and should not be used.

Caveat on wrappers.
- A proposed “pacing wrapper” that inserts extra steps to enforce older-first is not implementable without changing A’s subsequent choices (the transcript changes). We treat older-first either as an a priori restriction (justified w.l.o.g. after a correct Lemma D) or we do pathwise accounting without wrappers.

What remains.
- Formalize the older-first w.l.o.g. lemma (ties are exchangeable under label-invariance; older-first does not increase expected time to first collision). Provide a filtration-based proof.
- Integrate Lemma 6 into the epoch assembly, tracking starts as well as steps, and make the per-epoch constant probability explicit (α ≥ 1 suffices with a simple union bound; tighter martingale tails can reduce α).


Current output.md (if any):
Proved statements so far
- Lemma 1 (False merges are rare via permutation coupling). In any forward-only epoch with S starts and F steps, the expected number of false merges is at most F·S/(n−F), and hence Pr[at least one false merge] ≤ F·S/(n−F).
- Lemma 2 (Skips are also rare via permutation coupling). In the same epoch, the expected number of skip events is at most F·S/(n−F), and hence Pr[SKIP] ≤ F·S/(n−F).
- Corollary 3 (Uniform O(q^2/n) bound in 2q-query epochs). In any epoch with at most 2q total queries (so S,F≤2q) and q≤n/4, both Pr[at least one false merge] and Pr[SKIP] are O(q^2/n), more precisely ≤ 4q^2/(n−2q).

Proofs

Preliminaries and setup. Fix n≥1 and a function f:[n]→[n]. Consider an arbitrary (possibly adaptive) algorithm that issues two types of oracle interactions:
- Start: return a uniformly random vertex from the set of unseen vertices; here "unseen" means not yet returned by any Start and not yet revealed as the image of any Step.
- Step(u): for a previously seen vertex u, reveal y=f(u); now y becomes seen (if it was not already).
Fix an arbitrary epoch (time window) during which exactly S Start operations and F Step operations occur (S,F finite; they may be adapted to the history). Write the Step times as t=1,2,…,F in their chronological order within the epoch. Let I_t denote the set of images revealed by Steps strictly before the t-th Step, and let s_t be the number of Starts that occurred strictly before the t-th Step. Let W_t:=[n]\I_t be the set of vertices that have not yet been revealed as images before Step t.

We use the standard permutation coupling for the Start oracle: sample a uniform random permutation π of [n] at the beginning. At each Start, return the unseen vertex with smallest π-rank. This realizes exactly the uniform new-start rule and yields the following fact.

Fact (Uniform-subset view). Conditional on the history up to just before Step t, in particular on I_t, the set S_t of vertices returned by the s_t Starts so far is distributed as the set of the s_t smallest-π elements of W_t. Equivalently, S_t is uniform among all s_t-subsets of W_t.

Lemma 1 (False merges are rare).
Definition. A false merge at Step t occurs iff the revealed image y_t:=f(u_t) satisfies y_t∉I_t and y_t∈S_t (i.e., it is a newly revealed image that coincides with a previously started vertex).
Claim. E[#false merges in the epoch] ≤ F·S/(n−F). In particular, Pr[at least one false merge] ≤ F·S/(n−F).
Proof. Fix t. Conditional on the history up to Step t, either y_t∈I_t (then the indicator for a false merge at t is 0) or y_t∉I_t (then y_t∈W_t). By the Uniform-subset view, Pr[y_t∈S_t | history] = s_t/|W_t|. Since |W_t| ≥ n−F for all t (at most F images can be revealed in the entire epoch), we have
  Pr[false merge at t | history] ≤ s_t/(n−F).
Taking expectations and summing over t=1,…,F gives
  E[#false merges] ≤ ∑_{t=1}^F E[s_t/(n−F)] ≤ (1/(n−F)) ∑_{t=1}^F E[s_t] ≤ F·S/(n−F),
because s_t ≤ S for all t. Finally, Pr[#false merges ≥ 1] ≤ E[#false merges]. This bound holds uniformly over f and over the algorithm’s adaptivity.

Lemma 2 (Skips are rare).
Definition. Let r_1,r_2,… be the (random) Start sequence defined by the π-coupling: within the epoch, the j-th Start returns r_j. A skip event occurs at Step t if y_t:=f(u_t) satisfies y_t∉I_t and y_t equals one of the vertices that would be returned by a future Start within the epoch, i.e., y_t ∈ R_t where R_t is the set of the next S−s_t smallest-π elements of W_t.
Claim. E[#skip events in the epoch] ≤ F·S/(n−F). In particular, Pr[SKIP] ≤ F·S/(n−F).
Proof. Fix t. Conditional on the history up to Step t, if y_t∈I_t the indicator is 0. Otherwise y_t∈W_t. By symmetry of π, the probability that a fixed y_t lies among the next S−s_t smallest-π elements of W_t equals (S−s_t)/|W_t|. Hence
  Pr[skip at t | history] = (S−s_t)/|W_t| ≤ (S−s_t)/(n−F) ≤ S/(n−F).
Taking expectations and summing over t yields
  E[#skips] ≤ ∑_{t=1}^F E[(S−s_t)/(n−F)] = (1/(n−F)) ∑_{t=1}^F (S−E[s_t]) ≤ F·S/(n−F).
Finally, Pr[SKIP] ≤ E[#skips]. This bound is uniform over f and adaptive choices.

Corollary 3 (Bounds for 2q-query epochs).
Suppose an epoch performs at most 2q total queries, so S,F≤2q, and assume q≤n/4 (so n−2q≥n/2>0). Then Lemmas 1 and 2 give
  Pr[at least one false merge] ≤ 4q^2/(n−2q) ≤ 8q^2/n,
  Pr[SKIP] ≤ 4q^2/(n−2q) ≤ 8q^2/n.
Thus, in the low-complexity regime q≪√n, both events occur with vanishing probability O(q^2/n).

Remarks.
- These bounds require no assumptions on f beyond being a function; they are robust to algorithmic adaptivity and hold for any fixed f.
- The same permutation-coupling framework can be used to obtain martingale concentration (e.g., via Freedman) for the counts of false merges and skips if tighter tails are needed; the above expectation/Markov bounds suffice for the intended √n/polylog n regime.
Additional proved statements
- Lemma 4 (No-false-merge implies pre-collision disjointness and true-collision detection). Fix any run and any horizon T (counting Step queries). If no false merges occur among the first T Steps, then up to (and excluding) the first collision time: (i) no Step lands on any previously seen vertex; consequently, the active walks are disjoint forward paths; and (ii) whenever a Step does land on a previously seen vertex, that vertex lies in the Step-seen set I_t and this event witnesses a true collision.
- Lemma 5 (Age-monotone length invariant under older-first ties). Consider any run up to the first collision. If ties among equal-length eligible walks are always broken in favor of the smallest start index, then at every time the vector of walk lengths (indexed by start order) is nonincreasing: ℓ_1(t) ≥ ℓ_2(t) ≥ ⋯.
- Lemma 6 (Single-scale domination under older-first; step-count version). Fix a scale i and let A be any algorithm that resolves ties older-first. Let A_i be the single-scale process that uses the same pre-sampled start order r and, for each started walk, advances it forward up to 2^i steps (stopping earlier only upon detecting a collision) before moving to the next start. Suppose both A and A_i incur no skips and no false merges up to the relevant horizons. If the first collision of A occurs along the j-th started walk at length L ∈ [2^i, 2^{i+1}), and A uses t Step queries up to that moment, then A_i (on the same r) deterministically finds a collision within at most 2t Step queries.

Proofs

Lemma 4.
Let t be the first time a Step lands on a previously seen vertex v. If v ∈ S_t \ I_t, this is by definition a false merge, which is excluded. Hence v ∉ S_t \ I_t. Since v is previously seen, v ∈ S_t ∪ I_t, and thus v ∈ I_t. When v ∈ I_t there exists u′, stepped at some earlier time, with f(u′) = v; stepping at time t on some u ≠ u′ with f(u) = v therefore witnesses a collision. Before time t (or if such a time does not occur), no Step lands on any previously seen vertex, so every Step reveals a new image and all walk prefixes (including across different starts) are disjoint forward paths. ∎

Lemma 5.
We argue by induction on the number of Steps. Initially, all started walks have length 0 and the claim holds. Suppose just before a Step the lengths satisfy ℓ_1 ≥ ℓ_2 ≥ ⋯ for the already started walks. Let the Step increase ℓ_k by 1. If there exists j < k with ℓ_j = ℓ_k before the step, then by the older-first rule that Step would have been applied to the smallest such j instead of k, a contradiction. Therefore for all j < k we have ℓ_j ≥ ℓ_k + 1 before the step, and hence ℓ_j ≥ ℓ_k after the step. For j > k, increasing ℓ_k by 1 cannot violate ℓ_k ≥ ℓ_j. Starting a new walk appends a 0 at the end, which preserves nonincreasing order. Thus the invariant holds at all times up to the first collision. ∎

Lemma 6.
Let the first collision of A occur on the j-th started walk W_j when W_j attains length L ∈ [2^i, 2^{i+1}). Write t for the total number of Step queries A used up to that moment. Assume no skips and no false merges occur for either A or A_i up to the relevant horizons; then both processes share the same start order r and, by Lemma 4, before the first collision their active walks are disjoint forward paths.
By Lemma 5 (age-monotonicity), at the collision time we have ℓ_{j′} ≥ ℓ_j = L for every j′ < j. In particular, for each older start j′ < j, A has already invested at least 2^i steps on W_{j′}. Summing, A’s step-work on the set {1, …, j−1} is at least (j−1)·2^i, and its step-work on W_j is L. Therefore
  t ≥ (j−1)·2^i + L.
Consider A_i. By definition, A_i processes starts in order, and for each older start j′ < j it performs at most 2^i steps before moving on (or fewer if it detects a collision earlier). Hence A_i’s total step-work on {1, …, j−1} is at most (j−1)·2^i. For W_j, A_i needs at most 2^{i+1}−1 ≤ 2L steps to reach length L (at which point it encounters the same collision as A, or an earlier one). Thus the total number of steps A_i needs to find a collision is at most
  (j−1)·2^i + (2^{i+1}−1) ≤ (t − L) + 2L ≤ 2t.
This bound holds pathwise, given the shared start order r and the no-skip/no-false-merge conditions. ∎
