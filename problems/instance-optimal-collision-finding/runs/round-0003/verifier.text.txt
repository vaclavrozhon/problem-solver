{"feedback_md":"High-level assessment. Both reports push on the two key missing reductions: (i) a correct symmetrization/label-invariance reduction, and (ii) an older-first tie-breaking reduction. The symmetrization lemma (averaged over conjugacy) is sound and should be curated. The proposed “older-first w.l.o.g.” claims, however, are not yet rigorous; Prover 02’s equality-in-expectation statement is particularly suspect. I also found a concrete flaw in the currently curated Lemma 6: the single-scale A_i was defined to cap each walk at 2^i steps, but the proof subsequently allows up to 2^{i+1}−1 steps on W_j, exceeding the cap. This inconsistency must be fixed or the lemma removed. I recommend removing Lemma 6 from output.md for now and reintroducing a corrected version once the single-scale schedule and proof are fully consistent.\n\nOn Prover 02’s “tie-breaking invariance” (Lemma D). The idea—average over conjugacy, argue exchangeability at ties, and conclude that tie-breaking does not affect the expected time—is not proved. Equal one-step hazards at a tie do not imply equality of entire hitting-time distributions, because different tie-breaking choices change the evolution of lengths and thus future hazards. The sketch appeals to measure-preserving maps on the conjugacy σ, adaptively composed at successive ties. Making these maps well-defined and measure-preserving while conditioning on the unlabeled filtration and the evolving set of revealed labels is delicate; ties at later times involve endpoints whose labels have been partially constrained by earlier reveals, and the “disjointness” used at one tie need not persist across ties. This argument needs a formal inductive construction of such maps with explicit sigma-algebra bookkeeping. Until then, the equality claim should not be curated.\n\nOn Prover 01’s route via a capped-sum potential (Sub-lemma S). This looks promising: show that, at each tie with common length L<2^i, choosing the older index does not decrease the capped potential Φ_i(t)=∑_j min{ℓ_j(t),2^i}, and that iterating local exchanges yields Φ_i^{old}(t) ≥ Φ_i^A(t) pathwise for all t. That kind of exchange/majorization argument is standard and seems provable. However, by itself it does not yet imply that older-first has smaller or equal expected time to collision. A second ingredient is needed to connect larger Φ_i to a provable advantage in time-to-collision. One standard way is the BGN-style amortization: for the specific scale i of A’s collision, a “single-scale” schedule should force success in O(t) steps, where t is A’s work up to its collision. But this brings us to the inconsistency in Lemma 6.\n\nOn single-scale domination (Lemma 6). As curated, A_i caps each walk at 2^i steps, yet the proof allocates up to 2^{i+1}−1 steps on W_j. This cannot be correct as stated. A plausible fix is to redesign the single-scale comparator to allow a controlled second “half-cap” on exactly one walk (or to use a two-phase schedule that does not re-advance older walks in the second phase). Any such redesign must be specified in advance (not depending on the run of A) and proved to detect a collision within ≤ C·t steps under the no-skip/no-false-merge conditions. Without this correction the lemma should not remain in output.md.\n\nOn tails and parameters. The Freedman tail bound for skip/false-merge counts is fine and can be curated; it is a clean by-product of the permutation coupling with bounded increments and predictable variance V≤F·S/(n−F). However, it does not materially improve the exponent in the regime q≲√n/polylog n; the main asymptotic threshold for a per-epoch constant success probability, after union bounding across O(log n) scales, is α>1/2 already with our expectation-level bounds. Prover 01’s “α>1/2” check is correct; Prover 02’s “α≥1” is conservative but not tight.\n\nAction items and next steps.\n- Remove Lemma 6 from output.md for now; reinsert a corrected “single-scale comparator” lemma once the schedule is coherently defined (e.g., a two-phase, label-invariant schedule that avoids re-expanding older walks in phase 2) and the proof is complete.\n- Curate the correct symmetrization lemma (averaged over conjugacy) into output.md; it is solid and needed for reducing to label-invariant competitors.\n- Prove Sub-lemma S rigorously. Define the tie stopping times τ_k, fix a scale i, and carry out an adjacent-transposition exchange that shows Φ_i is maximized by older-first. Articulate a clear partial order or majorization argument.\n- Decide on a precise older-first reduction: either (a) prove tie-breaking invariance under conjugacy (Prover 02’s route) with a fully formal, measure-preserving mapping across σ’s at each tie; or (b) prove that transforming any label-invariant base policy to older-first multiplies the expected query complexity by at most a universal constant, using the Φ_i domination plus a corrected single-scale lemma.\n- Once (older-first w.l.o.g. + corrected single-scale) are in place, finalize the epoch assembly using α>1/2 and provide explicit constants.\n\nPlease ensure all future statements that enter output.md come with complete proofs and consistent algorithm definitions (no implicit second pass unless it is part of the formal schedule).","new_notes_md":"Updates and corrections (critical).\n- Symmetrization. The correct, averaged symmetrization lemma is sound and should be used to restrict attention to label-invariant competitors in the unlabeled-certificate benchmark. We curate it below into output.md.\n- Older-first w.l.o.g. remains unproven. Two routes:\n  1) Exchangeability/invariance (Prover 02’s route): average over conjugacy and construct measure-preserving bijections on σ at tie times to show that tie-breaking does not change the (conjugacy-averaged) law of the hitting time. This requires a fully formal inductive construction over the stopping times of ties and careful conditioning on the unlabeled filtration. At present, the proof is incomplete and should not be curated.\n  2) Potential/majorization (Prover 01’s route): prove Sub-lemma S, showing that for each scale i the capped potential Φ_i(t):=∑_j min{ℓ_j(t),2^i} is maximized by older-first at all times prior to the first collision. Combine this with a corrected single-scale comparator lemma to obtain a constant-factor reduction from an arbitrary label-invariant tie-breaker to older-first. This appears tractable and is my recommended path.\n\n- Single-scale comparator (Lemma 6) inconsistency. As previously curated, A_i caps walks at 2^i steps but the proof allocates up to 2^{i+1}−1 steps on W_j, exceeding the cap. This is a genuine error. We remove Lemma 6 from output.md for now. A corrected version should: (i) define in advance a label-invariant schedule that (a) invests at most 2^i steps on each older walk, and (b) allows up to an additional 2^i steps on one designated walk without re-advancing older ones; and (ii) prove that, under older-first and no-skip/no-false-merge for both processes, this schedule detects a collision within ≤ C·t steps, where t is A’s Steps to its first collision and C is an absolute constant (ideally C=2). One concrete option: a two-phase schedule that in the second phase continues only the earliest index whose length reached 2^i in phase one; this avoids re-expanding older walks.\n\n- Tails and parameter regime. Using the per-scale bounds and a union bound over O(log n) scales, the per-epoch failure probability is O((q^2 log n)/n). Hence a constant success probability per epoch holds already for α>1/2 in q≤√n/log^α n. Freedman/Bernstein tails are available (curated below) and sharpen constants but do not change the α-threshold qualitatively in this regime.\n\nTechnical to-do list (next steps).\n1) Prove Sub-lemma S rigorously via an adjacent-transposition exchange or majorization: at any tie with equal lengths below 2^i, replacing a younger-choice step by an older-choice step does not decrease Φ_i, and iterating yields Φ_i^{old}(t) ≥ Φ_i^A(t) for all t.\n2) Specify and prove a corrected single-scale comparator lemma with a coherent schedule (as above), ensuring no hidden re-advancement of older walks.\n3) Choose and formalize one older-first reduction route (exchangeability equality or constant-factor domination). If pursuing exchangeability, define the filtration, tie stopping times, and measure-preserving maps on conjugacies explicitly, with a proof that the average hitting-time distribution is invariant under tie-breakers. If pursuing domination, quantify the constant factor.\n4) Once 1–3 are in place, finalize the epoch assembly with explicit constants and α>1/2.\n\nSanity checks and examples.\n- Counter-check against tie-breaking invariance: construct small instances (n≈10–20) with two or three concurrent walks where the future hazard materially depends on which tied endpoint is extended (after averaging over conjugacy this should vanish if Lemma D were true). If a counterexample persists under averaging, Lemma D must be weakened to a constant-factor claim.\n- Necessity of older-first for the 2× single-scale bound: the toy example where a policy always advances the youngest shows that (j−1)·2^i≈t can fail badly without older-first. This motivates Sub-lemma S and an explicit older-first reduction.\n","new_notes_append":"True","new_outputs_md":"Proved statements so far\n- Lemma 1 (False merges are rare via permutation coupling). In any forward-only epoch with S Starts and F Steps, the expected number of false merges is at most F·S/(n−F), and hence Pr[at least one false merge] ≤ F·S/(n−F).\n- Lemma 2 (Skips are also rare via permutation coupling). In the same epoch, the expected number of skip events is at most F·S/(n−F), and hence Pr[SKIP] ≤ F·S/(n−F).\n- Corollary 3 (Uniform O(q^2/n) bound in 2q-query epochs). In any epoch with at most 2q total queries (so S,F≤2q) and q≤n/4, both Pr[at least one false merge] and Pr[SKIP] are O(q^2/n), more precisely ≤ 4q^2/(n−2q).\n- Lemma 4 (No-false-merge implies pre-collision disjointness and true-collision detection). Fix any run and any horizon T (counting Step queries). If no false merges occur among the first T Steps, then up to (and excluding) the first collision time: (i) no Step lands on any previously seen vertex; consequently, the active walks are disjoint forward paths; and (ii) whenever a Step does land on a previously seen vertex, that vertex lies in the Step-seen set I_t and this event witnesses a true collision.\n- Lemma 5 (Age-monotone length invariant under older-first ties). Consider any run up to the first collision. If ties among equal-length eligible walks are always broken in favor of the smallest start index, then at every time the vector of walk lengths (indexed by start order) is nonincreasing: ℓ_1(t) ≥ ℓ_2(t) ≥ ⋯.\n- Proposition 6 (Averaged symmetrization to label-invariant competitors). For any randomized algorithm A and any fixed f:[n]→[n], define A_sym that samples a uniform σ∈S_n at time 0 and simulates A on σ∘f∘σ^{-1}, undoing σ in queries and answers. For any horizon T,\n  E[T_hit∧T (A_sym on f)] = E_σ [ E[T_hit∧T (A on σ∘f∘σ^{-1})] ].\n  Consequently, for any conjugacy-invariant benchmark (e.g., RAC(collision,f)), the infimum over all algorithms equals the infimum over label-invariant algorithms (those whose decision distributions depend only on the unlabeled state). In particular, there exists a sequence of label-invariant algorithms that attains RAC(collision,f) up to arbitrary ε>0.\n- Proposition 7 (Freedman tails for skip/false-merge counts). In an epoch with S Starts and F Steps, let X_false be the number of false merges and X_skip the number of skips. There is a filtration with bounded martingale differences such that, for any λ>0,\n  Pr[X_false − E X_false ≥ λ] ≤ exp(−λ^2 / (2(V + λ/3))) and Pr[X_skip − E X_skip ≥ λ] ≤ exp(−λ^2 / (2(V + λ/3))),\n  where V ≤ F·S/(n−F) is a deterministic bound on the predictable quadratic variation.\n\nProofs\n\nPreliminaries and setup. Fix n≥1 and a function f:[n]→[n]. Consider an arbitrary (possibly adaptive) algorithm that issues two types of oracle interactions:\n- Start: return a uniformly random vertex from the set of unseen vertices; here “unseen” means not yet returned by any Start and not yet revealed as the image of any Step.\n- Step(u): for a previously seen vertex u, reveal y=f(u); now y becomes seen (if it was not already).\nFix an arbitrary epoch (time window) during which exactly S Start operations and F Step operations occur (S,F finite; they may be adapted to the history). Write the Step times as t=1,2,…,F in their chronological order within the epoch. Let I_t denote the set of images revealed by Steps strictly before the t-th Step, and let s_t be the number of Starts that occurred strictly before the t-th Step. Let W_t:=[n]\\I_t be the set of vertices that have not yet been revealed as images before Step t.\nWe use the standard permutation coupling for the Start oracle: sample a uniform random permutation π of [n] at the beginning. At each Start, return the unseen vertex with smallest π-rank. This realizes exactly the uniform new-start rule and yields the following fact.\nFact (Uniform-subset view). Conditional on the history up to just before Step t, in particular on I_t, the set S_t of vertices returned by the s_t Starts so far is distributed as the set of the s_t smallest-π elements of W_t. Equivalently, S_t is uniform among all s_t-subsets of W_t.\n\nLemma 1 (False merges are rare).\nDefinition. A false merge at Step t occurs iff the revealed image y_t:=f(u_t) satisfies y_t∉I_t and y_t∈S_t (i.e., it is a newly revealed image that coincides with a previously started vertex).\nClaim. E[#false merges in the epoch] ≤ F·S/(n−F). In particular, Pr[at least one false merge] ≤ F·S/(n−F).\nProof. Fix t. Conditional on the history up to Step t, either y_t∈I_t (then the indicator for a false merge at t is 0) or y_t∉I_t (then y_t∈W_t). By the Uniform-subset view, Pr[y_t∈S_t | history] = s_t/|W_t|. Since |W_t| ≥ n−F for all t (at most F images can be revealed in the entire epoch), we have Pr[false merge at t | history] ≤ s_t/(n−F). Taking expectations and summing over t=1,…,F gives E[#false merges] ≤ (1/(n−F))∑_{t=1}^F E[s_t] ≤ F·S/(n−F) because s_t ≤ S. Finally, Pr[#false merges ≥ 1] ≤ E[#false merges]. This bound holds uniformly over f and over the algorithm’s adaptivity. ∎\n\nLemma 2 (Skips are rare).\nDefinition. Let r_1,r_2,… be the (random) Start sequence defined by the π-coupling: within the epoch, the j-th Start returns r_j. A skip event occurs at Step t if y_t:=f(u_t) satisfies y_t∉I_t and y_t equals one of the vertices that would be returned by a future Start within the epoch, i.e., y_t∈R_t where R_t is the set of the next S−s_t smallest-π elements of W_t.\nClaim. E[#skip events in the epoch] ≤ F·S/(n−F). In particular, Pr[SKIP] ≤ F·S/(n−F).\nProof. Fix t. Conditional on the history up to Step t, if y_t∈I_t the indicator is 0. Otherwise y_t∈W_t. By symmetry of π, the probability that a fixed y_t lies among the next S−s_t smallest-π elements of W_t equals (S−s_t)/|W_t|. Hence Pr[skip at t | history] = (S−s_t)/|W_t| ≤ (S−s_t)/(n−F) ≤ S/(n−F). Taking expectations and summing over t yields E[#skips] ≤ (1/(n−F))∑_{t=1}^F (S−E[s_t]) ≤ F·S/(n−F). Finally, Pr[SKIP] ≤ E[#skips]. This bound is uniform over f and adaptive choices. ∎\n\nCorollary 3 (Bounds for 2q-query epochs).\nSuppose an epoch performs at most 2q total queries, so S,F≤2q, and assume q≤n/4 (so n−2q≥n/2>0). Then Lemmas 1 and 2 give Pr[at least one false merge] ≤ 4q^2/(n−2q) ≤ 8q^2/n and Pr[SKIP] ≤ 4q^2/(n−2q) ≤ 8q^2/n. Thus, in the low-complexity regime q≪√n, both events occur with vanishing probability O(q^2/n). ∎\n\nLemma 4 (No-false-merge ⇒ pre-collision disjointness and true-collision detection).\nProof. Let t be the first time a Step lands on a previously seen vertex v. If v∈S_t\\I_t, this is by definition a false merge, which is excluded. Hence v∉S_t\\I_t. Since v is previously seen, v∈S_t∪I_t, and thus v∈I_t. When v∈I_t there exists u′, stepped at some earlier time, with f(u′)=v; stepping at time t on some u≠u′ with f(u)=v therefore witnesses a collision. Before time t (or if such a time does not occur), no Step lands on any previously seen vertex, so every Step reveals a new image and all walk prefixes (including across different starts) are disjoint forward paths. ∎\n\nLemma 5 (Age-monotone invariant under older-first).\nProof. We argue by induction on the number of Steps. Initially, all started walks have length 0 and the claim holds. Suppose just before a Step the lengths satisfy ℓ_1 ≥ ℓ_2 ≥ ⋯ for the already started walks. Let the Step increase ℓ_k by 1. If there exists j<k with ℓ_j=ℓ_k before the step, then by the older-first rule that Step would have been applied to the smallest such j instead of k, a contradiction. Therefore for all j<k we have ℓ_j ≥ ℓ_k+1 before the step, and hence ℓ_j ≥ ℓ_k after the step. For j>k, increasing ℓ_k by 1 cannot violate ℓ_k ≥ ℓ_j. Starting a new walk appends a 0 at the end, which preserves nonincreasing order. Thus the invariant holds at all times up to the first collision. ∎\n\nProposition 6 (Averaged symmetrization to label-invariant competitors).\nProof. By construction of A_sym, when run on f it samples σ uniformly and simulates A on σ∘f∘σ^{-1}, undoing σ on queries/answers. Therefore T_hit∧T(A_sym on f) has the same law as T_hit∧T(A on σ∘f∘σ^{-1}) under the product measure over σ and the internal randomness of A. Taking expectations yields the identity. For the benchmark consequence, note that RAC is invariant under conjugation: RAC(collision,σ∘f∘σ^{-1})=RAC(collision,f) for all σ. Averaging any algorithm A over σ yields a label-invariant algorithm A′ with E[T_hit(A′ on f)] = E_σ E[T_hit(A on σ∘f∘σ^{-1})]. Taking infima proves that the infimum over all algorithms equals the infimum over label-invariant ones, and there exists a sequence of label-invariant algorithms approaching RAC(collision,f). ∎\n\nProposition 7 (Freedman tails for skip/false-merge counts).\nProof. Reveal the process step by step and let F_t be the sigma-field just before Step t. For false merges, define ξ_t:=1{false merge at t}. Then E[ξ_t | F_t] = p_t with p_t ≤ s_t/|W_t| ≤ S/(n−F) (deterministically). Let D_t := ξ_t − p_t. Then (D_t) is a martingale difference sequence with |D_t| ≤ 1 and conditional variance Var(D_t | F_t) ≤ p_t(1−p_t) ≤ p_t. The predictable quadratic variation V := ∑_{t=1}^F Var(D_t | F_t) satisfies V ≤ ∑_{t=1}^F p_t ≤ F·S/(n−F). By Freedman’s inequality for martingales with bounded increments (|D_t|≤1), for any λ>0,\n  Pr[∑_{t=1}^F D_t ≥ λ] ≤ exp(−λ^2/(2(V+λ/3))).\nSince X_false = ∑ ξ_t = ∑ p_t + ∑ D_t, we have Pr[X_false − E X_false ≥ λ] ≤ exp(−λ^2/(2(V+λ/3))). The argument for X_skip is identical, using p_t = (S−s_t)/|W_t| ≤ S/(n−F). ∎\n\nRemarks.\n- Lemma 6 from the previous version (single-scale domination under older-first) has been removed due to a definition/proof inconsistency (the schedule capped each walk at 2^i steps but the proof implicitly allocated up to 2^{i+1}−1 steps on one walk). A corrected comparator lemma will be added once the schedule and proof are fully aligned.\n- The above results are uniform over f and algorithmic adaptivity. The permutation coupling also supports refined concentration with Freedman tails (Proposition 7), which can be used for tighter constants or simultaneous control across scales.\n","new_outputs_append":"False","verdict":"partial success"}