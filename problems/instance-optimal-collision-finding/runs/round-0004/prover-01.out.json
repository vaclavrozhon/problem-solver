{
  "progress_md": "Round 0004 \u2014 Forward-only, low-complexity: fixing the single-scale inconsistency via a two-scale coupling, and an implementable older-first pacing\n\nSummary of gaps in output.md and corrections\n- The previously curated single-scale domination (removed from output.md) had an inconsistency: A_i was capped at 2^i per walk but the proof allocated up to 2^{i+1} steps on the colliding walk. This was rightly removed. We now propose a corrected, forward-only comparator that uses two adjacent scales (i and i+1) to effect the needed \u201csecond half\u201d of work on the colliding walk. This avoids violating the cap while preserving the O(1) overhead.\n- The \u201colder-first w.l.o.g.\u201d claim remains uncurated. We do not need it in a strong form. Instead, we introduce an implementable pacing wrapper B that enforces an \u201colder-first up to 2^i\u201d discipline at most doubling the competitor\u2019s step count. We use B purely as an auxiliary algorithm in the analysis to charge A_all\u2019s (i,i+1)-work to the competitor\u2019s work. We do not change the benchmark RAC nor claim w.l.o.g. for A; B is constructed from A only for analysis and has its own (Las Vegas) execution.\n- Symmetrization (Proposition 6) and the skip/false-merge bounds (Lemmas 1\u20132 and Proposition 7) remain correct and are used as black boxes below.\n\nNew ideas and claims (to be curated next)\n\n1) Lemma OF (older-first pacing wrapper; forward-only; deterministic).\n- Statement. Fix an instance f:[n]\u2192[n], a (possibly adaptive) algorithm A (e.g., a certificate-aided competitor), a pre-sampled global start sequence r (uniform permutation coupling), and an integer i\u22650. Define a wrapper algorithm B=B[A,i] that executes only Start and Step operations on f and satisfies:\n  \u2022 For any horizon T, if A finds a collision within \u2264T total queries (Starts+Steps), then B finds a collision within \u22642T queries.\n  \u2022 Up to the first moment when any active walk reaches length 2^i (or a collision is found or the walk terminates sooner), B enforces the discipline: whenever A attempts to Step-extend a walk of current length <2^i while there exists an older active walk with current length <2^i, B instead extends such an older walk; immediately after, B performs A\u2019s intended Step. For Starts, B issues the same Start as A (which equals the next element of r under no-skip).\n- Proof sketch (checkable, deterministic). B simulates A step-by-step. If A\u2019s intended Step respects the \u201colder-first up to 2^i\u201d rule, B mirrors it; otherwise B first inserts one catch-up Step on an older active walk of current length <2^i, then performs A\u2019s intended Step. Each simulated A-Step triggers either one or two B-Steps; thus if A halts by T queries, B halts by \u22642T queries. B never erases information: by the time B completes the first T simulated A-Steps (interleaved with \u2264T catch-ups), it has revealed a superset of the Step images A revealed up to its collision time; any collision witnessed by A is still present for B. The enforced discipline guarantees that, before any walk reaches 2^i (or collision), all older walks are at least as long and thus reach min{2^i, termination} by the time the designated walk reaches 2^i.\n- Why useful here. It gives, for analysis purposes, a version of the competitor whose pre-2^i work on older walks is maximally \u201cfront-loaded\u201d, enabling a clean resource charging to scale i, at the cost of at most a factor-2 overhead in its total queries. We do not require B to be label-invariant and we do not claim it w.l.o.g.; we use it only to upper bound A_all\u2019s rounds.\n\n2) Lemma TS (two-scale forward-only coupling; resolves the 2^i-cap inconsistency).\n- Setup. Fix f, pre-sampled start sequence r, and a certificate-aided competitor A. Let q*:=RAC(collision,f). Let t be the number of Steps used by A up to its first collision in a particular run, and suppose the collision occurs along the j-th started walk W_j at length L\u2208[2^i,2^{i+1}). Consider the following \u201cgood\u201d events: (i) E_noFM(A,2t): A has no false merge within 2t queries; (ii) E_noSK(A,2t): no skip for A within 2t; (iii) E_noFM(A_i,2t) and E_noSK(A_i,2t): no false merges/skips for the single-scale processes A_i up to 2t queries; and similarly for A_{i+1} up to 2t queries. All processes share the same start sequence r.\n- Statement. Condition on all the \u201cgood\u201d events and on the realization that A\u2019s first collision occurs at scale i with length L\u2208[2^i,2^{i+1}). Then, running the two scales i and i+1 of A_all in parallel, a collision is deterministically found within at most 2t rounds. Consequently, the total number of queries incurred by A_all up to that time is O(log n)\u00b72t.\n- Proof (deterministic, conditioned on the good events).\n  \u2022 Replace A by its pacing wrapper B=B[A,i]. By Lemma OF, B finds a collision within \u22642t queries and, crucially, enforces that by the time W_j first reaches length 2^i, each older walk W_{j\u2032} with j\u2032<j has length at least min{2^i, termination}.\n  \u2022 Charge to scale i: To make the future collision visible, it suffices that for every j\u2032<j, the walk W_{j\u2032} is advanced to min{2^i, termination}. Under the enforced discipline, the total number of Steps B has invested on these older walks by the time W_j reaches 2^i is S_i \u2264 #Steps_B \u2264 2t.\n  \u2022 Charge to scale i+1: The colliding walk W_j must be extended by L (its length at A\u2019s collision time). Under the no-skip coupling, A_{i+1} will process W_j as the j-th start and can spend L Steps on it. This requires S_{i+1}:=L Steps (no cap violation because A_{i+1} allows up to 2^{i+1} steps per started walk).\n  \u2022 Detection mechanism across scales: A_all maintains a global set of Step-seen images I across scales. Conditioning on no false merges, any step that lands in I produces a true collision (Lemma 4). When A_{i+1} advances W_j to length L, one of its Steps lands on an image already revealed earlier by scale i (from some W_{j\u2032}, j\u2032<j), hence a collision is detected.\n  \u2022 Round bound: The two scales run in parallel, consuming one query per round per active scale. The number of rounds until both budgets finish is at most max{S_i,S_{i+1}} \u2264 max{2t, L} \u2264 2t. Hence A_all finds a collision within \u2264 2t rounds, using \u2264 2t\u00b7O(log n) queries.\n- Why useful here. This fixes the \u201cextra 2^i on W_j\u201d gap by delegating the second half of W_j\u2019s work to scale i+1, while the older-walk prework resides at scale i. The parallelism of A_all converts the sum of per-scale work into the maximum over the two scales, preserving the desired O(t) round bound.\n\n3) Epoch assembly with explicit parameters (forward-only, low complexity)\n- Setup. Let q*:=RAC(collision,f). Choose a certificate-aided A with E[Queries]\u2264q*. By Markov, Pr[T_A\u22642q*] \u2265 1/2.\n- Good events probabilities.\n  \u2022 For A over \u22642q* queries: by Lemmas 1\u20132 (or Proposition 7 for tails), Pr[E_noFM^c \u222a E_noSK^c] = O(q*^2/n).\n  \u2022 For A_i and A_{i+1} over \u22642\u00b7(2q*) queries each (we can round up the per-scale budget to 4q* to be safe): Pr[bad at a fixed scale] = O(q*^2/n). We only need the two scales (i and i+1) corresponding to A\u2019s collision, but a union bound over all O(log n) scales still gives O((q*^2 log n)/n).\n- Per-epoch success. In an epoch of R:=8q* rounds of A_all (each round uses O(log n) queries), intersect the events: (i) T_A \u2264 2q*; (ii) no skips/false-merges for A; (iii) no skips/false-merges for the relevant A_i and A_{i+1}. By Lemma TS, conditioned on these, A_all deterministically finds a collision within \u22642\u00b7(2q*) \u2264 4q* rounds, so certainly within R rounds. Thus the per-epoch success probability \u2265 1/2 \u2212 O((q*^2 log n)/n).\n- Expected queries. In the regime q* \u2264 \u221an / log^\u03b1 n with any fixed \u03b1 > 1/2, we have (q*^2 log n)/n \u2264 1/ log^{2\u03b1\u22121} n = o(1). Hence a single epoch succeeds with probability at least, say, 1/3 for large n. A geometric bound yields E[Queries(A_all on f)] \u2264 C\u00b7q*\u00b7log n for an absolute C.\n- Note on constants and \u03b1. Using Proposition 7 (Freedman tails) tightens constants but is not needed to reach \u03b1>1/2. The previous conservative \u03b1\u22651 threshold can be improved to \u03b1>1/2 as above.\n\nExamples and sanity checks\n- Single long branch: Suppose A\u2019s first collision is at depth L\u2208[2^i,2^{i+1}). Even if many older walks terminated early, S_i only decreases, and scale i+1\u2019s budget remains L. Parallel rounds \u2264 max{S_i,L} \u2264 2t, consistent with Lemma TS.\n- Edge case L\u22482^i. Then scale i\u2019s and i+1\u2019s budgets are both \u0398(2^i). Parallel execution completes in \u0398(2^i) rounds, again \u2264 2t by the pacing wrapper.\n\nWhy wrappers are acceptable here (addressing prior concern)\n- The pacing wrapper B is used only as an auxiliary comparator in the analysis; we do not claim it is w.l.o.g. nor that it preserves A\u2019s transcript. The key pathwise inequality is: if A halts by T Steps, then B halts by \u22642T, revealing a superset of A\u2019s Step images; hence any collision A witnesses appears in B\u2019s run no later than time 2T. This monotonicity is sufficient to upper bound the work that A_all must perform across the two scales to expose the same collision.\n\nWhat to curate next into output.md\n- Lemma OF (older-first pacing wrapper) with a clean, deterministic proof.\n- Lemma TS (two-scale forward-only coupling) with the precise conditioning described above and the parallel-rounds accounting, explicitly referencing Lemma 4 (no-false-merge \u21d2 true-collision on hitting I) and the no-skip coupling to the shared start sequence r.\n- Proposition (Epoch assembly). In the regime RAC \u2264 \u221an / log^\u03b1 n with \u03b1>1/2, A_all achieves E[Queries] \u2264 C log n\u00b7RAC. This will complete the targeted forward-only, low-complexity theorem.\n\nOptional but beneficial next steps\n- Provide a formal, local exchange lemma for the capped potential \u03a6_i(t)=\u2211_j min{\u2113_j(t),2^i}: at a tie among equal-length (<2^i) walks, incrementing the oldest weakly increases all prefix sums of \u03a6_i relative to incrementing a younger one; iterating tie corrections shows \u03a6_i is maximized by older-first at every time. While not needed given the wrapper approach, it provides a clean structural underpinning if we later aim to reduce to older-first without a wrapper.\n- Tighten tail bounds (via Proposition 7) to improve constants and potentially simplify the per-epoch round budget.\n\nChecklist of dependencies and consistency\n- Uses curated Lemmas 1\u20132 (and optionally 7) for skip/false-merge control.\n- Uses curated Lemma 4 for collision detection upon hitting a Step-seen image (no false merge).\n- Does not rely on the previously removed, inconsistent single-scale lemma.\n- Does not assume the stronger, unproven \u201ctie-breaking invariance under conjugacy.\u201d\n\nPotential pitfalls to watch when formalizing\n- Be explicit that the two-scale parallel argument counts rounds (max of per-scale budgets), not sum. This is crucial to preserve the O(t) round bound.\n- Ensure all no-skip/no-false-merge events are stated for the correct horizons: 2t for A, and 2t (or simply 4q*) for each of A_i and A_{i+1}.\n- Clarify that the global image set I is shared across scales within A_all; since only oracle queries count, these set operations are \u201cfree\u201d in the query model.\n\nBottom line\nWith Lemma OF and the two-scale Lemma TS, we resolve the single-scale cap inconsistency in the forward-only setting by leveraging adjacent scales. Together with the permutation-coupled bounds on skips and false merges and a standard epoch assembly, this yields the target Theorem (forward-only, low complexity) with \u03b1>1/2: E[Queries_{A_all}(f)] \u2264 C log n\u00b7RAC(collision,f). We recommend curating Lemma OF and Lemma TS next, followed by the final theorem statement and its proof."
}