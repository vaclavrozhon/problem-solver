{
  "progress_md": "Round 0004 \u2014 Corrected single-scale comparator (two-chunk schedule) and a majorization lemma blueprint\n\nSummary of status and gaps in output.md\n- As the verifier requested, the flawed single-scale Lemma 6 was removed from output.md. The probabilistic pillars (permutation coupling for false merges/skips, and Freedman tails) and the basic structural Lemmas 4\u20135 remain correct and useful.\n- Missing pieces to reach Theorem (forward-only, low complexity): (i) a correct single-scale comparator that is consistent with its schedule; (ii) a clean reduction to older-first (or a constant-factor domination) so that we can apply the comparator to a certificate-aided competitor.\n\nNew: a corrected single-scale comparator under older-first, forward-only\nWe define a fixed, label-invariant, forward-only single-scale process that is coherent with its proof. The key is a \u201ctwo-chunk per start\u201d schedule at scale i.\n\nDefinition (two-chunk single-scale process B_i).\n- Input: fixed scale i\u22650; a start string r=(r_1,r_2,\u2026) (the global Start-permutation);\n- For j=1,2,3,\u2026 do sequentially:\n  1) Stage A: Start at r_j (if not yet started) and extend W_j forward for up to 2^i Step queries, stopping early if a collision is detected (i.e., the Step lands in I_t) or if a false-merge would occur (the actual run will be conditioned on no-false-merge; otherwise the process just halts on the collision event if it happens). If a collision is found, halt and report success.\n  2) Stage B: If Stage A completed without collision, immediately continue W_j forward for up to an additional 2^i Steps (again, stopping as soon as a collision is found). If a collision is found, halt and report success; otherwise advance to j+1.\n- B_i uses only forward queries and the Start interface; it is label-invariant and pre-specified (no dependence on any competitor\u2019s transcript).\n\nLemma E\u2032 (Single-scale domination with two-chunk schedule; forward-only functions).\nAssume the following conditioning for some fixed horizon T (large enough for the bounds below):\n- No-skip for A up to T and for B_i up to 2T, with respect to the same start string r (so their j-th new starts are r_j);\n- No-false-merge up to the same horizons (so pre-collision walks are disjoint and any revisit to a Step-seen image is a true collision by Lemma 4);\n- A is label-invariant and resolves ties older-first; its first collision occurs along W_j at distance L\u2208[2^i,2^{i+1}). Let t denote the number of Step queries used by A up to (and including) that collision.\nThen B_i (with start order r) finds a collision deterministically after at most 2t forward Steps.\n\nProof (deterministic, pathwise under the conditioning).\n- Disjointness and identity of starts: No-skip aligns the j-th start across A and B_i (both use r_j). No-false-merge implies disjointness of walks before the first collision (Lemma 4), so the forward trajectory of each W_\u2113 in B_i matches the corresponding forward trajectory that A would reveal if it extended W_\u2113 (no interference from other walks before collision).\n- Age-monotone lengths in A: Under older-first (Lemma 5), at the moment A first reaches the collision on W_j at length L\u2208[2^i,2^{i+1}), every older walk W_{\u2113} with \u2113<j has length at least L\u22652^i (unless a collision had already occurred earlier, which is excluded by the definition of the first collision). Consequently, A\u2019s total Step work t satisfies\n  t \u2265 (j\u22121)\u00b72^i + L.\n- Work of B_i up to processing W_j:\n  \u2022 For each older \u2113<j, B_i spends at most 2\u00b72^i Steps: it executes Stage A (\u22642^i) and then Stage B (\u22642^i) on W_\u2113 unless a collision is found even earlier (which only helps). Hence B_i\u2019s cumulative work on older walks is \u2264 (j\u22121)\u00b72^{i+1} = 2\u00b7(j\u22121)\u00b72^i.\n  \u2022 On W_j, B_i spends at most 2^i Steps in Stage A to reach length 2^i. Since A\u2019s collision along W_j occurs at length L<2^{i+1}, B_i\u2019s Stage B requires at most an additional L\u22122^i Steps to reach the collision (because the disjointness guarantees B_i traces the same path of W_j as A, and the collision trigger is a revisit to a previously Step-seen image).\n  \u2022 Therefore B_i\u2019s total Steps until collision are bounded by\n    (j\u22121)\u00b72^{i+1} + 2^i + (L\u22122^i) = (j\u22121)\u00b72^{i+1} + L \u2264 2\u00b7((j\u22121)\u00b72^i + L) \u2264 2t.\n- Thus B_i detects a collision within at most 2t Steps. \u220e\n\nWhy this fixes the earlier inconsistency\n- The schedule now explicitly permits up to 2^i additional Steps on exactly one walk per start (Stage B); we do not claim a 2^i cap on every walk globally. The analysis charges B_i\u2019s older-walk work as at most twice A\u2019s \u201colder-walk budget\u201d ((j\u22121)\u00b72^i), and B_i\u2019s W_j work as at most twice A\u2019s work on W_j (L). Hence the 2\u00d7 factor holds deterministically.\n- The process is fixed and label-invariant, does not invoke any backtracking or knowledge of the competitor.\n\nConsequence for epoch assembly (assuming older-first competitor)\n- Let q\u22c6 = RAC(collision,f). Take A\u22c6 to be a certificate-aided algorithm with E[queries]\u2264 q\u22c6. By Markov, Pr[A\u22c6 finishes within 2q\u22c6 Steps]\u22651/2.\n- Using output.md\u2019s bounds, for any 2q\u22c6-query window, both Pr[skip] and Pr[false-merge] are O(q\u22c6^2/n) for A\u22c6, and likewise O(q\u22c6^2/n) for B_i over a 4q\u22c6 window. Unioning over O(log n) scales adds a factor of log n. Thus, in one epoch of length 8q\u22c6 rounds of A_all (O(q\u22c6 log n) queries), the probability all the needed \u201cgood events\u201d (no-skip/no-false-merge for A\u22c6 and B_i and A\u22c6 finishing within 2q\u22c6) hold is at least 1/2 \u2212 O((q\u22c6^2 log n)/n).\n- In the low-complexity regime q\u22c6 \u2264 \u221an / log^\u03b1 n, this is \u2265 1/2 \u2212 O(1/log^{2\u03b1\u22121} n). For any fixed \u03b1>1/2 and large n, a single epoch succeeds with constant probability (say \u22651/3), whence E[Queries(A_all)] = O(q\u22c6 log n).\n- Constants: the per-scale multiplicative overhead is 2 in Lemma E\u2032; across scales we pay an additional O(log n) interleaving factor.\n\nNew structural lemma toward removing the older-first assumption\nTo apply Lemma E\u2032 to an arbitrary label-invariant competitor, we need a principled tie-breaking reduction. I propose to use a majorization-style potential and prove it cleanly. Here is the precise claim and a proof blueprint; it can be curated next.\n\nLemma M (capped-sum majorization under older-first).\n- Fix a scale i and consider any (collision-free so far) run with disjoint walks W_1,W_2,\u2026 (ordered by start age) and their lengths vector \u2113(t) at time t. Define \u03a6_i(t) := \u2211_{j\u22651} min{\u2113_j(t), 2^i} (sum of lengths capped at 2^i, in age order).\n- Among all tie-breaking policies that, at a given state, are allowed to extend any walk among those with maximum eligible length, the older-first policy maximizes \u03a6_i(t) at all times t, pathwise. Formally, if at each tie (equal-length choice below the cap 2^i) we replace a younger choice by the older one, \u03a6_i never decreases; iterating adjacent exchanges until all ties are resolved older-first yields a process with \u03a6_i^{old}(t) \u2265 \u03a6_i(t) for all t.\nProof sketch (adjacent-transposition exchange):\n- Consider a single step at a state where the set U of eligible walks share the maximal current length L<2^i; pick any two adjacent indices a<b in U. Compare the effects on \u03a6_i of choosing a vs. choosing b. In either choice, \u03a6_i increases by exactly 1 at this step (since L<2^i). The difference arises in future steps: by choosing the older index a, we \u201cfront-load\u201d a capped unit to an earlier coordinate, which can only increase the partial sums \u2211_{j\u2264k} min{\u2113_j,2^i} for all k\u2265a, and never decrease them for k<a. Standard majorization/Hardy\u2013Littlewood\u2013P\u00f3lya exchange arguments show that a sequence of such local adjacent improvements cannot decrease \u03a6_i at any future time (the choices below the cap commute and only the order in which capped units hit earlier coordinates matters). Rigorous details will be written with an induction on the number of tie resolutions up to time t and on the number of adjacent transpositions needed to transform any tie-breaking path into the older-first one.\nWhy useful: For a fixed scale i corresponding to A\u2019s first collision (L\u2208[2^i,2^{i+1})), having a larger \u03a6_i at each prefix time implies that by the time A has accrued t Steps, the older-first process has at least as many fully-capped older walks (reaching 2^i) as any other tie-breaker, and at least as much progression on the current walk. This is precisely the resource that B_i consumes (two chunks per start), so older-first is the \u201chardest\u201d tie-breaker to dominate by B_i. This clears the way to apply Lemma E\u2032 to an arbitrary label-invariant A via a comparison to its older-first variant.\n\nPlan to close the older-first reduction rigorously\n- Symmetrization (already curated as Proposition 6): We may assume the competitor is label-invariant for the unlabeled certificate benchmark.\n- Tie-breaking reduction: Using Lemma M, for each fixed f and start string r, we can pathwise couple any tie-breaking to the older-first one so that for every t, \u03a6_i^{old}(t) \u2265 \u03a6_i(t) for all i. Since B_i\u2019s budget up to the index of A\u2019s first collision is an increasing function of \u03a6_i (by the two-chunk accounting), Lemma E\u2032 applied to the older-first variant yields the same or a better bound than for the original. I will write this formally next: define the stopping time of A\u2019s first collision; show that B_i\u2019s Steps until success are \u2264 2\u00b7t_old, and that t_old \u2264 C\u00b7t for a universal constant C (we aim for C=1 using only tie exchanges; if an equality-in-law proof at ties remains delicate, we can settle for a constant-factor relation via amortized arguments on the potentials).\n\nSanity checks and small examples\n- Adversarial tie-breaking (always extend youngest): our Lemma M predicts this policy minimizes \u03a6_i and thus makes it easiest for B_i to win relative to A\u2019s budget; older-first is the extremal hard case for the single-scale domination.\n- Cycle closure corner case: Under no-false-merge, the only cycle closure that is not a collision (hitting the initial start vertex) does not occur before the first collision; thus Stage A/B halts on a collision (consistent with Lemma 4).\n\nNext steps (concrete curation items)\n1) Curate Lemma E\u2032 (statement and proof) into output.md. It is fully formal and consistent with the defined schedule.\n2) Curate Lemma M with a complete adjacent-transposition proof. This will justify using older-first in the comparator without loss (or establish it as the hardest tie-breaker to dominate).\n3) Assemble the epoch bound: with Lemma E\u2032 and Proposition 6, conclude Theorem (forward-only, low complexity) in the regime q\u22c6 \u2264 \u221an / log^\u03b1 n for any \u03b1>1/2 (per-epoch failure O((q\u22c6^2 log n)/n)). Track constants (the single-scale factor is 2, interleaving adds O(log n)).\n4) Optional: add a short note that Freedman tails (already curated) can polish constants and allow simultaneous control over all scales within an epoch, but do not change the \u03b1-threshold qualitatively.\n\nPotential issues to watch\n- Ensure the no-skip event is applied to both A and B_i at the appropriate horizons (2q\u22c6 and 4q\u22c6 respectively) and that S,F parameters are set consistently in the permutation-coupling bounds.\n- When formalizing Lemma M, specify precisely the filtration and what constitutes a tie (common maximal eligible length below 2^i) and handle adjacent transpositions carefully to preserve the history and the no-false-merge condition.\n"
}