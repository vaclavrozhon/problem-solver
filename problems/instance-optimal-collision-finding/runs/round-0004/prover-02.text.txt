{"progress_md":"Round 0004 — Corrected single-scale comparator (two-chunk schedule) and a majorization lemma blueprint\n\nSummary of status and gaps in output.md\n- As the verifier requested, the flawed single-scale Lemma 6 was removed from output.md. The probabilistic pillars (permutation coupling for false merges/skips, and Freedman tails) and the basic structural Lemmas 4–5 remain correct and useful.\n- Missing pieces to reach Theorem (forward-only, low complexity): (i) a correct single-scale comparator that is consistent with its schedule; (ii) a clean reduction to older-first (or a constant-factor domination) so that we can apply the comparator to a certificate-aided competitor.\n\nNew: a corrected single-scale comparator under older-first, forward-only\nWe define a fixed, label-invariant, forward-only single-scale process that is coherent with its proof. The key is a “two-chunk per start” schedule at scale i.\n\nDefinition (two-chunk single-scale process B_i).\n- Input: fixed scale i≥0; a start string r=(r_1,r_2,…) (the global Start-permutation);\n- For j=1,2,3,… do sequentially:\n  1) Stage A: Start at r_j (if not yet started) and extend W_j forward for up to 2^i Step queries, stopping early if a collision is detected (i.e., the Step lands in I_t) or if a false-merge would occur (the actual run will be conditioned on no-false-merge; otherwise the process just halts on the collision event if it happens). If a collision is found, halt and report success.\n  2) Stage B: If Stage A completed without collision, immediately continue W_j forward for up to an additional 2^i Steps (again, stopping as soon as a collision is found). If a collision is found, halt and report success; otherwise advance to j+1.\n- B_i uses only forward queries and the Start interface; it is label-invariant and pre-specified (no dependence on any competitor’s transcript).\n\nLemma E′ (Single-scale domination with two-chunk schedule; forward-only functions).\nAssume the following conditioning for some fixed horizon T (large enough for the bounds below):\n- No-skip for A up to T and for B_i up to 2T, with respect to the same start string r (so their j-th new starts are r_j);\n- No-false-merge up to the same horizons (so pre-collision walks are disjoint and any revisit to a Step-seen image is a true collision by Lemma 4);\n- A is label-invariant and resolves ties older-first; its first collision occurs along W_j at distance L∈[2^i,2^{i+1}). Let t denote the number of Step queries used by A up to (and including) that collision.\nThen B_i (with start order r) finds a collision deterministically after at most 2t forward Steps.\n\nProof (deterministic, pathwise under the conditioning).\n- Disjointness and identity of starts: No-skip aligns the j-th start across A and B_i (both use r_j). No-false-merge implies disjointness of walks before the first collision (Lemma 4), so the forward trajectory of each W_ℓ in B_i matches the corresponding forward trajectory that A would reveal if it extended W_ℓ (no interference from other walks before collision).\n- Age-monotone lengths in A: Under older-first (Lemma 5), at the moment A first reaches the collision on W_j at length L∈[2^i,2^{i+1}), every older walk W_{ℓ} with ℓ<j has length at least L≥2^i (unless a collision had already occurred earlier, which is excluded by the definition of the first collision). Consequently, A’s total Step work t satisfies\n  t ≥ (j−1)·2^i + L.\n- Work of B_i up to processing W_j:\n  • For each older ℓ<j, B_i spends at most 2·2^i Steps: it executes Stage A (≤2^i) and then Stage B (≤2^i) on W_ℓ unless a collision is found even earlier (which only helps). Hence B_i’s cumulative work on older walks is ≤ (j−1)·2^{i+1} = 2·(j−1)·2^i.\n  • On W_j, B_i spends at most 2^i Steps in Stage A to reach length 2^i. Since A’s collision along W_j occurs at length L<2^{i+1}, B_i’s Stage B requires at most an additional L−2^i Steps to reach the collision (because the disjointness guarantees B_i traces the same path of W_j as A, and the collision trigger is a revisit to a previously Step-seen image).\n  • Therefore B_i’s total Steps until collision are bounded by\n    (j−1)·2^{i+1} + 2^i + (L−2^i) = (j−1)·2^{i+1} + L ≤ 2·((j−1)·2^i + L) ≤ 2t.\n- Thus B_i detects a collision within at most 2t Steps. ∎\n\nWhy this fixes the earlier inconsistency\n- The schedule now explicitly permits up to 2^i additional Steps on exactly one walk per start (Stage B); we do not claim a 2^i cap on every walk globally. The analysis charges B_i’s older-walk work as at most twice A’s “older-walk budget” ((j−1)·2^i), and B_i’s W_j work as at most twice A’s work on W_j (L). Hence the 2× factor holds deterministically.\n- The process is fixed and label-invariant, does not invoke any backtracking or knowledge of the competitor.\n\nConsequence for epoch assembly (assuming older-first competitor)\n- Let q⋆ = RAC(collision,f). Take A⋆ to be a certificate-aided algorithm with E[queries]≤ q⋆. By Markov, Pr[A⋆ finishes within 2q⋆ Steps]≥1/2.\n- Using output.md’s bounds, for any 2q⋆-query window, both Pr[skip] and Pr[false-merge] are O(q⋆^2/n) for A⋆, and likewise O(q⋆^2/n) for B_i over a 4q⋆ window. Unioning over O(log n) scales adds a factor of log n. Thus, in one epoch of length 8q⋆ rounds of A_all (O(q⋆ log n) queries), the probability all the needed “good events” (no-skip/no-false-merge for A⋆ and B_i and A⋆ finishing within 2q⋆) hold is at least 1/2 − O((q⋆^2 log n)/n).\n- In the low-complexity regime q⋆ ≤ √n / log^α n, this is ≥ 1/2 − O(1/log^{2α−1} n). For any fixed α>1/2 and large n, a single epoch succeeds with constant probability (say ≥1/3), whence E[Queries(A_all)] = O(q⋆ log n).\n- Constants: the per-scale multiplicative overhead is 2 in Lemma E′; across scales we pay an additional O(log n) interleaving factor.\n\nNew structural lemma toward removing the older-first assumption\nTo apply Lemma E′ to an arbitrary label-invariant competitor, we need a principled tie-breaking reduction. I propose to use a majorization-style potential and prove it cleanly. Here is the precise claim and a proof blueprint; it can be curated next.\n\nLemma M (capped-sum majorization under older-first).\n- Fix a scale i and consider any (collision-free so far) run with disjoint walks W_1,W_2,… (ordered by start age) and their lengths vector ℓ(t) at time t. Define Φ_i(t) := ∑_{j≥1} min{ℓ_j(t), 2^i} (sum of lengths capped at 2^i, in age order).\n- Among all tie-breaking policies that, at a given state, are allowed to extend any walk among those with maximum eligible length, the older-first policy maximizes Φ_i(t) at all times t, pathwise. Formally, if at each tie (equal-length choice below the cap 2^i) we replace a younger choice by the older one, Φ_i never decreases; iterating adjacent exchanges until all ties are resolved older-first yields a process with Φ_i^{old}(t) ≥ Φ_i(t) for all t.\nProof sketch (adjacent-transposition exchange):\n- Consider a single step at a state where the set U of eligible walks share the maximal current length L<2^i; pick any two adjacent indices a<b in U. Compare the effects on Φ_i of choosing a vs. choosing b. In either choice, Φ_i increases by exactly 1 at this step (since L<2^i). The difference arises in future steps: by choosing the older index a, we “front-load” a capped unit to an earlier coordinate, which can only increase the partial sums ∑_{j≤k} min{ℓ_j,2^i} for all k≥a, and never decrease them for k<a. Standard majorization/Hardy–Littlewood–Pólya exchange arguments show that a sequence of such local adjacent improvements cannot decrease Φ_i at any future time (the choices below the cap commute and only the order in which capped units hit earlier coordinates matters). Rigorous details will be written with an induction on the number of tie resolutions up to time t and on the number of adjacent transpositions needed to transform any tie-breaking path into the older-first one.\nWhy useful: For a fixed scale i corresponding to A’s first collision (L∈[2^i,2^{i+1})), having a larger Φ_i at each prefix time implies that by the time A has accrued t Steps, the older-first process has at least as many fully-capped older walks (reaching 2^i) as any other tie-breaker, and at least as much progression on the current walk. This is precisely the resource that B_i consumes (two chunks per start), so older-first is the “hardest” tie-breaker to dominate by B_i. This clears the way to apply Lemma E′ to an arbitrary label-invariant A via a comparison to its older-first variant.\n\nPlan to close the older-first reduction rigorously\n- Symmetrization (already curated as Proposition 6): We may assume the competitor is label-invariant for the unlabeled certificate benchmark.\n- Tie-breaking reduction: Using Lemma M, for each fixed f and start string r, we can pathwise couple any tie-breaking to the older-first one so that for every t, Φ_i^{old}(t) ≥ Φ_i(t) for all i. Since B_i’s budget up to the index of A’s first collision is an increasing function of Φ_i (by the two-chunk accounting), Lemma E′ applied to the older-first variant yields the same or a better bound than for the original. I will write this formally next: define the stopping time of A’s first collision; show that B_i’s Steps until success are ≤ 2·t_old, and that t_old ≤ C·t for a universal constant C (we aim for C=1 using only tie exchanges; if an equality-in-law proof at ties remains delicate, we can settle for a constant-factor relation via amortized arguments on the potentials).\n\nSanity checks and small examples\n- Adversarial tie-breaking (always extend youngest): our Lemma M predicts this policy minimizes Φ_i and thus makes it easiest for B_i to win relative to A’s budget; older-first is the extremal hard case for the single-scale domination.\n- Cycle closure corner case: Under no-false-merge, the only cycle closure that is not a collision (hitting the initial start vertex) does not occur before the first collision; thus Stage A/B halts on a collision (consistent with Lemma 4).\n\nNext steps (concrete curation items)\n1) Curate Lemma E′ (statement and proof) into output.md. It is fully formal and consistent with the defined schedule.\n2) Curate Lemma M with a complete adjacent-transposition proof. This will justify using older-first in the comparator without loss (or establish it as the hardest tie-breaker to dominate).\n3) Assemble the epoch bound: with Lemma E′ and Proposition 6, conclude Theorem (forward-only, low complexity) in the regime q⋆ ≤ √n / log^α n for any α>1/2 (per-epoch failure O((q⋆^2 log n)/n)). Track constants (the single-scale factor is 2, interleaving adds O(log n)).\n4) Optional: add a short note that Freedman tails (already curated) can polish constants and allow simultaneous control over all scales within an epoch, but do not change the α-threshold qualitatively.\n\nPotential issues to watch\n- Ensure the no-skip event is applied to both A and B_i at the appropriate horizons (2q⋆ and 4q⋆ respectively) and that S,F parameters are set consistently in the permutation-coupling bounds.\n- When formalizing Lemma M, specify precisely the filtration and what constitutes a tie (common maximal eligible length below 2^i) and handle adjacent transpositions carefully to preserve the history and the no-false-merge condition.\n"}