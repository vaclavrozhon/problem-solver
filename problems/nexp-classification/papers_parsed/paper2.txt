1) Problem in one sentence

Given a Î²-normalized, radius-1 LCL on globally oriented paths with binary inputs, decide whether its LOCAL complexity is 
ğ‘‚
(
1
)
O(1), 
Î˜
(
log
â¡
âˆ—
ğ‘›
)
Î˜(log
âˆ—
n), or 
Î˜
(
ğ‘›
)
Î˜(n)â€”and do so in NEXPTIME in the encoding size 
ğ‘
=
p
o
l
y
(
ğ›½
)
N=poly(Î²).

2) Model and encoding (why this representation is nice)

Input alphabet: 
Î£
i
n
=
{
0
,
1
}
Î£
in
	â€‹

={0,1}.

Output alphabet: 
Î£
o
u
t
Î£
out
	â€‹

 with 
âˆ£
Î£
o
u
t
âˆ£
=
ğ›½
âˆ£Î£
out
	â€‹

âˆ£=Î².

Local legality (radius 1): Two tables encode all constraints:

ğ¶
i
n
â€“
o
u
t
âŠ†
{
0
,
1
}
Ã—
Î£
o
u
t
C
inâ€“out
	â€‹

âŠ†{0,1}Ã—Î£
out
	â€‹

: for each node 
ğ‘£
v, 
(
i
n
(
ğ‘£
)
,
o
u
t
(
ğ‘£
)
)
âˆˆ
ğ¶
i
n
â€“
o
u
t
(in(v),out(v))âˆˆC
inâ€“out
	â€‹

.

ğ¶
o
u
t
â€“
o
u
t
âŠ†
Î£
o
u
t
Ã—
Î£
o
u
t
C
outâ€“out
	â€‹

âŠ†Î£
out
	â€‹

Ã—Î£
out
	â€‹

: for each directed edge 
ğ‘¢
â€‰â£
â†’
â€‰â£
ğ‘£
uâ†’v, 
(
o
u
t
(
ğ‘¢
)
,
o
u
t
(
ğ‘£
)
)
âˆˆ
ğ¶
o
u
t
â€“
o
u
t
(out(u),out(v))âˆˆC
outâ€“out
	â€‹

.

Encoding size: 
p
o
l
y
(
ğ›½
)
poly(Î²) (think Boolean 
2
Ã—
ğ›½
2Ã—Î² and 
ğ›½
Ã—
ğ›½
Î²Ã—Î² tables). We measure time in 
ğ‘
=
p
o
l
y
(
ğ›½
)
N=poly(Î²).

Complexity trichotomy on paths: In this setting, only the three regimes 
ğ‘‚
(
1
)
O(1), 
Î˜
(
log
â¡
âˆ—
ğ‘›
)
Î˜(log
âˆ—
n), 
Î˜
(
ğ‘›
)
Î˜(n) occur.

This normalization isolates the combinatorics to binary inputs and finite output adjacency, letting us talk about finite automata over inputs and matrix-like conditions over outputs.

3) Where the known decidability approach blows up

The original decidability proof (from the paper) uses feasible functions and pumping/replacement arguments. Two scaling issues make a direct algorithm doubly exponential:

The pumping length / number of types 
ğ¾
K is exponential in 
ğ›½
Î².

The feasible functionâ€™s domain enumerates strings up to length 
ğ¾
K, i.e., 
Î˜
(
2
ğ¾
)
Î˜(2
K
) many inputs, so the witness itself is 2-EXP in 
ğ›½
Î².

Hence, â€œguess the feasible functionâ€ is too big for NEXPTIME; we need to shrink the witness or verify universally quantified constraints implicitly.

4) Key device: transfer-matrix types for radius-1 on oriented paths

The attempt proposes a sharper notion of â€œtypeâ€ tailored to this restricted setting.

For any input segment (a path) 
ğ‘ƒ
P, define its type 
\Type
(
ğ‘ƒ
)
\Type(P) to be the transfer matrix 
ğ‘€
ğ‘ƒ
âˆˆ
{
0
,
1
}
ğ›½
Ã—
ğ›½
M
P
	â€‹

âˆˆ{0,1}
Î²Ã—Î²
 where

ğ‘€
ğ‘ƒ
[
ğ‘
,
ğ‘
]
=
1
â€…â€Š
âŸº
â€…â€Š
thereÂ existsÂ aÂ legalÂ outputÂ labelingÂ onÂ 
ğ‘ƒ
Â thatÂ startsÂ atÂ 
ğ‘
Â andÂ endsÂ atÂ 
ğ‘
.
M
P
	â€‹

[a,b]=1âŸºthereÂ existsÂ aÂ legalÂ outputÂ labelingÂ onÂ PÂ thatÂ startsÂ atÂ aÂ andÂ endsÂ atÂ b.

Intuition: with radius-1 constraints, the only global information that matters about a segment when you splice it in/out is which boundary output labels it can connect between. Thatâ€™s exactly what 
ğ‘€
ğ‘ƒ
M
P
	â€‹

 records.

Concatenation = Boolean matrix product. If 
ğ‘ƒ
=
ğ‘ƒ
ğ‘„
P=PQ, then 
ğ‘€
ğ‘ƒ
=
ğ‘€
ğ‘„
â‹…
ğ‘€
ğ‘ƒ
M
P
	â€‹

=M
Q
	â€‹

â‹…M
P
	â€‹

 over the Boolean semiring (existential composition of boundary connections).

State count. The number of distinct Boolean 
ğ›½
Ã—
ğ›½
Î²Ã—Î² matrices is 
2
ğ›½
2
2
Î²
2
. So the number of types 
ğ¾
K is at most 
2
ğ›½
2
2
Î²
2
: still exponential but significantly tighter than general upper bounds used in broader settings.

The punchline: replacement/pumping can be made to depend solely on 
ğ‘€
ğ‘ƒ
M
P
	â€‹

, not on long raw stringsâ€”exactly what we need to compress witnesses.

5) The type DFA 
ğ´
types
A
types
	â€‹


Construct a deterministic automaton whose states are types (transfer matrices).

Alphabet: the binary inputs 
{
0
,
1
}
{0,1}.

Transitions: from a current type 
ğ‘€
M, reading symbol 
ğ‘–
âˆˆ
{
0
,
1
}
iâˆˆ{0,1} transforms the segment by appending one input 
ğ‘–
i. This gives a new matrix 
ğ›¿
(
ğ‘€
,
ğ‘–
)
Î´(M,i) computed from 
ğ¶
i
n
â€“
o
u
t
C
inâ€“out
	â€‹

 and 
ğ¶
o
u
t
â€“
o
u
t
C
outâ€“out
	â€‹

. (Formally, you precompute the one-step transfer matrices for input 
0
0 and 
1
1 and multiply accordingly.)

Reachable part: you donâ€™t need every one of the 
2
ğ›½
2
2
Î²
2
 matrices, only those reachable from the 1-length prefixes under these transitions. A BFS over the state space suffices.

Cost: building the reachable sub-automaton is EXPTIME in 
ğ›½
Î² (states and transitions are exponential; each step is 
p
o
l
y
(
ğ›½
)
poly(Î²) to multiply Boolean matrices).

6) Deciding 
Î˜
(
ğ‘›
)
Î˜(n) vs 
ğ‘‚
(
log
â¡
âˆ—
ğ‘›
)
O(log
âˆ—
n) via a type-based feasible function

The paperâ€™s middle-gap characterization uses a feasible function 
ğ‘“
f that selects boundary outputs for long contexts so that all gaps are fillable. The attemptâ€™s move is:

Replace 
ğ‘“
(
ğ‘¤
1
â€‰
ğ‘†
â€‰
ğ‘¤
2
)
f(w
1
	â€‹

Sw
2
	â€‹

) (which depends on concrete long strings 
ğ‘¤
1
,
ğ‘¤
2
w
1
	â€‹

,w
2
	â€‹

) with a type-based function

ğ‘“
type
:
(
ğœ
ğ¿
,
â€…â€Š
ğ‘†
âˆˆ
Î£
i
n
2
,
â€…â€Š
ğœ
ğ‘…
)
â€…â€Š
â†¦
â€…â€Š
boundaryÂ outputsÂ inÂ 
Î£
o
u
t
2
f
type
	â€‹

:(Ï„
L
	â€‹

,SâˆˆÎ£
in
2
	â€‹

,Ï„
R
	â€‹

)â†¦boundaryÂ outputsÂ inÂ Î£
out
2
	â€‹


where 
ğœ
ğ¿
=
\Type
(
ğ‘¤
1
)
Ï„
L
	â€‹

=\Type(w
1
	â€‹

) and 
ğœ
ğ‘…
=
\Type
(
ğ‘¤
2
)
Ï„
R
	â€‹

=\Type(w
2
	â€‹

).
(For radius 1, the â€œsandwichâ€ window 
ğ‘†
S has constant length 
2
ğ‘Ÿ
=
2
2r=2.)

Rationale: feasibility (i.e., â€œevery long enough middle gap with the same boundary types is fillableâ€) depends only on types, not on which particular representatives 
ğ‘¤
1
,
ğ‘¤
2
w
1
	â€‹

,w
2
	â€‹

 you pickedâ€”because replacement is legal whenever the boundary transfer matrices match.

Algorithmic structure

Construct 
ğ´
types
A
types
	â€‹

 and collect reachable types 
ğ‘‡
T (EXPTIME).

Nondeterministically guess the table for 
ğ‘“
type
:
ğ‘‡
Ã—
Î£
i
n
2
Ã—
ğ‘‡
â†’
Î£
o
u
t
2
f
type
	â€‹

:TÃ—Î£
in
2
	â€‹

Ã—Tâ†’Î£
out
2
	â€‹

.
Size: 
ğ‘‚
(
âˆ£
ğ‘‡
âˆ£
2
â‹…
âˆ£
Î£
i
n
âˆ£
2
â‹…
log
â¡
ğ›½
)
=
2
p
o
l
y
(
ğ›½
)
O(âˆ£Tâˆ£
2
â‹…âˆ£Î£
in
	â€‹

âˆ£
2
â‹…logÎ²)=2
poly(Î²)
 â†’ guessable in NEXPTIME.

Verify feasibility for all tuples 
(
ğœ
ğ‘
,
ğœ
ğ‘
,
ğœ
ğ‘
,
ğœ
ğ‘‘
,
ğ‘†
1
,
ğ‘†
2
)
(Ï„
a
	â€‹

,Ï„
b
	â€‹

,Ï„
c
	â€‹

,Ï„
d
	â€‹

,S
1
	â€‹

,S
2
	â€‹

):

Interpret 
ğ¿
1
=
ğ‘“
type
(
ğœ
ğ‘
,
ğ‘†
1
,
ğœ
ğ‘
)
L
1
	â€‹

=f
type
	â€‹

(Ï„
a
	â€‹

,S
1
	â€‹

,Ï„
b
	â€‹

) and 
ğ¿
2
=
ğ‘“
type
(
ğœ
ğ‘
,
ğ‘†
2
,
ğœ
ğ‘‘
)
L
2
	â€‹

=f
type
	â€‹

(Ï„
c
	â€‹

,S
2
	â€‹

,Ï„
d
	â€‹

) as boundary output requirements.

Requirement: For every pair of long contexts 
ğ‘¤
ğ‘
,
ğ‘¤
ğ‘
w
b
	â€‹

,w
c
	â€‹

 with 
\Type
(
ğ‘¤
ğ‘
)
=
ğœ
ğ‘
\Type(w
b
	â€‹

)=Ï„
b
	â€‹

 and 
\Type
(
ğ‘¤
ğ‘
)
=
ğœ
ğ‘
\Type(w
c
	â€‹

)=Ï„
c
	â€‹

, the concatenation 
ğ‘¤
ğ‘
ğ‘¤
ğ‘
w
b
	â€‹

w
c
	â€‹

 must admit a legal filling consistent with boundary outputs 
ğ¿
1
,
ğ¿
2
L
1
	â€‹

,L
2
	â€‹

.

Turn this into language inclusion:

Build a regular language 
ğ¿
gap
=
{
â€‰
ğ‘¤
ğ‘
ğ‘¤
ğ‘
:
\Type
(
ğ‘¤
ğ‘
)
=
ğœ
ğ‘
,
â€…â€Š
\Type
(
ğ‘¤
ğ‘
)
=
ğœ
ğ‘
,
â€…â€Š
âˆ£
ğ‘¤
ğ‘
âˆ£
,
âˆ£
ğ‘¤
ğ‘
âˆ£
âˆˆ
{
ğ¾
,
ğ¾
+
1
}
â€‰
}
L
gap
	â€‹

={w
b
	â€‹

w
c
	â€‹

:\Type(w
b
	â€‹

)=Ï„
b
	â€‹

,\Type(w
c
	â€‹

)=Ï„
c
	â€‹

,âˆ£w
b
	â€‹

âˆ£,âˆ£w
c
	â€‹

âˆ£âˆˆ{K,K+1}} using 
ğ´
types
A
types
	â€‹

 with a length filter (counters up to 
ğ¾
+
1
K+1). This automaton is poly
(
ğ¾
)
(K) in size.

Build a small NFA 
ğ‘
(
ğ¿
1
,
ğ¿
2
)
N(L
1
	â€‹

,L
2
	â€‹

) (size 
p
o
l
y
(
ğ›½
)
poly(Î²)) that accepts exactly the inputs for which a legal middle labeling exists that matches 
ğ¿
1
L
1
	â€‹

 and 
ğ¿
2
L
2
	â€‹

 at the boundaries.

Check 
ğ¿
gap
âŠ†
ğ¿
(
ğ‘
(
ğ¿
1
,
ğ¿
2
)
)
L
gap
	â€‹

âŠ†L(N(L
1
	â€‹

,L
2
	â€‹

)). Use 
ğ¿
âŠ†
ğ‘…
â€…â€Š
âŸº
â€…â€Š
ğ¿
âˆ©
ğ‘…
â€¾
=
âˆ…
LâŠ†RâŸºLâˆ©
R
=âˆ…:

Complement 
ğ‘
(
ğ¿
1
,
ğ¿
2
)
N(L
1
	â€‹

,L
2
	â€‹

) (exponential subset construction â†’ DFA of size 
2
p
o
l
y
(
ğ›½
)
2
poly(Î²)
).

Form the product with the 
ğ¿
gap
L
gap
	â€‹

 automaton (size 
p
o
l
y
(
ğ¾
)
â‹…
2
p
o
l
y
(
ğ›½
)
poly(K)â‹…2
poly(Î²)
).

Test emptiness in time polynomial in the product size.

Total cost across all tuples is still EXPTIME in 
ğ›½
Î².

Conclusion: We obtain a NEXPTIME procedure for the 
Î˜
(
ğ‘›
)
Î˜(n) vs 
ğ‘‚
(
log
â¡
âˆ—
ğ‘›
)
O(log
âˆ—
n) decision: guess an exponential-size witness 
ğ‘“
type
f
type
	â€‹

; verify it using EXPTIME automata-inclusion checks.

7) Complexity accounting (why this fits NEXPTIME)

Building the reachable type DFA: EXPTIME.

Size of the guessed 
ğ‘“
type
f
type
	â€‹

: exponential in 
ğ›½
Î² â†’ NEXPTIME guess.

Verification per tuple: product of a 
p
o
l
y
(
ğ¾
)
poly(K) automaton and a 
2
p
o
l
y
(
ğ›½
)
2
poly(Î²)
 DFA â†’ EXPTIME.
Number of tuples is 
ğ‘‚
(
âˆ£
ğ‘‡
âˆ£
4
â‹…
âˆ£
Î£
i
n
âˆ£
4
)
=
2
p
o
l
y
(
ğ›½
)
O(âˆ£Tâˆ£
4
â‹…âˆ£Î£
in
	â€‹

âˆ£
4
)=2
poly(Î²)
, absorbed in EXPTIME.

Therefore, the overall nondeterministic algorithm sits in NEXPTIME.

8) The hard part: 
ğ‘‚
(
1
)
O(1) vs 
Î©
(
log
â¡
âˆ—
ğ‘›
)
Î©(log
âˆ—
n)

The top gap in the paper uses a feasible function 
ğ‘“
f defined on all periodic inputs 
ğ‘¤
w with 
âˆ£
ğ‘¤
âˆ£
â‰¤
ğ¾
âˆ£wâˆ£â‰¤K, selecting a periodic output for each. Two constraints must hold:

Internal consistency: the output you pick for a period 
ğ‘¤
w must itself be realizable (cycles in the output transition structure constrained by the input).

Interface consistency: for any two periods 
ğ‘¤
1
,
ğ‘¤
2
w
1
	â€‹

,w
2
	â€‹

 and any short context 
ğ‘†
S, when you place 
ğ‘¤
1
ğ¾
ğ‘†
ğ‘¤
2
ğ¾
w
1
K
	â€‹

Sw
2
K
	â€‹

 in the middle, the selected outputs for 
ğ‘¤
1
w
1
	â€‹

 and 
ğ‘¤
2
w
2
	â€‹

 must be compatible across the interface.

The domain of 
ğ‘“
f has size 
Î˜
(
2
ğ¾
)
Î˜(2
K
) with 
ğ¾
=
2
Î˜
(
ğ›½
2
)
K=2
Î˜(Î²
2
)
 â†’ doubly exponential; naive guessing is impossible within NEXPTIME.

Proposed direction to compress the witness

Work implicitly over types using 
ğ´
types
A
types
	â€‹

 rather than enumerating all periods:

For each type 
ğœ
Ï„, characterize the set of admissible periodic output behaviors compatible with any 
ğ‘¤
w of type 
ğœ
Ï„. This amounts to finding output cycles permitted by the local constraints when the input repeats with type 
ğœ
Ï„.

Formalize interface compatibility between two chosen periodic behaviors across a short context 
ğ‘†
S; crucially, compatibility depends on the types and length-
ğ¾
K repetitions (which we can analyze via matrix powering or automata products without unfolding 
ğ¾
K steps explicitly).

Guess an exponential-size certificate instead of a 2-EXP feasible function, e.g.:

a per-type annotation that selects (or finitely describes the set of) periodic outputs, plus

a finite-state transducer that maps types (or short input representatives) to periodic outputs, subject to interface constraints.

Verify universally quantified interface constraints by reducing to emptiness/inclusion of regular languages (or a slight extension, e.g., automata with length-mod counters), leveraging the type DFA. The exponent 
ğ¾
K is handled symbolically (e.g., by powering transfer matrices) rather than by enumerating all length-
ğ¾
K words.

Status in the attempt: This is a credible plan but still missing the compression lemma that says:

If such a feasible 
ğ‘“
f exists, then there exists an equivalent witness of only exponential size (e.g., a transducer/annotation over the type DFA) whose constraints are checkable in EXPTIME.

Once that lemma is in place, the top gap should also drop to NEXPTIME (guess the exponential certificate, check by EXPTIME automata methods).

9) Assumptions that must be proved cleanly

Replacement via transfer matrices (radius-1, oriented path).
If two segments have the same transfer matrix, replacing one by the other preserves global legality (including boundaries). This is the backbone that lets feasibility depend only on types.

Middle-gap feasibility depends only on types.
The existence of a path-based feasible function implies the existence of a type-based one; picking different representatives with the same types does not change the fillability of long gaps.

Automata construction correctness.
The NFAs/DFAs used to recognize:
(a) â€œwords of type 
ğœ
Ï„ of lengths in 
[
ğ¾
,
ğ¾
+
1
]
[K,K+1]â€ and
(b) â€œwords that admit boundary-consistent fillings between 
ğ¿
1
L
1
	â€‹

 and 
ğ¿
2
L
2
	â€‹

â€
indeed capture the intended combinatorics, and length filters donâ€™t introduce artifacts.

None is exotic, but each needs a tight, radius-1-specific proof so the size bounds stay exponential, not double.

10) Risks, edge cases, and details to watch

Length filters 
[
ğ¾
,
ğ¾
+
1
]
[K,K+1]: The construction of 
ğ¿
gap
L
gap
	â€‹

 must enforce the exact length band without blowing up beyond 
p
o
l
y
(
ğ¾
)
poly(K).

Complementation blow-up: Complementing 
ğ‘
(
ğ¿
1
,
ğ¿
2
)
N(L
1
	â€‹

,L
2
	â€‹

) is exponential; ensure its size depends on 
ğ›½
Î², not on 
ğ¾
K.

Boundary encoding: When 
ğ‘“
type
f
type
	â€‹

 returns â€œboundary outputs in 
Î£
o
u
t
2
Î£
out
2
	â€‹

â€, be explicit: does this mean â€œoutputs at the two nodes adjacent to the gapâ€ or â€œa small boundary wordâ€? Keep it radius-1 consistent.

Reachable types only: Always cut down to the reachable part of the type graph; proofs should reference that to avoid vacuous states.

Periodicity handling in 
ğ‘‚
(
1
)
O(1): Use matrix powering and cycle detection in the output constraint graph to characterize periodic behaviors symbolically; donâ€™t unroll 
ğ¾
K steps.

11) What a â€œfinishedâ€ result would look like

To turn the plan into a theorem/algorithm with complete guarantees:

Lemma A (Type sufficiency). For Î²-normalized radius-1 LCLs on oriented paths, transfer-matrix types support a replacement lemma: equal matrices 
â‡’
â‡’ interchangeable segments preserving legality and boundary labels.

Lemma B (Feasibility â†’ type-feasibility). If a (path-based) feasible function for the middle gap exists, a type-based feasible function exists; the middle gap is decidable in NEXPTIME via automata inclusion.

Lemma C (Top-gap compression). If the (path-based) periodic feasible function exists, there exists an exponential-size certificate (type-annotated selection/transducer) verifiable in EXPTIME by automata-theoretic checks.
â†’ This yields a NEXPTIME decision for 
ğ‘‚
(
1
)
O(1) vs 
Î©
(
log
â¡
âˆ—
ğ‘›
)
Î©(log
âˆ—
n).

Algorithm statement and complexity. A single NEXPTIME procedure distinguishes among the three regimes (e.g., check top gap first; if false, check middle gap; else 
ğ‘‚
(
1
)
O(1); if middle gap also false, conclude 
Î˜
(
ğ‘›
)
Î˜(n)).

12) Sanity check on why transfer matrices are the right abstraction here

Radius-1 means the legality at a node uses only its own input and neighbor outputs.

For a fragment, the only information the outside world needs is: Given I â€œpinâ€ the left boundary output to 
ğ‘
a and the right boundary output to 
ğ‘
b, can I fill the interior in a way consistent with its internal inputs and the tables?

Thatâ€™s exactly what the Boolean relation 
ğ‘€
ğ‘ƒ
[
ğ‘
,
ğ‘
]
M
P
	â€‹

[a,b] encodes. This is why equal 
ğ‘€
ğ‘ƒ
M
P
	â€‹

 should imply semantic interchangeability, enabling pumping.

13) One-paragraph takeaway

The attempt replaces raw-string witnesses with type-level witnesses for radius-1 LCLs on oriented paths. A transfer-matrix type 
ğ‘€
ğ‘ƒ
M
P
	â€‹

 (Boolean 
ğ›½
Ã—
ğ›½
Î²Ã—Î² reachability between boundary outputs) compresses all the information a segment exposes to its context. Building the type DFA over the binary input lets you talk about regular languages of gaps and check the middle-gap feasible-function property as a language inclusion problem (hence NEXPTIME: guess an exponential table 
ğ‘“
type
f
type
	â€‹

, verify in EXPTIME). The tough 
ğ‘‚
(
1
)
O(1) vs 
Î©
(
log
â¡
âˆ—
ğ‘›
)
Î©(log
âˆ—
n) boundary remains, because the standard feasible function ranges over a doubly-exponential domain of periods. The proposed path is to compress that witness to an exponential certificateâ€”some combination of per-type annotations and a small transducerâ€”so that universal â€œinterfaceâ€ constraints can be verified by automata-theoretic emptiness/inclusion with matrix powering rather than unrolling 
ğ¾
K repetitions. Proving that compression lemma would complete a full NEXPTIME trichotomy decision.