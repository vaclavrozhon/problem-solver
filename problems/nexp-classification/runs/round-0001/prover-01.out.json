{
  "content": "# Ideas\n\n- Specialize \u201ctypes\u201d for radius-1, oriented paths to a Boolean transfer matrix M_P \u2208 {0,1}^{\u03b2\u00d7\u03b2} that records boundary-output feasibility: M_P[a,b]=1 iff P admits a legal output labeling with leftmost output a and rightmost output b.\n- Show composition M_{P\u00b7Q} = M_P \u00b7 E \u00b7 M_Q over the Boolean semiring, where E is the \u03b2\u00d7\u03b2 adjacency matrix of C_out\u2013out.\n- Prove a replacement lemma: if M_P = M_{P'}, then P is interchangeable with P' in any context without affecting feasibility or outside labels.\n- Use the transfer-matrix DFA (states = reachable \u03b2\u00d7\u03b2 Boolean matrices; transition \u03b4(M,i)=M\u00b7E\u00b7S_i with S_i = diag( Cin\u2013out(i,\u00b7) )) to enumerate all reachable types (exponentially many, \u2264 2^{\u03b2^2}).\n- Give a NEXPTIME procedure for deciding \u0398(n) vs O(log* n) by nondeterministically guessing a compressed, type-based feasible function and verifying it by constant-size matrix inequalities, avoiding doubly-exponential witnesses.\n- Outline how to compress the O(1) vs \u03a9(log* n) witness in the same spirit (per-type periodic outputs), and isolate the remaining technical step to complete the trichotomy in NEXPTIME.\n\n# Formalization\n\nLet \u03a3_in={0,1}, \u03a3_out of size \u03b2. Let Cin\u2013out \u2286 \u03a3_in\u00d7\u03a3_out and Cout\u2013out \u2286 \u03a3_out\u00d7\u03a3_out. Define the \u03b2\u00d7\u03b2 Boolean matrix E by E[x,y]=1 \u21d4 (x,y)\u2208Cout\u2013out.\nFor i\u2208{0,1}, define the \u03b2\u00d7\u03b2 Boolean matrix S_i by S_i[x,y]=1 \u21d4 x=y and (i,x)\u2208Cin\u2013out; i.e., S_i is diagonal with 1s on outputs allowed by Cin\u2013out at input i.\n\nGiven an input-labeled path P (directed left\u2192right), define its transfer matrix M_P as follows: for a one-node path with input i, M_P=S_i; for a concatenation P\u00b7Q, M_{P\u00b7Q} = M_P \u00b7 E \u00b7 M_Q (Boolean product). Equivalently, for w\u2208{0,1}^k, M(w)=S_{w_1}\u00b7E\u00b7S_{w_2}\u00b7E\u00b7\u2026\u00b7E\u00b7S_{w_k}.\n\nWe call two paths type-equivalent if their transfer matrices are equal. The number of types is \u2264 number of Boolean \u03b2\u00d7\u03b2 matrices = 2^{\u03b2^2}. Let T be the set of types reachable from {S_0,S_1} under transitions \u03b4(M,i)=M\u00b7E\u00b7S_i.\n\n# Lemma 1 (Composition).\nFor any input paths P,Q, M_{P\u00b7Q} = M_P \u00b7 E \u00b7 M_Q.\n\nProof. By construction for singletons; Boolean associativity yields the general case since each internal edge contributes one \u201cE\u201d factor.\n\n# Lemma 2 (Replacement for radius 1).\nLet G be an oriented path (or cycle), and P a subpath of G. Let P' be another path with M_{P'}=M_P. Then G admits a legal labeling that agrees with a given legal labeling outside P iff the graph obtained by replacing P with P' admits a legal labeling that agrees outside P'.\n\nProof. Fix the outside outputs on the two endpoints adjacent to P (call them a on the left boundary edge and c on the right boundary edge). Feasibility of filling P is equivalent to (row a, column c) of M_P being reachable through the surrounding Es; precisely, existence of u,v with E[a,u]=1, M_P[u,v]=1, E[v,c]=1. Since M_{P'}=M_P, the same condition holds with P' instead of P. Interior node input/output consistency and internal edges are already captured by M_P; the cross-edges are exactly the Es. Hence replacement preserves extendibility and allows relabeling strictly within P/P'.\n\n# Middle-gap feasibility via types\n\nWe adapt the feasible-function framework (for r=1 so 2r=2) to types. Given two length-2 input blocks S1,S2\u2208{0,1}^2, and four context types \u03c4_a,\u03c4_b,\u03c4_c,\u03c4_d\u2208T, a type-based feasible function is\nf_type: T \u00d7 {0,1}^2 \u00d7 T \u2192 \u03a3_out^2,\nthat returns the two outputs for the two nodes of S. Let f_type(\u03c4,S,\u03c4')=(x_1,x_2). Validity requires (Cin\u2013out(S[1],x_1)\u2227Cin\u2013out(S[2],x_2)\u2227E[x_1,x_2]). The extendibility requirement (bridging w_b of type \u03c4_b and w_c of type \u03c4_c) reduces to a single matrix inequality:\n\nLet L1=f_type(\u03c4_a,S1,\u03c4_b)=(\u2113_1,\u2113_2) and L2=f_type(\u03c4_c,S2,\u03c4_d)=(r_1,r_2). Writing M_b for the matrix of \u03c4_b and M_c for \u03c4_c, the existence of a filling of the middle context w_b w_c consistent with these boundary outputs holds iff\n\n(E \u00b7 M_b \u00b7 E \u00b7 M_c \u00b7 E)[\u2113_2, r_1] = 1.\n\nThis follows because bridging requires outputs u on the first node of w_b and v_b on the last of w_b, then u_c on the first of w_c and v on the last of w_c, with constraints\nE[\u2113_2,u]=1, M_b[u,v_b]=1, E[v_b,u_c]=1, M_c[u_c,v]=1, E[v,r_1]=1,\nwhich is equivalent to (E\u00b7M_b\u00b7E\u00b7M_c\u00b7E)[\u2113_2,r_1]=1.\n\n# Theorem 1 (NEXPTIME decision for \u0398(n) vs O(log* n)).\nThere is a nondeterministic exponential-time algorithm that, given (Cin\u2013out,Cout\u2013out), decides whether the complexity is O(log* n) or \u0398(n) on oriented paths.\n\nProof sketch.\n- Enumerate T (reachable types) by BFS on the transfer-matrix DFA starting from {S_0,S_1}, using transitions \u03b4(M,i)=M\u00b7E\u00b7S_i. State space \u2264 2^{\u03b2^2}, each step costs poly(\u03b2) for Boolean matrix multiplication; overall EXPTIME in \u03b2.\n- Guess f_type: T\u00d7{0,1}^2\u00d7T\u2192\u03a3_out^2. Size of the table is |T|^2\u00b74\u00b72\u00b7log\u03b2 bits = 2^{\u0398(\u03b2^2)} bits; guessing fits NEXPTIME in N=poly(\u03b2).\n- Verify: (i) local validity for every entry (Cin\u2013out and E on the two outputs), and (ii) for all tuples (\u03c4_a,\u03c4_b,\u03c4_c,\u03c4_d,S1,S2), check (E\u00b7M_b\u00b7E\u00b7M_c\u00b7E)[\u2113_2,r_1]=1, where L1=f_type(\u03c4_a,S1,\u03c4_b) and L2=f_type(\u03c4_c,S2,\u03c4_d). The number of tuples is |T|^4\u00b716=2^{\u0398(\u03b2^2)}, and each check is O(\u03b2^3) time (three Boolean matrix products and one lookup). Thus verification is EXPTIME.\n- If such f_type exists, we obtain an O(log* n) algorithm by the standard decomposition (compute a (2,\u2265K)-ruling-set on the cycle in O(log* n), label all 2-length S-blocks by f_type, and fill the gaps by the above matrix condition; replacement Lemma 2 and the usual pumping arguments ensure completeness). If no such f_type exists, the middle-gap is \u0398(n).\n\n# Examples / sanity checks\n\n- If Cout\u2013out is a complete relation, then E is all-ones and M(w)=S_{w_1}\u00b7\u2026\u00b7S_{w_k} is diagonal, so (E\u00b7M_b\u00b7E\u00b7M_c\u00b7E) is all-ones on every row/column corresponding to outputs allowed by Cin\u2013out; the check reduces to local Cin\u2013out admissibility.\n- If Cin\u2013out forces a unique output per input and Cout\u2013out is a fixed directed graph, then M(w) becomes the path-graph adjacency from the leftmost to rightmost outputs; composition formula matches ordinary graph reachability across concatenation.\n\n# Obstacles for O(1) vs \u03a9(log* n)\n\n- In the cycle setting, Chang et al. characterize O(1) by existence of a feasible periodic-output selection for every short primitive input period w (|w|\u2264K), with interface constraints across short separators. Naively, the domain size is \u22482^K with K\u22482^{\u0398(\u03b2^2)}, leading to doubly-exponential witnesses.\n- We propose to compress to per-type periodic behavior: for each reachable type \u03c4 induced by a primitive input period w (|w|\u2264poly(|T|)), select an output period y of length |w| such that (i) y is realizable on w (i.e., S_{w_1}\u00b7E\u00b7\u2026\u00b7E\u00b7S_{w_k} has ones on the diagonal entries (y_i,y_i) and E[y_i,y_{i+1}] for all i), and (ii) interface constraints between any two such choices across a 2-node separator S can be expressed by a constant Boolean matrix condition analogous to the middle-gap check. This yields an exponential-size certificate verifiable in EXPTIME, provided we show a compression lemma: any O(1) feasible map admits a type-annotated periodic certificate of size 2^{O(\u03b2^2)}.\n\n- Outstanding step: Prove the compression lemma rigorously. Strategy: (a) work over the transfer-matrix DFA to define \u201cprimitive type-cycles\u201d (i.e., minimal directed cycles in the type graph induced by concatenating one input symbol at a time) and associate each with a periodic output cycle in \u03a3_out constrained by E and Cin\u2013out; (b) show that any long repetitive block factors through such cycles; (c) verify interface constraints by constant-size products of E and the cycle\u2019s transfer matrices.\n\n# Next steps (auditable tasks)\n\n1) Write the full proof of Lemma 2 (replacement) in the radius-1 setting using only matrix algebra, and explicitly handle cycles vs paths and preservation of already-assigned outside labels.\n\n2) Formalize the construction of the transfer-matrix DFA: specify initial states {S_0,S_1}, define reachability, and prove that every nonempty input word\u2019s type is reachable, and the set is closed under \u03b4.\n\n3) Implement the \u0398(n) vs O(log* n) verifier: given (Cin\u2013out,Cout\u2013out) and a candidate f_type, check the two validation conditions. Provide precise asymptotic accounting: states \u22642^{\u03b2^2}, candidate size \u22642^{O(\u03b2^2)}, checks \u22642^{O(\u03b2^2)} operations, each poly(\u03b2). This gives EXPTIME verification, hence NEXPTIME decision by guessing f_type.\n\n4) For O(1) vs \u03a9(log* n): define \u201cprimitive type-cycles\u201d and periodic-output feasibility as a per-type constraint; formulate the interface matrix condition analogous to (E\u00b7M_b\u00b7E\u00b7M_c\u00b7E)[\u2113_2,r_1]=1 for separators; and attempt to show the compression lemma from per-word to per-type periodic selections.\n\n5) Try toy instances (small \u03b2) to validate the matrix machinery and the middle-gap checker; seek counterexamples to ensure no missing constraints at separators.\n"
}