# Ideas

- Specialize “types” for radius-1, oriented paths to a Boolean transfer matrix M_P ∈ {0,1}^{β×β} that records boundary-output feasibility: M_P[a,b]=1 iff P admits a legal output labeling with leftmost output a and rightmost output b.
- Show composition M_{P·Q} = M_P · E · M_Q over the Boolean semiring, where E is the β×β adjacency matrix of C_out–out.
- Prove a replacement lemma: if M_P = M_{P'}, then P is interchangeable with P' in any context without affecting feasibility or outside labels.
- Use the transfer-matrix DFA (states = reachable β×β Boolean matrices; transition δ(M,i)=M·E·S_i with S_i = diag( Cin–out(i,·) )) to enumerate all reachable types (exponentially many, ≤ 2^{β^2}).
- Give a NEXPTIME procedure for deciding Θ(n) vs O(log* n) by nondeterministically guessing a compressed, type-based feasible function and verifying it by constant-size matrix inequalities, avoiding doubly-exponential witnesses.
- Outline how to compress the O(1) vs Ω(log* n) witness in the same spirit (per-type periodic outputs), and isolate the remaining technical step to complete the trichotomy in NEXPTIME.

# Formalization

Let Σ_in={0,1}, Σ_out of size β. Let Cin–out ⊆ Σ_in×Σ_out and Cout–out ⊆ Σ_out×Σ_out. Define the β×β Boolean matrix E by E[x,y]=1 ⇔ (x,y)∈Cout–out.
For i∈{0,1}, define the β×β Boolean matrix S_i by S_i[x,y]=1 ⇔ x=y and (i,x)∈Cin–out; i.e., S_i is diagonal with 1s on outputs allowed by Cin–out at input i.

Given an input-labeled path P (directed left→right), define its transfer matrix M_P as follows: for a one-node path with input i, M_P=S_i; for a concatenation P·Q, M_{P·Q} = M_P · E · M_Q (Boolean product). Equivalently, for w∈{0,1}^k, M(w)=S_{w_1}·E·S_{w_2}·E·…·E·S_{w_k}.

We call two paths type-equivalent if their transfer matrices are equal. The number of types is ≤ number of Boolean β×β matrices = 2^{β^2}. Let T be the set of types reachable from {S_0,S_1} under transitions δ(M,i)=M·E·S_i.

# Lemma 1 (Composition).
For any input paths P,Q, M_{P·Q} = M_P · E · M_Q.

Proof. By construction for singletons; Boolean associativity yields the general case since each internal edge contributes one “E” factor.

# Lemma 2 (Replacement for radius 1).
Let G be an oriented path (or cycle), and P a subpath of G. Let P' be another path with M_{P'}=M_P. Then G admits a legal labeling that agrees with a given legal labeling outside P iff the graph obtained by replacing P with P' admits a legal labeling that agrees outside P'.

Proof. Fix the outside outputs on the two endpoints adjacent to P (call them a on the left boundary edge and c on the right boundary edge). Feasibility of filling P is equivalent to (row a, column c) of M_P being reachable through the surrounding Es; precisely, existence of u,v with E[a,u]=1, M_P[u,v]=1, E[v,c]=1. Since M_{P'}=M_P, the same condition holds with P' instead of P. Interior node input/output consistency and internal edges are already captured by M_P; the cross-edges are exactly the Es. Hence replacement preserves extendibility and allows relabeling strictly within P/P'.

# Middle-gap feasibility via types

We adapt the feasible-function framework (for r=1 so 2r=2) to types. Given two length-2 input blocks S1,S2∈{0,1}^2, and four context types τ_a,τ_b,τ_c,τ_d∈T, a type-based feasible function is
f_type: T × {0,1}^2 × T → Σ_out^2,
that returns the two outputs for the two nodes of S. Let f_type(τ,S,τ')=(x_1,x_2). Validity requires (Cin–out(S[1],x_1)∧Cin–out(S[2],x_2)∧E[x_1,x_2]). The extendibility requirement (bridging w_b of type τ_b and w_c of type τ_c) reduces to a single matrix inequality:

Let L1=f_type(τ_a,S1,τ_b)=(ℓ_1,ℓ_2) and L2=f_type(τ_c,S2,τ_d)=(r_1,r_2). Writing M_b for the matrix of τ_b and M_c for τ_c, the existence of a filling of the middle context w_b w_c consistent with these boundary outputs holds iff

(E · M_b · E · M_c · E)[ℓ_2, r_1] = 1.

This follows because bridging requires outputs u on the first node of w_b and v_b on the last of w_b, then u_c on the first of w_c and v on the last of w_c, with constraints
E[ℓ_2,u]=1, M_b[u,v_b]=1, E[v_b,u_c]=1, M_c[u_c,v]=1, E[v,r_1]=1,
which is equivalent to (E·M_b·E·M_c·E)[ℓ_2,r_1]=1.

# Theorem 1 (NEXPTIME decision for Θ(n) vs O(log* n)).
There is a nondeterministic exponential-time algorithm that, given (Cin–out,Cout–out), decides whether the complexity is O(log* n) or Θ(n) on oriented paths.

Proof sketch.
- Enumerate T (reachable types) by BFS on the transfer-matrix DFA starting from {S_0,S_1}, using transitions δ(M,i)=M·E·S_i. State space ≤ 2^{β^2}, each step costs poly(β) for Boolean matrix multiplication; overall EXPTIME in β.
- Guess f_type: T×{0,1}^2×T→Σ_out^2. Size of the table is |T|^2·4·2·logβ bits = 2^{Θ(β^2)} bits; guessing fits NEXPTIME in N=poly(β).
- Verify: (i) local validity for every entry (Cin–out and E on the two outputs), and (ii) for all tuples (τ_a,τ_b,τ_c,τ_d,S1,S2), check (E·M_b·E·M_c·E)[ℓ_2,r_1]=1, where L1=f_type(τ_a,S1,τ_b) and L2=f_type(τ_c,S2,τ_d). The number of tuples is |T|^4·16=2^{Θ(β^2)}, and each check is O(β^3) time (three Boolean matrix products and one lookup). Thus verification is EXPTIME.
- If such f_type exists, we obtain an O(log* n) algorithm by the standard decomposition (compute a (2,≥K)-ruling-set on the cycle in O(log* n), label all 2-length S-blocks by f_type, and fill the gaps by the above matrix condition; replacement Lemma 2 and the usual pumping arguments ensure completeness). If no such f_type exists, the middle-gap is Θ(n).

# Examples / sanity checks

- If Cout–out is a complete relation, then E is all-ones and M(w)=S_{w_1}·…·S_{w_k} is diagonal, so (E·M_b·E·M_c·E) is all-ones on every row/column corresponding to outputs allowed by Cin–out; the check reduces to local Cin–out admissibility.
- If Cin–out forces a unique output per input and Cout–out is a fixed directed graph, then M(w) becomes the path-graph adjacency from the leftmost to rightmost outputs; composition formula matches ordinary graph reachability across concatenation.

# Obstacles for O(1) vs Ω(log* n)

- In the cycle setting, Chang et al. characterize O(1) by existence of a feasible periodic-output selection for every short primitive input period w (|w|≤K), with interface constraints across short separators. Naively, the domain size is ≈2^K with K≈2^{Θ(β^2)}, leading to doubly-exponential witnesses.
- We propose to compress to per-type periodic behavior: for each reachable type τ induced by a primitive input period w (|w|≤poly(|T|)), select an output period y of length |w| such that (i) y is realizable on w (i.e., S_{w_1}·E·…·E·S_{w_k} has ones on the diagonal entries (y_i,y_i) and E[y_i,y_{i+1}] for all i), and (ii) interface constraints between any two such choices across a 2-node separator S can be expressed by a constant Boolean matrix condition analogous to the middle-gap check. This yields an exponential-size certificate verifiable in EXPTIME, provided we show a compression lemma: any O(1) feasible map admits a type-annotated periodic certificate of size 2^{O(β^2)}.

- Outstanding step: Prove the compression lemma rigorously. Strategy: (a) work over the transfer-matrix DFA to define “primitive type-cycles” (i.e., minimal directed cycles in the type graph induced by concatenating one input symbol at a time) and associate each with a periodic output cycle in Σ_out constrained by E and Cin–out; (b) show that any long repetitive block factors through such cycles; (c) verify interface constraints by constant-size products of E and the cycle’s transfer matrices.

# Next steps (auditable tasks)

1) Write the full proof of Lemma 2 (replacement) in the radius-1 setting using only matrix algebra, and explicitly handle cycles vs paths and preservation of already-assigned outside labels.

2) Formalize the construction of the transfer-matrix DFA: specify initial states {S_0,S_1}, define reachability, and prove that every nonempty input word’s type is reachable, and the set is closed under δ.

3) Implement the Θ(n) vs O(log* n) verifier: given (Cin–out,Cout–out) and a candidate f_type, check the two validation conditions. Provide precise asymptotic accounting: states ≤2^{β^2}, candidate size ≤2^{O(β^2)}, checks ≤2^{O(β^2)} operations, each poly(β). This gives EXPTIME verification, hence NEXPTIME decision by guessing f_type.

4) For O(1) vs Ω(log* n): define “primitive type-cycles” and periodic-output feasibility as a per-type constraint; formulate the interface matrix condition analogous to (E·M_b·E·M_c·E)[ℓ_2,r_1]=1 for separators; and attempt to show the compression lemma from per-word to per-type periodic selections.

5) Try toy instances (small β) to validate the matrix machinery and the middle-gap checker; seek counterexamples to ensure no missing constraints at separators.
