{
  "content": "Ideas\n\n- Transfer-matrix types for radius-1 oriented paths: For any input segment P with input string s1\u2026sk, define its type as the Boolean \u03b2\u00d7\u03b2 transfer matrix M_P with M_P[a,b]=1 iff there exists an output labeling y1\u2026yk such that y1=a, yk=b, (si,yi)\u2208Cin\u2013out for all i, and (yi,yi+1)\u2208Cout\u2013out for all i<k. For a single node with input \u03c3, set M_\u03c3[a,b]=1 iff a=b and (\u03c3,a)\u2208Cin\u2013out. Let A be the \u03b2\u00d7\u03b2 Boolean adjacency with A[x,y]=1 iff (x,y)\u2208Cout\u2013out. Then for any two segments P,Q, M_{PQ}=M_P\u00b7A\u00b7M_Q (Boolean product). For a word s1\u2026sk, M_{s1\u2026sk}=M_{s1} if k=1, and M_{s1}\u00b7A\u00b7M_{s2}\u00b7A\u00b7\u2026\u00b7A\u00b7M_{sk} otherwise.\n- Replacement lemma (matrix form): If two segments P,P\u2032 have the same transfer matrix, then they are interchangeable inside any global instance without affecting feasibility and the outputs outside the segment can be kept fixed; only the interior is relabeled. This makes types (matrices) the exact observable interface in radius-1.\n- Type automaton construction: Define transitions T_\u03c3(M)=M\u00b7A\u00b7M_\u03c3. The set of reachable types is the least fixpoint closure from {M_0,M_1} under T_0,T_1. Number of states \u22642^{\u03b2^2}. Each transition is computable in poly(\u03b2) time. Construct the reachable sub-automaton in time 2^{O(\u03b2^2)}\u00b7poly(\u03b2), i.e., EXPTIME in the encoding size N\u2248\u0398(\u03b2^2).\n- Middle-gap feasible function (type-based): With r=1, define f_type: T\u00d7\u03a3_in^2\u00d7T\u2192\u03a3_out^2 that maps (\u03c4L,S,\u03c4R) to the 2 outputs (x,y) assigned to the 2-node middle window S=(\u03c31,\u03c32). Feasibility requires that for all choices \u03c4a,\u03c4b,\u03c4c,\u03c4d\u2208T and S1,S2\u2208{0,1}^2, if S1 is labeled by (x,y)=f_type(\u03c4a,S1,\u03c4b) and S2 by (u,v)=f_type(\u03c4c,S2,\u03c4d) and they are locally legal (U_{\u03c31}[x,x]=U_{\u03c32}[y,y]=1 and A[x,y]=1; similarly for S2), then for the bridging segment types Mb=\u03c4b and Mc=\u03c4c there exist a0,aN,c0,cN\u2208\u03a3_out such that A[y,a0]=1, Mb[a0,aN]=1, A[aN,c0]=1, Mc[c0,cN]=1, and A[cN,u]=1. This condition depends only on matrices, not on particular words.\n- NEXPTIME test for \u0398(n) vs O(log* n): Nondeterministically guess f_type (a table of size |T|^2\u00b7|\u03a3_in|^2 with entries in \u03a3_out^2). Verify the above local-consistency and bridge-closure conditions for all tuples (\u03c4a,\u03c4b,\u03c4c,\u03c4d,S1,S2). Each check is a constant number of Boolean matrix products and entry inspections (poly(\u03b2)); enumerating all tuples is 2^{poly(\u03b2)}. Total deterministic verification cost is EXPTIME in N; guessing the table gives a NEXPTIME procedure. If a feasible f_type exists, the problem is o(n) (indeed O(log* n)); if no such f_type exists, the complexity is \u0398(n).\n- Toward O(1) vs \u03a9(log* n): For radius-1, oriented paths, constant-time algorithms cannot compute MIS. Using type matrices, we propose an exponential-size certificate: per-type periodic-output selections and local interface rules. For each reachable type \u03c4, choose a nonempty set C(\u03c4)\u2286\u03a3_out of periodic outputs admissible under \u03c4, meaning there is some c\u2208C(\u03c4) such that for arbitrarily long repeats of \u03c4 there exists an output labeling repeating c that is locally legal. This holds iff there exists c with U_\u03c3[c,c]=1 for the 1-letter constituents and cA c holds along edges; more precisely, periodicity reduces to the existence of a 1-cycle in the output graph restricted by the per-letter filters. Interface rules: choose, for each (\u03c4L,S,\u03c4R), boundary outputs (x,y) as before with the requirement that for all long contexts of type \u03c4L and \u03c4R (captured by matrices), the chosen x,y are elements of the corresponding C(\u03c4L), C(\u03c4R), and the same bridge-closure as above holds and moreover x,y are compatible with constant-time propagation (no dependence on distant choices). The exact compression lemma to show sufficiency of such an exponential certificate (and to reduce universal quantification to matrix checks) is outlined under Next steps.\n\nExamples\n\n- Tiny \u03b2=2 sanity check: Let \u03a3_out={a,b}. Suppose Cin\u2013out allows both outputs on both inputs, and Cout\u2013out allows only (a,a),(b,b) (i.e., constant runs). Then A=diag(1,1), M_0=M_1=diag(1,1). All reachable types are exactly the two diagonal matrices; T has size 1 (the all-ones diagonal). A feasible f_type exists: pick any locally valid x,y for S1,S2; bridges exist since A is identity. The algorithm declares O(log* n) (indeed O(1) in this trivial case). If instead Cout\u2013out forbids both self-loops, then A=0 and no nonempty segment is type-feasible; the instance is unsatisfiable except for length-1 segments, and classification collapses to \u0398(n) (needs global detection of impossibility).\n\nRigorous statements and proofs\n\nLemma 1 (concatenation law).\nLet P,Q be segments. Then M_{PQ}=M_P\u00b7A\u00b7M_Q, where \u00b7 is Boolean product.\nProof. An entry (M_{PQ})[a,d]=1 iff \u2203 boundary labels b,c with y1=a on P\u2019s left end, yp=b its right end, z1=c Q\u2019s left end, zq=d its right end, such that P admits (a\u2192b), Q admits (c\u2192d), and A[b,c]=1 for the bridge. This is exactly (M_P\u00b7A\u00b7M_Q)[a,d]=1.\n\nLemma 2 (replacement by equal matrices).\nLet an instance G contain a segment P with transfer matrix M, and P\u2032 another segment with the same matrix M. If G has a legal labeling L, then replacing P by P\u2032 yields a graph G\u2032 that has a legal labeling L\u2032 that agrees with L outside P and on the two boundary outputs of P, and is locally legal everywhere.\nProof. Let a,b be the boundary outputs of L at P\u2019s ends. Since L restricted to P is legal, M[a,b]=1. As M_{P\u2032}=M, there exists an interior labeling of P\u2032 that starts at a and ends at b and satisfies the local constraints. Assign it; outside outputs remain as in L. All node and edge checks internal to P\u2032 hold by construction; edges crossing the boundaries are unchanged (end outputs a,b are preserved), so remain legal. \u220e\n\nLemma 3 (type automaton construction).\nDefine T_\u03c3(M)=M\u00b7A\u00b7M_\u03c3 for \u03c3\u2208{0,1}, M_\u03c3[a,b]=1 iff a=b and (\u03c3,a)\u2208Cin\u2013out. From seeds {M_0,M_1}, the reachable closure under T_0,T_1 equals the set of all segment types. Its size \u22642^{\u03b2^2}. It can be built in time 2^{O(\u03b2^2)}\u00b7poly(\u03b2).\nProof. The seed matrices are exactly the types of length-1 segments. Every longer segment matrix is an iterated application of the recurrence in Lemma 1. Conversely any matrix reached by the closure corresponds to some input word. The bound and construction follow. \u220e\n\nDefinition (type-feasible middle-gap function).\nLet T be the reachable types. A mapping f_type: T\u00d7{0,1}^2\u00d7T\u2192\u03a3_out^2 is type-feasible if, for every (\u03c4a,\u03c4b,\u03c4c,\u03c4d,S1,S2), writing (x,y)=f_type(\u03c4a,S1,\u03c4b) and (u,v)=f_type(\u03c4c,S2,\u03c4d), the following hold:\n(i) Local windows: U_{S1[1]}[x,x]=U_{S1[2]}[y,y]=1 and A[x,y]=1; similarly U_{S2[1]}[u,u]=U_{S2[2]}[v,v]=1 and A[u,v]=1.\n(ii) Bridge existence: Let Mb=\u03c4b, Mc=\u03c4c. There exist a0,aN,c0,cN\u2208\u03a3_out with A[y,a0]=1, Mb[a0,aN]=1, A[aN,c0]=1, Mc[c0,cN]=1, A[cN,u]=1.\n\nProposition 4 (NEXPTIME decision of \u0398(n) vs O(log* n)).\nGiven (Cin\u2013out,Cout\u2013out), there is a NEXPTIME algorithm that accepts iff there exists a type-feasible f_type. If accepted, the problem has complexity O(log* n); otherwise it is \u0398(n).\nProof. Nondeterministically guess f_type. Verify (i) and (ii) for all tuples (\u03c4a,\u03c4b,\u03c4c,\u03c4d,S1,S2): each check is a bounded number of Boolean matrix products and lookups, hence poly(\u03b2). The domain size is |T|^4\u00b74 \u2264 2^{O(\u03b2^2)}. Building T is EXPTIME. Thus deterministic verification is EXPTIME, and the overall nondeterministic procedure is NEXPTIME. Soundness/completeness follows by the usual feasible-function method (with Lemma 2 replacing pumping): if a feasible function exists then labelling disjoint windows via f_type and solving bridges yields an O(log* n) algorithm, and if none exists then by the gap theorem the complexity is \u0398(n).\n\nObstacles\n\n- Top gap (O(1) vs \u03a9(log* n)) within NEXPTIME: The classical witness (periodic feasible function over all primitive words of length \u2264K) is doubly exponential. We need a compression lemma that reduces this to an exponential certificate in our radius-1, oriented-path setting via transfer matrices.\n- Periodicity characterization: For a type \u03c4, define admissible periodic outputs C(\u03c4) as those c with arbitrarily long repetitions feasible under inputs of type \u03c4. This reduces to checking that c survives all one-symbol filters (U_\u03c3[c,c]=1) occurring in \u03c4 and the edge loop A[c,c]=1; but \u2018occurring in \u03c4\u2019 must be formalized at the type level without unfolding words.\n\nNext steps\n\n1) Formalize per-type admissible periodic outputs.\n- Given \u03c4, define the set of edge-labeled paths in the type automaton that realize \u03c4; characterize, via matrix algebra, the set S(\u03c4)\u2286{0,1} of input symbols that appear with nonzero frequency in any representative of \u03c4 of sufficient length. Show S(\u03c4) is well-defined and computable from \u03c4 and the transitions T_\u03c3.\n- Define C(\u03c4)={c\u2208\u03a3_out | (\u2200\u03c3\u2208S(\u03c4)) U_\u03c3[c,c]=1 and A[c,c]=1}. Lemma to prove: \u03c4 admits arbitrarily long periodic outputs with period c iff c\u2208C(\u03c4).\n\n2) Interface compression.\n- Replace per-word periodic output assignments by per-type selections C(\u03c4) plus a type-based boundary map f_type_const: T\u00d7{0,1}^2\u00d7T\u2192\u03a3_out^2 with the extra constraint that the two outputs chosen are consistent with C(\u03c4) on adjacent long regions. Verify bridges as in the middle-gap check, plus the additional constraint that chosen boundary symbols lie in C(\u03c4b),C(\u03c4c).\n- Prove that existence of such selections implies an O(1)-round algorithm (decompose into short windows and long periodic regions), and conversely that O(1) solvability implies existence of such a selection. All checks are matrix-computable, yielding NEXPTIME.\n\n3) Sanity automata.\n- Implement and test on small \u03b2 with exhaustive enumeration to validate that the type automaton, feasibility checks, and bridge conditions match the known classifications on toy instances.\n\nWhy useful here\n\n- Lemma 1\u20132 provide a strictly smaller type space (2^{\u03b2^2}) and a clean replacement property tailored to radius-1 on oriented paths, enabling EXPTIME verification steps.\n- Proposition 4 supplies a concrete NEXPTIME procedure for separating \u0398(n) from O(log* n).\n- The proposed compression for O(1) vs \u03a9(log* n) outlines an exponential-size certificate verifiable via matrix checks, plausibly yielding a full NEXPTIME trichotomy.\n\n"
}