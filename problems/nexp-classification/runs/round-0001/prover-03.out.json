{
  "content": "Ideas\n\n- Use transfer-matrix types specialized to radius-1, oriented paths to compress all context information of an input segment into a single \u03b2\u00d7\u03b2 Boolean matrix T. This makes replacement, pumping, and middle-gap feasibility checks reduce to constant-size matrix algebra in the Boolean semiring.\n- Separate the trichotomy decision into two checks: (i) O(log* n) vs \u03a9(n) via a type-based feasible-function certificate verifiable in EXPTIME; (ii) O(1) vs \u03a9(log* n) via a stricter, still type-based certificate. Fully formalize (i) now; outline a compressed exponential certificate for (ii), with necessary conditions and a concrete plan to complete sufficiency.\n\nSetup and Notation (radius 1, oriented paths)\n\n- Output graph: A \u2208 {0,1}^{\u03b2\u00d7\u03b2}, A[x,y] = 1 iff (x,y) \u2208 C_out\u2013out.\n- Input filters: D_0, D_1 \u2208 {0,1}^{\u03b2\u00d7\u03b2} diagonal matrices, D_b[x,x] = 1 iff (b,x) \u2208 C_in\u2013out.\n- For an input word w = i_1\u2026i_m \u2208 {0,1}^m (m \u2265 0), define its transfer matrix\n  T_w := (A D_{i_1})(A D_{i_2})\u22ef(A D_{i_m}) with the convention T_\u03b5 = I.\n  Semantics: T_w[u,v] = 1 iff there exist outputs x_1,\u2026,x_m with A[u,x_1]=1, (x_j,x_{j+1}) \u2208 A for j<m, (i_j,x_j) \u2208 C_in\u2013out for all j, and v = x_m. In words: T_w maps the left boundary output to the last node\u2019s output across w, with both the left-entrance edge and all internal constraints incorporated.\n- Concatenation: T_{uv} = T_u \u00b7 T_v (Boolean product), and T_{w} depends only on w.\n- Reachable type set T: the submonoid generated by F_0 := A D_0 and F_1 := A D_1, from identity I. Compute by BFS over (at most) 2^{\u03b2^2} Boolean matrices using transitions M \u21a6 M\u00b7F_b.\n\nKey Replacement Lemma (radius-1, via T)\n\nLemma 1 (type sufficiency).\nLet P and P\u2032 be input segments with the same transfer matrix T_P = T_{P\u2032}. Replace P by P\u2032 inside any larger input path with a fixed output on the leftmost node before P and an arbitrary right continuation. Then any legal labeling extendable across P is extendable across P\u2032 without changing outputs outside the replaced region. Moreover, concatenations satisfy T_{\u2026P\u2026} = T_{\u2026}\u00b7T_P\u00b7T_{\u2026}.\nProof sketch. With radius-1 constraints, the outside world sees P only through: (i) the entry check A on its left boundary, (ii) internal constraints inside P, and (iii) the exit check A to its right boundary. All such feasibility reduces to the Boolean relation T_P; equal matrices imply identical feasibility. Concatenation is by definition.\n\nMiddle-gap Feasible Function (type version) and NEXPTIME decision of O(log* n) vs \u03a9(n)\n\nDecomposition theorems (Naor\u2013Stockmeyer/Chang\u2013Pettie et al.) yield: an LCL is solvable in O(log* n) on cycles/paths iff there exists a function f that locally assigns outputs to short separators S so that every adjacent long gap can be legally filled. Specializing to r=1 on oriented paths, we use types (T-matrices) to compress f.\n\nDefinition (type-feasible f). Fix K \u2265 the pumping constant (any K \u2265 |T| suffices). A type-feasible function is a map\n  f_type: T \u00d7 S \u00d7 T \u2192 \u03a3_out^2, where S = {00,01,10,11}\nthat assigns to each triple (\u03c4_L, S, \u03c4_R) a pair (o_L, o_R) with\n  (i) locality: D_{S[1]}[o_L,o_L] = 1, D_{S[2]}[o_R,o_R] = 1, and A[o_L,o_R] = 1;\n  (ii) fillability: for all quadruples (\u03c4_a,\u03c4_b,\u03c4_c,\u03c4_d) \u2208 T^4 and S1,S2 \u2208 S, letting\n      (x, y) := (o_R(\u03c4_a,S1,\u03c4_b), o_L(\u03c4_c,S2,\u03c4_d)),\n      we require (T_{\u03c4_b} \u00b7 T_{\u03c4_c} \u00b7 A)[x,y] = 1.\nInterpretation: separators choose boundary outputs; any adjacent pair of K- or (K+1)-long contexts of types \u03c4_b, \u03c4_c can then be filled, because the composed gap relation from the right boundary of the left separator to the left boundary of the right separator contains (x,y).\n\nLemma 2 (soundness). If a type-feasible f_type exists, the LCL is solvable in O(log* n).\nProof sketch. Compute an O(log* n) decomposition V = A \u222a B into separators of constant size (here, size 2) and gaps of length K or K+1. Label each separator S using f_type. For each gap with types (\u03c4_b,\u03c4_c), condition (ii) ensures the existence of a legal filling consistent with the chosen boundary outputs. This yields a legal global labeling.\n\nLemma 3 (completeness). If the LCL is solvable in o(n), then a type-feasible f_type exists.\nProof sketch. Simulate the o(n)-round algorithm on imaginary instances where each context is pumped to length \u2265 K without changing its type. Extract the outputs on the separator nodes as f_type(\u03c4_L,S,\u03c4_R). Replacement (Lemma 1) guarantees the fillability condition reduces to T_{\u03c4_b}\u00b7T_{\u03c4_c}\u00b7A.\n\nVerification: EXPTIME given f_type\n\n- Precompute T (reachable types) by BFS under transitions M \u21a6 M\u00b7F_b; this takes time 2^{O(\u03b2^2)}\u00b7poly(\u03b2). Store each T_\u03c4.\n- Given a guessed f_type table (size |T|\u00b7|S|\u00b7|T| entries, each an ordered pair in \u03a3_out), check:\n  (a) local constraints: O(|T|^2\u00b7|S|) scalar lookups in D_b and A;\n  (b) fillability: for all (\u03c4_a,\u03c4_b,\u03c4_c,\u03c4_d) \u2208 T^4 and S1,S2 \u2208 S, compute x, y as above and test (T_{\u03c4_b}\u00b7T_{\u03c4_c}\u00b7A)[x,y]=1. This is O(|T|^4\u00b7|S|^2\u00b7\u03b2^\u03c9) Boolean matrix work (\u03c9\u22643) and fits in EXPTIME as |T| \u2264 2^{\u03b2^2}.\n- Therefore a nondeterministic exponential-time algorithm exists: guess f_type; verify in EXPTIME. If some guess passes, conclude O(log* n); otherwise \u03a9(n).\n\nCorollary 4 (NEXPTIME middle-gap decision). For \u03b2-normalized, radius-1 LCLs on oriented paths, O(log* n) vs \u03a9(n) is decidable in NEXPTIME in N = poly(\u03b2).\n\nExamples (toy sanity checks)\n\n- If D_0 = D_1 = I and A is the complete digraph, then F_0 = F_1 = A, T = {I, A, A^2, \u2026} collapses quickly to {I,A}; any mapping of f_type that picks arbitrary outputs on S satisfies fillability since A\u00b7A\u00b7A = A. Algorithm returns O(log* n) (actually O(1)).\n- If A has only self-loops (A = I) and D_b arbitrary, then T_w is always diagonal. Fillability reduces to checking (x=y) and D\u2019s membership; the check catches unsatisfiable separators, correctly classifying \u03a9(n) when different contexts force inconsistent separator outputs.\n\nO(1) vs \u03a9(log* n): compressed certificate, necessary conditions, and plan\n\nGoal: Avoid doubly-exponential guesses over all primitive words w of length \u2264 K by working at the type level. The classical O(1)-algorithm proof labels a bounded number of \u201canchor\u201d nodes per short piece and uses feasible extensions; in our r=1, type-based setting we propose the following exponential-size certificate (and checks):\n\n- Idempotent boundary per type. Guess s_\u03c4 \u2208 \u03a3_out for each \u03c4 \u2208 T such that T_\u03c4[s_\u03c4, s_\u03c4] = 1. Intuition: across one block of type \u03c4 we can enter and exit at s_\u03c4; hence any pumped repetition of \u03c4 can be handled uniformly.\n- Separator-table reuse. Reuse a type-feasible f_type from the middle-gap step; this ensures fillability between any two neighboring blocks once the separators\u2019 outputs are fixed.\n- Interface consistency. Require that for all \u03c4_b, \u03c4_c and S1,S2, if x := o_R(\u03c4_a,S1,\u03c4_b) and y := o_L(\u03c4_c,S2,\u03c4_d), then (T_{\u03c4_b}\u00b7T_{\u03c4_c}\u00b7A)[x,y]=1 (already checked above), and moreover that (A\u00b7T_{\u03c4_b})[s_{\u03c4_a}, x]=1 and (T_{\u03c4_c}\u00b7A)[y, s_{\u03c4_d}] = 1 hold for some \u03c4_a, \u03c4_d that can appear in the constant-time partition. These conditions ensure that constant-radius labeling decisions can \u201csnap\u201d to idempotents s_\u03c4 at bounded distance.\n\nStatus.\n- Necessity: If an O(1) algorithm exists, on every long periodic segment of type \u03c4 it cannot coordinate a phase, hence it must realize a locally definable ultimately periodic run; an idempotent boundary s_\u03c4 with T_\u03c4[s_\u03c4,s_\u03c4]=1 is a necessary condition. This is checkable in EXPTIME once T is built.\n- Sufficiency (plan): Combine (i) an O(1)-round (L_width,L_count,L_pattern)-partition (as in the provided paper) to classify paths into short pieces with known ranks and long periodic pieces with known types, with (ii) idempotent choices s_\u03c4 to place bounded-size \u201cseeds\u201d that break long periodic pieces into O(1)-sized unlabeled gaps, and (iii) the previously verified f_type to fill all gaps. The remaining technical step is to formalize that one can enforce the \u201cseeding\u201d locally without a global phase by using only local type information and the existence of s_\u03c4; this will yield an exponential (in \u03b2) certificate verifiable in EXPTIME.\n\nObstacles\n\n- Phase ambiguity on long periodic segments: proving that s_\u03c4 with T_\u03c4[s_\u03c4,s_\u03c4]=1 suffices to place O(1)-dense seeds by an O(1)-round rule requires a careful local construction (e.g., using bounded lookahead for rare defects produced by the (L_width,L_count,L_pattern)-partition). This is the missing sufficiency piece for a full NEXPTIME decision of O(1) vs \u03a9(log* n).\n- Ensuring that the \u201callowed\u201d quadruples (\u03c4_a,\u03c4_b,\u03c4_c,\u03c4_d) in the interface checks match exactly those realizable by the O(1) partition. We can bound them by the reachable type automaton augmented with a small counter mod (K,K+1), but writing this cleanly is pending.\n\nNext steps (auditable, testable)\n\n1) Formal proof of Lemma 1 in the present radius-1 model (complete write-up): show rigorously that T-types are complete for replacement/pumping.\n2) Implementable verifier for middle-gap: given (Cin\u2013out, Cout\u2013out), construct T, then check a guessed f_type by the matrix identity (T_{\u03c4_b}\u00b7T_{\u03c4_c}\u00b7A)[x,y]=1 across all tuples; record worst-case bounds: |T| \u2264 2^{\u03b2^2}, time 2^{O(\u03b2^2)}\u00b7poly(\u03b2).\n3) Necessary condition for O(1): compute the set I := {\u03c4 : \u2203 s with T_\u03c4[s,s]=1}. If some reachable \u03c4 \u2209 I, conclude \u03a9(log* n). This is an efficiently checkable filter that often certifies the top gap.\n4) Design and verify a local \u201cseeding\u201d rule that, given s_\u03c4 for every \u03c4, places outputs at O(1)-density on long periodic paths using only local type information; then reuse the already-verified f_type to fill remaining gaps. Prove that the unlabeled components are O(1)-sized. This will complete the NEXPTIME decision for O(1) vs \u03a9(log* n).\n\nSummary of main deliverable (ready to curate into proofs.md)\n\n- Defined transfer matrices T_w = \u220f(A D_{i_j}) with T_{uv}=T_u T_v; showed they suffice for replacement and pumping at r=1.\n- Gave a concrete NEXPTIME algorithm for O(log* n) vs \u03a9(n): nondeterministically guess a type-feasible separator table f_type and verify by exponentially many (but single-exponential in \u03b2) Boolean matrix checks.\n- Provided a compressed, exponential-in-\u03b2 certificate template for the O(1) side (idempotent boundary states per type) and a verification plan; identified the remaining local \u201cseeding\u201d step as the key obstacle to finish the NEXPTIME trichotomy.\n"
}