Ideas

- Use transfer-matrix types specialized to radius-1, oriented paths to compress all context information of an input segment into a single β×β Boolean matrix T. This makes replacement, pumping, and middle-gap feasibility checks reduce to constant-size matrix algebra in the Boolean semiring.
- Separate the trichotomy decision into two checks: (i) O(log* n) vs Ω(n) via a type-based feasible-function certificate verifiable in EXPTIME; (ii) O(1) vs Ω(log* n) via a stricter, still type-based certificate. Fully formalize (i) now; outline a compressed exponential certificate for (ii), with necessary conditions and a concrete plan to complete sufficiency.

Setup and Notation (radius 1, oriented paths)

- Output graph: A ∈ {0,1}^{β×β}, A[x,y] = 1 iff (x,y) ∈ C_out–out.
- Input filters: D_0, D_1 ∈ {0,1}^{β×β} diagonal matrices, D_b[x,x] = 1 iff (b,x) ∈ C_in–out.
- For an input word w = i_1…i_m ∈ {0,1}^m (m ≥ 0), define its transfer matrix
  T_w := (A D_{i_1})(A D_{i_2})⋯(A D_{i_m}) with the convention T_ε = I.
  Semantics: T_w[u,v] = 1 iff there exist outputs x_1,…,x_m with A[u,x_1]=1, (x_j,x_{j+1}) ∈ A for j<m, (i_j,x_j) ∈ C_in–out for all j, and v = x_m. In words: T_w maps the left boundary output to the last node’s output across w, with both the left-entrance edge and all internal constraints incorporated.
- Concatenation: T_{uv} = T_u · T_v (Boolean product), and T_{w} depends only on w.
- Reachable type set T: the submonoid generated by F_0 := A D_0 and F_1 := A D_1, from identity I. Compute by BFS over (at most) 2^{β^2} Boolean matrices using transitions M ↦ M·F_b.

Key Replacement Lemma (radius-1, via T)

Lemma 1 (type sufficiency).
Let P and P′ be input segments with the same transfer matrix T_P = T_{P′}. Replace P by P′ inside any larger input path with a fixed output on the leftmost node before P and an arbitrary right continuation. Then any legal labeling extendable across P is extendable across P′ without changing outputs outside the replaced region. Moreover, concatenations satisfy T_{…P…} = T_{…}·T_P·T_{…}.
Proof sketch. With radius-1 constraints, the outside world sees P only through: (i) the entry check A on its left boundary, (ii) internal constraints inside P, and (iii) the exit check A to its right boundary. All such feasibility reduces to the Boolean relation T_P; equal matrices imply identical feasibility. Concatenation is by definition.

Middle-gap Feasible Function (type version) and NEXPTIME decision of O(log* n) vs Ω(n)

Decomposition theorems (Naor–Stockmeyer/Chang–Pettie et al.) yield: an LCL is solvable in O(log* n) on cycles/paths iff there exists a function f that locally assigns outputs to short separators S so that every adjacent long gap can be legally filled. Specializing to r=1 on oriented paths, we use types (T-matrices) to compress f.

Definition (type-feasible f). Fix K ≥ the pumping constant (any K ≥ |T| suffices). A type-feasible function is a map
  f_type: T × S × T → Σ_out^2, where S = {00,01,10,11}
that assigns to each triple (τ_L, S, τ_R) a pair (o_L, o_R) with
  (i) locality: D_{S[1]}[o_L,o_L] = 1, D_{S[2]}[o_R,o_R] = 1, and A[o_L,o_R] = 1;
  (ii) fillability: for all quadruples (τ_a,τ_b,τ_c,τ_d) ∈ T^4 and S1,S2 ∈ S, letting
      (x, y) := (o_R(τ_a,S1,τ_b), o_L(τ_c,S2,τ_d)),
      we require (T_{τ_b} · T_{τ_c} · A)[x,y] = 1.
Interpretation: separators choose boundary outputs; any adjacent pair of K- or (K+1)-long contexts of types τ_b, τ_c can then be filled, because the composed gap relation from the right boundary of the left separator to the left boundary of the right separator contains (x,y).

Lemma 2 (soundness). If a type-feasible f_type exists, the LCL is solvable in O(log* n).
Proof sketch. Compute an O(log* n) decomposition V = A ∪ B into separators of constant size (here, size 2) and gaps of length K or K+1. Label each separator S using f_type. For each gap with types (τ_b,τ_c), condition (ii) ensures the existence of a legal filling consistent with the chosen boundary outputs. This yields a legal global labeling.

Lemma 3 (completeness). If the LCL is solvable in o(n), then a type-feasible f_type exists.
Proof sketch. Simulate the o(n)-round algorithm on imaginary instances where each context is pumped to length ≥ K without changing its type. Extract the outputs on the separator nodes as f_type(τ_L,S,τ_R). Replacement (Lemma 1) guarantees the fillability condition reduces to T_{τ_b}·T_{τ_c}·A.

Verification: EXPTIME given f_type

- Precompute T (reachable types) by BFS under transitions M ↦ M·F_b; this takes time 2^{O(β^2)}·poly(β). Store each T_τ.
- Given a guessed f_type table (size |T|·|S|·|T| entries, each an ordered pair in Σ_out), check:
  (a) local constraints: O(|T|^2·|S|) scalar lookups in D_b and A;
  (b) fillability: for all (τ_a,τ_b,τ_c,τ_d) ∈ T^4 and S1,S2 ∈ S, compute x, y as above and test (T_{τ_b}·T_{τ_c}·A)[x,y]=1. This is O(|T|^4·|S|^2·β^ω) Boolean matrix work (ω≤3) and fits in EXPTIME as |T| ≤ 2^{β^2}.
- Therefore a nondeterministic exponential-time algorithm exists: guess f_type; verify in EXPTIME. If some guess passes, conclude O(log* n); otherwise Ω(n).

Corollary 4 (NEXPTIME middle-gap decision). For β-normalized, radius-1 LCLs on oriented paths, O(log* n) vs Ω(n) is decidable in NEXPTIME in N = poly(β).

Examples (toy sanity checks)

- If D_0 = D_1 = I and A is the complete digraph, then F_0 = F_1 = A, T = {I, A, A^2, …} collapses quickly to {I,A}; any mapping of f_type that picks arbitrary outputs on S satisfies fillability since A·A·A = A. Algorithm returns O(log* n) (actually O(1)).
- If A has only self-loops (A = I) and D_b arbitrary, then T_w is always diagonal. Fillability reduces to checking (x=y) and D’s membership; the check catches unsatisfiable separators, correctly classifying Ω(n) when different contexts force inconsistent separator outputs.

O(1) vs Ω(log* n): compressed certificate, necessary conditions, and plan

Goal: Avoid doubly-exponential guesses over all primitive words w of length ≤ K by working at the type level. The classical O(1)-algorithm proof labels a bounded number of “anchor” nodes per short piece and uses feasible extensions; in our r=1, type-based setting we propose the following exponential-size certificate (and checks):

- Idempotent boundary per type. Guess s_τ ∈ Σ_out for each τ ∈ T such that T_τ[s_τ, s_τ] = 1. Intuition: across one block of type τ we can enter and exit at s_τ; hence any pumped repetition of τ can be handled uniformly.
- Separator-table reuse. Reuse a type-feasible f_type from the middle-gap step; this ensures fillability between any two neighboring blocks once the separators’ outputs are fixed.
- Interface consistency. Require that for all τ_b, τ_c and S1,S2, if x := o_R(τ_a,S1,τ_b) and y := o_L(τ_c,S2,τ_d), then (T_{τ_b}·T_{τ_c}·A)[x,y]=1 (already checked above), and moreover that (A·T_{τ_b})[s_{τ_a}, x]=1 and (T_{τ_c}·A)[y, s_{τ_d}] = 1 hold for some τ_a, τ_d that can appear in the constant-time partition. These conditions ensure that constant-radius labeling decisions can “snap” to idempotents s_τ at bounded distance.

Status.
- Necessity: If an O(1) algorithm exists, on every long periodic segment of type τ it cannot coordinate a phase, hence it must realize a locally definable ultimately periodic run; an idempotent boundary s_τ with T_τ[s_τ,s_τ]=1 is a necessary condition. This is checkable in EXPTIME once T is built.
- Sufficiency (plan): Combine (i) an O(1)-round (L_width,L_count,L_pattern)-partition (as in the provided paper) to classify paths into short pieces with known ranks and long periodic pieces with known types, with (ii) idempotent choices s_τ to place bounded-size “seeds” that break long periodic pieces into O(1)-sized unlabeled gaps, and (iii) the previously verified f_type to fill all gaps. The remaining technical step is to formalize that one can enforce the “seeding” locally without a global phase by using only local type information and the existence of s_τ; this will yield an exponential (in β) certificate verifiable in EXPTIME.

Obstacles

- Phase ambiguity on long periodic segments: proving that s_τ with T_τ[s_τ,s_τ]=1 suffices to place O(1)-dense seeds by an O(1)-round rule requires a careful local construction (e.g., using bounded lookahead for rare defects produced by the (L_width,L_count,L_pattern)-partition). This is the missing sufficiency piece for a full NEXPTIME decision of O(1) vs Ω(log* n).
- Ensuring that the “allowed” quadruples (τ_a,τ_b,τ_c,τ_d) in the interface checks match exactly those realizable by the O(1) partition. We can bound them by the reachable type automaton augmented with a small counter mod (K,K+1), but writing this cleanly is pending.

Next steps (auditable, testable)

1) Formal proof of Lemma 1 in the present radius-1 model (complete write-up): show rigorously that T-types are complete for replacement/pumping.
2) Implementable verifier for middle-gap: given (Cin–out, Cout–out), construct T, then check a guessed f_type by the matrix identity (T_{τ_b}·T_{τ_c}·A)[x,y]=1 across all tuples; record worst-case bounds: |T| ≤ 2^{β^2}, time 2^{O(β^2)}·poly(β).
3) Necessary condition for O(1): compute the set I := {τ : ∃ s with T_τ[s,s]=1}. If some reachable τ ∉ I, conclude Ω(log* n). This is an efficiently checkable filter that often certifies the top gap.
4) Design and verify a local “seeding” rule that, given s_τ for every τ, places outputs at O(1)-density on long periodic paths using only local type information; then reuse the already-verified f_type to fill remaining gaps. Prove that the unlabeled components are O(1)-sized. This will complete the NEXPTIME decision for O(1) vs Ω(log* n).

Summary of main deliverable (ready to curate into proofs.md)

- Defined transfer matrices T_w = ∏(A D_{i_j}) with T_{uv}=T_u T_v; showed they suffice for replacement and pumping at r=1.
- Gave a concrete NEXPTIME algorithm for O(log* n) vs Ω(n): nondeterministically guess a type-feasible separator table f_type and verify by exponentially many (but single-exponential in β) Boolean matrix checks.
- Provided a compressed, exponential-in-β certificate template for the O(1) side (idempotent boundary states per type) and a verification plan; identified the remaining local “seeding” step as the key obstacle to finish the NEXPTIME trichotomy.
