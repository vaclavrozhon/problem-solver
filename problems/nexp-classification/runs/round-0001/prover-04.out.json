{
  "content": "Ideas\n- Specialize the \u201ctype/feasible-function\u201d machinery to \u03b2-normalized, radius-1 LCLs on globally oriented paths via transfer matrices. This compresses types to \u03b2\u00d7\u03b2 Boolean matrices and lets us replace any long string-based quantification by matrix equations, keeping all checks within single-exponential time in \u03b2.\n- Give a complete NEXPTIME procedure for the \u0398(n) vs O(log* n) dichotomy: nondeterministically guess a type-based feasible function of exponential size and verify it deterministically in EXPTIME.\n- Provide clean, radius-1 specific lemmas: (i) concatenation equals Boolean matrix product, (ii) replacement depends only on the transfer matrix, (iii) middle-gap feasibility reduces to a single Boolean scalar check per tuple of types.\n- Outline a compression target for the O(1) vs \u03a9(log* n) case that should fit NEXPTIME: per-type periodic-output annotations plus interface-compatibility checks via matrix algebra; defer full proof to next steps.\n\nSetup and Definitions (radius-1, oriented paths)\nLet \u03a3in={0,1}, \u03a3out of size \u03b2, with constraints Cin\u2013out\u2286\u03a3in\u00d7\u03a3out and Cout\u2013out\u2286\u03a3out\u00d7\u03a3out. Let A\u2208{0,1}^{\u03b2\u00d7\u03b2} be the adjacency matrix of Cout\u2013out: A[x,y]=1 iff (x,y)\u2208Cout\u2013out. Let D0,D1\u2208{0,1}^{\u03b2\u00d7\u03b2} be diagonal: Ds[z,z]=1 iff (s,z)\u2208Cin\u2013out.\nGiven an input word w=s1\u2026sk\u2208{0,1}^k (k\u22651), define its transfer matrix\nM(w)=D_{s1}\u00b7A\u00b7D_{s2}\u00b7A\u00b7\u2026\u00b7A\u00b7D_{sk}  (Boolean semiring).\nSemantics: M(w)[a,b]=1 iff there exists outputs y1= a,\u2026, yk= b such that (si,yi)\u2208Cin\u2013out and (yi,yi+1)\u2208Cout\u2013out for i=1..k\u22121. Thus the \u201ctype\u201d of w is exactly M(w).\nTransitions. Appending a bit s to w updates M by \u03b4(M,s)=M\u00b7A\u00b7Ds. Let T be the set of matrices reachable from {D0,D1} by repeated \u03b4(\u00b7,0/1).\n\nBasic Lemmas (radius-1 specific)\nLemma 1 (Concatenation = product). For words u,v, M(uv)=M(u)\u00b7M(v).\nProof: Expand the product; the middle adjacency between u and v contributes exactly one A factor bridging the last output of u and first of v, and the diagonals ensure node-wise Cin\u2013out. Standard Boolean path-composition argument.\n\nLemma 2 (Replacement by matrix type). Let P be an input fragment labeled by w with M(w)=M, and let Q be any fragment with M(Q)=M. Suppose the environment fixes the boundary outputs (left end a, right end b) and is locally consistent with a to the left and b to the right. Then replacing P by Q preserves global legality: fill the interior of Q by any witness path for M[a,b]=1. All radius-1 constraints are preserved since only the endpoint outputs interact with the environment.\n\nLemma 3 (Pumping by types). If two words have the same matrix, they are interchangeable. The set T of matrices reachable under \u03b4 from {D0,D1} is finite, |T|\u22642^{\u03b2^2}. Thus a standard DFA pumping lemma applies over {0,1} with state space T.\n\nMiddle-gap feasible function (type version)\nFix r=1, so S has length 2. Let S=(sL,sR)\u2208{0,1}^2. Let Good(S)\u2286\u03a3out^2 be the set of local output pairs (u,v) such that (sL,u)\u2208Cin\u2013out, (u,v)\u2208Cout\u2013out, (sR,v)\u2208Cin\u2013out.\nDefine a type-feasible function as any mapping g: T\u00d7{0,1}^2\u00d7T\u2192\u03a3out^2 such that g(\u03c4L,S,\u03c4R)\u2208Good(S) for all inputs and the following middle-gap property holds: For every quadruple \u03c4a,\u03c4b,\u03c4c,\u03c4d\u2208T and S1,S2\u2208{0,1}^2, writing g(\u03c4a,S1,\u03c4b)=(a1,a2) and g(\u03c4c,S2,\u03c4d)=(b1,b2), we require\nL_{a2} \u00b7 \u03c4b \u00b7 A \u00b7 \u03c4c \u00b7 v_{b1} = 1 (Boolean scalar),\nwhere L_{a2} is the row-filter with L_{a2}[x]=1 iff A[a2,x]=1, and v_{b1} is the column-filter with v_{b1}[y]=1 iff A[y,b1]=1. Intuition: we must be able to bridge from the last output of S1 through w_b, then an adjacency edge, then w_c, to reach the first output of S2.\n\nLemma 4 (Equivalence to string-feasible function). For \u03b2-normalized radius-1 on oriented paths, the existence of the Chang\u2013Pettie\u2013Suh type \u201cfeasible function\u201d (that labels two S-windows so every long enough middle gap of types \u03c4b,\u03c4c can be filled) is equivalent to the existence of g as above.\nProof sketch: \u201c\u21d2\u201d If a string-feasible function f exists, fix representatives w of each \u03c4 with M(w)=\u03c4; define g(\u03c4L,S,\u03c4R)=f(wL S wR) on these representatives. By Lemma 2, replacing wL,wR by any same-type strings preserves fillability; thus the matrix condition must hold. \u201c\u21d0\u201d Given g, apply the standard O(log* n) construction: label S-windows by g, then fill each middle gap using the matrix scalar check; correctness follows from Lemma 2.\n\nDeciding \u0398(n) vs O(log* n) in NEXPTIME\nAlgorithm (nondeterministic):\n1) Construct T. Start with {D0,D1}, repeatedly insert \u03b4(M,0), \u03b4(M,1) until closure. Cost: \u2264|T|\u00b7poly(\u03b2)=2^{O(\u03b2^2)} time and space; each \u03b4 is a Boolean matrix multiply by A\u00b7Ds in poly(\u03b2).\n2) Guess g: For each (\u03c4L,S,\u03c4R)\u2208T\u00d7{0,1}^2\u00d7T, choose g(\u03c4L,S,\u03c4R)\u2208Good(S). Table size: |T|^2\u00b74 entries, each with O(log \u03b2) bits \u21d2 2^{O(\u03b2^2)} bits.\n3) Verify middle-gap property: For all \u03c4a,\u03c4b,\u03c4c,\u03c4d\u2208T and S1,S2\u2208{0,1}^2, compute L_{a2}\u00b7\u03c4b\u00b7A\u00b7\u03c4c\u00b7v_{b1} and accept only if the result is 1. Number of checks: 4\u00b7|T|^4=2^{O(\u03b2^2)}; each check is O(\u03b2^3).\nAccept iff all checks pass. Soundness/completeness follow from Lemma 4 and Lemma 2.\nComplexity: Step 1 is EXPTIME, Step 2 is an exponential guess, Step 3 is EXPTIME. Thus the overall decision \u201cexists g?\u201d is in NEXPTIME in N=poly(\u03b2). If yes \u21d2 complexity O(log* n); if no \u21d2 complexity \u0398(n).\n\nProof obligation for Step 3 formula\nGiven g(\u03c4a,S1,\u03c4b)=(a1,a2) and g(\u03c4c,S2,\u03c4d)=(b1,b2): the middle-fill must choose an output x for the first node of w_b with A[a2,x]=1, traverse w_b (matrix \u03c4b), then traverse an adjacency edge A, then traverse w_c (matrix \u03c4c), and finally reach some y with A[y,b1]=1 for the handover to S2. The Boolean scalar L_{a2}\u00b7\u03c4b\u00b7A\u00b7\u03c4c\u00b7v_{b1} encodes this existential condition exactly.\n\nExamples / sanity checks\n- If A is the complete digraph on \u03a3out and Cin\u2013out is unconstrained, then \u03c4b=\u03c4c=J (all-ones). Any choice g with Good(S) respected passes since L_{a2}\u00b7J\u00b7A\u00b7J\u00b7v_{b1}=1 always holds.\n- If Cout\u2013out enforces proper 2-coloring on outputs and Cin\u2013out imposes no restriction, then the middle-gap property fails for any g (requires parity coordination), and the algorithm reports \u0398(n), as expected.\n\nObstacles for O(1) vs \u03a9(log* n)\n- The standard approach requires choosing periodic outputs for each input period w with |w|\u2264K (K exponential), yielding a doubly-exponential witness.\n- With transfer matrices, we can compress to per-type annotations: for each \u03c4\u2208T, characterize the set of admissible periodic output cycles in the output digraph constrained by Ds along the period. Interfaces through short windows can be enforced by matrix products as above. However, we still need a compression lemma: if a constant-time feasible function exists, then there is an exponential-size certificate over T (e.g., select a periodic output descriptor per \u03c4) verifiable by EXPTIME matrix and automata checks.\n\nProposed plan for the top gap (sketch)\n- For each \u03c4\u2208T, the set of admissible output cycles for any period w with M(w)=\u03c4 equals the set of cycles in the labeled product automaton built from the output graph (A) and the Ds sequence of one representative of \u03c4; this depends only on \u03c4 (by Lemma 2). Represent this set by a finite annotation U(\u03c4) (e.g., the SCCs/cycles supported).\n- Guess U(\u03c4) for all \u03c4, with size 2^{O(\u03b2^2)}. Verify internally: U(\u03c4) is nonempty iff the product automaton has a cycle consistent with Ds pattern of \u03c4. Verify interface compatibility across short contexts by equations of the form L\u00b7\u03c4b\u00b7A\u00b7\u03c4c\u00b7v plus constraints that the chosen periodic outputs belong to U(\u03c4b), U(\u03c4c). This stays within EXPTIME per check.\n- If such U exists, conclude O(1); else \u03a9(log* n). We will formalize U and the checks next.\n\nNext steps\n- Write and verify the full proof of Lemma 4 (both directions) rigorously, including the minor detail that only S of length 2 is needed at radius 1.\n- Formalize the per-type periodic-output descriptor U(\u03c4), show it is computable and checkable from \u03c4 alone, and prove the compression lemma: existence of a string-based constant-time feasible function implies existence of an exponential U.\n- Integrate both stages into a single NEXPTIME trichotomy algorithm: (i) test O(1) via U (once formalized); (ii) if not, test O(log* n) via g; else \u0398(n).\n"
}