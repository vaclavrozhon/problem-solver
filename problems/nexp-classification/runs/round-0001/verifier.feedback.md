Overall, all four provers converged on the right abstraction for radius‑1 oriented paths: Boolean transfer matrices encode exactly the observable interface of a segment. This yields a finite type automaton with at most 2^{β^2} states and enables EXPTIME verification of exponentially large certificates, which is the right scale for a NEXPTIME procedure in N = poly(β).

Strengths and correctness:
- The composition law M(P·Q) = M(P)·E·M(Q) and the (matrix) replacement lemma are correct in this setting and suffice to reduce all context reasoning to constant‑size matrix algebra. Multiple provers gave clean statements; we provide a fully rigorous write‑up in proofs.md.
- The middle‑gap certificate f_type and the scalar check (E·M_b·E·M_c·E)[ℓ_2, r_1] = 1 are sound and verifiable in EXPTIME. Enumerating reachable types by BFS under δ(M,i)=M·E·S_i has size ≤ 2^{β^2} and cost 2^{O(β^2)}·poly(β), as required.
- Complexity accounting is consistent: guessing f_type of size 2^{Θ(β^2)} bits and verifying all tuples in EXPTIME gives a NEXPTIME decision for O(log* n) vs Θ(n).

Key fix for completeness: Restrict gap types to lengths K or K+1. The decomposition produces gaps of length K or K+1 (for K ≥ the pumping constant). Some proofs/checks above quantified over all reachable types T; this is stronger than necessary and can cause false negatives. Compute R_K and R_{K+1} (types reachable by exactly K, K+1 symbols) and restrict the bridge checks to τ_b, τ_c ∈ R_K ∪ R_{K+1}. This restriction preserves soundness and restores completeness of the NEXPTIME test.

Top gap (O(1) vs Ω(log* n)): The proposed per‑type periodic/“idempotent boundary” certificates are promising, but the compression lemma (that reduces the doubly‑exponential word‑period witness to an exponential type‑level certificate) is still missing. We recommend formalizing a type‑monoid viewpoint: compute the finite monoid generated by F_i = E·S_i (or S_i·E, consistently), extract idempotents and SCC structure, and define per‑type admissible periodic outputs via cycles in the output graph constrained by the type. Then prove interface compatibility via constant matrix products (as for the middle gap). This would yield an exponential certificate verifiable in EXPTIME and complete the trichotomy in NEXPTIME.

Concrete next steps:
1) Implement type BFS and computation of R_K, R_{K+1}; finalize the NEXPTIME verifier for O(log* n) vs Θ(n) with the corrected restriction.
2) Finish a fully rigorous replacement lemma and automaton construction (now in proofs.md) and cross‑check with toy β.
3) For O(1) vs Ω(log* n): (a) define admissible periodic sets per type; (b) state and attempt the compression lemma; (c) reduce interface checks to fixed matrix identities; (d) seek counterexamples to refine conditions.
