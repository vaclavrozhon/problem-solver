{"feedback_md":"Overall, all four provers converged on the right abstraction for radius‑1 oriented paths: Boolean transfer matrices encode exactly the observable interface of a segment. This yields a finite type automaton with at most 2^{β^2} states and enables EXPTIME verification of exponentially large certificates, which is the right scale for a NEXPTIME procedure in N = poly(β).\n\nStrengths and correctness:\n- The composition law M(P·Q) = M(P)·E·M(Q) and the (matrix) replacement lemma are correct in this setting and suffice to reduce all context reasoning to constant‑size matrix algebra. Multiple provers gave clean statements; we provide a fully rigorous write‑up in proofs.md.\n- The middle‑gap certificate f_type and the scalar check (E·M_b·E·M_c·E)[ℓ_2, r_1] = 1 are sound and verifiable in EXPTIME. Enumerating reachable types by BFS under δ(M,i)=M·E·S_i has size ≤ 2^{β^2} and cost 2^{O(β^2)}·poly(β), as required.\n- Complexity accounting is consistent: guessing f_type of size 2^{Θ(β^2)} bits and verifying all tuples in EXPTIME gives a NEXPTIME decision for O(log* n) vs Θ(n).\n\nKey fix for completeness: Restrict gap types to lengths K or K+1. The decomposition produces gaps of length K or K+1 (for K ≥ the pumping constant). Some proofs/checks above quantified over all reachable types T; this is stronger than necessary and can cause false negatives. Compute R_K and R_{K+1} (types reachable by exactly K, K+1 symbols) and restrict the bridge checks to τ_b, τ_c ∈ R_K ∪ R_{K+1}. This restriction preserves soundness and restores completeness of the NEXPTIME test.\n\nTop gap (O(1) vs Ω(log* n)): The proposed per‑type periodic/“idempotent boundary” certificates are promising, but the compression lemma (that reduces the doubly‑exponential word‑period witness to an exponential type‑level certificate) is still missing. We recommend formalizing a type‑monoid viewpoint: compute the finite monoid generated by F_i = E·S_i (or S_i·E, consistently), extract idempotents and SCC structure, and define per‑type admissible periodic outputs via cycles in the output graph constrained by the type. Then prove interface compatibility via constant matrix products (as for the middle gap). This would yield an exponential certificate verifiable in EXPTIME and complete the trichotomy in NEXPTIME.\n\nConcrete next steps:\n1) Implement type BFS and computation of R_K, R_{K+1}; finalize the NEXPTIME verifier for O(log* n) vs Θ(n) with the corrected restriction.\n2) Finish a fully rigorous replacement lemma and automaton construction (now in proofs.md) and cross‑check with toy β.\n3) For O(1) vs Ω(log* n): (a) define admissible periodic sets per type; (b) state and attempt the compression lemma; (c) reduce interface checks to fixed matrix identities; (d) seek counterexamples to refine conditions.\n","summary_md":"We unified all provers’ approaches around transfer‑matrix types for radius‑1 oriented paths and wrote rigorous proofs for composition, replacement, and an EXPTIME‑verifiable type‑based feasible function. We corrected a completeness issue by restricting bridge checks to types realized at lengths K or K+1 (the lengths used by the decomposition). This yields a NEXPTIME algorithm for deciding O(log* n) vs Θ(n). The O(1) vs Ω(log* n) step remains pending a compression lemma to turn per‑word periodic witnesses into per‑type exponential certificates; we outlined a concrete monoid/idempotent plan to finish it.","verdict":"uncertain","blocking_issues":["Top-gap compression lemma (per-type periodic certificate) not yet proved; needed to complete trichotomy in NEXPTIME","Middle-gap verifier must restrict τ_b, τ_c to types realized at lengths K or K+1 to avoid false negatives","Need final consistency in definitions (use one of M(w)=S_{w1}·E·…·E·S_{wk} vs T_w=(A D_{i1})…); proofs now fix a consistent convention"],"per_prover":[{"prover_id":"01","brief_feedback":"Solid matrix setup (E, S_i, M_P), correct composition/replacement, and a clear middle‑gap check via (E·M_b·E·M_c·E)[ℓ_2,r_1]. Adjust verification to restrict τ_b,τ_c to types reachable at lengths K or K+1. O(1) vs Ω(log* n) still needs a formal compression lemma.","score":"promising"},{"prover_id":"02","brief_feedback":"Accurate transfer-matrix framework and bridge condition (existential a0,aN,c0,cN) equivalent to the scalar matrix test. Ensure verification ranges only over τ_b,τ_c ∈ R_K∪R_{K+1}. The periodic-output set C(τ) idea is promising but needs precise type-level formalization.","score":"promising"},{"prover_id":"03","brief_feedback":"Clean alternative factorization T_w=(A D_{i1})… and bridge check (T_{τ_b}·T_{τ_c}·A)[x,y]=1; align conventions with S_i,E or keep consistent throughout. Necessary idempotent filter is good; develop it into a full exponential certificate with interface checks.","score":"promising"},{"prover_id":"04","brief_feedback":"Good formalization and an automata‑inclusion angle; the scalar matrix check suffices, but your length‑filter point is crucial—restrict to K,K+1 types. For top gap, formalize U(τ) (admissible cycles) and prove compression, aiming for EXPTIME verification.","score":"promising"}],"notes_update":{"action":"append","content":"Research log – radius‑1 oriented paths via transfer matrices\n\nSetup\n- Outputs Σ_out of size β; inputs Σ_in={0,1}. Let E∈{0,1}^{β×β} with E[x,y]=1 iff (x,y)∈C_out–out. For i∈{0,1}, let S_i be diagonal with (S_i)[x,x]=1 iff (i,x)∈C_in–out.\n- For w=i_1…i_k, define the transfer matrix M(w)=S_{i_1}·E·S_{i_2}·E·…·E·S_{i_k} (Boolean semiring). Two segments have the same type iff their M(·) matrices are equal.\n- Composition: M(P·Q)=M(P)·E·M(Q). Replacement: If M(P)=M(P′), then P and P′ are interchangeable inside any larger instance while keeping outside outputs fixed.\n\nType automaton\n- States: reachable matrices; transitions δ(M,i)=M·E·S_i; seeds {S_0,S_1}. Reachable set T has size ≤2^{β^2}. Build by BFS in 2^{O(β^2)}·poly(β) time.\n- For length awareness, compute R_ℓ (types of words of exact length ℓ) by iterating R_{ℓ+1}={M·E·S_i: M∈R_ℓ, i∈{0,1}}. Let K=|T|; the standard decomposition uses gaps of length K or K+1.\n\nMiddle-gap feasible function (corrected)\n- Certificate: f_type: T×{00,01,10,11}×T→Σ_out^2. For each (τ_L,S,τ_R), outputs (x,y) with local legality: (S[1],x)∈C_in–out, (x,y)∈C_out–out, (S[2],y)∈C_in–out.\n- Bridge check: For all τ_b,τ_c ∈ R_K∪R_{K+1} and S1,S2, letting L1=f_type(·,S1,τ_b)=(ℓ_1,ℓ_2) and L2=f_type(τ_c,S2,·)=(r_1,r_2), require (E·M_{τ_b}·E·M_{τ_c}·E)[ℓ_2,r_1]=1.\n- If such an f_type exists, label length‑2 separators by f_type and fill each gap by the bridge condition, yielding an O(log* n) algorithm; else complexity is Θ(n).\n\nComplexity\n- Build T, R_K, R_{K+1}: EXPTIME. Guess f_type of size 2^{Θ(β^2)}; verify all constraints over τ_b,τ_c∈R_K∪R_{K+1} in EXPTIME. Overall: NEXPTIME.\n\nTop gap (O(1) vs Ω(log* n)) – plan\n- Per-type periodicity: For τ, characterize admissible periodic outputs as cycles in the output digraph constrained by the type τ (computed from the monoid generated by F_i=E·S_i). Guess per‑type selections and check interfaces via fixed products like E·M_{τ_b}·E and M_{τ_c}. Prove a compression lemma: any O(1) feasible mapping admits an exponential per‑type certificate verifiable in EXPTIME.\n\nAction items\n1) Implement T, R_K, R_{K+1} and the NEXPTIME verifier for O(log* n) vs Θ(n).\n2) Formalize per‑type admissible periodic sets and interface constraints; attempt the compression lemma.\n3) Validate on small β instances; probe edge cases (e.g., sparse E, forced outputs in S_i)."},"proofs_update":{"action":"append","content":"Radius‑1 LCLs on oriented paths: matrices, types, and the middle‑gap NEXPTIME decision\n\nDefinitions\n- Let Σ_in={0,1}, |Σ_out|=β. Define E∈{0,1}^{β×β} by E[x,y]=1 ⇔ (x,y)∈C_out–out. For i∈{0,1}, define S_i as the β×β diagonal matrix with (S_i)[x,x]=1 ⇔ (i,x)∈C_in–out.\n- For a word w=i_1…i_k (k≥1), define its transfer matrix M(w)=S_{i_1}·E·S_{i_2}·E·…·E·S_{i_k} over the Boolean semiring. Two words have the same type iff their transfer matrices are equal. For a segment P with input word w, write M_P:=M(w).\n\nLemma 1 (Composition).\nFor any segments P,Q, M_{P·Q}=M_P·E·M_Q.\nProof. Immediate by definition and associativity: concatenation introduces exactly one E between the blocks.\n\nLemma 2 (Replacement).\nLet G be an oriented path or cycle, P⊆G a subpath, and P′ another segment with M_{P′}=M_P. Fix a legal labeling of G that is locally consistent everywhere and fix the outputs on the two nodes adjacent to P (call them a on the left boundary edge and c on the right boundary edge). Then G admits a legal relabeling after replacing P by P′ that preserves all outputs outside P/P′ (and the two boundary outputs), if and only if there exist u,v∈Σ_out with E[a,u]=1, M_P[u,v]=1, and E[v,c]=1. In particular, if the original labeling labels P legally, such u,v exist, and the relabeling exists with P′.\nProof. Necessity is clear from the run across P. For sufficiency, pick any u,v with E[a,u]=1, M_{P′}[u,v]=1 (equal to M_P[u,v]=1), and E[v,c]=1; label P′ internally by a witness for M_{P′}[u,v]=1. All internal node/edge checks hold by construction; cross‑boundary edges use (a,u) and (v,c) and are legal by the E‑constraints. Outside labels are unchanged.\n\nType automaton and reachability\n- Define transitions δ(M,i)=M·E·S_i on β×β Boolean matrices. The set T of reachable types is the least set containing {S_0,S_1} and closed under δ(·,0/1). By construction, for any word w, M(w) is reachable by iterating δ on its letters. Conversely, any reachable matrix equals M(w) for some w.\n- Size bound: T⊆{0,1}^{β×β}, so |T|≤2^{β^2}. A BFS over δ builds T in time 2^{O(β^2)}·poly(β).\n- For length awareness, define R_1={S_0,S_1} and R_{ℓ+1}={M·E·S_i : M∈R_ℓ, i∈{0,1}}. Then R_ℓ is exactly the set of types of words of length ℓ. Let K:=|T|.\n\nType‑feasible separator function and bridge condition\n- Let S range over {00,01,10,11}. A function f_type: T×S×T→Σ_out^2 is locally valid if for all (τ_L,S,τ_R) it returns (x,y) with (S[1],x)∈C_in–out, E[x,y]=1, and (S[2],y)∈C_in–out.\n- For τ_b,τ_c∈T, define the bridge matrix B(τ_b,τ_c):=E·M_{τ_b}·E·M_{τ_c}·E.\n- Bridge condition: Given S1,S2 and outputs (ℓ_1,ℓ_2)=f_type(·,S1,τ_b), (r_1,r_2)=f_type(τ_c,S2,·), we require B(τ_b,τ_c)[ℓ_2,r_1]=1.\n\nTheorem 3 (NEXPTIME decision of O(log* n) vs Θ(n)).\nThere is a nondeterministic exponential‑time algorithm that, given (C_in–out,C_out–out) for a β‑normalized radius‑1 LCL on oriented paths, decides whether the LOCAL complexity is O(log* n) or Θ(n).\n\nAlgorithm and proof.\n1) Build T and the length‑filtered sets R_K and R_{K+1} by BFS (EXPTIME in β).\n2) Nondeterministically guess f_type: T×S×T→Σ_out^2.\n3) Verify:\n   (i) Local validity at every (τ_L,S,τ_R).\n   (ii) For all τ_b,τ_c ∈ R_K∪R_{K+1} and all S1,S2∈S, with (ℓ_1,ℓ_2)=f_type(·,S1,τ_b), (r_1,r_2)=f_type(τ_c,S2,·), check B(τ_b,τ_c)[ℓ_2,r_1]=1. Each check costs O(β^3).\nThe number of tuples is |R_K∪R_{K+1}|^2·|S|^2 ≤ |T|^2·16 ≤ 2^{O(β^2)}. Thus verification is EXPTIME, and the overall procedure is in NEXPTIME.\n\nSoundness. If a guessed f_type passes, run the standard O(log* n) decomposition on cycles/paths into length‑2 separators and gaps of length K or K+1. Label each separator S by f_type using the types of its neighboring gaps. For each gap with types (τ_b,τ_c), condition (ii) ensures a legal filling consistent with the chosen boundary outputs; replacement (Lemma 2) guarantees independence from the particular representatives. This yields a legal global labeling in O(log* n) rounds.\n\nCompleteness. If the problem is solvable in o(n), then by the standard feasible‑function method specialized to r=1 and the type replacement lemma, there exists a separator labeling depending only on the neighboring gap types that makes every K/K+1 gap fillable. Encoding these boundary choices as f_type produces a table satisfying (i)–(ii).\n\nComplexity. Building T, R_K, R_{K+1}: 2^{O(β^2)}·poly(β). Guess size: 2^{Θ(β^2)} entries. Verification: 2^{O(β^2)} checks, each O(β^3). Hence EXPTIME verification and NEXPTIME overall.\n\nRemark on conventions. One can equivalently work with A=E, D_i=S_i and T_w=(A D_{i_1})…(A D_{i_k}); the bridge scalar then appears as (T_{τ_b}·T_{τ_c}·A)[ℓ_2,r_1]. All results are unchanged if the convention is kept consistent.\n"},"output_update":{"action":"append","content":"Main results (current)\n- We give a NEXPTIME algorithm (in N=poly(β)) that decides, for β‑normalized radius‑1 LCLs on globally oriented paths, whether the LOCAL complexity is O(log* n) or Θ(n). The algorithm guesses a type‑based separator function and verifies it by exponentially many constant‑size Boolean matrix checks over the reachable transfer‑matrix types of length K or K+1.\n- To complete the full trichotomy (O(1) vs Ω(log* n) vs Ω(n)) within NEXPTIME, it remains to prove a compression lemma that reduces per‑word periodic witnesses to an exponential per‑type certificate verifiable via matrix/automata checks. We outline this plan in the notes and are working toward a formal proof."}}