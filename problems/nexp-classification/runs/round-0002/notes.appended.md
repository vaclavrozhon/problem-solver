# Research Notes



Research log – radius‑1 oriented paths via transfer matrices

Setup
- Outputs Σ_out of size β; inputs Σ_in={0,1}. Let E∈{0,1}^{β×β} with E[x,y]=1 iff (x,y)∈C_out–out. For i∈{0,1}, let S_i be diagonal with (S_i)[x,x]=1 iff (i,x)∈C_in–out.
- For w=i_1…i_k, define the transfer matrix M(w)=S_{i_1}·E·S_{i_2}·E·…·E·S_{i_k} (Boolean semiring). Two segments have the same type iff their M(·) matrices are equal.
- Composition: M(P·Q)=M(P)·E·M(Q). Replacement: If M(P)=M(P′), then P and P′ are interchangeable inside any larger instance while keeping outside outputs fixed.

Type automaton
- States: reachable matrices; transitions δ(M,i)=M·E·S_i; seeds {S_0,S_1}. Reachable set T has size ≤2^{β^2}. Build by BFS in 2^{O(β^2)}·poly(β) time.
- For length awareness, compute R_ℓ (types of words of exact length ℓ) by iterating R_{ℓ+1}={M·E·S_i: M∈R_ℓ, i∈{0,1}}. Let K=|T|; the standard decomposition uses gaps of length K or K+1.

Middle-gap feasible function (corrected)
- Certificate: f_type: T×{00,01,10,11}×T→Σ_out^2. For each (τ_L,S,τ_R), outputs (x,y) with local legality: (S[1],x)∈C_in–out, (x,y)∈C_out–out, (S[2],y)∈C_in–out.
- Bridge check: For all τ_b,τ_c ∈ R_K∪R_{K+1} and S1,S2, letting L1=f_type(·,S1,τ_b)=(ℓ_1,ℓ_2) and L2=f_type(τ_c,S2,·)=(r_1,r_2), require (E·M_{τ_b}·E·M_{τ_c}·E)[ℓ_2,r_1]=1.
- If such an f_type exists, label length‑2 separators by f_type and fill each gap by the bridge condition, yielding an O(log* n) algorithm; else complexity is Θ(n).

Complexity
- Build T, R_K, R_{K+1}: EXPTIME. Guess f_type of size 2^{Θ(β^2)}; verify all constraints over τ_b,τ_c∈R_K∪R_{K+1} in EXPTIME. Overall: NEXPTIME.

Top gap (O(1) vs Ω(log* n)) – plan
- Per-type periodicity: For τ, characterize admissible periodic outputs as cycles in the output digraph constrained by the type τ (computed from the monoid generated by F_i=E·S_i). Guess per‑type selections and check interfaces via fixed products like E·M_{τ_b}·E and M_{τ_c}. Prove a compression lemma: any O(1) feasible mapping admits an exponential per‑type certificate verifiable in EXPTIME.

Action items
1) Implement T, R_K, R_{K+1} and the NEXPTIME verifier for O(log* n) vs Θ(n).
2) Formalize per‑type admissible periodic sets and interface constraints; attempt the compression lemma.
3) Validate on small β instances; probe edge cases (e.g., sparse E, forced outputs in S_i).