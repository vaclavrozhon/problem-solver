{
  "content": "# Ideas\n\n- Complete the trichotomy by giving an EXPTIME-checkable certificate for the top gap (O(1) vs \u03a9(log* n)) in the radius-1, oriented-path, \u03b2-normalized setting, using the transfer-matrix abstraction M(w) and output-adjacency E.\n- Key observation: For a long periodic input block of type \u03c4 (matrix M_\u03c4), a constant-time labeling can be arranged by tiling with a constant-size chunk whenever there is some output label x and exponent e \u2264 \u03b2 with ((M_\u03c4\u00b7E)^e)[x,x] = 1. This follows from closed-walk/cycle arguments on the \u03b2-vertex output digraph induced by M_\u03c4\u00b7E.\n- Bridging across short separators reduces to constant-size matrix conditions (E\u00b7M_\u03c3\u00b7E)[x_l,x_r]=1 for \u03c3 a short-type and x_l\u2208L_\u03c4l, x_r\u2208L_\u03c4r, where L_\u03c4 = \u22c3_{e=1..\u03b2} diag((M_\u03c4\u00b7E)^e).\n- Thus we obtain a deterministic EXPTIME decision for O(1): compute all reachable types, their L_\u03c4 sets, enumerate short types, and check the bridging condition universally (witness existentially via L_\u03c4). Combining with the NEXPTIME middle-gap test (developed earlier) yields a full NEXPTIME trichotomy algorithm.\n\n# Setup and notation (radius 1)\n\n- \u03a3_in={0,1}, \u03a3_out of size \u03b2.\n- Boolean \u03b2\u00d7\u03b2 matrices: E with E[x,y]=1 iff (x,y)\u2208C_out\u2013out; for i\u2208{0,1}, S_i diagonal with (S_i)[x,x]=1 iff (i,x)\u2208C_in\u2013out.\n- For an input word w=i_1\u2026i_k, define the transfer matrix M(w)=S_{i_1}\u00b7E\u00b7S_{i_2}\u00b7E\u00b7\u2026\u00b7E\u00b7S_{i_k} (Boolean semiring). Types are these matrices; composition: M(P\u00b7Q)=M(P)\u00b7E\u00b7M(Q).\n- Replacement lemma (radius-1 specialization): if two segments P,P\u2032 have M(P)=M(P\u2032), they are interchangeable in any context without affecting the outside labels nor feasibility; all boundary/global checks reduce to finite Boolean matrix equalities.\n\n# Lemma A (closed walk bound \u2264 \u03b2)\n\nLet A be a Boolean \u03b2\u00d7\u03b2 matrix. If A^m has a 1 on the diagonal for some m\u22651, then A^e has a 1 on the diagonal for some e\u2264\u03b2.\n\nProof. A^m[v,v]=1 means there is a closed walk of length m at vertex v in the directed graph with adjacency A. Any closed walk contains a directed cycle; its length e is at most the number of vertices, hence e\u2264\u03b2. Then A^e[v,v]=1.\n\n# Consequence for periodic input types\n\nFix a type \u03c4 with matrix M_\u03c4, and define A_\u03c4:=M_\u03c4\u00b7E. Consider a cycle whose input is w^m, where M(w)=M_\u03c4. Any legal labeling induces A_\u03c4^m[x,x]=1 for some output label x (choose x as the output at a chosen boundary position and follow through m copies). By Lemma A, there exists e\u2264\u03b2 with A_\u03c4^e[x,x]=1.\n\nDefine the per-type loop set L_\u03c4 := { x \u2208 \u03a3_out : \u2203 e\u2208{1,\u2026,\u03b2} with (A_\u03c4^e)[x,x]=1 }.\n\n- Computation: L_\u03c4 is computable by summing diagonals of A_\u03c4,\u2026,A_\u03c4^\u03b2. Cost poly(\u03b2) per \u03c4.\n- Intuition: L_\u03c4 are precisely the boundary outputs that allow a constant-size chunking of the periodic input block (e copies) with both ends labeled x and internal outputs consistent with Cin\u2013out and E.\n\n# Bridging across a short separator\n\nLet \u03c3 be any short type, i.e., \u03c3=M(S) for some S with |S| \u2264 2\u00b7L_width, and define C_\u03c3:=E\u00b7M_\u03c3\u00b7E. If a long block of type \u03c4_l meets a short \u03c3 on its right and another long block of type \u03c4_r on \u03c3\u2019s right, then the necessary and sufficient boundary feasibility is\n\n\u2203 x_l \u2208 L_{\u03c4_l}, x_r \u2208 L_{\u03c4_r} with C_\u03c3[x_l, x_r]=1.\n\nReason: x_l can be enforced at the right boundary of the left long block by tiling its interior with a chunk of length e_l (since (A_{\u03c4_l}^{e_l})[x_l,x_l]=1). Analogously for the left boundary x_r of the right long block. The short block in between is feasible iff C_\u03c3[x_l,x_r]=1 (left E-edge to S, internal S via M_\u03c3, and right E-edge to the next block). As |S| is O(L_width), such fillings are computable in constant time in the LOCAL model.\n\n# Theorem (EXPTIME decision for O(1))\n\nGiven (Cin\u2013out, Cout\u2013out), there is a deterministic EXPTIME algorithm that decides whether the complexity is O(1) on oriented paths.\n\nAlgorithm.\n1) Build the reachable type set T by BFS in the transfer-matrix DFA with transitions \u03b4(M,i)=M\u00b7E\u00b7S_i from the seeds {S_0,S_1}. Time 2^{O(\u03b2^2)}\u00b7poly(\u03b2).\n2) Let K:=|T| and set L_width=L_pattern=K as in the O(1) partition. Compute the set of short types T_short = \u22c3_{\u2113=1}^{2 L_width} R_\u2113, where R_\u2113 are types reachable by exactly \u2113 letters (iterate \u03b4; each R_\u2113 \u2286 T).\n3) For each \u03c4\u2208R_{\u2264L_pattern}, compute L_\u03c4 = \u22c3_{e=1}^{\u03b2} diag((M_\u03c4\u00b7E)^e). If L_\u03c4=\u2205 for some \u03c4 in R_{\u2264L_pattern}, return \u201cnot O(1)\u201d.\n4) For each triple (\u03c4_l,\u03c3,\u03c4_r) with \u03c4_l,\u03c4_r\u2208R_{\u2264L_pattern} and \u03c3\u2208T_short, compute C_\u03c3=E\u00b7M_\u03c3\u00b7E and check whether \u2203 x_l\u2208L_{\u03c4_l}, x_r\u2208L_{\u03c4_r} with C_\u03c3[x_l,x_r]=1. If any triple fails, return \u201cnot O(1)\u201d. Otherwise return \u201cO(1)\u201d.\n\nComplexity. |T| \u2264 2^{\u03b2^2}. Steps 3\u20134 enumerate at most |T| + |T|^3 cases, each with O(\u03b2^\u03c9) arithmetic (\u03c9\u22643) and table lookups. Overall EXPTIME in \u03b2.\n\nSoundness. If the algorithm returns \u201cO(1)\u201d, construct an O(1)-round labeling strategy as follows: compute the (L_width,L_count,L_pattern)-partition (in O(1) rounds) of the input cycle/path. For each long block of type \u03c4, choose any x\u2208L_\u03c4 and tile it by e copies (e \u2264 \u03b2) of the underlying primitive period to enforce boundary x on both ends (exists by definition of L_\u03c4), and fill the interior by local DP of constant radius. For each short block \u03c3, pick any pair (x_l,x_r) as certified by C_\u03c3[L_{\u03c4_l},L_{\u03c4_r}] and fill \u03c3 by DP. All steps are O(1) in n.\n\nCompleteness. Suppose the problem is O(1). Then for every \u03c4\u2208R_{\u2264L_pattern} and every m\u22651, the cycle with input w^m (M(w)=M_\u03c4) is solvable; hence for some x and m we have (A_\u03c4^m)[x,x]=1, and by Lemma A there exists e \u2264 \u03b2 with (A_\u03c4^e)[x,x]=1. Thus L_\u03c4 \u2260 \u2205. For bridging, take any triple (\u03c4_l,\u03c3,\u03c4_r); consider the cycle formed by a long block of type \u03c4_l, the short \u03c3, and a long block of type \u03c4_r (with buffers if needed), which is solvable by the O(1) algorithm. Using the replacement lemma, we can locally modify each long block by swapping a constant-size suffix/prefix with the chunk guaranteed by L_{\u03c4_l}, L_{\u03c4_r} to enforce chosen boundaries x_l\u2208L_{\u03c4_l} and x_r\u2208L_{\u03c4_r} without affecting the far interior. If for all (x_l,x_r)\u2208L_{\u03c4_l}\u00d7L_{\u03c4_r} the entry C_\u03c3[x_l,x_r]=0, then the short block cannot be completed, contradicting solvability. Hence C_\u03c3[L_{\u03c4_l},L_{\u03c4_r}] must contain a 1 for all triples. Therefore the EXPTIME test accepts.\n\n# Middle gap (\u03a9(n) vs O(log* n)) \u2014 recap\n\n- Use the type-based separator certificate f_type: T\u00d7{00,01,10,11}\u00d7T \u2192 \u03a3_out^2, and verify, for \u03c4_b,\u03c4_c\u2208R_{K}\u222aR_{K+1}, the bridging scalar (E\u00b7M_{\u03c4_b}\u00b7E\u00b7M_{\u03c4_c}\u00b7E)[\u2113_2,r_1]=1 where L1=f_type(\u00b7,S1,\u03c4_b) and L2=f_type(\u03c4_c,S2,\u00b7). Verification time EXPTIME. Guess f_type in NEXPTIME, yielding a NEXPTIME decision.\n\n# Full trichotomy NEXPTIME algorithm\n\nGiven (Cin\u2013out,Cout\u2013out):\n1) Run the EXPTIME O(1)-test above. If it accepts, output \u201cO(1)\u201d.\n2) Otherwise, run the NEXPTIME middle-gap test (guess f_type, verify) to decide O(log* n) vs \u0398(n). If the middle test accepts, output \u201c\u0398(log* n)\u201d; else output \u201c\u0398(n)\u201d.\n\n# Example (\u03b2=2)\n\nLet \u03a3_out={a,b}. Suppose E has edges a\u2192a, a\u2192b, b\u2192b (Boolean upper triangular), and Cin\u2013out allows both outputs for input 0, and only b for input 1. Then S_0=I, S_1=diag(0,1). For any w, M(w) zeroes out rows/cols where an input-1 position forces output a; specifically A_\u03c4=M(w)\u00b7E will retain only rows/cols reachable via b on 1-positions. One computes L_\u03c4 by diagonals of A_\u03c4,\u2026,A_\u03c4^2; as E has cycles at a and b, L_\u03c4 contains b (and possibly a if w has no 1). For any short \u03c3, C_\u03c3=E\u00b7M_\u03c3\u00b7E will have at least one 1 in rows L_{\u03c4_l} and columns L_{\u03c4_r}; hence the O(1) test accepts.\n\n# Obstacles and checks\n\n- Replacement lemma must be applied carefully: replacing a boundary-adjacent slice inside a long block by a constant-size chunk with boundary x requires that both edges into/out of the chunk remain feasible (guaranteed by (A_\u03c4^e)[x,x]=1). This preserves extendibility by the radius-1 replacement argument.\n- Enumerating T_short requires exact-length sets R_\u2113, \u2113\u22642|T|. These are computed by iterating \u03b4; the number of new matrices per step is \u2264|T|.\n- The bound e\u2264\u03b2 is tight and independent of |T|, avoiding a blow-up in the chunk size.\n\n# Next steps\n\n- Move Lemma A, the definition and computation of L_\u03c4, and the EXPTIME O(1)-test into proofs.md with full details of the replacement surgery at block boundaries.\n- Implement a prototype to generate T, R_\u2113, and compute the O(1) test, and cross-check randomly generated small \u03b2 instances.\n- Integrate with the existing NEXPTIME middle-gap test: shared precomputation of T and R_\u2113 sets.\n- Optional: streamline the middle test by restricting \u03c4_b,\u03c4_c to R_K\u222aR_{K+1} (K=|T|), as noted in previous feedback, to ensure completeness.\n\n# Summary\n\n- We give a concrete, EXPTIME-decidable criterion for O(1) via per-type loop sets L_\u03c4 = \u22c3_{e\u2264\u03b2} diag((M_\u03c4\u00b7E)^e) and universal bridging checks across short types \u03c3. This completes the top-gap decision within our transfer-matrix framework.\n- Combined with the prior type-based NEXPTIME test for O(log* n) vs \u0398(n), we obtain a full NEXPTIME trichotomy algorithm for \u03b2-normalized, radius-1 LCLs on globally oriented paths.\n"
}