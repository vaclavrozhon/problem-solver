{
  "content": "Ideas\n\n- Solidify the transfer-matrix framework for radius-1 on oriented paths and complete the middle-gap (\u0398(n) vs O(log* n)) decision in NEXPTIME with explicit, verifiable matrix tests restricted to length-K or K+1 types.\n- Add simple, checkable O(1) subcases (constant-output and 2-phase alternation) that can be decided in polynomial time; these already cover a nontrivial slice of O(1) instances and avoid double-exponential witnesses.\n- Prepare the ground for the full O(1) vs \u03a9(log* n) step by introducing a finite semigroup viewpoint (monoid generated by F_i=E\u00b7S_i) and two computable \u201cletter-occurrence\u201d summaries per type (Occ_any, Occ_all), yielding necessary conditions for O(1) and a plausible direction for an exponential certificate.\n\nRigorous statements and proofs\n\nNotation. \u03a3_in={0,1}, |\u03a3_out|=\u03b2. Write E\u2208{0,1}^{\u03b2\u00d7\u03b2} with E[a,b]=1 iff (a,b)\u2208C_out\u2013out. For \u03c3\u2208{0,1}, S_\u03c3 is diagonal with S_\u03c3[c,c]=1 iff (\u03c3,c)\u2208C_in\u2013out. Boolean arithmetic throughout.\nFor w=\u03c3_1\u2026\u03c3_k, define the transfer matrix M(w)=S_{\u03c3_1}\u00b7E\u00b7S_{\u03c3_2}\u00b7E\u00b7\u2026\u00b7E\u00b7S_{\u03c3_k}.\n\nLemma 1 (concatenation). For segments P,Q, M(PQ)=M(P)\u00b7E\u00b7M(Q).\nProof. An entry (M(PQ))[a,d]=1 iff \u2203b,c with M(P)[a,b]=1, E[b,c]=1, M(Q)[c,d]=1. This is exactly the Boolean product M(P)\u00b7E\u00b7M(Q).\n\nLemma 2 (matrix replacement). If segments P,P\u2032 have M(P)=M(P\u2032), then in any globally legal instance G, replacing P by P\u2032 yields a graph G\u2032 that admits a legal labeling whose outputs agree with the original outside P and at the two boundary outputs of P.\nProof. Let the original labeling fix boundary outputs a,b at P\u2019s ends and be locally legal. Since M(P)[a,b]=1 and M(P\u2032)=M(P), P\u2032 admits an interior labeling from a to b respecting both Cin\u2013out and Cout\u2013out. Crossing edges at both ends are unchanged; legality follows.\n\nType automaton. Define \u03b4(M,\u03c3)=M\u00b7E\u00b7S_\u03c3. Seed states {S_0,S_1}. The reachable set T (the set of all types) is the closure under \u03b4; |T|\u22642^{\u03b2^2}. Construct T by BFS from {S_0,S_1}, in time 2^{O(\u03b2^2)}\u00b7poly(\u03b2). For exact lengths, define R_1={S_0,S_1}, and R_{\u2113+1}={\u03b4(M,\u03c3): M\u2208R_\u2113, \u03c3\u2208{0,1}}. Let K=|T|; the standard decomposition uses gap lengths in {K,K+1}.\n\nMiddle-gap certificate (corrected). A table f_type: T\u00d7{00,01,10,11}\u00d7T\u2192\u03a3_out^2 is feasible if for every tuple (\u03c4_a,\u03c4_b,\u03c4_c,\u03c4_d,S_1,S_2) with \u03c4_b,\u03c4_c\u2208R_K\u222aR_{K+1} and S_1,S_2\u2208{0,1}^2, writing (\u2113_1,\u2113_2)=f_type(\u03c4_a,S_1,\u03c4_b) and (r_1,r_2)=f_type(\u03c4_c,S_2,\u03c4_d), the following hold:\n- Local windows: S_1=(\u03c3,\u03c3\u2032) implies S_\u03c3[\u2113_1,\u2113_1]=1, S_{\u03c3\u2032}[\u2113_2,\u2113_2]=1, and E[\u2113_1,\u2113_2]=1; similarly for S_2 and r_1,r_2.\n- Bridge existence: Let M_b=\u03c4_b and M_c=\u03c4_c. Then (E\u00b7M_b\u00b7E\u00b7M_c\u00b7E)[\u2113_2,r_1]=1.\nThe second condition exactly encodes \u201cevery length-K/K+1 middle gap with boundary types \u03c4_b,\u03c4_c can be filled between chosen window labels\u201d.\n\nProposition 3 (NEXPTIME decision of \u0398(n) vs O(log* n)). Construct T and R_K,R_{K+1}. Nondeterministically guess f_type, then verify all constraints above by finitely many Boolean matrix products and entry checks. Verification is EXPTIME (2^{poly(\u03b2)} tuples; each check poly(\u03b2)). Hence nondeterministic exponential time overall. If a feasible f_type exists, the problem is O(log* n); otherwise it is \u0398(n).\nProof sketch. Soundness follows the standard decomposition: label 2-node separators by f_type and fill the K/K+1 gaps via the bridge condition, yielding a legal labeling extendable across the cycle; this implements the canonical O(log* n) scheme. Completeness relies on Chang\u2013Hsu\u2013Pettie\u2019s feasible-function method; our matrix replacement (Lemma 2) and the restriction \u03c4_b,\u03c4_c\u2208R_K\u222aR_{K+1} preserve their construction while keeping the state space exponential.\n\nTwo O(1) subcases (decidable in poly-time)\n\n- Constant-output test. If \u2203c\u2208\u03a3_out with (0,c)\u2208C_in\u2013out, (1,c)\u2208C_in\u2013out, and (c,c)\u2208C_out\u2013out, then the constant rule y_i\u2261c is a 0-round algorithm. Conversely, for any input consisting solely of 0s (resp. 1s), an O(1) algorithm must output a constant c with (0,c),(c,c) (resp. (1,c),(c,c)) allowed. These are necessary conditions and easy to check.\n- Alternation test. For the alternating inputs \u20260101\u2026 and \u20261010\u2026, a 1-round rule y_i=\u03c6(x_{i-1},x_i) exists iff there are a,b\u2208\u03a3_out with (1,a)\u2208C_in\u2013out, (0,b)\u2208C_in\u2013out and both edges (a,b),(b,a)\u2208C_out\u2013out. Then defining \u03c6(0,1)=a, \u03c6(1,0)=b (and arbitrarily consistent values for 00,11 if needed) yields a correct labeling on alternating inputs. This captures many nontrivial O(1) cases.\n\nSemigroup and letter-occurrence summaries (preparation for the top gap)\n\nLet F_\u03c3=E\u00b7S_\u03c3 and note E\u00b7M(w)=F_{\u03c3_1}F_{\u03c3_2}\u2026F_{\u03c3_k}. Let G be the finite monoid generated by {F_0,F_1} under Boolean multiplication; |G|\u2264|T|.\n- For \u03c4\u2208T, define Occ_any(\u03c4)\u2286{0,1} as the set of symbols that appear in some representative w with M(w)=\u03c4. Compute by augmenting the type automaton with a 2-bit \u201cseen\u201d register and testing reachability of \u03c4 with the register set to include a given symbol.\n- Define Occ_all(\u03c4)\u2286{0,1} as the set of symbols that appear in every representative of \u03c4. Compute by testing emptiness of the language {w: M(w)=\u03c4 and \u03b9\u2209w} (for \u03b9\u2208{0,1}) using the type automaton restricted to transitions labeled by the other symbol; if nonempty, then \u03b9\u2209Occ_all(\u03c4).\nNecessary conditions for O(1): if 0\u2208Occ_any(\u03c4), there must exist c with (0,c),(c,c) allowed; similarly for 1; otherwise O(1) fails on the corresponding constant-input segments. These checks are exponential-time computable over \u03c4\u2208R_K\u222aR_{K+1}.\n\nExamples\n\n- \u03b2=2, \u03a3_out={a,b}. If C_out\u2013out has only self-loops (a,a),(b,b) and Cin\u2013out allows both outputs on both inputs, then the constant-output test passes (choose a), yielding O(1) (0 rounds). If instead C_out\u2013out forbids self-loops but has a 2-cycle a\u2194b and Cin\u2013out allows (1,a),(0,b), the alternation test yields a 1-round rule for alternating inputs, while constant strings are impossible (hence O(1) fails unless Cin\u2013out also allows a self-loop label for each unary string). Our middle-gap test then classifies \u0398(n) unless the bridge matrices enable O(log* n).\n\nObstacles\n\n- Full O(1) vs \u03a9(log* n) still lacks an exponential certificate. The classic feasible-function approach for the top gap enumerates all primitive periods of length \u2264K (doubly exponential). Compressing this to per-type annotations requires controlling per-position Cin\u2013out constraints, which matrix types do not record. Augmenting types with limited letter-context summaries (e.g., Occ_any/Occ_all) is a start but not yet sufficient.\n- A naive \u201cradius-1 suffices\u201d conjecture is false in general: an O(1) local rule may depend on longer input windows in ways not collapsible to \u03c6(x_{i-1},x_i), even though checks are radius-1. Hence we cannot reduce top-gap to the 4-context rule without loss.\n\nNext steps\n\n1) Finalize the \u0398(n) vs O(log* n) NEXPTIME verifier.\n- Implement construction of T, and R_K,R_{K+1}.\n- Verify all tuples of (\u03c4_a,\u03c4_b,\u03c4_c,\u03c4_d,S_1,S_2) with the corrected bridge test (E\u00b7M_b\u00b7E\u00b7M_c\u00b7E)[\u2113_2,r_1]=1 and local-window checks.\n- Add early pruning with constant-output and alternation tests.\n\n2) Strengthen necessary conditions towards O(1).\n- Compute Occ_any/Occ_all(\u03c4) as above; reject instances failing constant-unary constraints for any \u03c4\u2208R_K\u222aR_{K+1}.\n- Explore 3-phase alternation: extend the pair test to three contexts present in words like 001001\u2026 by requiring outputs a,b,c with E[a,b]=E[b,c]=E[c,a]=1 and appropriate Cin\u2013out per context; these can be encoded as constraints on the de Bruijn graph of order 2 over the sublanguage induced by \u03c4 and checked via products with the type automaton (still exponential).\n\n3) Toward an exponential certificate for O(1).\n- Use the monoid G generated by {F_0,F_1}; compute idempotents e\u2208G. For a periodic word u, the product (E\u00b7M(u))^m stabilizes at an idempotent; relate admissible periodic outputs to cycles in the output graph restricted by node filters corresponding to letters occurring along u; formalize per-type admissible periodic sets via these idempotents.\n- Aim to show: if a top-gap feasible function exists, then there is a per-type certificate consisting of (i) for each \u03c4\u2208R_K a chosen output cycle C_\u03c4 in the output graph, with all labels in C_\u03c4 allowed by Occ_all(\u03c4), and (ii) boundary/interface assignments verifiable by constant many matrix equalities/products. This, if proved, yields a NEXPTIME decision for O(1) vs \u03a9(log* n).\n\nWhy useful here\n\n- Lemmas 1\u20132 (with proofs) justify the matrix semantics fully; together with the corrected R_K/R_{K+1} restriction they make the middle-gap verifier precise and implementable.\n- The constant-output and alternation subcases immediately classify a family of O(1) instances within polynomial time and can be integrated into the global NEXPTIME procedure as an early exit.\n- Occ_any/Occ_all(\u03c4) are computable summaries that propagate unary necessary conditions across types and suggest how to encode per-type periodic behaviors without unfolding all words, a key ingredient for compressing the top-gap witness.\n\n"
}