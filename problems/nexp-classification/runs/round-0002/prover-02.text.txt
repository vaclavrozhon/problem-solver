Ideas

- Solidify the transfer-matrix framework for radius-1 on oriented paths and complete the middle-gap (Θ(n) vs O(log* n)) decision in NEXPTIME with explicit, verifiable matrix tests restricted to length-K or K+1 types.
- Add simple, checkable O(1) subcases (constant-output and 2-phase alternation) that can be decided in polynomial time; these already cover a nontrivial slice of O(1) instances and avoid double-exponential witnesses.
- Prepare the ground for the full O(1) vs Ω(log* n) step by introducing a finite semigroup viewpoint (monoid generated by F_i=E·S_i) and two computable “letter-occurrence” summaries per type (Occ_any, Occ_all), yielding necessary conditions for O(1) and a plausible direction for an exponential certificate.

Rigorous statements and proofs

Notation. Σ_in={0,1}, |Σ_out|=β. Write E∈{0,1}^{β×β} with E[a,b]=1 iff (a,b)∈C_out–out. For σ∈{0,1}, S_σ is diagonal with S_σ[c,c]=1 iff (σ,c)∈C_in–out. Boolean arithmetic throughout.
For w=σ_1…σ_k, define the transfer matrix M(w)=S_{σ_1}·E·S_{σ_2}·E·…·E·S_{σ_k}.

Lemma 1 (concatenation). For segments P,Q, M(PQ)=M(P)·E·M(Q).
Proof. An entry (M(PQ))[a,d]=1 iff ∃b,c with M(P)[a,b]=1, E[b,c]=1, M(Q)[c,d]=1. This is exactly the Boolean product M(P)·E·M(Q).

Lemma 2 (matrix replacement). If segments P,P′ have M(P)=M(P′), then in any globally legal instance G, replacing P by P′ yields a graph G′ that admits a legal labeling whose outputs agree with the original outside P and at the two boundary outputs of P.
Proof. Let the original labeling fix boundary outputs a,b at P’s ends and be locally legal. Since M(P)[a,b]=1 and M(P′)=M(P), P′ admits an interior labeling from a to b respecting both Cin–out and Cout–out. Crossing edges at both ends are unchanged; legality follows.

Type automaton. Define δ(M,σ)=M·E·S_σ. Seed states {S_0,S_1}. The reachable set T (the set of all types) is the closure under δ; |T|≤2^{β^2}. Construct T by BFS from {S_0,S_1}, in time 2^{O(β^2)}·poly(β). For exact lengths, define R_1={S_0,S_1}, and R_{ℓ+1}={δ(M,σ): M∈R_ℓ, σ∈{0,1}}. Let K=|T|; the standard decomposition uses gap lengths in {K,K+1}.

Middle-gap certificate (corrected). A table f_type: T×{00,01,10,11}×T→Σ_out^2 is feasible if for every tuple (τ_a,τ_b,τ_c,τ_d,S_1,S_2) with τ_b,τ_c∈R_K∪R_{K+1} and S_1,S_2∈{0,1}^2, writing (ℓ_1,ℓ_2)=f_type(τ_a,S_1,τ_b) and (r_1,r_2)=f_type(τ_c,S_2,τ_d), the following hold:
- Local windows: S_1=(σ,σ′) implies S_σ[ℓ_1,ℓ_1]=1, S_{σ′}[ℓ_2,ℓ_2]=1, and E[ℓ_1,ℓ_2]=1; similarly for S_2 and r_1,r_2.
- Bridge existence: Let M_b=τ_b and M_c=τ_c. Then (E·M_b·E·M_c·E)[ℓ_2,r_1]=1.
The second condition exactly encodes “every length-K/K+1 middle gap with boundary types τ_b,τ_c can be filled between chosen window labels”.

Proposition 3 (NEXPTIME decision of Θ(n) vs O(log* n)). Construct T and R_K,R_{K+1}. Nondeterministically guess f_type, then verify all constraints above by finitely many Boolean matrix products and entry checks. Verification is EXPTIME (2^{poly(β)} tuples; each check poly(β)). Hence nondeterministic exponential time overall. If a feasible f_type exists, the problem is O(log* n); otherwise it is Θ(n).
Proof sketch. Soundness follows the standard decomposition: label 2-node separators by f_type and fill the K/K+1 gaps via the bridge condition, yielding a legal labeling extendable across the cycle; this implements the canonical O(log* n) scheme. Completeness relies on Chang–Hsu–Pettie’s feasible-function method; our matrix replacement (Lemma 2) and the restriction τ_b,τ_c∈R_K∪R_{K+1} preserve their construction while keeping the state space exponential.

Two O(1) subcases (decidable in poly-time)

- Constant-output test. If ∃c∈Σ_out with (0,c)∈C_in–out, (1,c)∈C_in–out, and (c,c)∈C_out–out, then the constant rule y_i≡c is a 0-round algorithm. Conversely, for any input consisting solely of 0s (resp. 1s), an O(1) algorithm must output a constant c with (0,c),(c,c) (resp. (1,c),(c,c)) allowed. These are necessary conditions and easy to check.
- Alternation test. For the alternating inputs …0101… and …1010…, a 1-round rule y_i=φ(x_{i-1},x_i) exists iff there are a,b∈Σ_out with (1,a)∈C_in–out, (0,b)∈C_in–out and both edges (a,b),(b,a)∈C_out–out. Then defining φ(0,1)=a, φ(1,0)=b (and arbitrarily consistent values for 00,11 if needed) yields a correct labeling on alternating inputs. This captures many nontrivial O(1) cases.

Semigroup and letter-occurrence summaries (preparation for the top gap)

Let F_σ=E·S_σ and note E·M(w)=F_{σ_1}F_{σ_2}…F_{σ_k}. Let G be the finite monoid generated by {F_0,F_1} under Boolean multiplication; |G|≤|T|.
- For τ∈T, define Occ_any(τ)⊆{0,1} as the set of symbols that appear in some representative w with M(w)=τ. Compute by augmenting the type automaton with a 2-bit “seen” register and testing reachability of τ with the register set to include a given symbol.
- Define Occ_all(τ)⊆{0,1} as the set of symbols that appear in every representative of τ. Compute by testing emptiness of the language {w: M(w)=τ and ι∉w} (for ι∈{0,1}) using the type automaton restricted to transitions labeled by the other symbol; if nonempty, then ι∉Occ_all(τ).
Necessary conditions for O(1): if 0∈Occ_any(τ), there must exist c with (0,c),(c,c) allowed; similarly for 1; otherwise O(1) fails on the corresponding constant-input segments. These checks are exponential-time computable over τ∈R_K∪R_{K+1}.

Examples

- β=2, Σ_out={a,b}. If C_out–out has only self-loops (a,a),(b,b) and Cin–out allows both outputs on both inputs, then the constant-output test passes (choose a), yielding O(1) (0 rounds). If instead C_out–out forbids self-loops but has a 2-cycle a↔b and Cin–out allows (1,a),(0,b), the alternation test yields a 1-round rule for alternating inputs, while constant strings are impossible (hence O(1) fails unless Cin–out also allows a self-loop label for each unary string). Our middle-gap test then classifies Θ(n) unless the bridge matrices enable O(log* n).

Obstacles

- Full O(1) vs Ω(log* n) still lacks an exponential certificate. The classic feasible-function approach for the top gap enumerates all primitive periods of length ≤K (doubly exponential). Compressing this to per-type annotations requires controlling per-position Cin–out constraints, which matrix types do not record. Augmenting types with limited letter-context summaries (e.g., Occ_any/Occ_all) is a start but not yet sufficient.
- A naive “radius-1 suffices” conjecture is false in general: an O(1) local rule may depend on longer input windows in ways not collapsible to φ(x_{i-1},x_i), even though checks are radius-1. Hence we cannot reduce top-gap to the 4-context rule without loss.

Next steps

1) Finalize the Θ(n) vs O(log* n) NEXPTIME verifier.
- Implement construction of T, and R_K,R_{K+1}.
- Verify all tuples of (τ_a,τ_b,τ_c,τ_d,S_1,S_2) with the corrected bridge test (E·M_b·E·M_c·E)[ℓ_2,r_1]=1 and local-window checks.
- Add early pruning with constant-output and alternation tests.

2) Strengthen necessary conditions towards O(1).
- Compute Occ_any/Occ_all(τ) as above; reject instances failing constant-unary constraints for any τ∈R_K∪R_{K+1}.
- Explore 3-phase alternation: extend the pair test to three contexts present in words like 001001… by requiring outputs a,b,c with E[a,b]=E[b,c]=E[c,a]=1 and appropriate Cin–out per context; these can be encoded as constraints on the de Bruijn graph of order 2 over the sublanguage induced by τ and checked via products with the type automaton (still exponential).

3) Toward an exponential certificate for O(1).
- Use the monoid G generated by {F_0,F_1}; compute idempotents e∈G. For a periodic word u, the product (E·M(u))^m stabilizes at an idempotent; relate admissible periodic outputs to cycles in the output graph restricted by node filters corresponding to letters occurring along u; formalize per-type admissible periodic sets via these idempotents.
- Aim to show: if a top-gap feasible function exists, then there is a per-type certificate consisting of (i) for each τ∈R_K a chosen output cycle C_τ in the output graph, with all labels in C_τ allowed by Occ_all(τ), and (ii) boundary/interface assignments verifiable by constant many matrix equalities/products. This, if proved, yields a NEXPTIME decision for O(1) vs Ω(log* n).

Why useful here

- Lemmas 1–2 (with proofs) justify the matrix semantics fully; together with the corrected R_K/R_{K+1} restriction they make the middle-gap verifier precise and implementable.
- The constant-output and alternation subcases immediately classify a family of O(1) instances within polynomial time and can be integrated into the global NEXPTIME procedure as an early exit.
- Occ_any/Occ_all(τ) are computable summaries that propagate unary necessary conditions across types and suggest how to encode per-type periodic behaviors without unfolding all words, a key ingredient for compressing the top-gap witness.

