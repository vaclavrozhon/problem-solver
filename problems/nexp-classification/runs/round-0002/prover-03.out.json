{
  "content": "Ideas\n\n- Fix F_i := E\u00b7S_i for i \u2208 {0,1} and T_w := F_{i_1}F_{i_2}\u22efF_{i_k} (Boolean semiring). This convention makes all statements uniform and keeps \u201cedge-then-node\u201d checks inline. Types are exactly T_w.\n- Middle-gap: finalize the EXPTIME verifier using only matrix products and the length-filter correction (\u03c4_b,\u03c4_c \u2208 R_K\u222aR_{K+1}). No language complementation needed.\n- Top-gap: isolate an EXPTIME-computable necessary condition for O(1) (period feasibility without anchors) via the \u201cright-stabilizer\u201d set Z_per := { Z \u2208 \u27e8F_0,F_1\u27e9 : \u2203M\u2208\u27e8F_0,F_1\u27e9, M\u00b7Z = M }. Show diag(Z)\u2260\u2205 is necessary. Also give a simple, EXPTIME-checkable sufficient condition (SCC-constant certificate) that, together with the middle-gap f_type, yields an O(1) algorithm. This is not yet a full characterization but is a concrete step toward a compressed certificate.\n\nReplacement and composition (radius 1)\n\nDefinition. Let E[x,y]=1 \u21d4 (x,y)\u2208C_out\u2013out and S_i diagonal with S_i[x,x]=1 \u21d4 (i,x)\u2208C_in\u2013out. Define F_i := E\u00b7S_i and, for w=i_1\u22efi_k, T_w := F_{i_1}\u22efF_{i_k}. Two segments P,Q have the same type iff T_P=T_Q. Concatenation obeys T_{uv}=T_u\u00b7T_v.\n\nLemma (matrix replacement). Let G be a directed path/cycle. Let P\u2286G and P\u2032 another segment with T_P=T_{P\u2032}. Suppose a labeling of G is locally consistent at all nodes of P. Then replacing P by P\u2032 yields a labeling that is locally consistent on P\u2032 and unchanged outside P\u2032. Proof. With radius 1, the only interface a segment exposes is the boundary relation T_P; equal relations imply identical extendibility. Composition follows from T_{uv}=T_u\u00b7T_v.\n\nMiddle-gap certificate: EXPTIME verification\n\n- Build the reachable set T by BFS on \u03b4(M,i)=M\u00b7F_i from I; cost 2^{O(\u03b2^2)}\u00b7poly(\u03b2).\n- Compute R_\u2113 \u2286 T, the types realized by exactly \u2113 inputs, by iterating R_{\u2113+1}={M\u00b7F_i : M\u2208R_\u2113, i\u2208{0,1}}; set K=|T| and use \u03c4_b,\u03c4_c \u2208 R_K\u222aR_{K+1}.\n- Guess f_type: T\u00d7{00,01,10,11}\u00d7T\u2192\u03a3_out^2; verify for each triple (\u03c4_L,S,\u03c4_R) that (i) local legality holds: S[1] on left output, edge E between the pair, and S[2] on right output; (ii) for all \u03c4_b,\u03c4_c \u2208 R_K\u222aR_{K+1} and S1,S2, if f_type(\u00b7,S1,\u03c4_b)=(\u2113_1,\u2113_2) and f_type(\u03c4_c,S2,\u00b7)=(r_1,r_2), then (F_{\u03c4_b}\u00b7F_{\u03c4_c}\u00b7E)[\u2113_2,r_1]=1. Here F_{\u03c4}:=T_w for any w with type \u03c4. The check is a scalar lookup after precomputing the products; total EXPTIME.\n- If some f_type passes, conclude O(log* n); else \u0398(n). This completes a NEXPTIME decision for the middle gap.\n\nTop-gap: periodic necessity via right-stabilizers\n\nDefinition (period generators). Let S:=\u27e8F_0,F_1\u27e9\u2286{0,1}^{\u03b2\u00d7\u03b2}. Define Z_per := { Z \u2208 S : \u2203 M \u2208 S with M\u00b7Z = M } (Z stabilizes some type on the right; these are exactly products labeling cycles in the type automaton).\n\nLemma (necessary condition for O(1)). If the LCL has an O(1) algorithm, then for every Z\u2208Z_per, \u2203x\u2208\u03a3_out with Z[x,x]=1.\nProof. Consider any long periodic input segment w^m whose period w yields Z=T_w and whose run in the type automaton stays in a cycle. A constant-time, ID-free algorithm cannot introduce anchors on a fully periodic instance; its output on w^m must be shift-invariant and hence valid on arbitrarily many repetitions. This implies the existence of a one-period closed witness of outputs; algebraically, Z has a diagonal 1. Otherwise, any attempt to close the period creates an interface conflict at the wrap-around. Since Z_per has size \u2264 |S|\u00b7|S| \u2264 2^{O(\u03b2^2)}, this test is EXPTIME.\n\nTop-gap: a sufficient certificate (SCC-constant)\n\nLet \ud835\udd04 be the type automaton on state set T with transitions \u03b4(M,i)=M\u00b7F_i. Compute its SCCs C. The following is sufficient for O(1):\n- There exists f_type passing the middle-gap verifier (above), and\n- For each SCC C, \u2203x_C \u2208 \u03a3_out s.t. E[x_C,x_C]=1 and D_i[x_C,x_C]=1 for every i labeling some edge inside C.\nConstruction (O(1) algorithm).\n- Compute an (L_width,L_count,L_pattern)-partition (paper\u2019s lemma) with L_width=L_pattern=|T|, L_count=2|T|+2. This splits the cycle into short paths P_short and long periodic paths P_long whose input runs stay inside some SCC C and have at least L_count/|w| periods.\n- On each P_long in SCC C, assign every node output x_C. Local legality holds by choices of E and D; since outputs are constant, the algorithm is phase-free and radius-1.\n- Use f_type to label the length-2 separators and fill the gaps (middle-gap lemma). Remaining unlabeled components are O(1)-sized; fill them locally.\n- Total runtime O(1).\nRemarks. This \u201cSCC-constant\u201d certificate is checkable in EXPTIME (compute SCCs; for each C, test feasibility of x_C by scanning D_0,D_1 and E). It is likely not necessary (there are cases where periodic outputs alternate but are phase-discernible by local windows); it nonetheless provides a nontrivial sufficient condition within our matrix framework.\n\nExamples\n\n- \u03b2=2, E=complete, D_0=D_1=I. Then F_i=E, T={I,E}, Z_per={I,E}, and diag(E)\u2260\u2205. SCC-constant holds with x_C arbitrary; algorithm returns O(1).\n- \u03b2=2, E has only self-loops (E=I), D_0=diag(1,0), D_1=diag(0,1). Then F_0=diag(1,0), F_1=diag(0,1). Z_per contains F_0,F_1; both have empty diagonal on the forbidden coordinate. Necessity detects \u03a9(log* n).\n\nObstacles\n\n- The SCC-constant condition is sufficient but not necessary; we still need a compressed, exact certificate. The planned refinement is a \u201cwindow-transducer\u201d defined only on SCC languages: guess a map g_C from bounded-length input windows (over the SCC) to outputs; check homomorphism constraints on the SCC de Bruijn graph. This stays in EXPTIME if the window size is chosen polylog(|T|), but proving such a bound remains open.\n\nNext steps\n\n1) Add to proofs.md: rigorous statement/proof of the replacement lemma and the middle-gap verifier with \u03c4_b,\u03c4_c \u2208 R_K\u222aR_{K+1}.\n2) Implement and test the Z_per necessity filter; produce small counterexamples that fail it and are indeed \u03a9(log* n).\n3) Formalize the SCC-constant sufficient certificate and its O(1) algorithm; add as a partial result toward the top-gap.\n4) Work toward the \u201cwindow-transducer over SCC\u201d compression lemma: specify the SCC-window automaton and the EXPTIME homomorphism check; attempt to bound the needed window size by |T|-related parameters.\n"
}