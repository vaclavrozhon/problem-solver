Ideas

- Fix F_i := EÂ·S_i for i âˆˆ {0,1} and T_w := F_{i_1}F_{i_2}â‹¯F_{i_k} (Boolean semiring). This convention makes all statements uniform and keeps â€œedge-then-nodeâ€ checks inline. Types are exactly T_w.
- Middle-gap: finalize the EXPTIME verifier using only matrix products and the length-filter correction (Ï„_b,Ï„_c âˆˆ R_KâˆªR_{K+1}). No language complementation needed.
- Top-gap: isolate an EXPTIME-computable necessary condition for O(1) (period feasibility without anchors) via the â€œright-stabilizerâ€ set Z_per := { Z âˆˆ âŸ¨F_0,F_1âŸ© : âˆƒMâˆˆâŸ¨F_0,F_1âŸ©, MÂ·Z = M }. Show diag(Z)â‰ âˆ… is necessary. Also give a simple, EXPTIME-checkable sufficient condition (SCC-constant certificate) that, together with the middle-gap f_type, yields an O(1) algorithm. This is not yet a full characterization but is a concrete step toward a compressed certificate.

Replacement and composition (radius 1)

Definition. Let E[x,y]=1 â‡” (x,y)âˆˆC_outâ€“out and S_i diagonal with S_i[x,x]=1 â‡” (i,x)âˆˆC_inâ€“out. Define F_i := EÂ·S_i and, for w=i_1â‹¯i_k, T_w := F_{i_1}â‹¯F_{i_k}. Two segments P,Q have the same type iff T_P=T_Q. Concatenation obeys T_{uv}=T_uÂ·T_v.

Lemma (matrix replacement). Let G be a directed path/cycle. Let PâŠ†G and Pâ€² another segment with T_P=T_{Pâ€²}. Suppose a labeling of G is locally consistent at all nodes of P. Then replacing P by Pâ€² yields a labeling that is locally consistent on Pâ€² and unchanged outside Pâ€². Proof. With radius 1, the only interface a segment exposes is the boundary relation T_P; equal relations imply identical extendibility. Composition follows from T_{uv}=T_uÂ·T_v.

Middle-gap certificate: EXPTIME verification

- Build the reachable set T by BFS on Î´(M,i)=MÂ·F_i from I; cost 2^{O(Î²^2)}Â·poly(Î²).
- Compute R_â„“ âŠ† T, the types realized by exactly â„“ inputs, by iterating R_{â„“+1}={MÂ·F_i : MâˆˆR_â„“, iâˆˆ{0,1}}; set K=|T| and use Ï„_b,Ï„_c âˆˆ R_KâˆªR_{K+1}.
- Guess f_type: TÃ—{00,01,10,11}Ã—Tâ†’Î£_out^2; verify for each triple (Ï„_L,S,Ï„_R) that (i) local legality holds: S[1] on left output, edge E between the pair, and S[2] on right output; (ii) for all Ï„_b,Ï„_c âˆˆ R_KâˆªR_{K+1} and S1,S2, if f_type(Â·,S1,Ï„_b)=(â„“_1,â„“_2) and f_type(Ï„_c,S2,Â·)=(r_1,r_2), then (F_{Ï„_b}Â·F_{Ï„_c}Â·E)[â„“_2,r_1]=1. Here F_{Ï„}:=T_w for any w with type Ï„. The check is a scalar lookup after precomputing the products; total EXPTIME.
- If some f_type passes, conclude O(log* n); else Î˜(n). This completes a NEXPTIME decision for the middle gap.

Top-gap: periodic necessity via right-stabilizers

Definition (period generators). Let S:=âŸ¨F_0,F_1âŸ©âŠ†{0,1}^{Î²Ã—Î²}. Define Z_per := { Z âˆˆ S : âˆƒ M âˆˆ S with MÂ·Z = M } (Z stabilizes some type on the right; these are exactly products labeling cycles in the type automaton).

Lemma (necessary condition for O(1)). If the LCL has an O(1) algorithm, then for every ZâˆˆZ_per, âˆƒxâˆˆÎ£_out with Z[x,x]=1.
Proof. Consider any long periodic input segment w^m whose period w yields Z=T_w and whose run in the type automaton stays in a cycle. A constant-time, ID-free algorithm cannot introduce anchors on a fully periodic instance; its output on w^m must be shift-invariant and hence valid on arbitrarily many repetitions. This implies the existence of a one-period closed witness of outputs; algebraically, Z has a diagonal 1. Otherwise, any attempt to close the period creates an interface conflict at the wrap-around. Since Z_per has size â‰¤ |S|Â·|S| â‰¤ 2^{O(Î²^2)}, this test is EXPTIME.

Top-gap: a sufficient certificate (SCC-constant)

Let ğ”„ be the type automaton on state set T with transitions Î´(M,i)=MÂ·F_i. Compute its SCCs C. The following is sufficient for O(1):
- There exists f_type passing the middle-gap verifier (above), and
- For each SCC C, âˆƒx_C âˆˆ Î£_out s.t. E[x_C,x_C]=1 and D_i[x_C,x_C]=1 for every i labeling some edge inside C.
Construction (O(1) algorithm).
- Compute an (L_width,L_count,L_pattern)-partition (paperâ€™s lemma) with L_width=L_pattern=|T|, L_count=2|T|+2. This splits the cycle into short paths P_short and long periodic paths P_long whose input runs stay inside some SCC C and have at least L_count/|w| periods.
- On each P_long in SCC C, assign every node output x_C. Local legality holds by choices of E and D; since outputs are constant, the algorithm is phase-free and radius-1.
- Use f_type to label the length-2 separators and fill the gaps (middle-gap lemma). Remaining unlabeled components are O(1)-sized; fill them locally.
- Total runtime O(1).
Remarks. This â€œSCC-constantâ€ certificate is checkable in EXPTIME (compute SCCs; for each C, test feasibility of x_C by scanning D_0,D_1 and E). It is likely not necessary (there are cases where periodic outputs alternate but are phase-discernible by local windows); it nonetheless provides a nontrivial sufficient condition within our matrix framework.

Examples

- Î²=2, E=complete, D_0=D_1=I. Then F_i=E, T={I,E}, Z_per={I,E}, and diag(E)â‰ âˆ…. SCC-constant holds with x_C arbitrary; algorithm returns O(1).
- Î²=2, E has only self-loops (E=I), D_0=diag(1,0), D_1=diag(0,1). Then F_0=diag(1,0), F_1=diag(0,1). Z_per contains F_0,F_1; both have empty diagonal on the forbidden coordinate. Necessity detects Î©(log* n).

Obstacles

- The SCC-constant condition is sufficient but not necessary; we still need a compressed, exact certificate. The planned refinement is a â€œwindow-transducerâ€ defined only on SCC languages: guess a map g_C from bounded-length input windows (over the SCC) to outputs; check homomorphism constraints on the SCC de Bruijn graph. This stays in EXPTIME if the window size is chosen polylog(|T|), but proving such a bound remains open.

Next steps

1) Add to proofs.md: rigorous statement/proof of the replacement lemma and the middle-gap verifier with Ï„_b,Ï„_c âˆˆ R_KâˆªR_{K+1}.
2) Implement and test the Z_per necessity filter; produce small counterexamples that fail it and are indeed Î©(log* n).
3) Formalize the SCC-constant sufficient certificate and its O(1) algorithm; add as a partial result toward the top-gap.
4) Work toward the â€œwindow-transducer over SCCâ€ compression lemma: specify the SCC-window automaton and the EXPTIME homomorphism check; attempt to bound the needed window size by |T|-related parameters.
