{
  "content": "Ideas\n- Strengthen the transfer-matrix method to cover the top gap (O(1) vs \u03a9(log* n)) with an exponential-size certificate verifiable in EXPTIME, yielding a NEXPTIME decision procedure.\n- Use two ingredients: (i) per-type periodic pairs for primitive periods (allowing us to label long periodic runs), and (ii) a short-separator table identical in spirit to the middle-gap feasible function. All checks reduce to constant-size Boolean matrix products over reachable types.\n\nDefinitions and Notation\n- Let \u03a3in={0,1}, |\u03a3out|=\u03b2. Let A\u2208{0,1}^{\u03b2\u00d7\u03b2} be the adjacency (Cout\u2013out). For s\u2208{0,1}, let Ds be diagonal with Ds[z,z]=1 iff (s,z)\u2208Cin\u2013out.\n- For w=s1\u2026sk, define M(w)=Ds1\u00b7A\u00b7Ds2\u00b7A\u00b7\u2026\u00b7A\u00b7Dsk (Boolean semiring). This matrix is the type of w. Concatenation: M(uv)=M(u)\u00b7A\u00b7M(v).\n- Type automaton: states T are matrices reachable from {D0,D1} under \u03b4(M,s)=M\u00b7A\u00b7Ds. Build T by BFS; |T|\u22642^{\u03b2^2}.\n- Let K=|T|. For exact lengths \u2113, let R\u2113 be types reachable by some word of length \u2113; compute R\u2113 by dynamic programming. Let Tshort=\u22c3_{\u2113\u22642K}R\u2113.\n- Primitive-period types Ptypes: types of primitive words of length at most K. Enumerate by scanning all \u03c4\u2208R\u2113, 1\u2264\u2113\u2264K, and eliminating those realizable by a nontrivial power (decidable via the automaton; see Example below).\n\nLemma 1 (Replacement by type; radius-1 version)\nIf two fragments P,Q have the same type M(P)=M(Q), then for any fixed outputs a on the predecessor of P and b on the successor of P satisfying A[a,a1]=1 and A[bk,b]=1 (where a1, bk denote outputs on the endpoints of P), P can be replaced by Q while preserving global legality by relabeling only the interior. Proof: identical to the standard radius-1 replacement, using that M encodes precisely the existence of an output-path consistent with the input and A encodes the boundary constraints.\n\nCertificate for O(1): periodic pairs + short-separator table\n- Periodic pairs: pick p: Ptypes\u2192\u03a3out\u00d7\u03a3out with p(\u03c4)=(a\u03c4,b\u03c4) such that \u03c4[a\u03c4,b\u03c4]=1 and A[b\u03c4,a\u03c4]=1. This guarantees a legal periodic labeling for any block repeating any primitive word w with M(w)=\u03c4 (existentially, by the definition of M and the wrap-around constraint A[b\u03c4,a\u03c4]=1).\n- Short-separator table (length-2 separator): g: T\u00d7{00,01,10,11}\u00d7T\u2192\u03a3out^2. For each (\u03c4L,S,\u03c4R) with S=(sL,sR), output (x,y)\u2208\u03a3out^2 subject to local legality (DsL[x,x]=1, A[x,y]=1, DsR[y,y]=1).\n\nInterface (bridge) constraints\nFor all \u03c4a,\u03c4b,\u03c4c,\u03c4d\u2208Ptypes and S1,S2\u2208{0,1}^2, write g(\u03c4a,S1,\u03c4b)=(\u21131,\u21132) and g(\u03c4c,S2,\u03c4d)=(r1,r2). Require the existence of a legal filling of the middle between the two S-windows when the left/right long blocks are periodic with (a,b) pairs p(\u03c4b)=(ab,bb) and p(\u03c4c)=(ac,bc). A sufficient (and necessary for radius-1) scalar condition is:\n(1) (A \u00b7 M_b \u00b7 A \u00b7 M_c \u00b7 A)[\u21132, r1] = 1,\nwhere M_b, M_c are the chosen representatives of \u03c4b, \u03c4c (any choices; replacement makes the condition type-dependent only). This encodes: from the last output of S1, take one A-step into the left block, traverse M_b, bridge by A into the right block, traverse M_c, and take one A-step to reach the first output of S2.\n\nAdditionally, separators against endpoints of a path are handled by replacing M_b (or M_c) by the identity (no interior) and dropping one A as appropriate; on cycles (our baseline), Eq. (1) suffices.\n\nLemma 2 (Sufficient certificate \u21d2 O(1))\nAssume we are given p and g satisfying the local legality and all bridge constraints (1) for every choice of \u03c4a,\u03c4b,\u03c4c,\u03c4d\u2208Ptypes and S1,S2\u2208{0,1}^2. Then there exists an O(1)-round algorithm.\nProof sketch:\n- In O(1) rounds, compute an (Lwidth,Lcount,Lpattern)-partition with Lwidth=Lpattern=K and Lcount=2K+2 (by Lemma in the paper; orientation is given). Every maximal long piece P\u2208Plong is a repetition w^m of a primitive w with |w|\u2264K.\n- For each long piece P of type \u03c4, use p(\u03c4)=(a,b) to fix a legal periodic labeling on its interior: within each period, pick any witness realizing \u03c4[a,b]=1; between periods, A[b,a]=1 closes the cycle. This step is local as all nodes in P know the period w and its direction.\n- On each short separator S (length 2 by construction), use g to label its two nodes. Now only the short residual zones at the interfaces remain unlabeled.\n- The bridge constraints (1) guarantee that between each pair of adjacent long blocks across a separator there exists a legal fill (by Lemma 1 replacement, using M_b, M_c), and these fills are confined to O(1) length regions. Perform these fills locally. Resulting labeling is globally legal.\n\nComplexity of verification (EXPTIME)\n- Building T and R\u2113, Ptypes and Tshort takes 2^{O(\u03b2^2)}\u00b7poly(\u03b2) time.\n- Guess p and g: size O(|Ptypes|\u00b7log \u03b2 + |T|^2\u00b74\u00b7log \u03b2)=2^{O(\u03b2^2)} bits.\n- Check local legality for all entries of g in poly(\u03b2). Check periodicity for p by verifying \u03c4[a,b]=1 and A[b,a]=1 (\u03b2^2 checks per \u03c4).\n- For all quadruples \u03c4a,\u03c4b,\u03c4c,\u03c4d and S1,S2 (\u22644\u00b7|Ptypes|^4 entries), check (1) by a constant number of Boolean matrix multiplications (O(\u03b2^3) per check). Total deterministic verification time 2^{O(\u03b2^2)}\u00b7poly(\u03b2).\nThus, existence of such a certificate is in NEXPTIME.\n\nExample sanity checks\n- Trivial labeling: If Ds=I for both s and A=J (all ones), then any choices p(\u03c4) with A[b,a]=1 hold, and (1) is trivially true since products equal J. Algorithm reports O(1).\n- Parity/2-coloring variant: If A is \u201cnot-equal\u201d on two outputs and Ds=I, Ptypes={\u03c4\u22c6} with \u03c4\u22c6=J. Choose p(\u03c4\u22c6)=(1,2). For any S, g must output (x,y) with x\u2260y. Then (A\u00b7J\u00b7A\u00b7J\u00b7A)[\u21132,r1]=A[\u21132,r1], so it forces \u21132\u2260r1. This is satisfiable by selecting g to alternate; if some universal choices fail for all pairs, certificate doesn\u2019t exist and the algorithm declares \u03a9(log* n). This aligns with the known need for symmetry breaking in constant time.\n\nAuxiliary routine: detecting primitive-period types\nGiven \u03c4\u2208R\u2113 (1\u2264\u2113\u2264K), decide if \u03c4 arises from some v^m with m\u22652 and |v|<\u2113: nondeterministically split \u2113 into d\u00b7m with d<\u2113, m\u22652, and check if there exists \u03c4v\u2208Rd such that \u03c4 = \u03c4v \u00b7 (A\u00b7\u03c4v)^{m-1} (by concatenation). If none matches, classify \u03c4 as primitive. This uses only matrix products and membership tests in R\u2113.\n\nObstacles (completeness)\n- We have only sufficiency: a certificate implies O(1). To get a decision procedure, we need a compression lemma: any O(1)-round algorithm yields p and g satisfying our constraints. Intuitively, the algorithm\u2019s behavior on long periodic inputs induces periodic outputs; existence of a \u201cstable phase\u201d yields (a,b) with \u03c4[a,b] and A[b,a]; locality on short separators yields a constant S-table g; replacement shows type-only dependence. Formalizing this extraction without unrolling doubly-exponential periodicities is the key remaining step.\n\nWhy types suffice for periodicity\nFor any two words w,w\u2032 with M(w)=M(w\u2032)=\u03c4 and any (a,b) with \u03c4[a,b]=1, there exist interior outputs realizing a\u2192b for both w and w\u2032 (by the definition of M). Thus choosing a wrap-around pair with A[b,a]=1 produces a periodic output for any representative of \u03c4. Hence periodic feasibility depends only on \u03c4, not on the specific w.\n\nNext steps\n1) Formalize and prove the extraction lemma: given a t=O(1) algorithm, build p and g of size 2^{O(\u03b2^2)} that satisfy (1). Use run stabilization on long periodic inputs and type replacement to argue type-only dependence.\n2) Add endpoint handling (paths) formally; currently the above is for cycles; adjust (1) by removing leading/trailing A factors.\n3) Implement computation of Ptypes and Tshort and the NEXPTIME verifier; test on small \u03b2 with random constraints to find corner cases.\n4) Integrate with the existing middle-gap NEXPTIME test: overall trichotomy procedure is (i) try O(1); if no certificate then (ii) try O(log* n); if no then report \u0398(n).\n"
}