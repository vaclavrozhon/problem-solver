All provers correctly leverage the radius‑1 transfer‑matrix abstraction: a segment’s observable interface is a β×β Boolean relation, composition is Boolean matrix product, and equal matrices give a clean replacement lemma. The middle‑gap (O(log* n) vs Θ(n)) certificate based on a type‑indexed separator table and the scalar bridge check (E·M_{τ_b}·E·M_{τ_c}·E)[ℓ_2,r_1]=1 is sound. A necessary correction (now incorporated) is to restrict τ_b,τ_c to types realized at lengths K or K+1, where K=|T|, to match the standard decomposition and avoid false negatives.

Top gap (O(1) vs Ω(log* n)): Prover 1’s proposed EXPTIME test via per‑type loop sets L_τ = ⋃_{e≤β} diag((M_τ·E)^e) and universal bridges over short types appears insufficient. The step “tile with an e‑chunk to enforce the same boundary x on both ends” is generally false when the number of periods in a long block is not a multiple of e; an O(1) partition cannot globally align block lengths to a fixed residue. A minimal counterexample schema: Σ_out={a,b}, E is the 2‑cycle a↔b, Cin–out admits both outputs on both inputs. Then (M_τ·E)^2 has nonempty diagonal so L_τ≠∅ for all τ, and C_σ reduces to powers of E, yet the problem is known to require Θ(log* n) on cycles; the proposed test would (incorrectly) accept. The missing ingredient is residue/aperiodicity handling: you need guarantees that boundary‑to‑boundary walks exist for all relevant block lengths (K or K+1 periods), not just for some e≤β.

Prover 3’s necessary condition via right‑stabilizers Z_per and the SCC‑constant sufficient certificate are solid partial results (necessary and sufficient, respectively), but do not yet yield a full characterization. Prover 4’s “periodic pairs + short‑separator table” is a promising sufficient certificate, but the extraction/completeness direction remains unproven and likely needs residue‑class reasoning or idempotent elements in the type monoid.

Actionable next steps:
- Keep the middle‑gap NEXPTIME verifier; implement with τ_b,τ_c∈R_K∪R_{K+1}.
- For O(1), strengthen the per‑type periodic criterion to account for gcds of cycle lengths (aperiodicity) or use idempotents in the monoid ⟨E·S_0,E·S_1⟩; define per‑type boundary relation families achievable for all lengths in {K,K+1}, and re‑formulate the EXPTIME checks accordingly.
- Develop an extraction lemma from any O(1) algorithm to an exponential per‑type certificate (e.g., idempotent/aperiodic choices plus an interface table), then prove EXPTIME verifiability.
