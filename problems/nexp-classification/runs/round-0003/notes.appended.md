# Research Notes



Research log – radius‑1 oriented paths via transfer matrices

Setup
- Outputs Σ_out of size β; inputs Σ_in={0,1}. Let E∈{0,1}^{β×β} with E[x,y]=1 iff (x,y)∈C_out–out. For i∈{0,1}, let S_i be diagonal with (S_i)[x,x]=1 iff (i,x)∈C_in–out.
- For w=i_1…i_k, define the transfer matrix M(w)=S_{i_1}·E·S_{i_2}·E·…·E·S_{i_k} (Boolean semiring). Two segments have the same type iff their M(·) matrices are equal.
- Composition: M(P·Q)=M(P)·E·M(Q). Replacement: If M(P)=M(P′), then P and P′ are interchangeable inside any larger instance while keeping outside outputs fixed.

Type automaton
- States: reachable matrices; transitions δ(M,i)=M·E·S_i; seeds {S_0,S_1}. Reachable set T has size ≤2^{β^2}. Build by BFS in 2^{O(β^2)}·poly(β) time.
- For length awareness, compute R_ℓ (types of words of exact length ℓ) by iterating R_{ℓ+1}={M·E·S_i: M∈R_ℓ, i∈{0,1}}. Let K=|T|; the standard decomposition uses gaps of length K or K+1.

Middle-gap feasible function (corrected)
- Certificate: f_type: T×{00,01,10,11}×T→Σ_out^2. For each (τ_L,S,τ_R), outputs (x,y) with local legality: (S[1],x)∈C_in–out, (x,y)∈C_out–out, (S[2],y)∈C_in–out.
- Bridge check: For all τ_b,τ_c ∈ R_K∪R_{K+1} and S1,S2, letting L1=f_type(·,S1,τ_b)=(ℓ_1,ℓ_2) and L2=f_type(τ_c,S2,·)=(r_1,r_2), require (E·M_{τ_b}·E·M_{τ_c}·E)[ℓ_2,r_1]=1.
- If such an f_type exists, label length‑2 separators by f_type and fill each gap by the bridge condition, yielding an O(log* n) algorithm; else complexity is Θ(n).

Complexity
- Build T, R_K, R_{K+1}: EXPTIME. Guess f_type of size 2^{Θ(β^2)}; verify all constraints over τ_b,τ_c∈R_K∪R_{K+1} in EXPTIME. Overall: NEXPTIME.

Top gap (O(1) vs Ω(log* n)) – plan
- Per-type periodicity: For τ, characterize admissible periodic outputs as cycles in the output digraph constrained by the type τ (computed from the monoid generated by F_i=E·S_i). Guess per‑type selections and check interfaces via fixed products like E·M_{τ_b}·E and M_{τ_c}. Prove a compression lemma: any O(1) feasible mapping admits an exponential per‑type certificate verifiable in EXPTIME.

Action items
1) Implement T, R_K, R_{K+1} and the NEXPTIME verifier for O(log* n) vs Θ(n).
2) Formalize per‑type admissible periodic sets and interface constraints; attempt the compression lemma.
3) Validate on small β instances; probe edge cases (e.g., sparse E, forced outputs in S_i).

Caution on the top-gap (O(1) vs Ω(log* n))

Issue with per-type loop sets.
- Proposal: L_τ := ⋃_{e≤β} diag((M_τ·E)^e); choose x∈L_τ and “tile” long periodic blocks with an e-chunk to enforce boundary x on both ends, then bridge short separators via C_σ=E·M_σ·E.
- Problem: This does not guarantee feasibility for arbitrary block lengths (numbers of periods). If m is not a multiple of e, A_τ^e[x,x]=1 does not imply A_τ^m[x,x]=1, so you cannot generally fix both boundaries to x. An O(1) partition cannot globally align blocks to a fixed residue.

Counterexample schema (parity).
- Σ_out={a,b}; E is the 2-cycle a↔b; S_0,S_1 allow both outputs. Then for every τ, (M_τ·E)^2 has nonempty diagonal, so L_τ≠∅ and C_σ reduces to powers of E, seemingly satisfying the test. However, proper 2-coloring on cycles requires Θ(log* n), so the test would be a false positive.

Takeaway: Any O(1) certificate must encode residue/aperiodicity constraints for all relevant block lengths (K or K+1). A promising direction is to use the finite monoid ⟨E·S_0,E·S_1⟩: extract idempotents and cycle-length gcds within SCCs to define per-type boundary behaviors achievable for all required lengths, then verify constant-size bridge conditions.

Middle-gap verifier (finalized).
- Restrict τ_b,τ_c to R_K∪R_{K+1} (types realized by exactly K or K+1 inputs). With this restriction, the type-based separator function f_type and the scalar check (E·M_{τ_b}·E·M_{τ_c}·E)[ℓ_2,r_1]=1 give a sound and complete NEXPTIME procedure for O(log* n) vs Θ(n).

Next steps toward O(1):
1) Compute for each τ the set of residues (mod d_τ) for which A_τ^m has diagonal entries, via SCC cycle-length gcds; ensure coverage for m corresponding to K or K+1 repetitions.
2) Formulate an exponential per-type certificate using monoid idempotents and residue classes; prove an extraction lemma from any O(1) algorithm; verify interfaces by fixed matrix products.
