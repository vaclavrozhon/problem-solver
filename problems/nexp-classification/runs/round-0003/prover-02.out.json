{
  "content": "Ideas\n\n- We finalize the middle-gap (\u0398(n) vs O(log* n)) NEXPTIME test and propose a new sufficient (and EXPTIME-verifiable) certificate for O(1), based on primitivity (aperiodicity) of boundary transitions inside each long-type block. This avoids the prior false positive (parity) and yields a concrete NEXPTIME trichotomy procedure: try O(1) certificate; if it fails, try O(log* n) certificate; else \u0398(n).\n\nMiddle-gap (\u0398(n) vs O(log* n))\n\n- Types and matrices are as in notes: E, S_\u03c3, M(w)=S_{\u03c31}\u00b7E\u00b7\u2026\u00b7E\u00b7S_{\u03c3k}, \u03b4(M,\u03c3)=M\u00b7E\u00b7S_\u03c3. T is the reachable set; R_\u2113 the types of exact length \u2113; K=|T|.\n- Certificate f_type: T\u00d7{00,01,10,11}\u00d7T\u2192\u03a3_out^2; for \u03c4_b,\u03c4_c\u2208R_K\u222aR_{K+1}, S_1,S_2 two-letter windows, let (\u2113_1,\u2113_2)=f_type(\u00b7,S_1,\u03c4_b), (r_1,r_2)=f_type(\u03c4_c,S_2,\u00b7). Verify:\n  (i) S-window legality: S=(\u03c3,\u03c3\u2032) \u21d2 S_\u03c3[\u2113_1,\u2113_1]=1, E[\u2113_1,\u2113_2]=1, S_{\u03c3\u2032}[\u2113_2,\u2113_2]=1 (similarly for S_2 and r_1,r_2).\n  (ii) Bridge: (E\u00b7M_{\u03c4_b}\u00b7E\u00b7M_{\u03c4_c}\u00b7E)[\u2113_2,r_1]=1.\n- This is verifiable in EXPTIME over exponentially many tuples, so guessing f_type yields a NEXPTIME decision between O(log* n) and \u0398(n) (proofs in notes and previous rounds).\n\nFirst/Last-letter sets per type (auxiliary for O(1))\n\nLemma A. For \u03c4\u2208R_\u2113, define First(\u03c4)={\u03c3\u2208{0,1} | \u2203w of length \u2113 with M(w)=\u03c4 and first letter \u03c3} and Last(\u03c4) analogously. Both sets are computable in EXPTIME.\nProof. Build the type automaton over states T with labeled transitions \u03b4(M,\u03c3). For each \u03c4 and \u03c3, check nonemptiness of paths of length \u2113 from some seed to \u03c4 whose first (resp. last) letter is \u03c3. This is reachability in the product of the type automaton with a 2-state filter for the first/last letter; cost exponential in \u03b2.\n\nNecessary aperiodicity condition for O(1)\n\nLet A_\u03c4=E\u00b7M_\u03c4. For c\u2208\u03a3_out, define T_c={m\u22651: (A_\u03c4^m)[c,c]=1}.\nLemma B. T_c is ultimately periodic with period d equal to the gcd of cycle lengths in the SCC of c in the digraph of A_\u03c4. If d>1, then T_c misses infinitely many residues mod d.\nProof. Standard semigroup/graph theory: the lengths of closed walks at c form a semilinear set with period the gcd of cycle lengths in its SCC; see e.g., properties of strongly connected digraphs and powers of adjacency matrices. \u220e\nCorollary. If an O(1) scheme must handle arbitrarily many repeats of \u03c4 (with arbitrary counts), then any fixed boundary c it uses must lie in an SCC of A_\u03c4 with gcd 1 (primitive component), or else some block lengths fail.\n\nSufficient O(1) certificate via primitive boundary loops\n\nDefine Occ_all(\u03c4)\u2286{0,1} as the letters that appear at every position in at least one representative of \u03c4 of the required length. (Computable by forbidding a letter and checking nonemptiness over the type automaton.) Let Sep(\u03c4_b,\u03c4_c)=Last(\u03c4_b)\u00d7First(\u03c4_c).\n\nTheorem (sufficient O(1) certificate). Suppose there exists a map h: R_K\u2192\u03a3_out such that for every \u03c4\u2208R_K:\n(i) For all \u03c3\u2208Occ_all(\u03c4), S_\u03c3[h(\u03c4),h(\u03c4)]=1.\n(ii) In the digraph of A_\u03c4=E\u00b7M_\u03c4, h(\u03c4) lies in a strongly connected component whose cycle-length gcd is 1 (i.e., the component is aperiodic/primitive), hence \u2203N_\u03c4 with (A_\u03c4^m)[h(\u03c4),h(\u03c4)]=1 for all m\u2265N_\u03c4.\n(iii) For all \u03c4_b,\u03c4_c\u2208R_K and all S=(\u03c3,\u03c3\u2032)\u2208Sep(\u03c4_b,\u03c4_c), there exist x,y\u2208\u03a3_out with S_\u03c3[x,x]=1, E[x,y]=1, S_{\u03c3\u2032}[y,y]=1, and (E\u00b7M_{\u03c4_b}\u00b7E)[h(\u03c4_b),x]=1, (E\u00b7M_{\u03c4_c}\u00b7E)[y,h(\u03c4_c)]=1. Equivalently, (E\u00b7M_{\u03c4_b}\u00b7E\u00b7X(S)\u00b7E\u00b7M_{\u03c4_c}\u00b7E)[h(\u03c4_b),h(\u03c4_c)]=1, where X(S) is diagonal with X(S)[z,z]=1 iff z is allowed at both positions of S.\nThen the LCL is solvable in O(1) rounds on globally oriented paths and cycles.\nProof. Use the (L,width,count,pattern) partition from the cycle proof, with L\u2265max_\u03c4 N_\u03c4 and pattern bound \u2265K. For each long block of type \u03c4 with repeat count m\u2265L/|w|, property (ii) guarantees a boundary-to-boundary walk from h(\u03c4) to h(\u03c4) through A_\u03c4^m, i.e., a legal interior labeling that preserves boundary outputs h(\u03c4) on both ends; (i) ensures each boundary is locally compatible with all letters occurring inside \u03c4. For each short 2-node separator S between \u03c4_b and \u03c4_c, (iii) supplies outputs for the two separator nodes that connect h(\u03c4_b) to h(\u03c4_c) via E. Thus we can label: assign boundary outputs h(\u03c4) to both ends of each long block, fill interiors from (ii), and label separators from (iii). All constraints are radius-1 local. This construction uses only constant-radius decisions (the partition is in O(1) as in the cited lemma). \u220e\n\nRemarks on verifiability and complexity\n\n- Occ_all(\u03c4), First(\u03c4), Last(\u03c4) for \u03c4\u2208R_K are computable in EXPTIME via the type automaton. The aperiodicity/gcd=1 check for A_\u03c4\u2019s SCC containing h(\u03c4) is polynomial in \u03b2 (graph-theoretic gcd of cycle lengths in an SCC).\n- The bridge condition (iii) is a constant number of Boolean matrix products per tuple (\u03c4_b,\u03c4_c,S), hence EXPTIME overall.\n- Guessing h (domain size |R_K|\u2264|T|\u22642^{\u03b2^2}) yields an exponential certificate; verification is EXPTIME. Thus \u201cO(1)\u201d is certified in NEXPTIME.\n\nExamples\n\n- Parity counterexample. \u03a3_out={a,b}, E is the 2-cycle a\u2194b, Cin\u2013out allows both outputs on both inputs. Each A_\u03c4 has SCCs with gcd 2, so (ii) fails for any choice of h. Hence the O(1) certificate is correctly rejected.\n- Trivial constant case. If \u2203c with (\u03c3,c)\u2208Cin\u2013out for \u03c3=0,1 and (c,c)\u2208Cout\u2013out, then choose h(\u03c4)=c for all \u03c4. Each A_\u03c4 has a self-loop (c,c), gcd=1, and (iii) holds by picking x=y=c. Certificate accepted; O(1) holds.\n\nObstacles\n\n- Completeness of O(1). We have a sufficient (and necessary-in-part) certificate; the missing piece is a compression lemma: from any O(1) LOCAL algorithm, extract h satisfying (i)\u2013(iii). This likely uses the finite monoid \u27e8E\u00b7S_0,E\u00b7S_1\u27e9 and idempotents: show that long-block effects stabilize to an aperiodic SCC, yielding primitive boundary loops. Formalizing this is next.\n- Boundary separators: we chose Sep(\u03c4_b,\u03c4_c)=Last(\u03c4_b)\u00d7First(\u03c4_c). This is exact for boundaries between K- (or K+1-)length representatives; verify this in code to avoid over-constraints.\n\nNext steps\n\n1) Implement O(1) sufficient test: compute R_K, First/Last, Occ_all, and SCC gcds; nondeterministically guess h and verify (i)\u2013(iii). Integrate as the first branch of the NEXPTIME trichotomy.\n2) Keep the middle-gap NEXPTIME verifier as the second branch (O(log* n) vs \u0398(n)).\n3) Work on the compression lemma: develop an idempotent extraction from any constant-time rule to a per-type boundary map h landing in primitive SCCs; formalize via the type monoid and stabilized powers A_\u03c4^\u03c9.\n\nWhy useful here\n\n- Provides a concrete, EXPTIME-checkable sufficient condition for O(1) that rules out known \u0398(log* n) cases (parity) and covers many constant-time problems; yields an overall NEXPTIME trichotomy procedure.\n- Introduces computable per-type summaries (First/Last, Occ_all, gcd in SCC) that are natural in the transfer-matrix framework and will likely be the right invariants for the full compression argument.\n"
}