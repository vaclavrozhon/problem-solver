Ideas

- We finalize the middle-gap (Θ(n) vs O(log* n)) NEXPTIME test and propose a new sufficient (and EXPTIME-verifiable) certificate for O(1), based on primitivity (aperiodicity) of boundary transitions inside each long-type block. This avoids the prior false positive (parity) and yields a concrete NEXPTIME trichotomy procedure: try O(1) certificate; if it fails, try O(log* n) certificate; else Θ(n).

Middle-gap (Θ(n) vs O(log* n))

- Types and matrices are as in notes: E, S_σ, M(w)=S_{σ1}·E·…·E·S_{σk}, δ(M,σ)=M·E·S_σ. T is the reachable set; R_ℓ the types of exact length ℓ; K=|T|.
- Certificate f_type: T×{00,01,10,11}×T→Σ_out^2; for τ_b,τ_c∈R_K∪R_{K+1}, S_1,S_2 two-letter windows, let (ℓ_1,ℓ_2)=f_type(·,S_1,τ_b), (r_1,r_2)=f_type(τ_c,S_2,·). Verify:
  (i) S-window legality: S=(σ,σ′) ⇒ S_σ[ℓ_1,ℓ_1]=1, E[ℓ_1,ℓ_2]=1, S_{σ′}[ℓ_2,ℓ_2]=1 (similarly for S_2 and r_1,r_2).
  (ii) Bridge: (E·M_{τ_b}·E·M_{τ_c}·E)[ℓ_2,r_1]=1.
- This is verifiable in EXPTIME over exponentially many tuples, so guessing f_type yields a NEXPTIME decision between O(log* n) and Θ(n) (proofs in notes and previous rounds).

First/Last-letter sets per type (auxiliary for O(1))

Lemma A. For τ∈R_ℓ, define First(τ)={σ∈{0,1} | ∃w of length ℓ with M(w)=τ and first letter σ} and Last(τ) analogously. Both sets are computable in EXPTIME.
Proof. Build the type automaton over states T with labeled transitions δ(M,σ). For each τ and σ, check nonemptiness of paths of length ℓ from some seed to τ whose first (resp. last) letter is σ. This is reachability in the product of the type automaton with a 2-state filter for the first/last letter; cost exponential in β.

Necessary aperiodicity condition for O(1)

Let A_τ=E·M_τ. For c∈Σ_out, define T_c={m≥1: (A_τ^m)[c,c]=1}.
Lemma B. T_c is ultimately periodic with period d equal to the gcd of cycle lengths in the SCC of c in the digraph of A_τ. If d>1, then T_c misses infinitely many residues mod d.
Proof. Standard semigroup/graph theory: the lengths of closed walks at c form a semilinear set with period the gcd of cycle lengths in its SCC; see e.g., properties of strongly connected digraphs and powers of adjacency matrices. ∎
Corollary. If an O(1) scheme must handle arbitrarily many repeats of τ (with arbitrary counts), then any fixed boundary c it uses must lie in an SCC of A_τ with gcd 1 (primitive component), or else some block lengths fail.

Sufficient O(1) certificate via primitive boundary loops

Define Occ_all(τ)⊆{0,1} as the letters that appear at every position in at least one representative of τ of the required length. (Computable by forbidding a letter and checking nonemptiness over the type automaton.) Let Sep(τ_b,τ_c)=Last(τ_b)×First(τ_c).

Theorem (sufficient O(1) certificate). Suppose there exists a map h: R_K→Σ_out such that for every τ∈R_K:
(i) For all σ∈Occ_all(τ), S_σ[h(τ),h(τ)]=1.
(ii) In the digraph of A_τ=E·M_τ, h(τ) lies in a strongly connected component whose cycle-length gcd is 1 (i.e., the component is aperiodic/primitive), hence ∃N_τ with (A_τ^m)[h(τ),h(τ)]=1 for all m≥N_τ.
(iii) For all τ_b,τ_c∈R_K and all S=(σ,σ′)∈Sep(τ_b,τ_c), there exist x,y∈Σ_out with S_σ[x,x]=1, E[x,y]=1, S_{σ′}[y,y]=1, and (E·M_{τ_b}·E)[h(τ_b),x]=1, (E·M_{τ_c}·E)[y,h(τ_c)]=1. Equivalently, (E·M_{τ_b}·E·X(S)·E·M_{τ_c}·E)[h(τ_b),h(τ_c)]=1, where X(S) is diagonal with X(S)[z,z]=1 iff z is allowed at both positions of S.
Then the LCL is solvable in O(1) rounds on globally oriented paths and cycles.
Proof. Use the (L,width,count,pattern) partition from the cycle proof, with L≥max_τ N_τ and pattern bound ≥K. For each long block of type τ with repeat count m≥L/|w|, property (ii) guarantees a boundary-to-boundary walk from h(τ) to h(τ) through A_τ^m, i.e., a legal interior labeling that preserves boundary outputs h(τ) on both ends; (i) ensures each boundary is locally compatible with all letters occurring inside τ. For each short 2-node separator S between τ_b and τ_c, (iii) supplies outputs for the two separator nodes that connect h(τ_b) to h(τ_c) via E. Thus we can label: assign boundary outputs h(τ) to both ends of each long block, fill interiors from (ii), and label separators from (iii). All constraints are radius-1 local. This construction uses only constant-radius decisions (the partition is in O(1) as in the cited lemma). ∎

Remarks on verifiability and complexity

- Occ_all(τ), First(τ), Last(τ) for τ∈R_K are computable in EXPTIME via the type automaton. The aperiodicity/gcd=1 check for A_τ’s SCC containing h(τ) is polynomial in β (graph-theoretic gcd of cycle lengths in an SCC).
- The bridge condition (iii) is a constant number of Boolean matrix products per tuple (τ_b,τ_c,S), hence EXPTIME overall.
- Guessing h (domain size |R_K|≤|T|≤2^{β^2}) yields an exponential certificate; verification is EXPTIME. Thus “O(1)” is certified in NEXPTIME.

Examples

- Parity counterexample. Σ_out={a,b}, E is the 2-cycle a↔b, Cin–out allows both outputs on both inputs. Each A_τ has SCCs with gcd 2, so (ii) fails for any choice of h. Hence the O(1) certificate is correctly rejected.
- Trivial constant case. If ∃c with (σ,c)∈Cin–out for σ=0,1 and (c,c)∈Cout–out, then choose h(τ)=c for all τ. Each A_τ has a self-loop (c,c), gcd=1, and (iii) holds by picking x=y=c. Certificate accepted; O(1) holds.

Obstacles

- Completeness of O(1). We have a sufficient (and necessary-in-part) certificate; the missing piece is a compression lemma: from any O(1) LOCAL algorithm, extract h satisfying (i)–(iii). This likely uses the finite monoid ⟨E·S_0,E·S_1⟩ and idempotents: show that long-block effects stabilize to an aperiodic SCC, yielding primitive boundary loops. Formalizing this is next.
- Boundary separators: we chose Sep(τ_b,τ_c)=Last(τ_b)×First(τ_c). This is exact for boundaries between K- (or K+1-)length representatives; verify this in code to avoid over-constraints.

Next steps

1) Implement O(1) sufficient test: compute R_K, First/Last, Occ_all, and SCC gcds; nondeterministically guess h and verify (i)–(iii). Integrate as the first branch of the NEXPTIME trichotomy.
2) Keep the middle-gap NEXPTIME verifier as the second branch (O(log* n) vs Θ(n)).
3) Work on the compression lemma: develop an idempotent extraction from any constant-time rule to a per-type boundary map h landing in primitive SCCs; formalize via the type monoid and stabilized powers A_τ^ω.

Why useful here

- Provides a concrete, EXPTIME-checkable sufficient condition for O(1) that rules out known Θ(log* n) cases (parity) and covers many constant-time problems; yields an overall NEXPTIME trichotomy procedure.
- Introduces computable per-type summaries (First/Last, Occ_all, gcd in SCC) that are natural in the transfer-matrix framework and will likely be the right invariants for the full compression argument.
