{
  "content": "Ideas\n\n- Finalize a clean, type/matrix formulation for the middle-gap NEXPTIME decision (O(log* n) vs \u0398(n)) and record exact verification conditions over the length-filtered type sets R_K, R_{K+1}.\n- Add two auditable pieces for the top gap (O(1) vs \u03a9(log* n)):\n  1) A sufficient \u201cSCC-constant\u201d certificate (EXPTIME-checkable) that yields an O(1) algorithm.\n  2) A necessary \u201ctwo-cycle obstruction\u201d that forces \u03a9(log* n); this generalizes the parity counterexample and is EXPTIME-checkable.\n\nRigorous statements and proofs\n\nLemma 1 (matrix replacement; radius 1).\nLet E[x,y]=1 iff (x,y)\u2208C_out\u2013out and S_i diagonal with (S_i)[x,x]=1 iff (i,x)\u2208C_in\u2013out. Define F_i:=E\u00b7S_i, and for w=i_1\u2026i_k set T_w:=F_{i_1}\u22efF_{i_k} (Boolean semiring). If two input segments P,Q satisfy T_P=T_Q, then in any larger instance, replacing P by Q preserves extendibility: any legal labeling that is locally consistent at all nodes of P remains locally consistent after the replacement and unchanged outside P.\nProof. With radius 1, the interface exposed by a segment is exactly the Boolean relation mapping its left boundary output to its right boundary output; this relation is T_w. Equal relations imply identical extendibility. Composition follows from T_{uv}=T_u\u00b7T_v.\n\nProposition 2 (middle-gap decision; NEXPTIME).\nLet T be the reachable set of types (matrices) obtained by BFS from I under \u03b4(M,i)=M\u00b7F_i; let K:=|T|. Let R_\u2113 be the set of types realized by exactly \u2113 inputs, defined by R_{\u2113+1}={M\u00b7F_i: M\u2208R_\u2113, i\u2208{0,1}}; compute R_K, R_{K+1}. Nondeterministically guess a table\nf_type: T\u00d7{00,01,10,11}\u00d7T \u2192 \u03a3_out^2.\nVerify:\n(i) Locality: for each (\u03c4_L,S,\u03c4_R) and (x,y)=f_type(\u03c4_L,S,\u03c4_R), we have S[1] allows x (diagonal of S_{S[1]}), E[x,y]=1, and S[2] allows y.\n(ii) Bridge: for all \u03c4_b,\u03c4_c\u2208R_K\u222aR_{K+1} and S1,S2, let f_type(\u00b7,S1,\u03c4_b)=(\u2113_1,\u2113_2), f_type(\u03c4_c,S2,\u00b7)=(r_1,r_2). Then (F_{\u03c4_b}\u00b7F_{\u03c4_c}\u00b7E)[\u2113_2,r_1]=1.\nIf some f_type passes, the LCL is solvable in O(log* n); else complexity is \u0398(n).\nProof sketch. The standard O(log* n) decomposition yields separators of size 2 and gaps of length K or K+1. Condition (i) makes separator labels locally legal; (ii) ensures every adjacent pair of gaps admits a legal filling consistent with separator outputs. All matrices are \u03b2\u00d7\u03b2, |T|\u22642^{\u03b2^2}, so verification is EXPTIME; guessing f_type is exponential \u21d2 NEXPTIME overall.\n\nLemma 3 (SCC-constant certificate; sufficient for O(1)).\nLet \ud835\udd04 be the type automaton on T with \u03b4(M,i)=M\u00b7F_i. Compute its SCCs C. Suppose there exists a separator table f_type passing Prop.2 and, for each SCC C, an output x_C\u2208\u03a3_out such that E[x_C,x_C]=1 and S_i[x_C,x_C]=1 for every i labeling some edge of C. Then there is an O(1)-round algorithm.\nProof. Use the (L_width,L_count,L_pattern)-partition with L_width=L_pattern=|T|, L_count=2|T|+2 (as in the paper). Each long periodic path resides in some SCC C; label all its nodes by x_C (radius-1 legality follows by E[x_C,x_C]=1 and S_i[x_C,x_C]=1 along the path). Label all separators via f_type, and fill remaining O(1)-sized unlabeled components locally (middle-gap lemma). Total time O(1).\n\nLemma 4 (two-cycle obstruction; necessary for \u03a9(log* n)).\nSuppose there exist outputs a\u2260b with E[a,a]=E[b,b]=0 and E[a,b]=E[b,a]=1, and S_0[a,a]=S_0[b,b]=S_1[a,a]=S_1[b,b]=1 (i.e., both outputs are allowed on both inputs). Then the LCL requires \u03a9(log* n) on cycles.\nProof. On any cycle whose inputs are arbitrary, the only way to satisfy edge constraints on the subalphabet {a,b} is a proper 2-coloring along the directed edges. Since both inputs allow both outputs, local input constraints do not restrict this freedom. Deterministic O(1) 2-coloring of cycles is impossible (Linial\u2019s lower bound). Therefore \u03a9(log* n).\n\nExamples\n\n- Complete E with self-loops everywhere, and S_0=S_1=I: Lemma 3 applies with x_C arbitrary \u21d2 O(1).\n- Parity: \u03a3_out={a,b}, E is the 2-cycle a\u2194b, and S_0=S_1=I: Lemma 4 applies \u21d2 \u03a9(log* n).\n\nObstacles and scope\n\n- Lemma 3 is sufficient but not necessary; it enforces constant output on each SCC. Many O(1) algorithms produce short-period outputs; capturing these requires handling residues (gcd of cycle lengths) within SCCs.\n- Lemma 4 is not the most general necessary condition; it isolates the widely occurring \u201c2-cycle\u201d obstruction. Extending this to longer permutations (and to residue-class constraints) is a natural next step.\n\nRefined direction for residues (plan)\n\nFor each primitive period w with type \u03c4:=T_w, analyze the semigroup \u3008\u03c4\u3009={\u03c4^m: m\u22650}. Compute, by repeated squaring, the sets D_m(\u03c4):={x: (\u03c4^m)[x,x]=1}. If for all \u03c4 reachable in long periodic blocks there exists x_\u03c4 with x_\u03c4\u2208D_K(\u03c4)\u2229D_{K+1}(\u03c4) and S_i[x_\u03c4,x_\u03c4]=1 for all i present in w, then one can place anchors of type x_\u03c4 at both ends of any gap of length K or K+1 and bridge via Prop.2; this yields a strictly more general sufficient certificate than Lemma 3 and remains EXPTIME-checkable. We leave a full proof of this \u201cresidue-diagonal\u201d certificate to the next round.\n\nNext steps\n\n1) Middle-gap: finalize proofs.md with Prop.2 (including the R_K,R_{K+1} restriction) and complexity accounting; prepare a small implementation to enumerate T and verify f_type.\n2) Top-gap sufficient: formalize Lemma 3 and its O(1) algorithm; add to proofs.md as a partial positive criterion.\n3) Top-gap necessary: formalize Lemma 4; search for generalizations (longer permutation cycles; gcd>1 obstructions) and provide check procedures.\n4) Residues: implement D_m(\u03c4) computation for m\u2208{K,K+1}; test the \u201cresidue-diagonal\u201d sufficient condition on random small \u03b2.\n"
}