Ideas

- Finalize a clean, type/matrix formulation for the middle-gap NEXPTIME decision (O(log* n) vs Î˜(n)) and record exact verification conditions over the length-filtered type sets R_K, R_{K+1}.
- Add two auditable pieces for the top gap (O(1) vs Î©(log* n)):
  1) A sufficient â€œSCC-constantâ€ certificate (EXPTIME-checkable) that yields an O(1) algorithm.
  2) A necessary â€œtwo-cycle obstructionâ€ that forces Î©(log* n); this generalizes the parity counterexample and is EXPTIME-checkable.

Rigorous statements and proofs

Lemma 1 (matrix replacement; radius 1).
Let E[x,y]=1 iff (x,y)âˆˆC_outâ€“out and S_i diagonal with (S_i)[x,x]=1 iff (i,x)âˆˆC_inâ€“out. Define F_i:=EÂ·S_i, and for w=i_1â€¦i_k set T_w:=F_{i_1}â‹¯F_{i_k} (Boolean semiring). If two input segments P,Q satisfy T_P=T_Q, then in any larger instance, replacing P by Q preserves extendibility: any legal labeling that is locally consistent at all nodes of P remains locally consistent after the replacement and unchanged outside P.
Proof. With radius 1, the interface exposed by a segment is exactly the Boolean relation mapping its left boundary output to its right boundary output; this relation is T_w. Equal relations imply identical extendibility. Composition follows from T_{uv}=T_uÂ·T_v.

Proposition 2 (middle-gap decision; NEXPTIME).
Let T be the reachable set of types (matrices) obtained by BFS from I under Î´(M,i)=MÂ·F_i; let K:=|T|. Let R_â„“ be the set of types realized by exactly â„“ inputs, defined by R_{â„“+1}={MÂ·F_i: MâˆˆR_â„“, iâˆˆ{0,1}}; compute R_K, R_{K+1}. Nondeterministically guess a table
f_type: TÃ—{00,01,10,11}Ã—T â†’ Î£_out^2.
Verify:
(i) Locality: for each (Ï„_L,S,Ï„_R) and (x,y)=f_type(Ï„_L,S,Ï„_R), we have S[1] allows x (diagonal of S_{S[1]}), E[x,y]=1, and S[2] allows y.
(ii) Bridge: for all Ï„_b,Ï„_câˆˆR_KâˆªR_{K+1} and S1,S2, let f_type(Â·,S1,Ï„_b)=(â„“_1,â„“_2), f_type(Ï„_c,S2,Â·)=(r_1,r_2). Then (F_{Ï„_b}Â·F_{Ï„_c}Â·E)[â„“_2,r_1]=1.
If some f_type passes, the LCL is solvable in O(log* n); else complexity is Î˜(n).
Proof sketch. The standard O(log* n) decomposition yields separators of size 2 and gaps of length K or K+1. Condition (i) makes separator labels locally legal; (ii) ensures every adjacent pair of gaps admits a legal filling consistent with separator outputs. All matrices are Î²Ã—Î², |T|â‰¤2^{Î²^2}, so verification is EXPTIME; guessing f_type is exponential â‡’ NEXPTIME overall.

Lemma 3 (SCC-constant certificate; sufficient for O(1)).
Let ğ”„ be the type automaton on T with Î´(M,i)=MÂ·F_i. Compute its SCCs C. Suppose there exists a separator table f_type passing Prop.2 and, for each SCC C, an output x_CâˆˆÎ£_out such that E[x_C,x_C]=1 and S_i[x_C,x_C]=1 for every i labeling some edge of C. Then there is an O(1)-round algorithm.
Proof. Use the (L_width,L_count,L_pattern)-partition with L_width=L_pattern=|T|, L_count=2|T|+2 (as in the paper). Each long periodic path resides in some SCC C; label all its nodes by x_C (radius-1 legality follows by E[x_C,x_C]=1 and S_i[x_C,x_C]=1 along the path). Label all separators via f_type, and fill remaining O(1)-sized unlabeled components locally (middle-gap lemma). Total time O(1).

Lemma 4 (two-cycle obstruction; necessary for Î©(log* n)).
Suppose there exist outputs aâ‰ b with E[a,a]=E[b,b]=0 and E[a,b]=E[b,a]=1, and S_0[a,a]=S_0[b,b]=S_1[a,a]=S_1[b,b]=1 (i.e., both outputs are allowed on both inputs). Then the LCL requires Î©(log* n) on cycles.
Proof. On any cycle whose inputs are arbitrary, the only way to satisfy edge constraints on the subalphabet {a,b} is a proper 2-coloring along the directed edges. Since both inputs allow both outputs, local input constraints do not restrict this freedom. Deterministic O(1) 2-coloring of cycles is impossible (Linialâ€™s lower bound). Therefore Î©(log* n).

Examples

- Complete E with self-loops everywhere, and S_0=S_1=I: Lemma 3 applies with x_C arbitrary â‡’ O(1).
- Parity: Î£_out={a,b}, E is the 2-cycle aâ†”b, and S_0=S_1=I: Lemma 4 applies â‡’ Î©(log* n).

Obstacles and scope

- Lemma 3 is sufficient but not necessary; it enforces constant output on each SCC. Many O(1) algorithms produce short-period outputs; capturing these requires handling residues (gcd of cycle lengths) within SCCs.
- Lemma 4 is not the most general necessary condition; it isolates the widely occurring â€œ2-cycleâ€ obstruction. Extending this to longer permutations (and to residue-class constraints) is a natural next step.

Refined direction for residues (plan)

For each primitive period w with type Ï„:=T_w, analyze the semigroup ã€ˆÏ„ã€‰={Ï„^m: mâ‰¥0}. Compute, by repeated squaring, the sets D_m(Ï„):={x: (Ï„^m)[x,x]=1}. If for all Ï„ reachable in long periodic blocks there exists x_Ï„ with x_Ï„âˆˆD_K(Ï„)âˆ©D_{K+1}(Ï„) and S_i[x_Ï„,x_Ï„]=1 for all i present in w, then one can place anchors of type x_Ï„ at both ends of any gap of length K or K+1 and bridge via Prop.2; this yields a strictly more general sufficient certificate than Lemma 3 and remains EXPTIME-checkable. We leave a full proof of this â€œresidue-diagonalâ€ certificate to the next round.

Next steps

1) Middle-gap: finalize proofs.md with Prop.2 (including the R_K,R_{K+1} restriction) and complexity accounting; prepare a small implementation to enumerate T and verify f_type.
2) Top-gap sufficient: formalize Lemma 3 and its O(1) algorithm; add to proofs.md as a partial positive criterion.
3) Top-gap necessary: formalize Lemma 4; search for generalizations (longer permutation cycles; gcd>1 obstructions) and provide check procedures.
4) Residues: implement D_m(Ï„) computation for mâˆˆ{K,K+1}; test the â€œresidue-diagonalâ€ sufficient condition on random small Î².
