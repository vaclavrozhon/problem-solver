{
  "content": "Ideas\n- Strengthen the top-gap (O(1) vs \u03a9(log* n)) direction with a type\u2013monoid analysis that encodes length-robust periodicity explicitly. The key objects are T_\u03c4 := A\u00b7M(\u03c4) (\u03b2\u00d7\u03b2 Boolean matrices), one per period type \u03c4, and their SCC periods (gcd of cycle lengths). Aperiodicity (period 1) in the relevant SCCs gives eventual closed walks of all large lengths; Wielandt\u2019s bound gives an explicit exponential (actually polynomial in \u03b2) index. This lets us replace \u201cper-word periodic witnesses\u201d by an exponential per-type certificate verifiable in EXPTIME.\n\nTechnical Lemmas (specialized to radius 1, oriented paths)\n- Lemma A (Matrix composition). For all u,v, M(uv)=M(u)\u00b7A\u00b7M(v) (Boolean semiring product). Consequently, for a primitive period w and m\u22651, M(w^m)=M(w)\u00b7(A\u00b7M(w))^{m\u22121}.\n- Lemma B (Replacement by type). If two input fragments P,Q satisfy M(P)=M(Q), then under any fixed boundary outputs that are locally legal with the environment, replacing P by Q preserves global legality by relabeling inside the fragment (standard radius-1 replacement). Why useful: guarantees that all feasibility constraints depend only on types M(\u00b7), not on representatives.\n\nLength-robust periodicity via SCC periods\n- Notation. For a \u03b2\u00d7\u03b2 0\u20131 matrix T, write G(T) for its directed graph. For a strongly connected component S of G(T), let per(S) be the gcd of cycle lengths in S (the period). S is aperiodic iff per(S)=1.\n- Lemma C (eventual closed walks on the diagonal). Let T be the adjacency of a finite strongly connected digraph S with per(S)=1. Then there exists an integer e(T,S) \u2264 (\u03b2\u22121)^2+1 (Wielandt bound) such that for all m \u2265 e(T,S), and all x\u2208S, T^m[x,x]=1. Proof sketch: T|_S is a primitive (aperiodic) 0\u20131 matrix of size \u2264\u03b2; by Wielandt\u2019s theorem, its exponent is \u2264(\u03b2\u22121)^2+1; hence all entries, in particular the diagonal, are 1 for m beyond the exponent.\n- Corollary D (two consecutive lengths). If S is aperiodic and m0 \u2265 e(T,S), then T^m[x,x]=1 holds for all m\u2208{m0,m0+1}; conversely, if for some x we have T^K[x,x]=T^{K+1}[x,x]=1 with K \u2265 e(T,S), necessarily per(S)=1. Why useful: ties the need for handling both K and K+1 (or any two consecutive large lengths) to aperiodicity.\n\nA sufficient certificate for O(1)\nWe define an exponential-size per-type certificate whose constraints are EXPTIME-checkable. Let Ptypes be the set of types \u03c4 realized by primitive words with length \u2264K (compute by scanning R_\u2113 for 1\u2264\u2113\u2264K and filtering non-primitive via type-product tests).\n- Period anchors per type: For each \u03c4\u2208Ptypes, choose an SCC S_\u03c4 of T_\u03c4 := A\u00b7M(\u03c4) with per(S_\u03c4)=1 and a state x_\u03c4 \u2208 S_\u03c4.\n- Global length threshold: Choose a single Lcount \u2265 max_{\u03c4\u2208Ptypes} e(T_\u03c4,S_\u03c4). Note Lcount \u2264 (\u03b2\u22121)^2+1.\n- Short separator table: g: T \u00d7 {00,01,10,11} \u00d7 T \u2192 \u03a3_out^2, with local legality for each (\u03c4_L,S,\u03c4_R): if g(\u03c4_L,S,\u03c4_R)=(u,v) then (S[1],u)\u2208Cin\u2013out, (u,v)\u2208Cout\u2013out, (S[2],v)\u2208Cin\u2013out.\n- Interface (bridge) constraints: For all \u03c4_a,\u03c4_b,\u03c4_c,\u03c4_d \u2208 Ptypes, all S1,S2\u2208{0,1}^2, writing g(\u03c4_a,S1,\u03c4_b)=(\u21131,\u21132) and g(\u03c4_c,S2,\u03c4_d)=(r1,r2), require:\n  1) Entry to S_b: there exists a state p_b\u2208S_b (SCC chosen for \u03c4_b) and a t_b \u2264 K such that (M(\u03c4_b)\u00b7T_b^{t_b})[\u21132,p_b]=1. (Reach S_b from the right endpoint of S1 through \u03c4_b and some iterations inside S_b.)\n  2) Exit from S_c: there exists a state q_c\u2208S_c and a t_c \u2264 K such that (T_c^{t_c}\u00b7M(\u03c4_c))[q_c,r1]=1. (From S_c through \u03c4_c to the left endpoint of S2.)\n  3) Cross-edge: There exist s_b\u2208S_b and s_c\u2208S_c with A[s_b,s_c]=1.\nThese three items together ensure that for any m_b,m_c \u2265 Lcount, there is a closed walk of length m_b\u22121 in S_b from p_b to s_b (by aperiodicity and Lemma C), then an A-step to s_c, then a walk of length m_c\u22121 in S_c from s_c to q_c, and finally the fixed tails (entry M\u03c4_b and exit M\u03c4_c) yield a path from \u21132 to r1. Formally, for all m_b,m_c \u2265 Lcount,\n(2)  (row_{\u21132})\u00b7M(\u03c4_b)\u00b7T_b^{m_b\u22121\u2212t_b}\u00b7E_{p_b\u2192s_b}\u00b7A\u00b7E_{s_c\u2192q_c}\u00b7T_c^{m_c\u22121\u2212t_c}\u00b7M(\u03c4_c)\u00b7(col_{r1}) = 1,\nso the scalar bridge holds uniformly in m_b,m_c.\n- Locality consistency: As in the mid-gap certificate, we also require the length-2 separator labels to be consistent with their immediate neighbors; this is already enforced by the local legality in g and the above bridges.\n\nCorrectness (sufficiency)\n- Labeling scheme (O(1) rounds). Use the standard (Lwidth,Lcount,Lpattern)-partition (with Lwidth=Lpattern=K and Lcount as above) in O(1) rounds. Each long block P\u2208Plong is a repetition w^m with primitive w (hence \u03c4=Type(w)\u2208Ptypes) and m\u2265Lcount by construction. Separators of length 2 are labeled by g.\n- Feasibility on long blocks: Given \u03c4 and m\u2265Lcount, choose the internal witness path inside S_\u03c4 using that T_\u03c4 is aperiodic and m is large (Lemma C). This only needs local knowledge of w and its direction (available in the partition).\n- Bridging across separators: For adjacent long blocks of types \u03c4_b, \u03c4_c around a separator pair, the three interface constraints ensure the scalar product in (2) equals 1 for all m_b,m_c\u2265Lcount, hence the remaining (O(1)-length) interface zones can be filled locally (by replacement, Lemma B).\n- Hence the labeling is globally legal. Since all parameters (K,Lcount) depend only on \u03b2, the algorithm is O(1).\n\nVerification complexity (EXPTIME)\n- Compute T (reachable types), R_\u2113 for \u2113\u2264K, and Ptypes by filtering primitives (all in 2^{O(\u03b2^2)}\u00b7poly(\u03b2)).\n- Guess the certificate: S_\u03c4 and x_\u03c4 per \u03c4 (encode by listing SCC node sets or representative), Lcount (bounded by (\u03b2\u22121)^2+1), and the table g (size 2^{O(\u03b2^2)} bits).\n- Verify: (i) per(S_\u03c4)=1 by gcd of cycle lengths in each SCC (\u03b2-size graph); (ii) Lcount\u2265e(T_\u03c4,S_\u03c4) using Wielandt bound (or compute the exact exponent via standard algorithms, still exponential at worst); (iii) for all tuples, check entry/exit witnesses (bounded powers t_b,t_c \u2264K) and the cross-edge A[s_b,s_c]=1; (iv) local legality checks for g. Each check uses Boolean matrix products of O(\u03b2^3) and graph reachabilities; the total number of tuples is 2^{O(\u03b2^2)}. Deterministic time is 2^{O(\u03b2^2)}\u00b7poly(\u03b2). Thus, existence of the certificate is in NEXPTIME.\n\nExamples and Counterexamples\n- Parity 2-coloring (\u03a3_out={a,b}, A is the 2-cycle, Cin\u2013out unconstrained). For any \u03c4, T_\u03c4 has all SCCs with per=2; there is no aperiodic S_\u03c4. Our certificate necessarily fails, ruling out O(1) as desired.\n- Trivial all-ones A and Ds. Every T_\u03c4 is the all-ones matrix on one SCC with per=1. Choose any S_\u03c4; Lcount can be 1. The interface constraints are vacuous since A is universal. The certificate passes; the algorithm outputs O(1).\n\nObstacles / limits (completeness)\n- We have proved a sufficient, EXPTIME-checkable condition for O(1). For a decision procedure we need a matching necessity/compression lemma: from any O(1)-round algorithm extract (S_\u03c4, x_\u03c4) and g satisfying the above. Intuition: since long blocks may appear with arbitrarily large lengths and both parities, local outputs must work for all m\u2265M; this forces aperiodicity in the relevant T_\u03c4, and the interface feasibility must reduce to our matrix constraints by type-replacement. Formalizing this extraction without reintroducing doubly-exponential per-word witnesses is the key remaining step.\n\nNext steps\n- Prove an \u201caperiodicity necessity\u201d lemma: if there exists a constant-round algorithm, then for every \u03c4\u2208Ptypes that can appear as a long block in an input, the chosen T_\u03c4 must have an aperiodic SCC mediating the effect of the block. Use the fact that the same \u03c4 can appear with both lengths m and m+1, while the algorithm cannot see the total length.\n- Prove an extraction lemma: from the algorithm\u2019s local behavior on long periodic inputs, extract x_\u03c4 and g satisfying our entry/exit and cross-edge constraints.\n- Integrate: With these, the top-gap test becomes NEXPTIME: first try the O(1) certificate; if it fails, try the mid-gap certificate (we already have) to decide O(log* n) vs \u0398(n).\n"
}