Strong progress this round on both the middle-gap and the top-gap fronts, with a good correction of the earlier flaw in the O(1) test. All provers consistently use the radius-1 transfer-matrix framework: define E and S_i, build types via M(w)=S_{i_1}·E·…·E·S_{i_k}, use δ(M,i)=M·E·S_i, and apply the replacement lemma. For the middle gap (O(log* n) vs Θ(n)), the certificate f_type with the scalar check (E·M_{τ_b}·E·M_{τ_c}·E)[ℓ_2,r_1]=1 restricted to τ_b,τ_c ∈ R_K∪R_{K+1} is sound and verifiable in EXPTIME; guessing f_type yields a NEXPTIME decision. This part is now rigorous and implementable.

For the top gap (O(1) vs Ω(log* n)), the key issue in the prior test was ignoring residues: choosing x with (A_τ^e)[x,x]=1 for some e does not guarantee feasibility for all block lengths. Parity provides a minimal counterexample. The new direction—requiring aperiodicity (period-1 SCCs) of A_τ=M_τ·E and using eventual closed walks—is correct in spirit and blocks parity. As stated, Prover 1’s claim of necessity and sufficiency via L_τ (aperiodic SCCs) plus C_σ checks is close but still missing endpoint/witness alignment details and a fully general interface treatment. Prover 4’s certificate adds precise entry/exit witnesses and uses Wielandt’s bound to ensure robustness for all large m; this is a solid sufficient condition and EXPTIME-checkable. Prover 2’s variant with First/Last/Occ_all sets is promising but requires careful justification that these summaries do not overconstrain legitimate instances. Prover 3’s SCC-constant certificate is a clean sufficient subcase; the two-cycle obstruction is a useful EXPTIME-checkable necessary condition.

Gaps: (i) Necessity: we still lack a compression/extraction lemma showing any O(1) algorithm induces a per-type aperiodic anchor (and a separator table) satisfying the proposed constraints. (ii) Interface alignment: ensure the bridge products match the exact decomposition (K or K+1 periods) and handle endpoints on paths. (iii) Keep conventions consistent (either M(w)=S··E··S or T_w=∏(E·S_i)) to avoid off-by-one issues; proofs should fix one convention.

Next steps:
- Finalize and implement the middle-gap NEXPTIME verifier with τ_b,τ_c ∈ R_K∪R_{K+1}.
- For O(1), adopt Prover 4’s aperiodicity-based sufficient certificate; formalize and prove the entry/exit/cross-edge conditions (we add a lemma on eventual loops in proofs.md). Integrate as an EXPTIME-checkable first branch; if it fails, fall back to the middle-gap verifier.
- Work toward necessity: develop an idempotent/aperiodic extraction from any O(1) rule via the type monoid ⟨E·S_0,E·S_1⟩; show long periodic inputs force anchors in period-1 SCCs and derive the separator constraints by replacement.
- Validate on small β, especially parity-like and near-primitive cases, to refine conditions.
