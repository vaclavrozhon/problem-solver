# Ideas

- Fix conventions to remove off-by-one issues and state a clean, EXPTIME-checkable sufficient (and plausibly necessary) certificate for O(1): use monoid generators T_i := E·S_i, so that M(w) = T_{i_1}·…·T_{i_k} and concatenation composes as M(P·Q)=M(P)·M(Q). Period matrices are A_τ := M_τ.
- Strengthen the aperiodicity test by adding constant-length entry/exit witnesses into/out of the aperiodic SCC. This resolves the “alignment” concern: for any long block length m, we can absorb fixed-length stubs and a long loop to achieve the chosen boundary outputs.

# Conventions and basic lemmas

Fix Σ_in={0,1}, Σ_out of size β. Define E[x,y]=1 iff (x,y)∈C_out–out. For i∈{0,1}, let S_i be diagonal with (S_i)[x,x]=1 iff (i,x)∈C_in–out. Define T_i := E·S_i and for an input word w=i_1…i_k, set
M(w) := T_{i_1}·T_{i_2}·…·T_{i_k}.
Then composition holds: for any concatenation P·Q, M(P·Q)=M(P)·M(Q). Note that this convention already includes boundary edges E between consecutive outputs including the edge crossing segment boundaries, so no extra E factors are needed in compositions.

- Replacement lemma (radius 1, T-convention). If two segments P,P′ satisfy M(P)=M(P′), they are interchangeable in any context while preserving already-fixed outside outputs; feasibility of completing the labeling reduces to matrix products of the fixed boundary outputs by M(·) products. (Same proof as standard, but compositions use M(·) without extra E.)

# Aperiodicity with entry/exit witnesses

Let τ be a “period type” (i.e., τ=M(w) for some primitive input pattern w with |w|≤K, K=|T|). Define A_τ:=M_τ. Consider the directed graph G_τ with adjacency A_τ.

- Lemma 1 (eventual loops in aperiodic SCCs). If x lies in a strongly connected component C of G_τ whose period (gcd of cycle lengths) is 1, then ∃N_τ such that (A_τ^m)[x,x]=1 for all m≥N_τ.

Proof. Standard in finite digraphs/Markov chains: aperiodic SCCs are primitive; by Wielandt’s theorem there exists an exponent W(C) ≤ β^2−2β+2 such that A^m has all positive entries on C for all m≥W(C). In particular, diagonal entries are 1 for all m≥W(C).

- Lemma 2 (constant-length entry/exit to an anchor). Fix τ and choose an aperiodic SCC C_τ of G_τ and an anchor x_τ∈C_τ. For any k≥0, define the k-step entry set En_τ(k):={a∈Σ_out : ∃p≤k with (A_τ^p)[a,x_τ]=1}, and the k-step exit set Ex_τ(k):={b∈Σ_out : ∃q≤k with (A_τ^q)[x_τ,b]=1}. For k large enough (e.g., k=β or k=K), these sets capture all boundary outputs that can reach (or be reached from) x_τ using a constant-length stub entirely within the τ-block.

Why useful: In an O(1) algorithm, each long τ-block has length m≥L_count; by choosing L_count≥N_τ+2k, we can realize any boundary a∈En_τ(k) on the left and any boundary b∈Ex_τ(k) on the right: consume p≤k steps to enter x_τ, then loop for m−(p+q)≥N_τ steps within C_τ to return to x_τ, then consume q≤k steps to exit to b.

# Interface across short separators

Let σ be a short type (|σ|≤2·L_width). With the T-convention we set C_σ := M_σ. If the long block on the left is τ_l with anchor x_l and the long block on the right is τ_r with anchor x_r, and if we choose boundary outputs a∈Ex_{τ_l}(k) and b∈En_{τ_r}(k), then feasibility across the separator is exactly the constant check C_σ[a,b] = 1. This is sufficient: the left long block can present a on its right boundary; the right long block can present b on its left boundary; and the short block σ can be labeled to connect a to b because M_σ[a,b]=1.

# EXPTIME O(1) test (refined)

Input: (Cin–out, Cout–out). Precompute the reachable type set T (|T|≤2^{β^2}) and R_ℓ (types of exact length ℓ) up to ℓ≤2K, K=|T|, via δ(M,i)=M·E·S_i replaced by T-convention δ(M,i)=M·T_i.

Parameters: L_pattern=K, L_width=K, choose k:=K (or any explicit constant ≥β) and L_count := max_{τ∈R_{≤K}} N_τ + 2k, where N_τ is the Wielandt exponent for the chosen anchor in τ.

Algorithm:
1) For each τ∈R_{≤K}, compute G_τ for A_τ=M_τ and its SCC periods. If no SCC of period 1 exists, reject (not O(1)). Else choose any aperiodic SCC C_τ and anchor x_τ∈C_τ. Compute En_τ(k), Ex_τ(k) by multiplying A_τ^p for p≤k.
2) For each triple (τ_l,σ,τ_r) with τ_l,τ_r∈R_{≤K} and σ∈⋃_{ℓ≤2K}R_ℓ, check if ∃ a∈Ex_{τ_l}(k), b∈En_{τ_r}(k) such that C_σ[a,b]=1 (C_σ=M_σ). If every triple passes, accept (O(1)); otherwise reject.

Complexity: Building T and R_ℓ is 2^{O(β^2)}·poly(β). SCC and period computations per τ are poly(β). Computing En/Ex up to k=K costs at most K matrix multiplications per τ. The triple check enumerates |T|^3 instances with O(β^2) lookups. Overall EXPTIME in β.

Correctness (sketch):
- Sufficiency: Use the (L_width,L_count,L_pattern)-partition. For each long block of type τ pick x_τ. With m≥L_count, choose any desired right boundary a∈Ex_τ(k) and left boundary b∈En_τ(k) by using p≤k steps to enter x_τ, loop for ≥N_τ steps, then exit for q≤k steps. For each adjacent short σ connecting a long block τ_l on the left and τ_r on the right, the certificate guarantees a∈Ex_{τ_l}(k), b∈En_{τ_r}(k) with C_σ[a,b]=1, so label σ accordingly. All steps are local and O(1) in n.
- Necessity (partial): If O(1) holds, then for every τ∈R_{≤K} there must be some x with (A_τ^m)[x,x]=1 for all sufficiently large m (otherwise some long τ-only cycle cannot be labeled for infinitely many lengths). Thus τ admits an aperiodic SCC, and En/Ex must be non-empty for sufficiently large k (else constant-time adjustment to chosen boundaries fails under replacement). A full compression lemma is still open (see next steps), but these conditions are unavoidable in typical obstructions (e.g., parity where all SCCs have period 2).

# Examples

- Parity obstruction (Θ(log* n)): Σ_out={a,b}, E is the 2-cycle a↔b, Cin–out admits both outputs for both inputs. For any τ, G_τ has SCCs of period 2 only; Step 1 fails (no aperiodic SCC), so we reject O(1), as desired.
- Trivial admissible case: E is complete (all ones), Cin–out admits all outputs. Then each G_τ is a complete aperiodic digraph; any x_τ works, and En/Ex=Σ_out for small k. All σ satisfy M_σ[a,b]=1. The test accepts O(1).

# Obstacles

- Completeness: We have not yet proved that existence of an O(1) algorithm implies existence of anchors x_τ and k-bounded En/Ex that pass all triple checks. An extraction/compression lemma from any O(1) algorithm to such a per-type certificate via the monoid ⟨T_0,T_1⟩ (idempotents and aperiodic SCCs) is pending.
- Endpoints on paths: The test and construction were presented for cycles; on oriented paths, boundary endpoints add at most constant padding, which can be handled by the same entry/exit technique (choose Ex/En relative to path ends). We will formalize this.

# Next steps

1) Formalize Lemma 1 and 2 in proofs.md under the T-convention, with explicit bounds (e.g., Wielandt’s exponent) and a precise argument that m≥N_τ+2k suffices.
2) Prove a replacement-based “stub surgery” lemma: a long τ-block can be rewritten (by replacing constant-size prefixes/suffixes) to present any boundary a∈Ex_τ(k) and b∈En_τ(k) while preserving type and keeping length ≥ L_count.
3) Implement the EXPTIME O(1)-test with the En/Ex witness sets and integrate with the previously finalized NEXPTIME middle-gap verifier (τ_b,τ_c∈R_K∪R_{K+1}). Validate on small β instances including parity-like obstructions and random constraints.
4) Work toward a necessity/compression lemma: from any O(1) algorithm, extract anchors in aperiodic SCCs and constant k so that En/Ex are non-empty and the triple checks hold; likely via idempotents of the type monoid and periodic stabilization.
