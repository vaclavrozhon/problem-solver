{
  "content": "Ideas\n\n- We tighten and simplify the O(1) sufficient certificate using aperiodicity of the boundary transition matrix A_\u03c4 = E\u00b7M_\u03c4 (fixed convention) and remove unnecessary terms in the bridge condition. This certificate is EXPTIME-verifiable and integrates as the first branch in a NEXPTIME trichotomy: try O(1) certificate; else try the middle-gap O(log* n) certificate; else \u0398(n).\n- We give small, checkable lemmas: computation of first/last letter sets for types; eventual closed-walk property from aperiodic SCCs (with a finite exponent bound); and a sufficiency lemma that the certificate yields an O(1)-round algorithm on globally oriented paths/cycles.\n\nDefinitions and conventions\n\n- Output alphabet \u03a3_out, |\u03a3_out|=\u03b2. Inputs \u03a3_in={0,1}. Boolean matrices:\n  \u2022 E[a,b]=1 iff (a,b)\u2208C_out\u2013out.\n  \u2022 S_\u03c3[c,c]=1 iff (\u03c3,c)\u2208C_in\u2013out; S_\u03c3 is diagonal.\n  \u2022 For w=\u03c3_1\u2026\u03c3_k, M(w)=S_{\u03c3_1}\u00b7E\u00b7S_{\u03c3_2}\u00b7E\u00b7\u2026\u00b7E\u00b7S_{\u03c3_k} (Boolean product). Types are the distinct matrices M(w). Transition \u03b4(M,\u03c3)=M\u00b7E\u00b7S_\u03c3. T is the set of reachable types; R_\u2113=types of exact length \u2113; K=|T|.\n  \u2022 For a type \u03c4, write M_\u03c4 for its matrix; define A_\u03c4=E\u00b7M_\u03c4 (one period block followed by the boundary edge).\n\nAuxiliary computable sets per type\n\nLemma 1 (First/Last sets). For \u03c4\u2208R_\u2113, define First(\u03c4) (resp. Last(\u03c4)) as the set of symbols \u03c3 that appear as the first (resp. last) input letter of some w with |w|=\u2113 and M(w)=\u03c4. Then First(\u03c4), Last(\u03c4) are computable in EXPTIME.\nProof. Use the type automaton on T with transitions \u03b4(M,\u03c3). For First(\u03c4,\u03c3), check if there exists a length-\u2113 path to \u03c4 whose initial transition uses \u03c3; equivalently, run a reachability DP in the product of the type automaton and a 2-state flag recording the first letter. Similarly for Last(\u03c4). The state space is exponential in \u03b2. \u220e\n\nEventual closed walks in aperiodic SCCs\n\nLemma 2 (aperiodic SCC \u21d2 eventual closed walks). Let G_\u03c4 be the directed graph on \u03a3_out with adjacency A_\u03c4. If a node c lies in an SCC whose cycle-length gcd is 1 (aperiodic), then \u2203N_\u03c4 (depending on the SCC) such that (A_\u03c4^m)[c,c]=1 for all m\u2265N_\u03c4. Moreover, N_\u03c4 can be upper bounded by a function of \u03b2 (e.g., by a Wielandt-type bound O(\u03b2^2)).\nProof. In an aperiodic SCC, the set of lengths of closed walks at c is cofinite (classical result on strongly connected aperiodic digraphs). A well-known bound on the exponent (index of primitivity) is \u2264(n\u22121)^2+1 for n=|SCC| (Wielandt\u2019s bound), and here n\u2264\u03b2. \u220e\n\nO(1) sufficient certificate (refined and EXPTIME-checkable)\n\nCertificate. Choose a map h: R_K\u2192\u03a3_out such that, for every \u03c4\u2208R_K:\n(i) h(\u03c4) belongs to an SCC of G_\u03c4 with gcd = 1 (aperiodic), equivalently \u2203N_\u03c4 with (A_\u03c4^m)[h(\u03c4),h(\u03c4)]=1 for all m\u2265N_\u03c4.\n(ii) For every adjacent pair (\u03c4_b,\u03c4_c)\u2208(R_K\u222aR_{K+1})^2 and for every separator window S=(\u03c3,\u03c3\u2032) with \u03c3\u2208Last(\u03c4_b), \u03c3\u2032\u2208First(\u03c4_c), there exist x,y\u2208\u03a3_out such that\n  \u2022 S_\u03c3[x,x]=1, S_{\u03c3\u2032}[y,y]=1 (separator-node Cin\u2013out),\n  \u2022 E[x,y]=1 (edge between the two separator nodes),\n  \u2022 E[h(\u03c4_b),x]=1 and E[y,h(\u03c4_c)]=1 (boundary edges connecting long blocks to the separator nodes).\nVerification. For each \u03c4, compute the SCC of h(\u03c4) in G_\u03c4 and check gcd=1 (gcd of simple cycle lengths; poly(\u03b2)). For each (\u03c4_b,\u03c4_c) and window S in Last(\u03c4_b)\u00d7First(\u03c4_c), check existence of x,y satisfying the three bullet conditions (constant-time checks). All \u03c4_b,\u03c4_c lie in R_K\u222aR_{K+1}; Last/First are from Lemma 1. Therefore the certificate is verifiable in EXPTIME overall.\n\nLemma 3 (sufficiency \u21d2 O(1) algorithm). If such an h exists, the LCL is solvable in O(1) rounds on globally oriented cycles/paths.\nProof. Use the standard O(1) partition (as in the cycle proof) that decomposes into long periodic blocks with types in R_K\u222aR_{K+1} and length at least L\u226bmax_\u03c4 N_\u03c4, separated by short windows of two nodes. For a long block of type \u03c4 with repetition count m\u2265N_\u03c4, Lemma 2 guarantees a legal labeling of the block whose boundary outputs (at both ends) equal h(\u03c4): indeed, (A_\u03c4^m)[h(\u03c4),h(\u03c4)]=1 expands to a sequence of per-period traversals, and each per-period traversal is a legal labeling of that period-concatenated with the boundary edge\u2014by definition of A_\u03c4=E\u00b7M_\u03c4. Now consider two neighboring long blocks of types \u03c4_b and \u03c4_c; pick S=(\u03c3,\u03c3\u2032)\u2208Last(\u03c4_b)\u00d7First(\u03c4_c). By (ii), we can label the two separator nodes by x,y so that: (a) each separator node satisfies Cin\u2013out (diagonal S constraints), (b) their connecting edge satisfies Cout\u2013out, and (c) boundary edges from the long blocks satisfy Cout\u2013out (E[h(\u03c4_b),x]=1 and E[y,h(\u03c4_c)]=1). Thus, combining the long-block interior labelings (with boundaries fixed to h(\u00b7)) and the separator labels x,y yields a globally legal labeling. The construction is local once the partition is computed (which is O(1) by the known orientation/partition lemmas). \u220e\n\nRemarks.\n- Compared to earlier variants, we no longer require Occ_all(\u03c4). The existence of a closed walk (A_\u03c4^m)[h,h]=1 certifies there is a legal labeling for the entire repeated block, including all Cin\u2013out checks inside the block; the separator\u2019s two nodes are enforced by S_\u03c3,S_{\u03c3\u2032} directly.\n- Parity test: If E is the 2-cycle a\u2194b and S_0,S_1 permit both outputs, then every SCC in G_\u03c4 has gcd 2, condition (i) fails; certificate rejected (correct: problem is \u0398(log* n)).\n- Constant label: If \u2203c with S_0[c,c]=S_1[c,c]=1 and E[c,c]=1, choosing h(\u03c4)=c for all \u03c4 and x=y=c satisfies (i)&(ii), certificate accepted (correct: O(1)).\n\nMiddle-gap (\u0398(n) vs O(log* n))\n\n- As established in earlier rounds, for the middle gap use the type-based separator function f_type: T\u00d7{00,01,10,11}\u00d7T\u2192\u03a3_out^2 restricted to \u03c4_b,\u03c4_c\u2208R_K\u222aR_{K+1}, and check:\n  (i) local window legality S_\u03c3 and E,\n  (ii) bridge scalar (E\u00b7M_{\u03c4_b}\u00b7E\u00b7M_{\u03c4_c}\u00b7E)[\u2113_2,r_1]=1,\nwith \u03c4_b,\u03c4_c ranging only over R_K\u222aR_{K+1}. Verification is EXPTIME; guessing f_type is exponential \u21d2 NEXPTIME procedure deciding O(log* n) vs \u0398(n).\n\nPutting the NEXPTIME trichotomy together\n\nAlgorithm (nondeterministic):\n1) Build T (|T|\u22642^{\u03b2^2}) and R_K,R_{K+1} (EXPTIME). First try to guess h:R_K\u2192\u03a3_out and verify the O(1) certificate (conditions (i)&(ii) above). If it succeeds, answer O(1).\n2) Else, guess f_type and verify the middle-gap conditions (as above). If succeeds, answer O(log* n).\n3) Else, answer \u0398(n).\nThe overall nondeterministic time is exponential in N=poly(\u03b2): the guessed objects are exponential-sized; every verification is EXPTIME in \u03b2.\n\nExamples\n\n- Parity 2-coloring: \u03a3_out={a,b}, E has only edges a\u2194b, Cin\u2013out allows both outputs for 0,1. G_\u03c4\u2019s SCCs have gcd 2 \u21d2 step (1) fails. The middle-gap certificate also fails (standard), hence \u0398(n).\n- Constant output: E[c,c]=1 and S_0[c,c]=S_1[c,c]=1 for some c \u21d2 step (1) accepts with h(\u03c4)=c, yielding O(1). Middle-gap also accepts but step (1) short-circuits earlier.\n\nObstacles\n\n- Necessity (extraction): we lack a proof that any O(1) algorithm induces h with aperiodic anchors per type and satisfies (ii). This likely follows from the finite monoid \u27e8E\u00b7S_0,E\u00b7S_1\u27e9 and idempotent/aperiodic behavior on long periodic words; we need to formalize the stabilization of A_\u03c4 powers and derive boundary choices compatible with all K/K+1 separations.\n- Endpoints on paths: Our construction naturally covers cycles. For paths, one adds sentinel windows at ends; the same certificate yields boundary-output to sentinel coupling (E/h to dummy). Formalization is pending, but standard replacement arguments apply.\n\nNext steps\n\n1) Implement step (1) certificate: compute SCC gcds of A_\u03c4, Last/First(\u03c4); verify (i)&(ii) in EXPTIME; integrate in the codepath.\n2) Keep the middle-gap verifier as in previous rounds; finalize code for R_K,R_{K+1} and the bridge scalar check.\n3) Work on the compression lemma: use the monoid \u27e8E\u00b7S_0,E\u00b7S_1\u27e9 to extract idempotents and aperiodic anchors from any O(1) algorithm; bind separator windows via finite checks; aim to show completeness of the O(1) certificate.\n4) Validate on small \u03b2, including parity-like, trivial, and mixed cases where some but not all types admit aperiodic anchors; refine the necessary coverage per \u03c4 and how partition avoids bad types (if needed).\n"
}