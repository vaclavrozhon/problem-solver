Ideas

- We tighten and simplify the O(1) sufficient certificate using aperiodicity of the boundary transition matrix A_τ = E·M_τ (fixed convention) and remove unnecessary terms in the bridge condition. This certificate is EXPTIME-verifiable and integrates as the first branch in a NEXPTIME trichotomy: try O(1) certificate; else try the middle-gap O(log* n) certificate; else Θ(n).
- We give small, checkable lemmas: computation of first/last letter sets for types; eventual closed-walk property from aperiodic SCCs (with a finite exponent bound); and a sufficiency lemma that the certificate yields an O(1)-round algorithm on globally oriented paths/cycles.

Definitions and conventions

- Output alphabet Σ_out, |Σ_out|=β. Inputs Σ_in={0,1}. Boolean matrices:
  • E[a,b]=1 iff (a,b)∈C_out–out.
  • S_σ[c,c]=1 iff (σ,c)∈C_in–out; S_σ is diagonal.
  • For w=σ_1…σ_k, M(w)=S_{σ_1}·E·S_{σ_2}·E·…·E·S_{σ_k} (Boolean product). Types are the distinct matrices M(w). Transition δ(M,σ)=M·E·S_σ. T is the set of reachable types; R_ℓ=types of exact length ℓ; K=|T|.
  • For a type τ, write M_τ for its matrix; define A_τ=E·M_τ (one period block followed by the boundary edge).

Auxiliary computable sets per type

Lemma 1 (First/Last sets). For τ∈R_ℓ, define First(τ) (resp. Last(τ)) as the set of symbols σ that appear as the first (resp. last) input letter of some w with |w|=ℓ and M(w)=τ. Then First(τ), Last(τ) are computable in EXPTIME.
Proof. Use the type automaton on T with transitions δ(M,σ). For First(τ,σ), check if there exists a length-ℓ path to τ whose initial transition uses σ; equivalently, run a reachability DP in the product of the type automaton and a 2-state flag recording the first letter. Similarly for Last(τ). The state space is exponential in β. ∎

Eventual closed walks in aperiodic SCCs

Lemma 2 (aperiodic SCC ⇒ eventual closed walks). Let G_τ be the directed graph on Σ_out with adjacency A_τ. If a node c lies in an SCC whose cycle-length gcd is 1 (aperiodic), then ∃N_τ (depending on the SCC) such that (A_τ^m)[c,c]=1 for all m≥N_τ. Moreover, N_τ can be upper bounded by a function of β (e.g., by a Wielandt-type bound O(β^2)).
Proof. In an aperiodic SCC, the set of lengths of closed walks at c is cofinite (classical result on strongly connected aperiodic digraphs). A well-known bound on the exponent (index of primitivity) is ≤(n−1)^2+1 for n=|SCC| (Wielandt’s bound), and here n≤β. ∎

O(1) sufficient certificate (refined and EXPTIME-checkable)

Certificate. Choose a map h: R_K→Σ_out such that, for every τ∈R_K:
(i) h(τ) belongs to an SCC of G_τ with gcd = 1 (aperiodic), equivalently ∃N_τ with (A_τ^m)[h(τ),h(τ)]=1 for all m≥N_τ.
(ii) For every adjacent pair (τ_b,τ_c)∈(R_K∪R_{K+1})^2 and for every separator window S=(σ,σ′) with σ∈Last(τ_b), σ′∈First(τ_c), there exist x,y∈Σ_out such that
  • S_σ[x,x]=1, S_{σ′}[y,y]=1 (separator-node Cin–out),
  • E[x,y]=1 (edge between the two separator nodes),
  • E[h(τ_b),x]=1 and E[y,h(τ_c)]=1 (boundary edges connecting long blocks to the separator nodes).
Verification. For each τ, compute the SCC of h(τ) in G_τ and check gcd=1 (gcd of simple cycle lengths; poly(β)). For each (τ_b,τ_c) and window S in Last(τ_b)×First(τ_c), check existence of x,y satisfying the three bullet conditions (constant-time checks). All τ_b,τ_c lie in R_K∪R_{K+1}; Last/First are from Lemma 1. Therefore the certificate is verifiable in EXPTIME overall.

Lemma 3 (sufficiency ⇒ O(1) algorithm). If such an h exists, the LCL is solvable in O(1) rounds on globally oriented cycles/paths.
Proof. Use the standard O(1) partition (as in the cycle proof) that decomposes into long periodic blocks with types in R_K∪R_{K+1} and length at least L≫max_τ N_τ, separated by short windows of two nodes. For a long block of type τ with repetition count m≥N_τ, Lemma 2 guarantees a legal labeling of the block whose boundary outputs (at both ends) equal h(τ): indeed, (A_τ^m)[h(τ),h(τ)]=1 expands to a sequence of per-period traversals, and each per-period traversal is a legal labeling of that period-concatenated with the boundary edge—by definition of A_τ=E·M_τ. Now consider two neighboring long blocks of types τ_b and τ_c; pick S=(σ,σ′)∈Last(τ_b)×First(τ_c). By (ii), we can label the two separator nodes by x,y so that: (a) each separator node satisfies Cin–out (diagonal S constraints), (b) their connecting edge satisfies Cout–out, and (c) boundary edges from the long blocks satisfy Cout–out (E[h(τ_b),x]=1 and E[y,h(τ_c)]=1). Thus, combining the long-block interior labelings (with boundaries fixed to h(·)) and the separator labels x,y yields a globally legal labeling. The construction is local once the partition is computed (which is O(1) by the known orientation/partition lemmas). ∎

Remarks.
- Compared to earlier variants, we no longer require Occ_all(τ). The existence of a closed walk (A_τ^m)[h,h]=1 certifies there is a legal labeling for the entire repeated block, including all Cin–out checks inside the block; the separator’s two nodes are enforced by S_σ,S_{σ′} directly.
- Parity test: If E is the 2-cycle a↔b and S_0,S_1 permit both outputs, then every SCC in G_τ has gcd 2, condition (i) fails; certificate rejected (correct: problem is Θ(log* n)).
- Constant label: If ∃c with S_0[c,c]=S_1[c,c]=1 and E[c,c]=1, choosing h(τ)=c for all τ and x=y=c satisfies (i)&(ii), certificate accepted (correct: O(1)).

Middle-gap (Θ(n) vs O(log* n))

- As established in earlier rounds, for the middle gap use the type-based separator function f_type: T×{00,01,10,11}×T→Σ_out^2 restricted to τ_b,τ_c∈R_K∪R_{K+1}, and check:
  (i) local window legality S_σ and E,
  (ii) bridge scalar (E·M_{τ_b}·E·M_{τ_c}·E)[ℓ_2,r_1]=1,
with τ_b,τ_c ranging only over R_K∪R_{K+1}. Verification is EXPTIME; guessing f_type is exponential ⇒ NEXPTIME procedure deciding O(log* n) vs Θ(n).

Putting the NEXPTIME trichotomy together

Algorithm (nondeterministic):
1) Build T (|T|≤2^{β^2}) and R_K,R_{K+1} (EXPTIME). First try to guess h:R_K→Σ_out and verify the O(1) certificate (conditions (i)&(ii) above). If it succeeds, answer O(1).
2) Else, guess f_type and verify the middle-gap conditions (as above). If succeeds, answer O(log* n).
3) Else, answer Θ(n).
The overall nondeterministic time is exponential in N=poly(β): the guessed objects are exponential-sized; every verification is EXPTIME in β.

Examples

- Parity 2-coloring: Σ_out={a,b}, E has only edges a↔b, Cin–out allows both outputs for 0,1. G_τ’s SCCs have gcd 2 ⇒ step (1) fails. The middle-gap certificate also fails (standard), hence Θ(n).
- Constant output: E[c,c]=1 and S_0[c,c]=S_1[c,c]=1 for some c ⇒ step (1) accepts with h(τ)=c, yielding O(1). Middle-gap also accepts but step (1) short-circuits earlier.

Obstacles

- Necessity (extraction): we lack a proof that any O(1) algorithm induces h with aperiodic anchors per type and satisfies (ii). This likely follows from the finite monoid ⟨E·S_0,E·S_1⟩ and idempotent/aperiodic behavior on long periodic words; we need to formalize the stabilization of A_τ powers and derive boundary choices compatible with all K/K+1 separations.
- Endpoints on paths: Our construction naturally covers cycles. For paths, one adds sentinel windows at ends; the same certificate yields boundary-output to sentinel coupling (E/h to dummy). Formalization is pending, but standard replacement arguments apply.

Next steps

1) Implement step (1) certificate: compute SCC gcds of A_τ, Last/First(τ); verify (i)&(ii) in EXPTIME; integrate in the codepath.
2) Keep the middle-gap verifier as in previous rounds; finalize code for R_K,R_{K+1} and the bridge scalar check.
3) Work on the compression lemma: use the monoid ⟨E·S_0,E·S_1⟩ to extract idempotents and aperiodic anchors from any O(1) algorithm; bind separator windows via finite checks; aim to show completeness of the O(1) certificate.
4) Validate on small β, including parity-like, trivial, and mixed cases where some but not all types admit aperiodic anchors; refine the necessary coverage per τ and how partition avoids bad types (if needed).
