{
  "content": "Ideas\n- We tighten the top-gap (O(1) vs \u03a9(log* n)) analysis by isolating a necessary condition based on aperiodicity of the per-period transfer T_\u03c4 := A\u00b7M(\u03c4). This complements the sufficient aperiodicity-based certificate proposed earlier and yields an EXPTIME-checkable filter: if it fails, the instance cannot be O(1).\n- We also formalize primitive type enumeration and matrix-period computation with explicit complexity bounds (single-exponential in \u03b2), making this step implementable for the overall NEXPTIME procedure.\n\nConventions and basic definitions (radius 1)\n- A is the \u03b2\u00d7\u03b2 Boolean adjacency of Cout\u2013out. For s\u2208{0,1}, Ds is diagonal with Ds[x,x]=1 iff (s,x)\u2208Cin\u2013out.\n- For an input word w=s1\u2026sk, define its transfer matrix M(w)=Ds1\u00b7A\u00b7Ds2\u00b7A\u00b7\u2026\u00b7A\u00b7Dsk (Boolean semiring). Types are matrices M(w). Concatenation: M(uv)=M(u)\u00b7A\u00b7M(v).\n- For a type \u03c4, define the per-period step T_\u03c4 := A\u00b7M(\u03c4). Informally, traversing one period of \u03c4 maps left boundary output to right boundary output by T_\u03c4.\n- Let K=|T| be the number of reachable types (2^{O(\u03b2^2)}). Let Ptypes be the set of types realized by primitive words of length \u2264K.\n\nLemma 1 (Enumerating primitive period types)\nOne can compute Ptypes in time 2^{O(\u03b2^2)}\u00b7poly(\u03b2):\n- Compute T (reachable types) and the length-filtered sets R_\u2113 for 1\u2264\u2113\u2264K by iterating R_{\u2113+1}={M\u00b7A\u00b7Ds: M\u2208R_\u2113, s\u2208{0,1}}.\n- A type \u03c4\u2208R_\u2113 is primitive iff there do not exist integers d,m with 1\u2264d<\u2113 and m\u22652 and a type \u03c3\u2208R_d such that \u03c4 = \u03c3 \u00b7 (A\u00b7\u03c3)^{m\u22121}. This check uses O(log \u2113) matrix products and membership tests in the precomputed R_.\nWhy useful: isolates the finite set of candidate period types for O(1) witnesses.\n\nLemma 2 (Matrix periods in SCCs)\nFor a 0\u20131 matrix T, let G(T) be its digraph, and for each SCC S\u2286G(T), define per(S) as the gcd of lengths of all directed cycles in S. One can compute per(S) in poly(\u03b2) time per SCC by standard distance-gcd methods: fix a root r, compute dist(\u00b7) on a spanning arborescence, and set per(S)=gcd over edges (u\u2192v) in S of dist(u)+1\u2212dist(v). If per(S)=1, T|_S is primitive and has an exponent e(S)\u2264(\u03b2\u22121)^2+1 (Wielandt).\nWhy useful: aperiodicity (per=1) implies existence of closed walks of all sufficiently large lengths.\n\nLemma 3 (Necessary aperiodicity for O(1))\nLet \u03a0 be a \u03b2-normalized, radius-1 LCL on cycles. Assume there exists an O(1)-round deterministic algorithm for \u03a0. Then for every \u03c4\u2208Ptypes the matrix T_\u03c4 has an aperiodic SCC S_\u03c4 (per(S_\u03c4)=1).\nProof.\nFix \u03c4\u2208Ptypes and let w be a primitive word realizing \u03c4. Consider the infinite family of inputs C_m that are cycles of length m\u00b7|w| with input labeling w^m. These are valid inputs, and m is arbitrary. Let R be the constant runtime of the algorithm. For sufficiently large m, each node in C_m sees the same radius-R input neighborhood up to rotation; hence the algorithm\u2019s local rule induces the same boundary behavior across all C_m. In particular, there exists an output state x such that the per-period transition induced on outputs corresponds to taking one step by T_\u03c4 from x, and consistency around the cycle demands a closed walk of length m in T_\u03c4 from x to x, i.e., (T_\u03c4^m)[x,x]=1 for all large m. Let S be the SCC of G(T_\u03c4) containing x. In a strongly connected digraph, the set of lengths of closed walks from a node to itself equals the semigroup generated by per(S) beyond some threshold; thus if per(S)>1, then closed walks exist only for lengths in a proper residue class modulo per(S). Since both m and m+1 appear (for large enough m), this is impossible unless per(S)=1. Therefore S is aperiodic.\n\nCorollary 4 (EXPTIME-checkable necessary test)\nIf there exists \u03c4\u2208Ptypes such that every SCC of G(T_\u03c4) has per>1, then \u03a0 cannot be O(1); hence its complexity is at least \u03a9(log* n).\nComplexity: compute Ptypes (Lemma 1). For each \u03c4, compute SCC periods (Lemma 2). If any \u03c4 fails the aperiodicity condition, reject O(1). Total time 2^{O(\u03b2^2)}\u00b7poly(\u03b2).\n\nExample (parity)\nLet \u03a3out={a,b}, A be the 2-cycle (a\u2194b), and Cin\u2013out accept both outputs for both inputs. Then for any \u03c4, T_\u03c4=A\u00b7M(\u03c4)=A (since M(\u03c4) is all-ones on the support of Cin\u2013out). G(T_\u03c4) is a single SCC with per=2. By Corollary 4, \u03a0 is not O(1), agreeing with the known \u0398(log* n) lower bound for 2-coloring on cycles.\n\nSufficient certificate recap (for O(1))\nAs in earlier notes, a sufficient certificate consists of:\n- For each \u03c4\u2208Ptypes, choice of an aperiodic SCC S_\u03c4 in T_\u03c4 and an anchor x_\u03c4\u2208S_\u03c4, plus a global Lcount \u2265 max_\u03c4 exponent(T_\u03c4|_{S_\u03c4}).\n- A short-separator table g: T\u00d7{00,01,10,11}\u00d7T\u2192\u03a3out^2 satisfying local legality.\n- For all tuples (\u03c4_a,\u03c4_b,\u03c4_c,\u03c4_d,S1,S2), witnesses establishing entry into S_\u03c4b and exit from S_\u03c4c within \u2264K steps, and a cross-edge A[s_b,s_c]=1, which together imply the bridge scalar holds uniformly for all m_b,m_c\u2265Lcount. Verification is EXPTIME in \u03b2, as detailed previously.\n\nWhy this is progress\n- Lemma 3 and Corollary 4 give a clean, implementable necessary condition for O(1) in single-exponential time. This prunes O(1) early and prevents false positives (e.g., parity).\n- Together with the earlier sufficient certificate, we now have a two-sided framework: (i) necessary aperiodicity test (deterministic EXPTIME), and (ii) if it passes, a NEXPTIME branch that guesses the anchors and g and verifies the interface constraints in EXPTIME. Proving the extraction/compression lemma remains to elevate sufficiency to equivalence, but the necessary half is now formal and checkable.\n\nObstacles / open items\n- Necessity proof is for cycles; extending the argument to globally oriented paths is routine by considering long interior runs of \u03c4 and fixed boundary conditions, but we need to write it carefully (endpoints remove the wrap-around A step; use M(\u03c4) instead of T_\u03c4 appropriately).\n- Completeness: we still need to show any O(1) algorithm induces (S_\u03c4,x_\u03c4) and g satisfying the interface constraints for all \u03c4 and short windows. This seems to follow from local indistinguishability on large periodic segments plus replacement, but requires a careful extraction.\n- Convention coherence: we fixed T_\u03c4=A\u00b7M(\u03c4); all bridge formulas and witnesses should continue to follow this convention to avoid off-by-one issues.\n\nNext steps\n1) Integrate the necessary aperiodicity test (Cor. 4) into the top-gap branch of the overall procedure; produce a short write-up and add to proofs.md.\n2) Formalize endpoint (path) version of Lemma 3 using M(\u03c4) instead of T_\u03c4.\n3) Work on the extraction lemma: from any O(1) rule on cycles, define anchors x_\u03c4 in aperiodic SCCs and derive a uniform separator table g; use type replacement to eliminate dependence on particular representatives. Establish that the interface witness constraints are met.\n4) Implement Ptypes and per(S) computation; test on small \u03b2 instances (including parity-like gadgets) to validate the necessary filter and refine witness search for the sufficient certificate.\n"
}