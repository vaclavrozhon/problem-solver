Ideas
- We tighten the top-gap (O(1) vs Ω(log* n)) analysis by isolating a necessary condition based on aperiodicity of the per-period transfer T_τ := A·M(τ). This complements the sufficient aperiodicity-based certificate proposed earlier and yields an EXPTIME-checkable filter: if it fails, the instance cannot be O(1).
- We also formalize primitive type enumeration and matrix-period computation with explicit complexity bounds (single-exponential in β), making this step implementable for the overall NEXPTIME procedure.

Conventions and basic definitions (radius 1)
- A is the β×β Boolean adjacency of Cout–out. For s∈{0,1}, Ds is diagonal with Ds[x,x]=1 iff (s,x)∈Cin–out.
- For an input word w=s1…sk, define its transfer matrix M(w)=Ds1·A·Ds2·A·…·A·Dsk (Boolean semiring). Types are matrices M(w). Concatenation: M(uv)=M(u)·A·M(v).
- For a type τ, define the per-period step T_τ := A·M(τ). Informally, traversing one period of τ maps left boundary output to right boundary output by T_τ.
- Let K=|T| be the number of reachable types (2^{O(β^2)}). Let Ptypes be the set of types realized by primitive words of length ≤K.

Lemma 1 (Enumerating primitive period types)
One can compute Ptypes in time 2^{O(β^2)}·poly(β):
- Compute T (reachable types) and the length-filtered sets R_ℓ for 1≤ℓ≤K by iterating R_{ℓ+1}={M·A·Ds: M∈R_ℓ, s∈{0,1}}.
- A type τ∈R_ℓ is primitive iff there do not exist integers d,m with 1≤d<ℓ and m≥2 and a type σ∈R_d such that τ = σ · (A·σ)^{m−1}. This check uses O(log ℓ) matrix products and membership tests in the precomputed R_.
Why useful: isolates the finite set of candidate period types for O(1) witnesses.

Lemma 2 (Matrix periods in SCCs)
For a 0–1 matrix T, let G(T) be its digraph, and for each SCC S⊆G(T), define per(S) as the gcd of lengths of all directed cycles in S. One can compute per(S) in poly(β) time per SCC by standard distance-gcd methods: fix a root r, compute dist(·) on a spanning arborescence, and set per(S)=gcd over edges (u→v) in S of dist(u)+1−dist(v). If per(S)=1, T|_S is primitive and has an exponent e(S)≤(β−1)^2+1 (Wielandt).
Why useful: aperiodicity (per=1) implies existence of closed walks of all sufficiently large lengths.

Lemma 3 (Necessary aperiodicity for O(1))
Let Π be a β-normalized, radius-1 LCL on cycles. Assume there exists an O(1)-round deterministic algorithm for Π. Then for every τ∈Ptypes the matrix T_τ has an aperiodic SCC S_τ (per(S_τ)=1).
Proof.
Fix τ∈Ptypes and let w be a primitive word realizing τ. Consider the infinite family of inputs C_m that are cycles of length m·|w| with input labeling w^m. These are valid inputs, and m is arbitrary. Let R be the constant runtime of the algorithm. For sufficiently large m, each node in C_m sees the same radius-R input neighborhood up to rotation; hence the algorithm’s local rule induces the same boundary behavior across all C_m. In particular, there exists an output state x such that the per-period transition induced on outputs corresponds to taking one step by T_τ from x, and consistency around the cycle demands a closed walk of length m in T_τ from x to x, i.e., (T_τ^m)[x,x]=1 for all large m. Let S be the SCC of G(T_τ) containing x. In a strongly connected digraph, the set of lengths of closed walks from a node to itself equals the semigroup generated by per(S) beyond some threshold; thus if per(S)>1, then closed walks exist only for lengths in a proper residue class modulo per(S). Since both m and m+1 appear (for large enough m), this is impossible unless per(S)=1. Therefore S is aperiodic.

Corollary 4 (EXPTIME-checkable necessary test)
If there exists τ∈Ptypes such that every SCC of G(T_τ) has per>1, then Π cannot be O(1); hence its complexity is at least Ω(log* n).
Complexity: compute Ptypes (Lemma 1). For each τ, compute SCC periods (Lemma 2). If any τ fails the aperiodicity condition, reject O(1). Total time 2^{O(β^2)}·poly(β).

Example (parity)
Let Σout={a,b}, A be the 2-cycle (a↔b), and Cin–out accept both outputs for both inputs. Then for any τ, T_τ=A·M(τ)=A (since M(τ) is all-ones on the support of Cin–out). G(T_τ) is a single SCC with per=2. By Corollary 4, Π is not O(1), agreeing with the known Θ(log* n) lower bound for 2-coloring on cycles.

Sufficient certificate recap (for O(1))
As in earlier notes, a sufficient certificate consists of:
- For each τ∈Ptypes, choice of an aperiodic SCC S_τ in T_τ and an anchor x_τ∈S_τ, plus a global Lcount ≥ max_τ exponent(T_τ|_{S_τ}).
- A short-separator table g: T×{00,01,10,11}×T→Σout^2 satisfying local legality.
- For all tuples (τ_a,τ_b,τ_c,τ_d,S1,S2), witnesses establishing entry into S_τb and exit from S_τc within ≤K steps, and a cross-edge A[s_b,s_c]=1, which together imply the bridge scalar holds uniformly for all m_b,m_c≥Lcount. Verification is EXPTIME in β, as detailed previously.

Why this is progress
- Lemma 3 and Corollary 4 give a clean, implementable necessary condition for O(1) in single-exponential time. This prunes O(1) early and prevents false positives (e.g., parity).
- Together with the earlier sufficient certificate, we now have a two-sided framework: (i) necessary aperiodicity test (deterministic EXPTIME), and (ii) if it passes, a NEXPTIME branch that guesses the anchors and g and verifies the interface constraints in EXPTIME. Proving the extraction/compression lemma remains to elevate sufficiency to equivalence, but the necessary half is now formal and checkable.

Obstacles / open items
- Necessity proof is for cycles; extending the argument to globally oriented paths is routine by considering long interior runs of τ and fixed boundary conditions, but we need to write it carefully (endpoints remove the wrap-around A step; use M(τ) instead of T_τ appropriately).
- Completeness: we still need to show any O(1) algorithm induces (S_τ,x_τ) and g satisfying the interface constraints for all τ and short windows. This seems to follow from local indistinguishability on large periodic segments plus replacement, but requires a careful extraction.
- Convention coherence: we fixed T_τ=A·M(τ); all bridge formulas and witnesses should continue to follow this convention to avoid off-by-one issues.

Next steps
1) Integrate the necessary aperiodicity test (Cor. 4) into the top-gap branch of the overall procedure; produce a short write-up and add to proofs.md.
2) Formalize endpoint (path) version of Lemma 3 using M(τ) instead of T_τ.
3) Work on the extraction lemma: from any O(1) rule on cycles, define anchors x_τ in aperiodic SCCs and derive a uniform separator table g; use type replacement to eliminate dependence on particular representatives. Establish that the interface witness constraints are met.
4) Implement Ptypes and per(S) computation; test on small β instances (including parity-like gadgets) to validate the necessary filter and refine witness search for the sufficient certificate.
