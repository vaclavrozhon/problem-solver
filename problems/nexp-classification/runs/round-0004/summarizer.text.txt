{"summary_md":"Last round: developed a transfer‑matrix/types framework for β‑normalized radius‑1 LCLs on oriented paths. For each input segment w define M(w)=S_{i1}·E·S_{i2}·E·… (Boolean β×β); proved composition and replacement lemmas and built the reachable type set T (|T|≤2^{β^2}) and length‑filtered sets R_K,R_{K+1}. Using types, gave a NEXPTIME procedure for the middle gap (O(log* n) vs Θ(n)): nondeterministically guess an exponential table f_type:T×{00,01,10,11}×T→Σ_out^2 and verify local + bridge matrix checks (E·M_{τ_b}·E·M_{τ_c}·E) over τ_b,τ_c∈R_K∪R_{K+1} in EXPTIME. The O(1) vs Ω(log* n) case needs a compression/extraction lemma: naive per‑type loop tests fail (parity counterexample). Proposed fix: require aperiodic (period‑1) SCC anchors in A_τ:=M_τ·E and use Wielandt bounds to obtain eventual closure; supply entry/exit witnesses and cross‑edges to form an EXPTIME‑checkable exponential certificate. Remaining tasks: prove stub‑surgery and compression lemmas to extract such a certificate from any O(1) algorithm and finish the NEXPTIME trichotomy.","highlights":["Defined transfer‑matrix types M(w) (Boolean β×β) with composition M(P·Q)=M_P·E·M_Q and a replacement lemma; reachable type set T computable (|T|≤2^{β^2}).","Middle‑gap (O(log* n) vs Θ(n)) decided in NEXPTIME: guess f_type:T×{00,01,10,11}×T→Σ_out^2 and verify bridge checks B(τ_b,τ_c)=E·M_{τ_b}·E·M_{τ_c}·E over τ_b,τ_c∈R_K∪R_{K+1} in EXPTIME.","Complexity accounting: building T and verification cost 2^{O(β^2)}·poly(β), so overall NEXPTIME in input length N=poly(β).","Naive per‑type loop certificates can false‑positive (parity counterexample) — need residue/aperiodicity info, not just existence of some closed walk.","Proposed sufficient EXPTIME‑checkable O(1) certificate: pick anchors in aperiodic SCCs of A_τ=M_τ·E, use Wielandt exponent for eventual closure, supply bounded entry/exit witnesses and cross‑edges to guarantee interfaces for all large repetition counts.","Remaining gap: prove extraction/compression (and stub‑surgery) lemmas that derive the above exponential per‑type certificate from any O(1) algorithm; formalize endpoint/no-wrap cases."],"next_questions":["Implement the type automaton (compute T, R_K,R_{K+1}) and the EXPTIME verifier for f_type; run tests on small β to sanity‑check costs.","Formalize the aperiodic‑anchor certificate (compute SCC periods, Wielandt bounds, entry/exit sets) and write precise EXPTIME checks for interface conditions.","Prove the compression/extraction lemma and the stub‑surgery lemma: show any O(1) algorithm yields the per‑type anchors and bounded separator table, and handle endpoint/no‑wrap cases."] }