=== SYSTEM ===
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md, proofs.md, and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (informal progress & exploratory work so far)
- proofs.md (rigorous proofs & detailed mathematics so far)
- output.md (main results found so far)

**Three-tier file system guidelines**:
- **notes.md**: Readable, log of exploratory work, intuitions, failed attempts, ideas. Prefer appending. Replace only if old notes are clearly misleading. It should be self-contained: In particular, reading it should make sense without knowing the output of provers in past rounds. 

- **proofs.md**: Complete rigorous mathematical proofs with full details. Think twice before adding anything. Contains proven lemmas, theorems, and detailed derivations. Only add mathematically verified content here.
- **output.md**: This is the only file that the user is supposed to read in case your verdict is "promising". It has to be self-contained. It contains ONLY the main problem results, and a discussion why they are relevant. It is extremely selective. Think twice before promoting proofs from proofs.md to output.md. Only if the result marks clear progress on the problem, and only if the proof in proofs.md has been thoroughly vetted by provers and you, it can join output.md. Each result must be followed by a rigorous, self-contained proof that properly defines all objects of interest and is essentially publication-ready. 

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (≥200 words). Include concrete next-step suggestions.",
  "summary_md": "Concise summary of this round's work for summarizer.",
  "verdict": "promising|uncertain|unlikely",
  "blocking_issues": ["List of issues preventing progress"],
  "per_prover": [{"prover_id": "01", "brief_feedback": "feedback", "score": "promising|uncertain|unlikely"}],
  "notes_update": {"action": "append|replace", "content": "Markdown for notes.md"},
  "proofs_update": {"action": "append|replace", "content": "Markdown for proofs.md"}, 
  "output_update": {"action": "append|replace", "content": "Markdown for output.md"}
}

**Verdict definitions**:
- **promising**: Significant mathematical progress, publishable results
- **uncertain**: Some progress you deem nontrivial, but with unresolved issues or incomplete reasoning  
- **unlikely**: No meaningful progress, fundamentally flawed approaches, or just exploratory work

**Update guidelines**:
- Use null for any update field you don't want to modify
- notes_update: Include informal reasoning, failed attempts, intuitions, exploratory work
- proofs_update: Only include complete, rigorous proofs that you have verified
- output_update: Only include main problem results that directly advance toward the solution


=== USER ===
=== Task (txt) ===


Let M be a tridiagonal matrix with complex numbers z_1, z_2, ..., z_n on diagonal, all entries right below the main diagonal are 1 and all entries right above are -1, e.g.

z_1 -1   0
1    z_2 -1
0   1       z_3

Furthermore, the numbers on diagonal satisfy linear condition
z_1 + 2 z_2 + 3z_3 + ... n z_n =0.

Prove that there is no nilpotent matrix of this form.

It has been checked computationally that the conjecture holds for n <= 5. 


=== Notes ===

# Research Notes




=== Current Output ===

# Main Results




=== Prover 1 Output ===

# Critical assessment of the current writeup

- The current files contain only the problem statement and no mathematical development. There is no notation, no decomposition of the matrix, no auxiliary operators, and no plan of attack. This makes it hard to verify or build upon any partial results.
- Immediate priorities:
  - Fix notation and introduce convenient operators (lower/upper shift, weight-diagonal), so that commutator identities can be exploited.
  - Extract necessary consequences of nilpotency (traces of powers vanish, special entries of powers vanish) and translate the weighted condition into a form that interacts with those identities.
  - Prove small but nontrivial lemmas that can be checked independently (e.g., exact formulas for certain boundary entries of powers of M), useful for an inductive or combinatorial argument.

Below I propose concrete, testable lemmas and derive several identities that appear useful, together with a complete proof for n = 3. These should be entered into notes.md and proofs.md as appropriate.


Ideas and notation

- Let D = diag(z_1, …, z_n), L be the lower shift (ones on the sub-diagonal), U the upper shift (ones on the super-diagonal), and W = diag(1,2,…,n). Then M = D + L − U.
- Define J := L + U and S := L − U (so M = D + S and J = [W, M]).
- Nilpotency of M implies: tr(M^k) = 0 for all k ≥ 1 and M^n = 0. In particular tr(M) = z_1 + … + z_n = 0 and det(M) = 0.
- The weighted constraint is ∑_{i=1}^n i z_i = 0. A key reformulation (proved below) is
  ∑_{i=1}^n i z_i = ∑_{k=1}^n S_k = ∑_{k=1}^n T_k,
  where S_k := ∑_{j=1}^k z_j (prefix sums) and T_k := ∑_{j=n-k+1}^n z_j (suffix sums).


Basic commutator identities (rigorous)

Lemma 1 (weight commutator): For W = diag(1,…,n) and M = D + L − U,
[W, M] = J = L + U.
Proof. Since [W, D] = 0 and for the bidiagonals one has [W, L] = L and [W, U] = −U (because (w_{i+1}−w_i)=1 and (w_i−w_{i+1})=−1), we get [W, M] = [W, L] − [W, U] = L + U = J. ∎

Lemma 2 (edge commutator): [L, M] = [L, D] + E_{1,1} − E_{n,n}, where [L, D] is strictly lower bidiagonal with entries ([L, D])_{i+1,i} = z_i − z_{i+1}.
Proof. One checks [L, D]_{i+1,i} = L_{i+1,i} z_i − z_{i+1} L_{i+1,i} = z_i − z_{i+1}. A direct computation with E_{ij}-basis shows [L, L−U] = [L, S] = E_{1,1} − E_{n,n}. Thus [L, M] = [L, D] + [L, S] = [L, D] + E_{1,1} − E_{n,n}. ∎

Corollary 3 (trace identities): For every k ≥ 1,
tr(J M^{k−1}) = 0 and tr([L, M] M^{k−1}) = 0.
Proof. Both are traces of commutators: tr([W, M] M^{k−1}) and tr([L, M] M^{k−1}). ∎


Exact boundary entries of powers: path-counting lemmas (rigorous)

These are pivotal and easy to check computationally.

Lemma 4 (prefix boundary entries). For 1 ≤ k ≤ n,
(M^k)_{k,1} = S_k := ∑_{j=1}^k z_j,
and for 0 ≤ k ≤ n−1,
(M^k)_{k+1,1} = 1.
Proof. Consider M = D + L − U acting on e_1. To reach row k from column 1 in exactly k steps on the path graph, you must perform exactly k−1 lower (L) steps and exactly one diagonal (D) step, with zero upper steps; any U-step would necessitate at least two additional L-steps to compensate, exceeding k total steps. The unique family of such paths inserts D at step s = 1,…,k, contributing z_s, while the L steps are weight 1. Summing gives (M^k)_{k,1} = ∑_{s=1}^k z_s.
Similarly, to reach row k+1 in k steps from column 1 you must take k L-steps, giving weight 1. ∎

Lemma 5 (suffix boundary entries). For 1 ≤ k ≤ n,
(M^k)_{n−k+1, n} = (−1)^{k−1} T_k,  with T_k := ∑_{j=n−k+1}^n z_j.
Proof. To reach row n−k+1 from column n in k steps, you must make exactly k−1 upper (U) steps and exactly one diagonal (D) step, with zero L-steps; any L-step would require too many U-steps to end k levels above. There are k choices for the unique D insertion; each U contributes a factor −1, so the sign is (−1)^{k−1}. ∎

Corollary 6 (weighted sum as boundary-sum). One has
∑_{i=1}^n i z_i = ∑_{k=1}^n S_k = ∑_{k=1}^n T_k = ∑_{k=1}^n (M^k)_{k,1} = ∑_{k=1}^n (−1)^{k−1} (M^k)_{n−k+1,n}.
Proof. The first equality is the classical identity ∑ i z_i = ∑_{k=1}^n ∑_{j=1}^k z_j. The second is the analogous decomposition into suffix sums. The last two follow from Lemmas 4 and 5. ∎

Remarks on nilpotency vs. the boundary entries. If M is nilpotent then M^n = 0, hence (M^n)_{n,1} = 0 and Lemma 4 with k = n yields ∑_{i=1}^n z_i = 0 (trace condition) from a single boundary entry. Likewise, Lemma 5 with k = n also yields ∑_{i=1}^n z_i = 0.


Low-order trace identities (rigorous, easy checks)

Lemma 7. For every n,
tr(M^2) = ∑_{i=1}^n z_i^2 − 2(n−1).
Proof. Using M = D + S with S = L − U and S having zero diagonal, we have tr(M^2) = tr(D^2) + tr(S^2). The diagonal entries of S^2 are −1 at the ends and −2 in the interior; summing gives tr(S^2) = −2(n−1). ∎

Corollary: If M is nilpotent then ∑ z_i^2 = 2(n−1).

Lemma 8. tr(M^3) = ∑_{i=1}^n z_i^3 + 3(z_1 + z_n).
Proof. Expand M^3 = (D + S)^3 and use cyclicity of trace. All terms with exactly one S have zero trace because S has zero diagonal. For three S’s, tr(S^3) = 0 (S is real skew-symmetric). The remaining terms give 3 tr(D S^2). Since (S^2)_{ii} is −1 at i = 1, n and −2 otherwise, tr(D S^2) = −z_1 − 2∑_{i=2}^{n−1} z_i − z_n. If tr(M) = 0 (as in the nilpotent case), this collapses to tr(D S^2) = z_1 + z_n, hence tr(M^3) = ∑ z_i^3 + 3(z_1 + z_n). ∎

Corollary: If M is nilpotent then ∑ z_i^3 = −3(z_1 + z_n).

These identities give quickly-checkable necessary conditions and are useful for small n eliminations.


A complete hand proof for n = 3

Let n = 3. Nilpotent M requires
(1) z_1 + z_2 + z_3 = 0 (trace 0),
(2) z_1 z_2 + z_1 z_3 + z_2 z_3 + 2 = 0 (coefficient of t in characteristic polynomial),
(3) z_1 z_2 z_3 + z_1 + z_3 = 0 (determinant = 0),
and the weighted condition gives
(4) z_1 + 2 z_2 + 3 z_3 = 0.
Subtract (1) from (4): z_2 + 2 z_3 = 0 ⇒ z_2 = −2 z_3 and then from (1) z_1 = z_3. Plug into (3): z_1 z_2 z_3 + z_1 + z_3 = −2 z_3^3 + 2 z_3 = 0 ⇒ z_3 ∈ {0, ±1}. If z_3 = 0 then all z_i = 0 contradict (2). If z_3 = ±1, then (2) becomes (±1)(∓2) + (±1)(±1) + (∓2)(±1) + 2 = −3 + 2 = −1 ≠ 0. Contradiction in all cases. Thus no nilpotent M exists for n = 3 under the weighted condition.

This matches the computational claim and shows the techniques can hand-certify small n.


How the weighted condition interacts with the structure (insight)

- The key observation is Corollary 6: the weighted sum ∑ i z_i is literally the sum of a sequence of boundary entries of the powers of M, either from the left edge ((M^k)_{k,1}) or the right edge ((M^k)_{n−k+1,n}) with alternating signs. This makes the linear constraint algebraically compatible with identities that come from commutators ([W, M] = J and [L, M] = [L, D] + edge-projection), and with path-counting on the chain.
- For nilpotent M, M^n = 0 kills the last terms in these sums, enforcing, in addition to trace 0, that the prefix or suffix sums obey specific alternating-sum cancellations. The low-degree trace identities add strong algebraic constraints (e.g., ∑ z_i^2 = 2(n−1) and ∑ z_i^3 = −3(z_1 + z_n)). In small n these already lead to contradictions; in large n they seem overdetermined together with the single weighted linear constraint.


Obstacles and why some direct routes fail

- Using only tr(M^k) = 0 and the weighted linear equation is insufficient for a direct contradiction in general n; extra structure is needed (the commutator identities and path-counting lemmas supply it).
- Direct Gershgorin or positivity arguments don’t apply (z_i can be complex, and off-diagonal signs do not force spectral separation from 0).
- A naive attempt to kill all U/L contributions in M^{n+1} using alternating sums fails because multiple path types of the same parity contribute with the same sign.


Actionable next steps (incremental and auditable)

1) Formalize and verify Lemmas 4–5 (boundary entries) for general n, with a clean inductive or path-counting proof written in proofs.md. These are central tools.
2) Extend the trace computations to tr(M^4) and tr(M^5) in terms of {z_i} and a few short edge-sums (z_1, z_n). The pattern should stabilize and likely yield tr(M^{2m}) as a polynomial in the power sums ∑ z_i^{2r} plus fixed constants, and tr(M^{2m+1}) as a polynomial involving odd power sums and (z_1 + z_n). Each identity adds algebraic constraints under nilpotency.
3) Attempt an induction on n using elimination of the edge variables z_1 and z_n via the two linear equations (trace 0 and weighted 0), then write the Schur complement of the 1st and nth rows/columns to derive a tri-diagonal of size n−2 with the same off-diagonal pattern and a derived weighted equation. Show this induction step preserves the forbidden structure (i.e., if the smaller matrix were nilpotent with the derived weighted condition, then so would the original). Proving the impossibility at the base case (n = 3) would then yield the full result.
4) Alternatively, push the commutator method: from Lemma 2, the identities 0 = tr([L, M] M^{k−1}) give for all k ≥ 1
   (M^{k−1})_{1,1} − (M^{k−1})_{n,n} + ∑_{i=1}^{n−1} (z_i − z_{i+1}) (M^{k−1})_{i, i+1} = 0.
   Combine these with the boundary formulas of Lemma 4 to isolate linear combinations of the z_i. For small k these reduce to tautologies; for larger k they may generate independent constraints, especially when coupled with tr(M^k) = 0.
5) Document and hand-check the case n = 4 via the identities above (should be feasible by hand, given we already have tr(M^2), tr(M^3), and the two linear equations; adding one more identity like tr(M^4) or a commutator-derived constraint likely completes it). This will exercise the method and inform the induction strategy.


Summary of new, rigorously proven ingredients

- [W, M] = L + U and [L, M] = [L, D] + E_{1,1} − E_{n,n}.
- For all 1 ≤ k ≤ n: (M^k)_{k,1} = ∑_{j=1}^k z_j and (M^k)_{n−k+1,n} = (−1)^{k−1} ∑_{j=n−k+1}^n z_j.
- Weighted constraint equivalences: ∑ i z_i = ∑_{k=1}^n (M^k)_{k,1} = ∑_{k=1}^n (−1)^{k−1} (M^k)_{n−k+1,n}.
- Trace identities: tr(M^2) = ∑ z_i^2 − 2(n−1); tr(M^3) = ∑ z_i^3 + 3(z_1 + z_n); hence under nilpotency ∑ z_i^2 = 2(n−1) and ∑ z_i^3 = −3(z_1 + z_n).
- Complete contradiction for n = 3 under the weighted condition.

These give a solid platform for the verifier to incorporate into notes.md and proofs.md, and a clear plan for pushing to the full theorem via induction or higher-trace constraints.


=== Prover 2 Output ===

# Ideas

We encode the characteristic polynomial via continuants and extract explicit coefficient identities. These give necessary algebraic constraints for nilpotence, including new ones that isolate the contributions of the two endpoints z_1 and z_n. The plan is to combine these with the weighted linear constraint ∑ i z_i = 0 and pursue an induction-on-n “edge-peeling” strategy.

# Setup and basic continuant facts

Let M be the n×n tridiagonal with diagonal z_1,…,z_n, sub-diagonal entries 1, and super-diagonal entries −1. Set

- Δ_0(λ) = 1,
- Δ_1(λ) = λ − z_1,
- Δ_{k+1}(λ) = (λ − z_{k+1}) Δ_k(λ) + Δ_{k−1}(λ) for k ≥ 1.

Then Δ_n(λ) = det(λ I − M). In particular, det M = (−1)^n Δ_n(0).

Write α_k := det M_{[1..k]} (the leading k×k principal minor of M). Then α_0 = 1, α_1 = z_1, and α_{k+1} = z_{k+1} α_k + α_{k−1}. Also Δ_k(0) = (−1)^k α_k.

Nilpotence (det(λ I − M) = λ^n) forces all coefficients except the leading to vanish. We translate the first coefficients and certain traces in terms of the z_i.

# Necessary conditions for nilpotence

- Coefficient of λ^{n−1}: − tr M = −∑_{i=1}^n z_i = 0. So ∑ z_i = 0.

- Coefficient of λ^{n−2}: sum of all principal 2×2 minors. For non-adjacent pairs {i,j}, the 2×2 principal minor is z_i z_j; for adjacent pairs {i,i+1} it is z_i z_{i+1} − (−1)·1 = z_i z_{i+1} + 1. Hence
  ∑_{1≤i<j≤n} z_i z_j + (n−1) = 0.
  Equivalently, using (∑ z_i)^2 = ∑ z_i^2 + 2∑_{i<j} z_i z_j and ∑ z_i = 0,
  tr(M^2) = 0 ⇒ ∑_{i=1}^n z_i^2 = 2(n−1).

  A direct check via M^2 also gives tr(M^2) = ∑ z_i^2 − (2n−2): the diagonal of K^2 (K = off-diagonal part) is −1 at i = 1, n and −2 otherwise.

- Coefficient of λ^{n−3}: combinatorial identity. Using the continuant/matching expansion
  Δ_n(λ) = ∑_{matchings M on P_n} ∏_{i∉V(M)} (λ − z_i),
  the coefficient of λ^{n−3} collects contributions from:
  • matchings with 0 edges: choose 3 z’s → −∑_{i<j<k} z_i z_j z_k,
  • matchings with 1 edge: choose 1 z among unmatched vertices → −∑_{|M|=1} ∑_{i∉V(M)} z_i.

  Summing over all single edges e_k = {k,k+1}, the inner sum counts each interior vertex i∈{2,…,n−1} exactly (n−3) times (all edges except k = i−1,i), and each end i∈{1,n} exactly (n−2) times. Thus
  ∑_{|M|=1} ∑_{i∉V(M)} z_i = (n−3) ∑_{i=1}^n z_i + (z_1 + z_n).

  Therefore the λ^{n−3} coefficient is
  c_{n−3} = −∑_{i<j<k} z_i z_j z_k − (n−3) ∑_{i=1}^n z_i − (z_1 + z_n).
  Under nilpotence c_{n−3} = 0, and using ∑ z_i = 0 we get the clean identity
  ∑_{1≤i<j<k≤n} z_i z_j z_k = −(z_1 + z_n).

  By Newton’s identities with e_1 = 0 and e_2 = −(n−1), this implies
  ∑ z_i^3 = 3 e_3 = −3(z_1 + z_n),
  which also matches tr(M^3) = 0 computed directly (see below).

# Trace(M^3) check

Write M = D + K with D diagonal, K skew-symmetric tridiagonal (1 below, −1 above). A direct expansion shows, using trace-cyclicity and the vanishing of traces with an odd number of K’s except in the mixed terms:

tr(M^3) = tr(D^3) + 2 tr(D K^2) + tr(K D K).

One computes tr(D K^2) = −2∑ z_i + (z_1 + z_n) and tr(K D K) = −2∑ z_i + (z_1 + z_n). Thus, with ∑ z_i = 0,

tr(M^3) = ∑ z_i^3 + 3(z_1 + z_n).

Nilpotence forces tr(M^3)=0, i.e. ∑ z_i^3 = −3(z_1 + z_n), as above.

# A Wronskian-type telescoping identity for continuants

Let T_k(λ) = Δ_k'(λ) Δ_{k−1}(λ) − Δ_k(λ) Δ_{k−1}'(λ). Differentiating the recurrence yields the telescoping relation T_{k+1} + T_k = Δ_k(λ)^2, with base T_1(λ) = 1. Hence

T_n(λ) = (−1)^{n−1} [1 − Δ_1(λ)^2 + Δ_2(λ)^2 − ⋯ + (−1)^{n−1} Δ_{n−1}(λ)^2].

Evaluating at λ = 0 and using Δ_n(λ) = λ^n under nilpotence (so Δ_n(0) = 0 and Δ_n'(0) = 0 for n≥2), we get T_n(0) = 0 and the necessary identity

1 − a_1^2 + a_2^2 − ⋯ + (−1)^{n−1} a_{n−1}^2 = 0,  where a_k = Δ_k(0) = (−1)^k α_k.

Equivalently, in terms of leading principal minors α_k = det M_{[1..k]},

1 − α_1^2 + α_2^2 − ⋯ + (−1)^{n−1} α_{n−1}^2 = 0.

This adds a global quadratic constraint on the sequence of principal minors that any nilpotent instance must satisfy.

# Cofactor factorization at λ=0

For A(λ) = λ I − M, the i-th principal cofactor at λ satisfies

C_{ii}(λ) = Δ_{i−1}(λ) · Δ^{(i+1)}_{n−i}(λ),

where the second factor is the continuant built from z_{i+1},…,z_n. At λ = 0, if Δ_n(λ) were identically λ^n, then all i-cofactors of A(λ) would vanish at λ = 0 (equivalently, det(−M) is stationary in each z_i at that point). Thus any nilpotent solution must satisfy the system

Δ_{i−1}(0) · Δ^{(i+1)}_{n−i}(0) = 0,  for all i = 1,…,n.

This forces a combinatorial propagation of zeros among the leading and trailing continuants, severely restricting possible z. In combination with the Wronskian identity above, this suggests a strong rigidity that we aim to exploit.

# How the weighted constraint enters

The given condition is ∑_{i=1}^n i z_i = 0. We record two calculi that connect it to the structure:

- tr(W M) = ∑ i z_i, where W = diag(1,2,…,n). So the weight constraint is tr(W M) = 0.

- The fixed commutator [W, M] = S is the symmetric tridiagonal with 1 on both off-diagonals and 0 on the diagonal, independent of z. Although tr([M^k, W]) = 0 yields tr(S M^{k−1}) = 0 for all k, this holds for all z and thus does not isolate the weighted constraint by itself. Nonetheless, it provides a stable algebraic framework to combine with specific coefficient identities.

# Examples and checks

- For n ≤ 5, c_{n−3} identity simplifies drastically and is easy to verify symbolically; when combined with e_1 = 0 and e_2 = −(n−1), it agrees with computational checks that no solution exists under ∑ i z_i = 0.

- The Wronskian identity furnishes a nontrivial necessary condition that can be explicitly tested for small n using the recurrences for α_k.

# Obstacles

- Extending the explicit coefficient computation to λ^{n−4} and beyond requires careful combinatorial accounting of matchings. While feasible, the bookkeeping is intricate (boundary effects and adjacency exclusions), so we present only the precise λ^{n−3} identity here.

- Direct use of commutator identities alone does not leverage the weighted constraint. One needs to combine them with coefficient identities or principal-minor propagation to get contradictions.

# Next steps

- Compute c_{n−4} explicitly. Strategy: express the λ^{n−4} coefficient as
  c_{n−4} = e_4 − Q + m_2,
  where m_2 is the number of 2-edge matchings on P_n, and Q = ∑_{edges} ∑_{pairs of unmatched vertices} z_i z_j. One can show
  Q = (n−4) e_2 + ∑_{i=1}^{n−1} z_i z_{i+1},
  by counting for each pair {i,j} how many edges avoid both i and j (endpoints contribute one extra allowed edge). This yields a closed form for c_{n−4}. Then impose c_{n−4}=0 together with e_1=0, e_2=−(n−1), and the λ^{n−3} identity to isolate z_1 + z_n and the nearest-neighbor sum ∑ z_i z_{i+1}. Combined with ∑ i z_i = 0, this should force a contradiction (e.g., by induction peeling the ends).

- Pursue an induction: assume no nilpotent instance for size < n; from the identities deduce z_1 = z_n = 0, reduce to size n−2 via the Schur complement of the middle block, and conclude.

- Alternatively, use the cofactor-vanishing propagation Δ_{i−1}(0) Δ^{(i+1)}_{n−i}(0) = 0 for all i. Combine with the Wronskian identity to prove that all α_k must vanish, which is impossible when inserted into 1 − α_1^2 + α_2^2 − ⋯ + (−1)^{n−1} α_{n−1}^2 = 0.

# Summary of proven, reusable lemmas

- Continuant recurrence: Δ_{k+1} = (λ − z_{k+1}) Δ_k + Δ_{k−1}.

- Nilpotence implies: ∑ z_i = 0, ∑_{i<j} z_i z_j = −(n−1), and ∑_{i<j<k} z_i z_j z_k = −(z_1 + z_n).

- Trace identities: tr(M^2) = ∑ z_i^2 − (2n−2), tr(M^3) = ∑ z_i^3 + 3(z_1 + z_n). Under nilpotence these vanish, consistent with the above symmetric sums.

- Wronskian identity at λ = 0: 1 − α_1^2 + α_2^2 − ⋯ + (−1)^{n−1} α_{n−1}^2 = 0.

These are nontrivial, checkable constraints. The intended completion is to add c_{n−4} (and possibly c_{n−5}) in closed form, then combine with the weighted linear constraint to force a contradiction for all n.
