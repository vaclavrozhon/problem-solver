\newcommand{\bits}{\{0,1\}}
\newcommand{\E}{\mathbb{E}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\polylog}{\operatorname{poly}\log}
\newcommand{\RAC}{\mathrm{RAC}}
\newcommand{\Queries}{\mathrm{Queries}}
\newcommand{\Aall}{A_{\textsf{all-scales}}}

\section{Goal.}
The goal is to confirm or refute \textbf{Conjecture~1.5} from Ben-Eliezer–Grossman–Naor (2024) in the $O(\sqrt{n / \polylog(n)})$ regime. We will describe the conjecture precisely next. 

\section{Model}
We work with the directed graph of a function $f:[n]\to[n]$: each vertex has out-degree~1; for simplicity assume \emph{no loops} ($f(v)\ne v$). An algorithm has two query types per step:
\begin{enumerate}
  \item \textbf{Start:} sample a uniformly random unseen vertex $u\in[n]$ (\emph{start a new walk}).
  \item \textbf{Step:} if $u$ was already encountered, query its unique out-neighbor, revealing $f(u)$.
\end{enumerate}
The \emph{state} is the set of seen vertices and any exposed edges; equivalently, a disjoint family of directed walks and (possibly) cycles encountered so far. A \emph{collision} is a pair $x\neq y$ with $f(x)=f(y)$; the algorithm succeeds upon exhibiting such a pair.

\paragraph{Unlabeled instance optimality.}
Let $\RAC(P,f)$ denote the \emph{unlabeled certificate complexity} for property $P$
(e.g.\ collision) on instance $f$---the expected query complexity of the best algorithm
\emph{given an unlabeled certificate} (a permutation of $f$), in the Las Vegas sense.\,%
(See their formal Definitions~2.1--2.3.)
An algorithm $A$ is \emph{$g(n)$-close to instance optimal} if
$\Queries_A(f)\le g(n)\cdot \RAC(P,f)$ for all $f$.

\section{The all-scales strategy}
We consider the natural parallel strategy $\Aall$ (``at scales $2^i$''):

\begin{quote}
For $i=0,1,\dots,\lfloor \log_2 n\rfloor$, maintain a process $A_i$ that repeatedly:
\begin{enumerate}
  \item starts at a fresh uniform random vertex $v$;
  \item walks forward for up to $2^i$ steps (stopping early if a cycle closes or a collision is found);
  \item if no collision was found, restart from a new random vertex.
\end{enumerate}
Interleave all $A_i$ fairly (e.g.\ round-robin): each round makes $O(\log n)$ forward queries, one for each $i$; stop as soon as any $A_i$ finds a collision (we also look for collisions between vertices found by $A_i$ and some other $A_j$). 
\end{quote}

This is more-or-less the function analogue of the graph algorithm for claws in \S1.1 and \S6 (there dubbed $\Aall$); the paper conjectures that $\Aall$ is $O(\log n)$-instance-optimal for collisions and claws. (Conjectures~1.5 and~1.6; see also their informal theorem and analysis.) 

\section{A target statement in the low-complexity regime}
Your task is to prove the following forward-only analogue of their Theorem~1.7.

\begin{theorem}[Forward-only, low complexity --- target]
\label{thm:forward-low}
There exist absolute constants $C,\alpha>0$ such that for every $f:[n]\to[n]$ with no loops,
if $\RAC(\text{collision}, f)\le \sqrt{n} / \log^{\alpha} n$, then
\[
  \E[\Queries_{\Aall}(f)] \;\le\; C\,\log n\cdot \RAC(\text{collision}, f).
\]
\end{theorem}

\noindent The theorem above mirrors their near-optimality bound for claws (\S6, Theorem~6.1), but specialized to collisions and with \emph{forward-only} walks; the proof needs a substitute for their ``hardness of merging'' lemma in graphs (\S6.2). 



\section{Guiding intuition for the forward-only model}

\paragraph{Known evidence.}
They prove an $O(\log n)$ near-optimality theorem for \emph{claw detection} in graphs in a
``low-complexity'' regime, and explain how the proof extends to \emph{functions} \emph{if}
backward queries (preimages) are allowed; the obstacle is \emph{merging walks} without finding a claw/collision.\,%
(See Theorem~1.7 and \S6, and remarks under ``Model robustness''.) 

\paragraph{Obstruction}
In our forward-only function model, a potential obstruction is a \emph{false merge}:
while walking from $u$ we discover $f(u)=v$ where $v$ is a vertex we previously sampled as a
\emph{start}, but which was not reached by some other forward walk. This is \emph{not} a collision.
Heuristically, with $q\ll \sqrt{n}$ total forward steps, the number of such false merges is
$\ll 1$ in expectation (birthday-type reasoning), so with good probability \emph{any} merge we see is a true collision. This suggests the graph proof scheme (which conditions on ``no merging'') can be adapted:
when false merges are negligible, we can couple an arbitrary algorithm to $\Aall$ scale-by-scale.


\section{A roadmap for how a proof of Theorem~\ref{thm:forward-low} could look like}
We sketch a possible approach to prove the theorem. It was generated by an LLM. Take it with a grain of salt; and only as a potentially flawed inspiration. 

\subsection*{(I) Controlling false merges up to $q=O(\sqrt{n/\log n})$ steps}
Let $S_t$ be the set of start vertices sampled by time $t$ (starts, not discovered via an out-edge),
and let $X_t$ be the number of \emph{false merges} by time $t$:
events of the form ``query $f(u)$ and reveal $f(u)=v\in S_{t-1}$'' when $v$ was \emph{not} first reached by another forward walk.

\begin{lemma}[Few false merges]
\label{lem:false-merge}
There exist constants $c_0,c_1>0$ such that for any (adaptive) algorithm that makes $q\le c_0\sqrt{n/\log n}$ forward queries,
\[
  \E[X_q]\;\le\; c_1\,\frac{q^2}{n}
  \quad\text{and}\quad
  \Pr[X_q\ge 1]\;=\;O\!\left(\frac{q^2}{n}\right)\;=\;o(1).
\]
\end{lemma}

\emph{Sketch.} Reveal the process step-by-step.
At step $t$, the probability that $f(u_t)$ hits the (random) set $S_{t-1}$ is at most $|S_{t-1}|/(n-t+1)$.
Summing and applying a martingale (Freedman/Azuma) bound for sampling without replacement yields the claim.
Adaptivity only lowers these hit probabilities. \qed

\subsection*{(II) Coupling to $\Aall$ when false merges do not occur}
Fix any algorithm $A$ that finds a collision in expected $q=\RAC(\text{collision}, f)$ queries when given the unlabeled certificate.
As in \S6.3 of the paper, expose in advance a random string $r$ listing the ``new'' starting vertices;
assume the event \textsf{no-skip}: the $j$-th new start $A$ uses is the $j$-th entry of $r$ (standard, with failure prob.\ $O(q^2/n)$).
Condition also on \textsf{no-false-merge}: $X_{2q}=0$.
Under these two events,
the walk-system of $A$ decomposes cleanly by \emph{age}: older walks are always at least as long as newer ones (no merges to entangle them).
Exactly as in Claim~6.11 of the paper, one couples (scale by scale) the progress of $A$ to that of a single-scale process $A_i$,
\emph{but now with forward-only walks}:
if $A$ first hits a collision within distance $[2^i,2^{i+1})$ from its starting point $v_j$,
then $A_i$ finds the same collision after at most a constant factor more forward steps (here: $\le 4$ times),
because every older start $v_{j'}$ has already been advanced by at least $2^i$ steps unless it hit a cycle earlier.
This is the identical amortization used in \S6.3, just without backtracking, which we do not need.

\subsection*{(III) Assembling the bound}
By Markov, $A$ succeeds within $2q$ queries with probability $\ge 1/2$.
Intersecting the high-probability events \textsf{no-false-merge} (Lemma~\ref{lem:false-merge}) and \textsf{no-skip} (prob.\ $\ge 1-O(q^2/n)$) gives
overall success probability $\ge 1/3$ in a single \emph{epoch} of $8q$ rounds of the interleaved $\Aall$ (cost $O(q\log n)$ queries per epoch).
A standard geometric argument then yields
$\E[\Queries_{\Aall}(f)] = O(q\log n)$, proving Theorem~\ref{thm:forward-low}.

\paragraph{Where this differs from the paper.}
Their graph proof needs an explicit lemma that \emph{merging} two undirected walks is hard before $\tilde{\Theta}(\sqrt n)$ queries (\S6.2),
plus a path-symmetry cleanup (\S6.1).
In the forward-only function model, we replace both by Lemma~\ref{lem:false-merge}:
with $q\ll \sqrt n$, every merge is a true collision with high probability, and thus the \S6.3 coupling applies verbatim. 

\paragraph{References.} All references and terminology (unlabeled certificates, $\Aall$, low-complexity regime, coupling) follow Ben-Eliezer–Grossman–Naor, \emph{On the Instance Optimality of Detecting Collisions and Subgraphs} (arXiv:2312.10196, v2, Aug 2024). 

