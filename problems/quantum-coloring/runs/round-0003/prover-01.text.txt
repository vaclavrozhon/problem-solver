{"progress_md":"Headlines for this round\n- We stress-test the logical interface between the LP and the algorithmic regimes and add two small structural lemmas (monotonicity in r; extreme-point structure) to guide computations. We also sharpen what the interior-placement constraints actually model and when they are justified.\n- We outline an auditable plan to generate and certify r = 2 LP instances for k ≈ 10–16 with symmetry reductions, and propose a fallback “transfer-matrix” analytic relaxation for cross-checks. \n- We point out two places in output.md that benefit from explicit caveats (regime for LP constraints; role of automorphism invariance with entanglement).\n\nGaps or clarifications needed in output.md\n1) Scope of the LP constraints (Definition 6). The LP enforces “interior placement invariance.” As stated, Definition 6 is purely combinatorial and does not mention the regime under which these equalities are necessary for a physical algorithm. In the entangled regime, those equalities are only guaranteed if the initial global state is invariant under the automorphisms of the cycle (or if one applies a symmetrization step at the start). In the product-state regime (no entanglement, identical local states), they are justified. Suggestion: add one sentence after Definition 6 clarifying: “These constraints are necessary for r-round uniform algorithms under (i) product initial states with identical local marginals, or (ii) arbitrary shared entanglement provided the initial global state is invariant under cycle automorphisms (rotations/reflections). Without such symmetry in the initial state, the constraints need not hold.” This would harmonize Definition 6 with Lemma 5 and Corollary 8.\n2) Constant-error bound with entanglement (Corollary 8). The proof correctly uses Lemma 5; it would help to add a pointer back to Remark 5.2 (EPR-pair counterexample) to remind the reader that the automorphism-invariance hypothesis is essential. As a constructive note: in many distributed protocols one can enforce automorphism invariance by a public random rotation of node labels/ports prior to the algorithm; if allowed, that reduces the assumption to “shared randomness is available”. If such a symmetry-randomization step is admissible in our model, we can note this explicitly; otherwise, keep the assumption as is.\n\nNew small lemmas (useful structure for the LP and for planning computations)\n- Lemma A (Monotonicity in r). For fixed k, the LP optimum is nondecreasing in r: q(r+1,k) ≥ q(r,k). Reason: Every feasible p for (r,k) is also feasible for (r+1,k), because as r grows the family of interior placements shrinks (fewer ω with buffers fully inside [1..k]), so the set of equality constraints weakens. Therefore the feasible set enlarges and the supremum cannot decrease.\n- Lemma B (Extreme points). The feasible region of Definition 6 is a polytope in R^{3^k} cut out by linear equalities and nonnegativity plus Σ p_ψ = 1. Hence an optimal solution exists at an extreme point. In particular, for any (r,k) one can search for sparse optimal supports (basic feasible solutions). This is useful for reducing solver time and for constructing human-auditable dual certificates.\n\nSanity checks and toy examples\n- Consistency of thresholds: The stride k+2r in Corollary 3 matches the necessity of 2r-separation; the r = 1, path 0–1–2 example shows that an r-stride would be false. \n- Dirac mass infeasibility: As noted in notes.md, under single-core invariance constraints even a single proper coloring dirac mass is infeasible; we will keep this test in our solver harness to catch bugs.\n\nComputation plan (r = 2) — concrete and auditable\n- Variables and symmetries:\n  • Work in the quotient space under S3 color permutations and reflection to reduce Σ^k orbits. For k = 12 this typically yields ~5–10× reduction. Maintain a map to lift primal/dual certificates back to the full space.\n  • Enforce translation invariance across interior placements by constraints; do not hardwire stationarity on positions in advance, to keep the LP sound in our regime.\n- Constraint families (progressive tightening):\n  • Start with all single-core families {{s}} with s ∈ {1,2,3}, all r-gapped interior placements; this enforces uniformity of position-marginals for blocks of length ≤ 3.\n  • Add two-core families ({{1}},{{1}}), ({{2}},{{1}}), ({{2}},{{2}}) at separations d ranging over those permitted by r-gaps inside [1..k]. This captures pairwise non-signaling constraints beyond immediate adjacencies.\n  • If the optimum remains 1, expand to t = 3 families, e.g., (1,1,1) and (2,1,1), again at several admissible placements.\n- Solving and certification:\n  • Use a high-precision LP solver (e.g., exact rational via QSopt_ex or SoPlex with long-double) to avoid numerical slack. \n  • For any instance with optimum q < 1, extract the dual solution (weights on equality constraints and indicator inequalities) and store it as a certificate. We will include: problem parameters (r,k), list of placements F, the dual vector, and the certificate inequality showing Σ_ψ p_ψ 1{proper(ψ)} ≤ q.\n- Targets and acceptance criteria:\n  • Parameter sweep: (r,k) = (2,10..16). Stop as soon as one k yields q ≤ 0.99 (or any q < 1). Record the smallest such k and the achieved q.\n  • Cross-checks: (i) Verify monotonicity q(r,k+1) ≤ q(r,k) on our chosen constraint families (a relaxation); (ii) Verify Lemma A empirically by comparing r = 2 and r = 3 with identical constraint families.\n\nBackup analytic cross-check (transfer-matrix / Markov relaxations)\n- As an independent relaxation (feasible set ⊂ LP-feasible), we can restrict to stationary Markov chains of order d (e.g., d = 2 or 3) on Σ with forbidden equal-adjacency transitions. The feasible chains are parameterized by local marginals consistent with our single-/two-core placement constraints. Maximizing P[proper on [1..k]] under such a chain yields an upper bound on q(r,k). This helps detect solver/modeling errors and provides intuition about which local patterns saturate the optimum.\n\nEntanglement regime and symmetry discussion (why our LP still yields a valid constant bound)\n- With entanglement but without automorphism-invariance, interior placement equality need not hold (Remark 5.2). For constant-error bounds (Corollary 8), we either (i) assume the initial state is automorphism-invariant, or (ii) allow an initial public random rotation of the cycle (if admissible), which effectively restores invariance in distribution. In both cases, Lemma 5 applies and the LP optimum upper-bounds P[W proper]. Without such symmetry, we cannot soundly use the LP; this caveat should be explicit at Definition 6 (see “Gaps” above).\n\nAdditional observations\n- Theorem 2 independence with product states remains sound: disjoint supports imply commuting effects and factorization of the trace; there is no subtlety from non-commutativity.\n- Combining Lemma 7 (monotonicity in k) and Lemma A (monotonicity in r) suggests focusing first on the smallest r and the largest k our solver tolerates; any q < 1 found there is “hardest won” and suffices for amplification.\n\nNext steps (checkable)\n1) Text refinements in output.md:\n   - After Definition 6, add a one-sentence regime caveat as above.\n   - In Corollary 8, add a parenthetical “(under automorphism-invariant initial states; cf. Remark 5.2)” to spotlight the assumption.\n2) Implement the r = 2 solver (with symmetry reductions and staged constraints) and sweep k ∈ {10,…,16}. For any instance with optimum < 1, produce and archive a dual certificate. \n3) If a (2,k,q<1) is found, immediately state: \n   - No-entanglement exponential bound: P_success(C_n) ≤ q^{⌊n/(k+4)⌋}.\n   - Entanglement (automorphism-invariant) constant bound: P_success(C_n) ≤ q for n ≥ k.\n4) Explore r = 3 with smaller k (≤ 14) to gauge sensitivity; verify Lemma A numerically.\n5) Build the Markov-chain relaxation and compute its bound for the same (r,k) to cross-check solver outputs; keep code and numeric logs for audit.\n\nPotential pitfalls to watch\n- Over-reduction of symmetry (e.g., misquotienting S3 or reflection) can silently invalidate constraints; we will keep both full and reduced LPs on small k to validate the reduction pipeline.\n- Constraint generation must ensure that every equality ties only placements whose r-buffers lie entirely inside [1..k]. We will implement a placement validator to avoid illegal constraints.\n"}