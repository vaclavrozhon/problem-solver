--- SYSTEM ---
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (summary so far)
- output.md (rigorously proven results so far)

Guidelines:
- notes.md: should be a readable running log of interesting work. Prefer appending. Replace only if old notes are clearly misleading. Remember -- notes should be self-contained and should make sense even without seeing outputs of past provers. 
- output.md: should be concise and rigorous. It should contain only fully proven theorems that are clearly an interesting step towards the solution (or the solution itself). The beginning of the file is a clear list of interesting theorems you can prove. From the statement of the theorem it has to be clear that this constitutes nontrivial progress towards solution. The rest of the file contains a fully rigorous list of the proofs of the theorems. Keep only proven theorems with clear proofs. If a statement is flawed and you cannot fix it, remove it from output.md and instead add it to notes.md with explanation.
- Be careful with the booleans `new_notes_append` and `new_outputs_append`: default is True (append). Use False only when deliberately rewriting everything.

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (≥200 words). Include concrete next-step suggestions. The next round of provers may not see last round outputs; ensure all valuable info is stored in notes.",
  "new_notes_md": "Markdown (KaTeX allowed). Usually appended to notes.",
  "new_notes_append": "True|False",
  "new_outputs_md": "Markdown (KaTeX allowed). Usually appended to output.md.",
  "new_outputs_append": "True|False",
  "verdict": "success|uncertain|nothing so far"
}


--- USER ---
You receive multiple prover reports. Evaluate correctness, value, and pick promising directions. Update notes.md (append/replace) with useful ideas and update output.md (append/replace) ONLY with rigorously verified results.

Prover reports (JSON):
[{"prover_id": "01", "progress_md": "Headlines for this round\n- We stress-test the logical interface between the LP and the algorithmic regimes and add two small structural lemmas (monotonicity in r; extreme-point structure) to guide computations. We also sharpen what the interior-placement constraints actually model and when they are justified.\n- We outline an auditable plan to generate and certify r = 2 LP instances for k \u2248 10\u201316 with symmetry reductions, and propose a fallback \u201ctransfer-matrix\u201d analytic relaxation for cross-checks. \n- We point out two places in output.md that benefit from explicit caveats (regime for LP constraints; role of automorphism invariance with entanglement).\n\nGaps or clarifications needed in output.md\n1) Scope of the LP constraints (Definition 6). The LP enforces \u201cinterior placement invariance.\u201d As stated, Definition 6 is purely combinatorial and does not mention the regime under which these equalities are necessary for a physical algorithm. In the entangled regime, those equalities are only guaranteed if the initial global state is invariant under the automorphisms of the cycle (or if one applies a symmetrization step at the start). In the product-state regime (no entanglement, identical local states), they are justified. Suggestion: add one sentence after Definition 6 clarifying: \u201cThese constraints are necessary for r-round uniform algorithms under (i) product initial states with identical local marginals, or (ii) arbitrary shared entanglement provided the initial global state is invariant under cycle automorphisms (rotations/reflections). Without such symmetry in the initial state, the constraints need not hold.\u201d This would harmonize Definition 6 with Lemma 5 and Corollary 8.\n2) Constant-error bound with entanglement (Corollary 8). The proof correctly uses Lemma 5; it would help to add a pointer back to Remark 5.2 (EPR-pair counterexample) to remind the reader that the automorphism-invariance hypothesis is essential. As a constructive note: in many distributed protocols one can enforce automorphism invariance by a public random rotation of node labels/ports prior to the algorithm; if allowed, that reduces the assumption to \u201cshared randomness is available\u201d. If such a symmetry-randomization step is admissible in our model, we can note this explicitly; otherwise, keep the assumption as is.\n\nNew small lemmas (useful structure for the LP and for planning computations)\n- Lemma A (Monotonicity in r). For fixed k, the LP optimum is nondecreasing in r: q(r+1,k) \u2265 q(r,k). Reason: Every feasible p for (r,k) is also feasible for (r+1,k), because as r grows the family of interior placements shrinks (fewer \u03c9 with buffers fully inside [1..k]), so the set of equality constraints weakens. Therefore the feasible set enlarges and the supremum cannot decrease.\n- Lemma B (Extreme points). The feasible region of Definition 6 is a polytope in R^{3^k} cut out by linear equalities and nonnegativity plus \u03a3 p_\u03c8 = 1. Hence an optimal solution exists at an extreme point. In particular, for any (r,k) one can search for sparse optimal supports (basic feasible solutions). This is useful for reducing solver time and for constructing human-auditable dual certificates.\n\nSanity checks and toy examples\n- Consistency of thresholds: The stride k+2r in Corollary 3 matches the necessity of 2r-separation; the r = 1, path 0\u20131\u20132 example shows that an r-stride would be false. \n- Dirac mass infeasibility: As noted in notes.md, under single-core invariance constraints even a single proper coloring dirac mass is infeasible; we will keep this test in our solver harness to catch bugs.\n\nComputation plan (r = 2) \u2014 concrete and auditable\n- Variables and symmetries:\n  \u2022 Work in the quotient space under S3 color permutations and reflection to reduce \u03a3^k orbits. For k = 12 this typically yields ~5\u201310\u00d7 reduction. Maintain a map to lift primal/dual certificates back to the full space.\n  \u2022 Enforce translation invariance across interior placements by constraints; do not hardwire stationarity on positions in advance, to keep the LP sound in our regime.\n- Constraint families (progressive tightening):\n  \u2022 Start with all single-core families {{s}} with s \u2208 {1,2,3}, all r-gapped interior placements; this enforces uniformity of position-marginals for blocks of length \u2264 3.\n  \u2022 Add two-core families ({{1}},{{1}}), ({{2}},{{1}}), ({{2}},{{2}}) at separations d ranging over those permitted by r-gaps inside [1..k]. This captures pairwise non-signaling constraints beyond immediate adjacencies.\n  \u2022 If the optimum remains 1, expand to t = 3 families, e.g., (1,1,1) and (2,1,1), again at several admissible placements.\n- Solving and certification:\n  \u2022 Use a high-precision LP solver (e.g., exact rational via QSopt_ex or SoPlex with long-double) to avoid numerical slack. \n  \u2022 For any instance with optimum q < 1, extract the dual solution (weights on equality constraints and indicator inequalities) and store it as a certificate. We will include: problem parameters (r,k), list of placements F, the dual vector, and the certificate inequality showing \u03a3_\u03c8 p_\u03c8 1{proper(\u03c8)} \u2264 q.\n- Targets and acceptance criteria:\n  \u2022 Parameter sweep: (r,k) = (2,10..16). Stop as soon as one k yields q \u2264 0.99 (or any q < 1). Record the smallest such k and the achieved q.\n  \u2022 Cross-checks: (i) Verify monotonicity q(r,k+1) \u2264 q(r,k) on our chosen constraint families (a relaxation); (ii) Verify Lemma A empirically by comparing r = 2 and r = 3 with identical constraint families.\n\nBackup analytic cross-check (transfer-matrix / Markov relaxations)\n- As an independent relaxation (feasible set \u2282 LP-feasible), we can restrict to stationary Markov chains of order d (e.g., d = 2 or 3) on \u03a3 with forbidden equal-adjacency transitions. The feasible chains are parameterized by local marginals consistent with our single-/two-core placement constraints. Maximizing P[proper on [1..k]] under such a chain yields an upper bound on q(r,k). This helps detect solver/modeling errors and provides intuition about which local patterns saturate the optimum.\n\nEntanglement regime and symmetry discussion (why our LP still yields a valid constant bound)\n- With entanglement but without automorphism-invariance, interior placement equality need not hold (Remark 5.2). For constant-error bounds (Corollary 8), we either (i) assume the initial state is automorphism-invariant, or (ii) allow an initial public random rotation of the cycle (if admissible), which effectively restores invariance in distribution. In both cases, Lemma 5 applies and the LP optimum upper-bounds P[W proper]. Without such symmetry, we cannot soundly use the LP; this caveat should be explicit at Definition 6 (see \u201cGaps\u201d above).\n\nAdditional observations\n- Theorem 2 independence with product states remains sound: disjoint supports imply commuting effects and factorization of the trace; there is no subtlety from non-commutativity.\n- Combining Lemma 7 (monotonicity in k) and Lemma A (monotonicity in r) suggests focusing first on the smallest r and the largest k our solver tolerates; any q < 1 found there is \u201chardest won\u201d and suffices for amplification.\n\nNext steps (checkable)\n1) Text refinements in output.md:\n   - After Definition 6, add a one-sentence regime caveat as above.\n   - In Corollary 8, add a parenthetical \u201c(under automorphism-invariant initial states; cf. Remark 5.2)\u201d to spotlight the assumption.\n2) Implement the r = 2 solver (with symmetry reductions and staged constraints) and sweep k \u2208 {10,\u2026,16}. For any instance with optimum < 1, produce and archive a dual certificate. \n3) If a (2,k,q<1) is found, immediately state: \n   - No-entanglement exponential bound: P_success(C_n) \u2264 q^{\u230an/(k+4)\u230b}.\n   - Entanglement (automorphism-invariant) constant bound: P_success(C_n) \u2264 q for n \u2265 k.\n4) Explore r = 3 with smaller k (\u2264 14) to gauge sensitivity; verify Lemma A numerically.\n5) Build the Markov-chain relaxation and compute its bound for the same (r,k) to cross-check solver outputs; keep code and numeric logs for audit.\n\nPotential pitfalls to watch\n- Over-reduction of symmetry (e.g., misquotienting S3 or reflection) can silently invalidate constraints; we will keep both full and reduced LPs on small k to validate the reduction pipeline.\n- Constraint generation must ensure that every equality ties only placements whose r-buffers lie entirely inside [1..k]. We will implement a placement validator to avoid illegal constraints.\n"}]

Current notes.md:
Scope and goal
We seek lower bounds for 2–3 round quantum LOCAL algorithms that 3-color an n-cycle. We separate two resource regimes: (i) no initial shared entanglement (initial product state across vertices), and (ii) arbitrary initial shared entanglement. Our strategy follows and extends Le Gall–Rosmanis (LGR, 2022): reduce to a line-segment optimization under r-local non-signaling constraints, then lift to cycles. Two technical pillars are (A) light-cone localization of measurements in r rounds (implying r-non-signaling), and (B) independence across well-separated regions when the initial state is a product.

Key corrections/new facts
- Independence threshold is 2r, not r, in the two-way model without entanglement. After reversing r communication layers, any measurement on a block depends only on the block’s r-neighborhood. Thus independence of multiple blocks requires their r-neighborhoods to be disjoint, i.e., pairwise distances > 2r. Counterexample to “> r” for r = 1: on a path 0–1–2, one round suffices for node 1 to broadcast a private random bit to nodes 0 and 2, correlating their outputs at distance 2.
- Non-signaling beyond r holds with or without shared entanglement: the marginal on a set S depends only on the initial state on N_r(S). This follows from Heisenberg-picture localization of effects under depth-r local circuits/channels.

Amplification templates
- No entanglement (product initial state): If there exists k and q < 1 such that every r-non-signaling distribution on a length-k segment makes the segment proper with probability at most q, then on cycles C_n the success probability is at most q^{⌊n/(k+2r)⌋}. Partition C_n into ⌊n/(k+2r)⌋ disjoint windows of length k separated by gaps of size 2r; window events are independent by the 2r-separation lemma; ring proper implies all windows are proper.
- With entanglement allowed: For any fixed window W of length k, ring proper implies W is proper. The distribution on W (restricted to placements with r-buffers inside W) is feasible for the r-non-signaling LP, hence P[ring proper] ≤ P[W proper] ≤ q. There is no improvement from packing without independence; the optimal general bound is the n-independent constant q.

LP plan for r = 2, 3
- Variables: probabilities over colorings on r-gapped placements (collections of frames) inside [1..k]. Placements include cores and r-buffers fully contained in [1..k].
- Constraints: non-signaling equalities enforcing that the marginal distribution on a given core is independent of the surrounding placement context as long as r-buffers are intact (equalities of marginals across placements that agree on the core).
- Objective: maximize P[all k − 1 edges inside [1..k] are properly 3-colored].
- Symmetries: quotient by S3 color permutations; translations (and reflections, if used). It is safe (as a relaxation) to enforce only a generating set of non-signaling constraints; for the final certificate, include all placements that respect the segment.
- Execution: sweep k ≈ 10–16 for r = 2 (then smaller k for r = 3), solve numerically, and extract dual certificates for any instance with optimum < 1.

What remains to be computed
- A concrete (r, k, q) with q < 1 via the LP. Once obtained, immediately plug into the amplification templates above. Note the stride is k + 2r (not k + r) in the independence-based exponential bound.

Reference counterexample (to avoid regression)
- Two-way, r = 1, no entanglement: path 0–1–2. Node 1 samples b ∈ {0,1}, sends b to 0 and 2, both output b. Outputs at distance 2 are perfectly correlated; independence beyond r = 1 fails. Independence holds only when r-neighborhoods are disjoint (distance > 2r).
Additional clarifications and refinements

1) Interior placement invariance: correct assumptions and a counterexample
- Valid regimes. For an r-round uniform LOCAL algorithm on a cycle C_n, invariance of interior placements (i.e., equality of core marginals for all gap-r placements whose r-buffers lie within a window W) holds under either of the following assumptions:
  (a) No shared entanglement and identical local initial states (product initial state ⊗_v ρ, with the same ρ at every vertex).
  (b) Shared entanglement is allowed, but the global initial state ρ_0 is invariant under the automorphisms of C_n (rotations and reflections). Uniformity of the local channels across vertices is also required.
- Why. In the Heisenberg picture, the effect for a core event depends only on the union of r-neighborhoods of the cores. Two interior placements of the same frame family induce isomorphic unions; the corresponding effects are related by a permutation of registers. If ρ_0 is invariant under that permutation (true in (a) and (b)), the probabilities coincide.
- Necessity of the symmetry assumption with entanglement. Without (b), the statement can fail. Counterexample (r = 0): prepare EPR pairs on disjoint edges (1,2), (3,4), … around the cycle, and have each vertex measure Z and output a color that is a function of its bit. Then the joint distribution on two adjacent cores depends on whether the placement coincides with a paired edge (correlated) or straddles a pair boundary (independent). Hence, equality across placements fails.

2) Segment LP (precise, and what it models)
- Alphabet Σ = {1,2,3}. Fix r ≥ 1 and k ≥ 1. Let a frame family F = ({{s_1}}, …, {{s_t}}), each {{s_j}} a contiguous core of length s_j.
- An r-gapped placement ω of F inside [1..k] is a t-tuple of start positions (ω_1,…,ω_t) such that the r-buffers [[ω_j − r .. ω_j + s_j − 1 + r]] are subsets of [1..k] and pairwise disjoint. The cores are C_j = [[ω_j .. ω_j + s_j − 1]].
- Variables: p_ψ for ψ ∈ Σ^k, with p_ψ ≥ 0 and ∑_ψ p_ψ = 1.
- Objective: maximize ∑_ψ p_ψ · 1{ψ has no equal-color adjacencies on edges (i, i+1), i = 1..k−1}.
- Constraints (interior placement invariance): For every family F and every core assignment ζ = (ζ_1,…,ζ_t), the marginal probability ∑_{ψ: ∀j ψ|_{C_j} = ζ_j} p_ψ is the same for all gap-r placements ω of F (whose r-buffers lie in [1..k]).
- Soundness: These constraints are necessary for distributions induced by r-round uniform algorithms in regimes (1a) or (1b). Dropping some equalities yields a relaxation (weaker constraints and thus a larger feasible set); any optimum < 1 for a relaxation implies the true optimum < 1 as well.

3) Monotonicity in segment length
Let q(r,k) denote the LP optimum at parameters (r,k) as above. Then q(r,k+1) ≤ q(r,k). Proof idea: Any feasible distribution on Σ^{k+1} marginalizes to a feasible distribution on Σ^k (equalities on interior placements survive marginalization), and 1{proper on k+1} ≤ 1{proper on first k} pointwise.

4) Why a point mass on a proper coloring violates the constraints
Under the single-core placement-invariance constraints, the distribution of s-blocks (e.g., s ∈ {1,2}) must be identical for all interior positions. A point mass on a single proper ψ has position-dependent s-blocks unless ψ is constant (impossible if ψ is proper). Hence a Dirac mass cannot be feasible—this is a useful solver sanity check.

5) Amplification stride and regimes
- No entanglement (product initial state): independence requires gaps of size 2r (not r). The exponential amplification stride is k + 2r. This is tight in general (see r = 1 path 0–1–2 counterexample).
- With entanglement: constant-error bounds via the LP above are valid if the initial shared state is automorphism-invariant; without that symmetry, the placement-equality constraints need not hold (cf. the counterexample in item 1).

6) Computational plan (r = 2)
- Variables: p_ψ, ψ ∈ Σ^k. For k = 10, |Σ^k| = 59,049; for k = 12, |Σ^k| = 531,441.
- Symmetry/useful reductions: quotient by S_3 (color permutations) and reflection; treat translation of placements via equality constraints.
- Constraints to start with: all single-core families with s ∈ {1,2,3}; then add two-core families (1,1), (2,1), (2,2) at several separations, over all interior placements.
- Certification: if optimum < 1, extract a dual certificate (constraint multipliers) that verifies the bound.


Current output.md (if any):
Main theorems proved in this file
- Light-cone localization and r-non-signaling for r-round LOCAL algorithms (with or without initial entanglement).
- Independence beyond 2r for two-way r-round LOCAL algorithms with product initial states (no shared entanglement).
- Amplification lemmas: (i) exponential decay in n without entanglement given a segment-level r-non-signaling bound q < 1; (ii) constant error bound with entanglement given the same segment-level bound.

Preliminaries
Let G = (V, E) be a graph (here, cycles are of primary interest). An r-round quantum LOCAL algorithm consists of r synchronous layers of local channels acting on vertex and edge registers, followed by local measurements at the vertices that output colors in {1,2,3}. We model each round as a product of completely positive trace-preserving (CPTP) maps localized on vertices and edges (purifiable to local unitaries by Stinespring dilation). For S ⊆ V, let N_r(S) = {v ∈ V : dist(v, S) ≤ r} denote the r-neighborhood of S.

Theorem 1 (Light-cone localization and r-non-signaling)
Fix an r-round quantum LOCAL algorithm as above. Let S ⊆ V, and let M_S be any POVM element that depends only on the final local measurements in S (e.g., the indicator of a specified color pattern on S). Then there exists a positive operator X_S supported only on the registers associated with N_r(S) (and local ancillas therein) such that, for every initial global state ρ (possibly entangled), the probability of the event M_S is Tr[ρ X_S]. Consequently, if two initial states ρ and ρ′ agree on N_r(S) (i.e., have identical reduced density matrices on N_r(S)), then the output marginal on S is the same under ρ and ρ′. In particular, the output on S is non-signaling with respect to changes outside N_r(S).

Proof sketch (fully rigorous upon standard dilation): Purify the algorithm to a depth-r circuit of local unitaries by introducing vertex-local ancillas. In the Heisenberg picture, conjugating M_S backward through each round enlarges its support by at most one graph hop (only gates that touch the current support can change it). After r rounds, the Heisenberg-evolved effect X_S is supported on N_r(S). For any initial state ρ, P[M_S] = Tr[ρ X_S]. If ρ and ρ′ coincide on N_r(S), then Tr[ρ X_S] = Tr[ρ′ X_S], proving r-non-signaling.

Theorem 2 (Independence beyond 2r without initial entanglement)
Assume the initial state is a product state across vertices (no shared entanglement or shared randomness). Let S_1, …, S_m ⊆ V be subsets whose r-neighborhoods N_r(S_i) are pairwise disjoint (equivalently, dist(S_i, S_j) > 2r for i ≠ j). For each i, let M_{S_i} be any event depending only on the final measurements in S_i, and let X_{S_i} be its Heisenberg-evolved effect from Theorem 1. Then the random outcomes on the sets S_1, …, S_m are mutually independent; in particular,
Tr[ρ X_{S_1} ⋯ X_{S_m}] = ∏_{i=1}^m Tr[ρ_{N_r(S_i)} X_{S_i}],
so the joint distribution factors. This applies to the events “S_i is properly 3-colored internally,” etc.

Proof: By Theorem 1, each X_{S_i} acts only on the registers in N_r(S_i). By hypothesis, these supports are disjoint, and ρ = ⊗_v ρ_v factorizes across the partition of V induced by the disjoint supports. Therefore, the trace of the product factors as claimed, which is precisely independence of the outcomes on S_1, …, S_m.

Corollary 3 (Exponential amplification without entanglement)
Let r ≥ 1. Fix k ≥ 1 and suppose there exists q < 1 such that, for every r-non-signaling distribution on a length-k path segment, the probability that the segment is properly 3-colored is at most q. Then, for any r-round two-way quantum LOCAL algorithm on the n-cycle with product initial state (no shared entanglement), the success probability satisfies
P_success(C_n) ≤ q^{⌊n / (k + 2r)⌋}.

Proof: Partition the cycle into m = ⌊n / (k + 2r)⌋ disjoint windows W_1, …, W_m of length k separated by gaps of size 2r. If the entire cycle is properly 3-colored, then each window W_i is internally proper. For each i, let E_i be the event “W_i is internally proper,” and X_i its Heisenberg-evolved effect. Each X_i is supported on N_r(W_i), and these supports are disjoint by construction, so the events E_i are independent by Theorem 2. By the hypothesis on the segment-level bound, P[E_i] ≤ q for each i, hence P_success(C_n) ≤ P[⋂_i E_i] = ∏_i P[E_i] ≤ q^m.

Corollary 4 (Constant-error bound with shared entanglement)
Let r, k, q be as in Corollary 3. For any r-round two-way quantum LOCAL algorithm on the n-cycle (allowing arbitrary shared entanglement), the success probability obeys
P_success(C_n) ≤ q for all n ≥ k.

Proof: Fix any length-k contiguous window W ⊆ C_n. If the entire cycle is properly 3-colored, then W is internally proper. Let E be the event “W is internally proper.” By Theorem 1, the distribution on W (for placements whose r-buffers lie within W) is r-non-signaling with respect to changes outside W. By the definition of q, P[E] ≤ q. Since {cycle proper} ⊆ {E}, we have P_success(C_n) ≤ P[E] ≤ q.

Remark on the tightness of independence: The threshold 2r is necessary in general. For r = 1 on a path 0–1–2, one round suffices for node 1 to correlate nodes 0 and 2 (e.g., by broadcasting a private random bit), so outputs at distance 2 need not be independent.
Lemma 5 (Interior placement invariance under automorphisms)
Fix an r-round uniform quantum LOCAL algorithm on a cycle C_n, with initial global state ρ_0 on the vertex registers. Let W ⊆ C_n be any contiguous window of length k, and let F be any family of sliding frames ({{s_1}}, …, {{s_t}}). Suppose ω and ω′ are two gap-r placements of F whose r-buffers are contained in W. Assume that ρ_0 is invariant under the automorphisms of C_n (rotations and reflections). Then, for every core assignment ζ = (ζ_1,…,ζ_t), the probability that the algorithm’s outputs on the cores equal ζ is the same for ω and ω′.

Proof
Let U_ω ⊆ W and U_{ω′} ⊆ W be the unions of the r-neighborhoods of the cores in placements ω and ω′, respectively. By Theorem 1 (light-cone localization), there exist positive operators X_ω and X_{ω′} supported on the registers in U_ω and U_{ω′} such that the probabilities of the event “cores equal ζ” are Tr[ρ_0 X_ω] and Tr[ρ_0 X_{ω′}], respectively. Because ω and ω′ are placements of the same frame family with r-buffers contained in W, there is a global automorphism π of the cycle (a rotation or composition with reflection) that maps U_ω to U_{ω′} and preserves adjacency. Uniformity of the local channels implies that the Heisenberg-evolved effects transform covariantly: X_{ω′} = U_π X_ω U_π^†, where U_π is the unitary that permutes the vertex registers according to π. Since ρ_0 is invariant under π, we have Tr[ρ_0 X_{ω′}] = Tr[U_π ρ_0 U_π^† · U_π X_ω U_π^†] = Tr[ρ_0 X_ω].

Corollary 5.1 (Product-state case)
If ρ_0 is a product of identical local states ⊗_{v∈V} ρ (no shared entanglement), then the invariance assumption holds, and Lemma 5 applies.

Remark 5.2 (Necessity of symmetry with entanglement)
Without automorphism-invariance of ρ_0, placement invariance can fail. For example, at r = 0, prepare EPR pairs on disjoint edges (1,2), (3,4), … and measure Z locally; the joint distribution on adjacent cores depends on whether the placement coincides with a paired edge or straddles a pair boundary.

Definition 6 (Segment LP for r-local uniform algorithms)
Fix Σ = {1,2,3}, r ≥ 1, k ≥ 1. A frame family F = ({{s_1}}, …, {{s_t}}) consists of contiguous cores of lengths s_j. An r-gapped placement ω of F inside [1..k] is a t-tuple of start positions (ω_1,…,ω_t) such that the r-buffers [[ω_j − r .. ω_j + s_j − 1 + r]] are subsets of [1..k] and pairwise disjoint. The variables are p_ψ for ψ ∈ Σ^k, with p_ψ ≥ 0 and ∑_ψ p_ψ = 1. The objective is to maximize ∑_ψ p_ψ · 1{ψ has no equal-color adjacencies on edges (i,i+1), i = 1..k−1}. The constraints enforce interior placement invariance: for every F and every core assignment ζ = (ζ_1,…,ζ_t), the marginal ∑_{ψ: ∀j ψ|_{C_j} = ζ_j} p_ψ is identical for all r-gapped placements ω of F inside [1..k]. Denote the optimum by q(r,k).

Lemma 7 (Monotonicity in k)
For all r ≥ 1 and k ≥ 1, q(r,k+1) ≤ q(r,k).

Proof
Let p be feasible for (r,k+1). Its marginal p′ on the first k coordinates satisfies all interior placement invariance constraints for (r,k), because these constraints involve events supported on coordinates 1..k and are linear equalities preserved by marginalization. Moreover 1{ψ is proper on k+1} ≤ 1{ψ|_{[1..k]} is proper on k} pointwise, hence ∑_ψ p_ψ · 1{proper on k+1} ≤ ∑_{ψ′} p′_{ψ′} · 1{proper on k}. Taking suprema over feasible p proves the claim.

Corollary 8 (Constant-error bound with shared entanglement under automorphism invariance)
Let r ≥ 1 and k ≥ 1, and let q(r,k) be as in Definition 6. Consider any r-round uniform quantum LOCAL algorithm on C_n whose initial global state is invariant under the automorphisms of the cycle. Then, for all n ≥ k, the success probability obeys P_success(C_n) ≤ q(r,k).

Proof
Fix any contiguous window W ⊆ C_n of length k. If the cycle is properly colored, then W is internally proper. By Lemma 5, the distribution on W (restricted to events supported on interior r-buffered placements) satisfies the interior placement invariance constraints. Therefore it is feasible for the LP in Definition 6, and the probability that W is internally proper is at most q(r,k). Since {cycle proper} ⊆ {W proper}, P_success(C_n) ≤ q(r,k).

