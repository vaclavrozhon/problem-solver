Ideas
- We target TREE-REACHABLE-PE: given a tree, initial endowment, strict preferences, decide whether there exists a reachable allocation that is globally Pareto-efficient (no allocation at all Pareto-dominates it), and construct one if yes.
- We establish general verifiability (NP membership), a necessary optimality condition for any YES-witness, and give complete polynomial-time solutions for stars (unique terminal state), plus a small path counterexample exhibiting NO. We also give an FPT algorithm parameterized by treewidth and suggest a concrete computational test to resolve whether IR+global-PO must equal TTC.

Lemmas and proofs
1) NP membership
Claim. TREE-REACHABLE-PE ∈ NP.
Proof. A certificate is a perfect matching µ∗. Verification is polynomial: (i) Reachability from µ0 to µ∗ on a tree can be decided in O(n^2) using the “good edge” scheduling: every agent moves along its unique dipath from µ0(a) to µ∗(a); define an edge e as good if the two agents at its endpoints each need e next along their dipaths; if µ∗ is reachable and different from current, at least one good edge exists; greedily swapping on arbitrary good edges reaches µ∗ if and only if µ∗ is reachable (total O(n^2) swaps/time). (ii) Global Pareto-efficiency of µ∗ is checkable in O(n^2) via the improvement digraph: create arcs agent→object for objects strictly preferred to the agent’s current assignment, and arc object→current owner; µ∗ is globally PO iff this digraph has no directed cycle. Hence verification is polynomial. ∎

2) Global PO implies local swap-stability
Lemma. If an allocation µ admits an allowed swap on some edge (both endpoints strictly prefer to exchange), then µ is not globally PO.
Proof. The swap yields another matching ν where the two endpoints are strictly better off and all other agents unchanged; thus ν Pareto-dominates µ. ∎
Corollary. Any reachable matching that is globally PO must be a terminal state (no allowed swap available). In particular, we only need to examine sinks of the swap dynamics.

3) Stars: uniqueness of the terminal state and a complete polynomial algorithm
Model: star centered at c, leaves L; initial houses h_c, {h_ℓ : ℓ∈L}.
Define for each leaf ℓ its “acceptance set” T_ℓ = {x ∈ Objects : x ≻_ℓ h_ℓ}. In a swap sequence, ℓ will accept a swap precisely when the center currently holds an object in T_ℓ. The center’s willingness at any time with current object x is to swap with leaf ℓ iff h_ℓ ≻_c x. Thus the center’s object moves strictly upward in c’s order through a sequence of leaf initial houses.
Theorem (star-sink uniqueness). On a star, every maximal sequence of allowed swaps terminates at the same allocation µ⋆ (unique sink), independent of the order of swaps.
Proof (sketch). Consider the center’s current object x_t at step t; define its rank r_t in c’s preference list (lower is better). Each swap strictly decreases r_t; thus r_t is strictly decreasing and bounded below; termination follows. Define a partial order on center objects by ≻_c. We assert that the set of center objects reachable by any sequence from x_0 is a downward-closed interval in c’s order, and the maximal reachable element y⋆ is unique. Characterize feasibility of moving x→y via a chain ℓ_1,…,ℓ_k of distinct leaves such that: (i) x ∈ T_{ℓ_1}, (ii) h_{ℓ_i} ∈ T_{ℓ_{i+1}} for i<k, (iii) h_{ℓ_i} ≻_c h_{ℓ_{i+1}} and h_{ℓ_k}=y. Any allowed swap sequence corresponds to such a chain; conversely any such chain can be executed, because after i−1 swaps the center holds h_{ℓ_{i−1}} and ℓ_i will accept. Define Y = {y : there exists such a chain from x_0 to y}. Then Y is closed downward in ≻_c and has a unique maximal y⋆. An exchange argument shows any maximal sequence must end at center object y⋆, hence unique sink allocation µ⋆. ∎
Algorithm (stars).
- Compute y⋆ by scanning c’s preference order top to bottom; maintain reachable set via checking for each candidate y whether there exists a chain as above (O(n^2) using a greedy reachability on the DAG of leaves ordered by ≻_c with arcs ℓ→ℓ′ if h_ℓ ∈ T_{ℓ′}). Recover a valid chain and simulate swaps to construct µ⋆ (O(n)).
- By the lemma above, any reachable globally PO matching must be a terminal state; since the terminal state is unique, TREE-REACHABLE-PE on stars reduces to computing µ⋆ and checking if it is globally PO via the cycle test. If yes, output µ⋆; else output NO.
Complexity: O(n^2).

4) A NO-instance on a path (existence can fail)
Instance: path A–B–C with initial (A:a,B:b,C:c) and preferences
- A: c ≻ a ≻ b
- B: b ≻ a ≻ c
- C: a ≻ c ≻ b
No edge-swap is allowed initially (each neighbor pair has at most one endpoint willing), so every reachable allocation equals the initial. However the allocation (A:c,B:a,C:b) globally Pareto-dominates the initial (strictly better for all three). Hence no reachable globally PO allocation exists; TREE-REACHABLE-PE answers NO.

5) FPT algorithm by treewidth
Theorem. TREE-REACHABLE-PE is FPT parameterized by treewidth w of T.
Proof (sketch). Compute a nice tree decomposition of width w. Perform a dynamic program over the decomposition storing, at each bag X, all partial injective assignments µ_X mapping agents in the subtree to objects in the subtree or in X, restricted so that each object is used at most once and unmatched items are tracked. This is a standard assignment DP over bounded treewidth graphs; the number of states per bag is n^{O(w)}. Transitions for introduce/forget/join maintain consistency of partial matchings. At the root, each full matching µ is produced in n^{O(w)} time/total. For each candidate µ, run the O(n^2) reachability test from µ0 and the O(n^2) global PO test; accept if a candidate passes both tests and output it. Total time n^{O(w)}·poly(n). ∎

Remarks on TTC (open pivot)
- A full reduction of TREE-REACHABLE-PE to a single reachability check of the TTC outcome would follow from “IR + global PO ⇒ TTC”. This is presently unproven here. To resolve, we propose an exhaustive search for n ≤ 5 to find a counterexample (an IR and globally PO allocation different from TTC), or else to support a proof attempt by induction on TTC rounds.
- Search template: variables encode a strict preference profile and a matching µ ≠ µ_TTC such that: (i) µ is individually rational (each agent weakly prefers µ(a) to its endowment), (ii) µ is globally PO (no directed cycle in the improvement digraph), (iii) µ ≠ µ_TTC (computed centrally). SAT/CP encoding is straightforward; the verifier can implement this finite check.

Obstacles
- On trees, terminal states of the local swap dynamics need not be unique, and among them some may be globally PO while others are not; identifying the existence of a reachable globally PO terminal state remains subtle beyond stars.
- The equivalence IR+global-PO = TTC remains unresolved here; a positive resolution would yield an O(n^2) algorithm (reachability of TTC on trees). Until then, TTC remains a sufficient certificate only (if TTC is reachable, output it), not a complete algorithm.

Next steps
- Implement the small-instance search to settle IR+global-PO vs TTC (up to n=5 or 6). Either outcome advances the main question.
- Extend the star sink-uniqueness proof to “generalized stars” (one high-degree node) to seek a full polynomial algorithm on that class (compute all terminal states via branch-wise path subroutines, then global PO-check). This is a plausible intermediate class between stars and trees.
- Strengthen necessary conditions: since any globally PO reachable allocation must be a terminal state, characterize terminal states on trees combinatorially (e.g., as acyclic orientations of “desire” edges), then checkability may reduce to a constraint satisfaction instance.
- Maintain the FPT algorithm as a baseline and refine the DP to prune by local no-swap constraints to reduce states.

Summary of deliverables to proofs.md / output.md
- Formal NP membership proof; details of reachability and global PO tests.
- Lemma: globally PO reachable ⇒ no allowed swap (terminal state).
- Star theorem: uniqueness of terminal state; O(n^2) algorithm to compute the sink and decide TREE-REACHABLE-PE on stars.
- Path counterexample showing NO (existence can fail even when a global PO exists but is unreachable).
- FPT algorithm parameterized by treewidth with state definition and complexity.
