{
  "content": "Ideas\n\n- Corrected parameterization: The \u201cnumber of movers k\u201d enumeration yields an XP algorithm, not FPT. Time O(n^k\u00b7k!\u00b7poly(n)); we correct that classification and make it a baseline solver for small k.\n- New parameter and special case: number of leaves L. For trees with a constant number of leaves, we propose a decomposition-based procedure that is polynomial for fixed L. This yields an FPT algorithm parameterized by L (time f(L)\u00b7poly(n)). The path techniques (Algorithm 1, Section 3 of the paper) will be used on each branch.\n- Cut-decomposition lemma for PO: For a tree cut at an articulation vertex r (a center), any directed improvement cycle in the global trading digraph either lies completely within a branch, or uses r and edges to enter/leave branches. This allows us to summarize each branch by a boundary relation at r and to check global PO by combining acyclicity summaries.\n\nExamples\n\n- Sink special case (record): On path A\u2013B\u2013C with initial (A:a,B:b,C:c) and preferences A: c\u227ba\u227bb, B: b\u227ba\u227bc, C: a\u227bc\u227bb, no swap applies. Then reach(\u00b50)={\u00b50}. A single PO test (improvement-digraph acyclicity) shows \u00b50 is not globally PO, hence TREE-REACHABLE-PE answers \u201cnone.\u201d\n- XP-by-k sanity: If k=1, we enumerate S of size \u22641 and test the O(1) permutations; each test uses (i) componentwise reachability (Lemma 3) and (ii) global PO (Lemma 2). This is immediate, and extends to general k with O(n^k\u00b7k!).\n\nRigorous lemmas and corrected statements\n\nLemma A (Reachable \u21d2 IR). Any allocation \u00b5 \u2208 reach(\u00b50) is individually rational: every agent weakly prefers \u00b5(a) to \u00b50(a).\nProof. Each allowed swap strictly improves its endpoints, others unchanged. For each agent a, the sequence of objects they hold is strictly increasing in \u227b_a across their swaps, hence \u00b5(a) \u227d_a \u00b50(a). \u220e\n\nLemma B (PO test in O(n^2)). For a given allocation \u00b5, form the improvement digraph D(\u00b5) with vertices A\u222aO, arcs a\u2192b for b\u227b_a \u00b5(a), and b\u2192owner\u00b5(b). Then \u00b5 is globally Pareto-efficient iff D(\u00b5) is acyclic.\nSketch. A directed cycle prescribes a strict Pareto improvement; conversely any strict Pareto improvement yields such a cycle. Standard. \u220e\n\nLemma C (Tree target reachability in O(n^2)). Given tree T, initial \u00b50 and target \u00b5*, deciding \u00b5*\u2208reach(\u00b50) and producing a swap sequence is doable in O(n^2) by the \u201cgood-edge\u201d scheduler.\nProof sketch. Each agent moves along its unique dipath from \u00b50(a) to \u00b5*(a). An edge is good if both incident agents must cross it next; if current\u2260target and target is reachable, some good edge exists (as in GLW). Repeatedly swap across any good edge; update in O(1); O(n^2) swaps in total. \u220e\n\nTheorem D (NP membership). TREE-REACHABLE-PE \u2208 NP: a certificate is a target allocation \u00b5*. Verification: (i) \u00b5*\u2208reach(\u00b50) by Lemma C; (ii) \u00b5* globally PO by Lemma B.\n\nCorrected XP algorithm by number of movers\n\nProposition E (XP in k). Let k be the number of movers (agents whose final object differs from initial). There is an XP algorithm running in O(n^k\u00b7k!\u00b7poly(n)) that decides TREE-REACHABLE-PE and outputs a witness when one exists.\nProof (outline). Enumerate S\u2286A with |S|\u2264k; for each S, enumerate permutations \u03c0 of H(S):={\u00b50(a): a\u2208S} onto S; define \u00b5 by \u00b5|_S(a)=\u03c0(a), \u00b5|_{A\\S}=\u00b50. For each connected component C of T[S], check \u00b5|_C\u2208reach(\u00b50|_C) by Lemma C on the induced subtree; if any component fails, discard \u03c0. If all pass, check global PO by Lemma B; the first passing \u00b5 is a witness. If none, answer \u201cnone.\u201d Reachability is local because outsiders remain fixed; disjoint components realize independently; PO is global (Lemma B). \u220e\n\nAcyclic merge at cut vertices\n\nSetup. Root T at an articulation vertex r (a cut). Removing r splits T into branches T_1,\u2026,T_m (each a path if r is the only high-degree vertex). For a given allocation \u00b5, let D(\u00b5) be its improvement digraph. For a set X, write D[ X ] for the subgraph induced by vertices X.\n\nLemma F (Cycle localization at r). If D(\u00b5) has a directed cycle C, then either (i) all vertices of C lie in {r}\u222aV(T_i)\u222aO(T_i) for some i (a single branch plus r), or (ii) the cycle passes through r and visits at least two distinct branches.\nProof. Any directed cycle alternates between agents and objects. In the tree, any path that departs a branch must pass through r to reach another branch. Since edges linking branches go through r (in the trading digraph these are arcs between r and objects/agents in branches), any cycle that includes vertices from different branches must include r. Otherwise the cycle is contained within a single branch plus possibly r. \u220e\n\nDefinition (Boundary summary at r for branch i). For branch T_i, define the boundary set B_i consisting of r (agent and object h_r), the unique neighbor u_i of r in T_i (agent and object h_{u_i}), and the set of objects and agents in T_i that may appear on a cycle involving r. For an allocation \u00b5, define the partial order P_i(\u00b5) on B_i as the transitive closure of reachability in D(\u00b5)[B_i], i.e., x\u227a_i y iff there is a directed path from x to y in D(\u00b5)[B_i]. Also record whether D(\u00b5)[V(T_i)\u222aO(T_i)] has an internal cycle.\n\nLemma G (Acyclic union via boundary orders). Suppose for each i, D(\u00b5)[V(T_i)\u222aO(T_i)] is acyclic and B_i-summaries P_i(\u00b5) are available. Then D(\u00b5) is acyclic iff the union partial order P:=\u22c3_i P_i(\u00b5) on the boundary vertices B:=\u22c3_i B_i is acyclic.\nProof. \u201cOnly if\u201d: Any directed cycle projects to a directed cycle in the boundary union. \u201cIf\u201d: By Lemma F, any cycle either lies within a branch (ruled out) or traverses r and thus corresponds to a directed cycle in the boundary union P. If P is acyclic, no such cycle exists. \u220e\n\nPolynomial-time algorithm for fixed number of leaves L\n\nTheorem H. On trees with at most L leaves (constant), TREE-REACHABLE-PE is solvable in time f(L)\u00b7poly(n).\n\nAlgorithm (outline).\n- Root at a vertex r of maximum degree; removing r leaves m\u2264L branches, each a simple path P_i.\n- Enumerate a finite family of boundary flow patterns F across r: for each branch P_i, the set of objects that end in P_i but originate outside P_i, and those that leave P_i to other branches, together with their cyclic order relative to r that would affect P_i\u2019s boundary summary (this family is bounded as a function of L, because each flow must traverse r and we only need relative orders among the O(L) boundary tokens).\n- For a fixed pattern F, solve each path P_i independently:\n  (a) Using the path subroutines (Algorithm 1 and its corollaries), compute the set of reachable allocations on P_i (with r treated as fixed boundary) that realize the prescribed local in-/out-flow and compute their boundary summary P_i(\u00b5). During this computation, prune any allocation whose local improvement digraph has a cycle.\n  (b) This is polynomial per branch because P_i is a path and the boundary is constant-size; the dynamic extends Algorithm 1 by conditioning on which few boundary tokens pass through the first vertex.\n- Combine branches by checking that the union P:=\u22c3_i P_i(\u00b5) is acyclic (Lemma G). If acyclic, we have assembled a globally PO allocation whose restriction to each P_i is reachable and consistent across r; construct a global allocation \u00b5 and verify \u00b5\u2208reach(\u00b50) by interleaving the per-branch reachability sequences with swaps at r.\n- If some pattern succeeds, output \u00b5; otherwise, answer \u201cnone.\u201d\n\nCorrectness. For any globally PO reachable allocation, its cross-branch flows across r determine a pattern F. For each branch, our path solver realizes the branch allocation and records an acyclicity summary; Lemma G ensures that the absence of a boundary cycle implies global PO. Reachability follows from concatenating path reachability sequences and swaps at r (standard in tree swap scheduling). Conversely, any allocation produced is reachable and globally PO by construction.\n\nComplexity. The number of patterns F is bounded by a function of L (at most partitioning O(L) boundary tokens among branches with cyclic order); per pattern, solving m paths costs poly(n); checking acyclicity of the combined boundary order is constant-time for fixed L. Hence f(L)\u00b7poly(n).\n\nObstacles\n\n- Full general trees. The difficulty is not the treewidth of T (which is 1) but tracking object identities across cuts; naive DP states must encode arbitrary subsets of objects, causing blowup. The bounded-leaves approach constrains the number of cross-branch flows to O(L), enabling a finite pattern enumeration.\n- Stars. While the final center object is order-independent (monotonic center improvements), uniqueness of the full terminal allocation remains unproven; we keep stars as \u201cunder investigation\u201d until we settle order-independence for all leaves.\n- Hardness attempts. A reduction from Reachable Object on trees would require an \u201calarm gadget\u201d (a constant-size tree attached at a cut) whose improvement digraph is cyclic unless a designated external agent-object pair is matched. Designing and verifying such a gadget (insulated from outside by preferences) is promising but not yet complete.\n\nNext steps\n\n- Formalize the per-branch (path) solver under boundary constraints: specify precisely the boundary tokens and how Algorithm 1 extends to enforce fixed in-/out-flow and to produce the boundary partial order P_i(\u00b5).\n- Implement and test Theorem H for small L (e.g., L\u22643) via exhaustive enumeration to validate boundary summaries and global merge.\n- Extend the XP-by-k to a combined-parameter FPT by (k + number of branch vertices): in trees with few high-degree vertices, cross-branch flows are sparse; a DP over the branch-vertex skeleton with state size exponential in k may be feasible.\n- Continue designing a small \u201calarm gadget\u201d for hardness: propose a 5\u20137 vertex gadget with internal preferences ensuring any non-designated match induces a directed improvement cycle confined to the gadget.\n\nSummary of claims to record\n\n- XP algorithm in O(n^k\u00b7k!\u00b7poly(n)) for k movers (correcting previous FPT misclassification).\n- Cut-based Lemmas F and G for composing PO across an articulation vertex.\n- FPT algorithm (Theorem H) parameterized by number of leaves L, using per-branch path solvers and acyclicity summaries at the center.\n- Keep safe primitives (Lemmas A\u2013C; Theorem D) in proofs as they are used as building blocks across procedures. "
}