Ideas

- Corrected parameterization: The “number of movers k” enumeration yields an XP algorithm, not FPT. Time O(n^k·k!·poly(n)); we correct that classification and make it a baseline solver for small k.
- New parameter and special case: number of leaves L. For trees with a constant number of leaves, we propose a decomposition-based procedure that is polynomial for fixed L. This yields an FPT algorithm parameterized by L (time f(L)·poly(n)). The path techniques (Algorithm 1, Section 3 of the paper) will be used on each branch.
- Cut-decomposition lemma for PO: For a tree cut at an articulation vertex r (a center), any directed improvement cycle in the global trading digraph either lies completely within a branch, or uses r and edges to enter/leave branches. This allows us to summarize each branch by a boundary relation at r and to check global PO by combining acyclicity summaries.

Examples

- Sink special case (record): On path A–B–C with initial (A:a,B:b,C:c) and preferences A: c≻a≻b, B: b≻a≻c, C: a≻c≻b, no swap applies. Then reach(µ0)={µ0}. A single PO test (improvement-digraph acyclicity) shows µ0 is not globally PO, hence TREE-REACHABLE-PE answers “none.”
- XP-by-k sanity: If k=1, we enumerate S of size ≤1 and test the O(1) permutations; each test uses (i) componentwise reachability (Lemma 3) and (ii) global PO (Lemma 2). This is immediate, and extends to general k with O(n^k·k!).

Rigorous lemmas and corrected statements

Lemma A (Reachable ⇒ IR). Any allocation µ ∈ reach(µ0) is individually rational: every agent weakly prefers µ(a) to µ0(a).
Proof. Each allowed swap strictly improves its endpoints, others unchanged. For each agent a, the sequence of objects they hold is strictly increasing in ≻_a across their swaps, hence µ(a) ≽_a µ0(a). ∎

Lemma B (PO test in O(n^2)). For a given allocation µ, form the improvement digraph D(µ) with vertices A∪O, arcs a→b for b≻_a µ(a), and b→ownerµ(b). Then µ is globally Pareto-efficient iff D(µ) is acyclic.
Sketch. A directed cycle prescribes a strict Pareto improvement; conversely any strict Pareto improvement yields such a cycle. Standard. ∎

Lemma C (Tree target reachability in O(n^2)). Given tree T, initial µ0 and target µ*, deciding µ*∈reach(µ0) and producing a swap sequence is doable in O(n^2) by the “good-edge” scheduler.
Proof sketch. Each agent moves along its unique dipath from µ0(a) to µ*(a). An edge is good if both incident agents must cross it next; if current≠target and target is reachable, some good edge exists (as in GLW). Repeatedly swap across any good edge; update in O(1); O(n^2) swaps in total. ∎

Theorem D (NP membership). TREE-REACHABLE-PE ∈ NP: a certificate is a target allocation µ*. Verification: (i) µ*∈reach(µ0) by Lemma C; (ii) µ* globally PO by Lemma B.

Corrected XP algorithm by number of movers

Proposition E (XP in k). Let k be the number of movers (agents whose final object differs from initial). There is an XP algorithm running in O(n^k·k!·poly(n)) that decides TREE-REACHABLE-PE and outputs a witness when one exists.
Proof (outline). Enumerate S⊆A with |S|≤k; for each S, enumerate permutations π of H(S):={µ0(a): a∈S} onto S; define µ by µ|_S(a)=π(a), µ|_{A\S}=µ0. For each connected component C of T[S], check µ|_C∈reach(µ0|_C) by Lemma C on the induced subtree; if any component fails, discard π. If all pass, check global PO by Lemma B; the first passing µ is a witness. If none, answer “none.” Reachability is local because outsiders remain fixed; disjoint components realize independently; PO is global (Lemma B). ∎

Acyclic merge at cut vertices

Setup. Root T at an articulation vertex r (a cut). Removing r splits T into branches T_1,…,T_m (each a path if r is the only high-degree vertex). For a given allocation µ, let D(µ) be its improvement digraph. For a set X, write D[ X ] for the subgraph induced by vertices X.

Lemma F (Cycle localization at r). If D(µ) has a directed cycle C, then either (i) all vertices of C lie in {r}∪V(T_i)∪O(T_i) for some i (a single branch plus r), or (ii) the cycle passes through r and visits at least two distinct branches.
Proof. Any directed cycle alternates between agents and objects. In the tree, any path that departs a branch must pass through r to reach another branch. Since edges linking branches go through r (in the trading digraph these are arcs between r and objects/agents in branches), any cycle that includes vertices from different branches must include r. Otherwise the cycle is contained within a single branch plus possibly r. ∎

Definition (Boundary summary at r for branch i). For branch T_i, define the boundary set B_i consisting of r (agent and object h_r), the unique neighbor u_i of r in T_i (agent and object h_{u_i}), and the set of objects and agents in T_i that may appear on a cycle involving r. For an allocation µ, define the partial order P_i(µ) on B_i as the transitive closure of reachability in D(µ)[B_i], i.e., x≺_i y iff there is a directed path from x to y in D(µ)[B_i]. Also record whether D(µ)[V(T_i)∪O(T_i)] has an internal cycle.

Lemma G (Acyclic union via boundary orders). Suppose for each i, D(µ)[V(T_i)∪O(T_i)] is acyclic and B_i-summaries P_i(µ) are available. Then D(µ) is acyclic iff the union partial order P:=⋃_i P_i(µ) on the boundary vertices B:=⋃_i B_i is acyclic.
Proof. “Only if”: Any directed cycle projects to a directed cycle in the boundary union. “If”: By Lemma F, any cycle either lies within a branch (ruled out) or traverses r and thus corresponds to a directed cycle in the boundary union P. If P is acyclic, no such cycle exists. ∎

Polynomial-time algorithm for fixed number of leaves L

Theorem H. On trees with at most L leaves (constant), TREE-REACHABLE-PE is solvable in time f(L)·poly(n).

Algorithm (outline).
- Root at a vertex r of maximum degree; removing r leaves m≤L branches, each a simple path P_i.
- Enumerate a finite family of boundary flow patterns F across r: for each branch P_i, the set of objects that end in P_i but originate outside P_i, and those that leave P_i to other branches, together with their cyclic order relative to r that would affect P_i’s boundary summary (this family is bounded as a function of L, because each flow must traverse r and we only need relative orders among the O(L) boundary tokens).
- For a fixed pattern F, solve each path P_i independently:
  (a) Using the path subroutines (Algorithm 1 and its corollaries), compute the set of reachable allocations on P_i (with r treated as fixed boundary) that realize the prescribed local in-/out-flow and compute their boundary summary P_i(µ). During this computation, prune any allocation whose local improvement digraph has a cycle.
  (b) This is polynomial per branch because P_i is a path and the boundary is constant-size; the dynamic extends Algorithm 1 by conditioning on which few boundary tokens pass through the first vertex.
- Combine branches by checking that the union P:=⋃_i P_i(µ) is acyclic (Lemma G). If acyclic, we have assembled a globally PO allocation whose restriction to each P_i is reachable and consistent across r; construct a global allocation µ and verify µ∈reach(µ0) by interleaving the per-branch reachability sequences with swaps at r.
- If some pattern succeeds, output µ; otherwise, answer “none.”

Correctness. For any globally PO reachable allocation, its cross-branch flows across r determine a pattern F. For each branch, our path solver realizes the branch allocation and records an acyclicity summary; Lemma G ensures that the absence of a boundary cycle implies global PO. Reachability follows from concatenating path reachability sequences and swaps at r (standard in tree swap scheduling). Conversely, any allocation produced is reachable and globally PO by construction.

Complexity. The number of patterns F is bounded by a function of L (at most partitioning O(L) boundary tokens among branches with cyclic order); per pattern, solving m paths costs poly(n); checking acyclicity of the combined boundary order is constant-time for fixed L. Hence f(L)·poly(n).

Obstacles

- Full general trees. The difficulty is not the treewidth of T (which is 1) but tracking object identities across cuts; naive DP states must encode arbitrary subsets of objects, causing blowup. The bounded-leaves approach constrains the number of cross-branch flows to O(L), enabling a finite pattern enumeration.
- Stars. While the final center object is order-independent (monotonic center improvements), uniqueness of the full terminal allocation remains unproven; we keep stars as “under investigation” until we settle order-independence for all leaves.
- Hardness attempts. A reduction from Reachable Object on trees would require an “alarm gadget” (a constant-size tree attached at a cut) whose improvement digraph is cyclic unless a designated external agent-object pair is matched. Designing and verifying such a gadget (insulated from outside by preferences) is promising but not yet complete.

Next steps

- Formalize the per-branch (path) solver under boundary constraints: specify precisely the boundary tokens and how Algorithm 1 extends to enforce fixed in-/out-flow and to produce the boundary partial order P_i(µ).
- Implement and test Theorem H for small L (e.g., L≤3) via exhaustive enumeration to validate boundary summaries and global merge.
- Extend the XP-by-k to a combined-parameter FPT by (k + number of branch vertices): in trees with few high-degree vertices, cross-branch flows are sparse; a DP over the branch-vertex skeleton with state size exponential in k may be feasible.
- Continue designing a small “alarm gadget” for hardness: propose a 5–7 vertex gadget with internal preferences ensuring any non-designated match induces a directed improvement cycle confined to the gadget.

Summary of claims to record

- XP algorithm in O(n^k·k!·poly(n)) for k movers (correcting previous FPT misclassification).
- Cut-based Lemmas F and G for composing PO across an articulation vertex.
- FPT algorithm (Theorem H) parameterized by number of leaves L, using per-branch path solvers and acyclicity summaries at the center.
- Keep safe primitives (Lemmas A–C; Theorem D) in proofs as they are used as building blocks across procedures. 