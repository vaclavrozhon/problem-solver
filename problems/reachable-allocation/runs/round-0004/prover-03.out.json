{
  "content": "Ideas\n- Correct and strengthen the star analysis. We prove two structural lemmas on stars: (i) center-object monotonicity; (ii) each leaf swaps at most once. We then refute the previous uniqueness claim by exhibiting a concrete counterexample with two distinct terminal allocations (sinks) having the same final center object. We keep the \u201ccompute one terminal sink and test global PO\u201d as a valid poly-time sufficient certificate, but uniqueness of the terminal allocation is false.\n- Consolidate standard verifiers: target reachability on trees (good-edge scheduler) and global PO (improvement digraph acyclicity) as formal building blocks for NP membership.\n\nRigorous lemmas (stars)\nSetup: Star with center vertex c and leaves L. Agents are fixed on vertices; objects move by swaps on edges {c,\u2113}. Center\u2019s strict preference order over objects: \u227b_c. For a leaf \u2113 with endowment h_\u2113, define acceptance set T_\u2113 = {x : x \u227b_\u2113 h_\u2113}. A swap at state (center holds x, leaf \u2113 holds h_\u2113) is allowed iff h_\u2113 \u227b_c x and x \u2208 T_\u2113.\n\nLemma 1 (center monotonicity). Along any allowed swap sequence, the center\u2019s held object strictly increases in \u227b_c.\nProof. If center holds x and swaps with leaf \u2113, then h_\u2113 \u227b_c x by the swap condition. Hence the new center object is strictly higher in \u227b_c. \u220e\n\nLemma 2 (leaf swaps at most once). Along any allowed swap sequence, each leaf \u2113 participates in at most one swap.\nProof. Suppose \u2113 swaps when the center holds x, so \u2113 receives x and center receives h_\u2113. Later, a second swap with \u2113 would require the center to prefer \u2113\u2019s current object (which is x) to its current center object, contradicting Lemma 1, as the center\u2019s object strictly increases and thus never returns below x. \u220e\n\nAcceptance digraph and the center\u2019s final object\nConstruct a directed graph on objects B: add arc x\u2192h_\u2113 iff x \u2208 T_\u2113 (leaf \u2113 accepts x). By Lemma 1, all swaps correspond to following arcs x\u2192h_\u2113 with h_\u2113 \u227b_c x (center moves monotonically up). Let Y be the set of objects reachable from the initial center object x_0 by directed paths that are strictly \u227b_c-monotone at each step. Y is finite and nonempty; let y\u22c6 be its \u227b_c-maximum.\nLemma 3. In any maximal (no further allowed swap) sequence, the center ends with y\u22c6; conversely, y\u22c6 is reachable by a sequence of allowed swaps.\nProof. Any swap corresponds to a graph arc x\u2192h_\u2113 with h_\u2113 \u227b_c x; thus any terminal center object y lies in Y and y \u227c_c y\u22c6. If y \u227a_c y\u22c6 then, by the path witnessing y\u22c6 from y, another allowed swap would exist, contradicting maximality. Conversely, following a witnessing \u227b_c-monotone path from x_0 to y\u22c6 yields a valid swap sequence (each target leaf still holds its endowment by Lemma 2 and the monotonicity), so y\u22c6 is reachable. \u220e\n\nCounterexample: non-uniqueness of terminal allocation on a star\nLet objects be {b,a,x0}, initial center object x0; two leaves \u21131 (endowment a), \u21132 (endowment b). Center: b \u227b_c a \u227b_c x0. Leaves: \u21131: x0 \u227b_\u21131 a \u227b_\u21131 b; \u21132: x0 \u227b_\u21132 a \u227b_\u21132 b. Then both sequences are valid:\n- Path 1: x0\u2192b (swap center with \u21132). Terminal: center b; leaves (\u21131:a, \u21132:x0).\n- Path 2: x0\u2192a\u2192b (swap with \u21131 then \u21132). Terminal: center b; leaves (\u21131:x0, \u21132:a).\nBoth are sinks (no allowed swap remains), yet differ on leaf allocations. Hence uniqueness of the terminal allocation is false, although the final center object y\u22c6=b is unique by Lemma 3.\n\nPoly-time certificate on stars (sufficient)\n- Compute Y and y\u22c6 in O(n^2): build arcs x\u2192h_\u2113 for all (x,\u2113) with x \u2208 T_\u2113; BFS/DFS from x_0 while only traversing arcs x\u2192x\u2032 with x\u2032 \u227b_c x. Record a parent to reconstruct one path to y\u22c6. Simulate swaps along this path to build a terminal allocation \u00b5_term. Then test \u00b5_term for global PO via the improvement-digraph acyclicity test (O(n^2)). If PO holds, output \u00b5_term; else inconclusive (other sinks may or may not be PO).\n\nGeneral verifiers (trees)\n- Fixed-target reachability in O(n^2) by the good-edge scheduler (unique dipaths; swap along good edges until the target is reached or a dead-end is certified). Produces a witness sequence if reachable.\n- Global PO test in O(n^2): improvement digraph (agent\u2192strictly better objects; object\u2192current owner); PO iff acyclic.\n- Hence TREE-REACHABLE-PE \u2208 NP: a certificate is a matching \u00b5; verify reachability and PO in poly-time.\n\nParameterization notes\n- Number of movers k (agents whose final object differs) yields an XP algorithm by enumerating agent subsets and permutations in time O(n^k\u00b7k!\u00b7poly(n)); a true FPT f(k)\u00b7poly(n) remains open.\n\nObstacles\n- On stars, although y\u22c6 is unique, the set of terminal allocations is not, and the existence of a globally PO sink cannot be decided by inspecting a single sink in general. A full polynomial characterization of PO among star sinks remains open.\n\nNext steps\n- Develop a DP on stars over the \u227b_c-monotone acceptance DAG to decide existence of a PO sink without enumerating all paths (state likely tracks a frontier summary sufficient for the improvement-digraph\u2019s cycle absence). Validate on small instances.\n- For trees, continue with a treewidth-based DP (states: partial injections on bags; root filters = reachability + PO). Add pruning by local no-swap constraints.\n"
}