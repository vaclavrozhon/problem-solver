{
  "content": "# Ideas\n\n- Provide rigorous XP-time algorithms and structural lemmas that can be checked now, while postponing global polynomial-time decidability on trees. Two incremental directions:\n  1) An XP algorithm parameterized by the number k of agents who end up with a different object than their initial one (movers). This is exact and verifiable: enumerate candidate final matchings with \u2264 k movers, and verify reachability and global PO in polytime.\n  2) Structural decomposition for double-stars (two centers joined by a bridge), with provable invariants about cross-bridge swaps. This sets up a bounded-search algorithm over bridge swaps with polynomial subroutines (local star closures + global PO check).\n\n# Lemmas and proofs\n\nLemma 1 (Reachable \u21d2 IR). In the tree model with strict preferences, any matching reachable from the initial endowment is individually rational (each agent weakly prefers her object to her initial endowment).\n\nProof. Each allowed swap strictly improves the two endpoints and leaves all others unchanged. Along a sequence, an agent\u2019s assignment only changes at her own swap and strictly improves. Hence relative to the initial endowment, no agent is worse off. \u220e\n\nLemma 2 (PO \u21d2 sink). If a matching \u00b5 admits an allowed swap on some edge, then \u00b5 is not globally Pareto-efficient. Thus any globally PO matching has no allowed swap (is a sink).\n\nProof. The allowed swap strictly improves both participants and leaves all others unchanged. The resulting matching Pareto-dominates \u00b5. \u220e\n\nLemma 3 (Global PO test in O(n^2)). For any matching \u00b5, build the improvement digraph G_\u00b5 on vertices A\u222aB with arcs a\u2192b for each b with b \u227b_a \u00b5(a), and arcs b\u2192a where a=\u00b5^{-1}(b). Then \u00b5 is globally PO iff G_\u00b5 has no directed cycle. Cycle detection takes O(n^2).\n\nProof. Standard Shapley\u2013Scarf improvement-digraph characterization. \u220e\n\nLemma 4 (Tree target-reachability in O(n^2)). Given initial matching \u00b50 and a target matching \u00b5 on a tree, we can decide in O(n^2) whether \u00b5 is reachable by allowed swaps and produce a sequence if yes.\n\nProof (sketch). As in Gourv\u00e8s\u2013Lesca\u2013Wilczynski, assign each agent its unique dipath from current to target object. An edge is good if both agents at its ends need to traverse it next. If \u00b5 is reachable and not current, there exists a good edge. Swapping on a good edge preserves goodness (except possibly two adjacent edges). Iterating reaches \u00b5 or halts when no good edge exists. Initialization and updates yield O(n^2) time. \u220e\n\nTheorem 5 (TREE-REACHABLE-PE \u2208 NP). Given (T, \u00b50, \u227b), a certificate is a target matching \u00b5*. Verification uses Lemma 3 (PO in O(n^2)) and Lemma 4 (reachability in O(n^2)). \u220e\n\nCorollary 6 (Search reduction). TREE-REACHABLE-PE is a YES-instance iff there exists a reachable sink that is globally PO.\n\n# XP algorithm parameterized by movers k\n\nDefinition. A mover is an agent whose final object differs from her initial one. Let k be an upper bound on the number of movers in a target solution.\n\nAlgorithm XP(k).\n- For s=0..k:\n  - Enumerate S \u2286 A with |S|=s (O(n^s) choices).\n  - Enumerate injective maps \u03c6: S \u2192 B \\ {h_a : a\u2208A\\S} (O(n^s) choices). Define candidate matching \u00b5_S by \u00b5_S(a)=\u03c6(a) for a\u2208S and \u00b5_S(a)=h_a for a\u2209S.\n  - For each \u00b5_S, run: (i) PO-test (Lemma 3); (ii) reachability test from \u00b50 (Lemma 4). If both pass, output the witness sequence to \u00b5_S.\n- If none pass, answer NO.\n\nCorrectness. By construction we enumerate all perfect matchings with \u2264 k movers. For any such \u00b5, PO-test accepts iff \u00b5 is globally PO; reachability accepts iff \u00b5 is reachable. Hence any solution with \u2264 k movers will be found.\n\nRunning time. Sum_{s=0}^k C(n,s)\u00b7P(n,s) = \u0398(\u2211_{s=0}^k n^{2s}/s!) = n^{O(k)}. Each candidate check is O(n^2). Thus time is n^{O(k)}\u00b7poly(n), i.e., XP in k.\n\nRemark. This is not FPT (unless improved), but gives a slice-wise polynomial bound for small k and provides a verifiable baseline.\n\n# Double-star structure and bridge-swap bounds\n\nModel. A double-star is a tree consisting of two centers u and v connected by a bridge edge {u,v}, with leaves adjacent only to u or to v.\n\nLemma 7 (Bridge swaps are center\u2013center only). In a double-star, any swap across the bridge edge {u,v} can only involve agents located at u and v.\n\nProof. Only adjacent agents may swap, and the only pair of adjacent vertices across the two sides is {u,v}. \u220e\n\nLemma 8 (Bound on cross-bridge swaps). Each center participates in at most n\u22121 swaps along any sequence (including leaf swaps and cross-bridge swaps). Consequently, the total number of cross-bridge swaps is O(n).\n\nProof. Each time a center agent swaps (with a leaf or with the other center), she strictly improves her held object (strict preferences). An agent can strictly improve at most n\u22121 times. Cross-bridge swaps are a subset of swaps involving centers, hence O(n). \u220e\n\nClosure operator (local star saturation). Fix a center x\u2208{u,v} and a current center object b_x. Consider only swaps along edges incident to x (center\u2013leaf swaps on that side), holding the other side frozen. Define Saturate(x,b_x) as any maximal sequence of allowed center\u2013leaf swaps on x\u2019s side, until no such swap remains.\n\nObservation 9. Saturate(x,b_x) runs in O(n^2) time (at most O(n) swaps, each identified in O(n)). It yields a local sink on that side given the current b_x.\n\nCaveat. Different local swap orders may lead to different local terminal states; we do not claim uniqueness. However, any such terminal state is a local sink (no center\u2013leaf swap available with b_x fixed at that moment).\n\nSearch scheme for double-stars (bounded by Lemma 8).\n- Enumerate a sequence \u03c3 of cross-bridge swaps of length t \u2264 O(n). A sequence is specified by the times when {u,v} swaps are applied (interleaved with local saturations) and the direction is always u\u2194v.\n- Start from (b_u^0, b_v^0) = (\u00b50(u), \u00b50(v)). For i=1..t:\n  - Compute local sinks by iteratively applying Saturate(u, b_u^{i-1}) and Saturate(v, b_v^{i-1}) (in any order), until neither side has an allowed center\u2013leaf swap.\n  - If at that point both u and v strictly prefer each other\u2019s objects, perform the i-th cross-bridge swap to obtain (b_u^i, b_v^i); otherwise abort this \u03c3 (infeasible).\n- After t cross swaps, perform one final local saturation on both sides to obtain a global sink \u00b5_\u03c3.\n- PO-test \u00b5_\u03c3 (Lemma 3); if PO and \u00b5_\u03c3 is reachable (optionally verified by Lemma 4), output it.\n\nRemarks.\n- Termination and boundedness follow from Lemma 8.\n- Completeness of this scheme is open because local star saturation might depend on the local swap order, which could affect availability of the next cross-bridge swap. The scheme is thus a heuristic unless we further constrain/branch on local saturation outcomes.\n- Nevertheless, \u03c3 ranges over at most exponential (in O(n)) possibilities, but one can prune sequences infeasible early; combined with polynomial local procedures, this provides a concrete, testable bounded-search algorithm for double-stars.\n\n# Examples\n\nExample (NO on path/star). Path A\u2013B\u2013C with initial (A:a,B:b,C:c), preferences A: b \u227b a \u227b c; B: c \u227b b \u227b a; C: a \u227b c \u227b b. No adjacent swap applies initially; yet (A:b,B:c,C:a) strictly Pareto-dominates the initial matching. Thus no reachable globally PO matching exists.\n\n# Obstacles\n\n- Enumeration of all reachable sinks on trees appears exponential; the simple greedy closure can reach a non-PO sink even when a PO sink is reachable.\n- For double-stars, local-star confluence (uniqueness of local closure) is unproven. Without confluence, the cross-bridge search may need to branch on local closure outcomes, complicating complexity.\n- Treewidth does not help directly: all trees have treewidth 1, but the state must encode global object-usage/permutation information, so a straightforward bag-DP does not yield a polytime algorithm.\n\n# Next steps\n\n1) Strengthen double-star: Prove a confluence property for local star saturation with a fixed center object (uniqueness of the terminal center object or a dominance lattice), or else introduce controlled branching on local outcomes with polynomially many branches per cross step.\n2) Parameterized refinement: Combine \u201cnumber of movers k\u201d with \u201cnumber of branch vertices b\u201d to obtain FPT in (k+b) via a decomposition that confines movers to a bounded region; formalize and bound the state space.\n3) TTC-reachability region: Characterize when TTC is reachable on trees (local necessary and sufficient conditions on edges), to enlarge the polynomially decidable YES region.\n4) Small-instance enumeration (n\u22646): Count reachable sinks and PO status on random trees to test the double-star scheme, validate confluence hypotheses, and guide structural lemmas.\n\n# What to add to proofs.md now\n\n- Lemmas 1\u20134 with proofs (IR, PO\u21d2sink, PO test, tree target-reachability) and Theorem 5 (NP membership).\n- XP(k) algorithm with correctness and n^{O(k)} bound.\n- Lemmas 7\u20138 (bridge structure and O(n) cross-bridge swaps) for double-stars, plus Observation 9 and the bounded-search scheme outline (clearly marked as partial with a confluence caveat).\n"
}