# Ideas

- Provide rigorous XP-time algorithms and structural lemmas that can be checked now, while postponing global polynomial-time decidability on trees. Two incremental directions:
  1) An XP algorithm parameterized by the number k of agents who end up with a different object than their initial one (movers). This is exact and verifiable: enumerate candidate final matchings with ≤ k movers, and verify reachability and global PO in polytime.
  2) Structural decomposition for double-stars (two centers joined by a bridge), with provable invariants about cross-bridge swaps. This sets up a bounded-search algorithm over bridge swaps with polynomial subroutines (local star closures + global PO check).

# Lemmas and proofs

Lemma 1 (Reachable ⇒ IR). In the tree model with strict preferences, any matching reachable from the initial endowment is individually rational (each agent weakly prefers her object to her initial endowment).

Proof. Each allowed swap strictly improves the two endpoints and leaves all others unchanged. Along a sequence, an agent’s assignment only changes at her own swap and strictly improves. Hence relative to the initial endowment, no agent is worse off. ∎

Lemma 2 (PO ⇒ sink). If a matching µ admits an allowed swap on some edge, then µ is not globally Pareto-efficient. Thus any globally PO matching has no allowed swap (is a sink).

Proof. The allowed swap strictly improves both participants and leaves all others unchanged. The resulting matching Pareto-dominates µ. ∎

Lemma 3 (Global PO test in O(n^2)). For any matching µ, build the improvement digraph G_µ on vertices A∪B with arcs a→b for each b with b ≻_a µ(a), and arcs b→a where a=µ^{-1}(b). Then µ is globally PO iff G_µ has no directed cycle. Cycle detection takes O(n^2).

Proof. Standard Shapley–Scarf improvement-digraph characterization. ∎

Lemma 4 (Tree target-reachability in O(n^2)). Given initial matching µ0 and a target matching µ on a tree, we can decide in O(n^2) whether µ is reachable by allowed swaps and produce a sequence if yes.

Proof (sketch). As in Gourvès–Lesca–Wilczynski, assign each agent its unique dipath from current to target object. An edge is good if both agents at its ends need to traverse it next. If µ is reachable and not current, there exists a good edge. Swapping on a good edge preserves goodness (except possibly two adjacent edges). Iterating reaches µ or halts when no good edge exists. Initialization and updates yield O(n^2) time. ∎

Theorem 5 (TREE-REACHABLE-PE ∈ NP). Given (T, µ0, ≻), a certificate is a target matching µ*. Verification uses Lemma 3 (PO in O(n^2)) and Lemma 4 (reachability in O(n^2)). ∎

Corollary 6 (Search reduction). TREE-REACHABLE-PE is a YES-instance iff there exists a reachable sink that is globally PO.

# XP algorithm parameterized by movers k

Definition. A mover is an agent whose final object differs from her initial one. Let k be an upper bound on the number of movers in a target solution.

Algorithm XP(k).
- For s=0..k:
  - Enumerate S ⊆ A with |S|=s (O(n^s) choices).
  - Enumerate injective maps φ: S → B \ {h_a : a∈A\S} (O(n^s) choices). Define candidate matching µ_S by µ_S(a)=φ(a) for a∈S and µ_S(a)=h_a for a∉S.
  - For each µ_S, run: (i) PO-test (Lemma 3); (ii) reachability test from µ0 (Lemma 4). If both pass, output the witness sequence to µ_S.
- If none pass, answer NO.

Correctness. By construction we enumerate all perfect matchings with ≤ k movers. For any such µ, PO-test accepts iff µ is globally PO; reachability accepts iff µ is reachable. Hence any solution with ≤ k movers will be found.

Running time. Sum_{s=0}^k C(n,s)·P(n,s) = Θ(∑_{s=0}^k n^{2s}/s!) = n^{O(k)}. Each candidate check is O(n^2). Thus time is n^{O(k)}·poly(n), i.e., XP in k.

Remark. This is not FPT (unless improved), but gives a slice-wise polynomial bound for small k and provides a verifiable baseline.

# Double-star structure and bridge-swap bounds

Model. A double-star is a tree consisting of two centers u and v connected by a bridge edge {u,v}, with leaves adjacent only to u or to v.

Lemma 7 (Bridge swaps are center–center only). In a double-star, any swap across the bridge edge {u,v} can only involve agents located at u and v.

Proof. Only adjacent agents may swap, and the only pair of adjacent vertices across the two sides is {u,v}. ∎

Lemma 8 (Bound on cross-bridge swaps). Each center participates in at most n−1 swaps along any sequence (including leaf swaps and cross-bridge swaps). Consequently, the total number of cross-bridge swaps is O(n).

Proof. Each time a center agent swaps (with a leaf or with the other center), she strictly improves her held object (strict preferences). An agent can strictly improve at most n−1 times. Cross-bridge swaps are a subset of swaps involving centers, hence O(n). ∎

Closure operator (local star saturation). Fix a center x∈{u,v} and a current center object b_x. Consider only swaps along edges incident to x (center–leaf swaps on that side), holding the other side frozen. Define Saturate(x,b_x) as any maximal sequence of allowed center–leaf swaps on x’s side, until no such swap remains.

Observation 9. Saturate(x,b_x) runs in O(n^2) time (at most O(n) swaps, each identified in O(n)). It yields a local sink on that side given the current b_x.

Caveat. Different local swap orders may lead to different local terminal states; we do not claim uniqueness. However, any such terminal state is a local sink (no center–leaf swap available with b_x fixed at that moment).

Search scheme for double-stars (bounded by Lemma 8).
- Enumerate a sequence σ of cross-bridge swaps of length t ≤ O(n). A sequence is specified by the times when {u,v} swaps are applied (interleaved with local saturations) and the direction is always u↔v.
- Start from (b_u^0, b_v^0) = (µ0(u), µ0(v)). For i=1..t:
  - Compute local sinks by iteratively applying Saturate(u, b_u^{i-1}) and Saturate(v, b_v^{i-1}) (in any order), until neither side has an allowed center–leaf swap.
  - If at that point both u and v strictly prefer each other’s objects, perform the i-th cross-bridge swap to obtain (b_u^i, b_v^i); otherwise abort this σ (infeasible).
- After t cross swaps, perform one final local saturation on both sides to obtain a global sink µ_σ.
- PO-test µ_σ (Lemma 3); if PO and µ_σ is reachable (optionally verified by Lemma 4), output it.

Remarks.
- Termination and boundedness follow from Lemma 8.
- Completeness of this scheme is open because local star saturation might depend on the local swap order, which could affect availability of the next cross-bridge swap. The scheme is thus a heuristic unless we further constrain/branch on local saturation outcomes.
- Nevertheless, σ ranges over at most exponential (in O(n)) possibilities, but one can prune sequences infeasible early; combined with polynomial local procedures, this provides a concrete, testable bounded-search algorithm for double-stars.

# Examples

Example (NO on path/star). Path A–B–C with initial (A:a,B:b,C:c), preferences A: b ≻ a ≻ c; B: c ≻ b ≻ a; C: a ≻ c ≻ b. No adjacent swap applies initially; yet (A:b,B:c,C:a) strictly Pareto-dominates the initial matching. Thus no reachable globally PO matching exists.

# Obstacles

- Enumeration of all reachable sinks on trees appears exponential; the simple greedy closure can reach a non-PO sink even when a PO sink is reachable.
- For double-stars, local-star confluence (uniqueness of local closure) is unproven. Without confluence, the cross-bridge search may need to branch on local closure outcomes, complicating complexity.
- Treewidth does not help directly: all trees have treewidth 1, but the state must encode global object-usage/permutation information, so a straightforward bag-DP does not yield a polytime algorithm.

# Next steps

1) Strengthen double-star: Prove a confluence property for local star saturation with a fixed center object (uniqueness of the terminal center object or a dominance lattice), or else introduce controlled branching on local outcomes with polynomially many branches per cross step.
2) Parameterized refinement: Combine “number of movers k” with “number of branch vertices b” to obtain FPT in (k+b) via a decomposition that confines movers to a bounded region; formalize and bound the state space.
3) TTC-reachability region: Characterize when TTC is reachable on trees (local necessary and sufficient conditions on edges), to enlarge the polynomially decidable YES region.
4) Small-instance enumeration (n≤6): Count reachable sinks and PO status on random trees to test the double-star scheme, validate confluence hypotheses, and guide structural lemmas.

# What to add to proofs.md now

- Lemmas 1–4 with proofs (IR, PO⇒sink, PO test, tree target-reachability) and Theorem 5 (NP membership).
- XP(k) algorithm with correctness and n^{O(k)} bound.
- Lemmas 7–8 (bridge structure and O(n) cross-bridge swaps) for double-stars, plus Observation 9 and the bounded-search scheme outline (clearly marked as partial with a confluence caveat).
