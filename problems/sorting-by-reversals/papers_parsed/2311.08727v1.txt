
--- Page 1 ---
The Hierarchy of Hereditary Sorting Operators
Vít Jelínek∗1, Michal Opler†2, and Jakub Pekárek1
1Charles University, Czechia
2Czech Technical University in Prague, Czechia
Abstract
We consider the following general model of a sorting procedure: we fix a
hereditary permutation class C, which corresponds to the operations that the
procedure is allowed to perform in a single step. The input of sorting is a
permutation π of the set rns “ t1, 2, . . . , nu, i.e., a sequence where each element
of rns appears once. In every step, the sorting procedure picks a permutation
σ of length n from C, and rearranges the current permutation of numbers by
composing it with σ. The goal is to transform the input π into the sorted
sequence 1, 2, . . . , n in as few steps as possible.
Formally, for a hereditary permutation class C and a permutation π of rns,
we say that C can sort π in k steps, if the inverse of π can be obtained by
composing k (not necessarily distinct) permutations from C. The C-sorting time
of π, denoted stpC; πq, is the smallest k such that C can sort π in k steps; if no
such k exists, we put stpC; πq “ `8. For an integer n, the worst-case C-sorting
time, denoted wstpC; nq, is the maximum of stpC; πq over all permutations π of
rns.
This model of sorting captures not only classical sorting algorithms, like
insertion sort or bubble sort, but also sorting by series of devices, like stacks or
parallel queues, as well as sorting by block operations commonly considered,
e.g., in the context of genome rearrangement.
Our goal is to describe the possible asymptotic behavior of the function
wstpC; nq, and relate it to structural properties of C. As the main result, we
show that any hereditary permutation class C falls into one of the following
five categories:
• wstpC; nq “ `8 for n large enough,
• wstpC; nq “ Θpn2q,
• Ωp?nq ď wstpC; nq ď Opnq,
• Ωplog nq ď wstpC; nq ď Oplog2 nq, or
• wstpC; nq “ 1 for all n ě 2.
In addition, we characterize the permutation classes in each of the five
categories.
∗Supported by the Czech Science Foundation under the grant agreement no. 23-04949X.
†Supported by the Czech Science Foundation Grant no. 22-19557S.
1
arXiv:2311.08727v1  [math.CO]  15 Nov 2023

--- Page 2 ---
1
Introduction
Sorting is, needless to stress, a central concept in computer science. The aim of
this paper is to study a general way to formalize the notion of sorting, based upon
the concept of hereditary permutation classes. In this approach, we fix a hereditary
class C of permutations, which corresponds to the operations that we are allowed to
perform in a single step of sorting. Given an input sequence of n distinct values, itself
viewed as a permutation, we aim to sort it into an increasing sequence by a sequence
of steps, where in each step we compose the current sequence with an element of C.
The goal is to minimize the number of steps for a given input, and to determine the
worst-case number of steps C needs on inputs of size n. This last quantity, which we
call the worst-case sorting time of the class C, is the main focus of this paper.
Our formalism is general enough to encompass standard sorting procedures, like
sorting by adjacent transpositions (“bubble-sort”) or sorting by insertions (“insertion
sort”), as well as parallel procedures like Habermann’s “parallel neighbor sort” [21]
(a.k.a. “odd-even sort”), which allows performing any number of adjacent swaps in a
single step.
Our formalism also models sorting procedures which are described via operations
not on single elements, but on blocks of consecutive elements, e.g. block reversals
or block transpositions. Such block-based sorting occurs, e.g., in the well-known
toy problem known as “pancake sorting” [11, 19], where the goal is to sort the input
by a sequence of prefix reversals. Block operations are also the backbone of the
sorting procedures studied in the context of genome rearrangement research (see,
e.g., [7, 14, 22, 24], or the surveys in [9, 18]).
Finally, we point out that our sorting formalism is closely related to the concept
of sorting networks, an approach which dates back to the works of Knuth [25] and
Tarjan [27] in late 1960s and early 1970s, respectively. A sorting network is an
acyclic directed graph whose every vertex represents a “sorting device” (e.g., a stack,
a queue, a double-ended queue, or a more general “C-container” considered by Albert
et al. [3]). An input sequence enters into the network from a designated source, its
elements can move along the edges and be rearranged by the devices at the vertices,
with the goal that the elements reach a designated sink in ascending order. Since
the action of most sorting devices considered in the literature can be modelled by a
hereditary permutation classes, our sorting formalism can be seen as a serial sorting
network (i.e., the network is a path) in which all the devices are of the same type.
The topic of sorting networks continues to be a major focus of research [10, 12, 13,
17], but we note that most of its previous results address the question of how many
permutations can be sorted by a given fixed network and what these permutations
look like, while our own focus is on finding the shortest serial network that sorts
every permutation of a given length. Additionally, some authors consider sorting
networks where the operation of the devices is restricted by the properties of the
input sequence, e.g., by assuming that a stack may only hold a monotone sequence
of values. These restricted devices no longer fit into our own formalism.
The aim of our paper is neither to improve the analysis of any specific sorting
algorithm, nor to propose a new specific algorithm; instead, our goal is to answer the
general question of which functions can occur as worst-case sorting times of hereditary
2

--- Page 3 ---
permutation classes. Accordingly, we disregard constant multiplicative factors and
focus on asymptotic behavior. Our results show that at this level of detail, the
possible sorting times can be classified into a hierarchy with gaps between individual
levels. Disregarding trivial extreme cases, a worst-case sorting time of a hereditary
class is either Θpn2q, or a function between Opnq and Ωp?nq, or Oplog2 nq, and for
each of these cases we can provide a structural characterization of the corresponding
hereditary classes.
We remark that the assumption of heredity is substantial in our setting. If
we were to consider sorting with an arbitrary set of generators, the sorting-time
problem would be essentially reduced to the problem of determining the diameter of
a Cayley graph in the symmetric group. This is a well-known group-theoretic open
problem, with a conjecture of Babai and Seress [6] stating that the diameter is at
most polynomial.
Let us now introduce the necessary definitions to state our results properly.
Notation, terminology, and the main result
A permutation of size n is a sequence π “ pπp1q, πp2q, . . . , πpnqq in which each
number from the set rns “ t1, 2, . . . , nu appears exactly once. We let Sn be the set
of permutations of size n, Sďn the set of permutations of size at most n, and S the
set Ť
ně1 Sn. We say that a permutation π P Sn contains a permutation σ P Sk if π
contains a subsequence of length k whose elements are in the same relative order as
the elements of σ, or more formally, if there are indices 1 ď i1 ă i2 ă ¨ ¨ ¨ ă ik ď n
such that πpiaq ă πpibq ðñ σpaq ă σpbq for every a, b P rks. If π does not contain
σ, we say it avoids σ.
A hereditary permutation class (or henceforth just class) is a set C Ď S such that
for every π P C and every σ contained in π, σ is also in C. For a permutation class C,
we let Cn denote the set C X Sn.
For a pair of permutations σ, π P Sn, their composition σ ˝ π is the permutation
pσpπp1qq, σpπp2qq, . . . , σpπpnqqq. For a pair of permutation classes A and B, we write
A ˝ B for tα ˝ β; α P A, β P Bu, A˝k for the k-fold composition A ˝ A ˝ ¨ ¨ ¨ ˝ A, and
A˚ for Ť
kě1 A˝k. Note that A ˝ B, A˝k and A˚ are again permutation classes.
The inverse of a permutation π P Sn is the permutation π´1 P Sn such that
π´1 ˝ π is the identity permutation p1, 2, . . . , nq.
Recall that the C-sorting time of π, denoted stpC; πq, is the smallest k such that
π´1 is in C˝k, or `8 if no such k exists. For an integer n, the worst-case C-sorting
time, denoted wstpC; nq, is the maximum of stpC; πq over all permutations π of rns.
We are now ready to recall the main result of this paper.
Theorem 1.1. Every permutation class C falls into one of the following five cate-
gories:
• wstpC; nq “ `8 for n large enough,
• wstpC; nq “ Θpn2q,
• Ωp?nq ď wstpC; nq ď Opnq,
3

--- Page 4 ---
• Ωplog nq ď wstpC; nq ď Oplog2 nq, or
• wstpC; nq “ 1 for all n ě 2.
The rest of this paper is devoted to the proof of this theorem. After we introduce
some more terminology and review some relevant facts about permutation classes
(Section 2), we will proceed by characterizing the classes with infinite sorting time in
Section 3. This is easily done, as it more or less directly follows from previous results
on composition-closed permutation classes. We then show, in Section 4, that if the
sorting time is finite, it is at most Opn2q. Next, in Section 5, we establish the gap
between quadratic and linear sorting times. Our main device is a numerical parameter
called reduced inversion number rinpπq, which we introduce. We show that a class
C has wstpC; nq “ Ωpn2q whenever rinp¨q is bounded on C, and wstpC; nq “ Opnq
otherwise.
The most difficult part of the proof appears in Section 6, where we show that
there are twelve (or four, after we account for symmetries) minimal classes with
sorting time Oplog2 nq, while any class that does not contain one of these twelve as
a subclass has sorting time Ωp?nq. The proof of this lower bound combines a new
structural result on classes avoiding the twelve ‘polylog’ subclasses, an argument
showing that sorting with such a class can be encoded into a specific graph which
has a drawing on a surface of not-too-large genus with not-too-many crossings, and a
bound on the tree-width of a graph that can be drawn on a surface of a given genus
with a given number of crossings.
The short Section 7 contains the proof that any class not containing all permuta-
tions has sorting time Ωplog nq. This is a straightforward counting argument using
the Marcus–Tardos theorem. We conclude in Section 8 with open problems, chief
of which is to close the gaps between Ωp?nq and Opnq, and between Ωplog nq and
Oplog2 nq implied by Theorem 1.1. In fact, for all the classes whose sorting time
we can establish asymptotically tightly, the sorting time is either `8, Θpn2q, Θpnq,
Θplog nq or 1.
2
Permutation classes
We let Avpπ1, π2, . . . , πmq denote the class of permutations that avoid all the per-
mutations π1, . . . , πm. We also use the special notation
for the class Avp21q of
all the increasing permutations, and
for the class Avp12q of all the decreasing
permutations. Let ιk denote the identity permutation p1, 2, . . . , kq, and let δk be the
decreasing permutation pk, k ´ 1, . . . , 1q.
It is often convenient to represent a permutation π P Sn by its diagram, which is
the point set Dpπq “ tpi, πpiq; i P rnsu.
Apart from the inverse π´1 introduced before, we will need several other operations
on a permutation π “ pπp1q, . . . , πpnqq. Its reverse, denoted πr, is the permutation
pπpnq, πpn´1q, . . . , πp1qq, its complement πc is the permutation pn`1´πp1q, n`1´
πp2q, . . . , n`1´πpnqq. Finally, the flip of π, denoted πf, is defined as πf “ ppπrq´1qr.
In terms of permutation diagrams, the reverse corresponds to reflection over a
vertical line, the complement corresponds to reflection over a horizontal line, the
4

--- Page 5 ---
inverse corresponds to reflection over the diagonal line y “ x, and flip corresponds
to reflection over the line y “ n ` 1 ´ x.
For a set of permutations C, we write Cr “ tπr; π P Cu, Cc “ tπc; π P Cu,
C´1 “ tπ´1; π P Cu and Cf “ tπf; π P Cu. Note that if C is a class, then so are Cr,
Cc, C´1 and Cf.
For a pair of permutations α P Sk and β P Sℓ, their direct sum α ‘ β is the
permutation pαp1q, αp2q, . . . , αpkq, k ` βp1q, k ` βp2q, . . . , k ` βpℓqq, and their skew
sum α a β is the permutation pℓ` αp1q, ℓ` αp2q, . . . , ℓ` αpkq, βp1q, βp2q, . . . , βpℓqq.
We let Àm α denote the direct sum α ‘ α ‘ ¨ ¨ ¨ ‘ α with m summands, and Ám α
is defined similarly. For a set of permutations C, its sum-closure À C is the set of all
the permutations that can be obtained as a direct sum of a finite number of (not
necessarily distinct) elements of C. Similarly, we define the skew-closure Á C. If C is
a class, then so are À C and Á C.
Before we proceed, let us collect several simple observations related to sorting
times of various classes.
Observation 2.1. For any two permutations σ and π of size n, we have pσ ˝ πq´1 “
π´1 ˝ σ´1 and pσ ˝ πqf “ πf ˝ σf.
Consequently, for any permutation class C
and any permutation τ, stpC; τq “ stpC´1; τ ´1q “ stpCf; τ fq, and in particular,
wstpC; nq “ wstpC´1; nq “ wstpCf; nq.
Observation 2.2. If A and B are permutation classes such that A Ď B˝k and π is
any permutation, then stpB; πq ď k ¨ stpA; πq, and hence wstpB; nq ď k ¨ wstpA; nq.
Observation 2.3. Let C be a class containing
as a subclass. Then Cr “ C˝
Ď C˝2,
and in particular, by Observation 2.2, wstpC; nq ď 2wstpCr; nq. Similarly, wstpC; nq ď
2wstpCc; nq.
Griddings and grid classes
We say that a set P of points in the plane is in general position if no two points of P
are on the same horizontal or vertical line. We say that two finite point sets P and
Q in general position are order-isomorphic, if there is a bijection from P to Q which
preserves both the left-to-right and the bottom-to-top order of the points. Note that
any finite set P of points in general position is order-isomorphic to a permutation
diagram of a unique permutation α; we than say that P induces a copy of α.
Let π P Sn be a permutation with a permutation diagram Dpπq. A k ˆ ℓgridding
of π is a set of k ` 1 vertical lines v0, v1, . . . , vk numbered left to right and ℓ` 1
horizontal lines h0, h1, . . . , hℓnumbered bottom to top, such that Dpπq is inside the
rectangle bounded by v0, vk, h0 and hℓ, and no point of Dpπq lies on any of the
k ` ℓlines of the gridding. For i P rks and j P rℓs, the cell pi, jq of the gridding,
denoted is the rectangle bounded by the lines vi´1, vi, hj´1 and hj. A permutation
together with its gridding is referred to as a gridded permutation. If π is a gridded
permutation and X a cell of its gridding, we let πrXs denote the set Dpπq X X, and
the permutation induced by this set is simply referred to as the subpermutation of π
induced by X.
A gridding matrix is a matrix M whose every entry is a permutation class; see
Figure 1 for an example. For consistency with the Cartesian coordinates we use for
5

--- Page 6 ---
Figure 1: Left: a 4 ˆ 3 gridding matrix M; by convention, we assume that the empty
cells represent the permutation class that only contains the empty permutation.
Right: an example of an M-gridded permutation, represented by its diagram.
permutation diagrams, we will assume that rows in a matrix are numbered bottom
to top, and we let Mi,j denote the entry in column i and row j of the matrix M.
Suppose M is a gridding matrix with k columns and ℓrows. An M-gridding of a
permutation π is a k ˆ ℓgridding with the property that for every pi, jq P rks ˆ rℓs,
the cell pi, jq of the gridding induces in π a permutation belonging to the class Mi,j.
The grid class determined by M, denoted GridpMq, is the set of those permutations
π that admit an M-gridding.
An important special case of grid classes are the so-called monotone juxtapositions,
whose gridding matrices have shape 2 ˆ 1 or 1 ˆ 2, and each of their two entries is
or
. In particular, there are eight monotone juxtapositions.
2.1
Some notable classes
We will now introduce several permutation classes that will play an important role
in our results. See Figure 2 for some examples and Table 1 for a complete list.
The class of layered permutations, denoted L, is the sum-closure of the class
.
Equivalently, it can be defined as Avp231, 312q. We remark that sorting by layered
permutations is equivalent by sorting with a series of so-called pop-stacks.
The Fibonacci class, denoted F, is the sum-closure of the set t1, 21u, or equiva-
lently the class of 321-avoiding layered permutations. Its name refers to the fact that
|Fn| is the n-th Fibonacci number. Sorting with the Fibonacci class F corresponds to
sorting where in each step we perform parallel transpositions of disjoint adjacent pairs
of elements. This includes, as a special case, an algorithm known as odd-even sort
(also known as parallel neighbor-sort), introduced and analyzed by Habermann [21],
who showed that the algorithm requires n rounds in the worst case. This implies
that wstpF; nq “ Opnq. This is asymptotically tight since, e.g., any permutation π
with πpnq “ 1 requires at least n ´ 1 F-steps to be sorted. Thus, wstpF; nq “ Θpnq.
The rotation class is the class R :“ tιa a ιb; a, b P N0u. Note that for ρ P Rn and
π P Sn, π ˝ ρ is a cyclic rotation of the sequence π. We will also consider the class
RR :“ R Y Rr, corresponding to rotations and their reversals. Both these classes
are composition closed, and in particular have infinite sorting time, as they cannot
sort any permutation that does not belong to the class.
The parallel block transposition class, denoted PBT , is the sum-closure of R. To
our knowledge, this class has not been considered before, but it emerges naturally in
6

--- Page 7 ---
Figure 2: From left to right: diagram of a layered permutation, diagram of a
permutation from the Fibonacci class F, and a diagram of a permutation from the
class PBT .
our results as one of the twelve minimal classes with polylogarithmic sorting time.
The class CBub :“ tιa ‘ 21 ‘ ιb; a, b P N0u Y
corresponds to sorting by adjacent
transpositions. This includes, e.g., the classical bubble sort algorithm. It can be
easily seen that wstpCBub; nq “
`n
2
˘
. A slight modification yields the class T :“
tιa ‘ 21 ‘ ιb; a, b P N0u Y t1 a ιc a 1; c P N0u Y
, which corresponds to cyclic
adjacent transpositions, where positions 1 and n are treated as adjacent.
The class k-Fringe :“ tπ‘ιa‘σ; a P N0, |σ| ď k, |π| ď ku contains permutations
in which only the prefix of length k and the suffix of length k can be permuted. We
also define k-RFringe :“ k-Fringe Y pk-Fringeqr.
The grid class CPan “ Grid
´
¯
corresponds to sorting where in each step, we
reverse the prefix of the permutation being sorted. This is known in the literature as
pancake sorting. It is well known that wstpCPan; nq “ Θpnq. It is easy to see that the
same asymptotic estimate also applies to Cr
Pan, Cc
Pan and Cf
Pan.
The grid class
CIns “ Grid
¨
˝‚
˛
‚
corresponds to sorting where in each step, we take the first element of the input and
insert it to an arbitrary position i, while moving the elements in positions 2, 3, . . . , i
one step to the left. This corresponds to the classical insertion sort algorithm. The
standard application of the algorithm can sort any input in n´1 steps, by maintaining
the invariant that after k steps, the final k `1 elements are in increasing order; hence,
wstpCIns; nq ď n ´ 1. This bound is tight, since any permutation π with πpnq “ 1
requires n ´ 1 steps to be sorted.
3
Classes that cannot sort
Let us say that a class C cannot sort, if wstpC; nq “ `8 for some n. Note that this
is equivalent to C˚
n ‰ Sn. Moreover, if C˚
n is different from Sn for some n, then for
any m ě n, C˚
m is different from Sm, since C˚ is a permutation class.
7

--- Page 8 ---
Notation
Description
L
À
F
Àt1, 12u “ L X Avp321q
R
Grid
ˆ
˙
RR
R Y Rr
PBT
À R
CBub
Grid
¨
˚
˚
˝
‚
‚
˛
‹‹‚
Notation
Description
T
CBub Y Grid
¨
˝
‚
‚
˛
‚
k-Fringe
Grid
¨
˝
Sďk
Sďk
˛
‚
k-RFringe
k-Fringe Y k-Fringer
CPan
Grid
ˆ
˙
CIns
Grid
¨
˝‚
˛
‚
Table 1: A summary of relevant permutation classes
When seeking to characterize the maximal classes that cannot sort, we may
restrict our attention to the classes C that are composition closed, that is, those that
satisfy C “ C˚. Composition closed permutation classes have been characterized by
Atkinson and Beals [4]. Translating their results into our terminology, we obtain the
following proposition.
Proposition 3.1. A permutation class C cannot sort if and only if it satisfies, for
some k P N, one of the following two conditions:
1. C is a subclass of RR Y Sďk, or
2. C is a subclass of k-RFringe.
4
From infinity to Opn2q
Let us now focus on showing that any class that can sort has at most quadratic
sorting time. Our key concept will be the notion of peg class, which is a grid class
with a gridding matrix whose every row and column has exactly one nonempty cell,
and each nonempty cell is either the singleton class t1u or one of the two monotone
classes
and
.
Peg classes have been previously studied mostly in the context of enumeration [2,
23, 22]. Indeed, it is known that a permutation class has polynomial growth rate
if and only if it is a finite union of peg classes. For our purposes, we will use the
following result.
Fact 4.1 (Homberger–Vatter [22, Theorem 3.1]). If a permutation class C does not
contain as a subclass any monotone juxtaposition, nor F nor Fr, then C is a finite
union of peg classes.
8

--- Page 9 ---
Ca “ Grid
¨
˝
‚
‚
˛
‚, Cb “ Grid
¨
˝
‚
‚
˛
‚, Cc “ Grid
¨
˝
‚
‚
˛
‚,
Cd “ Grid
¨
˚
˚
˝
‚
‚
˛
‹‹‚, Ce “ Grid
¨
˚
˚
˝
‚
‚
‚
˛
‹‹‚.
Figure 3: Five peg classes that can sort in quadratic time.
It is not hard to see that any monotone juxtaposition has worst-case sorting time
of order Oplog nq; we later prove this in Proposition 6.11. Also for the Fibonacci
class F, we have already pointed out that wstpF; nq “ Θpnq, and we may easily
observe that wstpFr; nq “ Opnq.
Thus, if a class C has at least quadratic wstpC; nq, it cannot contain any monotone
juxtaposition and any symmetry of F as a subclass. Thus, by Fact 4.1, such a class
C can be written as a finite union of peg classes.
Lemma 4.2. Let C be a peg class. If C can sort, then wstpC; nq “ Opn2q.
Proof. If the gridding matrix of C contains a cell equal to
as well as a cell equal to
, then C contains CPan “
‘
or one of its symmetries as a subclass, and with the
help of Observation 2.3 we easily conclude that wstpC; nq “ Opnq.
Suppose then that at most one of the two classes
and
occurs in the gridding
of C. If
occurs, then by Observation 2.3, wstpC; nq ď 2wstpCr; nq, and Cr is a peg
class whose gridding matrix contains
. It is therefore enough to deal with peg
classes whose gridding matrix contains
but not
. We assume from now on that C
is such a peg class.
Let M be the gridding matrix of the class C, and assume that M has been chosen
to have the smallest possible number of rows and columns. In particular, this means
that if Mi,j “
for some i and j, then either the cell Mi,j is in the last column or
last row of M, or the cell Mi`1,j`1 is empty. If not, then we could delete column
i ` 1 and row j ` 1 from M to obtain a smaller gridding matrix representing the
same class C. By the same reasoning, if Mi,j “
for some i ą 1 and j ą 1, then
Mi´1,j´1 is empty.
Consider now the five peg classes from Figure 3. We claim that all these classes,
and therefore also their inverses and flips, have at most quadratic sorting time.
Consider the class Ca, which corresponds to sorting where in every step we either
move the first element of the input to the last position, shifting the remaining
elements one step forward, or we move the first two elements to the end, while
simultaneously changing their relative position. We may easily see that by a sequence
of at most n steps of Ca, we may simulate a single step of the class F of parallel
adjacent transpositions on an input of size n. As we pointed out in Section 2,
wstpF; nq “ Opnq. It follows that wstpCa; nq “ wstpC´1
a ; nq “ wstpCf
a; nq “ Opn2q.
The same argument also applies to the remaining classes Cb, Cc, Cd and Ce.
9

--- Page 10 ---
Consider again the peg class C from our lemma, with its gridding matrix M. We
will show that C either contains, as a subclass, one of the classes Ca, . . . , Ce from
Figure 3 or its inverse or flip. We know that M contains at least one entry equal to
,
so let us fix one such entry Mi,j. We now let MTL, MTR, MBL and MBR denote the
submatrices of M formed be the cells strictly to the top-left, top-right, bottom-left
and bottom-right of the cell Mi,j, respectively; for instance MBL is formed by the
intersection of the leftmost i ´ 1 columns and bottommost j ´ 1 rows of M.
If both MTL and MBR contain a non-empty cell, then C contains Cb as a subclass,
so suppose this is not the case, and assume, without loss of generality, that MBR
only contains empty cells. If the grid class of MTL contains 21, then C contains Ca
and we are done, so we assume from now on that MTL generates a (possibly empty)
subclass of
. It follows that at least one of MBL and MTR must contain a nonempty
cell, otherwise C would be a subclass of R and it could not sort.
Suppose without loss of generality that MTR contains at least as many
-cells as
MBL, and in case neither MTR nor MBL contains any
-cell, suppose that MTR has
at least one nonempty cell. Let Mi`1,k be a nonempty cell in the column of M right
next to Mi,j. Note that k is at least j ` 2, since MBR only has empty cells and if
the cell Mi`1,j`1 were nonempty, we could combine it with Mi,j contradicting the
minimality of M.
Let Mℓ,j`1 be a nonempty cell of M in the row above Mi,j. If Mℓ,j`1 is inside
MTL, then C contains Cc as a subclass, so suppose that Mℓ,j`1 is inside MTR. If at
least one of the two cells Mi`1,k and Mℓ,j`1 is equal to
, then C contains either Cf
c
or pCf
c q´1 as a subclass and we are done. Suppose that this is not the case. Since C
is not a subclass of k-Fringe for any fixed k, there must be either a nonempty cell
in MTL or a cell equal to
in MTR. In the former case, C contains as a subclass
either Cc or Cf
e . In the latter case, it contains either Cd or a class symmetric to Cc as
a subclass.
In all the cases considered, we found that C contains a class symmetric to one of
Ca, . . . , Ce as a subclass, proving that wstpC; nq “ Opn2q as claimed.
Lemma 4.2 shows that a peg class that can sort has at most quadratic sorting
time. We now turn our attention to classes that can be expressed as unions of two or
more peg classes. The goal is to show that even if the individual peg classes cannot
sort, as long as their union can sort, it has at most quadratic sorting time.
Lemma 4.3. Assume that a class C is a subclass of RRYSďk for some k, but is not
a subclass of k-RFringe for any k, and that a class D is a subclass of k-RFringe
for some k, but not a subclass of RR Y Sďk for any k. Then wstpC Y D; nq “ Opn2q.
Proof. By assumption, C contains infinitely many permutations that belong to RR
but not to 0-RFringe “ Avp21q Y Avp12q. Any such permutation has the form
ιa a ιb or δa ‘ δb for some a, b ą 0. It follows that C contains as a subclass the peg
class Grid
` ‚
˘
or one of its symmetries.
Similarly, the class D contains, for some k, infinitely many permutations belonging
to k-RFringe but not to RR. From this, we easily deduce that D contains as a
subclass the peg class Grid
´
‚
‚
¯
or one of its symmetries.
10

--- Page 11 ---
We may then easily check that any permutation from the class Fn can be obtained
by composing Opnq permutations from C Y D, implying that wstpC Y D; nq “
Opn2q.
Combining the previous arguments, we reach the main result of this section.
Proposition 4.4. A class C that can sort satisfies wstpC; nq “ Opn2q.
Proof. Suppose that C can sort. If C contains a monotone juxtaposition or any
symmetry of the class F as a subclass, then its worst-case sorting time is Opnq.
Otherwise, C can be written as a union of finitely many peg classes C1, . . . , Ct, as
shown by Albert et al. and Homberger–Vatter [2, 22]. If any of the peg classes Ci can
sort, then wstpC; nq ď wstpCi; nq “ Opn2q by Lemma 4.2. Suppose then that none of
the peg classes C1, . . . , Ct can sort, and in particular, by Proposition 3.1, each Ci is
either a subclass of RR Y Sďk or a subclass of k-RFringe for some k.
If all of C1, . . . , Ct are subclasses of k-RFringe, or all of them are subclasses of
RR Y Sďk, then C cannot sort by Proposition 3.1. Otherwise there is a Ci which is
not a subclass of RR Y Sďk for any k, and a Cj which is not a subclass of k-RFringe
for any k, and by Lemma 4.3, wstpC; nq ď wstpCi Y Cj; nq “ Opn2q.
5
From quadratic to linear
Recall that T denotes the class of cyclic adjacent transpositions. To show there is a
gap between quadratic and linear worst-case sorting times, and to describe the classes
with quadratic time, we need to introduce another concept: the reduced inversion
number of a permutation π, denoted rinpπq, is the smallest integer k P N0 such that
π belongs to T ˝k ˝ RR.
The reduced inversion number rinpπq is inspired by the (better-known) inversion
number of a permutation π, which can be defined as the smallest k such that π
belongs to C˝k
Bub. Observe that the inversion number is an upper bound for the reduced
inversion number.
Lemma 5.1. For any α, β P RRn and any π P Sn, rinpα ˝ π ˝ βq “ rinpπq.
Proof. First, notice that RR ˝ T “ T ˝ RR; in other words, a permutation obtained
by composing a rotation (with optional reversal) with a cyclic transposition can also
be obtained by performing a cyclic transposition first followed by a rotation (with
optional reversal), and vice versa. It is also easy to see that RR ˝ RR “ RR, that
is, the class RR is closed under compositions.
Suppose now that we are given α, β and π as above, and let k :“ rinpπq. Let σ
be the permutation α ˝ π ˝ β. Then π belongs to T ˝k ˝ RR, and hence σ belongs to
RR ˝ T ˝k ˝ RR˝2 “ T ˝k ˝ RR. This shows that rinpσq ď rinpπq. Conversely, π is
equal to α´1 ˝ σ ˝ β´1, and since α´1 and β´1 both belong to RR, we may repeat
the above argument to show that rinpπq ď rinpσq. We conclude that rinpπq “ rinpσq,
as claimed.
Lemma 5.2. For any σ, π P Sn,
rinpπ ˝ σq ď rinpπq ` rinpσq.
11

--- Page 12 ---
Proof. Let k :“ rinpσq and ℓ:“ rinpπq. Then σ ˝ π belongs to the class T ˝k ˝ RR ˝
T ˝ℓ˝ RR “ T ˝pk`ℓq ˝ RR, hence rinpσ ˝ πq ď k ` ℓ.
For a class C and n P N, let us define rinpC; nq :“ maxtrinpσq; σ P Cnu. As
a direct consequence of Lemma 5.2, we obtain the following relationship between
sorting time and reduced inversion number.
Corollary 5.3. For any class C and any π P Sn,
stpC; πq ě
rinpπq
rinpC; nq.
To make use of this corollary, we need to show that there are permutations π P Sn
of large rinpπq.
Lemma 5.4. We have rinpS; nq “ Θpn2q.
Proof. A permutation π of length n has inversion number at most
`n
2
˘
, and hence
rinpS; nq ď
`n
2
˘
. For a lower bound, we first introduce some auxiliary notions. For
two numbers i, j P rns, we define their cyclic distance cdpi, jq by
cdpi, jq “ mint|i ´ j|, n ´ |i ´ j|u,
and for a permutation π P Sn, define its total cyclic distance tcdpπq by
tcdpπq “ cd
`
πp1q, πpnq
˘
`
n´1
ÿ
i“1
cd
`
πpiq, πpi ` 1q
˘
.
Observe that for any ρ P RR and π P Sn, both tcdpπ ˝ ρq and tcdpρ ˝ πq are equal
to tcdpπq. Observe also that for any σ P T , we have tcdpσ ˝ πq ď tcdpπq ` 4.
Consequently, given that the identity permutation ιn satisfies tcdpιnq “ n, we see
that for any π P T ˝k we have tcdpπq ď n ` 4k. Combining these observations, we
see that any π P Sn satisfies tcdpπq ď n ` 4 rinpπq.
To prove the desired lower bound rinpS, nq “ Ωpn2q, it is enough to find a
permutation π P Sn with tcdpπq “ Ωpn2q. An example can be the permutation
π “ p1, rn{2s ` 1, 2, rn{2s ` 2, 3, rn{2s ` 3, . . . q obtained by interleaving the two
sequences p1, 2, 3, . . . , rn{2sq and prn{2s ` 1, rn{2s ` 2, . . . , nq.
Combining Corollary 5.3 and Lemma 5.4, we obtain the following bound.
Corollary 5.5. For any class C,
wstpC; nq ě Ω
ˆ
n2
rinpC; nq
˙
.
For a gridding matrix M with m rows and n columns, the reversal of M, denoted
M r, is the gridding matrix obtained by replacing each individual entry C “ Mi,j
with its reversal Cr, and then reversing the order of columns of the whole matrix M;
formally, if Mi,j “ C, then M r
n´i`1,j “ Cr. Note that the permutations in the class
GridpM rq are precisely the reverses of those in GridpMq.
12

--- Page 13 ---
CIns “ Grid
¨
˝‚
˛
‚,
C1 “ Grid
¨
˝
‚
˛
‚,
C2 “ Grid
¨
˝
‚
˛
‚
Figure 4: Three classes with congruent gridding matrices, all with linear sorting time
Let M be a gridding matrix. The column rotation of M is the operation that
transforms M into the matrix M 1 of the same size, where the first column of M is
equal to the last column of M 1, and for each i ą 1 the i-th column of M is equal to the
pi´1q-th column of M 1. The row rotation of M is defined analogously. We say that a
gridding matrix M is congruent to a matrix M 1, if M can be transformed into M 1 by
a sequence of column rotations, row rotations and reversals. Note that if M and M 1
are congruent, then for any π P GridpMq there are permutations ρ, ρ1 P RR such that
ρ ˝ π ˝ ρ1 belongs to GridpM 1q. In particular, rinpGridpMq; nq “ rinpGridpM 1q; nq.
Lemma 5.6. For any peg class C, either rinpC; nq is bounded, or wstpC; nq “ Opnq.
Proof. Let C be a peg class with a gridding matrix M, and suppose that rinpC; nq is
unbounded. In particular, M contains at least one entry equal to
or to
. Let M 1
be a gridding matrix congruent to M whose top-right entry is equal to
.
Suppose that M 1 contains an entry equal to
. Then GridpM 1q contains, as a
subclass, the peg class CPan “ Grid
´
¯
, and C contains one of the symmetries of
this class. Since all the symmetries of CPan have linear worst-case sorting time, we
conclude that wstpC; nq “ Opnq.
Suppose then that M 1 does not contain
. Let M 1
i,j be an entry of M 1 equal to
.
If M 1 contains a nonempty entry strictly to the left and above M 1
i,j, then GridpM 1q
contains CIns as a subclass. It follows that C contains as a subclass one of the three
classes from Figure 4 or one its symmetries. Noting that CIns Ď C˝2
1 and CIns Ď C˝2
2 ,
and applying Observation 2.3 if needed, we easily conclude that wstpC; nq “ Opnq.
An analogous argument applies when M 1 has a nonzero entry to the right and
below M 1
i,j.
Finally, suppose that no entry of M 1 equal to
has any nonzero entry to the left
and above, or to the right and below of itself. It follows that all the entries of M 1
equal to
appear on the main diagonal, and M 1 is a block-diagonal matrix whose
every block consists either of a single entry
, or a submatrix that has no entry
equal to
. It then easily follows that rinpGridpM 1q; nq is bounded, and rinpC; nq is
bounded as well.
Proposition 5.7. For a class C, the following are equivalent:
1. wstpC; nq “ opn2q,
2. wstpC; nq “ Opnq, and
3. rinpC; nq is unbounded as n Ñ 8.
13

--- Page 14 ---
Proof. By Corollary 5.5, if rinpC; nq is bounded then wstpC; nq “ Ωpn2q. This shows
the implication 1 ùñ 3.
To prove 3 ùñ 2, suppose now that rinpC; nq is unbounded for a class C. If
C contains as a subclass a monotone juxtaposition or its inverse or if it contains
the Fibonacci class F or its reverse, then clearly wstpC; nq “ Opnq. On the other
hand, if C contains no such subclass, then it can be expressed as a union of finitely
many peg classes C1, . . . , Ck. Since rinpC; nq is unbounded, there must be an i P rks
such that rinpCi; nq is unbounded. By Lemma 5.6, wstpCi; nq “ Opnq, and therefore
wstpC; nq “ Opnq. This proves the implication 3 ùñ 2.
The implication 2 ùñ 1 is trivial.
6
From Ωp?nq to polylog
The most difficult part of our argument deals with the gap between sorting times
Oplog2 nq and Ωp?nq. The criterion distinguishing the two types of classes is rather
simple to state, though. For ease of notation, let X be the set of permutation classes
that contains the eight monotone juxtapositions and the four classes L, Lr, PBT
and PBT r. We say that a permutation class C is X-avoiding if it does not contain
any class from X as a subclass, otherwise we say that it is X-containing.
Theorem 6.1. Any X-avoiding class C satisfies wstpC; nq “ Ωp?nq, while any
X-containing class C satisfies wstpC; nq “ Oplog2 nq.
The rest of this section is devoted to a detailed proof of Theorem 6.1. We first
focus on showing that every X-avoiding class C satisfies wstpC; nq “ Ωp?nq.
An inversion in a permutation π is a decreasing subsequence of length 2, i.e., a
pair pπpiq, πpjqq such that i ă j and πpiq ą πpjq. The first ingredient in the proof of
Theorem 6.1 is a structural result characterizing permutation classes admitting a
linear bound on the number of inversions.
Proposition 6.2. For a permutation class C, the following statements are equivalent:
1. Neither R nor
is a subclass of C.
2. There is a k P N such that every permutation in C avoids both δk and ιk a ιk.
3. There is a Q P N such that every permutation π P C of size n has at most Qn
inversions.
Proof. The implication 3 ñ 1 is clear, since both
and R contain permutations of
size n with Ωpn2q inversions, namely δn and ιtn{2u a ιrn{2s. Likewise, the implication
1 ñ 2 follows directly from the fact that any permutation in R is a subpermutation
of ιk a ιk for some k.
It remains to prove 2 ñ 3. Fix k such that every permutation of C avoids both
δk and ιk a ιk, and let π be a permutation of size n in C. Since π avoids δk, it can be
partitioned into k ´ 1 increasing subsequences I1, . . . , Ik´1. We will show that π has
at most pk ´ 1q3n inversions.
Suppose that pπpiq, πpjqq is an inversion, that is, i ă j and πpiq ą πpjq. We say
that the inversion has type pa, bq if πpiq belongs to Ia and πpjq belongs to Ib. Note
14

--- Page 15 ---
that this implies a ‰ b. We will show that for any pa, bq P rk ´ 1s ˆ rk ´ 1s there are
at most pk ´ 1qn inversions of type pa, bq. To this end, we define a graph Ga,b on
the vertex set Ia Y Ib whose edges are the pairs of vertices that form an inversion of
type pa, bq. We claim that the graph Ga,b is pk ´ 1q-degenerate, that is, each of its
nonempty subgraphs has a vertex of degree at most k ´ 1.
Suppose for contradiction that Ga,b has a nonempty subgraph G1 whose every
vertex has degree at least k. The vertex set of G1 has the form I1
a Y I1
b for some
I1
a Ď Ia and I1
b Ď Ib. Let x1 be the rightmost vertex in I1
a, and let Npx1q be the
vertices of I1
b adjacent to x1. By assumption, |Npx1q| ě k. Let y1 be the rightmost
(and therefore also topmost) vertex in Npx1q, and let Npy1q Ď I1
a be its neighbors.
Since any vertex in Npx1q is to the right of x1, it follows that any vertex in Npx1q is
to the right of all the vertices in Npy1q (recall that x1 is the rightmost vertex of I1
a).
Moreover, since y1 is topmost in Npx1q, all the vertices of Npx1q are below all the
vertices in Npy1q. It follows that the set Npx1q Y Npy1q induces in π a permutation
containing ιk a ιk, which is a contradiction.
We conclude that the graph Ga,b is pk´1q-degenerate for any pa, bq P rk´1sˆrk´1s,
and therefore has at most pk ´ 1qp|Ia| ` |Ib|q ď pk ´ 1qn edges. Summing over all
values of a and b, we conclude that π has at most pk ´ 1q3n inversions.
The key part in the proof of Theorem 6.1 is a structural characterization of
X-avoiding classes. To state it, we need to introduce some terminology.
An integer interval (or just interval, if there is no risk of confusion) is a finite
set of consecutive positive integers, i.e., a set of the form ti P N; a ď i ď bu for some
a, b P N. For a finite set X Ď N, its intervalicity, denoted IntpXq, is the smallest
k P N0 such that X can be expressed as a union of k integer intervals. For a finite
point set P Ď N ˆ N, we let P|x and P|y denote its projections to the x-axis and to
the y-axis, respectively. The intervalicity of the point set P, denoted again IntpPq,
is the maximum of IntpP|xq and IntpP|yq.
Proposition 6.3. For every X-avoiding class C there is a constant K ” KpCq, such
that every π P C admits a gridding with at most K rows and K columns such that
for every cell X of the gridding, the following holds:
1. the point set πrXs has intervalicity at most K,
2. the permutation induced by πrXs avoids at least one of ιK and δK,
3. the permutation induced by πrXs avoids both ιK a ιK and δK ‘ δK, and
4. if nX is the number of elements in πrXs, then either πrXs or its reverse has
at most K ¨ nX inversions.
Before we prove the proposition, let us collect several known facts about permu-
tation classes.
Fact 6.4 (Vatter [29, Corollary 5]). For every permutation class C that does not con-
tain L or Lr as a subclass, there is a constant K “ K6.4 such that every permutation
π P C is a union of at most K monotone subsequences.
15

--- Page 16 ---
Fact 6.5 (Vatter [28, Theorem 3.1]). Let C be a permutation class, and let α be a
permutation. The following two statements are equivalent:
• There is a constant K “ K6.5 such that every permutation in C has a gridding
of size K ˆ K in which every cell induces a permutation that avoids α.
• There is a constant Q such that neither ÀQ α nor ÁQ α belongs to C.
A horizontal alternation is a permutation in which all the odd values appear to
the left of all the even values or vice versa. A vertical alternation is an inverse of a
horizontal alternation. An alternation is a horizontal or vertical alternation.
Fact 6.6 (Huczynska–Vatter [23, Proposition 3.2]). For a permutation class C
that does not contain any monotone juxtaposition as a subclass there is a constant
K “ K6.6 such that C does not contain any alternation of size K.
Proof of Proposition 6.3. Let C be an X-avoiding class, and fix π P C.
By Fact 6.6, there is a constant K6.6 such that C does not contain any alternation
of size K6.6 or more. We claim that this implies that in any gridding of π, every cell
has intervalicity less than K6.6. To see this, suppose for contradiction that there
is a cell X such that the projection of πrXs on the horizontal or vertical axis has
intervalicity at least K6.6. Without loss of generality, suppose that the projection
is onto the horizontal axis, let ℓě K6.6 be its intervalicity, and let P1, P2, . . . , Pℓbe
the intervals, numbered left to right, whose union is the projection of πrXs. For any
i P rℓ´ 1s, fix an integer ji such that max Pi ă ji ă min Pi`1. Since πpjiq is not in
πrXs, it is either smaller than all the values in πrXs or larger than all the values
in πrXs. Without loss of generality, there are at least pℓ´ 1q{2 values of i P rℓ´ 1s
for which πpjiq is larger than all the values in πrXs. We can then choose at least
pℓ` 1q{2 values in πrXs which form a vertical alternation with these pℓ´ 1q{2 ‘large’
values πpjiq, showing that π has an alternation of size ℓě K6.6, which is impossible.
Thus, in any gridding of π, every cell has intervalicity less than K6.6.
By Fact 6.4, there is a constant K6.4 such that every permutation of C is a union
of at most K6.4 monotone sequences. Let us therefore fix such a partition of π into
monotone sequences, and suppose that the partition contains p increasing sequences
I1, . . . , Ip and q decreasing sequences D1, . . . , Dq, for some p ` q ď K6.4. Define
IY “ Ťp
i“1 Ii and DY “ Ťq
i“1 Di. Notice that IY avoids δp`1 and DY avoids ιq`1.
We will now show that π has a gridding with bounded number of cells in which
each cell is either disjoint from IY or disjoint from DY. For any choice of i P rps
and j P rqs, we can easily construct a 2 ˆ 2 gridding of π such that the increasing
subsequence Ii intersects neither the top-left nor the bottom-right cell, while Dj
intersects neither the bottom-left nor the top-right cells. Combining such griddings for
all the choices of pi, jq P rpsˆrqs, we obtain a single gridding of size ppq`1qˆppq`1q
in which every cell avoids either IY or DY, and in particular, every cell avoids ιq`1
or δp`1.
For the next step, we note that there are constants A, B such that neither
ÀApιB a ιBq nor ÁApιB a ιBq belongs to C. Indeed, if C contained ÀApιB a ιBq
for each A and B, then C would contain PBT as a subclass, and if C contained
ÁApιB aιBq for all A, B, then C would contain Lr as a subclass. By Fact 6.5 applied
16

--- Page 17 ---
to α “ ιB a ιB, we can refine the gridding of π obtained in the previous step by
adding at most K6.5 rows and columns to obtain a gridding in which no cell contains
ιB a ιB. By a symmetric argument, another round of refinement ensures that no cell
of the gridding contains δB ‘ δB for a constant B.
Invoking Proposition 6.2 (or its symmetric version) to each cell of the resulting
gridding, and choosing K large enough in terms of the constants appearing in the
previous arguments, we conclude that the gridding obtained by this procedure has
all the properties from the statement of the proposition.
For a permutation π, the adjacency graph Gpπq is a graph whose vertices are
the elements of π, and two vertices are connected by an edge if and only if the
corresponding two elements have adjacent positions or adjacent values. In particular,
the adjacency graph is a union of two paths, one visiting the vertices in left-to-right
order, and the other in bottom-to-top order.
The tree-width of the permutation π, denoted twpπq, is then defined as the
tree-width of Gpπq. Note that there are permutations of size n with tree-width
Ωpnq [1].
Now, we introduce the concept of sorting diagram, which will offer a convenient
way to represent a sequence of steps performed during the sorting of a sequence. Let
t and n be positive integers, and let ⃗σ “ pσ1, σ2, . . . , σtq be a t-tuple of permutations
of rns. Define the permutation π “ σt ˝ σt´1 ˝ ¨ ¨ ¨ ˝ σ2 ˝ σ1. In particular, by applying
the steps σ1, . . . , σt in this order, we would sort the sequence π´1 into an increasing
sequence.
Let P be the set rpt ` 1qns ˆ rpt ` 1qns, viewed as an integer grid in the plane.
We partition P into blocks of size n ˆ n as follows: for a, b P rt ` 1s, let Pa,b be the
set tpi, jq P P; pa ´ 1qn ă i ď an ^ pb ´ 1qn ă j ď bnu. For a permutation σ P Sn,
let Pa,brσs denote the set of n points forming a translated copy of the diagram of σ
inside the block Pa,b; formally,
Pa,brσs “
␣`
pa ´ 1qn ` i, pb ´ 1qn ` σpiq
˘
; i P rns
(
.
We are now ready to describe the sorting diagram of the t-tuple of permutations
⃗σ “ pσ1, σ2, . . . , σtq; refer to Figure 5. Recall that ιn is the increasing permutation
p1, 2, . . . , nq. The sorting diagram of the t-tuple ⃗σ “ pσ1, . . . , σtq, denoted SD ”
SDp⃗σq, is the graph whose vertex set is the point set
V pSDq “
t`1
ď
i“1
Pt`2´i,irιns Y
tď
i“1
Pt`2´i,i`1rσis.
In particular, the vertex set consists of t ` 1 copies of the diagram of ιn inside the
blocks forming the decreasing diagonal of P, together with the copies of the diagrams
of σ1, . . . , σt, appearing right-to-left inside the blocks just above the decreasing
diagonal. We refer to the n vertices inside the bottom-right block Pt`1,1 as starting
vertices, and we label them s1, . . . , sn in left-to-right order. Similarly, the vertices
inside the top-left block P1,t`1 are the terminal vertices, and are labelled t1, . . . , tn in
left-to-right order. The edge set of SD is determined as follows:
17

--- Page 18 ---
Figure 5: The sorting diagram of the triple of permutations σ1 “ 2413, σ2 “
3214, σ3 “ 3412.
• Any two vertices of V pSDq that lie on the same horizontal line are connected
by an edge. We call these edges horizontal edges. Note that every vertex is
incident to a unique horizontal edge, except for the n starting vertices.
• Any two vertices of V pSDq that lie on the same vertical line are connected by
an edge. We call these edges vertical edges. Note that every vertex is incident
to a unique vertical edge, except for the n terminal vertices. Note also that
the horizontal and vertical edges together form n vertex-disjoint paths, each
connecting a starting vertex to a distinct terminal vertex, with the vertex si
being connected to tπpiq, where π “ σt ˝ ¨ ¨ ¨ ˝ σ1.
• Finally, for any i P rn ´ 1s, the vertex si is connected to si`1 and ti to ti`1. We
call these edges as the diagonal edges.
This completes the description of the graph SD.
Lemma 6.7. For a t-tuple of permutations ⃗σ “ pσ1, . . . , σtq and their composition
π “ σt˝¨ ¨ ¨˝σ1, the tree-width of the graph SDp⃗σq is at least as large as the tree-width
of the incidence graph Gpπq of π.
Proof. The graph Gpπq is a minor of SDp⃗σq, since by contracting all the horizontal
and vertical edges in SDp⃗σq, we obtain precisely the graph Gpπq. The lemma follows,
since tree-width is minor-monotone.
Proposition 6.8. Let C be an X-avoiding class. There are constants Q and R, such
that for any t P N, any n P N, and any t-tuple ⃗σ “ pσ1, . . . , σtq of permutations from
Cn, the sorting diagram SDp⃗σq can be drawn on a surface of genus at most Q ¨ t with
at most R ¨ t ¨ n edge-crossings.
18

--- Page 19 ---
Di
Di+1
Si
Figure 6: A fragment of a sorting diagram, induced by three consecutive blocks Di,
Si and Di`1. The light gray rectangle is a cell of the gridding of σi. The four dark
gray rectangles represent the two horizontal and two vertical handles attached to
this cell.
Proof. The definition of the graph SD “ SDp⃗σq already implies a drawing in the
plane, where vertices are points and edges are straight-line segments. Unfortunately,
such a drawing may have too many edge-crossings. Our strategy is to insert handles
and cross-caps into this drawing, so that we eliminate enough of the crossings, without
increasing the genus of the surface too much.
Recall from the definition of sorting diagram that the vertices of SD are organized
into 2t ` 1 square blocks, which include t ` 1 diagonal blocks Pt`1,1, Pt,2, . . . , P1,t`1,
as well as t blocks right above the diagonal, namely Pt`1,2, Pt,3, . . . , P2,t`1. For ease
of notation, for i P rt ` 1s let Di refer to the diagonal block Pt`2´i,i, and for i P rts
let Si refer to the block right above Di, i.e., Pt`2´i,i`1. The vertices of SD induce a
copy of ιn inside every Di, and a copy of σi inside Si.
In the straight-line drawing of SD, the only edge-crossings that occur are inside
the blocks Si, between a vertical edge connecting a vertex x from Di to a vertex
y in Si, and a horizontal edge connecting a vertex x1 in Si to a vertex y1 in Di`1.
Notice that such a pair of edges has a crossing if and only if py, x1q corresponds to a
decreasing subsequence of σi. We will now modify the drawing of edges (and the
surface they are drawn upon) inside each block Si for i P rts, while the parts of the
drawing inside the Di’s are unaffected.
Fix i P rts. Let K “ KpCq be the constant from Proposition 6.3. As the first
step, apply to the copy of σi inside Si the gridding described by Proposition 6.3. We
will now add handles to our surface, and route the edges along these handles, to
ensure that no two edges cross, unless they have endpoint inside the same cell of the
gridding. Refer to Figure 6.
Let X be a cell of the gridding of σi. By Proposition 6.3, σirXs has intervalicity
at most K. In particular, there are K disjoint intervals I1, . . . , IK (some possibly
empty) such that a vertical edge from Di to Si has an endpoint in X if and only
if its projection to the x-axis is a point from I1 Y I2 Y ¨ ¨ ¨ Y IK. For each j P rKs
such that Ij ‰ H, we attach a new handle H|
j to our surface, oriented vertically,
whose bottom end is near the bottom edge of Si, the top end is near the bottom
edge of X, and its horizontal position corresponds to the interval Ij (in case X is in
the bottom row of the gridding, we omit these handles and leave the vertical edges
19

--- Page 20 ---
p1
p2
p3
e1
e2
e3
p1
p2
p3
e1
e2
e3
Figure 7: A modification of horizontal edges inside a cell X of the gridding of σi.
The gray rectangles represent the handles adjacent to X, and the circle near the top
boundary of the modified drawing represents a cross-cap.
into X unchanged). All the vertical edges whose projection on the x-axis lies in Ij
are then routed through H|
j, from the point when they cross the boundary from Di
to Si, till the point when they reach the bottom of edge of the cell X. This way,
we remove any crossing between a vertical edge incident with a point in X and a
horizontal edge incident with a cell X1 in the gridding which lies below X.
We perform an analogous operation with the horizontal edges. Again, for a cell
X, the projection of σirXs on the y-axis forms K intervals J1, . . . , JK, and for each
such nonempty interval Jℓwe attach a horizontal handle H´
ℓ, whose left endpoint is
near the boundary between Si and Di`1 and its right endpoint is near the left edge
of X; if X is in the leftmost column of the gridding, these handles are omitted. The
horizontal edges projecting into Jℓare then routed through the handle H´
ℓ.
For each i P rts, this operation adds at most K vertical and K horizontal handles
incident to any given cell X of the gridding of σi, so at most 2K3t handles overall.
After these handles are added, a vertical edge from Di to Si may cross a horizontal
edge from Si to Di`1 only if their endpoints inside Si belong to the same cell of the
gridding of σi. Unfortunately, there may still be too many such edge-crossings, and
so we may need to perform additional modifications inside a cell X to reduce the
number of crossings. The goal is for the number of crossings inside X to be linear in
the size of σirXs.
Consider again a cell X of the gridding of σi, and let nX be the size of σirXs.
Observe that at this point, the number of edge-crossings inside X is equal to the
number of decreasing subsequences of length 2 in σirXs. By Proposition 6.3, σirXs
contains either at most K ¨nX decreasing subsequences of length 2, or at most K ¨nX
increasing subsequences of length 2. In the former case, we do not need to modify
the drawing of the edges incident to X any further. Consider now that the second
situation occurs; refer to Figure 7.
Let p1, . . . , pnX be the points of σirXs, numbered bottom to top, and let ej be
the horizontal edge incident to pj. We will modify the drawings of all the horizontal
edges inside X as follows: the edge ej, instead of heading straight to the left from
pj towards the horizontal handle leading to Di`1, will instead head straight to the
right from pj, until it reaches close to the right edge of X, then it will turn upwards,
follow the right edge towards the top-right corner of X, then turn left and follow
the top edge of X. All the horizontal edges will perform this ‘U-turn’, keeping their
20

--- Page 21 ---
mutual positions so that they do not introduce any mutual crossings. In particular,
as the edges reach the top edge of X and head to the left, the edge e1 will be the
topmost, followed by e2, e3 etc. However, we need the edges to reach the handles in
the opposite bottom-to-top order. To fix this, we attach a cross-cap near the top
edge of X and let all the edges ei pass through it. This reverses their bottom-to-top
order, and it is easy to then extend the edges along the top and left edge of X
towards their designated handles, without introducing any new crossings. After this
modification, an edge ej crosses a vertical edge incident to a vertex pk if and only if
ppj, pkq form an increasing subsequence of length 2 in σirXs. In particular, there are
now at most K ¨ nX crossings inside X.
In the end, we obtain a drawing of SDp⃗σq on a surface with at most 2K3t handles
and at most K2t cross-caps, and in particular, the genus of the surface is at most
p4K3 ` K2qt. Each block Si contains at most Kn edge-crossings, so there are at
most Knt edge-crossings overall.
Our next tool is an inequality that relates the genus, the crossing number and
the tree-width of a graph. Its proof is based an idea of Dujmović, Eppstein and
Wood [15].
Proposition 6.9. Every graph on n vertices that can be drawn on a surface of genus
g with at most x edge-crossings has treewidth O
´a
pg ` 1qpn ` xq
¯
.
Proof. Suppose a graph G on n vertices has been drawn on a surface of genus g with
x edge-crossings. Let us orient the edges of G arbitrarily, so that each edge e has
a designated tail te and head he. Next, let us replace each edge-crossing by a new
vertex, thereby obtaining a crossing-free drawing of a new graph H with nH “ n ` x
vertices. Since H can be drawn on a surface of genus g, it has treewidth at most
Op?g ¨ nHq “ Op
a
gpn ` xqq [16, 20]. Let us fix an optimal tree decomposition
pTH, βHq of the graph H, where TH is the corresponding decomposition tree, and
βH : V pTHq Ñ 2V pHq is the function that assigns to each node q of TH a bag βpqq of
vertices of H of size at most Op
a
gpn ` xqq.
We now modify this decomposition to a tree decomposition of G, as follows. Let
w be any vertex of H that is not a vertex of G. This means that in the original
drawing of G, w corresponded to a crossing of a pair of edges e and f. Let te and tf
be the tails of the two edges. We modify the decomposition pTH, βq by replacing any
occurrence of the vertex w in any of the bags by the two vertices te and tf. After we
perform these replacements for every vertex w P V pHqzV pGq, we may easily check
that we obtain a tree decomposition of G of width at most twice as large as the
width of pTH, βq (see Dujmović et al. [15] for details).
We now have all the ingredients to prove the harder part of Theorem 6.1.
Proposition 6.10. Any X-avoiding class C has wstpC; nq “ Ωp?nq.
Proof. Let π P Sn be a permutation of tree-width Ωpnq (such permutations exist by
a result of Ahal and Rabinovich [1, Theorem 3.4 and Proposition 3.6]). Let us put
t :“ stpC; πq, and let ⃗σ “ pσ1, . . . , σtq be a t-tuple of permutations from C such that
π “ σt ˝ σt´1 ˝ ¨ ¨ ¨ ˝ σ1.
21

--- Page 22 ---
Consider the sorting diagram SD “ SDp⃗σq. By Lemma 6.7, twpSDq ě twpπq “
Ωpnq. On the other hand, SD has p2t ` 1qn vertices, and by Proposition 6.8, it
can be drawn on a surface of genus Optq with Optnq edge-crossings. Therefore, by
Proposition 6.9, SD has tree-width Opt?nq. Combining these bounds, we conclude
that
wstpC; nq ě stpC; πq “ t “ Ωp?nq,
proving the proposition.
To complete the proof of Theorem 6.1, we now turn to upper bounds.
Proposition 6.11. Any X-containing class C has wstpC; nq “ Oplog2 nq.
Proof. It is clearly enough to prove the proposition for a class C that belongs to X.
Let us first consider the monotone juxtapositions, starting with C1 “ Grid
´
¯
. We
may easily observe that wstpC1; nq “ Oplog nq, e.g., by considering the elements of
rns as binary strings of length Oplog nq and sort them using radix-sort, which can be
performed by Oplog nq operations of C1.
With the help of Observation 2.3, we conclude that also the classes Cr
1, C´1
1 , and
pCr
1q´1 have worst-case sorting time Oplog nq.
Consider now the class C2 “ Grid
´
¯
. Notice that C1 Ď C˝2
2 , which implies
wstpC2; nq “ Oplog nq via Observation 2.2. Again, the same bound applies to all
the four symmetries of C2, showing that all the eight monotone juxtapositions have
worst-case sorting time Oplog nq.
We now deal with the four classes L, Lr, PBT and PBT r. Noting that PBT Ď
L˝2, it is enough to prove that wstpPBT ; nq “ Oplog2 nq, and invoke Observations 2.2
and 2.3 to see that the same upper bound applies to the other three classes as well.
Composing a sequence π with a permutation σ P PBT corresponds to parti-
tioning π into an even number of blocks B1B2B3B4 ¨ ¨ ¨ B2k´1B2k, each block being
a (possibly empty) subsequence of consecutive entries of π, and then exchanging
the position of B2j´1 and B2j for each j P rks.
For instance, the permutation
π “ p3, 8, 1, 6, 2, 5, 9, 4, 7q P S9 can be partitioned as B1 “ p3, 8q, B2 “ p1q, B3 “ H,
B4 “ p6, 2q, B5 “ p5, 9, 4q and B6 “ p7q, which after exchanging adjacent odd and
even blocks yields the permutation B2B1B4B3B6B5 “ p1, 3, 8, 6, 2, 7, 5, 9, 4q, which
is equal to σ ˝ π for σ “ p3, 1, 2, 4, 5, 9, 6, 7, 8q P PBT 9.
We now describe a strategy to sort an arbitrary π P Sn by Oplog2 nq steps of the
form described above. We say that an entry πpiq is small if πpiq ď n{2, otherwise it
is large. We will use a divide-and-conquer approach, where in the initial phase, which
will take Oplog nq steps, we move all the small entries to the left of all the large ones,
and then proceed recursively to separately and concurrently sort the small entries
and the large ones.
In the initial phase, in every step we first partition the current input sequence
π1 into small runs and large runs, where a small run is a maximal sequence of
consecutive small values, and a large run is defined similarly. Suppose π1 starts
with a small element, the other case being analogous. It is then partitioned as
S1L1S2L2 ¨ ¨ ¨ SkLk, where each Sj is a small run and Lj a large run, with Lk possibly
empty. Then in a single sorting step, for every even j P rks we exchange the positions
22

--- Page 23 ---
of the Lj´1 and Sj, leaving all the other runs unaffected. In this manner, Sj becomes
adjacent to Sj´1 and Lj (if it exists) to Lj´1. Thus, every small and large run will
merge with another run of the same type, except perhaps the rightmost small run
and the rightmost large run. In Oplog nq steps, we reach a permutation with only a
single small run and a single large run, which can be swapped to ensure that the
small run is to the left of the large one.
We then recursively apply the same strategy to concurrently sort the tn{2u
small elements and the rn{2s large ones. In Oplog2 nq steps, the entire sequence is
sorted.
Propositions 6.10 and 6.11 together prove Theorem 6.1.
We remark that sorting by layered permutations corresponds to sorting by a
sequence of pop-stacks in “genuine series”, which has been considered (for two
pop-stacks) by Atkinson and Stitt [5].
We also note that sorting by layered permutations is related to the setting of
sorting by length-weighted reversals with linear weights, considered by Bender et
al. [8]. More precisely, a single step of sorting by layered permutations can be
simulated by a sequence of length-weighted reversals of total cost Opnq in the linear-
weight setting of [8], and in particular, an improvement to the Oplog2 nq upper bound
for wstpL; nq would also improve the bounds in [8].
7
From Ωplog nq to 1
A simple counting argument, combined with the famous Marcus–Tardos theorem [26]
shows that any proper permutation class C, i.e., a class C not containing all permu-
tations, has at least logarithmic worst-case sorting time.
Proposition 7.1. If C is a permutation class that does not contain all permutations,
then wstpC; nq “ Ωplog nq.
Proof. By the Marcus–Tardos theorem, there is a constant c ą 0 such that |Cn| ď cn
for all n. Consequently, |C˝k
n | ď ckn for any k ě 1. Taking k :“ wstpC; nq yields
n! “ |Sn| “
ˇˇˇˇˇ
kď
m“1
C˝m
n
ˇˇˇˇˇ ď
kÿ
m“1
|C˝m
n | ď kckn,
which implies k “ Ωplog nq.
Obviously, if C is the class of all permutations, then wstpC; nq “ 1 for all n ě 2.
This completes the proof of Theorem 1.1.
8
Conclusion and open problems
The two main open problems concern the two levels of our hierarchy where we do
not have matching upper and lower bounds. Recall that the set X contains the eight
monotone juxtapositions, the class L of layered permutations, its reverse Lr, the
class PBT of parallel block transpositions, and its reversal PBT r. We know that
23

--- Page 24 ---
for any monotone juxtaposition, the worst-case sorting time is Θplog nq, but for L,
PBT and their symmetries, we only have a lower bound of order Ωplog nq and an
upper bound of order Oplog2 nq.
Note that Observations 2.2 and 2.3 imply that wstpL; nq “ ΘpwstpLr; nqq,
wstpPBT ; nq “ ΘpwstpPBT r; nqq, and wstpL; nq “ OpwstpPBT ; nqq. We can there-
fore restrict our attention to L and PBT .
Problem 8.1. What is the worst-case sorting time of the class L of layered permu-
tations, and of the class PBT of parallel block transpositions?
Another gap in our bounds concerns the broad family of X-avoiding classes.
We proved that any X-avoiding class has worst-case sorting time of order Ωp?nq.
However, every example of such a class that we know of has worst-case sorting time
of order Ωpnq, suggesting that the lower bound can be further improved.
Problem 8.2. Is there an X-avoiding class C with wstpC; nq “ opnq?
References
[1] S. Ahal and Y. Rabinovich.
On complexity of the subpattern problem.
SIAM Journal on Discrete Mathematics, 22(2):629–649, 2008. doi:10.1137/
S0895480104444776.
[2] M. H. Albert, M. D. Atkinson, M. Bouvel, N. Ruškuc, and V. Vatter. Geometric
grid classes of permutations. Trans. Amer. Math. Soc., 365(11):5859–5881, 2013.
doi:10.1090/S0002-9947-2013-05804-7.
[3] M. H. Albert, C. Homberger, J. Pantone, N. Shar, and V. Vatter. Generating
permutations with restricted containers. Journal of Combinatorial Theory,
Series A, 157:205–232, 2018. doi:10.1016/j.jcta.2018.02.006.
[4] M. D. Atkinson and R. Beals. Permutation involvement and groups. Q. J.
Math., 52(4):415–421, 2001. doi:10.1093/qjmath/52.4.415.
[5] M. D. Atkinson and T. Stitt. Restricted permutations and the wreath product.
Discrete Math., 259(1-3):19–36, 2002. doi:10.1016/S0012-365X(02)00443-0.
[6] L. Babai and Ákos Seress. On the diameter of Cayley graphs of the symmetric
group. Journal of Combinatorial Theory, Series A, 49(1):175–179, 1988. doi:
10.1016/0097-3165(88)90033-7.
[7] V. Bafna and P. A. Pevzner. Genome rearrangements and sorting by reversals.
In 34th Annual Symposium on Foundations of Computer Science (Palo Alto,
CA, 1993), pages 148–157. IEEE Comput. Soc. Press, Los Alamitos, CA, 1993.
doi:10.1109/SFCS.1993.366872.
[8] M. A. Bender, D. Ge, S. He, H. Hu, R. Y. Pinter, S. Skiena, and F. Swidan.
Improved bounds on sorting by length-weighted reversals. J. Comput. System
Sci., 74(5):744–774, 2008. doi:10.1016/j.jcss.2007.08.008.
24

--- Page 25 ---
[9] S. Bhatia, P. Feijão, and A. R. Francis. Position and content paradigms in
genome rearrangements: the wild and crazy world of permutations in genomics.
Bull. Math. Biol., 80(12):3227–3246, 2018. doi:10.1007/s11538-018-0514-3.
[10] M. Bóna. A survey of stack-sorting disciplines. Electron. J. Combin., 9(2):Article
1, 16, 2002/03. Permutation patterns (Otago, 2003). doi:10.37236/1693.
[11] L. Bulteau, G. Fertin, and I. Rusu. Pancake flipping is hard. J. Comput. System
Sci., 81(8):1556–1574, 2015. doi:10.1016/j.jcss.2015.02.003.
[12] G. Cerbai, A. Claesson, and L. Ferrari. Stack sorting with restricted stacks.
J. Combin. Theory Ser. A, 173:105230, 19, 2020. doi:10.1016/j.jcta.2020.
105230.
[13] G. Cerbai, A. Claesson, L. Ferrari, and E. Steingrímsson. Sorting with pattern-
avoiding stacks: the 132-machine. Electron. J. Combin., 27(3):Paper No. 3.32,
27, 2020. doi:10.37236/9642.
[14] G. Cerbai and L. Ferrari.
Permutation patterns in genome rearrangement
problems: The reversal model. Discrete Applied Mathematics, 279:34–48, 2020.
doi:10.1016/j.dam.2019.10.012.
[15] V. Dujmović, D. Eppstein, and D. R. Wood. Structure of graphs with locally
restricted crossings. SIAM J. Discrete Math., 31(2):805–824, 2017. doi:10.
1137/16M1062879.
[16] Z. Dvořák and S. Norin. Treewidth of graphs with balanced separations. Journal
of Combinatorial Theory, Series B, 137:137–144, 2019. doi:10.1016/j.jctb.
2018.12.007.
[17] A. Elvey Price and A. J. Guttmann. Permutations sortable by two stacks in
series. Advances in Applied Mathematics, 83:81–96, 2017. doi:10.1016/j.aam.
2016.09.003.
[18] G. Fertin, A. Labarre, I. Rusu, E. Tannier, and S. Vialette. Combinatorics
of genome rearrangements.
Computational Molecular Biology. MIT Press,
Cambridge, MA, 2009. doi:10.7551/mitpress/9780262062824.001.0001.
[19] W. H. Gates and C. H. Papadimitriou. Bounds for sorting by prefix reversal.
Discrete Math., 27(1):47–57, 1979. doi:10.1016/0012-365X(79)90068-2.
[20] J. R. Gilbert, J. P. Hutchinson, and R. E. Tarjan. A separator theorem for
graphs of bounded genus. Journal of Algorithms, 5(3):391–407, 1984. doi:
10.1016/0196-6774(84)90019-1.
[21] N. Habermann. Parallel neighbor-sort (or the glory of the induction principle).
Technical Report, 1972.
[22] C. Homberger and V. Vatter. On the effective and automatic enumeration of
polynomial permutation classes. J. Symbolic Comput., 76:84–96, 2016. doi:
10.1016/j.jsc.2015.11.019.
25

--- Page 26 ---
[23] S. Huczynska and V. Vatter. Grid classes and the Fibonacci dichotomy for
restricted permutations. Electron. J. Combin., 13(1):Research Paper 54, 14,
2006. doi:10.37236/1080.
[24] J. Kececioglu and D. Sankoff. Exact and approximation algorithms for sorting
by reversals, with application to genome rearrangement. Algorithmica, 13(1-
2):180–210, 1995. doi:10.1007/BF01188586.
[25] D. E. Knuth. The Art of Computer Programming, Volume I: Fundamental
Algorithms. Addison-Wesley, 1968.
[26] A. Marcus and G. Tardos. Excluded permutation matrices and the Stanley-Wilf
conjecture. J. Combin. Theory Ser. A, 107(1):153–160, 2004. doi:10.1016/j.
jcta.2004.04.002.
[27] R. Tarjan. Sorting using networks of queues and stacks. J. Assoc. Comput.
Mach., 19:341–346, 1972. doi:10.1145/321694.321704.
[28] V. Vatter. Small permutation classes. Proc. Lond. Math. Soc. (3), 103(5):879–
921, 2011. doi:10.1112/plms/pdr017.
[29] V. Vatter. An Erdős-Hajnal analogue for permutation classes. Discrete Math.
Theor. Comput. Sci., 18(2):Paper No. 4, 5, 2016. doi:10.46298/dmtcs.1328.
26
