{
  "progress_md": "Headlines\n- Model identification: each step is a parallel adjacent block transposition, i.e., the class PBT in Jel\u00ednek\u2013Opler\u2013Pek\u00e1rek (arXiv:2311.08727). So we study the PBT-sorting time of the specific input \u03c0 = bit-reversal on n = 2^d.\n- Known bounds from 2311.08727: wstp(PBT; n) = O(log^2 n); lower bound \u2126(log n) for any proper class. The tight bound for PBT (and layered L) is explicitly left open; proving \u2126(log^2 n) for the bit-reversal input would improve the general lower bound for PBT.\n- Proposed potential \u03a6(A) = \u03a3_j D_j(A), with D_j(A) := |log_2 B_j(A) \u2212 (d \u2212 j)|, where B_j(A) is the number of monochromatic runs under coloring by bit j. For the bit-reversal input A_0, \u03a3_j D_j(A_0) = \u0398(d^2) = \u0398(log^2 n). Goal: per step drop \u0394\u03a6 = O(1).\n\nNew rigor (small lemmas), why useful, and proofs/sketches\n1) Equivalence to PBT (why useful: aligns our model with the literature and its O(log^2 n) upper bound, and frames the task as a special-case lower bound within their class hierarchy).\n- In one step we partition into consecutive intervals and swap disjoint adjacent pairs of intervals in parallel. This is precisely a composition with an element of the class PBT (parallel block transpositions), namely a permutation obtained as a sum of rotations on the interval decomposition. Therefore \u201cour model\u201d = sorting by PBT.\n\n2) Exact values B_j at the endpoints (why useful: calibrates the potential function).\n- For n=2^d and the bit-reversal input A_0, B_j(A_0) = 2^{j+1} (j=0,\u2026,d\u22121). For the fully sorted order A_\u22c6, B_j(A_\u22c6) = 2^{d\u2212j}. Thus D_j(A_0) = |(j+1) \u2212 (d\u2212j)| = |2j+1\u2212d| and\n  \u03a3_{j=0}^{d\u22121} D_j(A_0) = \u0398(d^2) = \u0398(log^2 n).\n\n3) Per-level \u201cadditive\u201d change bound via local boundary accounting (why useful: bounds how much B_j can move in one step in terms of which array boundaries are affected).\n- Fix j. Let T_j(A) \u2286 {1,\u2026,n\u22121} be the set of indices i where the j-color changes between positions i and i+1; so |T_j(A)| = B_j(A) \u2212 1.\n- One step picks disjoint adjacent interval pairs (L_k, R_k). For each matched pair there are exactly three index positions whose adjacent pair changes: the boundary before L_k, the boundary between L_k and R_k, and the boundary after R_k. All other internal adjacencies remain unchanged.\n- Hence the symmetric difference T_j(A) \u0394 T_j(A\u2032) is contained in the set S_step of indices altered by this step, with |S_step| \u2264 3\u00b7(# matched pairs). Consequently, for every j we have |B_j(A\u2032) \u2212 B_j(A)| \u2264 |T_j(A\u2032) \u0394 T_j(A)| \u2264 3\u00b7(# pairs).\n- Remark: this by itself is too coarse for our \u2126(log^2 n) goal, because the number of pairs can be \u0398(n) in a step. It does, however, isolate that only the 3-per-pair boundary changes can affect B_j.\n\n4) Per-level \u201cuseful boundary\u201d refinement (why useful: ties the change in B_j to current j-run structure, not to the raw number of pairs).\nClaim 4.1. For fixed j, a matched pair can change B_j only if at least one of its three altered indices is either (i) itself in T_j(A), or (ii) adjacent to a run boundary in the following sense: the altered index shares one of its incident positions with a j-run boundary in A.\n- Rationale. If both positions adjacent to an altered index belong to the same j-run and neither end of the index abuts a j-run boundary in A, then the two items at that index (pre- and post-step) both come from the same j-run; in particular they have the same j-color both before and after, so the indicator \u201ci \u2208 T_j(\u00b7)\u201d cannot flip at that index.\n- Consequence. Let U_j(A) be the set of indices that are in T_j(A) or adjacent to an element of T_j(A). Then |U_j(A)| \u2264 3\u00b7|T_j(A)| = 3(B_j(A) \u2212 1). The number of indices at which T_j-membership can possibly change in one step is \u2264 |U_j(A)|. Therefore\n  |B_j(A\u2032) \u2212 B_j(A)| \u2264 |T_j(A\u2032) \u0394 T_j(A)| \u2264 |U_j(A)| \u2264 3(B_j(A) \u2212 1).\n- Corollary 4.2 (per-level constant-factor cap). For any A\u2192A\u2032 in one step and any j,\n  B_j(A\u2032) \u2264 4\u00b7B_j(A) and B_j(A) \u2264 4\u00b7B_j(A\u2032). Equivalently, |log_2 B_j| changes by at most 2 per step.\nProof. From the inequality above, B_j(A\u2032) \u2264 B_j(A) + 3(B_j(A) \u2212 1) \u2264 4B_j(A). Apply the same inequality to the inverse step (also a PBT step) to get the reverse inequality.\n- Comment. The factor 4 is certainly improvable; I suspect factor 2 holds, but a clean proof that avoids overcounting \u201cdouble-adjacent\u201d alterations requires a tight charging scheme. Even factor 4 already implies |\u0394 log_2 B_j| \u2264 2.\n\n5) Alignment scarcity of cut positions across bit-levels (why useful: a quantitative cross-level restriction for the bit-reversal input A_0).\nLemma 5.1 (dyadic alignment bound). For the bit-reversal input A_0, let G_j \u2286 {1,\u2026,n\u22121} denote the set of j-run boundary indices (so |G_j| = B_j(A_0) \u2212 1 = 2^{j+1} \u2212 1). For any set S of partition cut positions (i.e., indices where we place interval boundaries in a step),\n  \u03a3_{j=0}^{d\u22121} |S \u2229 G_j| = \u03a3_{i\u2208S} (1 + v_2(i)) \u2264 |S|(1 + \u230alog_2(n\u22121)\u230b).\n- Proof. In A_0 the j-run boundaries are the indices i divisible by 2^{d\u2212j\u22121}. Equivalently, i \u2208 G_j iff d\u2212j\u22121 \u2264 v_2(i), where v_2(i) is the 2-adic valuation. Thus for a fixed i, the set {j: i \u2208 G_j} has size 1+v_2(i). Summing over S and using v_2(i) \u2264 \u230alog_2 i\u230b \u2264 \u230alog_2(n\u22121)\u230b gives the bound.\n- Intuition: a single cut index can be simultaneously \u201cuseful\u201d for only O(log n) bit-levels; hence even very fine partitions cannot align with all bit-level boundaries at once at linear density.\n\nSmall examples and sanity checks\n- n=8, A_0 = [0,4,2,6,1,5,3,7]. B_0=2, B_1=4, B_2=8. If we partition into singletons and match (1,2), (3,4), (5,6), (7,8), the three indices that change per matched pair are exactly the three boundaries around each pair; but for j=0 only the central boundary near the 0/1 split can be \u201cuseful\u201d. Empirically B_0 cannot jump from 2 to \u0398(n) in one step; more generally, the useful-boundary lemma predicts |\u0394B_0| \u2264 3(B_0\u22121) = 3.\n- For j = d\u22121 (MSB) at A_0, B_{d\u22121} = 2^d = n. Then |\u0394B_{d\u22121}| \u2264 3(n\u22121) is trivially true; the interesting regime is small j where B_j is small. There, Lemma 4.1 caps the number of useful indices by O(B_j), consistent with the block-coalescence intuition.\n\nWhy these are not yet enough for \u2126(log^2 n)\n- The \u201cper-level constant factor cap\u201d (even with factor 2) alone only yields that each D_j can decrease by O(1) per step; summing over all levels gives \u0394\u03a6 = O(d) per step, implying only \u2126(d) steps. To reach \u2126(d^2) we need to argue that only O(1) levels can enjoy constant-factor progress in the same step (a cross-level scarcity lemma).\n- A naive \u201ccapacity\u201d counting using \u03a3_j B_j(A_0) = \u0398(n) and the observation that a matched pair of size L influences \u2248 L/\u2113_j boundaries at level j (where \u2113_j = 2^{d\u2212j\u22121} is the j-run length in A_0) suggests that simultaneously reducing B_j by a constant factor across many j is not obviously impossible: \u03a3_j (L/\u2113_j) = O(L), and \u03a3_j B_j(A_0) = \u0398(n). So simple one-dimensional capacity arguments do not create a missing log factor.\n- The alignment lemma (Lemma 5.1) shows a single cut index hits O(log n) levels, but a partition has |S| \u2248 n cuts in the extreme, and |S|\u00b7log n is still big enough to interact with all levels in principle. So we need a stronger statement than mere counting of aligned cuts; we must quantify how many aligned cuts are actually needed to produce constant-factor changes in B_j and show that a single partition cannot simultaneously supply that demand for many j.\n\nObstacles and gaps (explicit)\n- The factor-2 per-level cap is plausible but not yet proved cleanly; I gave a rigorous factor-4 cap (Corollary 4.2). Improving this constant strengthens the per-level bound but does not yet give \u2126(log^2 n).\n- The key missing piece is a robust cross-level scarcity theorem. The naive union bound over cuts (Lemma 5.1) is insufficient\u2014the capacity vs. demand calculation doesn\u2019t produce an extra log. We need a structural reason why the same set of disjoint adjacent block swaps cannot simultaneously realize the \u201cgood pairings\u201d of runs required for constant-factor reduction at many distinct bit-levels.\n- There is no output.md provided; thus far there is no curated, rigorously proved result beyond the baseline \u2126(log n). Our Lemma 3\u20135 fill some pieces but do not yet imply \u2126(log^2 n).\n\nIdeas for next steps (testable subgoals)\n- Strengthen the per-level cap: Aim to prove B_j(A\u2032) \u2264 2\u00b7B_j(A) and B_j(A) \u2264 2\u00b7B_j(A\u2032) in one step for every j. Strategy: refine the \u201cuseful boundary\u201d charging so that every index whose membership toggles is charged to a unique j-run boundary in A or in A\u2032, and each boundary receives O(1) charge. This would give |\u0394 log_2 B_j| \u2264 1 per step.\n- Quantify \u201cdemand\u201d to get constant-factor progress at a fixed j: Formalize that reducing B_j by a factor of 1\u2212\u03b5 requires selecting cuts that microscopically pair (most of) adjacent j-runs in an alternating fashion. Prove that such a pairing demands \u03a9(B_j) central cuts specifically at the j-run boundaries (not just adjacency to them) and also constraints on which of those cuts are matched. This could lift the per-level demand from mere \u0398(B_j) \u201ctouched indices\u201d to \u0398(B_j) \u201ccentral matched boundaries,\u201d which then interacts more tightly across levels via disjointness of pairs.\n- Cross-level conflict via disjointness: For A_0 the sets of j-run boundaries form a family of dyadic arithmetic progressions. Try to show that if you match central boundaries to reduce B_j substantially, those same matched pairs necessarily misalign with the central boundaries needed to reduce B_k for |k\u2212j| large; i.e., central boundaries for different j\u2019s largely do not coincide and cannot all be matched at once due to disjointness of pairs. Precise goal: For any partition+matching M, let C_j(M) be the number of matched central boundaries that lie in G_j. Prove \u03a3_j C_j(M)/B_j \u2264 O(1) (or at least O(log n)). This would imply that only O(1) (or O(log n)) levels can see constant-factor progress in a single step.\n- Computational probe (n=16,32): Enumerate partitions+matchings from A_0 (up to symmetries), compute all B_j before/after, and record which levels see \u22652\u00d7 change. This can guide a conjecture on an absolute bound for the number of such levels per step.\n- Alternative potentials: Explore weighted potentials that penalize \u201csimultaneous progress across many j\u201d more severely, e.g., \u03a6_\u03b1(A) = \u03a3_j \u03b1^{|2j+1\u2212d|}\u00b7|log_2 B_j(A) \u2212 (d\u2212j)| for \u03b1>1, and try to prove a per-step drop independent of d. This would hinge on relating the weights to the dyadic structure of G_j.\n- Connection to known open problem: If we can show the desired cross-level scarcity for the specific A_0, it already yields \u2126(log^2 n) for bit-reversal under PBT and strictly improves the general lower bound for the class. Even a weaker statement like \u201cin any step, at most O(1) levels with |2j+1\u2212d| \u2265 c\u00b7d see constant-factor progress\u201d would imply a near-\u2126(log^2 n) bound.\n\nSummary\n- Formalized that our model is exactly PBT.\n- Established a clean per-step per-level bound: |\u0394B_j| \u2264 3(B_j\u22121) \u21d2 a constant-factor cap B_j\u2032/B_j \u2264 4 (factor likely improvable to 2). This justifies that |\u0394 log B_j| is O(1) per level per step.\n- Proved an \u201calignment scarcity\u201d lemma (Lemma 5.1) for A_0: a cut position can be aligned with at most O(log n) levels j. This is a building block towards a cross-level scarcity theorem, but by itself not sufficient.\n- Identified the main obstacle: converting alignment scarcity and disjointness of matched pairs into a sharp bound on how many levels can make constant-factor progress in the same step.\n- Outlined concrete next steps: (i) tighten the per-level cap to factor 2; (ii) quantify per-level demand in terms of central matched boundaries; (iii) prove a cross-level trade-off \u03a3_j C_j(M)/B_j \u2264 O(1); (iv) run small-n experiments to test these phenomena.\n"
}