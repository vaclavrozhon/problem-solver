--- SYSTEM ---
You are a research **summarizer**. Summarize this *last round only* for a human log.

Include:
- 3–7 bullet **Highlights** (facts learned, reductions, counterexamples, partial bounds).
- 1–3 **Open questions / TODOs** for the next round.
- 1–3 **Citations to files** you relied on (e.g. round files or papers by name).

**Return strictly JSON**:
{
  "summary_md": "Readable summary of the round (≤200 words)",
  "highlights": [],
  "next_questions": []
}

--- USER ---
=== prover-01.out.json (progress_md) ===
Headlines
- New rigorous, step-local identities for how B_j changes: an exact toggle-count formula restricted to the set S of the at-most-3-per-pair indices whose adjacency actually changes. Two immediate corollaries quantify how much B_j can decrease (or increase) in terms of how many of these changed indices hit current j-boundaries. These identities are clean, model-agnostic, and ready to be curated.
- Clarification: The “useful boundary adjacency” heuristic is invalid in general (as already noted in notes.md). The correct locality is at the changed indices S only; nothing else can contribute in a step.
- Programmatic next step: Use the toggle-count identity plus the dyadic alignment structure of A_0 to lower bound the necessary “central hits” at many levels at once. I outline a restricted (equal-scale, grid-aligned) special case that can likely be proved fully and would yield an Ω(log^2 n) bound for that restricted class.

Formal statements and proofs (new, ready to curate)
1) Lemma (toggle-locality identity and signed change at level j).
- Setup. Let A→A′ be any single PBT step, and S⊆{1,…,n−1} be the set of indices whose adjacency changes in this step (i.e., the three indices around each matched pair: left outer, inner, right outer). For j∈{0,…,d−1}, let T_j(A) be the set of j-run boundary indices of A.
- Claim. For every j,
  B_j(A′) − B_j(A) = |T_j(A′) ∩ S| − |T_j(A) ∩ S|.
- Proof. By definition, all adjacencies outside S are identical in A and A′, hence their membership in T_j(·) is unchanged. Thus T_j(A′) Δ T_j(A)⊆S, and
  |T_j(A′)| − |T_j(A)| = |T_j(A′)∩S| − |T_j(A)∩S|.
Since B_j(·)=|T_j(·)|+1, the identity follows. ∎

Corollary 1.1 (one-sided bounds per level).
- For every j,
  Decrease_j := max{0, B_j(A) − B_j(A′)} ≤ |T_j(A) ∩ S|,
  Increase_j := max{0, B_j(A′) − B_j(A)} ≤ |S\T_j(A)|.
- Proof. From the identity, B_j(A) − B_j(A′) = |T_j(A)∩S| − |T_j(A′)∩S| ≤ |T_j(A)∩S|, and similarly for increases. ∎

Remarks on usefulness.
- This exposes the exact “demand”: shrinking B_j by Δ forces at least Δ of the changed indices to land on T_j(A). For A=A_0 (bit-reversal), T_j(A)=G_j are dyadic arithmetic progressions, so we can quantify how often a single changed index can service many levels via v_2(i).
- It also yields the previously curated factor-4 cap as a very special (and weaker) consequence when combined with the disjointness-of-unions argument (only O(B_j) pairs can intersect T_j(A)). More importantly, it is sharp enough to support cross-level trade-off inequalities.

2) Lemma (alignment counting at A_0, restated with weights).
Let A=A_0 and G_j be the j-boundary set at A_0. For any set of changed indices S (from an arbitrary step):
  Σ_{j=0}^{d−1} |S ∩ G_j| = Σ_{i∈S} (1+v_2(i)).
In particular, for any weights a_j≥0,
  Σ_j a_j·|S∩G_j| = Σ_{i∈S} Σ_{j: 2^{d−1−j}|i} a_j.
- Proof. As in Theorem 4 of output.md; I include the flexible weighted form since we will need to choose tailored a_j.

Immediate consequences and their limits
- Using Cor. 1.1 with A=A_0 gives Σ_j Decrease_j ≤ Σ_j |S∩G_j| = Σ_{i∈S}(1+v_2(i)). This shows that the total number of j-boundaries removed in a single step is at most the “alignment budget” Σ_i(1+v_2(i)). Since 1+v_2(i) ≤ 1+⌊log_2(n−1)⌋, we get the coarse bound Σ_j Decrease_j ≤ |S|·O(log n).
- This is not yet strong enough to force an O(1) drop of the log-gap potential per step (the step may create increases elsewhere, and |S| can be Θ(n)), but it is the right necessary-condition inequality to drive sharper cross-level trade-offs (see Next steps).

Restricted special case towards cross-level scarcity (equal-scale, grid-aligned)
- Definition (equal-scale, grid-aligned step). Fix L a power of two. A step is L-aligned if (i) every matched pair consists of two adjacent intervals each of length in [L,2L), and (ii) all inner boundaries of matched pairs occur at indices divisible by L (i.e., central cuts lie on the L-grid). This is a strong but natural restriction; many plausible blockwise algorithms satisfy it in phases.
- Claim (to be proved next; sketch here). In an L-aligned step from A_0, at most O(1) bit-levels j with 2^{d−1−j}∈[L/2,2L] can shrink B_j by a constant factor; all other levels change by at most o(B_j). Outline:
  • By Cor. 1.1, to reduce B_j by θ·B_j we need |S∩G_j| ≥ θ·B_j − |S\G_j|. Since all inner boundaries lie on the L-grid and all outer boundaries are spaced by at least L (due to equal-scale blocks), |S∩G_j| is Θ(#pairs) if and only if the two grids (L and 2^{d−1−j}) are commensurate: specifically, if 2^{d−1−j}∈[L/2,2L]. Otherwise |S∩G_j|/B_j=O(2^{d−1−j}/L) or O(L/2^{d−1−j}), which is o(1), precluding constant-factor change by Lemma 1.
  • Moreover, only O(1) consecutive j satisfy 2^{d−1−j}∈[L/2,2L]. Thus per step only O(1) “active levels” can reduce by a constant factor. Combining with the per-level factor cap (Theorem 3) bounds the per-step drop of Σ_j |log_2 B_j − (d−j)| by O(1) in this restricted regime.
- Status: The combinatorics of outer-boundary contributions needs a careful bound to ensure |S\G_j| does not swamp the inequality; but because outer boundaries per pair are only 2 and lie on the same L-grid offsets, the o(B_j) estimate for off-scale j is achievable. I will write this rigorously next.

Why the “useful-boundary” heuristic fails and how the new lemma fixes the issue
- Earlier “U_j” (indices adjacent to boundaries) is not a certificate. A changed index far from T_j(A) can certainly toggle membership at j depending on the imported endpoints. The correct locality is: only the indices whose adjacencies change (S) can flip membership; among them, a decrease of B_j can only occur on those that were in T_j(A) (Cor. 1.1). This is the precise and minimal condition we need.

A small but precise trade-off for A_0 (weighted decreases)
- For A=A_0 and any step, Cor. 1.1 plus weighted alignment gives
  Σ_{j=0}^{d−1} 2^{−(j+1)}·Decrease_j ≤ Σ_{i∈S} Σ_{j: i∈G_j} 2^{−(j+1)}.
For i with v_2(i)=t, the inner sum equals Σ_{j≥d−1−t} 2^{−(j+1)} = 2^{−(d−t)}(1−2^{−(t+1)}) ≤ 2^{−d+t}.
Therefore Σ_j 2^{−(j+1)}·Decrease_j ≤ Σ_{i∈S} 2^{−d+v_2(i)}.
- Crude bound: since v_2(i) ≤ ⌊log_2 i⌋ ≤ d−1, the RHS ≤ |S|/2. This is not strong enough by itself, but it is an exact accounting that we can pair, in the equal-scale regime, with commensurability to limit |S∩G_j| where it matters.

Checks on small n
- For n=8 (A_0=[0,4,2,6,1,5,3,7]), Cor. 1.1 predicts that B_0 can decrease only if S contains the unique G_0 index (the middle cut); indeed, experiments confirm B_0 changes by at most O(1) per step. For B_1, G_1 are indices 2,4,6; placing inner boundaries on these is necessary for noticeable decrease; changing other indices primarily increases B_1.

Gaps in output.md
- The current output.md includes Theorem 3 (factor-4 cap) proved by bounding |ΔB_j| via the number of pairs that intersect T_j(A). This is correct as written. However, for subsequent stronger trade-offs we need the toggle-locality identity (new Lemma 1) and its corollary as they cleanly separate (i) where decreases can happen (only at S∩T_j(A)) from (ii) where increases can happen (only at S\T_j(A)). I recommend curating Lemma 1 and Cor. 1.1 next.

Obstacles and what failed (crisp)
- A previously sketched “size lemma” Δ_j ≤ C·Σ_p min{1, s(p)/L_j} is false; changed adjacencies are only three per pair and independent of s(p).
- Cross-level scarcity in full generality cannot rely purely on counting |S|, because each changed index can be “relevant” to O(log n) levels at A_0 (via v_2(i)), and |S| can be Θ(n).
- Weighting arguments that sum ΔB_j/B_j(A_0) over j yield bounds of order |S| (too large) unless we impose structural constraints (equal-scale, grid alignment) to force commensurability conflicts.

Next steps (concrete, testable)
1) Curate Lemma 1 (toggle-locality identity) and Cor. 1.1. These are simple, exact, and will be repeatedly used.
2) Prove the equal-scale, grid-aligned cross-level scarcity claimed above. The key is to bound |S∩G_j|/B_j for off-scale j by o(1) using simple arithmetic progression intersection counts and the fact that inner cuts lie on the L-grid, while outer cuts contribute only O(#pairs) uniformly spread on that grid.
3) Generalize from exact alignment to “near alignment”: pairs with lengths in [L,2L) but inner boundaries allowed to drift; show via a pigeonhole/averaging over residues modulo L that one residue class captures a constant fraction, hence we can apply the aligned argument to that fraction, obtaining the same O(1) active-level cap (up to constants).
4) Experiments for n=64,128: enumerate random equal-scale partitions for several L and measure, per step, the number of j with B_j reduced by ≥1/2. We expect this number to be O(1) near levels with 2^{d−1−j}≈L and near zero for others. Record distributions to calibrate constants.
5) With the scarcity lemma in hand for each equal-scale phase, layer phases across L=1,2,4,… to argue that Σ_j |log_2 B_j − (d−j)| drops by at most O(1) per phase. This would yield Ω(log^2 n) steps for any algorithm restricted to equal-scale phases. Later, try to remove the restriction by decomposing an arbitrary step into O(1) “scale bins” (pigeonhole) and charging the potential drop to those bins.

Why this is promising
- The toggle-locality identity provides the right “demand certificate” per level j in terms of S∩T_j(A). In the A_0 regime, T_j(A) are dyadic grids, and equal-scale steps naturally constrain S to near-periodic grids; this sets up an arithmetic progressions intersection framework that is well suited to proving the desired O(1) active-level cap per step.


=== prover-02.out.json (progress_md) ===
Headlines
- Fix a gap in output.md: the phrase “all other internal adjacencies remain unchanged” is false as stated; what is true (and sufficient) is that the number of j-boundaries internal to each block is preserved by a block swap, hence the net change in B_j is fully determined by the three interface indices per swapped pair.
- New per-pair inequality: for any fixed bit-level j and any single matched pair (L,R), the contribution to ΔB_j from that pair is in [−2,2]. Summing over pairs that are non-monochromatic at level j yields |ΔB_j| ≤ 2·(# such pairs).
- Consequence: a per-level factor-3 cap per step: B_j(A′) ≤ 3 B_j(A) and B_j(A) ≤ 3 B_j(A′). This improves Theorem 3’s factor-4 to factor-3.
- Equal-scale first-step scarcity (from A_0): if all matched pairs have total size s in [L,2L], then only levels j with run-length L_j ≤ s can be affected (and |ΔB_j| ≤ 2·(n/s)), hence only O(1) adjacent levels around the “home scale” L_j≈L can undergo constant-factor changes in that first step.

Corrections to output.md (local, not changing statements)
- The proof of Theorem 3 currently says “all other internal adjacencies remain unchanged”. This is false literalistically—after swapping L and R the identities of the adjacent pairs across internal indices do change. What holds (and is enough) is:
  • For any fixed j, the number of j-boundaries internal to L (and to R) is preserved by the swap, because the internal order within L and within R does not change.
  • Therefore the net change in the total number of j-boundaries across the union U = L∪R equals the change across the three interface indices: (left outer, inner, right outer). Summing over disjoint pairs yields that ΔB_j equals the sum of changes at 3·(#pairs) interface indices. This validates the “three indices per pair” counting for the change in the number (though not for the set) of boundaries.

New technical lemmas and proofs
- Lemma A (binary 4-cycle inequality). For any bits p,q,r,s ∈ {0,1}, one has [p≠q]+[q≠r]+[r≠s]−[s≠p] ≤ 2 and also ≥ −2.
  Proof. Consider the 4-cycle p−q−r−s−p. The sum S := [p≠q]+[q≠r]+[r≠s]+[s≠p] is even and at most 4. Then [p≠q]+[q≠r]+[r≠s]−[s≠p] = S − 2·[s≠p] ∈ {−2,0,2}.

- Lemma B (per-pair ±2 contribution). Fix level j. Let a_L be the j-color of the outside neighbor left of L; a_R the j-color of the outside neighbor right of R; and let L_1,L_k (first/last j-colors of L), R_1,R_m (first/last j-colors of R). For the matched pair (L,R), let Δ_pair denote its contribution to ΔB_j (i.e., the change in the number of j-boundaries inside U=L∪R, which equals the change across the three interfaces as noted above). Then |Δ_pair| ≤ 2.
  Proof. Using the notation x_a=[a_L≠L_1], y_a=[a_L≠R_1], x_b=[L_k≠R_1], y_b=[R_m≠L_1], x_c=[R_m≠a_R], y_c=[L_k≠a_R], one has Δ_pair = (x_a+x_b+x_c)−(y_a+y_b+y_c). By triangle inequalities [q≠x]−[q≠y] ≤ [x≠y], we get x_a−y_a ≤ [L_1≠R_1] and x_c−y_c ≤ [R_m≠L_k]. Hence
    Δ_pair ≤ [L_1≠R_1] + [R_m≠L_k] + (x_b−y_b)
            = [L_1≠R_1] + [R_m≠L_k] + ([L_k≠R_1] − [R_m≠L_1]).
  Applying Lemma A with (p,q,r,s)=(L_1,R_1,L_k,R_m) gives Δ_pair ≤ 2. The lower bound Δ_pair ≥ −2 follows symmetrically (or by applying the same argument to the inverse swap).∎

- Lemma C (counting pairs that can matter at level j). If the union U=L∪R is j-monochromatic in A (equivalently in A′), then Δ_pair=0. Therefore, letting M_j(A) be the set of matched pairs whose union is not j-monochromatic in A, we have |ΔB_j| ≤ 2·|M_j(A)|.
  Proof. If U is j-monochromatic, then L_1=L_k=R_1=R_m, hence all three interface indicators are unchanged and Δ_pair=0. Summing Lemma B over pairs in M_j(A) yields the claim.∎

- Theorem 3′ (per-level factor-3 cap). For any A→A′ in one step and any j,
  B_j(A′) ≤ 3·B_j(A) and B_j(A) ≤ 3·B_j(A′).
  Proof. As in output.md, every pair whose union is j-monochromatic gives Δ_pair=0; the remaining pairs are at most |T_j(A)|=B_j(A)−1 by disjointness (charge each such pair to, say, its leftmost internal j-boundary). Then
    |B_j(A′) − B_j(A)| ≤ ∑_{pairs} |Δ_pair| ≤ 2·|M_j(A)| ≤ 2(B_j(A)−1),
  which implies B_j(A′) ≤ B_j(A) + 2(B_j(A)−1) ≤ 3B_j(A). Apply the bound to the inverse step for the reverse inequality.∎
  Remark. This improves the factor-4 cap to factor 3 and implies |Δ log_2 B_j| ≤ log_2 3 per step.

First-step equal-scale scarcity from A_0
- Setup. Let A=A_0 be the bit-reversal input. Fix a step whose matched pairs all have total size s in [L,2L]. Recall L_j=2^{d−1−j} is the j-run length in A_0, and B_j(A_0)=2^{j+1}.
- Observation. If L_j > s then every union U=L∪R is j-monochromatic in A_0, hence by Lemma C the step has ΔB_j=0. Therefore only levels j with L_j ≤ s can be affected at all. Equivalently, j ≥ d−1−⌊log_2 s⌋.
- Bound on magnitude. The number of matched pairs m satisfies m·s ≤ n, hence m ≤ n/s. By Lemma B, |ΔB_j| ≤ 2m ≤ 2n/s for every j. Thus for any j with L_j ≪ s the relative change is tiny at A_0: |ΔB_j|/B_j(A_0) ≤ (2n/s)/2^{j+1} = 2·(2^{d−j−1}/s) = 2·(L_j/s).
- Consequence (first-step “active levels”). For a constant-factor change (say a ≥ 2× drop) at level j we need |ΔB_j| ≥ B_j(A_0)/2 = 2^{j}/2. The bound above forces L_j ≳ s (indeed L_j ≥ s/4 suffices to violate). Hence, in such an equal-scale step from A_0, only those j with L_j within a constant factor of s can undergo a constant-factor change. There are O(1) such adjacent levels.
- Why useful. This is a clean, checkable special case of the sought cross-level scarcity: in an equal-scale step, only O(1) levels can progress by a constant factor from A_0. It suggests the “home level” approach: pairs of size s are only capable of large impact around the dyadic scale L_j≈s.

Examples and sanity checks (n=16)
- Take A_0=[0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15]. For j=0, B_0=2; j=1, B_1=4; j=2, B_2=8; j=3, B_3=16.
- Pair singletons (s=2). Then m≤n/s=8 and per-level |ΔB_j|≤2m≤16. From A_0: only levels with L_j≤s=2 can be affected, i.e., L_3=1, L_2=2; j∈{2,3}. Indeed, j=0,1 are untouched (monochromatic unions). This matches the observation.
- Pair 4-blocks (s=8). Only levels with L_j≤8, i.e., j∈{1,2,3}, can be affected in the first step.

Obstacles and gaps
- The per-level factor-3 cap (Theorem 3′) still allows ΔΦ(A)=∑_j |Δ log_2 B_j| to drop by O(d) per step in principle—hence only Ω(log n) steps from this argument alone. We still need a cross-level scarcity result to show that only O(1) levels can experience constant-factor progress per step globally (not just in the equal-scale-first-step special case).
- The equal-scale scarcity proved here relies on A_0’s rigid dyadic runs. After the first step, run lengths cease to be uniform, so the argument does not extend immediately.
- The “size lemma” Δ_j ≤ C·∑_p min{1, s(p)/L_j} is false in general (as noted in notes.md) and should not be used. Our per-pair ±2 bound is robust and correct, but too weak alone to prove Ω(log^2 n).

Next steps (concrete, testable)
1) Curate Theorem 3′ (factor-3 cap) into output.md, with the corrected proof of the “three indices per pair” mechanism and the per-pair ±2 bound (Lemmas A–C). This is a clean improvement and fully rigorous.
2) Strengthen equal-scale scarcity beyond the first step. Target: If all pairs in a step have sizes within a factor-2 range [L,2L], then for any input A, only O(1) levels j can have |ΔB_j| ≥ θ·B_j(A) for a fixed θ∈(0,1). Approach: combine (i) the per-pair ±2 bound (so |ΔB_j| ≤ 2m ≤ 2n/L), with (ii) lower bounds B_j(A) ≳ n/L_j valid under mild structural hypotheses on A (to be identified), and (iii) an invariant controlling how small B_j(A) can be across many j simultaneously.
3) Home-level charging: Assign to each pair p its home index h(p) with L_{h(p)}≈|p|. Prove a “demand lemma”: constant-factor progress at level j requires Ω(B_j(A)) pairs with h(p)=j (not just any pairs). This would imply that only O(1) levels can see constant-factor progress in a step since ∑_p 1_{h(p)=j} ≤ n/L_j and ∑_j n/L_j=O(n).
4) Small-n brute force (n=16,32): For random partitions/matchings from A_0, measure the number of levels with ≥2× drop in B_j; check whether it is bounded by a small constant; log the configurations saturating Theorem 3′ (per pair Δ_pair=±2) to guide structural characterizations.

Why these steps matter
- Theorem 3′ improves a central per-level cap and repairs the proof. The equal-scale first-step scarcity is a concrete, verifiable instance of the cross-level bottleneck and a useful base case for induction-type arguments.
- The home-level charging is the most promising path to an Ω(log^2 n) lower bound: combined with Theorem 3′, it would bound per-step reduction in Φ(A)=∑_j |log_2 B_j(A)−(d−j)| by an absolute constant, as only O(1) levels can reduce by Θ(1) and the rest by o(1).


=== Verifier (summary_md) ===

=== Verifier (verdict) ===
partial success

