--- SYSTEM ---
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (summary so far)
- output.md (rigorously proven results so far)

Guidelines:
- notes.md: should be a readable running log of interesting work. Prefer appending. Replace only if old notes are clearly misleading. Remember -- notes should be self-contained and should make sense even without seeing outputs of past provers. 
- output.md:  Think twice before you add something to this file. Everything here should be rigorous, almost publication-ready. It should contain only fully proven theorems that are clearly an interesting step towards the solution (or the solution itself). The beginning of the file is a clear list of interesting theorems you can prove, together with a discussion about why it is relevant. From the statement of the theorem it has to be clear that this constitutes nontrivial progress towards solution. The rest of the file contains a fully rigorous list of the proofs of the theorems. Keep only proven theorems with clear proofs. If a statement in that file is flawed / unprecise and you cannot fix it on the spot, remove it from output.md and instead add it to notes.md with explanation.
- Be careful with the booleans `new_notes_append` and `new_outputs_append`: default is True (append). Use False only when deliberately rewriting everything.

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (≥200 words). Include concrete next-step suggestions. The next round of provers may not see last round outputs; ensure all valuable info is stored in notes.",
  "new_notes_md": "Markdown (KaTeX allowed). Usually appended to notes.",
  "new_notes_append": "True|False",
  "new_outputs_md": "Markdown (KaTeX allowed). Usually appended to output.md.",
  "new_outputs_append": "True|False",
  "verdict": "success|partial success|nothing so far"
}

**Verdict definitions**:
- **success**: Something that one could publish, even if it is not the full solution (e.g., significant theorem, key lemma, novel technique, partial solution with clear path forward)
- **partial success**: Something worthy enough to write into output.md (e.g., correct but preliminary results, useful technical lemmas, validated approaches that advance understanding)
- **nothing so far**: No meaningful mathematical progress or only exploratory work


--- USER ---
You receive multiple prover reports. Evaluate correctness, value, and pick promising directions. Update notes.md (append/replace) with useful ideas and update output.md (append/replace) ONLY with rigorously verified results.

Prover reports (JSON):
[{"prover_id": "01", "progress_md": "Headlines\n- New rigorous, step-local identities for how B_j changes: an exact toggle-count formula restricted to the set S of the at-most-3-per-pair indices whose adjacency actually changes. Two immediate corollaries quantify how much B_j can decrease (or increase) in terms of how many of these changed indices hit current j-boundaries. These identities are clean, model-agnostic, and ready to be curated.\n- Clarification: The \u201cuseful boundary adjacency\u201d heuristic is invalid in general (as already noted in notes.md). The correct locality is at the changed indices S only; nothing else can contribute in a step.\n- Programmatic next step: Use the toggle-count identity plus the dyadic alignment structure of A_0 to lower bound the necessary \u201ccentral hits\u201d at many levels at once. I outline a restricted (equal-scale, grid-aligned) special case that can likely be proved fully and would yield an \u03a9(log^2 n) bound for that restricted class.\n\nFormal statements and proofs (new, ready to curate)\n1) Lemma (toggle-locality identity and signed change at level j).\n- Setup. Let A\u2192A\u2032 be any single PBT step, and S\u2286{1,\u2026,n\u22121} be the set of indices whose adjacency changes in this step (i.e., the three indices around each matched pair: left outer, inner, right outer). For j\u2208{0,\u2026,d\u22121}, let T_j(A) be the set of j-run boundary indices of A.\n- Claim. For every j,\n  B_j(A\u2032) \u2212 B_j(A) = |T_j(A\u2032) \u2229 S| \u2212 |T_j(A) \u2229 S|.\n- Proof. By definition, all adjacencies outside S are identical in A and A\u2032, hence their membership in T_j(\u00b7) is unchanged. Thus T_j(A\u2032) \u0394 T_j(A)\u2286S, and\n  |T_j(A\u2032)| \u2212 |T_j(A)| = |T_j(A\u2032)\u2229S| \u2212 |T_j(A)\u2229S|.\nSince B_j(\u00b7)=|T_j(\u00b7)|+1, the identity follows. \u220e\n\nCorollary 1.1 (one-sided bounds per level).\n- For every j,\n  Decrease_j := max{0, B_j(A) \u2212 B_j(A\u2032)} \u2264 |T_j(A) \u2229 S|,\n  Increase_j := max{0, B_j(A\u2032) \u2212 B_j(A)} \u2264 |S\\T_j(A)|.\n- Proof. From the identity, B_j(A) \u2212 B_j(A\u2032) = |T_j(A)\u2229S| \u2212 |T_j(A\u2032)\u2229S| \u2264 |T_j(A)\u2229S|, and similarly for increases. \u220e\n\nRemarks on usefulness.\n- This exposes the exact \u201cdemand\u201d: shrinking B_j by \u0394 forces at least \u0394 of the changed indices to land on T_j(A). For A=A_0 (bit-reversal), T_j(A)=G_j are dyadic arithmetic progressions, so we can quantify how often a single changed index can service many levels via v_2(i).\n- It also yields the previously curated factor-4 cap as a very special (and weaker) consequence when combined with the disjointness-of-unions argument (only O(B_j) pairs can intersect T_j(A)). More importantly, it is sharp enough to support cross-level trade-off inequalities.\n\n2) Lemma (alignment counting at A_0, restated with weights).\nLet A=A_0 and G_j be the j-boundary set at A_0. For any set of changed indices S (from an arbitrary step):\n  \u03a3_{j=0}^{d\u22121} |S \u2229 G_j| = \u03a3_{i\u2208S} (1+v_2(i)).\nIn particular, for any weights a_j\u22650,\n  \u03a3_j a_j\u00b7|S\u2229G_j| = \u03a3_{i\u2208S} \u03a3_{j: 2^{d\u22121\u2212j}|i} a_j.\n- Proof. As in Theorem 4 of output.md; I include the flexible weighted form since we will need to choose tailored a_j.\n\nImmediate consequences and their limits\n- Using Cor. 1.1 with A=A_0 gives \u03a3_j Decrease_j \u2264 \u03a3_j |S\u2229G_j| = \u03a3_{i\u2208S}(1+v_2(i)). This shows that the total number of j-boundaries removed in a single step is at most the \u201calignment budget\u201d \u03a3_i(1+v_2(i)). Since 1+v_2(i) \u2264 1+\u230alog_2(n\u22121)\u230b, we get the coarse bound \u03a3_j Decrease_j \u2264 |S|\u00b7O(log n).\n- This is not yet strong enough to force an O(1) drop of the log-gap potential per step (the step may create increases elsewhere, and |S| can be \u0398(n)), but it is the right necessary-condition inequality to drive sharper cross-level trade-offs (see Next steps).\n\nRestricted special case towards cross-level scarcity (equal-scale, grid-aligned)\n- Definition (equal-scale, grid-aligned step). Fix L a power of two. A step is L-aligned if (i) every matched pair consists of two adjacent intervals each of length in [L,2L), and (ii) all inner boundaries of matched pairs occur at indices divisible by L (i.e., central cuts lie on the L-grid). This is a strong but natural restriction; many plausible blockwise algorithms satisfy it in phases.\n- Claim (to be proved next; sketch here). In an L-aligned step from A_0, at most O(1) bit-levels j with 2^{d\u22121\u2212j}\u2208[L/2,2L] can shrink B_j by a constant factor; all other levels change by at most o(B_j). Outline:\n  \u2022 By Cor. 1.1, to reduce B_j by \u03b8\u00b7B_j we need |S\u2229G_j| \u2265 \u03b8\u00b7B_j \u2212 |S\\G_j|. Since all inner boundaries lie on the L-grid and all outer boundaries are spaced by at least L (due to equal-scale blocks), |S\u2229G_j| is \u0398(#pairs) if and only if the two grids (L and 2^{d\u22121\u2212j}) are commensurate: specifically, if 2^{d\u22121\u2212j}\u2208[L/2,2L]. Otherwise |S\u2229G_j|/B_j=O(2^{d\u22121\u2212j}/L) or O(L/2^{d\u22121\u2212j}), which is o(1), precluding constant-factor change by Lemma 1.\n  \u2022 Moreover, only O(1) consecutive j satisfy 2^{d\u22121\u2212j}\u2208[L/2,2L]. Thus per step only O(1) \u201cactive levels\u201d can reduce by a constant factor. Combining with the per-level factor cap (Theorem 3) bounds the per-step drop of \u03a3_j |log_2 B_j \u2212 (d\u2212j)| by O(1) in this restricted regime.\n- Status: The combinatorics of outer-boundary contributions needs a careful bound to ensure |S\\G_j| does not swamp the inequality; but because outer boundaries per pair are only 2 and lie on the same L-grid offsets, the o(B_j) estimate for off-scale j is achievable. I will write this rigorously next.\n\nWhy the \u201cuseful-boundary\u201d heuristic fails and how the new lemma fixes the issue\n- Earlier \u201cU_j\u201d (indices adjacent to boundaries) is not a certificate. A changed index far from T_j(A) can certainly toggle membership at j depending on the imported endpoints. The correct locality is: only the indices whose adjacencies change (S) can flip membership; among them, a decrease of B_j can only occur on those that were in T_j(A) (Cor. 1.1). This is the precise and minimal condition we need.\n\nA small but precise trade-off for A_0 (weighted decreases)\n- For A=A_0 and any step, Cor. 1.1 plus weighted alignment gives\n  \u03a3_{j=0}^{d\u22121} 2^{\u2212(j+1)}\u00b7Decrease_j \u2264 \u03a3_{i\u2208S} \u03a3_{j: i\u2208G_j} 2^{\u2212(j+1)}.\nFor i with v_2(i)=t, the inner sum equals \u03a3_{j\u2265d\u22121\u2212t} 2^{\u2212(j+1)} = 2^{\u2212(d\u2212t)}(1\u22122^{\u2212(t+1)}) \u2264 2^{\u2212d+t}.\nTherefore \u03a3_j 2^{\u2212(j+1)}\u00b7Decrease_j \u2264 \u03a3_{i\u2208S} 2^{\u2212d+v_2(i)}.\n- Crude bound: since v_2(i) \u2264 \u230alog_2 i\u230b \u2264 d\u22121, the RHS \u2264 |S|/2. This is not strong enough by itself, but it is an exact accounting that we can pair, in the equal-scale regime, with commensurability to limit |S\u2229G_j| where it matters.\n\nChecks on small n\n- For n=8 (A_0=[0,4,2,6,1,5,3,7]), Cor. 1.1 predicts that B_0 can decrease only if S contains the unique G_0 index (the middle cut); indeed, experiments confirm B_0 changes by at most O(1) per step. For B_1, G_1 are indices 2,4,6; placing inner boundaries on these is necessary for noticeable decrease; changing other indices primarily increases B_1.\n\nGaps in output.md\n- The current output.md includes Theorem 3 (factor-4 cap) proved by bounding |\u0394B_j| via the number of pairs that intersect T_j(A). This is correct as written. However, for subsequent stronger trade-offs we need the toggle-locality identity (new Lemma 1) and its corollary as they cleanly separate (i) where decreases can happen (only at S\u2229T_j(A)) from (ii) where increases can happen (only at S\\T_j(A)). I recommend curating Lemma 1 and Cor. 1.1 next.\n\nObstacles and what failed (crisp)\n- A previously sketched \u201csize lemma\u201d \u0394_j \u2264 C\u00b7\u03a3_p min{1, s(p)/L_j} is false; changed adjacencies are only three per pair and independent of s(p).\n- Cross-level scarcity in full generality cannot rely purely on counting |S|, because each changed index can be \u201crelevant\u201d to O(log n) levels at A_0 (via v_2(i)), and |S| can be \u0398(n).\n- Weighting arguments that sum \u0394B_j/B_j(A_0) over j yield bounds of order |S| (too large) unless we impose structural constraints (equal-scale, grid alignment) to force commensurability conflicts.\n\nNext steps (concrete, testable)\n1) Curate Lemma 1 (toggle-locality identity) and Cor. 1.1. These are simple, exact, and will be repeatedly used.\n2) Prove the equal-scale, grid-aligned cross-level scarcity claimed above. The key is to bound |S\u2229G_j|/B_j for off-scale j by o(1) using simple arithmetic progression intersection counts and the fact that inner cuts lie on the L-grid, while outer cuts contribute only O(#pairs) uniformly spread on that grid.\n3) Generalize from exact alignment to \u201cnear alignment\u201d: pairs with lengths in [L,2L) but inner boundaries allowed to drift; show via a pigeonhole/averaging over residues modulo L that one residue class captures a constant fraction, hence we can apply the aligned argument to that fraction, obtaining the same O(1) active-level cap (up to constants).\n4) Experiments for n=64,128: enumerate random equal-scale partitions for several L and measure, per step, the number of j with B_j reduced by \u22651/2. We expect this number to be O(1) near levels with 2^{d\u22121\u2212j}\u2248L and near zero for others. Record distributions to calibrate constants.\n5) With the scarcity lemma in hand for each equal-scale phase, layer phases across L=1,2,4,\u2026 to argue that \u03a3_j |log_2 B_j \u2212 (d\u2212j)| drops by at most O(1) per phase. This would yield \u03a9(log^2 n) steps for any algorithm restricted to equal-scale phases. Later, try to remove the restriction by decomposing an arbitrary step into O(1) \u201cscale bins\u201d (pigeonhole) and charging the potential drop to those bins.\n\nWhy this is promising\n- The toggle-locality identity provides the right \u201cdemand certificate\u201d per level j in terms of S\u2229T_j(A). In the A_0 regime, T_j(A) are dyadic grids, and equal-scale steps naturally constrain S to near-periodic grids; this sets up an arithmetic progressions intersection framework that is well suited to proving the desired O(1) active-level cap per step.\n"}, {"prover_id": "02", "progress_md": "Headlines\n- Fix a gap in output.md: the phrase \u201call other internal adjacencies remain unchanged\u201d is false as stated; what is true (and sufficient) is that the number of j-boundaries internal to each block is preserved by a block swap, hence the net change in B_j is fully determined by the three interface indices per swapped pair.\n- New per-pair inequality: for any fixed bit-level j and any single matched pair (L,R), the contribution to \u0394B_j from that pair is in [\u22122,2]. Summing over pairs that are non-monochromatic at level j yields |\u0394B_j| \u2264 2\u00b7(# such pairs).\n- Consequence: a per-level factor-3 cap per step: B_j(A\u2032) \u2264 3 B_j(A) and B_j(A) \u2264 3 B_j(A\u2032). This improves Theorem 3\u2019s factor-4 to factor-3.\n- Equal-scale first-step scarcity (from A_0): if all matched pairs have total size s in [L,2L], then only levels j with run-length L_j \u2264 s can be affected (and |\u0394B_j| \u2264 2\u00b7(n/s)), hence only O(1) adjacent levels around the \u201chome scale\u201d L_j\u2248L can undergo constant-factor changes in that first step.\n\nCorrections to output.md (local, not changing statements)\n- The proof of Theorem 3 currently says \u201call other internal adjacencies remain unchanged\u201d. This is false literalistically\u2014after swapping L and R the identities of the adjacent pairs across internal indices do change. What holds (and is enough) is:\n  \u2022 For any fixed j, the number of j-boundaries internal to L (and to R) is preserved by the swap, because the internal order within L and within R does not change.\n  \u2022 Therefore the net change in the total number of j-boundaries across the union U = L\u222aR equals the change across the three interface indices: (left outer, inner, right outer). Summing over disjoint pairs yields that \u0394B_j equals the sum of changes at 3\u00b7(#pairs) interface indices. This validates the \u201cthree indices per pair\u201d counting for the change in the number (though not for the set) of boundaries.\n\nNew technical lemmas and proofs\n- Lemma A (binary 4-cycle inequality). For any bits p,q,r,s \u2208 {0,1}, one has [p\u2260q]+[q\u2260r]+[r\u2260s]\u2212[s\u2260p] \u2264 2 and also \u2265 \u22122.\n  Proof. Consider the 4-cycle p\u2212q\u2212r\u2212s\u2212p. The sum S := [p\u2260q]+[q\u2260r]+[r\u2260s]+[s\u2260p] is even and at most 4. Then [p\u2260q]+[q\u2260r]+[r\u2260s]\u2212[s\u2260p] = S \u2212 2\u00b7[s\u2260p] \u2208 {\u22122,0,2}.\n\n- Lemma B (per-pair \u00b12 contribution). Fix level j. Let a_L be the j-color of the outside neighbor left of L; a_R the j-color of the outside neighbor right of R; and let L_1,L_k (first/last j-colors of L), R_1,R_m (first/last j-colors of R). For the matched pair (L,R), let \u0394_pair denote its contribution to \u0394B_j (i.e., the change in the number of j-boundaries inside U=L\u222aR, which equals the change across the three interfaces as noted above). Then |\u0394_pair| \u2264 2.\n  Proof. Using the notation x_a=[a_L\u2260L_1], y_a=[a_L\u2260R_1], x_b=[L_k\u2260R_1], y_b=[R_m\u2260L_1], x_c=[R_m\u2260a_R], y_c=[L_k\u2260a_R], one has \u0394_pair = (x_a+x_b+x_c)\u2212(y_a+y_b+y_c). By triangle inequalities [q\u2260x]\u2212[q\u2260y] \u2264 [x\u2260y], we get x_a\u2212y_a \u2264 [L_1\u2260R_1] and x_c\u2212y_c \u2264 [R_m\u2260L_k]. Hence\n    \u0394_pair \u2264 [L_1\u2260R_1] + [R_m\u2260L_k] + (x_b\u2212y_b)\n            = [L_1\u2260R_1] + [R_m\u2260L_k] + ([L_k\u2260R_1] \u2212 [R_m\u2260L_1]).\n  Applying Lemma A with (p,q,r,s)=(L_1,R_1,L_k,R_m) gives \u0394_pair \u2264 2. The lower bound \u0394_pair \u2265 \u22122 follows symmetrically (or by applying the same argument to the inverse swap).\u220e\n\n- Lemma C (counting pairs that can matter at level j). If the union U=L\u222aR is j-monochromatic in A (equivalently in A\u2032), then \u0394_pair=0. Therefore, letting M_j(A) be the set of matched pairs whose union is not j-monochromatic in A, we have |\u0394B_j| \u2264 2\u00b7|M_j(A)|.\n  Proof. If U is j-monochromatic, then L_1=L_k=R_1=R_m, hence all three interface indicators are unchanged and \u0394_pair=0. Summing Lemma B over pairs in M_j(A) yields the claim.\u220e\n\n- Theorem 3\u2032 (per-level factor-3 cap). For any A\u2192A\u2032 in one step and any j,\n  B_j(A\u2032) \u2264 3\u00b7B_j(A) and B_j(A) \u2264 3\u00b7B_j(A\u2032).\n  Proof. As in output.md, every pair whose union is j-monochromatic gives \u0394_pair=0; the remaining pairs are at most |T_j(A)|=B_j(A)\u22121 by disjointness (charge each such pair to, say, its leftmost internal j-boundary). Then\n    |B_j(A\u2032) \u2212 B_j(A)| \u2264 \u2211_{pairs} |\u0394_pair| \u2264 2\u00b7|M_j(A)| \u2264 2(B_j(A)\u22121),\n  which implies B_j(A\u2032) \u2264 B_j(A) + 2(B_j(A)\u22121) \u2264 3B_j(A). Apply the bound to the inverse step for the reverse inequality.\u220e\n  Remark. This improves the factor-4 cap to factor 3 and implies |\u0394 log_2 B_j| \u2264 log_2 3 per step.\n\nFirst-step equal-scale scarcity from A_0\n- Setup. Let A=A_0 be the bit-reversal input. Fix a step whose matched pairs all have total size s in [L,2L]. Recall L_j=2^{d\u22121\u2212j} is the j-run length in A_0, and B_j(A_0)=2^{j+1}.\n- Observation. If L_j > s then every union U=L\u222aR is j-monochromatic in A_0, hence by Lemma C the step has \u0394B_j=0. Therefore only levels j with L_j \u2264 s can be affected at all. Equivalently, j \u2265 d\u22121\u2212\u230alog_2 s\u230b.\n- Bound on magnitude. The number of matched pairs m satisfies m\u00b7s \u2264 n, hence m \u2264 n/s. By Lemma B, |\u0394B_j| \u2264 2m \u2264 2n/s for every j. Thus for any j with L_j \u226a s the relative change is tiny at A_0: |\u0394B_j|/B_j(A_0) \u2264 (2n/s)/2^{j+1} = 2\u00b7(2^{d\u2212j\u22121}/s) = 2\u00b7(L_j/s).\n- Consequence (first-step \u201cactive levels\u201d). For a constant-factor change (say a \u2265 2\u00d7 drop) at level j we need |\u0394B_j| \u2265 B_j(A_0)/2 = 2^{j}/2. The bound above forces L_j \u2273 s (indeed L_j \u2265 s/4 suffices to violate). Hence, in such an equal-scale step from A_0, only those j with L_j within a constant factor of s can undergo a constant-factor change. There are O(1) such adjacent levels.\n- Why useful. This is a clean, checkable special case of the sought cross-level scarcity: in an equal-scale step, only O(1) levels can progress by a constant factor from A_0. It suggests the \u201chome level\u201d approach: pairs of size s are only capable of large impact around the dyadic scale L_j\u2248s.\n\nExamples and sanity checks (n=16)\n- Take A_0=[0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15]. For j=0, B_0=2; j=1, B_1=4; j=2, B_2=8; j=3, B_3=16.\n- Pair singletons (s=2). Then m\u2264n/s=8 and per-level |\u0394B_j|\u22642m\u226416. From A_0: only levels with L_j\u2264s=2 can be affected, i.e., L_3=1, L_2=2; j\u2208{2,3}. Indeed, j=0,1 are untouched (monochromatic unions). This matches the observation.\n- Pair 4-blocks (s=8). Only levels with L_j\u22648, i.e., j\u2208{1,2,3}, can be affected in the first step.\n\nObstacles and gaps\n- The per-level factor-3 cap (Theorem 3\u2032) still allows \u0394\u03a6(A)=\u2211_j |\u0394 log_2 B_j| to drop by O(d) per step in principle\u2014hence only \u2126(log n) steps from this argument alone. We still need a cross-level scarcity result to show that only O(1) levels can experience constant-factor progress per step globally (not just in the equal-scale-first-step special case).\n- The equal-scale scarcity proved here relies on A_0\u2019s rigid dyadic runs. After the first step, run lengths cease to be uniform, so the argument does not extend immediately.\n- The \u201csize lemma\u201d \u0394_j \u2264 C\u00b7\u2211_p min{1, s(p)/L_j} is false in general (as noted in notes.md) and should not be used. Our per-pair \u00b12 bound is robust and correct, but too weak alone to prove \u2126(log^2 n).\n\nNext steps (concrete, testable)\n1) Curate Theorem 3\u2032 (factor-3 cap) into output.md, with the corrected proof of the \u201cthree indices per pair\u201d mechanism and the per-pair \u00b12 bound (Lemmas A\u2013C). This is a clean improvement and fully rigorous.\n2) Strengthen equal-scale scarcity beyond the first step. Target: If all pairs in a step have sizes within a factor-2 range [L,2L], then for any input A, only O(1) levels j can have |\u0394B_j| \u2265 \u03b8\u00b7B_j(A) for a fixed \u03b8\u2208(0,1). Approach: combine (i) the per-pair \u00b12 bound (so |\u0394B_j| \u2264 2m \u2264 2n/L), with (ii) lower bounds B_j(A) \u2273 n/L_j valid under mild structural hypotheses on A (to be identified), and (iii) an invariant controlling how small B_j(A) can be across many j simultaneously.\n3) Home-level charging: Assign to each pair p its home index h(p) with L_{h(p)}\u2248|p|. Prove a \u201cdemand lemma\u201d: constant-factor progress at level j requires \u03a9(B_j(A)) pairs with h(p)=j (not just any pairs). This would imply that only O(1) levels can see constant-factor progress in a step since \u2211_p 1_{h(p)=j} \u2264 n/L_j and \u2211_j n/L_j=O(n).\n4) Small-n brute force (n=16,32): For random partitions/matchings from A_0, measure the number of levels with \u22652\u00d7 drop in B_j; check whether it is bounded by a small constant; log the configurations saturating Theorem 3\u2032 (per pair \u0394_pair=\u00b12) to guide structural characterizations.\n\nWhy these steps matter\n- Theorem 3\u2032 improves a central per-level cap and repairs the proof. The equal-scale first-step scarcity is a concrete, verifiable instance of the cross-level bottleneck and a useful base case for induction-type arguments.\n- The home-level charging is the most promising path to an \u2126(log^2 n) lower bound: combined with Theorem 3\u2032, it would bound per-step reduction in \u03a6(A)=\u2211_j |log_2 B_j(A)\u2212(d\u2212j)| by an absolute constant, as only O(1) levels can reduce by \u0398(1) and the rest by o(1).\n"}]

Current notes.md:
Setting and notation
- Input size n=2^d. The specific permutation A_0 is bit-reversal order of [0,…,n−1]. For j∈{0,…,d−1} we color elements by their j-th bit and denote by B_j(A) the number of monochromatic runs (contiguous blocks of equal j-bit) in the array A. Let T_j(A)⊆{1,…,n−1} be the set of j-run boundary indices (|T_j(A)|=B_j(A)−1). We consider one-step operations that swap a family of disjoint adjacent interval pairs in parallel.
- Our model of one step coincides with PBT (parallel adjacent block transpositions). One step chooses disjoint pairs (L_k,R_k) of adjacent contiguous intervals and swaps every chosen pair simultaneously.

Endpoint calibration (bit-reversal vs sorted)
- For A_0 (bit-reversal), B_j(A_0)=2^{j+1}. For the fully sorted order A_* = [0,1,…,n−1], B_j(A_*)=2^{d−j}. Consequently, the potential Φ(A):=Σ_{j=0}^{d−1} |log_2 B_j(A) − (d−j)| satisfies Φ(A_0)=Θ(d^2) and Φ(A_*)=0.

Locality of changes per pair and a safe per-level cap
- A single swapped pair (L,R) can alter adjacency only at three indices: the left outer boundary before L, the inner boundary between L and R, and the right outer boundary after R. For a fixed level j, if the union L∪R contains no j-boundary of the current array A, then all three affected adjacencies are between same colors both before and after; hence this pair produces no change in B_j.
- Therefore only pairs whose union contains at least one element of T_j(A) can affect B_j. Because the pair unions are disjoint, the number of such pairs is at most |T_j(A)|=B_j(A)−1. Each such pair contributes at most 3 to |B_j(A′)−B_j(A)|. Hence for every j and every PBT step A→A′,
  |B_j(A′) − B_j(A)| ≤ 3(B_j(A) − 1),
  which implies the multiplicative cap B_j(A′) ≤ 4·B_j(A) and B_j(A) ≤ 4·B_j(A′). In particular, |Δ log_2 B_j| ≤ 2 per step.

Dyadic alignment for A_0
- Let G_j denote the j-run boundary set in A_0. Then G_j = { i∈{1,…,n−1} : 2^{d−1−j} divides i }. For any set S of cut indices used in a step, one has
  Σ_{j=0}^{d−1} |S ∩ G_j| = Σ_{i∈S} (1 + v_2(i)) ≤ |S| (1 + ⌊log_2(n−1)⌋),
  since the number of j for which i∈G_j equals 1+v_2(i).

Caveats and corrections to earlier sketches
- The previously proposed “useful boundary” set U_j (indices in or adjacent to T_j(A)) is not a valid certificate for where toggles can occur: the post-step adjacency at a changed index depends on elements imported from potentially far away; mere distance-1 proximity to T_j(A) is insufficient to characterize where toggles can or cannot happen. We avoid using U_j.
- A claimed “size lemma” of the form Δ_j ≤ C·Σ_p min{1, s(p)/L_j} is false deterministically. Short pairs can be aligned to j-gridlines so that Δ_j ≍ n/L_j while the RHS is ≍ n/L_j^2. Any valid size-sensitive bound must use a different aggregation (see Next steps).
- Edge-to-level weighting that relies on fixed dyadic gridlines E_j holds at A_0 but not after the array evolves; after one step the j-boundaries are no longer constrained to those gridlines.

Next steps (program)
1) Try to sharpen the per-level cap to factor 2: Show |B_j(A′)−B_j(A)| ≤ c·|T_j(A)∪T_j(A′)| with small c (ideally c=1 or 2) by charging every toggling edge to a unique j-boundary contained in the union of the pair in either A or A′.
2) Demand for central matches: Prove that achieving a constant-factor decrease of B_j in one step requires Θ(B_j) central-boundary alignments (inner boundaries of swapped pairs) with j-run boundaries of A; outer-boundary hits alone cannot effect global coalescence. Make this precise and robust to local cancellations.
3) Cross-level scarcity via “home levels”: For each pair p of total size s(p), assign h(p) with L_{h(p)}≈s(p). Prove that constant-factor progress at level j needs Σ_{p: h(p)=j} Ω(1) contribution. Since Σ_p s(p) ≤ n and the sets {p: h(p)=j} are disjoint across j, only O(1) levels can make factor-≥2 progress in the same step. First prove the equal-scale special case (all pairs have sizes within ×2 of some L), which should already yield an Ω(log^2 n) lower bound for that restricted class.
4) Use the dyadic structure of G_j at A_0 to formalize a “central-boundary alignment trade-off” across levels: matched central boundaries that effect progress for one j are largely incompatible with those needed for many other j due to disjointness and dyadic spacing.
5) Perform small-n experiments (n=16,32) to estimate the maximal number of levels that can experience ≥2× change in B_j in one step and to guide constants.


Current output.md (if any):
Statements and proofs curated so far

Theorem 1 (Model equivalence to PBT). A single step of the model (swapping a family of disjoint adjacent interval pairs in parallel) is exactly a parallel block transposition (PBT) step: a product of disjoint adjacent block transpositions.
Proof. A step chooses disjoint adjacent pairs (L_k,R_k) of intervals and swaps each pair simultaneously, leaving all other positions untouched. This is precisely a product of disjoint adjacent block transpositions. Conversely, any product of disjoint adjacent block transpositions can be realized by choosing those pairs. ∎

Theorem 2 (Endpoint run-counts). Let n=2^d and A_0 be the bit-reversal permutation of [0,…,n−1]. For j∈{0,…,d−1}:
- B_j(A_0)=2^{j+1}.
- For the fully sorted order A_*=[0,1,…,n−1], B_j(A_*)=2^{d−j}.
Consequently, with D_j(A):=|log_2 B_j(A) − (d−j)|, one has Σ_{j=0}^{d−1} D_j(A_0)=Θ(d^2) and Σ_{j=0}^{d−1} D_j(A_*)=0.
Proof. In A_0, the j-bit of the value at position i equals the (d−1−j)-th bit of i; thus along positions 0,…,n−1 this bit is constant on runs of length 2^{d−1−j} and alternates every such block, giving exactly 2^{j+1} runs. In A_*, the j-bit is constant on blocks of length 2^j and alternates every 2^j positions, yielding 2^{d−j} runs. The Θ(d^2) sum follows from Σ_{j=0}^{d−1} |2j+1−d| = Θ(d^2) by symmetry around (d−1)/2. ∎

Theorem 3 (Per-level factor-4 cap per step). For any array A, any j, and any single PBT step A→A′, we have B_j(A′) ≤ 4·B_j(A) and B_j(A) ≤ 4·B_j(A′). Equivalently, |log_2 B_j| changes by at most 2 in one step.
Proof. Let T_j(A) be the set of j-boundary indices in A. Consider a swapped pair (L,R). If the union U=L∪R contains no index from T_j(A), then the j-color is constant throughout U, so the three adjacencies that can change (left outer boundary of U, inner boundary between L and R, and right outer boundary of U) all remain between equal colors both before and after; hence this pair produces no change in B_j. Therefore only pairs whose union intersects T_j(A) can change B_j. Because the unions of the swapped pairs are disjoint, the number of such pairs is at most |T_j(A)|=B_j(A)−1. Each such pair affects at most the three indices mentioned, so it can change B_j by at most 3. Hence |B_j(A′)−B_j(A)| ≤ 3(B_j(A)−1), which implies B_j(A′) ≤ 4·B_j(A). Applying the same argument to the inverse step A′→A gives B_j(A) ≤ 4·B_j(A′). ∎

Theorem 4 (Dyadic alignment for A_0). Let G_j⊆{1,…,n−1} be the set of j-run boundary indices in A_0. Then G_j = { i : 2^{d−1−j} divides i }. For any set S⊆{1,…,n−1} (e.g., cut positions used in a step),
  Σ_{j=0}^{d−1} |S ∩ G_j| = Σ_{i∈S} (1 + v_2(i)) ≤ |S| (1 + ⌊log_2(n−1)⌋).
Proof. In A_0 the j-bit of values is periodic with period 2^{d−j}, so boundaries occur exactly at indices i that are multiples of 2^{d−1−j}. For fixed i, the set of j with i∈G_j has size 1+v_2(i) (the largest τ=v_2(i) yields divisibility by 2^τ). Summing over i∈S gives the identity; since v_2(i)≤⌊log_2 i⌋≤⌊log_2(n−1)⌋, the inequality follows. ∎
