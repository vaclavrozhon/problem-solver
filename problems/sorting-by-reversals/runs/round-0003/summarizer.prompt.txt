--- SYSTEM ---
You are a research **summarizer**. Summarize this *last round only* for a human log.

Include:
- 3–7 bullet **Highlights** (facts learned, reductions, counterexamples, partial bounds).
- 1–3 **Open questions / TODOs** for the next round.
- 1–3 **Citations to files** you relied on (e.g. round files or papers by name).

**Return strictly JSON**:
{
  "summary_md": "Readable summary of the round (≤200 words)",
  "highlights": [],
  "next_questions": []
}

--- USER ---
=== prover-01.out.json (progress_md) ===
Ideas
- Strengthen our step-local toolkit with two exact identities that (i) relate changes of all B_j at once to Hamming distances across changed adjacencies, and (ii) sharpen the per-pair effect in the “sub-run” regime from the bit-reversal start A_0. These are small, testable steps toward a cross-level scarcity principle.
- Reassess the “equal-scale scarcity” heuristic. A careful check shows that even with strong grid alignment, a single step can interact with Θ(log n) levels via the dyadic divisibility lattice; thus the very strong claim “only O(1) active levels per step” is false in that aligned special case. We document the precise extent of this phenomenon.

New lemmas (clean statements and proofs)
1) Hamming-sum identity across levels (exact).
- Statement. For any array A (permutation of {0,…,n−1}), let HD_A(i) be the Hamming distance in d-bit binary between the values at positions i and i+1, i∈{1,…,n−1}. Then for every j, |T_j(A)|=B_j(A)−1 counts the edges i where the j-th bit flips; consequently
  Σ_{j=0}^{d−1} (B_j(A)−1) = Σ_{i=1}^{n−1} HD_A(i).
- Moreover, in a single step A→A′, let S be the set of changed indices (three per matched pair). Then
  Σ_{j=0}^{d−1} (B_j(A′)−B_j(A)) = Σ_{i∈S} (HD_{A′}(i) − HD_A(i)).
- Proof. For fixed i, the indicator [i∈T_j(A)] equals [j-th bits of (A[i], A[i+1]) differ]. Summing over j gives HD_A(i). Summing over i yields the first identity. For the second: outside S adjacencies are unchanged, so HD does not change; inside S, boundary-membership toggles per j encode exactly the change of HD at i; summing over j then over i gives the displayed equality.∎
- Why useful. It is an exact accounting that complements toggle-locality: per changed adjacency, the total “boundary mass” across all levels can change by at most d. This can be paired with level-weighted potentials in future steps. It also indicates why naive unweighted potentials (Σ_j B_j) are too crude: a single step can change them by Θ(d·|S|).

2) Sub-run per-pair sharpening at A_0 (s < L_j regime).
- Setup. Fix j, and let L_j := 2^{d−1−j} be the j-run length at A_0 (positions are colored by the j-th bit of their values in A_0). Consider a matched pair (L,R) whose union U=L∪R has total span s := |U|.
- Lemma. If s < L_j, then among the three changed indices (left-outer, inner, right-outer) at most one belongs to G_j = T_j(A_0) (the j-boundary set in A_0). Consequently, for A=A_0,
  Δ_pair(j) ∈ {−1,0,1}, and in particular |Δ_pair(j)| ≤ 1.
- Proof. In A_0 the indices in G_j are exactly multiples of L_j; in particular, any two distinct elements of G_j differ by at least L_j. The three changed indices of the pair lie in the interval from the left-outer to the right-outer boundary, whose length is s+1. Because s < L_j, that interval contains at most one multiple of L_j. Hence at most one of the three changed indices lies in G_j. Applying toggle-locality at A_0, the contribution to |T_j| from this pair’s neighborhood can change by at most 1 in absolute value.∎
- Consequences (first step from A_0). For any level j and any family of pairs with s < L_j, the total j-level change satisfies |ΔB_j| ≤ |S∩G_j| ≤ min{m, |G_j|} ≤ min{m, B_j(A_0)−1}, where m is the number of pairs; moreover each contributing pair accounts for at most ±1 at level j. This refines Lemma 4 in the sub-run regime for the first step only.

3) Decrease-only alignment bound at A_0 under strong L-grid alignment.
- Setup. Let L be a positive integer. Suppose a step from A_0 is such that every interval boundary (both pair inners and outers) lies at an index multiple of L (e.g., we partition at indices ≡0 mod L and swap some adjacent blocks). Recall G_j = {i: 2^{d−1−j}|i}.
- Lemma. For any j with 2^{d−1−j} ∤ L (equivalently, L_j ∤ L), we have Decrease_j = 0.
- Proof. By toggle-locality at A_0, Decrease_j ≤ |T_j(A_0)∩S|=|G_j∩S|. But S⊆{multiples of L}, and if 2^{d−1−j}∤L then G_j contains no multiple of L, so the intersection is empty, whence Decrease_j=0.∎
- Remarks.
  • Increases may still occur (since new j-boundaries can be created at these indices), i.e., B_j can change even when Decrease_j=0. Thus the lemma is one-sided and must be combined with the desired direction of progress at level j.
  • The set of j with 2^{d−1−j}|L has size 1+⌊log_2 L⌋. Hence even under very strong alignment, ‘decrease-capable’ levels per step can be Θ(log L), not O(1). This corrects and quantifies the earlier over-optimistic equal-scale scarcity heuristic.

Examples (sanity checks)
- n=8, d=3, A_0=[0,4,2,6,1,5,3,7]. Take pairs of size s=2 that do not cross the unique G_0 boundary (at i=4). For j=0, Lemma 2 applies: each such pair changes B_0 by at most ±1; in fact, if s=2 and pairs do not straddle i=4, B_0 remains 2.
- With strong L-grid alignment and L=2, all boundary indices S are even. For j=1 (G_1={2,4,6}), decreases are possible; for j=0 (G_0={4}) decreases are also possible; for hypothetical j with L_j odd (none here), decreases would vanish. This matches Lemma 3.

Obstacles and why certain approaches fail
- Equal-scale scarcity beyond O(1). Even with all boundaries placed on an L-grid, decreases are only blocked for j with 2^{d−1−j}∤L; for the complementary j (those with 2^{d−1−j}|L) decreases are possible, and there are Θ(log L) such levels. Thus the sought “only O(1) active levels per step” is false under strong alignment. Moreover, for off-scale j where decreases are blocked, increases can occur—and for j in the lower half (where B_j(A_0) < B_j(A_*)), increases actually reduce the potential D_j. This shows that a decrease-only analysis cannot deliver the cross-level scarcity needed for an Ω(log^2 n) bound.
- Capacity-style bounds on Σ_j Decrease_j/B_j(A_0) suffice only for Ω(log n). Binning pairs by scale and using per-pair ±2 yields Σ_j (Decrease_j/B_j(A_0)) ≤ O(d) per step; hence the log-gap potential Σ_j |log B_j − (d−j)| can drop by Θ(d) per step, giving only Ω(d)=Ω(log n) steps.
- Why we need a “signed” cross-level constraint. The toggle-locality and Hamming-sum identities show that a changed index influences many levels in a structured way. To bound the drop of a potential like Φ(A)=Σ_j |log B_j(A)−(d−j)| by O(1), we likely need a cancellation principle across levels (e.g., a signed inequality per changed index), not a pure counting of aligned hits. Establishing such a cancellation is the core open obstacle.

Gaps or issues in output.md
- Output so far is consistent and correct with the factor-3 per-level cap (Theorem 5), toggle-locality (Lemma 3), and the dyadic alignment identity (Theorem 6). The new Lemma 3 above clarifies a one-sided phenomenon (decreases blocked by L-grid misalignment) and should be flagged as one-sided (increases can still occur). No changes to existing statements are needed, but adding the Hamming-sum identity would enrich the toolkit.

Next steps (concrete, testable)
1) Curate the Hamming-sum identity and the sub-run per-pair sharpening (s<L_j ⇒ |Δ_pair(j)|≤1 at A_0) into output.md. Both are exact/local and straightforward to verify.
2) Classify per-pair outcomes: For fixed j, characterize exactly when Δ_pair(j)∈{−2,−1,0,1,2} in terms of the six endpoint bits (a_L,L_1,L_k,R_1,R_m,a_R). This finite case analysis will allow a demand lemma quantifying how many inner-boundary hits (as opposed to outer) are necessary for a large decrease.
3) Develop a signed cross-level inequality: For a single changed index i, analyze the vector over j of the sign of its contribution to B_j (increase/decrease) in terms of the Hamming patterns before vs. after. Aim: show that for each i, the sum of “useful signed contributions” to the potential over j is bounded by an absolute constant (or by O(1) after a carefully chosen weighting). This is the most promising route to an O(1) per-step drop for an appropriate potential.
4) Small-n experiments (n=16,32,64): enumerate random steps from A_0; for each, record the set of j with B_j decreasing by ≥(1/2)·B_j, and those with D_j dropping by ≥1. Empirically bound the number of “active levels” and identify structural patterns of steps that maximize concurrent progress across j.
5) If step 3 succeeds, integrate with Theorem 5 to show an O(1) drop of Σ_j |log B_j − (d−j)| per step, implying Ω(log^2 n). Otherwise, pivot to algorithmic exploration: design a multiscale PBT schedule exploiting simultaneous increases/decreases to approach an O(log n) algorithm specific to bit-reversal.

Why this is progress
- The Hamming-sum identity is a new exact tool, and the sub-run sharpening is a concrete refinement in a key regime (first step from A_0). The alignment lemma (decreases-only) precisely corrects an earlier heuristic. Together, they map the landscape of what must be overcome for an Ω(log^2 n) lower bound and outline a plausible, testable path via signed cross-level cancellations.

=== prover-02.out.json (progress_md) ===
## Round 0003 — New local bounds, an aligned-step cross-level inequality, and a reassessment of the “O(1) active-levels” goal

### Quick recap of curated facts (for reference)
- Toggle-locality identity (curated): for a step with changed-adjacency set S, for each level j,
  \[ B_j(A')-B_j(A) = |T_j(A')\cap S| - |T_j(A)\cap S|. \]
  In particular, Decrease_j ≤ |T_j(A)∩S| and Increase_j ≤ |S\setminus T_j(A)|.
- Per-pair ±2 and factor-3 per-level cap (curated): each pair contributes at most ±2 to ΔB_j; hence B_j changes by at most a factor 3 per step.
- Dyadic alignment at A_0 and the weighted form (curated): for any S, \(\sum_j |S\cap G_j| = \sum_{i\in S}(1+v_2(i))\). Weighted instantiations are available and correct (verifier’s correction applied).

### New: a simple per-step “pair-budget” demand bound
- Lemma (per-step demand). Let a step use m matched pairs and S its set of changed indices. Then for any fixed bit-level j,
  \[\text{Decrease}_j \le |T_j(A)\cap S| \le |S| \le 3m.\]
  Proof. Immediate from toggle-locality and that a pair changes at most 3 adjacencies.
- Consequence (coarse necessary condition). A constant-fraction decrease at level j in one step, i.e., \(\text{Decrease}_j \ge \theta\,B_j(A)\), forces \(m \ge \tfrac{\theta}{3}\,B_j(A)\). For A=A_0, this is \(m \ge \tfrac{\theta}{3}\,(n/L_j)\). If moreover all total pair sizes lie in [L,2L], then m ≤ n/L, so a constant-fraction decrease at j necessitates \(L_j \gtrsim L\). This recovers the intuitive “only levels at or above the step’s scale can be significantly coarsened” necessary condition.

Why useful here. Although very coarse, this “pair-budget” lower bound is universal (no alignment assumptions) and will be a repeatedly invoked necessary condition when we later combine scale-wise inequalities.

### New: an equal-scale, grid-aligned cross-level inequality at A_0
We formalize a clean cross-level bound that leverages alignment to a dyadic grid and will be a base tool for any “phase-by-scale” analysis.

- Setting. Let A=A_0. Fix L=2^\ell and consider a step with:
  1) all matched pairs having total sizes in [L,2L), and
  2) all inner boundaries of the matched pairs at indices divisible by L (i.e., inner boundaries lie on the L-grid).
  Let m be the number of pairs; thus m ≤ n/L. Let S be the set of the (at most 3m) changed indices.

- Inequality 1 (large-scale weighted bound). For the set of levels with run-length at least L, i.e., \(\{j: L_j\ge L\}\), we have
  \[ \sum_{\{j: L_j\ge L\}} \frac{L}{L_j}\,\text{Decrease}_j\;\le\; 2|S|\;\le\;6m\;\le\;\frac{6n}{L}. \]
  Proof. From toggle-locality: \(\sum_j \frac{L}{L_j}\,\text{Decrease}_j \le \sum_{i\in S}\sum_{\{j: i\in G_j,\,L_j\ge L\}} \frac{L}{L_j}\). For an index i with 2-adic valuation t = v_2(i), the inner sum is a truncated geometric series \(\sum_{s=\ell}^{t} 2^{\ell-s} \le 2\), and is 0 if t<\ell. Thus the entire sum is ≤ 2|S|.

- Inequality 2 (small-scale aggregate fractional bound). For the levels with run-length below L (i.e., \(L_j<L\)), define \(w_j:=1/B_j(A_0)=L_j/n\). Then
  \[ \sum_{\{j: L_j<L\}} \frac{\text{Decrease}_j}{B_j(A_0)} \;=\; \sum_{\{j: L_j<L\}} w_j\,\text{Decrease}_j \;\le\; C\,\frac{n}{L}\,\log\frac{n}{L} \cdot \frac{1}{n}\;=\; C\,\frac{\log(n/L)}{L}. \]
  Proof idea. Toggle-locality gives \(\sum_j w_j\,\text{Decrease}_j \le \sum_{i\in S}\sum_{\{j: i\in G_j\}} w_j\). For A_0, as in the weighted version of Theorem 6, \(\sum_{\{j: i\in G_j\}} w_j = \sum_{\{j: i\in G_j\}} 2^{-(j+1)}\), which for v_2(i)=t evaluates to \(\le 2^{-d+t+1}\). The novel ingredient is to bound \(\sum_{i\in S} 2^{v_2(i)}\) for L-grid-aligned steps: each changed index i lies within distance <2L of a multiple of L; one can show (standard 2-adic counting) that \(\sum_{i\in S}2^{v_2(i)}\) is \(O\big(m\,2^{\ell}\,(1+\log(\tfrac{n}{L}))\big)\). Dividing by \(2^d=n\) yields the RHS. (I will write the detailed combinatorial bound in the next round; it uses that among N integers, the sum of the top-k values of v_2 is O(k log(N/k)+k), and here N≈n/L and k≈m≤N.)

- Consequences (interpreting the two inequalities).
  • From Inequality 1: it constrains the total weighted progress at levels with \(L_j\ge L\). In particular, it rules out (in an aligned step) making relative progress \(\Omega(1)\) across more than O(1) geometrically spaced large scales—more precisely, if \(\text{Decrease}_j\ge \theta B_j\) for all j in some set J with \(L_j\ge L\), then \(\sum_{j\in J} L/L_j\) is bounded, which forces J to be concentrated on O(1) adjacent scales. (Note: this does not bound |J| by a constant—it bounds a weighted count; see caveats below.)
  • From Inequality 2: at small scales \(L_j<L\), the sum of relative decreases \(\sum \text{Decrease}_j/B_j\) is \(O(\log(n/L)/L)\). Thus for large L (coarse steps), only a tiny number of small-scale levels can see a constant-fraction drop; quantitatively, the number of j with \(\text{Decrease}_j\ge \theta B_j\) and \(L_j<L\) is \(O\big((\log(n/L))/(\theta L)\big)\).

Why useful here. These inequalities, while not yet sufficient to give an \(O(1)\) drop of \(\sum_j |\log B_j - (d-j)|\) per step, provide scale-sensitive trade-offs that any “phase-by-scale” lower bound will need. They also identify the small-scale vs. large-scale dichotomy within an aligned step.

### Important reassessment: the “O(1) active levels per step” claim is likely false
- The earlier speculative Lemma 2 (“a matched boundary is only useful for O(1) levels, hence only O(1) levels can change by a constant factor per step”) appears untenable. Heuristic counterexample: take L=1, align inner boundaries on the 1-grid, and partition into singletons matched pairwise across the entire array. Then S contains almost all indices (up to endpoints), so \(|S\cap G_j|\) is \(\Theta(n/L_j)=\Theta(B_j)\) for all j simultaneously. Toggle-locality then permits \(\Theta(1)\) relative decreases for \(\Theta(\log n)\) many levels in the same step. This directly contradicts the “O(1) active levels” narrative.
- What is still tenable. Our new inequalities show that even though many levels can progress at once, an aligned step cannot simultaneously give large relative progress at scales far below L (Inequality 2) and its weighted progress across higher scales is bounded (Inequality 1). This suggests that any robust lower bound must measure progress with a scale-sensitive potential rather than a flat sum of \(|\log B_j - (d-j)|\).

### A restricted-class milestone: towards an \(\Omega(\log^2 n)\) bound for scale-phased algorithms
- Restricted model hypothesis. Consider algorithms that operate in phases; in each phase t, all matched pairs have sizes within a factor-2 window [L_t,2L_t), and (possibly after discarding a constant fraction of pairs by residue-class averaging) the inner boundaries are aligned to the L_t-grid.
- Strategy sketch. Define a scale-sensitive potential \(\Psi(A)=\sum_j w_t(j)\,|\log_2 B_j(A) - (d-j)|\) whose weights \(w_t(j)\) sharply peak around the “home scale” \(L_j\approx L_t\), e.g., \(w_t(j)=\alpha^{|\log_2 L_j - \log_2 L_t|}\) for a fixed \(\alpha\in(0,1)\). Using Inequalities 1–2 plus the pair-budget bound, aim to prove that in any L_t-aligned phase, \(\Psi\) decreases by at most a constant. Since \(\sum_t 1=\Theta(\log n)\) phases are needed to cover all scales L_t=2^t, this would force \(\Omega(\log^2 n)\) steps. This is a realistic, checkable plan for the restricted model.
- Status. The per-phase constant-drop claim requires a careful combinatorial bound on the weighted sum of decreases induced by the S-edges; our Inequality 1 gives the “upper tail” (\(L_j\ge L_t\)) control, and Inequality 2 controls the “lower tail” (\(L_j<L_t\)). I will formalize the choice of \(\alpha\) and complete the per-phase bound next.

### Gaps and clarifications in output.md
- Suggest adding the new “pair-budget” lemma stated above; it is an immediate corollary of Lemma 3 (toggle-locality) and is useful for quick necessary conditions.
- The equal-scale, grid-aligned cross-level bounds (Inequalities 1–2) are new and not yet in output.md. They are specialized to A_0, but they capture the key arithmetic-progression intersection needed for any scale-phased lower bound. I recommend curating Inequality 1 (fully rigorous as written) and flagging Inequality 2 as a lemma with a short proof deferred (the only remaining detail is the bound \(\sum_{i\in S}2^{v_2(i)}=O\big(m2^\ell(1+\log(n/L))\big)\), which I’ll write out).
- Caution: the earlier envisioned “O(1) active levels per step” is incompatible with aligned steps at small scale (L=1); hence it should not be pursued as a general lemma. The per-level factor-3 cap remains correct and relevant but does not by itself deliver \(\Omega(\log^2 n)\).

### Obstacles
- The sum-of-logs potential \(\Phi(A)=\sum_j |\log_2 B_j(A)-(d-j)|\) can drop by \(\Theta(\log n)\) in a single step (e.g., L=1 aligned), so it is not suitable to yield \(\Omega(\log^2 n)\) via an \(O(1)\) per-step drop.
- Cross-level scarcity in full generality (without alignment/restrictions) appears false at the granularity of “number of active levels.” New lower-bound proofs must use scale-sensitive weights and exploit alignment or pair-size budgets.

### Next steps (concrete and testable)
1) Curate the “pair-budget” lemma into output.md.
2) Curate Inequality 1 (large-scale weighted bound) for L-aligned steps from A_0, with a clean proof (as above).
3) Provide a complete proof of Inequality 2: write the combinatorial bound \(\sum_{i\in S}2^{v_2(i)}=O\big(m2^\ell(1+\log(n/L))\big)\) and record it as a lemma on 2-adic valuation sums near an L-grid.
4) Formalize a per-phase potential \(\Psi_t\) with geometric weights around scale L_t and prove an \(O(1)\) per-phase drop in the restricted (aligned, equal-scale) model, yielding \(\Omega(\log^2 n)\) steps for that class of algorithms.
5) Empirics on small n (n=32,64): verify that an L=1 aligned step from A_0 can reduce \(B_j\) by a constant factor for \(\Theta(\log n)\) levels, corroborating the reassessment.
6) Begin investigating whether a strong “central-boundary demand” lemma can be salvaged: quantify, per level j, the maximal number of decreases realizable by outer boundaries alone; aim to show that to achieve \(\Omega(B_j)\) decreases one must contribute \(\Omega(B_j)\) via inner boundaries when \(L_j\lesssim L\). This would strengthen Inequality 2 and aid the per-phase bound.

### Why this counts as progress
- Adds a universal, clean “pair-budget” demand bound for \(\text{Decrease}_j\) that will be used in multiple places.
- Proves a sharp cross-level inequality (Inequality 1) for aligned steps and outlines a second (Inequality 2) with a near-complete proof plan.
- Correctly identifies and documents the failure of the “O(1) active levels” approach, steering the program towards scale-sensitive potentials, which are more realistic for an \(\Omega(\log^2 n)\) lower bound in restricted models.
- Sets up a feasible restricted-model milestone (equal-scale, grid-aligned phases) where an \(\Omega(\log^2 n)\) lower bound appears within reach.


=== Verifier (summary_md) ===

=== Verifier (verdict) ===
partial success

