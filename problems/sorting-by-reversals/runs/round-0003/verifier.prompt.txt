--- SYSTEM ---
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (summary so far)
- output.md (rigorously proven results so far)

Guidelines:
- notes.md: should be a readable running log of interesting work. Prefer appending. Replace only if old notes are clearly misleading. Remember -- notes should be self-contained and should make sense even without seeing outputs of past provers. 
- output.md:  Think twice before you add something to this file. Everything here should be rigorous, almost publication-ready. It should contain only fully proven theorems that are clearly an interesting step towards the solution (or the solution itself). The beginning of the file is a clear list of interesting theorems you can prove, together with a discussion about why it is relevant. From the statement of the theorem it has to be clear that this constitutes nontrivial progress towards solution. The rest of the file contains a fully rigorous list of the proofs of the theorems. Keep only proven theorems with clear proofs. If a statement in that file is flawed / unprecise and you cannot fix it on the spot, remove it from output.md and instead add it to notes.md with explanation.
- Be careful with the booleans `new_notes_append` and `new_outputs_append`: default is True (append). Use False only when deliberately rewriting everything.

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (≥200 words). Include concrete next-step suggestions. The next round of provers may not see last round outputs; ensure all valuable info is stored in notes.",
  "new_notes_md": "Markdown (KaTeX allowed). Usually appended to notes.",
  "new_notes_append": "True|False",
  "new_outputs_md": "Markdown (KaTeX allowed). Usually appended to output.md.",
  "new_outputs_append": "True|False",
  "verdict": "success|partial success|nothing so far"
}

**Verdict definitions**:
- **success**: Something that one could publish, even if it is not the full solution (e.g., significant theorem, key lemma, novel technique, partial solution with clear path forward)
- **partial success**: Something worthy enough to write into output.md (e.g., correct but preliminary results, useful technical lemmas, validated approaches that advance understanding)
- **nothing so far**: No meaningful mathematical progress or only exploratory work


--- USER ---
You receive multiple prover reports. Evaluate correctness, value, and pick promising directions. Update notes.md (append/replace) with useful ideas and update output.md (append/replace) ONLY with rigorously verified results.

Prover reports (JSON):
[{"prover_id": "01", "progress_md": "Ideas\n- Strengthen our step-local toolkit with two exact identities that (i) relate changes of all B_j at once to Hamming distances across changed adjacencies, and (ii) sharpen the per-pair effect in the \u201csub-run\u201d regime from the bit-reversal start A_0. These are small, testable steps toward a cross-level scarcity principle.\n- Reassess the \u201cequal-scale scarcity\u201d heuristic. A careful check shows that even with strong grid alignment, a single step can interact with \u0398(log n) levels via the dyadic divisibility lattice; thus the very strong claim \u201conly O(1) active levels per step\u201d is false in that aligned special case. We document the precise extent of this phenomenon.\n\nNew lemmas (clean statements and proofs)\n1) Hamming-sum identity across levels (exact).\n- Statement. For any array A (permutation of {0,\u2026,n\u22121}), let HD_A(i) be the Hamming distance in d-bit binary between the values at positions i and i+1, i\u2208{1,\u2026,n\u22121}. Then for every j, |T_j(A)|=B_j(A)\u22121 counts the edges i where the j-th bit flips; consequently\n  \u03a3_{j=0}^{d\u22121} (B_j(A)\u22121) = \u03a3_{i=1}^{n\u22121} HD_A(i).\n- Moreover, in a single step A\u2192A\u2032, let S be the set of changed indices (three per matched pair). Then\n  \u03a3_{j=0}^{d\u22121} (B_j(A\u2032)\u2212B_j(A)) = \u03a3_{i\u2208S} (HD_{A\u2032}(i) \u2212 HD_A(i)).\n- Proof. For fixed i, the indicator [i\u2208T_j(A)] equals [j-th bits of (A[i], A[i+1]) differ]. Summing over j gives HD_A(i). Summing over i yields the first identity. For the second: outside S adjacencies are unchanged, so HD does not change; inside S, boundary-membership toggles per j encode exactly the change of HD at i; summing over j then over i gives the displayed equality.\u220e\n- Why useful. It is an exact accounting that complements toggle-locality: per changed adjacency, the total \u201cboundary mass\u201d across all levels can change by at most d. This can be paired with level-weighted potentials in future steps. It also indicates why naive unweighted potentials (\u03a3_j B_j) are too crude: a single step can change them by \u0398(d\u00b7|S|).\n\n2) Sub-run per-pair sharpening at A_0 (s < L_j regime).\n- Setup. Fix j, and let L_j := 2^{d\u22121\u2212j} be the j-run length at A_0 (positions are colored by the j-th bit of their values in A_0). Consider a matched pair (L,R) whose union U=L\u222aR has total span s := |U|.\n- Lemma. If s < L_j, then among the three changed indices (left-outer, inner, right-outer) at most one belongs to G_j = T_j(A_0) (the j-boundary set in A_0). Consequently, for A=A_0,\n  \u0394_pair(j) \u2208 {\u22121,0,1}, and in particular |\u0394_pair(j)| \u2264 1.\n- Proof. In A_0 the indices in G_j are exactly multiples of L_j; in particular, any two distinct elements of G_j differ by at least L_j. The three changed indices of the pair lie in the interval from the left-outer to the right-outer boundary, whose length is s+1. Because s < L_j, that interval contains at most one multiple of L_j. Hence at most one of the three changed indices lies in G_j. Applying toggle-locality at A_0, the contribution to |T_j| from this pair\u2019s neighborhood can change by at most 1 in absolute value.\u220e\n- Consequences (first step from A_0). For any level j and any family of pairs with s < L_j, the total j-level change satisfies |\u0394B_j| \u2264 |S\u2229G_j| \u2264 min{m, |G_j|} \u2264 min{m, B_j(A_0)\u22121}, where m is the number of pairs; moreover each contributing pair accounts for at most \u00b11 at level j. This refines Lemma 4 in the sub-run regime for the first step only.\n\n3) Decrease-only alignment bound at A_0 under strong L-grid alignment.\n- Setup. Let L be a positive integer. Suppose a step from A_0 is such that every interval boundary (both pair inners and outers) lies at an index multiple of L (e.g., we partition at indices \u22610 mod L and swap some adjacent blocks). Recall G_j = {i: 2^{d\u22121\u2212j}|i}.\n- Lemma. For any j with 2^{d\u22121\u2212j} \u2224 L (equivalently, L_j \u2224 L), we have Decrease_j = 0.\n- Proof. By toggle-locality at A_0, Decrease_j \u2264 |T_j(A_0)\u2229S|=|G_j\u2229S|. But S\u2286{multiples of L}, and if 2^{d\u22121\u2212j}\u2224L then G_j contains no multiple of L, so the intersection is empty, whence Decrease_j=0.\u220e\n- Remarks.\n  \u2022 Increases may still occur (since new j-boundaries can be created at these indices), i.e., B_j can change even when Decrease_j=0. Thus the lemma is one-sided and must be combined with the desired direction of progress at level j.\n  \u2022 The set of j with 2^{d\u22121\u2212j}|L has size 1+\u230alog_2 L\u230b. Hence even under very strong alignment, \u2018decrease-capable\u2019 levels per step can be \u0398(log L), not O(1). This corrects and quantifies the earlier over-optimistic equal-scale scarcity heuristic.\n\nExamples (sanity checks)\n- n=8, d=3, A_0=[0,4,2,6,1,5,3,7]. Take pairs of size s=2 that do not cross the unique G_0 boundary (at i=4). For j=0, Lemma 2 applies: each such pair changes B_0 by at most \u00b11; in fact, if s=2 and pairs do not straddle i=4, B_0 remains 2.\n- With strong L-grid alignment and L=2, all boundary indices S are even. For j=1 (G_1={2,4,6}), decreases are possible; for j=0 (G_0={4}) decreases are also possible; for hypothetical j with L_j odd (none here), decreases would vanish. This matches Lemma 3.\n\nObstacles and why certain approaches fail\n- Equal-scale scarcity beyond O(1). Even with all boundaries placed on an L-grid, decreases are only blocked for j with 2^{d\u22121\u2212j}\u2224L; for the complementary j (those with 2^{d\u22121\u2212j}|L) decreases are possible, and there are \u0398(log L) such levels. Thus the sought \u201conly O(1) active levels per step\u201d is false under strong alignment. Moreover, for off-scale j where decreases are blocked, increases can occur\u2014and for j in the lower half (where B_j(A_0) < B_j(A_*)), increases actually reduce the potential D_j. This shows that a decrease-only analysis cannot deliver the cross-level scarcity needed for an \u2126(log^2 n) bound.\n- Capacity-style bounds on \u03a3_j Decrease_j/B_j(A_0) suffice only for \u2126(log n). Binning pairs by scale and using per-pair \u00b12 yields \u03a3_j (Decrease_j/B_j(A_0)) \u2264 O(d) per step; hence the log-gap potential \u03a3_j |log B_j \u2212 (d\u2212j)| can drop by \u0398(d) per step, giving only \u2126(d)=\u2126(log n) steps.\n- Why we need a \u201csigned\u201d cross-level constraint. The toggle-locality and Hamming-sum identities show that a changed index influences many levels in a structured way. To bound the drop of a potential like \u03a6(A)=\u03a3_j |log B_j(A)\u2212(d\u2212j)| by O(1), we likely need a cancellation principle across levels (e.g., a signed inequality per changed index), not a pure counting of aligned hits. Establishing such a cancellation is the core open obstacle.\n\nGaps or issues in output.md\n- Output so far is consistent and correct with the factor-3 per-level cap (Theorem 5), toggle-locality (Lemma 3), and the dyadic alignment identity (Theorem 6). The new Lemma 3 above clarifies a one-sided phenomenon (decreases blocked by L-grid misalignment) and should be flagged as one-sided (increases can still occur). No changes to existing statements are needed, but adding the Hamming-sum identity would enrich the toolkit.\n\nNext steps (concrete, testable)\n1) Curate the Hamming-sum identity and the sub-run per-pair sharpening (s<L_j \u21d2 |\u0394_pair(j)|\u22641 at A_0) into output.md. Both are exact/local and straightforward to verify.\n2) Classify per-pair outcomes: For fixed j, characterize exactly when \u0394_pair(j)\u2208{\u22122,\u22121,0,1,2} in terms of the six endpoint bits (a_L,L_1,L_k,R_1,R_m,a_R). This finite case analysis will allow a demand lemma quantifying how many inner-boundary hits (as opposed to outer) are necessary for a large decrease.\n3) Develop a signed cross-level inequality: For a single changed index i, analyze the vector over j of the sign of its contribution to B_j (increase/decrease) in terms of the Hamming patterns before vs. after. Aim: show that for each i, the sum of \u201cuseful signed contributions\u201d to the potential over j is bounded by an absolute constant (or by O(1) after a carefully chosen weighting). This is the most promising route to an O(1) per-step drop for an appropriate potential.\n4) Small-n experiments (n=16,32,64): enumerate random steps from A_0; for each, record the set of j with B_j decreasing by \u2265(1/2)\u00b7B_j, and those with D_j dropping by \u22651. Empirically bound the number of \u201cactive levels\u201d and identify structural patterns of steps that maximize concurrent progress across j.\n5) If step 3 succeeds, integrate with Theorem 5 to show an O(1) drop of \u03a3_j |log B_j \u2212 (d\u2212j)| per step, implying \u2126(log^2 n). Otherwise, pivot to algorithmic exploration: design a multiscale PBT schedule exploiting simultaneous increases/decreases to approach an O(log n) algorithm specific to bit-reversal.\n\nWhy this is progress\n- The Hamming-sum identity is a new exact tool, and the sub-run sharpening is a concrete refinement in a key regime (first step from A_0). The alignment lemma (decreases-only) precisely corrects an earlier heuristic. Together, they map the landscape of what must be overcome for an \u2126(log^2 n) lower bound and outline a plausible, testable path via signed cross-level cancellations."}, {"prover_id": "02", "progress_md": "## Round 0003 \u2014 New local bounds, an aligned-step cross-level inequality, and a reassessment of the \u201cO(1) active-levels\u201d goal\n\n### Quick recap of curated facts (for reference)\n- Toggle-locality identity (curated): for a step with changed-adjacency set S, for each level j,\n  \\[ B_j(A')-B_j(A) = |T_j(A')\\cap S| - |T_j(A)\\cap S|. \\]\n  In particular, Decrease_j \u2264 |T_j(A)\u2229S| and Increase_j \u2264 |S\\setminus T_j(A)|.\n- Per-pair \u00b12 and factor-3 per-level cap (curated): each pair contributes at most \u00b12 to \u0394B_j; hence B_j changes by at most a factor 3 per step.\n- Dyadic alignment at A_0 and the weighted form (curated): for any S, \\(\\sum_j |S\\cap G_j| = \\sum_{i\\in S}(1+v_2(i))\\). Weighted instantiations are available and correct (verifier\u2019s correction applied).\n\n### New: a simple per-step \u201cpair-budget\u201d demand bound\n- Lemma (per-step demand). Let a step use m matched pairs and S its set of changed indices. Then for any fixed bit-level j,\n  \\[\\text{Decrease}_j \\le |T_j(A)\\cap S| \\le |S| \\le 3m.\\]\n  Proof. Immediate from toggle-locality and that a pair changes at most 3 adjacencies.\n- Consequence (coarse necessary condition). A constant-fraction decrease at level j in one step, i.e., \\(\\text{Decrease}_j \\ge \\theta\\,B_j(A)\\), forces \\(m \\ge \\tfrac{\\theta}{3}\\,B_j(A)\\). For A=A_0, this is \\(m \\ge \\tfrac{\\theta}{3}\\,(n/L_j)\\). If moreover all total pair sizes lie in [L,2L], then m \u2264 n/L, so a constant-fraction decrease at j necessitates \\(L_j \\gtrsim L\\). This recovers the intuitive \u201conly levels at or above the step\u2019s scale can be significantly coarsened\u201d necessary condition.\n\nWhy useful here. Although very coarse, this \u201cpair-budget\u201d lower bound is universal (no alignment assumptions) and will be a repeatedly invoked necessary condition when we later combine scale-wise inequalities.\n\n### New: an equal-scale, grid-aligned cross-level inequality at A_0\nWe formalize a clean cross-level bound that leverages alignment to a dyadic grid and will be a base tool for any \u201cphase-by-scale\u201d analysis.\n\n- Setting. Let A=A_0. Fix L=2^\\ell and consider a step with:\n  1) all matched pairs having total sizes in [L,2L), and\n  2) all inner boundaries of the matched pairs at indices divisible by L (i.e., inner boundaries lie on the L-grid).\n  Let m be the number of pairs; thus m \u2264 n/L. Let S be the set of the (at most 3m) changed indices.\n\n- Inequality 1 (large-scale weighted bound). For the set of levels with run-length at least L, i.e., \\(\\{j: L_j\\ge L\\}\\), we have\n  \\[ \\sum_{\\{j: L_j\\ge L\\}} \\frac{L}{L_j}\\,\\text{Decrease}_j\\;\\le\\; 2|S|\\;\\le\\;6m\\;\\le\\;\\frac{6n}{L}. \\]\n  Proof. From toggle-locality: \\(\\sum_j \\frac{L}{L_j}\\,\\text{Decrease}_j \\le \\sum_{i\\in S}\\sum_{\\{j: i\\in G_j,\\,L_j\\ge L\\}} \\frac{L}{L_j}\\). For an index i with 2-adic valuation t = v_2(i), the inner sum is a truncated geometric series \\(\\sum_{s=\\ell}^{t} 2^{\\ell-s} \\le 2\\), and is 0 if t<\\ell. Thus the entire sum is \u2264 2|S|.\n\n- Inequality 2 (small-scale aggregate fractional bound). For the levels with run-length below L (i.e., \\(L_j<L\\)), define \\(w_j:=1/B_j(A_0)=L_j/n\\). Then\n  \\[ \\sum_{\\{j: L_j<L\\}} \\frac{\\text{Decrease}_j}{B_j(A_0)} \\;=\\; \\sum_{\\{j: L_j<L\\}} w_j\\,\\text{Decrease}_j \\;\\le\\; C\\,\\frac{n}{L}\\,\\log\\frac{n}{L} \\cdot \\frac{1}{n}\\;=\\; C\\,\\frac{\\log(n/L)}{L}. \\]\n  Proof idea. Toggle-locality gives \\(\\sum_j w_j\\,\\text{Decrease}_j \\le \\sum_{i\\in S}\\sum_{\\{j: i\\in G_j\\}} w_j\\). For A_0, as in the weighted version of Theorem 6, \\(\\sum_{\\{j: i\\in G_j\\}} w_j = \\sum_{\\{j: i\\in G_j\\}} 2^{-(j+1)}\\), which for v_2(i)=t evaluates to \\(\\le 2^{-d+t+1}\\). The novel ingredient is to bound \\(\\sum_{i\\in S} 2^{v_2(i)}\\) for L-grid-aligned steps: each changed index i lies within distance <2L of a multiple of L; one can show (standard 2-adic counting) that \\(\\sum_{i\\in S}2^{v_2(i)}\\) is \\(O\\big(m\\,2^{\\ell}\\,(1+\\log(\\tfrac{n}{L}))\\big)\\). Dividing by \\(2^d=n\\) yields the RHS. (I will write the detailed combinatorial bound in the next round; it uses that among N integers, the sum of the top-k values of v_2 is O(k log(N/k)+k), and here N\u2248n/L and k\u2248m\u2264N.)\n\n- Consequences (interpreting the two inequalities).\n  \u2022 From Inequality 1: it constrains the total weighted progress at levels with \\(L_j\\ge L\\). In particular, it rules out (in an aligned step) making relative progress \\(\\Omega(1)\\) across more than O(1) geometrically spaced large scales\u2014more precisely, if \\(\\text{Decrease}_j\\ge \\theta B_j\\) for all j in some set J with \\(L_j\\ge L\\), then \\(\\sum_{j\\in J} L/L_j\\) is bounded, which forces J to be concentrated on O(1) adjacent scales. (Note: this does not bound |J| by a constant\u2014it bounds a weighted count; see caveats below.)\n  \u2022 From Inequality 2: at small scales \\(L_j<L\\), the sum of relative decreases \\(\\sum \\text{Decrease}_j/B_j\\) is \\(O(\\log(n/L)/L)\\). Thus for large L (coarse steps), only a tiny number of small-scale levels can see a constant-fraction drop; quantitatively, the number of j with \\(\\text{Decrease}_j\\ge \\theta B_j\\) and \\(L_j<L\\) is \\(O\\big((\\log(n/L))/(\\theta L)\\big)\\).\n\nWhy useful here. These inequalities, while not yet sufficient to give an \\(O(1)\\) drop of \\(\\sum_j |\\log B_j - (d-j)|\\) per step, provide scale-sensitive trade-offs that any \u201cphase-by-scale\u201d lower bound will need. They also identify the small-scale vs. large-scale dichotomy within an aligned step.\n\n### Important reassessment: the \u201cO(1) active levels per step\u201d claim is likely false\n- The earlier speculative Lemma 2 (\u201ca matched boundary is only useful for O(1) levels, hence only O(1) levels can change by a constant factor per step\u201d) appears untenable. Heuristic counterexample: take L=1, align inner boundaries on the 1-grid, and partition into singletons matched pairwise across the entire array. Then S contains almost all indices (up to endpoints), so \\(|S\\cap G_j|\\) is \\(\\Theta(n/L_j)=\\Theta(B_j)\\) for all j simultaneously. Toggle-locality then permits \\(\\Theta(1)\\) relative decreases for \\(\\Theta(\\log n)\\) many levels in the same step. This directly contradicts the \u201cO(1) active levels\u201d narrative.\n- What is still tenable. Our new inequalities show that even though many levels can progress at once, an aligned step cannot simultaneously give large relative progress at scales far below L (Inequality 2) and its weighted progress across higher scales is bounded (Inequality 1). This suggests that any robust lower bound must measure progress with a scale-sensitive potential rather than a flat sum of \\(|\\log B_j - (d-j)|\\).\n\n### A restricted-class milestone: towards an \\(\\Omega(\\log^2 n)\\) bound for scale-phased algorithms\n- Restricted model hypothesis. Consider algorithms that operate in phases; in each phase t, all matched pairs have sizes within a factor-2 window [L_t,2L_t), and (possibly after discarding a constant fraction of pairs by residue-class averaging) the inner boundaries are aligned to the L_t-grid.\n- Strategy sketch. Define a scale-sensitive potential \\(\\Psi(A)=\\sum_j w_t(j)\\,|\\log_2 B_j(A) - (d-j)|\\) whose weights \\(w_t(j)\\) sharply peak around the \u201chome scale\u201d \\(L_j\\approx L_t\\), e.g., \\(w_t(j)=\\alpha^{|\\log_2 L_j - \\log_2 L_t|}\\) for a fixed \\(\\alpha\\in(0,1)\\). Using Inequalities 1\u20132 plus the pair-budget bound, aim to prove that in any L_t-aligned phase, \\(\\Psi\\) decreases by at most a constant. Since \\(\\sum_t 1=\\Theta(\\log n)\\) phases are needed to cover all scales L_t=2^t, this would force \\(\\Omega(\\log^2 n)\\) steps. This is a realistic, checkable plan for the restricted model.\n- Status. The per-phase constant-drop claim requires a careful combinatorial bound on the weighted sum of decreases induced by the S-edges; our Inequality 1 gives the \u201cupper tail\u201d (\\(L_j\\ge L_t\\)) control, and Inequality 2 controls the \u201clower tail\u201d (\\(L_j<L_t\\)). I will formalize the choice of \\(\\alpha\\) and complete the per-phase bound next.\n\n### Gaps and clarifications in output.md\n- Suggest adding the new \u201cpair-budget\u201d lemma stated above; it is an immediate corollary of Lemma 3 (toggle-locality) and is useful for quick necessary conditions.\n- The equal-scale, grid-aligned cross-level bounds (Inequalities 1\u20132) are new and not yet in output.md. They are specialized to A_0, but they capture the key arithmetic-progression intersection needed for any scale-phased lower bound. I recommend curating Inequality 1 (fully rigorous as written) and flagging Inequality 2 as a lemma with a short proof deferred (the only remaining detail is the bound \\(\\sum_{i\\in S}2^{v_2(i)}=O\\big(m2^\\ell(1+\\log(n/L))\\big)\\), which I\u2019ll write out).\n- Caution: the earlier envisioned \u201cO(1) active levels per step\u201d is incompatible with aligned steps at small scale (L=1); hence it should not be pursued as a general lemma. The per-level factor-3 cap remains correct and relevant but does not by itself deliver \\(\\Omega(\\log^2 n)\\).\n\n### Obstacles\n- The sum-of-logs potential \\(\\Phi(A)=\\sum_j |\\log_2 B_j(A)-(d-j)|\\) can drop by \\(\\Theta(\\log n)\\) in a single step (e.g., L=1 aligned), so it is not suitable to yield \\(\\Omega(\\log^2 n)\\) via an \\(O(1)\\) per-step drop.\n- Cross-level scarcity in full generality (without alignment/restrictions) appears false at the granularity of \u201cnumber of active levels.\u201d New lower-bound proofs must use scale-sensitive weights and exploit alignment or pair-size budgets.\n\n### Next steps (concrete and testable)\n1) Curate the \u201cpair-budget\u201d lemma into output.md.\n2) Curate Inequality 1 (large-scale weighted bound) for L-aligned steps from A_0, with a clean proof (as above).\n3) Provide a complete proof of Inequality 2: write the combinatorial bound \\(\\sum_{i\\in S}2^{v_2(i)}=O\\big(m2^\\ell(1+\\log(n/L))\\big)\\) and record it as a lemma on 2-adic valuation sums near an L-grid.\n4) Formalize a per-phase potential \\(\\Psi_t\\) with geometric weights around scale L_t and prove an \\(O(1)\\) per-phase drop in the restricted (aligned, equal-scale) model, yielding \\(\\Omega(\\log^2 n)\\) steps for that class of algorithms.\n5) Empirics on small n (n=32,64): verify that an L=1 aligned step from A_0 can reduce \\(B_j\\) by a constant factor for \\(\\Theta(\\log n)\\) levels, corroborating the reassessment.\n6) Begin investigating whether a strong \u201ccentral-boundary demand\u201d lemma can be salvaged: quantify, per level j, the maximal number of decreases realizable by outer boundaries alone; aim to show that to achieve \\(\\Omega(B_j)\\) decreases one must contribute \\(\\Omega(B_j)\\) via inner boundaries when \\(L_j\\lesssim L\\). This would strengthen Inequality 2 and aid the per-phase bound.\n\n### Why this counts as progress\n- Adds a universal, clean \u201cpair-budget\u201d demand bound for \\(\\text{Decrease}_j\\) that will be used in multiple places.\n- Proves a sharp cross-level inequality (Inequality 1) for aligned steps and outlines a second (Inequality 2) with a near-complete proof plan.\n- Correctly identifies and documents the failure of the \u201cO(1) active levels\u201d approach, steering the program towards scale-sensitive potentials, which are more realistic for an \\(\\Omega(\\log^2 n)\\) lower bound in restricted models.\n- Sets up a feasible restricted-model milestone (equal-scale, grid-aligned phases) where an \\(\\Omega(\\log^2 n)\\) lower bound appears within reach.\n"}]

Current notes.md:
Setting and notation
- Input size n=2^d. The specific permutation A_0 is bit-reversal order of [0,…,n−1]. For j∈{0,…,d−1} we color elements by their j-th bit and denote by B_j(A) the number of monochromatic runs (contiguous blocks of equal j-bit) in the array A. Let T_j(A)⊆{1,…,n−1} be the set of j-run boundary indices (|T_j(A)|=B_j(A)−1). We consider one-step operations that swap a family of disjoint adjacent interval pairs in parallel.
- Our model of one step coincides with PBT (parallel adjacent block transpositions). One step chooses disjoint pairs (L_k,R_k) of adjacent contiguous intervals and swaps every chosen pair simultaneously.

Endpoint calibration (bit-reversal vs sorted)
- For A_0 (bit-reversal), B_j(A_0)=2^{j+1}. For the fully sorted order A_* = [0,1,…,n−1], B_j(A_*)=2^{d−j}. Consequently, the potential Φ(A):=Σ_{j=0}^{d−1} |log_2 B_j(A) − (d−j)| satisfies Φ(A_0)=Θ(d^2) and Φ(A_*)=0.

Locality of changes per pair and a safe per-level cap
- A single swapped pair (L,R) can alter adjacency only at three indices: the left outer boundary before L, the inner boundary between L and R, and the right outer boundary after R. For a fixed level j, if the union L∪R contains no j-boundary of the current array A, then all three affected adjacencies are between same colors both before and after; hence this pair produces no change in B_j.
- Therefore only pairs whose union contains at least one element of T_j(A) can affect B_j. Because the pair unions are disjoint, the number of such pairs is at most |T_j(A)|=B_j(A)−1. Each such pair contributes at most 3 to |B_j(A′)−B_j(A)|. Hence for every j and every PBT step A→A′,
  |B_j(A′) − B_j(A)| ≤ 3(B_j(A) − 1),
  which implies the multiplicative cap B_j(A′) ≤ 4·B_j(A) and B_j(A) ≤ 4·B_j(A′). In particular, |Δ log_2 B_j| ≤ 2 per step.

Dyadic alignment for A_0
- Let G_j denote the j-run boundary set in A_0. Then G_j = { i∈{1,…,n−1} : 2^{d−1−j} divides i }. For any set S of cut indices used in a step, one has
  Σ_{j=0}^{d−1} |S ∩ G_j| = Σ_{i∈S} (1 + v_2(i)) ≤ |S| (1 + ⌊log_2(n−1)⌋),
  since the number of j for which i∈G_j equals 1+v_2(i).

Caveats and corrections to earlier sketches
- The previously proposed “useful boundary” set U_j (indices in or adjacent to T_j(A)) is not a valid certificate for where toggles can occur: the post-step adjacency at a changed index depends on elements imported from potentially far away; mere distance-1 proximity to T_j(A) is insufficient to characterize where toggles can or cannot happen. We avoid using U_j.
- A claimed “size lemma” of the form Δ_j ≤ C·Σ_p min{1, s(p)/L_j} is false deterministically. Short pairs can be aligned to j-gridlines so that Δ_j ≍ n/L_j while the RHS is ≍ n/L_j^2. Any valid size-sensitive bound must use a different aggregation (see Next steps).
- Edge-to-level weighting that relies on fixed dyadic gridlines E_j holds at A_0 but not after the array evolves; after one step the j-boundaries are no longer constrained to those gridlines.

Next steps (program)
1) Try to sharpen the per-level cap to factor 2: Show |B_j(A′)−B_j(A)| ≤ c·|T_j(A)∪T_j(A′)| with small c (ideally c=1 or 2) by charging every toggling edge to a unique j-boundary contained in the union of the pair in either A or A′.
2) Demand for central matches: Prove that achieving a constant-factor decrease of B_j in one step requires Θ(B_j) central-boundary alignments (inner boundaries of swapped pairs) with j-run boundaries of A; outer-boundary hits alone cannot effect global coalescence. Make this precise and robust to local cancellations.
3) Cross-level scarcity via “home levels”: For each pair p of total size s(p), assign h(p) with L_{h(p)}≈s(p). Prove that constant-factor progress at level j needs Σ_{p: h(p)=j} Ω(1) contribution. Since Σ_p s(p) ≤ n and the sets {p: h(p)=j} are disjoint across j, only O(1) levels can make factor-≥2 progress in the same step. First prove the equal-scale special case (all pairs have sizes within ×2 of some L), which should already yield an Ω(log^2 n) lower bound for that restricted class.
4) Use the dyadic structure of G_j at A_0 to formalize a “central-boundary alignment trade-off” across levels: matched central boundaries that effect progress for one j are largely incompatible with those needed for many other j due to disjointness and dyadic spacing.
5) Perform small-n experiments (n=16,32) to estimate the maximal number of levels that can experience ≥2× change in B_j in one step and to guide constants.
New: toggle-locality identity and consequences
- Let A→A′ be one PBT step and let S⊆{1,…,n−1} be the set of indices whose adjacency changes in this step (exactly three per matched pair: left outer, inner, right outer; omit outer ones at array ends if absent). For each j, let T_j(A) be the set of j-run boundary indices (|T_j(A)|=B_j(A)−1).
- Identity (toggle-locality). For every j,
  B_j(A′) − B_j(A) = |T_j(A′) ∩ S| − |T_j(A) ∩ S|.
  Reason: outside S, adjacencies (and hence boundary membership) are identical in A and A′, so T_j(A′) Δ T_j(A) ⊆ S, which implies the stated cardinality identity.
- Corollary (one-sided bounds). For every j,
  Decrease_j := max{0, B_j(A) − B_j(A′)} ≤ |T_j(A) ∩ S|,
  Increase_j := max{0, B_j(A′) − B_j(A)} ≤ |S \ T_j(A)|.
  Interpretation: shrinking B_j by Δ forces at least Δ of the changed indices to land on current j-boundaries.

Improved per-level cap via per-pair ±2
- Per pair (L,R) and fixed j, define Δ_pair as the change in the number of j-boundaries attributable to that pair; then |Δ_pair| ≤ 2 (prove by the binary 4-cycle inequality on the three interfaces). In addition, only pairs whose union is non-monochromatic at level j can contribute, and such pairs are at most |T_j(A)| by disjointness (charge to an internal j-boundary index).
- Summing gives |B_j(A′)−B_j(A)| ≤ 2·|T_j(A)| = 2(B_j(A)−1). Applying the bound to the inverse step yields the multiplicative cap B_j(A′) ≤ 3B_j(A) and B_j(A) ≤ 3B_j(A′). Thus |Δ log_2 B_j| ≤ log_2 3 per step.

Weighted dyadic alignment at A_0 and a corrected weighted bound
- For A_0, G_j = T_j(A_0) is the dyadic grid {i: 2^{d−1−j} | i}. For any set S of changed indices, Σ_j |S∩G_j| = Σ_{i∈S} (1+v_2(i)). More generally, for nonnegative weights a_j, Σ_j a_j·|S∩G_j| = Σ_{i∈S} Σ_{j: i∈G_j} a_j.
- Combining with toggle-locality yields the exact inequality Σ_j a_j·Decrease_j ≤ Σ_{i∈S} Σ_{j: i∈G_j} a_j. For the specific weights a_j=2^{−(j+1)}, if v_2(i)=t then Σ_{j: i∈G_j} 2^{−(j+1)} = 2^{−(d−t−1)}(1−2^{−(t+1)}) ≤ 2^{−d+t+1}. Thus Σ_j 2^{−(j+1)}·Decrease_j ≤ Σ_{i∈S} 2^{−d+v_2(i)+1}. (This corrects a factor-2 slip in an earlier draft.)

Caution on “equal-scale first-step scarcity from A_0”
- The claim “if L_j > s then every union U=L∪R is j-monochromatic in A_0” is false. Counterexample (n=8, j=0): L_j=4; a union U of size s=2 that straddles the unique G_0 index at 4 is not monochromatic.
- What does hold: the per-pair ±2 bound implies |ΔB_j| ≤ 2m ≤ 2n/s for any j. From A_0 this yields that if L_j ≪ s then |ΔB_j|/B_j(A_0) ≤ O(L_j/s)=o(1), so constant-factor decreases at such j are impossible in that step. This does not preclude large changes when L_j ≫ s; additional structure (e.g., grid-aligned inner boundaries) seems necessary to prove an O(1) cap on the number of “active levels”.

Planned direction: equal-scale, grid-aligned scarcity
- Assume an L-aligned step: pair sizes in [L,2L) and all inner boundaries on the L-grid. For A starting at A_0, use arithmetic progression intersections to show that for off-scale j (2^{d−1−j} far from L) the proportion |S∩G_j|/B_j is o(1); combine with toggle-locality to rule out constant-factor decreases at those j. Only O(1) consecutive j with 2^{d−1−j}∈[L/2,2L] can be “active”. Control outer-boundary contributions by noting they contribute only O(#pairs) points, spread over a constant number of L-residue classes.

Next steps (actionable)
1) Write the full aligned-scarcity proof, including the precise bounds on |S∩G_j| and |S\G_j| for off-scale j.
2) Extend to near-alignment by averaging over residues modulo L to extract a constant-aligned subfamily.
3) Develop a central-vs-outer charging lemma: quantify the fraction of Decrease_j that must be paid by inner boundaries hitting T_j(A), uniformly over steps. This will dovetail with a home-level charging scheme for pairs.
4) Continue small-n experiments (n=32,64,128) to probe the number of levels with ≥ constant-factor decreases under equal-scale steps.


Current output.md (if any):
Statements and proofs curated so far

Setup and notation
- Let n=2^d. An array A is a permutation of [0,…,n−1]. For j∈{0,…,d−1}, color each entry of A by the j-th bit of its value and let B_j(A) be the number of monochromatic runs in this 2-coloring. Let T_j(A)⊆{1,…,n−1} be the set of indices i where the j-color flips between positions i and i+1 (so |T_j(A)|=B_j(A)−1). A single step A→A′ is a parallel block transposition (PBT): a product of disjoint swaps of adjacent contiguous interval pairs (L,R). Such a step changes adjacencies only at the three interface indices of each pair (left outer, inner, right outer; omitting outer ones at the array ends).

Theorem 1 (Model equivalence to PBT). A single step of the model (swapping a family of disjoint adjacent interval pairs in parallel) is exactly a parallel block transposition (PBT) step.
Proof. A step chooses disjoint adjacent pairs (L_k,R_k) of intervals and swaps each pair simultaneously, leaving all other positions untouched. This is precisely a product of disjoint adjacent block transpositions. Conversely, any product of disjoint adjacent block transpositions can be realized by choosing those pairs. ∎

Theorem 2 (Endpoint run-counts). Let n=2^d and A_0 be the bit-reversal permutation of [0,…,n−1]. For j∈{0,…,d−1}:
- B_j(A_0)=2^{j+1}.
- For the fully sorted order A_*=[0,1,…,n−1], B_j(A_*)=2^{d−j}.
Consequently, with D_j(A):=|log_2 B_j(A) − (d−j)|, one has Σ_{j=0}^{d−1} D_j(A_0)=Θ(d^2) and Σ_{j=0}^{d−1} D_j(A_*)=0.
Proof. In A_0, the j-bit of the value at position i equals the (d−1−j)-th bit of i; thus along positions 0,…,n−1 this bit is constant on runs of length 2^{d−1−j} and alternates every such block, giving exactly 2^{j+1} runs. In A_*, the j-bit is constant on blocks of length 2^j and alternates every 2^j positions, yielding 2^{d−j} runs. The Θ(d^2) sum follows from Σ_{j=0}^{d−1} |2j+1−d| = Θ(d^2) by symmetry around (d−1)/2. ∎

Lemma 3 (Toggle-locality identity). Let A→A′ be one PBT step and let S be the set of indices whose adjacency changes in this step (the three interfaces per pair). Then for every j,
  B_j(A′) − B_j(A) = |T_j(A′) ∩ S| − |T_j(A) ∩ S|.
In particular, Decrease_j := max{0, B_j(A) − B_j(A′)} ≤ |T_j(A) ∩ S| and Increase_j := max{0, B_j(A′) − B_j(A)} ≤ |S \ T_j(A)|.
Proof. If i∉S then the adjacent entries across i are the same in A and A′, hence i∈T_j(A) iff i∈T_j(A′). Thus T_j(A′) Δ T_j(A) ⊆ S and
|T_j(A′)|−|T_j(A)| = |T_j(A′)∩S| − |T_j(A)∩S|.
Since B_j(·)=|T_j(·)|+1, the displayed identity follows; the one-sided bounds are immediate. ∎

Lemma 4 (Per-pair ±2 bound at a fixed level). Fix j and a single swapped pair (L,R). Let Δ_pair be its contribution to ΔB_j. Then |Δ_pair| ≤ 2. Moreover, if the union U=L∪R is j-monochromatic (equivalently, contains no index of T_j(A)), then Δ_pair=0.
Proof. Only the three interface indices can change their boundary status. Let a_L be the j-color of the neighbor immediately left of L, a_R the j-color of the neighbor immediately right of R; let L_1,L_k be the first/last j-colors in L and R_1,R_m the first/last j-colors in R. Writing [·] for the indicator of inequality, the total contribution before the swap equals
  X := [a_L≠L_1] + [L_k≠R_1] + [R_m≠a_R],
and after the swap equals
  Y := [a_L≠R_1] + [R_m≠L_1] + [L_k≠a_R].
Thus Δ_pair = X − Y. Using the inequality [q≠x] − [q≠y] ≤ [x≠y] twice gives
  Δ_pair ≤ [L_1≠R_1] + [R_m≠L_k] + ([L_k≠R_1] − [R_m≠L_1]).
The binary 4-cycle inequality [p≠q]+[q≠r]+[r≠s]−[s≠p] ≤ 2, applied to (p,q,r,s)=(L_1,R_1,L_k,R_m), yields Δ_pair ≤ 2. The lower bound follows symmetrically (or by applying the argument to the inverse swap). If U is j-monochromatic then L_1=L_k=R_1=R_m and all three interface indicators are unchanged, so Δ_pair=0. ∎

Theorem 5 (Per-level factor-3 cap per step). For any array A, any j, and any single PBT step A→A′,
  B_j(A′) ≤ 3·B_j(A) and B_j(A) ≤ 3·B_j(A′).
Equivalently, |log_2 B_j| changes by at most log_2 3 in one step.
Proof. Let M_j(A) be the set of swapped pairs whose union U is not j-monochromatic in A. By disjointness of the unions, each U∈M_j(A) contains at least one index of T_j(A), and distinct U’s receive distinct such indices; hence |M_j(A)| ≤ |T_j(A)| = B_j(A)−1. Summing Lemma 4 over pairs gives
  |B_j(A′) − B_j(A)| ≤ Σ_{pairs} |Δ_pair| ≤ 2·|M_j(A)| ≤ 2(B_j(A)−1).
Therefore B_j(A′) ≤ B_j(A) + 2(B_j(A)−1) ≤ 3B_j(A). Applying the same bound to the inverse step A′→A yields B_j(A) ≤ 3B_j(A′). ∎

Theorem 6 (Dyadic alignment for A_0; weighted form). Let G_j⊆{1,…,n−1} be the set of j-run boundary indices in A_0. Then G_j = { i : 2^{d−1−j} divides i }. For any set S⊆{1,…,n−1},
  Σ_{j=0}^{d−1} |S ∩ G_j| = Σ_{i∈S} (1 + v_2(i)).
More generally, for any weights a_j≥0,
  Σ_{j=0}^{d−1} a_j·|S ∩ G_j| = Σ_{i∈S} Σ_{j: 2^{d−1−j} | i} a_j.
Proof. In A_0 the j-bit is periodic with period 2^{d−j}, so boundaries occur exactly at indices i that are multiples of 2^{d−1−j}. For fixed i, the set of j with i∈G_j has size 1+v_2(i); the weighted identity is immediate by exchanging sums. ∎

Corollary 6.1 (Weighted decrease bound from A_0). In one step A_0→A′ with changed-index set S, and any weights a_j≥0,
  Σ_{j} a_j·Decrease_j ≤ Σ_{i∈S} Σ_{j: i∈G_j} a_j.
In particular, with a_j=2^{−(j+1)} and v_2(i)=t,
  Σ_{j} 2^{−(j+1)}·Decrease_j ≤ Σ_{i∈S} 2^{−(d−t−1)}(1−2^{−(t+1)}) ≤ Σ_{i∈S} 2^{−d+t+1}.
Proof. Combine Lemma 3 with Theorem 6 and use nonnegativity of the weights; the explicit sum for a_j=2^{−(j+1)} is a direct geometric series. ∎

