--- SYSTEM ---
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (summary so far)
- output.md (rigorously proven results so far)

Guidelines:
- notes.md: should be a readable running log of interesting work. Prefer appending. Replace only if old notes are clearly misleading. Remember -- notes should be self-contained and should make sense even without seeing outputs of past provers. 
- output.md:  Think twice before you add something to this file. Everything here should be rigorous, almost publication-ready. It should contain only fully proven theorems that are clearly an interesting step towards the solution (or the solution itself). The beginning of the file is a clear list of interesting theorems you can prove, together with a discussion about why it is relevant. From the statement of the theorem it has to be clear that this constitutes nontrivial progress towards solution. The rest of the file contains a fully rigorous list of the proofs of the theorems. Keep only proven theorems with clear proofs. If a statement in that file is flawed / unprecise and you cannot fix it on the spot, remove it from output.md and instead add it to notes.md with explanation.
- Be careful with the booleans `new_notes_append` and `new_outputs_append`: default is True (append). Use False only when deliberately rewriting everything.

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (≥200 words). Include concrete next-step suggestions. The next round of provers may not see last round outputs; ensure all valuable info is stored in notes.",
  "new_notes_md": "Markdown (KaTeX allowed). Usually appended to notes.",
  "new_notes_append": "True|False",
  "new_outputs_md": "Markdown (KaTeX allowed). Usually appended to output.md.",
  "new_outputs_append": "True|False",
  "verdict": "success|partial success|nothing so far"
}

**Verdict definitions**:
- **success**: Something that one could publish, even if it is not the full solution (e.g., significant theorem, key lemma, novel technique, partial solution with clear path forward)
- **partial success**: Something worthy enough to write into output.md (e.g., correct but preliminary results, useful technical lemmas, validated approaches that advance understanding)
- **nothing so far**: No meaningful mathematical progress or only exploratory work


--- USER ---
You receive multiple prover reports. Evaluate correctness, value, and pick promising directions. Update notes.md (append/replace) with useful ideas and update output.md (append/replace) ONLY with rigorously verified results.

Prover reports (JSON):
[{"prover_id": "01", "progress_md": "Headlines\n- New exact, first-step bounds at A_0: a 2-adic \u201clayer-cake\u201d inequality for changed indices S implies a sharp upper bound on the weighted mass \u03a3_i 2^{v_2(i)} in terms of the number m of matched pairs. Combined with toggle-locality and the dyadic alignment identity, this yields a rigorous small-scale fractional bound: for a step from A_0 using m pairs, the sum of relative decreases \u03a3_{j: L_j<L} Decrease_j/B_j(A_0) \u2264 O((1+log(n/m))/L). For equal-scale steps (all pair lengths in [L,2L)), this simplifies to O((log L)/L). This fills the gap flagged in the verifier\u2019s feedback (our previous Inequality 2 lacked a proof).\n- Consequences: in an equal-scale step, the total \u201crelative progress budget\u201d across all levels strictly below scale L is o(1) when L grows, sharply constraining simultaneous factor reductions at those levels in one step. This complements the large-scale weighted bound already curated (Theorem 8) and is ready to be added to output.md as a pair of lemmas/corollaries.\n\nNew lemmas and proofs (ready to curate)\n1) Lemma (2-adic layer-cake bound for changed indices).\nSetup. Let n=2^d, A=A_0, and let a single step use m matched pairs. Let S\u2286{1,\u2026,n\u22121} be the set of changed adjacency indices (|S|\u22643m). For t\u22650 let M_t={i\u2208{1,\u2026,n\u22121}: 2^t divides i}.\nClaim. One has\n\u03a3_{i\u2208S} 2^{v_2(i)} \u2264 C\u00b7n\u00b7(1+log_2(n/m)) for an absolute constant C.\nProof. For any i, write 2^{v_2(i)} \u2264 2\u00b7\u03a3_{t=0}^{v_2(i)} 2^t = 2\u00b7\u03a3_{t\u22650} 2^t\u00b71_{(i\u2208M_t)}; hence\n\u03a3_{i\u2208S} 2^{v_2(i)} \u2264 2\u00b7\u03a3_{t\u22650} 2^t\u00b7|S\u2229M_t|.\nFor each t, |S\u2229M_t| \u2264 min{3m, \u230a(n\u22121)/2^t\u230b}. Let T=\u230alog_2(n\u22121)\u230b and choose t_0 = \u230alog_2((n\u22121)/(3m))\u230b (take t_0=\u22121 if (n\u22121)/(3m)<1). Then\n\u03a3_{t=0}^{T} 2^t\u00b7|S\u2229M_t| \u2264 \u03a3_{t\u2264t_0} 2^t\u00b73m + \u03a3_{t>t_0} 2^t\u00b7(n/2^t)\n\u2264 3m\u00b7(2^{t_0+1}\u22121) + n\u00b7(T\u2212t_0)\n\u2264 6m\u00b72^{t_0} + n\u00b7log_2(2n/(3m)) \u2264 2n + n\u00b7log_2(2n/(3m)).\nMultiplying by the factor 2 from the first inequality yields the claim with C an absolute constant.\u220e\nWhy useful. This bound depends only on n and the number of pairs m, not on any alignment assumptions. It is exactly the missing upper bound on \u03a3_{i\u2208S}2^{v_2(i)} requested in the verifier\u2019s note, and it plugs into the toggle-locality/weighted-dyadic framework at A_0.\n\n2) Theorem (small-scale fractional decrease bound at A_0).\nLet A=A_0, n=2^d. For any integer L\u22651,\n\u03a3_{j: L_j<L} Decrease_j / B_j(A_0) \u2264 (2/(nL))\u00b7\u03a3_{i\u2208S} 2^{v_2(i)}.\nIn particular, for a step with m pairs,\n\u03a3_{j: L_j<L} Decrease_j / B_j(A_0) \u2264 C\u00b7(1+log(n/m))/L.\nProof. Apply Lemma 3 (toggle-locality) with the weighted dyadic identity (Theorem 6) using weights a_j = (1/L)\u00b71_{L_j<L}\u00b7(1/B_j(A_0)) = (1/L)\u00b72^{\u2212(j+1)}:\n\u03a3_{j: L_j<L} Decrease_j/B_j(A_0) \u2264 (1/L)\u00b7\u03a3_{i\u2208S} \u03a3_{j: i\u2208G_j} 2^{\u2212(j+1)} = (1/L)\u00b7\u03a3_{i\u2208S} 2^{\u2212(d\u2212v_2(i)\u22121)} = (2/(nL))\u00b7\u03a3_{i\u2208S} 2^{v_2(i)}.\nThe inequality then follows from the Lemma above.\u220e\n\nCorollary (equal-scale specialization). If all matched pairs have total lengths in [L,2L), then m\u2264n/L and hence\n\u03a3_{j: L_j<L} Decrease_j / B_j(A_0) \u2264 C\u00b7(1+log L)/L.\nIn particular, as L grows, the total relative decrease budget below scale L in a single equal-scale step is o(1).\n\nCorollary (counting active small-scale levels). Fix \u03b8\u2208(0,1]. In a step with m pairs, the number of levels j with L_j<L and Decrease_j \u2265 \u03b8\u00b7B_j(A_0) is at most O((1+log(n/m))/(\u03b8 L)). In the equal-scale [L,2L) regime this is O((1+log L)/(\u03b8 L)).\n\nWhy these results matter\n- They provide the first rigorous, scale-sensitive small-scale trade-off from A_0: at scales strictly below L, the sum of relative decreases is bounded by O((log(n/m))/L), and hence by O((log L)/L) in equal-scale phases. This matches and formalizes the previously heuristic \u201cInequality 2\u201d (now fully proved, with clear constants) and dovetails with the already curated large-scale bound (Theorem 8):\n  \u2022 Large scales L_j\u2265L: \u03a3_{j} (L/L_j)\u00b7Decrease_j \u2264 6m.\n  \u2022 Small scales L_j<L: \u03a3_{j} Decrease_j/B_j(A_0) \u2264 C\u00b7(1+log(n/m))/L.\n- Together, these are precisely the ingredients needed to bound per-phase progress under an equal-scale scheduling: the \u201cupper tail\u201d (large L_j) is controlled by the (L/L_j)-weighted absolute decreases, while the \u201clower tail\u201d (small L_j) admits only a vanishing total relative decrease of order (log L)/L. This strongly suggests that a geometric-weighted potential concentrated near the phase\u2019s home scale L can be shown to drop by O(1) per phase, yielding an \u03a9(log^2 n) lower bound for algorithms that proceed in equal-scale phases (grid alignment not required for the new small-scale bound).\n\nSanity checks and examples\n- n=16, consider an equal-scale L=4 step. Then m\u2264n/L=4 and (1+log(n/m))/L \u2264 (1+log(16/4))/4 = (1+2)/4 = 3/4. The corollary asserts \u03a3_{j: L_j<4}(Decrease_j/B_j(A_0)) \u2264 O(0.75). Since L_j<4 means j with run lengths 1 or 2 (i.e., j\u2208{2,3}), the total fractional decrease across these two levels cannot exceed a constant < 1, precluding simultaneous 1/2-fraction drops at both j=2 and j=3 in a single L=4 step.\n- For a coarser step, say L=n/8, m\u22648 and (1+log(n/m))/L = O((1+log(n/8))/ (n/8)) = O((log n)/n), i.e., negligible small-scale progress below L.\n\nHow to combine with Theorem 8 (large scales)\n- Theorem 8 bounds \u03a3_{j: L_j\u2265L} (L/L_j)\u00b7Decrease_j \u2264 6m (\u2264 6n/L in equal-scale). This controls absolute decreases with a decaying weight L/L_j. Translating to log-changes requires care; however, for large-scale levels, a drop in log B_j is at most O(Decrease_j/B_j) per level (whenever Decrease_j \u2264 B_j/2), and is uniformly O(1) otherwise by Theorem 5 (factor-3 cap). An O(1)-per-phase drop for a geometric-weighted potential \u03a8_L(A)=\u03a3_j w_L(j)\u00b7|log B_j(A)\u2212(d\u2212j)| with weights w_L(j) sharply peaked around L (e.g., w_L(j)=min{1, L/L_j} or a smoother geometric taper) appears within reach: the new small-scale bound controls the tail j with L_j<L, while Theorem 8 controls the upper tail j with L_j\u2265L. I will formalize this per-phase potential in the next round.\n\nGaps or errors in output.md\n- No errors spotted in the currently curated items. The new small-scale fractional bound (Theorem above and its corollaries) is currently missing and should be added. It relies only on Lemma 3 (toggle-locality), Theorem 6 (dyadic alignment at A_0), and the new Lemma (2-adic layer-cake bound), all of which are now self-contained and rigorously proved.\n\nObstacles and limitations (explicit)\n- The new bounds are first-step-from-A_0 statements; after the array evolves, the clean dyadic identity (Theorem 6) no longer applies. Extending small-scale scarcity beyond the first step will require either (i) re-establishing a comparable structure on T_j(A) for the current A, or (ii) designing a different potential/weighting (possibly using the Hamming-sum identity, Theorem 7) that yields per-index signed cancellations across levels without relying on A_0\u2019s dyadic grids.\n- Large-scale progress to log-potential drop still needs a careful argument converting \u03a3 (L/L_j)\u00b7Decrease_j into a comparable bound on \u03a3 w_L(j)\u00b7\u0394 log B_j; this will use the factor-3 cap and case distinctions (small vs. large relative drops) per level.\n\nNext steps (concrete and testable)\n1) Curate the new Lemma (2-adic layer-cake bound) and the Theorem + corollaries (small-scale fractional bounds) into output.md.\n2) Define a geometric phase-potential \u03a8_L and prove an O(1) drop for equal-scale phases by combining Theorem 8 with the new small-scale inequality; quantify constants and edge cases (levels exhibiting >1/2 relative drop) via Theorem 5.\n3) Explore signed cross-level weights using the Hamming-sum identity (Theorem 7): attempt to bound, per changed index i, the weighted sum over j of contributions to \u0394 log B_j by O(1), to decouple from A_0.\n4) Case-analysis toward a \u201ccentral-boundary demand\u201d lemma: classify per-pair \u0394_pair(j) in terms of six endpoint bits and show that achieving \u03a9(B_j) decrease forces \u03a9(B_j) inner-boundary hits; this would generalize small-scale control past the first step.\n5) Small-n experiments (n=32,64): validate the sum-of-fractional-decreases bound in equal-scale steps and measure how close to saturation steps can get at various L.\n\nSummary\n- Established a crisp and fully rigorous small-scale fractional bound from A_0: \u03a3_{L_j<L} Decrease_j/B_j(A_0) \u2264 C\u00b7(1+log(n/m))/L, and in particular, \u2264 C\u00b7(log L)/L in equal-scale [L,2L) steps. The core technical tool is a new 2-adic layer-cake bound on \u03a3_{i\u2208S}2^{v_2(i)} that depends only on m.\n- This complements the curated large-scale weighted decrease bound and is a key building block toward an \u03a9(log^2 n) lower bound in a phase-by-scale regime. The per-phase potential argument remains to be written; the present lemmas are immediately curatable and advance the program materially."}, {"prover_id": "02", "progress_md": "Headlines\n- New extremal inequality: for any K-subset S\u2286{1,\u2026,N}, one has \u03a3_{i\u2208S} 2^{v_2(i)} \u2264 N\u00b7H_K (H_K the K-th harmonic number). This sharpens and formalizes the 2-adic summation bound needed in Corollary 6.1 and yields \u03a3_j Decrease_j/B_j(A_0) \u2264 O(log(n/L)) in equal-scale steps with \u2264 n/L pairs.\n- Geometric-window weights (first-step from A_0): for any fixed scale L=2^\u2113 and any step (no alignment assumed) whose changed-index set is S, define a_j(L):=\u03b2^{| (d\u22121\u2212j) \u2212 \u2113 |}/2^{j+1} with \u03b2\u2208(0,1/2). Then \u03a3_j a_j(L)\u00b7Decrease_j \u2264 C_\u03b2\u00b7(L/n)\u00b7|S|. In particular, for equal-scale steps with m pairs (hence |S|\u22643m\u22643n/L), one gets \u03a3_j a_j(L)\u00b7Decrease_j \u2264 3C_\u03b2 = O(1). This gives an O(1) per-step cap on a scale-focused, cross-level weighted decrease from the bit-reversal start.\n\nGaps or corrections in output.md to flag\n- The current output already contains Theorem 8 (large-scale weighted decrease bound) and Lemma 7.2 (sub-run decrease bound), both correct. There is, however, still no curated bound of the form \u03a3_{i\u2208S}2^{v_2(i)} in terms of |S|. I recommend adding the extremal bound below as a lemma; it is used implicitly in several sketches and enables a clean derivation of \u03a3_j Decrease_j/B_j(A_0) \u2264 O(log(n/L)).\n- The program still lacks any signed, cross-level per-step bound that applies beyond the first step (once A deviates from A_0). The geometric-window lemma below is first-step specific (it uses T_j(A_0)=G_j) and cannot be applied verbatim after the array evolves.\n\nNew technical lemmas (ready to curate)\n1) Extremal 2-adic sum bound.\nLemma. Let N\u22651 and S\u2286{1,\u2026,N} with |S|=K\u22651. Then \u03a3_{i\u2208S} 2^{v_2(i)} \u2264 N\u00b7H_K, where H_K=1+1/2+\u22ef+1/K.\nProof. Order the weights w(i):=2^{v_2(i)} for i\u2208{1,\u2026,N} in nonincreasing order s_1\u2265s_2\u2265\u22ef\u2265s_N. For t\u22650, at most \u230aN/2^t\u230b integers have v_2\u2265t, i.e., at most \u230aN/2^t\u230b weights are \u22652^t. Hence for every \u2113\u22651, s_\u2113 \u2264 max{2^t : N/2^t \u2265 \u2113} \u2264 N/\u2113. Therefore \u03a3_{i\u2208S} 2^{v_2(i)} \u2264 \u03a3_{\u2113=1}^K s_\u2113 \u2264 \u03a3_{\u2113=1}^K (N/\u2113) = N\u00b7H_K.\u220e\nCorollary (small-scale fractional decreases, coarse but general). For A=A_0, any step with changed-index set S (|S|=K) satisfies\n\u03a3_{j=0}^{d\u22121} Decrease_j/B_j(A_0) = \u03a3_j 2^{\u2212(j+1)}\u00b7Decrease_j \u2264 (2/n)\u00b7\u03a3_{i\u2208S} 2^{v_2(i)} \u2264 2\u00b7H_K.\nIn particular, in an equal-scale step with m pairs (hence K\u22643m\u22643n/L), \u03a3_j Decrease_j/B_j(A_0) \u2264 O(log(n/L)).\nWhy useful: This fully rigorous bound replaces the previously sketched Inequality 2 with a clean, general estimate (though without the extra 1/L factor). It confirms that, in aggregate and relative to B_j(A_0), only logarithmic-in-(n/L) fractional shrinkage can be achieved across all levels in an equal-scale step.\n\n2) Geometric-window weighted cross-level decrease (first step from A_0).\nLemma (geometric window). Fix L=2^\u2113 and pick any \u03b2\u2208(0,1/2). Define scale-centered weights a_j(L):=\u03b2^{| (d\u22121\u2212j) \u2212 \u2113 |}/2^{j+1}. For A=A_0 and any one-step change with index set S,\n\u03a3_{j=0}^{d\u22121} a_j(L)\u00b7Decrease_j \u2264 C_\u03b2\u00b7(L/n)\u00b7|S|,\nwhere C_\u03b2 := (1/(1\u2212\u03b2/2) + 1/(1\u22122\u03b2)). In particular, for equal-scale steps with m pairs one has \u03a3_j a_j(L)\u00b7Decrease_j \u2264 3C_\u03b2=O(1).\nProof. By toggle-locality and Theorem 6 (weighted form at A_0),\n\u03a3_j a_j(L)\u00b7Decrease_j \u2264 \u03a3_{i\u2208S} \u03a3_{j: i\u2208G_j} a_j(L).\nFor i with v_2(i)=t, the inner sum ranges over j with s:=d\u22121\u2212j\u2208{0,1,\u2026,t} and equals\n\u03a3_{s=0}^{t} \u03b2^{|s\u2212\u2113|}\u00b72^{s\u2212d} = 2^{\u2212d}\u00b7(\u03a3_{s=0}^{\u2113} \u03b2^{\u2113\u2212s}2^{s} + \u03a3_{s=\u2113}^{t} \u03b2^{s\u2212\u2113}2^{s}).\nBound the two parts separately: \u03a3_{s=0}^{\u2113} \u03b2^{\u2113\u2212s}2^{s} = 2^{\u2113}\u00b7\u03a3_{r=0}^{\u2113} (\u03b2/2)^r \u2264 2^{\u2113}/(1\u2212\u03b2/2), and \u03a3_{s=\u2113}^{t} \u03b2^{s\u2212\u2113}2^{s} = 2^{\u2113}\u00b7\u03a3_{r=0}^{t\u2212\u2113} (2\u03b2)^r \u2264 2^{\u2113}/(1\u22122\u03b2). Thus, \u03a3_{j: i\u2208G_j} a_j(L) \u2264 C_\u03b2\u00b72^{\u2113\u2212d} = C_\u03b2\u00b7(L/n). Summing over i\u2208S gives the claim; using |S|\u22643m and m\u2264n/L (equal-scale) yields the O(1) consequence.\u220e\nRemarks.\n- Crucially, this does not assume any alignment; it is purely a first-step property from A_0. It precisely formalizes the \u201chome scale\u201d phenomenon: pairs with total size \u2248L can only induce O(1) total weighted decreases when measured by a geometric window centered at that scale.\n- The choice of \u03b2<1/2 ensures the tail beyond the home scale decays sufficiently quickly (the 2\u03b2 factor in the upper tail), giving a per-index constant bound.\n\nHow these help and their limits\n- The extremal 2-adic bound plus Corollary cleanly upper bound aggregate relative decreases across all levels by O(log(n/L)) in an equal-scale step. While not strong enough alone for an O(1) per-step drop of the unweighted potential, it quantifies a strict trade-off for small scales.\n- The geometric-window lemma provides an O(1) per-step cap for a family of scale-focused, cross-level weighted potentials at the bit-reversal start. This is the first rigorous cross-level scarcity result that is scale-sensitive and constant per equal-scale step.\n- Limitation: Both statements rely on A=A_0. After the first step, the boundary sets T_j(A) are no longer dyadic grids, so Theorem 6 cannot be applied directly. Extending the geometric-window argument beyond the first step requires new structure (e.g., showing that after a near-L step from A_0 the sets T_j(A) retain enough arithmetic regularity at scales \u2248L to re-run the argument, or developing a signed, per-index cancellation bound that is independent of A).\n\nSanity checks and examples\n- n=16, L=4 (\u2113=2), \u03b2=1/4. In a step of 4-block pairs (m\u22644), we have |S|\u226412 and L/n=1/4, hence \u03a3_j a_j(L)\u00b7Decrease_j \u2264 C_\u03b2\u00b7(1/4)\u00b712 = O(1). Empirically, the only levels with noticeable (unweighted) decreases are those with L_j\u2208{2,4,8} (adjacent to L), consistent with \u201chome-scale\u201d concentration.\n- For L=1 (singletons paired), the geometric-window lemma still bounds the windowed decrease by O(1), despite the possibility that \u0398(log n) levels see constant-factor unweighted changes. This illustrates the necessity of scale-sensitive weights.\n\nObstacles\n- The geometric-window lemma is \u201cfirst-step only.\u201d Without a characterization of T_j(A) after a step, we cannot iterate the bound. A naive attempt to keep measuring against G_j (of A_0) does not telescope to a lower bound on sorting time.\n- The extremal bound yields only O(log(n/L)) control on \u03a3_j Decrease_j/B_j(A_0); taken over \u0398(log n) scales this still gives merely \u03a9(log n) steps for the unweighted potential.\n- A signed cross-level inequality (bounding a weighted combination of decreases and increases that correlates with |log B_j\u2212(d\u2212j)|) remains open. The Hamming-sum identity suggests such cancellation might be possible with carefully chosen weights, but a precise bound is not yet proved.\n\nNext steps (actionable)\n1) Curate the extremal 2-adic bound and the geometric-window lemma into output.md (after verifier checks), as they are exact and broadly useful.\n2) Search for persistence of arithmetic regularity: After an equal-scale step from A_0 at scale L, characterize T_j(A) for j with L_j\u2248L. Goal: show these boundary sets are unions of a bounded number of arithmetic progressions with large modulus, enabling a rerun of the geometric-window argument at the next step.\n3) Signed per-index inequality: For a single changed index i (arbitrary A), analyze the vector over j of contributions to B_j(A\u2032)\u2212B_j(A) via HD_{A\u2032}(i)\u2212HD_A(i). Try weights of the form a_j(L)=\u03b3^{| (d\u22121\u2212j) \u2212 \u2113 |}/2^{j+1} with \u03b3<1/2 and prove \u03a3_j a_j(L)\u00b7(B_j(A\u2032)\u2212B_j(A)) \u2264 O(L/n) uniformly in A. This would extend the geometric-window lemma beyond A_0.\n4) Restricted-phase milestone: Under the equal-scale assumption per phase, define a phase potential \u03a8_L(A):=\u03a3_j \u03b2^{|log_2 L_j\u2212log_2 L|}\u00b7|log_2 B_j(A)\u2212(d\u2212j)| and prove an O(1) drop per phase from A_0 using the geometric-window lemma (for the \u201cdecrease-needed\u201d half) together with a symmetric variant for increases. This would yield \u03a9(log^2 n) steps for the restricted model.\n5) Case analysis for per-pair decreases: Classify the six-bit patterns (a_L,L_1,L_k,R_1,R_m,a_R) that yield \u0394_pair(j)<0 and quantify when the inner boundary must coincide with a current j-boundary. This may lead to a \u201ccentral-boundary demand\u201d lemma needed to control decreases when T_j(A) has partial regularity.\n\nWhy this is progress\n- The extremal 2-adic inequality closes a missing technical gap and makes several prior sketches rigorous.\n- The geometric-window lemma is a genuinely new, constant-per-step cross-level bound (albeit for the first step), capturing scale-locality in a quantitative way. It provides a clear template for the type of weighting that could ultimately yield an \u03a9(log^2 n) lower bound via an O(1) per-phase drop argument.\n"}]

Current notes.md:
Setting and notation
- Input size n=2^d. The specific permutation A_0 is bit-reversal order of [0,…,n−1]. For j∈{0,…,d−1} we color elements by their j-th bit and denote by B_j(A) the number of monochromatic runs (contiguous blocks of equal j-bit) in the array A. Let T_j(A)⊆{1,…,n−1} be the set of j-run boundary indices (|T_j(A)|=B_j(A)−1). We consider one-step operations that swap a family of disjoint adjacent interval pairs in parallel.
- Our model of one step coincides with PBT (parallel adjacent block transpositions). One step chooses disjoint pairs (L_k,R_k) of adjacent contiguous intervals and swaps every chosen pair simultaneously.

Endpoint calibration (bit-reversal vs sorted)
- For A_0 (bit-reversal), B_j(A_0)=2^{j+1}. For the fully sorted order A_* = [0,1,…,n−1], B_j(A_*)=2^{d−j}. Consequently, the potential Φ(A):=Σ_{j=0}^{d−1} |log_2 B_j(A) − (d−j)| satisfies Φ(A_0)=Θ(d^2) and Φ(A_*)=0.

Locality of changes per pair and a safe per-level cap
- A single swapped pair (L,R) can alter adjacency only at three indices: the left outer boundary before L, the inner boundary between L and R, and the right outer boundary after R. For a fixed level j, if the union L∪R contains no j-boundary of the current array A, then all three affected adjacencies are between same colors both before and after; hence this pair produces no change in B_j.
- Therefore only pairs whose union contains at least one element of T_j(A) can affect B_j. Because the pair unions are disjoint, the number of such pairs is at most |T_j(A)|=B_j(A)−1. Each such pair contributes at most 3 to |B_j(A′)−B_j(A)|. Hence for every j and every PBT step A→A′,
  |B_j(A′) − B_j(A)| ≤ 3(B_j(A) − 1),
  which implies the multiplicative cap B_j(A′) ≤ 4·B_j(A) and B_j(A) ≤ 4·B_j(A′). In particular, |Δ log_2 B_j| ≤ 2 per step.

Dyadic alignment for A_0
- Let G_j denote the j-run boundary set in A_0. Then G_j = { i∈{1,…,n−1} : 2^{d−1−j} divides i }. For any set S of cut indices used in a step, one has
  Σ_{j=0}^{d−1} |S ∩ G_j| = Σ_{i∈S} (1 + v_2(i)) ≤ |S| (1 + ⌊log_2(n−1)⌋),
  since the number of j for which i∈G_j equals 1+v_2(i).

Caveats and corrections to earlier sketches
- The previously proposed “useful boundary” set U_j (indices in or adjacent to T_j(A)) is not a valid certificate for where toggles can occur: the post-step adjacency at a changed index depends on elements imported from potentially far away; mere distance-1 proximity to T_j(A) is insufficient to characterize where toggles can or cannot happen. We avoid using U_j.
- A claimed “size lemma” of the form Δ_j ≤ C·Σ_p min{1, s(p)/L_j} is false deterministically. Short pairs can be aligned to j-gridlines so that Δ_j ≍ n/L_j while the RHS is ≍ n/L_j^2. Any valid size-sensitive bound must use a different aggregation (see Next steps).
- Edge-to-level weighting that relies on fixed dyadic gridlines E_j holds at A_0 but not after the array evolves; after one step the j-boundaries are no longer constrained to those gridlines.

Next steps (program)
1) Try to sharpen the per-level cap to factor 2: Show |B_j(A′)−B_j(A)| ≤ c·|T_j(A)∪T_j(A′)| with small c (ideally c=1 or 2) by charging every toggling edge to a unique j-boundary contained in the union of the pair in either A or A′.
2) Demand for central matches: Prove that achieving a constant-factor decrease of B_j in one step requires Θ(B_j) central-boundary alignments (inner boundaries of swapped pairs) with j-run boundaries of A; outer-boundary hits alone cannot effect global coalescence. Make this precise and robust to local cancellations.
3) Cross-level scarcity via “home levels”: For each pair p of total size s(p), assign h(p) with L_{h(p)}≈s(p). Prove that constant-factor progress at level j needs Σ_{p: h(p)=j} Ω(1) contribution. Since Σ_p s(p) ≤ n and the sets {p: h(p)=j} are disjoint across j, only O(1) levels can make factor-≥2 progress in the same step. First prove the equal-scale special case (all pairs have sizes within ×2 of some L), which should already yield an Ω(log^2 n) lower bound for that restricted class.
4) Use the dyadic structure of G_j at A_0 to formalize a “central-boundary alignment trade-off” across levels: matched central boundaries that effect progress for one j are largely incompatible with those needed for many other j due to disjointness and dyadic spacing.
5) Perform small-n experiments (n=16,32) to estimate the maximal number of levels that can experience ≥2× change in B_j in one step and to guide constants.
New: toggle-locality identity and consequences
- Let A→A′ be one PBT step and let S⊆{1,…,n−1} be the set of indices whose adjacency changes in this step (exactly three per matched pair: left outer, inner, right outer; omit outer ones at array ends if absent). For each j, let T_j(A) be the set of j-run boundary indices (|T_j(A)|=B_j(A)−1).
- Identity (toggle-locality). For every j,
  B_j(A′) − B_j(A) = |T_j(A′) ∩ S| − |T_j(A) ∩ S|.
  Reason: outside S, adjacencies (and hence boundary membership) are identical in A and A′, so T_j(A′) Δ T_j(A) ⊆ S, which implies the stated cardinality identity.
- Corollary (one-sided bounds). For every j,
  Decrease_j := max{0, B_j(A) − B_j(A′)} ≤ |T_j(A) ∩ S|,
  Increase_j := max{0, B_j(A′) − B_j(A)} ≤ |S \ T_j(A)|.
  Interpretation: shrinking B_j by Δ forces at least Δ of the changed indices to land on current j-boundaries.

Improved per-level cap via per-pair ±2
- Per pair (L,R) and fixed j, define Δ_pair as the change in the number of j-boundaries attributable to that pair; then |Δ_pair| ≤ 2 (prove by the binary 4-cycle inequality on the three interfaces). In addition, only pairs whose union is non-monochromatic at level j can contribute, and such pairs are at most |T_j(A)| by disjointness (charge to an internal j-boundary index).
- Summing gives |B_j(A′)−B_j(A)| ≤ 2·|T_j(A)| = 2(B_j(A)−1). Applying the bound to the inverse step yields the multiplicative cap B_j(A′) ≤ 3B_j(A) and B_j(A) ≤ 3B_j(A′). Thus |Δ log_2 B_j| ≤ log_2 3 per step.

Weighted dyadic alignment at A_0 and a corrected weighted bound
- For A_0, G_j = T_j(A_0) is the dyadic grid {i: 2^{d−1−j} | i}. For any set S of changed indices, Σ_j |S∩G_j| = Σ_{i∈S} (1+v_2(i)). More generally, for nonnegative weights a_j, Σ_j a_j·|S∩G_j| = Σ_{i∈S} Σ_{j: i∈G_j} a_j.
- Combining with toggle-locality yields the exact inequality Σ_j a_j·Decrease_j ≤ Σ_{i∈S} Σ_{j: i∈G_j} a_j. For the specific weights a_j=2^{−(j+1)}, if v_2(i)=t then Σ_{j: i∈G_j} 2^{−(j+1)} = 2^{−(d−t−1)}(1−2^{−(t+1)}) ≤ 2^{−d+t+1}. Thus Σ_j 2^{−(j+1)}·Decrease_j ≤ Σ_{i∈S} 2^{−d+v_2(i)+1}. (This corrects a factor-2 slip in an earlier draft.)

Caution on “equal-scale first-step scarcity from A_0”
- The claim “if L_j > s then every union U=L∪R is j-monochromatic in A_0” is false. Counterexample (n=8, j=0): L_j=4; a union U of size s=2 that straddles the unique G_0 index at 4 is not monochromatic.
- What does hold: the per-pair ±2 bound implies |ΔB_j| ≤ 2m ≤ 2n/s for any j. From A_0 this yields that if L_j ≪ s then |ΔB_j|/B_j(A_0) ≤ O(L_j/s)=o(1), so constant-factor decreases at such j are impossible in that step. This does not preclude large changes when L_j ≫ s; additional structure (e.g., grid-aligned inner boundaries) seems necessary to prove an O(1) cap on the number of “active levels”.

Planned direction: equal-scale, grid-aligned scarcity
- Assume an L-aligned step: pair sizes in [L,2L) and all inner boundaries on the L-grid. For A starting at A_0, use arithmetic progression intersections to show that for off-scale j (2^{d−1−j} far from L) the proportion |S∩G_j|/B_j is o(1); combine with toggle-locality to rule out constant-factor decreases at those j. Only O(1) consecutive j with 2^{d−1−j}∈[L/2,2L] can be “active”. Control outer-boundary contributions by noting they contribute only O(#pairs) points, spread over a constant number of L-residue classes.

Next steps (actionable)
1) Write the full aligned-scarcity proof, including the precise bounds on |S∩G_j| and |S\G_j| for off-scale j.
2) Extend to near-alignment by averaging over residues modulo L to extract a constant-aligned subfamily.
3) Develop a central-vs-outer charging lemma: quantify the fraction of Decrease_j that must be paid by inner boundaries hitting T_j(A), uniformly over steps. This will dovetail with a home-level charging scheme for pairs.
4) Continue small-n experiments (n=32,64,128) to probe the number of levels with ≥ constant-factor decreases under equal-scale steps.
New exact identities, corrections, and scale-weighted constraints

1) Exact Hamming-sum identity across levels
- For any array A, define HD_A(i) as the Hamming distance (in d bits) between the values at positions i and i+1. Then for all A,
  Σ_{j=0}^{d−1} (B_j(A) − 1) = Σ_{i=1}^{n−1} HD_A(i).
- Across one step A→A′ with changed-adjacency set S (three per pair),
  Σ_{j=0}^{d−1} (B_j(A′) − B_j(A)) = Σ_{i∈S} (HD_{A′}(i) − HD_A(i)).
Explanation: For each i, the indicator that i∈T_j(A) is exactly the indicator that the j-th bits at i and i+1 differ; summing over j gives HD_A(i). Subtracting two arrays and noting HD is unchanged outside S yields the step identity. This is complementary to toggle-locality and shows per changed index the total boundary mass across all levels changes by at most d.

2) Sub-run regime from A_0: corrected one-sided statement
- Setup: A=A_0, fix j and its run length L_j=2^{d−1−j}. Consider a single pair (L,R) with union U of length s=|U|.
- Fact (geometry on G_j): If s<L_j then among the three changed indices of this pair (left outer, inner, right outer), at most one index belongs to G_j=T_j(A_0). Indeed, the three indices lie in an index interval of length s, which contains at most one multiple of L_j.
- Consequence (decrease-only). For such a pair and level j, the per-pair j-decrease is ≤1 (toggle-locality gives Decrease_j ≤ |T_j(A_0)∩S_pair| ≤ 1). Caution: increases can be as large as +2 in this regime (e.g., when the pair straddles a single j-boundary), so |Δ_pair(j)| is not ≤1 in general.
- Counterexample to the |Δ_pair(j)|≤1 claim: Let L be the last item of a j-run and R the first item of the next j-run in A_0; then s=2<L_j. Before the swap, only the inner interface is a j-boundary; after swapping, all three interfaces are j-boundaries, so the per-pair change is Δ_pair(j)=−2 (B_j increases by 2).

3) “Decrease-only alignment bound” as stated is false
- The claim “if all pair boundaries lie on the L-grid then for j with L_j∤L one has Decrease_j=0” does not hold. Even if S⊆{multiples of L}, S can still contain indices that are also multiples of L_j (e.g., multiples of lcm(L,L_j)), so |G_j∩S| may be nonempty. Toggle-locality alone cannot force Decrease_j=0 under this assumption. Any valid one-sided alignment bound must add further structure about which L-residue classes are used by S.

4) A clean large-scale weighted inequality from A_0
- For A=A_0 and any power-of-two L=2^ℓ,
  Σ_{j: L_j≥L} (L/L_j)·Decrease_j ≤ 2|S|.
  In steps with m pairs, this gives Σ_{j: L_j≥L} (L/L_j)·Decrease_j ≤ 6m. If in addition all pair lengths lie in [L,2L), then m≤n/L, yielding Σ_{j: L_j≥L} (L/L_j)·Decrease_j ≤ 6n/L.
- Proof idea: Combine toggle-locality with the dyadic alignment of G_j in A_0; for i with v_2(i)=t, the inner sum Σ_{j: i∈G_j, L_j≥L} (L/L_j)=Σ_{s=ℓ}^{t}2^{ℓ−s}≤2.

5) On small-scale control (sketch; not yet curated)
- Using weights w_j:=1/B_j(A_0)=L_j/n, toggle-locality and dyadic alignment give
  Σ_j w_j·Decrease_j ≤ (2/n)·Σ_{i∈S} 2^{v_2(i)}.
- Two routes to control the RHS:
  (a) General extremal bound: For any K-subset S⊆{1,…,n−1}, prove Σ_{i∈S}2^{v_2(i)} ≤ C K log(2n/K). With K≤|S|≤3m≤3n/L this yields Σ_{j: L_j<L} Decrease_j/B_j(A_0) ≤ O((log L)/L).
  (b) L-grid inner-boundary route: If a “central-boundary demand” lemma shows small-scale decreases must be paid mostly by inner boundaries, then restricting to S_inner⊆{multiples of L} gives Σ_{i∈S_inner}2^{v_2(i)} ≤ 2^ℓ·Σ_{k≤n/L}2^{v_2(k)} = O(n·log(n/L)), hence Σ_j Decrease_j/B_j(A_0) ≤ O(log(n/L)/L).
- Either route needs a complete proof before inclusion in output.

6) Reassessment of the “O(1) active levels per step)” heuristic
- In aligned steps at very small scale (e.g., L=1), S can intersect G_j at Θ(B_j(A_0)) for Θ(log n) many j simultaneously, so any argument purely bounding the number of active levels is untenable. Scale-sensitive weighted bounds (as above) are the right replacements.

7) Restricted-phase milestone
- For algorithms operating in phases with pair sizes in [L_t,2L_t) and inner L_t-grid alignment, define a phase-weighted potential Ψ_t(A) concentrated near the home scale L_t. Combine the large-scale inequality in (4) with a proved small-scale control to show O(1) drop per phase, yielding Ω(log^2 n) steps across scales.

Actionable next steps
- Prove a sharp bound on Σ_{i∈S}2^{v_2(i)} via route (a) or (b) above.
- Complete a per-pair six-bit case analysis; extract a “central-boundary demand” lemma quantifying the necessary contribution of the inner boundary for large decreases at a fixed j.
- Design signed cross-level weights using the Hamming-sum identity to bound per-index signed contributions by O(1). Validate on small-n instances.


Current output.md (if any):
Statements and proofs curated so far

Setup and notation
- Let n=2^d. An array A is a permutation of [0,…,n−1]. For j∈{0,…,d−1}, color each entry of A by the j-th bit of its value and let B_j(A) be the number of monochromatic runs in this 2-coloring. Let T_j(A)⊆{1,…,n−1} be the set of indices i where the j-color flips between positions i and i+1 (so |T_j(A)|=B_j(A)−1). A single step A→A′ is a parallel block transposition (PBT): a product of disjoint swaps of adjacent contiguous interval pairs (L,R). Such a step changes adjacencies only at the three interface indices of each pair (left outer, inner, right outer; omitting outer ones at the array ends).

Theorem 1 (Model equivalence to PBT). A single step of the model (swapping a family of disjoint adjacent interval pairs in parallel) is exactly a parallel block transposition (PBT) step.
Proof. A step chooses disjoint adjacent pairs (L_k,R_k) of intervals and swaps each pair simultaneously, leaving all other positions untouched. This is precisely a product of disjoint adjacent block transpositions. Conversely, any product of disjoint adjacent block transpositions can be realized by choosing those pairs. ∎

Theorem 2 (Endpoint run-counts). Let n=2^d and A_0 be the bit-reversal permutation of [0,…,n−1]. For j∈{0,…,d−1}:
- B_j(A_0)=2^{j+1}.
- For the fully sorted order A_*=[0,1,…,n−1], B_j(A_*)=2^{d−j}.
Consequently, with D_j(A):=|log_2 B_j(A) − (d−j)|, one has Σ_{j=0}^{d−1} D_j(A_0)=Θ(d^2) and Σ_{j=0}^{d−1} D_j(A_*)=0.
Proof. In A_0, the j-bit of the value at position i equals the (d−1−j)-th bit of i; thus along positions 0,…,n−1 this bit is constant on runs of length 2^{d−1−j} and alternates every such block, giving exactly 2^{j+1} runs. In A_*, the j-bit is constant on blocks of length 2^j and alternates every 2^j positions, yielding 2^{d−j} runs. The Θ(d^2) sum follows from Σ_{j=0}^{d−1} |2j+1−d| = Θ(d^2) by symmetry around (d−1)/2. ∎

Lemma 3 (Toggle-locality identity). Let A→A′ be one PBT step and let S be the set of indices whose adjacency changes in this step (the three interfaces per pair). Then for every j,
  B_j(A′) − B_j(A) = |T_j(A′) ∩ S| − |T_j(A) ∩ S|.
In particular, Decrease_j := max{0, B_j(A) − B_j(A′)} ≤ |T_j(A) ∩ S| and Increase_j := max{0, B_j(A′) − B_j(A)} ≤ |S \ T_j(A)|.
Proof. If i∉S then the adjacent entries across i are the same in A and A′, hence i∈T_j(A) iff i∈T_j(A′). Thus T_j(A′) Δ T_j(A) ⊆ S and
|T_j(A′)|−|T_j(A)| = |T_j(A′)∩S| − |T_j(A)∩S|.
Since B_j(·)=|T_j(·)|+1, the displayed identity follows; the one-sided bounds are immediate. ∎

Lemma 4 (Per-pair ±2 bound at a fixed level). Fix j and a single swapped pair (L,R). Let Δ_pair be its contribution to ΔB_j. Then |Δ_pair| ≤ 2. Moreover, if the union U=L∪R is j-monochromatic (equivalently, contains no index of T_j(A)), then Δ_pair=0.
Proof. Only the three interface indices can change their boundary status. Let a_L be the j-color of the neighbor immediately left of L, a_R the j-color of the neighbor immediately right of R; let L_1,L_k be the first/last j-colors in L and R_1,R_m the first/last j-colors in R. Writing [·] for the indicator of inequality, the total contribution before the swap equals
  X := [a_L≠L_1] + [L_k≠R_1] + [R_m≠a_R],
and after the swap equals
  Y := [a_L≠R_1] + [R_m≠L_1] + [L_k≠a_R].
Thus Δ_pair = X − Y. Using the inequality [q≠x] − [q≠y] ≤ [x≠y] twice gives
  Δ_pair ≤ [L_1≠R_1] + [R_m≠L_k] + ([L_k≠R_1] − [R_m≠L_1]).
The binary 4-cycle inequality [p≠q]+[q≠r]+[r≠s]−[s≠p] ≤ 2, applied to (p,q,r,s)=(L_1,R_1,L_k,R_m), yields Δ_pair ≤ 2. The lower bound follows symmetrically (or by applying the argument to the inverse swap). If U is j-monochromatic then L_1=L_k=R_1=R_m and all three interface indicators are unchanged, so Δ_pair=0. ∎

Theorem 5 (Per-level factor-3 cap per step). For any array A, any j, and any single PBT step A→A′,
  B_j(A′) ≤ 3·B_j(A) and B_j(A) ≤ 3·B_j(A′).
Equivalently, |log_2 B_j| changes by at most log_2 3 in one step.
Proof. Let M_j(A) be the set of swapped pairs whose union U is not j-monochromatic in A. By disjointness of the unions, each U∈M_j(A) contains at least one index of T_j(A), and distinct U’s receive distinct such indices; hence |M_j(A)| ≤ |T_j(A)| = B_j(A)−1. Summing Lemma 4 over pairs gives
  |B_j(A′) − B_j(A)| ≤ Σ_{pairs} |Δ_pair| ≤ 2·|M_j(A)| ≤ 2(B_j(A)−1).
Therefore B_j(A′) ≤ B_j(A) + 2(B_j(A)−1) ≤ 3B_j(A). Applying the same bound to the inverse step A′→A yields B_j(A) ≤ 3B_j(A′). ∎

Theorem 6 (Dyadic alignment for A_0; weighted form). Let G_j⊆{1,…,n−1} be the set of j-run boundary indices in A_0. Then G_j = { i : 2^{d−1−j} divides i }. For any set S⊆{1,…,n−1},
  Σ_{j=0}^{d−1} |S ∩ G_j| = Σ_{i∈S} (1 + v_2(i)).
More generally, for any weights a_j≥0,
  Σ_{j=0}^{d−1} a_j·|S ∩ G_j| = Σ_{i∈S} Σ_{j: 2^{d−1−j} | i} a_j.
Proof. In A_0 the j-bit is periodic with period 2^{d−j}, so boundaries occur exactly at indices i that are multiples of 2^{d−1−j}. For fixed i, the set of j with i∈G_j has size 1+v_2(i); the weighted identity is immediate by exchanging sums. ∎

Corollary 6.1 (Weighted decrease bound from A_0). In one step A_0→A′ with changed-index set S, and any weights a_j≥0,
  Σ_{j} a_j·Decrease_j ≤ Σ_{i∈S} Σ_{j: i∈G_j} a_j.
In particular, with a_j=2^{−(j+1)} and v_2(i)=t,
  Σ_{j} 2^{−(j+1)}·Decrease_j ≤ Σ_{i∈S} 2^{−(d−t−1)}(1−2^{−(t+1)}) ≤ Σ_{i∈S} 2^{−d+t+1}.
Proof. Combine Lemma 3 with Theorem 6 and use nonnegativity of the weights; the explicit sum for a_j=2^{−(j+1)} is a direct geometric series. ∎
Theorem 7 (Hamming-sum identity across levels).
Let A be any permutation of [0,…,n−1]. For i∈{1,…,n−1}, let HD_A(i) be the Hamming distance in d-bit binary between the values at positions i and i+1. Then
- Σ_{j=0}^{d−1} (B_j(A) − 1) = Σ_{i=1}^{n−1} HD_A(i).
Moreover, for any single PBT step A→A′ with changed-adjacency set S,
- Σ_{j=0}^{d−1} (B_j(A′) − B_j(A)) = Σ_{i∈S} (HD_{A′}(i) − HD_A(i)).
Proof. For fixed i, the indicator that i∈T_j(A) is exactly the indicator that the j-th bits of the adjacent values differ; summing over j gives HD_A(i). Summing over i yields the first identity. Subtracting the identity for A from that for A′ gives Σ_j(B_j(A′)−B_j(A)) = Σ_i(HD_{A′}(i)−HD_A(i)). Since HD is unchanged outside S, the sum over all i reduces to the sum over i∈S. ∎

Corollary 7.1 (Pair-budget demand for decreases).
Let a step use m disjoint pairs and S be its set of changed indices. Then for every j,
- Decrease_j ≤ |T_j(A)∩S| ≤ |S| ≤ 3m.
In particular, achieving Decrease_j ≥ θ·B_j(A) in one step requires m ≥ (θ/3)·B_j(A).
Proof. The first inequality is Lemma 3; |S|≤3m since each pair contributes at most three changed indices. The demand bound is immediate. ∎

Lemma 7.2 (A_0 sub-run per-pair decrease bound).
Let A=A_0. Fix j and its run length L_j=2^{d−1−j}. Consider a single swapped pair (L,R) whose union U has length s< L_j, and let S_pair be the three changed indices contributed by this pair. Then |T_j(A_0)∩S_pair|≤1; consequently the per-pair decrease at level j in this step satisfies Decrease_j ≤ 1.
Proof. The three changed indices lie between the left-outer and right-outer interfaces; this integer interval has length s< L_j and hence contains at most one multiple of L_j. Since G_j=T_j(A_0) is exactly the set of multiples of L_j, at most one of the three changed indices lies in G_j. Toggle-locality gives Decrease_j ≤ |T_j(A_0)∩S_pair| ≤ 1. ∎

Theorem 8 (Large-scale weighted decrease bound from A_0).
Let A=A_0 and L=2^ℓ. For any PBT step A→A′ with changed-index set S,
- Σ_{j: L_j≥L} (L/L_j)·Decrease_j ≤ 2|S|.
Consequently, if the step uses m pairs then Σ_{j: L_j≥L} (L/L_j)·Decrease_j ≤ 6m. If, moreover, all pair lengths lie in [L,2L), then m≤n/L and hence Σ_{j: L_j≥L} (L/L_j)·Decrease_j ≤ 6n/L.
Proof. By Lemma 3 and Theorem 6 (weighted form), for any nonnegative weights a_j,
  Σ_j a_j·Decrease_j ≤ Σ_{i∈S} Σ_{j: i∈G_j} a_j.
Take a_j = (L/L_j)·1_{L_j≥L}. For i with 2-adic valuation v_2(i)=t, the inner sum equals Σ_{s=ℓ}^{t} 2^{ℓ−s} ≤ 2 (empty if t<ℓ). Summing over i∈S gives Σ_{j: L_j≥L} (L/L_j)·Decrease_j ≤ 2|S|. The two corollaries follow from |S|≤3m and, under equal-scale [L,2L) pairs, m≤n/L. ∎

