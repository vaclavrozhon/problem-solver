--- SYSTEM ---
You are a research mathematician. 

You are being run in a loop with a verifier that checks rigor. Your goal is to make **incremental, auditable progress**. You are not expected to solve the problem at once, but to generate new, testable ideas.

Inputs: 
- task statement 
- notes.md (summary of past progress; optional) 
- output.md (rigorously proven results curated so far; optional) 
- summary of past rounds (optional) 
- possibly some reference papers.

What counts as progress:
- Extract small lemmas/heuristics from literature and state them cleanly with one-line "why useful here".
- Explore small examples & try to break your own claims with toy counterexamples.
- Prove special cases or nontrivial bounds.
- If an approach fails, explain crisply why.
- Point out flaws in notes.md or output.md (but do not rewrite output.md yourself).

**Discipline.** 
- Read notes, outputs, summaries carefully before proposing new work. 
- Reference papers if relevant, but focus on *incremental, checkable steps*. 
- Do not output Markdown code fences, only raw JSON. 
- Length: at least ~200 words. 
- Organize your reasoning with short headings (Ideas, Examples, Obstacles, Next steps), make clear what your claims are and how they are supported. 
- Remember: the verifier curates notes and outputs, you only suggest.

**Return strictly JSON**:
{
  "progress_md": "Your progress notes for this round in Markdown (KaTeX allowed). Point out any gaps in output.md clearly. Do not modify output.md directly."
}


--- USER ---
Work on this problem context:

=== task.tex ===

The task is to show $\Omega(\log^2 n)$ lower bound for sorting bit-reversal sequence in a model defined next. (Alternatively, provide $o(\log^2 n)$ algorithm if there is one)


\section{Model explanation and the statement of the problem}

\paragraph{Model (one step).}
We start with an array $A$ containing the integers $0,1,\dots,n-1$ in some order.
A single \emph{step} of the algorithm consists of:
\begin{enumerate}
  \item Partition $A$ into disjoint, consecutive intervals that cover $A$.
  \item Select some disjoint pairs of \emph{adjacent} intervals.
  \item For each selected pair, \emph{swap} the two intervals as whole blocks (these swaps occur in parallel).
  \item Unmatched intervals remain in place.
\end{enumerate}
The partition and the chosen pairs may depend on the current contents of $A$.

\paragraph{Example of one step ($n=16$).}
Start with
\[
[0,1,2,3,\;\;4,5,6,7,\;\;8,9,10,11,12,\;\;13,14,\;\;15].
\]
Partition into $I_1=[0,1,2,3]$, $I_2=[4,5,6,7]$, $I_3=[8,9,10,11,12]$, $I_4=[13,14]$, $I_5=[15]$.
Match $(I_1,I_2)$ and $(I_4,I_5)$; leave $I_3$ unmatched. After the step:
\[
[4,5,6,7,\;\;0,1,2,3,\;\;8,9,10,11,12,\;\;15,\;\;13,14].
\]

\paragraph{Bit-reversal order}
Let $n=2^d$. The \emph{bit-reversal order} lists $0,1,\dots,n-1$ and reverses the $d$-bit representations to obtain the input permutation.

\paragraph{Example ($n=16$, $d=4$).}
\[
\underbrace{0,\;8,\;4,\;12,\;2,\;10,\;6,\;14,\;1,\;9,\;5,\;13,\;3,\;11,\;7,\;15}_{\text{bit-reversal sequence}}.
\]
Write bits (from MSB $b_3$ to LSB $b_0$) under the sequence:
\[
\begin{array}{l|cccccccccccccccc}
\text{values} & 0&8&4&12&2&10&6&14&1&9&5&13&3&11&7&15\\\hline
b_3\;(\text{MSB}) & 0&1&0&1&0&1&0&1&0&1&0&1&0&1&0&1\\
b_2 & 0&0&1&1&0&0&1&1&0&0&1&1&0&0&1&1\\
b_1 & 0&0&0&0&1&1&1&1&0&0&0&0&1&1&1&1\\
b_0\;(\text{LSB}) & 0&0&0&0&0&0&0&0&1&1&1&1&1&1&1&1\\
\end{array}
\]
For $n=8$ ($d=3$) the bit-reversal sequence is $[0,4,2,6,1,5,3,7]$ with analogous bit rows:
$b_2:01010101$, $b_1:00110011$, $b_0:00001111$ (truncated to $8$ entries).

\paragraph{The problem}
Your task is to prove that any algorithm in our model that sorts this bit-reversal sequence requires $\Omega(\log^2 n)$ steps. Alternatively, if there is an algorithm that requires only $o(\log^2 n)$ steps, prove that. 

\section{Baseline results}

\paragraph{Counting lower bound: $\Omega(\log n)$ steps.}
There are $n!$ possible inputs, requiring $\log_2(n!)=n\log_2 n - \Theta(n)$ bits to distinguish.
One step is determined by a partition plus a choice of which adjacent interval-pairs to swap, all describable with $O(n)$ bits, i.e.\ at most $2^{O(n)}$ possibilities per step.
Hence each step injects only $O(n)$ bits of ``entropy'', and sorting from scratch needs $\Theta(n\log n)$ bits, implying $\Omega(\log n)$ steps lower bound for any general sorting algorithm. 

\paragraph{Upper bounds: $O(\log^2 n)$ steps.}
Two standard paradigms adapt to this model.

\medskip\noindent
\textbf{(A) Merge-sort style.}
Sort blocks of size $2$, then $4$, then $8$, etc., doubling each stage. The key primitive is \emph{merging} two sorted sequences.
Merging can be done in $O(\log n)$ steps by recursive median partitioning:
pick the median $m$ of the union, partition both sequences into $<m$ and $\ge m$, use $O(1)$ flips to place all $<m$ before all $\ge m$, and recurse on the two halves in parallel.
Depth $O(\log n)$; each merge takes $O(\log n)$ steps $\Rightarrow O(\log^2 n)$ total.

\medskip\noindent
\textbf{(B) Quicksort style.}
Given pivot $p$, color items red if $<p$ and blue otherwise. View the array as maximal monochromatic blocks.
One step can reduce the number of red/blue blocks by a constant factor (by flipping adjacent red/blue block pairs to coalesce like colors).
Thus partitioning by $p$ takes $O(\log n)$ steps; recurse on the two sides $\Rightarrow O(\log^2 n)$ overall.

\subsection{Two specialized $O(\log^2 n)$ strategies.}

\medskip\noindent
\textbf{MSB-first (quicksort-like).}
The MSB row is $0101\ldots$. Using the red/blue block-reduction, in $O(\log n)$ steps group all MSB$=0$ items left and MSB$=1$ right.
For $n=16$ this yields:
\[
\text{left: }[0,4,2,6,1,5,3,7]\qquad
\text{right: }[8,12,10,14,9,13,11,15].
\]
Each side is the bit-reversal sequence on $n/2$ elements (one fewer bit). Recurse for depth $\log n$; each level costs $O(\log n)$ steps $\Rightarrow O(\log^2 n)$.

\medskip\noindent
\textbf{LSB-first (interlacing).}
Initially LSB has eight $0$'s then eight $1$'s, so the sequence splits into quarters
\[
[0,8,4,12]\;|\;[2,10,6,14]\;|\;[1,9,5,13]\;|\;[3,11,7,15].
\]
Flip the second and third quarters to interlace:
\[
[0,8,4,12]\;|\;[1,9,5,13]\;|\;[2,10,6,14]\;|\;[3,11,7,15].
\]
Continue interlacing for $O(\log n)$ rounds to obtain
\[
[0,1,\;8,9,\;4,5,\;12,13,\;2,3,\;10,11,\;6,7,\;14,15],
\]
which forms sorted pairs $(0,1),(8,9),\dots$. Treat pairs as super-items and repeat to form sorted $4$-tuples, then $8$-tuples, etc.
$\log n$ macro-levels, each $O(\log n)$ steps $\Rightarrow O(\log^2 n)$.

\subsection{Structural $\Omega(\log n)$ lower bounds beyond counting}
The counting lower bound ($\Omega(\log n)$) is too weak for $\Omega(\log^2 n)$. Two task-specific $\Omega(\log n)$ lower bounds are relevant.

\paragraph{Merging requires $\Omega(\log n)$ steps.}
Consider
\[
[0,2,4,6,8,10,12,14 \;\mid\; 1,3,5,7,9,11,13,15].
\]
Color evens red and odds blue. Start: two monochromatic blocks (R$|$B).
Target: fully interlaced (R,B,R,B,$\dots$), i.e.\ $\Theta(n)$ blocks.
\emph{Observation:} In one step, only boundaries where a red block meets a blue block can create more alternations; each matched adjacent-pair affects only $O(1)$ such boundaries.
Thus the number of monochromatic blocks can grow by at most a constant factor per step.
Going from $2$ to $\Theta(n)$ blocks needs $\Omega(\log n)$ steps.

\paragraph{Pivoting (coarsening) requires $\Omega(\log n)$ steps.}
Color items $<n/2$ red and $\ge n/2$ blue. For $n=16$ in bit-reversal order the pattern is R,B,R,B,\dots (many small blocks).
Goal: all reds then all blues (two blocks).
By the same boundary-locality, a step can reduce the number of blocks by only a constant factor, so $\Omega(\log n)$ steps are necessary.

\paragraph{Significance.}
If merging or pivoting were doable in $O(1)$ steps, the corresponding $O(\log^2 n)$ algorithm would become $O(\log n)$.
Hence any $\Omega(\log^2 n)$ lower bound must \emph{internally} show that both primitives inherently cost $\Omega(\log n)$ in this model.

\section{Ideas for how a proof might look like}

\paragraph{Important note}
You don't have to follow these ideas, take them only as a very speculative guess for how a solution might look like. 

Write $n=2^d$.
For an arrangement $A$ and bit level $j\in\{0,\dots,d-1\}$ (LSB $j=0$), let $B_j(A)$ be the number of monochromatic runs when items are colored by their $j$-th bit.

\paragraph{Values for bit-reversal vs.\ sorted.}
For the bit-reversal input $A_0$:
\[
B_j(A_0)=2^{j+1}\quad (j=0,1,\dots,d-1).
\]
For the sorted order $A_\star$:
\[
B_j(A_\star)=\frac{n}{2^j}=2^{d-j}\quad (j=0,1,\dots,d-1).
\]
Define the per-level log-gap
\[
D_j(A):=\big|\log_2 B_j(A)-\log_2 B_j(A_\star)\big|.
\]
Then
\[
D_j(A_0)=\big|(j+1)-(d-j)\big|=\big|2j+1-d\big|,\qquad
\sum_{j=0}^{d-1} D_j(A_0)=\Theta(d^2)=\Theta(\log^2 n).
\]

\paragraph{Goal.}
Prove a per-step progress cap showing that the potential
\[
\Phi(A)\;:=\;\sum_{j=0}^{d-1} D_j(A)
\]
drops by at most $O(1)$ per step. Since $\Phi(A_0)=\Theta(\log^2 n)$ and $\Phi(A_\star)=0$, this would yield an $\Omega(\log^2 n)$ lower bound.

\subsection*{Two lemmas that could be helpful if true (informal)}

\paragraph{Lemma 1 (per-level constant-factor cap, informal).}
For any fixed level $j$, one step can change $B_j$ by at most a constant multiplicative factor.
\emph{Rationale:} Only boundaries between opposite colors (at level $j$) can modify $B_j$, and each matched adjacent-interval flip perturbs $B_j$ by $O(1)$.

\paragraph{Lemma 2 (cross-level scarcity, informal).}
A matched boundary (between two swapped intervals) is only ``useful'' for $O(1)$ nearby bit levels, determined by the scale of the intervals. Consequently, in one step, only $O(1)$ levels can experience a constant-factor change in $B_j$.
\emph{Rationale:} Progress at level $j$ needs boundaries aligned at the dyadic scale $2^j$; a boundary created at a given geometric scale cannot simultaneously serve many levels.

\paragraph{Consequence.}
Combining Lemmas~1 and~2, $\Phi$ decreases by at most $O(1)$ per step, forcing $\Omega(\log^2 n)$ steps to sort the bit-reversal input.

\paragraph{Important note}
We retiterate that this section is just a speculative attempt not know to lead to a solution. 

=== progress.md ===
...
ase of the sought cross-level scarcity: in an equal-scale step, only O(1) levels can progress by a constant factor from A_0. It suggests the “home level” approach: pairs of size s are only capable of large impact around the dyadic scale L_j≈s.

Examples and sanity checks (n=16)
- Take A_0=[0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15]. For j=0, B_0=2; j=1, B_1=4; j=2, B_2=8; j=3, B_3=16.
- Pair singletons (s=2). Then m≤n/s=8 and per-level |ΔB_j|≤2m≤16. From A_0: only levels with L_j≤s=2 can be affected, i.e., L_3=1, L_2=2; j∈{2,3}. Indeed, j=0,1 are untouched (monochromatic unions). This matches the observation.
- Pair 4-blocks (s=8). Only levels with L_j≤8, i.e., j∈{1,2,3}, can be affected in the first step.

Obstacles and gaps
- The per-level factor-3 cap (Theorem 3′) still allows ΔΦ(A)=∑_j |Δ log_2 B_j| to drop by O(d) per step in principle—hence only Ω(log n) steps from this argument alone. We still need a cross-level scarcity result to show that only O(1) levels can experience constant-factor progress per step globally (not just in the equal-scale-first-step special case).
- The equal-scale scarcity proved here relies on A_0’s rigid dyadic runs. After the first step, run lengths cease to be uniform, so the argument does not extend immediately.
- The “size lemma” Δ_j ≤ C·∑_p min{1, s(p)/L_j} is false in general (as noted in notes.md) and should not be used. Our per-pair ±2 bound is robust and correct, but too weak alone to prove Ω(log^2 n).

Next steps (concrete, testable)
1) Curate Theorem 3′ (factor-3 cap) into output.md, with the corrected proof of the “three indices per pair” mechanism and the per-pair ±2 bound (Lemmas A–C). This is a clean improvement and fully rigorous.
2) Strengthen equal-scale scarcity beyond the first step. Target: If all pairs in a step have sizes within a factor-2 range [L,2L], then for any input A, only O(1) levels j can have |ΔB_j| ≥ θ·B_j(A) for a fixed θ∈(0,1). Approach: combine (i) the per-pair ±2 bound (so |ΔB_j| ≤ 2m ≤ 2n/L), with (ii) lower bounds B_j(A) ≳ n/L_j valid under mild structural hypotheses on A (to be identified), and (iii) an invariant controlling how small B_j(A) can be across many j simultaneously.
3) Home-level charging: Assign to each pair p its home index h(p) with L_{h(p)}≈|p|. Prove a “demand lemma”: constant-factor progress at level j requires Ω(B_j(A)) pairs with h(p)=j (not just any pairs). This would imply that only O(1) levels can see constant-factor progress in a step since ∑_p 1_{h(p)=j} ≤ n/L_j and ∑_j n/L_j=O(n).
4) Small-n brute force (n=16,32): For random partitions/matchings from A_0, measure the number of levels with ≥2× drop in B_j; check whether it is bounded by a small constant; log the configurations saturating Theorem 3′ (per pair Δ_pair=±2) to guide structural characterizations.

Why these steps matter
- Theorem 3′ improves a central per-level cap and repairs the proof. The equal-scale first-step scarcity is a concrete, verifiable instance of the cross-level bottleneck and a useful base case for induction-type arguments.
- The home-level charging is the most promising path to an Ω(log^2 n) lower bound: combined with Theorem 3′, it would bound per-step reduction in Φ(A)=∑_j |log_2 B_j(A)−(d−j)| by an absolute constant, as only O(1) levels can reduce by Θ(1) and the rest by o(1).

## Round 0002 — 2025-08-27T19:00:19.998765Z

Headlines
- New rigorous, step-local identities for how B_j changes: an exact toggle-count formula restricted to the set S of the at-most-3-per-pair indices whose adjacency actually changes. Two immediate corollaries quantify how much B_j can decrease (or increase) in terms of how many of these changed indices hit current j-boundaries. These identities are clean, model-agnostic, and ready to be curated.
- Clarification: The “useful boundary adjacency” heuristic is invalid in general (as already noted in notes.md). The correct locality is at the changed indices S only; nothing else can contribute in a step.
- Programmatic next step: Use the toggle-count identity plus the dyadic alignment structure of A_0 to lower bound the necessary “central hits” at many levels at once. I outline a restricted (equal-scale, grid-aligned) special case that can likely be proved fully and would yield an Ω(log^2 n) bound for that restricted class.

Formal statements and proofs (new, ready to curate)
1) Lemma (toggle-locality identity and signed change at level j).
- Setup. Let A→A′ be any single PBT step, and S⊆{1,…,n−1} be the set of indices whose adjacency changes in this step (i.e., the three indices around each matched pair: left outer, inner, right outer). For j∈{0,…,d−1}, let T_j(A) be the set of j-run boundary indices of A.
- Claim. For every j,
  B_j(A′) − B_j(A) = |T_j(A′) ∩ S| − |T_j(A) ∩ S|.
- Proof. By definition, all adjacencies outside S are identical in A and A′, hence their membership in T_j(·) is unchanged. Thus T_j(A′) Δ T_j(A)⊆S, and
  |T_j(A′)| − |T_j(A)| = |T_j(A′)∩S| − |T_j(A)∩S|.
Since B_j(·)=|T_j(·)|+1, the identity follows. ∎

Corollary 1.1 (one-sided bounds per level).
- For every j,
  Decrease_j := max{0, B_j(A) − B_j(A′)} ≤ |T_j(A) ∩ S|,
  Increase_j := max{0, B_j(A′) − B_j(A)} ≤ |S\T_j(A)|.
- Proof. From the identity, B_j(A) − B_j(A′) = |T_j(A)∩S| − |T_j(A′)∩S| ≤ |T_j(A)∩S|, and similarly for increases. ∎

Remarks on usefulness.
- This exposes the exact “demand”: shrinking B_j by Δ forces at least Δ of the changed indices to land on T_j(A). For A=A_0 (bit-reversal), T_j(A)=G_j are dyadic arithmetic progressions, so we can quantify how often a single changed index can service many levels via v_2(i).
- It also yields the previously curated factor-4 cap as a very special (and weaker) consequence when combined with the disjointness-of-unions argument (only O(B_j) pairs can intersect T_j(A)). More importantly, it is sharp enough to support cross-level trade-off inequalities.

2) Lemma (alignment counting at A_0, restated with weights).
Let A=A_0 and G_j be the j-boundary set at A_0. For any set of changed indices S (from an arbitrary step):
  Σ_{j=0}^{d−1} |S ∩ G_j| = Σ_{i∈S} (1+v_2(i)).
In particular, for any weights a_j≥0,
  Σ_j a_j·|S∩G_j| = Σ_{i∈S} Σ_{j: 2^{d−1−j}|i} a_j.
- Proof. As in Theorem 4 of output.md; I include the flexible weighted form since we will need to choose tailored a_j.

Immediate consequences and their limits
- Using Cor. 1.1 with A=A_0 gives Σ_j Decrease_j ≤ Σ_j |S∩G_j| = Σ_{i∈S}(1+v_2(i)). This shows that the total number of j-boundaries removed in a single step is at most the “alignment budget” Σ_i(1+v_2(i)). Since 1+v_2(i) ≤ 1+⌊log_2(n−1)⌋, we get the coarse bound Σ_j Decrease_j ≤ |S|·O(log n).
- This is not yet strong enough to force an O(1) drop of the log-gap potential per step (the step may create increases elsewhere, and |S| can be Θ(n)), but it is the right necessary-condition inequality to drive sharper cross-level trade-offs (see Next steps).

Restricted special case towards cross-level scarcity (equal-scale, grid-aligned)
- Definition (equal-scale, grid-aligned step). Fix L a power of two. A step is L-aligned if (i) every matched pair consists of two adjacent intervals each of length in [L,2L), and (ii) all inner boundaries of matched pairs occur at indices divisible by L (i.e., central cuts lie on the L-grid). This is a strong but natural restriction; many plausible blockwise algorithms satisfy it in phases.
- Claim (to be proved next; sketch here). In an L-aligned step from A_0, at most O(1) bit-levels j with 2^{d−1−j}∈[L/2,2L] can shrink B_j by a constant factor; all other levels change by at most o(B_j). Outline:
  • By Cor. 1.1, to reduce B_j by θ·B_j we need |S∩G_j| ≥ θ·B_j − |S\G_j|. Since all inner boundaries lie on the L-grid and all outer boundaries are spaced by at least L (due to equal-scale blocks), |S∩G_j| is Θ(#pairs) if and only if the two grids (L and 2^{d−1−j}) are commensurate: specifically, if 2^{d−1−j}∈[L/2,2L]. Otherwise |S∩G_j|/B_j=O(2^{d−1−j}/L) or O(L/2^{d−1−j}), which is o(1), precluding constant-factor change by Lemma 1.
  • Moreover, only O(1) consecutive j satisfy 2^{d−1−j}∈[L/2,2L]. Thus per step only O(1) “active levels” can reduce by a constant factor. Combining with the per-level factor cap (Theorem 3) bounds the per-step drop of Σ_j |log_2 B_j − (d−j)| by O(1) in this restricted regime.
- Status: The combinatorics of outer-boundary contributions needs a careful bound to ensure |S\G_j| does not swamp the inequality; but because outer boundaries per pair are only 2 and lie on the same L-grid offsets, the o(B_j) estimate for off-scale j is achievable. I will write this rigorously next.

Why the “useful-boundary” heuristic fails and how the new lemma fixes the issue
- Earlier “U_j” (indices adjacent to boundaries) is not a certificate. A changed index far from T_j(A) can certainly toggle membership at j depending on the imported endpoints. The correct locality is: only the indices whose adjacencies change (S) can flip membership; among them, a decrease of B_j can only occur on those that were in T_j(A) (Cor. 1.1). This is the precise and minimal condition we need.

A small but precise trade-off for A_0 (weighted decreases)
- For A=A_0 and any step, Cor. 1.1 plus weighted alignment gives
  Σ_{j=0}^{d−1} 2^{−(j+1)}·Decrease_j ≤ Σ_{i∈S} Σ_{j: i∈G_j} 2^{−(j+1)}.
For i with v_2(i)=t, the inner sum equals Σ_{j≥d−1−t} 2^{−(j+1)} = 2^{−(d−t)}(1−2^{−(t+1)}) ≤ 2^{−d+t}.
Therefore Σ_j 2^{−(j+1)}·Decrease_j ≤ Σ_{i∈S} 2^{−d+v_2(i)}.
- Crude bound: since v_2(i) ≤ ⌊log_2 i⌋ ≤ d−1, the RHS ≤ |S|/2. This is not strong enough by itself, but it is an exact accounting that we can pair, in the equal-scale regime, with commensurability to limit |S∩G_j| where it matters.

Checks on small n
- For n=8 (A_0=[0,4,2,6,1,5,3,7]), Cor. 1.1 predicts that B_0 can decrease only if S contains the unique G_0 index (the middle cut); indeed, experiments confirm B_0 changes by at most O(1) per step. For B_1, G_1 are indices 2,4,6; placing inner boundaries on these is necessary for noticeable decrease; changing other indices primarily increases B_1.

Gaps in output.md
- The current output.md includes Theorem 3 (factor-4 cap) proved by bounding |ΔB_j| via the number of pairs that intersect T_j(A). This is correct as written. However, for subsequent stronger trade-offs we need the toggle-locality identity (new Lemma 1) and its corollary as they cleanly separate (i) where decreases can happen (only at S∩T_j(A)) from (ii) where increases can happen (only at S\T_j(A)). I recommend curating Lemma 1 and Cor. 1.1 next.

Obstacles and what failed (crisp)
- A previously sketched “size lemma” Δ_j ≤ C·Σ_p min{1, s(p)/L_j} is false; changed adjacencies are only three per pair and independent of s(p).
- Cross-level scarcity in full generality cannot rely purely on counting |S|, because each changed index can be “relevant” to O(log n) levels at A_0 (via v_2(i)), and |S| can be Θ(n).
- Weighting arguments that sum ΔB_j/B_j(A_0) over j yield bounds of order |S| (too large) unless we impose structural constraints (equal-scale, grid alignment) to force commensurability conflicts.

Next steps (concrete, testable)
1) Curate Lemma 1 (toggle-locality identity) and Cor. 1.1. These are simple, exact, and will be repeatedly used.
2) Prove the equal-scale, grid-aligned cross-level scarcity claimed above. The key is to bound |S∩G_j|/B_j for off-scale j by o(1) using simple arithmetic progression intersection counts and the fact that inner cuts lie on the L-grid, while outer cuts contribute only O(#pairs) uniformly spread on that grid.
3) Generalize from exact alignment to “near alignment”: pairs with lengths in [L,2L) but inner boundaries allowed to drift; show via a pigeonhole/averaging over residues modulo L that one residue class captures a constant fraction, hence we can apply the aligned argument to that fraction, obtaining the same O(1) active-level cap (up to constants).
4) Experiments for n=64,128: enumerate random equal-scale partitions for several L and measure, per step, the number of j with B_j reduced by ≥1/2. We expect this number to be O(1) near levels with 2^{d−1−j}≈L and near zero for others. Record distributions to calibrate constants.
5) With the scarcity lemma in hand for each equal-scale phase, layer phases across L=1,2,4,… to argue that Σ_j |log_2 B_j − (d−j)| drops by at most O(1) per phase. This would yield Ω(log^2 n) steps for any algorithm restricted to equal-scale phases. Later, try to remove the restriction by decomposing an arbitrary step into O(1) “scale bins” (pigeonhole) and charging the potential drop to those bins.

Why this is promising
- The toggle-locality identity provides the right “demand certificate” per level j in terms of S∩T_j(A). In the A_0 regime, T_j(A) are dyadic grids, and equal-scale steps naturally constrain S to near-periodic grids; this sets up an arithmetic progressions intersection framework that is well suited to proving the desired O(1) active-level cap per step.

## Round 0003 — New local bounds, an aligned-step cross-level inequality, and a reassessment of the “O(1) active-levels” goal

### Quick recap of curated facts (for reference)
- Toggle-locality identity (curated): for a step with changed-adjacency set S, for each level j,
  \[ B_j(A')-B_j(A) = |T_j(A')\cap S| - |T_j(A)\cap S|. \]
  In particular, Decrease_j ≤ |T_j(A)∩S| and Increase_j ≤ |S\setminus T_j(A)|.
- Per-pair ±2 and factor-3 per-level cap (curated): each pair contributes at most ±2 to ΔB_j; hence B_j changes by at most a factor 3 per step.
- Dyadic alignment at A_0 and the weighted form (curated): for any S, \(\sum_j |S\cap G_j| = \sum_{i\in S}(1+v_2(i))\). Weighted instantiations are available and correct (verifier’s correction applied).

### New: a simple per-step “pair-budget” demand bound
- Lemma (per-step demand). Let a step use m matched pairs and S its set of changed indices. Then for any fixed bit-level j,
  \[\text{Decrease}_j \le |T_j(A)\cap S| \le |S| \le 3m.\]
  Proof. Immediate from toggle-locality and that a pair changes at most 3 adjacencies.
- Consequence (coarse necessary condition). A constant-fraction decrease at level j in one step, i.e., \(\text{Decrease}_j \ge \theta\,B_j(A)\), forces \(m \ge \tfrac{\theta}{3}\,B_j(A)\). For A=A_0, this is \(m \ge \tfrac{\theta}{3}\,(n/L_j)\). If moreover all total pair sizes lie in [L,2L], then m ≤ n/L, so a constant-fraction decrease at j necessitates \(L_j \gtrsim L\). This recovers the intuitive “only levels at or above the step’s scale can be significantly coarsened” necessary condition.

Why useful here. Although very coarse, this “pair-budget” lower bound is universal (no alignment assumptions) and will be a repeatedly invoked necessary condition when we later combine scale-wise inequalities.

### New: an equal-scale, grid-aligned cross-level inequality at A_0
We formalize a clean cross-level bound that leverages alignment to a dyadic grid and will be a base tool for any “phase-by-scale” analysis.

- Setting. Let A=A_0. Fix L=2^\ell and consider a step with:
  1) all matched pairs having total sizes in [L,2L), and
  2) all inner boundaries of the matched pairs at indices divisible by L (i.e., inner boundaries lie on the L-grid).
  Let m be the number of pairs; thus m ≤ n/L. Let S be the set of the (at most 3m) changed indices.

- Inequality 1 (large-scale weighted bound). For the set of levels with run-length at least L, i.e., \(\{j: L_j\ge L\}\), we have
  \[ \sum_{\{j: L_j\ge L\}} \frac{L}{L_j}\,\text{Decrease}_j\;\le\; 2|S|\;\le\;6m\;\le\;\frac{6n}{L}. \]
  Proof. From toggle-locality: \(\sum_j \frac{L}{L_j}\,\text{Decrease}_j \le \sum_{i\in S}\sum_{\{j: i\in G_j,\,L_j\ge L\}} \frac{L}{L_j}\). For an index i with 2-adic valuation t = v_2(i), the inner sum is a truncated geometric series \(\sum_{s=\ell}^{t} 2^{\ell-s} \le 2\), and is 0 if t<\ell. Thus the entire sum is ≤ 2|S|.

- Inequality 2 (small-scale aggregate fractional bound). For the levels with run-length below L (i.e., \(L_j<L\)), define \(w_j:=1/B_j(A_0)=L_j/n\). Then
  \[ \sum_{\{j: L_j<L\}} \frac{\text{Decrease}_j}{B_j(A_0)} \;=\; \sum_{\{j: L_j<L\}} w_j\,\text{Decrease}_j \;\le\; C\,\frac{n}{L}\,\log\frac{n}{L} \cdot \frac{1}{n}\;=\; C\,\frac{\log(n/L)}{L}. \]
  Proof idea. Toggle-locality gives \(\sum_j w_j\,\text{Decrease}_j \le \sum_{i\in S}\sum_{\{j: i\in G_j\}} w_j\). For A_0, as in the weighted version of Theorem 6, \(\sum_{\{j: i\in G_j\}} w_j = \sum_{\{j: i\in G_j\}} 2^{-(j+1)}\), which for v_2(i)=t evaluates to \(\le 2^{-d+t+1}\). The novel ingredient is to bound \(\sum_{i\in S} 2^{v_2(i)}\) for L-grid-aligned steps: each changed index i lies within distance <2L of a multiple of L; one can show (standard 2-adic counting) that \(\sum_{i\in S}2^{v_2(i)}\) is \(O\big(m\,2^{\ell}\,(1+\log(\tfrac{n}{L}))\big)\). Dividing by \(2^d=n\) yields the RHS. (I will write the detailed combinatorial bound in the next round; it uses that among N integers, the sum of the top-k values of v_2 is O(k log(N/k)+k), and here N≈n/L and k≈m≤N.)

- Consequences (interpreting the two inequalities).
  • From Inequality 1: it constrains the total weighted progress at levels with \(L_j\ge L\). In particular, it rules out (in an aligned step) making relative progress \(\Omega(1)\) across more than O(1) geometrically spaced large scales—more precisely, if \(\text{Decrease}_j\ge \theta B_j\) for all j in some set J with \(L_j\ge L\), then \(\sum_{j\in J} L/L_j\) is bounded, which forces J to be concentrated on O(1) adjacent scales. (Note: this does not bound |J| by a constant—it bounds a weighted count; see caveats below.)
  • From Inequality 2: at small scales \(L_j<L\), the sum of relative decreases \(\sum \text{Decrease}_j/B_j\) is \(O(\log(n/L)/L)\). Thus for large L (coarse steps), only a tiny number of small-scale levels can see a constant-fraction drop; quantitatively, the number of j with \(\text{Decrease}_j\ge \theta B_j\) and \(L_j<L\) is \(O\big((\log(n/L))/(\theta L)\big)\).

Why useful here. These inequalities, while not yet sufficient to give an \(O(1)\) drop of \(\sum_j |\log B_j - (d-j)|\) per step, provide scale-sensitive trade-offs that any “phase-by-scale” lower bound will need. They also identify the small-scale vs. large-scale dichotomy within an aligned step.

### Important reassessment: the “O(1) active levels per step” claim is likely false
- The earlier speculative Lemma 2 (“a matched boundary is only useful for O(1) levels, hence only O(1) levels can change by a constant factor per step”) appears untenable. Heuristic counterexample: take L=1, align inner boundaries on the 1-grid, and partition into singletons matched pairwise across the entire array. Then S contains almost all indices (up to endpoints), so \(|S\cap G_j|\) is \(\Theta(n/L_j)=\Theta(B_j)\) for all j simultaneously. Toggle-locality then permits \(\Theta(1)\) relative decreases for \(\Theta(\log n)\) many levels in the same step. This directly contradicts the “O(1) active levels” narrative.
- What is still tenable. Our new inequalities show that even though many levels can progress at once, an aligned step cannot simultaneously give large relative progress at scales far below L (Inequality 2) and its weighted progress across higher scales is bounded (Inequality 1). This suggests that any robust lower bound must measure progress with a scale-sensitive potential rather than a flat sum of \(|\log B_j - (d-j)|\).

### A restricted-class milestone: towards an \(\Omega(\log^2 n)\) bound for scale-phased algorithms
- Restricted model hypothesis. Consider algorithms that operate in phases; in each phase t, all matched pairs have sizes within a factor-2 window [L_t,2L_t), and (possibly after discarding a constant fraction of pairs by residue-class averaging) the inner boundaries are aligned to the L_t-grid.
- Strategy sketch. Define a scale-sensitive potential \(\Psi(A)=\sum_j w_t(j)\,|\log_2 B_j(A) - (d-j)|\) whose weights \(w_t(j)\) sharply peak around the “home scale” \(L_j\approx L_t\), e.g., \(w_t(j)=\alpha^{|\log_2 L_j - \log_2 L_t|}\) for a fixed \(\alpha\in(0,1)\). Using Inequalities 1–2 plus the pair-budget bound, aim to prove that in any L_t-aligned phase, \(\Psi\) decreases by at most a constant. Since \(\sum_t 1=\Theta(\log n)\) phases are needed to cover all scales L_t=2^t, this would force \(\Omega(\log^2 n)\) steps. This is a realistic, checkable plan for the restricted model.
- Status. The per-phase constant-drop claim requires a careful combinatorial bound on the weighted sum of decreases induced by the S-edges; our Inequality 1 gives the “upper tail” (\(L_j\ge L_t\)) control, and Inequality 2 controls the “lower tail” (\(L_j<L_t\)). I will formalize the choice of \(\alpha\) and complete the per-phase bound next.

### Gaps and clarifications in output.md
- Suggest adding the new “pair-budget” lemma stated above; it is an immediate corollary of Lemma 3 (toggle-locality) and is useful for quick necessary conditions.
- The equal-scale, grid-aligned cross-level bounds (Inequalities 1–2) are new and not yet in output.md. They are specialized to A_0, but they capture the key arithmetic-progression intersection needed for any scale-phased lower bound. I recommend curating Inequality 1 (fully rigorous as written) and flagging Inequality 2 as a lemma with a short proof deferred (the only remaining detail is the bound \(\sum_{i\in S}2^{v_2(i)}=O\big(m2^\ell(1+\log(n/L))\big)\), which I’ll write out).
- Caution: the earlier envisioned “O(1) active levels per step” is incompatible with aligned steps at small scale (L=1); hence it should not be pursued as a general lemma. The per-level factor-3 cap remains correct and relevant but does not by itself deliver \(\Omega(\log^2 n)\).

### Obstacles
- The sum-of-logs potential \(\Phi(A)=\sum_j |\log_2 B_j(A)-(d-j)|\) can drop by \(\Theta(\log n)\) in a single step (e.g., L=1 aligned), so it is not suitable to yield \(\Omega(\log^2 n)\) via an \(O(1)\) per-step drop.
- Cross-level scarcity in full generality (without alignment/restrictions) appears false at the granularity of “number of active levels.” New lower-bound proofs must use scale-sensitive weights and exploit alignment or pair-size budgets.

### Next steps (concrete and testable)
1) Curate the “pair-budget” lemma into output.md.
2) Curate Inequality 1 (large-scale weighted bound) for L-aligned steps from A_0, with a clean proof (as above).
3) Provide a complete proof of Inequality 2: write the combinatorial bound \(\sum_{i\in S}2^{v_2(i)}=O\big(m2^\ell(1+\log(n/L))\big)\) and record it as a lemma on 2-adic valuation sums near an L-grid.
4) Formalize a per-phase potential \(\Psi_t\) with geometric weights around scale L_t and prove an \(O(1)\) per-phase drop in the restricted (aligned, equal-scale) model, yielding \(\Omega(\log^2 n)\) steps for that class of algorithms.
5) Empirics on small n (n=32,64): verify that an L=1 aligned step from A_0 can reduce \(B_j\) by a constant factor for \(\Theta(\log n)\) levels, corroborating the reassessment.
6) Begin investigating whether a strong “central-boundary demand” lemma can be salvaged: quantify, per level j, the maximal number of decreases realizable by outer boundaries alone; aim to show that to achieve \(\Omega(B_j)\) decreases one must contribute \(\Omega(B_j)\) via inner boundaries when \(L_j\lesssim L\). This would strengthen Inequality 2 and aid the per-phase bound.

### Why this counts as progress
- Adds a universal, clean “pair-budget” demand bound for \(\text{Decrease}_j\) that will be used in multiple places.
- Proves a sharp cross-level inequality (Inequality 1) for aligned steps and outlines a second (Inequality 2) with a near-complete proof plan.
- Correctly identifies and documents the failure of the “O(1) active levels” approach, steering the program towards scale-sensitive potentials, which are more realistic for an \(\Omega(\log^2 n)\) lower bound in restricted models.
- Sets up a feasible restricted-model milestone (equal-scale, grid-aligned phases) where an \(\Omega(\log^2 n)\) lower bound appears within reach.

## Round 0003 — 2025-08-27T19:59:07.307583Z

Ideas
- Strengthen our step-local toolkit with two exact identities that (i) relate changes of all B_j at once to Hamming distances across changed adjacencies, and (ii) sharpen the per-pair effect in the “sub-run” regime from the bit-reversal start A_0. These are small, testable steps toward a cross-level scarcity principle.
- Reassess the “equal-scale scarcity” heuristic. A careful check shows that even with strong grid alignment, a single step can interact with Θ(log n) levels via the dyadic divisibility lattice; thus the very strong claim “only O(1) active levels per step” is false in that aligned special case. We document the precise extent of this phenomenon.

New lemmas (clean statements and proofs)
1) Hamming-sum identity across levels (exact).
- Statement. For any array A (permutation of {0,…,n−1}), let HD_A(i) be the Hamming distance in d-bit binary between the values at positions i and i+1, i∈{1,…,n−1}. Then for every j, |T_j(A)|=B_j(A)−1 counts the edges i where the j-th bit flips; consequently
  Σ_{j=0}^{d−1} (B_j(A)−1) = Σ_{i=1}^{n−1} HD_A(i).
- Moreover, in a single step A→A′, let S be the set of changed indices (three per matched pair). Then
  Σ_{j=0}^{d−1} (B_j(A′)−B_j(A)) = Σ_{i∈S} (HD_{A′}(i) − HD_A(i)).
- Proof. For fixed i, the indicator [i∈T_j(A)] equals [j-th bits of (A[i], A[i+1]) differ]. Summing over j gives HD_A(i). Summing over i yields the first identity. For the second: outside S adjacencies are unchanged, so HD does not change; inside S, boundary-membership toggles per j encode exactly the change of HD at i; summing over j then over i gives the displayed equality.∎
- Why useful. It is an exact accounting that complements toggle-locality: per changed adjacency, the total “boundary mass” across all levels can change by at most d. This can be paired with level-weighted potentials in future steps. It also indicates why naive unweighted potentials (Σ_j B_j) are too crude: a single step can change them by Θ(d·|S|).

2) Sub-run per-pair sharpening at A_0 (s < L_j regime).
- Setup. Fix j, and let L_j := 2^{d−1−j} be the j-run length at A_0 (positions are colored by the j-th bit of their values in A_0). Consider a matched pair (L,R) whose union U=L∪R has total span s := |U|.
- Lemma. If s < L_j, then among the three changed indices (left-outer, inner, right-outer) at most one belongs to G_j = T_j(A_0) (the j-boundary set in A_0). Consequently, for A=A_0,
  Δ_pair(j) ∈ {−1,0,1}, and in particular |Δ_pair(j)| ≤ 1.
- Proof. In A_0 the indices in G_j are exactly multiples of L_j; in particular, any two distinct elements of G_j differ by at least L_j. The three changed indices of the pair lie in the interval from the left-outer to the right-outer boundary, whose length is s+1. Because s < L_j, that interval contains at most one multiple of L_j. Hence at most one of the three changed indices lies in G_j. Applying toggle-locality at A_0, the contribution to |T_j| from this pair’s neighborhood can change by at most 1 in absolute value.∎
- Consequences (first step from A_0). For any level j and any family of pairs with s < L_j, the total j-level change satisfies |ΔB_j| ≤ |S∩G_j| ≤ min{m, |G_j|} ≤ min{m, B_j(A_0)−1}, where m is the number of pairs; moreover each contributing pair accounts for at most ±1 at level j. This refines Lemma 4 in the sub-run regime for the first step only.

3) Decrease-only alignment bound at A_0 under strong L-grid alignment.
- Setup. Let L be a positive integer. Suppose a step from A_0 is such that every interval boundary (both pair inners and outers) lies at an index multiple of L (e.g., we partition at indices ≡0 mod L and swap some adjacent blocks). Recall G_j = {i: 2^{d−1−j}|i}.
- Lemma. For any j with 2^{d−1−j} ∤ L (equivalently, L_j ∤ L), we have Decrease_j = 0.
- Proof. By toggle-locality at A_0, Decrease_j ≤ |T_j(A_0)∩S|=|G_j∩S|. But S⊆{multiples of L}, and if 2^{d−1−j}∤L then G_j contains no multiple of L, so the intersection is empty, whence Decrease_j=0.∎
- Remarks.
  • Increases may still occur (since new j-boundaries can be created at these indices), i.e., B_j can change even when Decrease_j=0. Thus the lemma is one-sided and must be combined with the desired direction of progress at level j.
  • The set of j with 2^{d−1−j}|L has size 1+⌊log_2 L⌋. Hence even under very strong alignment, ‘decrease-capable’ levels per step can be Θ(log L), not O(1). This corrects and quantifies the earlier over-optimistic equal-scale scarcity heuristic.

Examples (sanity checks)
- n=8, d=3, A_0=[0,4,2,6,1,5,3,7]. Take pairs of size s=2 that do not cross the unique G_0 boundary (at i=4). For j=0, Lemma 2 applies: each such pair changes B_0 by at most ±1; in fact, if s=2 and pairs do not straddle i=4, B_0 remains 2.
- With strong L-grid alignment and L=2, all boundary indices S are even. For j=1 (G_1={2,4,6}), decreases are possible; for j=0 (G_0={4}) decreases are also possible; for hypothetical j with L_j odd (none here), decreases would vanish. This matches Lemma 3.

Obstacles and why certain approaches fail
- Equal-scale scarcity beyond O(1). Even with all boundaries placed on an L-grid, decreases are only blocked for j with 2^{d−1−j}∤L; for the complementary j (those with 2^{d−1−j}|L) decreases are possible, and there are Θ(log L) such levels. Thus the sought “only O(1) active levels per step” is false under strong alignment. Moreover, for off-scale j where decreases are blocked, increases can occur—and for j in the lower half (where B_j(A_0) < B_j(A_*)), increases actually reduce the potential D_j. This shows that a decrease-only analysis cannot deliver the cross-level scarcity needed for an Ω(log^2 n) bound.
- Capacity-style bounds on Σ_j Decrease_j/B_j(A_0) suffice only for Ω(log n). Binning pairs by scale and using per-pair ±2 yields Σ_j (Decrease_j/B_j(A_0)) ≤ O(d) per step; hence the log-gap potential Σ_j |log B_j − (d−j)| can drop by Θ(d) per step, giving only Ω(d)=Ω(log n) steps.
- Why we need a “signed” cross-level constraint. The toggle-locality and Hamming-sum identities show that a changed index influences many levels in a structured way. To bound the drop of a potential like Φ(A)=Σ_j |log B_j(A)−(d−j)| by O(1), we likely need a cancellation principle across levels (e.g., a signed inequality per changed index), not a pure counting of aligned hits. Establishing such a cancellation is the core open obstacle.

Gaps or issues in output.md
- Output so far is consistent and correct with the factor-3 per-level cap (Theorem 5), toggle-locality (Lemma 3), and the dyadic alignment identity (Theorem 6). The new Lemma 3 above clarifies a one-sided phenomenon (decreases blocked by L-grid misalignment) and should be flagged as one-sided (increases can still occur). No changes to existing statements are needed, but adding the Hamming-sum identity would enrich the toolkit.

Next steps (concrete, testable)
1) Curate the Hamming-sum identity and the sub-run per-pair sharpening (s<L_j ⇒ |Δ_pair(j)|≤1 at A_0) into output.md. Both are exact/local and straightforward to verify.
2) Classify per-pair outcomes: For fixed j, characterize exactly when Δ_pair(j)∈{−2,−1,0,1,2} in terms of the six endpoint bits (a_L,L_1,L_k,R_1,R_m,a_R). This finite case analysis will allow a demand lemma quantifying how many inner-boundary hits (as opposed to outer) are necessary for a large decrease.
3) Develop a signed cross-level inequality: For a single changed index i, analyze the vector over j of the sign of its contribution to B_j (increase/decrease) in terms of the Hamming patterns before vs. after. Aim: show that for each i, the sum of “useful signed contributions” to the potential over j is bounded by an absolute constant (or by O(1) after a carefully chosen weighting). This is the most promising route to an O(1) per-step drop for an appropriate potential.
4) Small-n experiments (n=16,32,64): enumerate random steps from A_0; for each, record the set of j with B_j decreasing by ≥(1/2)·B_j, and those with D_j dropping by ≥1. Empirically bound the number of “active levels” and identify structural patterns of steps that maximize concurrent progress across j.
5) If step 3 succeeds, integrate with Theorem 5 to show an O(1) drop of Σ_j |log B_j − (d−j)| per step, implying Ω(log^2 n). Otherwise, pivot to algorithmic exploration: design a multiscale PBT schedule exploiting simultaneous increases/decreases to approach an O(log n) algorithm specific to bit-reversal.

Why this is progress
- The Hamming-sum identity is a new exact tool, and the sub-run sharpening is a concrete refinement in a key regime (first step from A_0). The alignment lemma (decreases-only) precisely corrects an earlier heuristic. Together, they map the landscape of what must be overcome for an Ω(log^2 n) lower bound and outline a plausible, testable path via signed cross-level cancellations.

## Round 0004 — 2025-08-27T20:15:06.329678Z

Headlines
- New extremal inequality: for any K-subset S⊆{1,…,N}, one has Σ_{i∈S} 2^{v_2(i)} ≤ N·H_K (H_K the K-th harmonic number). This sharpens and formalizes the 2-adic summation bound needed in Corollary 6.1 and yields Σ_j Decrease_j/B_j(A_0) ≤ O(log(n/L)) in equal-scale steps with ≤ n/L pairs.
- Geometric-window weights (first-step from A_0): for any fixed scale L=2^ℓ and any step (no alignment assumed) whose changed-index set is S, define a_j(L):=β^{| (d−1−j) − ℓ |}/2^{j+1} with β∈(0,1/2). Then Σ_j a_j(L)·Decrease_j ≤ C_β·(L/n)·|S|. In particular, for equal-scale steps with m pairs (hence |S|≤3m≤3n/L), one gets Σ_j a_j(L)·Decrease_j ≤ 3C_β = O(1). This gives an O(1) per-step cap on a scale-focused, cross-level weighted decrease from the bit-reversal start.

Gaps or corrections in output.md to flag
- The current output already contains Theorem 8 (large-scale weighted decrease bound) and Lemma 7.2 (sub-run decrease bound), both correct. There is, however, still no curated bound of the form Σ_{i∈S}2^{v_2(i)} in terms of |S|. I recommend adding the extremal bound below as a lemma; it is used implicitly in several sketches and enables a clean derivation of Σ_j Decrease_j/B_j(A_0) ≤ O(log(n/L)).
- The program still lacks any signed, cross-level per-step bound that applies beyond the first step (once A deviates from A_0). The geometric-window lemma below is first-step specific (it uses T_j(A_0)=G_j) and cannot be applied verbatim after the array evolves.

New technical lemmas (ready to curate)
1) Extremal 2-adic sum bound.
Lemma. Let N≥1 and S⊆{1,…,N} with |S|=K≥1. Then Σ_{i∈S} 2^{v_2(i)} ≤ N·H_K, where H_K=1+1/2+⋯+1/K.
Proof. Order the weights w(i):=2^{v_2(i)} for i∈{1,…,N} in nonincreasing order s_1≥s_2≥⋯≥s_N. For t≥0, at most ⌊N/2^t⌋ integers have v_2≥t, i.e., at most ⌊N/2^t⌋ weights are ≥2^t. Hence for every ℓ≥1, s_ℓ ≤ max{2^t : N/2^t ≥ ℓ} ≤ N/ℓ. Therefore Σ_{i∈S} 2^{v_2(i)} ≤ Σ_{ℓ=1}^K s_ℓ ≤ Σ_{ℓ=1}^K (N/ℓ) = N·H_K.∎
Corollary (small-scale fractional decreases, coarse but general). For A=A_0, any step with changed-index set S (|S|=K) satisfies
Σ_{j=0}^{d−1} Decrease_j/B_j(A_0) = Σ_j 2^{−(j+1)}·Decrease_j ≤ (2/n)·Σ_{i∈S} 2^{v_2(i)} ≤ 2·H_K.
In particular, in an equal-scale step with m pairs (hence K≤3m≤3n/L), Σ_j Decrease_j/B_j(A_0) ≤ O(log(n/L)).
Why useful: This fully rigorous bound replaces the previously sketched Inequality 2 with a clean, general estimate (though without the extra 1/L factor). It confirms that, in aggregate and relative to B_j(A_0), only logarithmic-in-(n/L) fractional shrinkage can be achieved across all levels in an equal-scale step.

2) Geometric-window weighted cross-level decrease (first step from A_0).
Lemma (geometric window). Fix L=2^ℓ and pick any β∈(0,1/2). Define scale-centered weights a_j(L):=β^{| (d−1−j) − ℓ |}/2^{j+1}. For A=A_0 and any one-step change with index set S,
Σ_{j=0}^{d−1} a_j(L)·Decrease_j ≤ C_β·(L/n)·|S|,
where C_β := (1/(1−β/2) + 1/(1−2β)). In particular, for equal-scale steps with m pairs one has Σ_j a_j(L)·Decrease_j ≤ 3C_β=O(1).
Proof. By toggle-locality and Theorem 6 (weighted form at A_0),
Σ_j a_j(L)·Decrease_j ≤ Σ_{i∈S} Σ_{j: i∈G_j} a_j(L).
For i with v_2(i)=t, the inner sum ranges over j with s:=d−1−j∈{0,1,…,t} and equals
Σ_{s=0}^{t} β^{|s−ℓ|}·2^{s−d} = 2^{−d}·(Σ_{s=0}^{ℓ} β^{ℓ−s}2^{s} + Σ_{s=ℓ}^{t} β^{s−ℓ}2^{s}).
Bound the two parts separately: Σ_{s=0}^{ℓ} β^{ℓ−s}2^{s} = 2^{ℓ}·Σ_{r=0}^{ℓ} (β/2)^r ≤ 2^{ℓ}/(1−β/2), and Σ_{s=ℓ}^{t} β^{s−ℓ}2^{s} = 2^{ℓ}·Σ_{r=0}^{t−ℓ} (2β)^r ≤ 2^{ℓ}/(1−2β). Thus, Σ_{j: i∈G_j} a_j(L) ≤ C_β·2^{ℓ−d} = C_β·(L/n). Summing over i∈S gives the claim; using |S|≤3m and m≤n/L (equal-scale) yields the O(1) consequence.∎
Remarks.
- Crucially, this does not assume any alignment; it is purely a first-step property from A_0. It precisely formalizes the “home scale” phenomenon: pairs with total size ≈L can only induce O(1) total weighted decreases when measured by a geometric window centered at that scale.
- The choice of β<1/2 ensures the tail beyond the home scale decays sufficiently quickly (the 2β factor in the upper tail), giving a per-index constant bound.

How these help and their limits
- The extremal 2-adic bound plus Corollary cleanly upper bound aggregate relative decreases across all levels by O(log(n/L)) in an equal-scale step. While not strong enough alone for an O(1) per-step drop of the unweighted potential, it quantifies a strict trade-off for small scales.
- The geometric-window lemma provides an O(1) per-step cap for a family of scale-focused, cross-level weighted potentials at the bit-reversal start. This is the first rigorous cross-level scarcity result that is scale-sensitive and constant per equal-scale step.
- Limitation: Both statements rely on A=A_0. After the first step, the boundary sets T_j(A) are no longer dyadic grids, so Theorem 6 cannot be applied directly. Extending the geometric-window argument beyond the first step requires new structure (e.g., showing that after a near-L step from A_0 the sets T_j(A) retain enough arithmetic regularity at scales ≈L to re-run the argument, or developing a signed, per-index cancellation bound that is independent of A).

Sanity checks and examples
- n=16, L=4 (ℓ=2), β=1/4. In a step of 4-block pairs (m≤4), we have |S|≤12 and L/n=1/4, hence Σ_j a_j(L)·Decrease_j ≤ C_β·(1/4)·12 = O(1). Empirically, the only levels with noticeable (unweighted) decreases are those with L_j∈{2,4,8} (adjacent to L), consistent with “home-scale” concentration.
- For L=1 (singletons paired), the geometric-window lemma still bounds the windowed decrease by O(1), despite the possibility that Θ(log n) levels see constant-factor unweighted changes. This illustrates the necessity of scale-sensitive weights.

Obstacles
- The geometric-window lemma is “first-step only.” Without a characterization of T_j(A) after a step, we cannot iterate the bound. A naive attempt to keep measuring against G_j (of A_0) does not telescope to a lower bound on sorting time.
- The extremal bound yields only O(log(n/L)) control on Σ_j Decrease_j/B_j(A_0); taken over Θ(log n) scales this still gives merely Ω(log n) steps for the unweighted potential.
- A signed cross-level inequality (bounding a weighted combination of decreases and increases that correlates with |log B_j−(d−j)|) remains open. The Hamming-sum identity suggests such cancellation might be possible with carefully chosen weights, but a precise bound is not yet proved.

Next steps (actionable)
1) Curate the extremal 2-adic bound and the geometric-window lemma into output.md (after verifier checks), as they are exact and broadly useful.
2) Search for persistence of arithmetic regularity: After an equal-scale step from A_0 at scale L, characterize T_j(A) for j with L_j≈L. Goal: show these boundary sets are unions of a bounded number of arithmetic progressions with large modulus, enabling a rerun of the geometric-window argument at the next step.
3) Signed per-index inequality: For a single changed index i (arbitrary A), analyze the vector over j of contributions to B_j(A′)−B_j(A) via HD_{A′}(i)−HD_A(i). Try weights of the form a_j(L)=γ^{| (d−1−j) − ℓ |}/2^{j+1} with γ<1/2 and prove Σ_j a_j(L)·(B_j(A′)−B_j(A)) ≤ O(L/n) uniformly in A. This would extend the geometric-window lemma beyond A_0.
4) Restricted-phase milestone: Under the equal-scale assumption per phase, define a phase potential Ψ_L(A):=Σ_j β^{|log_2 L_j−log_2 L|}·|log_2 B_j(A)−(d−j)| and prove an O(1) drop per phase from A_0 using the geometric-window lemma (for the “decrease-needed” half) together with a symmetric variant for increases. This would yield Ω(log^2 n) steps for the restricted model.
5) Case analysis for per-pair decreases: Classify the six-bit patterns (a_L,L_1,L_k,R_1,R_m,a_R) that yield Δ_pair(j)<0 and quantify when the inner boundary must coincide with a current j-boundary. This may lead to a “central-boundary demand” lemma needed to control decreases when T_j(A) has partial regularity.

Why this is progress
- The extremal 2-adic inequality closes a missing technical gap and makes several prior sketches rigorous.
- The geometric-window lemma is a genuinely new, constant-per-step cross-level bound (albeit for the first step), capturing scale-locality in a quantitative way. It provides a clear template for the type of weighting that could ultimately yield an Ω(log^2 n) lower bound via an O(1) per-phase drop argument.

## Round 0004 — 2025-08-27T20:16:38.241266Z

Headlines
- New exact, first-step bounds at A_0: a 2-adic “layer-cake” inequality for changed indices S implies a sharp upper bound on the weighted mass Σ_i 2^{v_2(i)} in terms of the number m of matched pairs. Combined with toggle-locality and the dyadic alignment identity, this yields a rigorous small-scale fractional bound: for a step from A_0 using m pairs, the sum of relative decreases Σ_{j: L_j<L} Decrease_j/B_j(A_0) ≤ O((1+log(n/m))/L). For equal-scale steps (all pair lengths in [L,2L)), this simplifies to O((log L)/L). This fills the gap flagged in the verifier’s feedback (our previous Inequality 2 lacked a proof).
- Consequences: in an equal-scale step, the total “relative progress budget” across all levels strictly below scale L is o(1) when L grows, sharply constraining simultaneous factor reductions at those levels in one step. This complements the large-scale weighted bound already curated (Theorem 8) and is ready to be added to output.md as a pair of lemmas/corollaries.

New lemmas and proofs (ready to curate)
1) Lemma (2-adic layer-cake bound for changed indices).
Setup. Let n=2^d, A=A_0, and let a single step use m matched pairs. Let S⊆{1,…,n−1} be the set of changed adjacency indices (|S|≤3m). For t≥0 let M_t={i∈{1,…,n−1}: 2^t divides i}.
Claim. One has
Σ_{i∈S} 2^{v_2(i)} ≤ C·n·(1+log_2(n/m)) for an absolute constant C.
Proof. For any i, write 2^{v_2(i)} ≤ 2·Σ_{t=0}^{v_2(i)} 2^t = 2·Σ_{t≥0} 2^t·1_{(i∈M_t)}; hence
Σ_{i∈S} 2^{v_2(i)} ≤ 2·Σ_{t≥0} 2^t·|S∩M_t|.
For each t, |S∩M_t| ≤ min{3m, ⌊(n−1)/2^t⌋}. Let T=⌊log_2(n−1)⌋ and choose t_0 = ⌊log_2((n−1)/(3m))⌋ (take t_0=−1 if (n−1)/(3m)<1). Then
Σ_{t=0}^{T} 2^t·|S∩M_t| ≤ Σ_{t≤t_0} 2^t·3m + Σ_{t>t_0} 2^t·(n/2^t)
≤ 3m·(2^{t_0+1}−1) + n·(T−t_0)
≤ 6m·2^{t_0} + n·log_2(2n/(3m)) ≤ 2n + n·log_2(2n/(3m)).
Multiplying by the factor 2 from the first inequality yields the claim with C an absolute constant.∎
Why useful. This bound depends only on n and the number of pairs m, not on any alignment assumptions. It is exactly the missing upper bound on Σ_{i∈S}2^{v_2(i)} requested in the verifier’s note, and it plugs into the toggle-locality/weighted-dyadic framework at A_0.

2) Theorem (small-scale fractional decrease bound at A_0).
Let A=A_0, n=2^d. For any integer L≥1,
Σ_{j: L_j<L} Decrease_j / B_j(A_0) ≤ (2/(nL))·Σ_{i∈S} 2^{v_2(i)}.
In particular, for a step with m pairs,
Σ_{j: L_j<L} Decrease_j / B_j(A_0) ≤ C·(1+log(n/m))/L.
Proof. Apply Lemma 3 (toggle-locality) with the weighted dyadic identity (Theorem 6) using weights a_j = (1/L)·1_{L_j<L}·(1/B_j(A_0)) = (1/L)·2^{−(j+1)}:
Σ_{j: L_j<L} Decrease_j/B_j(A_0) ≤ (1/L)·Σ_{i∈S} Σ_{j: i∈G_j} 2^{−(j+1)} = (1/L)·Σ_{i∈S} 2^{−(d−v_2(i)−1)} = (2/(nL))·Σ_{i∈S} 2^{v_2(i)}.
The inequality then follows from the Lemma above.∎

Corollary (equal-scale specialization). If all matched pairs have total lengths in [L,2L), then m≤n/L and hence
Σ_{j: L_j<L} Decrease_j / B_j(A_0) ≤ C·(1+log L)/L.
In particular, as L grows, the total relative decrease budget below scale L in a single equal-scale step is o(1).

Corollary (counting active small-scale levels). Fix θ∈(0,1]. In a step with m pairs, the number of levels j with L_j<L and Decrease_j ≥ θ·B_j(A_0) is at most O((1+log(n/m))/(θ L)). In the equal-scale [L,2L) regime this is O((1+log L)/(θ L)).

Why these results matter
- They provide the first rigorous, scale-sensitive small-scale trade-off from A_0: at scales strictly below L, the sum of relative decreases is bounded by O((log(n/m))/L), and hence by O((log L)/L) in equal-scale phases. This matches and formalizes the previously heuristic “Inequality 2” (now fully proved, with clear constants) and dovetails with the already curated large-scale bound (Theorem 8):
  • Large scales L_j≥L: Σ_{j} (L/L_j)·Decrease_j ≤ 6m.
  • Small scales L_j<L: Σ_{j} Decrease_j/B_j(A_0) ≤ C·(1+log(n/m))/L.
- Together, these are precisely the ingredients needed to bound per-phase progress under an equal-scale scheduling: the “upper tail” (large L_j) is controlled by the (L/L_j)-weighted absolute decreases, while the “lower tail” (small L_j) admits only a vanishing total relative decrease of order (log L)/L. This strongly suggests that a geometric-weighted potential concentrated near the phase’s home scale L can be shown to drop by O(1) per phase, yielding an Ω(log^2 n) lower bound for algorithms that proceed in equal-scale phases (grid alignment not required for the new small-scale bound).

Sanity checks and examples
- n=16, consider an equal-scale L=4 step. Then m≤n/L=4 and (1+log(n/m))/L ≤ (1+log(16/4))/4 = (1+2)/4 = 3/4. The corollary asserts Σ_{j: L_j<4}(Decrease_j/B_j(A_0)) ≤ O(0.75). Since L_j<4 means j with run lengths 1 or 2 (i.e., j∈{2,3}), the total fractional decrease across these two levels cannot exceed a constant < 1, precluding simultaneous 1/2-fraction drops at both j=2 and j=3 in a single L=4 step.
- For a coarser step, say L=n/8, m≤8 and (1+log(n/m))/L = O((1+log(n/8))/ (n/8)) = O((log n)/n), i.e., negligible small-scale progress below L.

How to combine with Theorem 8 (large scales)
- Theorem 8 bounds Σ_{j: L_j≥L} (L/L_j)·Decrease_j ≤ 6m (≤ 6n/L in equal-scale). This controls absolute decreases with a decaying weight L/L_j. Translating to log-changes requires care; however, for large-scale levels, a drop in log B_j is at most O(Decrease_j/B_j) per level (whenever Decrease_j ≤ B_j/2), and is uniformly O(1) otherwise by Theorem 5 (factor-3 cap). An O(1)-per-phase drop for a geometric-weighted potential Ψ_L(A)=Σ_j w_L(j)·|log B_j(A)−(d−j)| with weights w_L(j) sharply peaked around L (e.g., w_L(j)=min{1, L/L_j} or a smoother geometric taper) appears within reach: the new small-scale bound controls the tail j with L_j<L, while Theorem 8 controls the upper tail j with L_j≥L. I will formalize this per-phase potential in the next round.

Gaps or errors in output.md
- No errors spotted in the currently curated items. The new small-scale fractional bound (Theorem above and its corollaries) is currently missing and should be added. It relies only on Lemma 3 (toggle-locality), Theorem 6 (dyadic alignment at A_0), and the new Lemma (2-adic layer-cake bound), all of which are now self-contained and rigorously proved.

Obstacles and limitations (explicit)
- The new bounds are first-step-from-A_0 statements; after the array evolves, the clean dyadic identity (Theorem 6) no longer applies. Extending small-scale scarcity beyond the first step will require either (i) re-establishing a comparable structure on T_j(A) for the current A, or (ii) designing a different potential/weighting (possibly using the Hamming-sum identity, Theorem 7) that yields per-index signed cancellations across levels without relying on A_0’s dyadic grids.
- Large-scale progress to log-potential drop still needs a careful argument converting Σ (L/L_j)·Decrease_j into a comparable bound on Σ w_L(j)·Δ log B_j; this will use the factor-3 cap and case distinctions (small vs. large relative drops) per level.

Next steps (concrete and testable)
1) Curate the new Lemma (2-adic layer-cake bound) and the Theorem + corollaries (small-scale fractional bounds) into output.md.
2) Define a geometric phase-potential Ψ_L and prove an O(1) drop for equal-scale phases by combining Theorem 8 with the new small-scale inequality; quantify constants and edge cases (levels exhibiting >1/2 relative drop) via Theorem 5.
3) Explore signed cross-level weights using the Hamming-sum identity (Theorem 7): attempt to bound, per changed index i, the weighted sum over j of contributions to Δ log B_j by O(1), to decouple from A_0.
4) Case-analysis toward a “central-boundary demand” lemma: classify per-pair Δ_pair(j) in terms of six endpoint bits and show that achieving Ω(B_j) decrease forces Ω(B_j) inner-boundary hits; this would generalize small-scale control past the first step.
5) Small-n experiments (n=32,64): validate the sum-of-fractional-decreases bound in equal-scale steps and measure how close to saturation steps can get at various L.

Summary
- Established a crisp and fully rigorous small-scale fractional bound from A_0: Σ_{L_j<L} Decrease_j/B_j(A_0) ≤ C·(1+log(n/m))/L, and in particular, ≤ C·(log L)/L in equal-scale [L,2L) steps. The core technical tool is a new 2-adic layer-cake bound on Σ_{i∈S}2^{v_2(i)} that depends only on m.
- This complements the curated large-scale weighted decrease bound and is a key building block toward an Ω(log^2 n) lower bound in a phase-by-scale regime. The per-phase potential argument remains to be written; the present lemmas are immediately curatable and advance the program materially.



=== summary.md ===

## round-0001 — model summary — 2025-08-27T07:25:30.062332Z
Summarizer JSON fallback

## round-0001 — model summary — 2025-08-27T07:29:07.486957Z
In this round, the prover focused on establishing a lower bound of Omega(log^2 n) for sorting bit-reversal sequences through the formulation of two key lemmas. Lemma 1 addresses the constant-factor cap on changes to $B_j$ per step, while Lemma 2 limits the number of levels affected by a swap. Both lemmas require rigorous justification to ensure their validity. Empirical testing on small cases (n=2^k for k=1,2,3) was proposed to gather evidence, but it should be complemented with theoretical analysis. Additionally, the relationship between the counting lower bound and the potential function $Φ(A)$ needs further exploration.

## round-0001 — model summary — 2025-08-27T07:32:00.888558Z
Summarizer JSON fallback

## round-0001 — model summary — 2025-08-27T07:35:40.499980Z
In this round, two significant lemmas were proposed: Lemma 1 establishes a constant-factor cap on changes in monochromatic runs at a fixed bit level, while Lemma 2 asserts that a matched boundary only affects a constant number of nearby bit levels. Both lemmas are crucial for proving the overall lower bound but require rigorous justification. Initial test attempts with small cases (n=8 and n=16) were conducted to analyze the effects of swaps, and the potential function Φ(A) was explored to track changes. The relationship between counting arguments and the potential function was also examined, highlighting the need for coherence in the proof. Overall, the direction of the research is promising, but further rigor is essential for advancement.

## round-0001 — model summary — 2025-08-27T18:49:08.193845Z
This round formalized that our single-step model = PBT (parallel adjacent block transpositions, JOP arXiv:2311.08727) and set a concrete potential Φ(A)=∑_j D_j(A) with D_j(A)=|log2 B_j(A)−(d−j)|; for bit-reversal A0 this Φ(A0)=Θ(d^2). Two complementary threads produced rigorous local bounds: a per-level constant-factor cap on B_j change in one step (prover-01 gave a factor-4 bound; prover-02 refined the argument to c=7 via careful edge counting), and a size-sensitive bound Δ_j ≤ C·∑_p min{1, s(p)/L_j} tying level-j progress to swapped-pair sizes. A dyadic alignment lemma shows any cut index is “useful” for only O(log n) levels. These tools recover the known Ω(log n) lower bound but do not yet yield Ω(d^2)=Ω(log^2 n): the missing ingredient is a robust cross-level scarcity (only O(1) levels can get constant-factor progress in one step). Next steps target a “home-level” charging argument and small-n enumeration to validate constants. Citations: prover-01.out.json, prover-02.out.json; Jelínek–Opler–Pekárek (arXiv:2311.08727).

## round-0002 — model summary — 2025-08-27T19:46:36.085312Z
This round produced two complementary technical advances and a clear programmatic path. Prover-01 introduced the toggle-locality identity: for any single PBT step with changed-adjacency set S, B_j(A')−B_j(A)=|T_j(A')∩S|−|T_j(A)∩S|, and the immediate one-sided corollary Decrease_j ≤ |T_j(A)∩S| (and symmetrically for increases). It also restated the A_0 alignment count Σ_j |S∩G_j| = Σ_{i∈S}(1+v_2(i)) (weighted form included). Prover-02 fixed a proof gap and proved a tight per-pair ±2 contribution bound, yielding a per-level factor-3 cap B_j(A') ≤ 3 B_j(A). Both files give a clean equal-scale first-step scarcity claim from A_0: when all pairs have size ≈L, only O(1) adjacent dyadic levels near L can undergo constant-factor change. Remaining gaps: extending equal-scale scarcity beyond the first step and proving a robust home-level charging lemma. Files relied on: prover-01.out.json, prover-02.out.json.

## round-0003 — model summary — 2025-08-27T20:10:19.526707Z
This round develops two usable cross-level inequalities for L-grid-aligned steps from A_0 and a universal “pair-budget” lemma, and it overturns the earlier “O(1) active levels per step” hope. The pair-budget lemma gives Decrease_j ≤ |T_j(A)∩S| ≤ |S| ≤ 3m and forces m ≥ (θ/3)·B_j(A) to realize a θ-fraction drop at level j. For A_0 and steps with pairs of size in [L,2L) whose inner boundaries lie on the L-grid the authors prove: (1) a large-scale weighted bound Σ_{L_j≥L} (L/L_j)·Decrease_j ≤ 2|S| ≤ 6m ≤ 6n/L, and (2) a small-scale fractional bound Σ_{L_j<L} Decrease_j/B_j(A_0) = O((log(n/L))/L) (the latter reduces to bounding Σ_{i∈S} 2^{v2(i)} = O(m·2^ℓ(1+log(n/L))). A concrete counterexample shows an L=1 aligned step can give constant-factor drops at Θ(log n) levels, so a flat “O(1) active levels” lemma is false. A realistic route is a restricted phase-by-scale model (equal-scale, grid-aligned phases) with a geometric-weighted potential Ψ_t; proving an O(1) per-phase drop there would imply Ω(log^2 n). Citations: prover-02.out.json; prover-01.out.json.

## round-0004 — model summary — 2025-08-27T20:23:14.019832Z
This round produced two complementary, rigorous first-step bounds at the dyadic start A_0 and their immediate corollaries. Prover-01 gives a 2-adic “layer-cake” inequality bounding Σ_{i∈S} 2^{v_2(i)} ≤ C·n·(1+log_2(n/m)) (m = number of matched pairs), and uses toggle-locality + the dyadic identity to prove the small-scale fractional bound
Σ_{j: L_j<L} Decrease_j/B_j(A_0) ≤ (2/(nL))·Σ_{i∈S}2^{v_2(i)} ≤ C·(1+log(n/m))/L,
so equal-scale [L,2L) steps give O((log L)/L). Prover-02 supplies an extremal 2-adic sum lemma Σ_{i∈S}2^{v_2(i)} ≤ N·H_K and a geometric-window lemma: with weights a_j(L)=β^{| (d−1−j) − ℓ |}/2^{j+1} one has Σ_j a_j(L)·Decrease_j ≤ C_β·(L/n)·|S|, hence O(1) per equal-scale step. Together these plug the verifier’s missing Inequality 2 and give concrete scale-sensitive scarcity at A_0. Main limitation: all results are first-step (A=A_0) and must be extended (via signed per-index bounds or persistence of arithmetic regularity) to iterate phases. Citations: prover-01.out.json, prover-02.out.json.



=== notes.md ===
Setting and notation
- Input size n=2^d. The specific permutation A_0 is bit-reversal order of [0,…,n−1]. For j∈{0,…,d−1} we color elements by their j-th bit and denote by B_j(A) the number of monochromatic runs (contiguous blocks of equal j-bit) in the array A. Let T_j(A)⊆{1,…,n−1} be the set of j-run boundary indices (|T_j(A)|=B_j(A)−1). We consider one-step operations that swap a family of disjoint adjacent interval pairs in parallel.
- Our model of one step coincides with PBT (parallel adjacent block transpositions). One step chooses disjoint pairs (L_k,R_k) of adjacent contiguous intervals and swaps every chosen pair simultaneously.

Endpoint calibration (bit-reversal vs sorted)
- For A_0 (bit-reversal), B_j(A_0)=2^{j+1}. For the fully sorted order A_* = [0,1,…,n−1], B_j(A_*)=2^{d−j}. Consequently, the potential Φ(A):=Σ_{j=0}^{d−1} |log_2 B_j(A) − (d−j)| satisfies Φ(A_0)=Θ(d^2) and Φ(A_*)=0.

Locality of changes per pair and a safe per-level cap
- A single swapped pair (L,R) can alter adjacency only at three indices: the left outer boundary before L, the inner boundary between L and R, and the right outer boundary after R. For a fixed level j, if the union L∪R contains no j-boundary of the current array A, then all three affected adjacencies are between same colors both before and after; hence this pair produces no change in B_j.
- Therefore only pairs whose union contains at least one element of T_j(A) can affect B_j. Because the pair unions are disjoint, the number of such pairs is at most |T_j(A)|=B_j(A)−1. Each such pair contributes at most 3 to |B_j(A′)−B_j(A)|. Hence for every j and every PBT step A→A′,
  |B_j(A′) − B_j(A)| ≤ 3(B_j(A) − 1),
  which implies the multiplicative cap B_j(A′) ≤ 4·B_j(A) and B_j(A) ≤ 4·B_j(A′). In particular, |Δ log_2 B_j| ≤ 2 per step.

Dyadic alignment for A_0
- Let G_j denote the j-run boundary set in A_0. Then G_j = { i∈{1,…,n−1} : 2^{d−1−j} divides i }. For any set S of cut indices used in a step, one has
  Σ_{j=0}^{d−1} |S ∩ G_j| = Σ_{i∈S} (1 + v_2(i)) ≤ |S| (1 + ⌊log_2(n−1)⌋),
  since the number of j for which i∈G_j equals 1+v_2(i).

Caveats and corrections to earlier sketches
- The previously proposed “useful boundary” set U_j (indices in or adjacent to T_j(A)) is not a valid certificate for where toggles can occur: the post-step adjacency at a changed index depends on elements imported from potentially far away; mere distance-1 proximity to T_j(A) is insufficient to characterize where toggles can or cannot happen. We avoid using U_j.
- A claimed “size lemma” of the form Δ_j ≤ C·Σ_p min{1, s(p)/L_j} is false deterministically. Short pairs can be aligned to j-gridlines so that Δ_j ≍ n/L_j while the RHS is ≍ n/L_j^2. Any valid size-sensitive bound must use a different aggregation (see Next steps).
- Edge-to-level weighting that relies on fixed dyadic gridlines E_j holds at A_0 but not after the array evolves; after one step the j-boundaries are no longer constrained to those gridlines.

Next steps (program)
1) Try to sharpen the per-level cap to factor 2: Show |B_j(A′)−B_j(A)| ≤ c·|T_j(A)∪T_j(A′)| with small c (ideally c=1 or 2) by charging every toggling edge to a unique j-boundary contained in the union of the pair in either A or A′.
2) Demand for central matches: Prove that achieving a constant-factor decrease of B_j in one step requires Θ(B_j) central-boundary alignments (inner boundaries of swapped pairs) with j-run boundaries of A; outer-boundary hits alone cannot effect global coalescence. Make this precise and robust to local cancellations.
3) Cross-level scarcity via “home levels”: For each pair p of total size s(p), assign h(p) with L_{h(p)}≈s(p). Prove that constant-factor progress at level j needs Σ_{p: h(p)=j} Ω(1) contribution. Since Σ_p s(p) ≤ n and the sets {p: h(p)=j} are disjoint across j, only O(1) levels can make factor-≥2 progress in the same step. First prove the equal-scale special case (all pairs have sizes within ×2 of some L), which should already yield an Ω(log^2 n) lower bound for that restricted class.
4) Use the dyadic structure of G_j at A_0 to formalize a “central-boundary alignment trade-off” across levels: matched central boundaries that effect progress for one j are largely incompatible with those needed for many other j due to disjointness and dyadic spacing.
5) Perform small-n experiments (n=16,32) to estimate the maximal number of levels that can experience ≥2× change in B_j in one step and to guide constants.
New: toggle-locality identity and consequences
- Let A→A′ be one PBT step and let S⊆{1,…,n−1} be the set of indices whose adjacency changes in this step (exactly three per matched pair: left outer, inner, right outer; omit outer ones at array ends if absent). For each j, let T_j(A) be the set of j-run boundary indices (|T_j(A)|=B_j(A)−1).
- Identity (toggle-locality). For every j,
  B_j(A′) − B_j(A) = |T_j(A′) ∩ S| − |T_j(A) ∩ S|.
  Reason: outside S, adjacencies (and hence boundary membership) are identical in A and A′, so T_j(A′) Δ T_j(A) ⊆ S, which implies the stated cardinality identity.
- Corollary (one-sided bounds). For every j,
  Decrease_j := max{0, B_j(A) − B_j(A′)} ≤ |T_j(A) ∩ S|,
  Increase_j := max{0, B_j(A′) − B_j(A)} ≤ |S \ T_j(A)|.
  Interpretation: shrinking B_j by Δ forces at least Δ of the changed indices to land on current j-boundaries.

Improved per-level cap via per-pair ±2
- Per pair (L,R) and fixed j, define Δ_pair as the change in the number of j-boundaries attributable to that pair; then |Δ_pair| ≤ 2 (prove by the binary 4-cycle inequality on the three interfaces). In addition, only pairs whose union is non-monochromatic at level j can contribute, and such pairs are at most |T_j(A)| by disjointness (charge to an internal j-boundary index).
- Summing gives |B_j(A′)−B_j(A)| ≤ 2·|T_j(A)| = 2(B_j(A)−1). Applying the bound to the inverse step yields the multiplicative cap B_j(A′) ≤ 3B_j(A) and B_j(A) ≤ 3B_j(A′). Thus |Δ log_2 B_j| ≤ log_2 3 per step.

Weighted dyadic alignment at A_0 and a corrected weighted bound
- For A_0, G_j = T_j(A_0) is the dyadic grid {i: 2^{d−1−j} | i}. For any set S of changed indices, Σ_j |S∩G_j| = Σ_{i∈S} (1+v_2(i)). More generally, for nonnegative weights a_j, Σ_j a_j·|S∩G_j| = Σ_{i∈S} Σ_{j: i∈G_j} a_j.
- Combining with toggle-locality yields the exact inequality Σ_j a_j·Decrease_j ≤ Σ_{i∈S} Σ_{j: i∈G_j} a_j. For the specific weights a_j=2^{−(j+1)}, if v_2(i)=t then Σ_{j: i∈G_j} 2^{−(j+1)} = 2^{−(d−t−1)}(1−2^{−(t+1)}) ≤ 2^{−d+t+1}. Thus Σ_j 2^{−(j+1)}·Decrease_j ≤ Σ_{i∈S} 2^{−d+v_2(i)+1}. (This corrects a factor-2 slip in an earlier draft.)

Caution on “equal-scale first-step scarcity from A_0”
- The claim “if L_j > s then every union U=L∪R is j-monochromatic in A_0” is false. Counterexample (n=8, j=0): L_j=4; a union U of size s=2 that straddles the unique G_0 index at 4 is not monochromatic.
- What does hold: the per-pair ±2 bound implies |ΔB_j| ≤ 2m ≤ 2n/s for any j. From A_0 this yields that if L_j ≪ s then |ΔB_j|/B_j(A_0) ≤ O(L_j/s)=o(1), so constant-factor decreases at such j are impossible in that step. This does not preclude large changes when L_j ≫ s; additional structure (e.g., grid-aligned inner boundaries) seems necessary to prove an O(1) cap on the number of “active levels”.

Planned direction: equal-scale, grid-aligned scarcity
- Assume an L-aligned step: pair sizes in [L,2L) and all inner boundaries on the L-grid. For A starting at A_0, use arithmetic progression intersections to show that for off-scale j (2^{d−1−j} far from L) the proportion |S∩G_j|/B_j is o(1); combine with toggle-locality to rule out constant-factor decreases at those j. Only O(1) consecutive j with 2^{d−1−j}∈[L/2,2L] can be “active”. Control outer-boundary contributions by noting they contribute only O(#pairs) points, spread over a constant number of L-residue classes.

Next steps (actionable)
1) Write the full aligned-scarcity proof, including the precise bounds on |S∩G_j| and |S\G_j| for off-scale j.
2) Extend to near-alignment by averaging over residues modulo L to extract a constant-aligned subfamily.
3) Develop a central-vs-outer charging lemma: quantify the fraction of Decrease_j that must be paid by inner boundaries hitting T_j(A), uniformly over steps. This will dovetail with a home-level charging scheme for pairs.
4) Continue small-n experiments (n=32,64,128) to probe the number of levels with ≥ constant-factor decreases under equal-scale steps.
New exact identities, corrections, and scale-weighted constraints

1) Exact Hamming-sum identity across levels
- For any array A, define HD_A(i) as the Hamming distance (in d bits) between the values at positions i and i+1. Then for all A,
  Σ_{j=0}^{d−1} (B_j(A) − 1) = Σ_{i=1}^{n−1} HD_A(i).
- Across one step A→A′ with changed-adjacency set S (three per pair),
  Σ_{j=0}^{d−1} (B_j(A′) − B_j(A)) = Σ_{i∈S} (HD_{A′}(i) − HD_A(i)).
Explanation: For each i, the indicator that i∈T_j(A) is exactly the indicator that the j-th bits at i and i+1 differ; summing over j gives HD_A(i). Subtracting two arrays and noting HD is unchanged outside S yields the step identity. This is complementary to toggle-locality and shows per changed index the total boundary mass across all levels changes by at most d.

2) Sub-run regime from A_0: corrected one-sided statement
- Setup: A=A_0, fix j and its run length L_j=2^{d−1−j}. Consider a single pair (L,R) with union U of length s=|U|.
- Fact (geometry on G_j): If s<L_j then among the three changed indices of this pair (left outer, inner, right outer), at most one index belongs to G_j=T_j(A_0). Indeed, the three indices lie in an index interval of length s, which contains at most one multiple of L_j.
- Consequence (decrease-only). For such a pair and level j, the per-pair j-decrease is ≤1 (toggle-locality gives Decrease_j ≤ |T_j(A_0)∩S_pair| ≤ 1). Caution: increases can be as large as +2 in this regime (e.g., when the pair straddles a single j-boundary), so |Δ_pair(j)| is not ≤1 in general.
- Counterexample to the |Δ_pair(j)|≤1 claim: Let L be the last item of a j-run and R the first item of the next j-run in A_0; then s=2<L_j. Before the swap, only the inner interface is a j-boundary; after swapping, all three interfaces are j-boundaries, so the per-pair change is Δ_pair(j)=−2 (B_j increases by 2).

3) “Decrease-only alignment bound” as stated is false
- The claim “if all pair boundaries lie on the L-grid then for j with L_j∤L one has Decrease_j=0” does not hold. Even if S⊆{multiples of L}, S can still contain indices that are also multiples of L_j (e.g., multiples of lcm(L,L_j)), so |G_j∩S| may be nonempty. Toggle-locality alone cannot force Decrease_j=0 under this assumption. Any valid one-sided alignment bound must add further structure about which L-residue classes are used by S.

4) A clean large-scale weighted inequality from A_0
- For A=A_0 and any power-of-two L=2^ℓ,
  Σ_{j: L_j≥L} (L/L_j)·Decrease_j ≤ 2|S|.
  In steps with m pairs, this gives Σ_{j: L_j≥L} (L/L_j)·Decrease_j ≤ 6m. If in addition all pair lengths lie in [L,2L), then m≤n/L, yielding Σ_{j: L_j≥L} (L/L_j)·Decrease_j ≤ 6n/L.
- Proof idea: Combine toggle-locality with the dyadic alignment of G_j in A_0; for i with v_2(i)=t, the inner sum Σ_{j: i∈G_j, L_j≥L} (L/L_j)=Σ_{s=ℓ}^{t}2^{ℓ−s}≤2.

5) On small-scale control (sketch; not yet curated)
- Using weights w_j:=1/B_j(A_0)=L_j/n, toggle-locality and dyadic alignment give
  Σ_j w_j·Decrease_j ≤ (2/n)·Σ_{i∈S} 2^{v_2(i)}.
- Two routes to control the RHS:
  (a) General extremal bound: For any K-subset S⊆{1,…,n−1}, prove Σ_{i∈S}2^{v_2(i)} ≤ C K log(2n/K). With K≤|S|≤3m≤3n/L this yields Σ_{j: L_j<L} Decrease_j/B_j(A_0) ≤ O((log L)/L).
  (b) L-grid inner-boundary route: If a “central-boundary demand” lemma shows small-scale decreases must be paid mostly by inner boundaries, then restricting to S_inner⊆{multiples of L} gives Σ_{i∈S_inner}2^{v_2(i)} ≤ 2^ℓ·Σ_{k≤n/L}2^{v_2(k)} = O(n·log(n/L)), hence Σ_j Decrease_j/B_j(A_0) ≤ O(log(n/L)/L).
- Either route needs a complete proof before inclusion in output.

6) Reassessment of the “O(1) active levels per step)” heuristic
- In aligned steps at very small scale (e.g., L=1), S can intersect G_j at Θ(B_j(A_0)) for Θ(log n) many j simultaneously, so any argument purely bounding the number of active levels is untenable. Scale-sensitive weighted bounds (as above) are the right replacements.

7) Restricted-phase milestone
- For algorithms operating in phases with pair sizes in [L_t,2L_t) and inner L_t-grid alignment, define a phase-weighted potential Ψ_t(A) concentrated near the home scale L_t. Combine the large-scale inequality in (4) with a proved small-scale control to show O(1) drop per phase, yielding Ω(log^2 n) steps across scales.

Actionable next steps
- Prove a sharp bound on Σ_{i∈S}2^{v_2(i)} via route (a) or (b) above.
- Complete a per-pair six-bit case analysis; extract a “central-boundary demand” lemma quantifying the necessary contribution of the inner boundary for large decreases at a fixed j.
- Design signed cross-level weights using the Hamming-sum identity to bound per-index signed contributions by O(1). Validate on small-n instances.
New rigorously verified bounds from A_0 (bit-reversal start)

- Extremal 2-adic sum bound. For N≥1 and any K-subset S⊆{1,…,N}, one has
  \[\sum_{i\in S} 2^{v_2(i)} \le N\,H_K,\]
  where H_K is the K-th harmonic number. This is sharp up to constants and will be our default way to control 2-adic weighted sums over changed indices.

- Small-scale fractional decrease bound (first step from A_0). For L=2^\ell,
  \[\sum_{j: L_j<L} \frac{\mathrm{Decrease}_j}{B_j(A_0)} \le \frac{2}{nL}\sum_{i\in S} 2^{v_2(i)}.\]
  Combining with the extremal bound and |S|=K≤3m gives
  \[\sum_{j: L_j<L} \frac{\mathrm{Decrease}_j}{B_j(A_0)} \le \frac{2}{L} H_K \le \frac{2}{L} H_{3m}=O\!\left(\frac{\log m}{L}\right).\]
  Under equal-scale steps (all pair lengths in [L,2L)), we have m≤n/L and thus
  \[\sum_{j: L_j<L} \frac{\mathrm{Decrease}_j}{B_j(A_0)} = O\!\left(\frac{\log(n/L)}{L}\right).\]
  Immediate counting corollary: for any \(\theta\in(0,1]\), the number of levels j with L_j<L and \(\mathrm{Decrease}_j \ge \theta\,B_j(A_0)\) is at most \(O((\log(n/L))/(\theta L))\).

- Geometric-window weighted decrease (first step from A_0). Fix \(\beta\in(0,1/2)\) and a home scale L=2^\ell. Define weights \(a_j(L):=\beta^{\,| (d-1-j) - \ell |}/2^{j+1}\). Then
  \[\sum_j a_j(L)\,\mathrm{Decrease}_j \le C_\beta\,(L/n)\,|S|,\quad C_\beta=\frac{1}{1-\beta/2}+\frac{1}{1-2\beta}.\]
  In equal-scale steps, \(|S|\le 3m\le 3n/L\), so \(\sum_j a_j(L)\,\mathrm{Decrease}_j\le 3C_\beta=O(1)\).

Corrections to earlier sketches
- A previously claimed “layer-cake” estimate \(\sum_{i\in S}2^{v_2(i)}\le C n (1+\log(n/m))\) is not tight and in general false for large m; the correct universal upper bound is \(\sum_{i\in S}2^{v_2(i)}\le (n-1) H_{|S|}=O(n\log|S|)=O(n\log m)\).
- The specialization \(O((\log L)/L)\) for \(\sum_{j: L_j<L}\mathrm{Decrease}_j/B_j(A_0)\) does not follow in general; the correct equal-scale bound is \(O((\log(n/L))/L)\).

How these fit the program
- Together with Theorem 8 (large-scale weighted decreases), the new small-scale bound pinches progress from both sides at a chosen L, and the geometric-window lemma concentrates the accounting near L with an O(1) per-step cap (from A_0). This strongly motivates a phase potential centered at L and a proof of O(1) drop per equal-scale phase.

Next steps (refined)
1) Formalize an equal-scale phase potential that combines Theorem 8 with the small-scale bound and handles large relative drops via the factor-3 cap; target an O(1) drop per phase starting at A_0.
2) Extend beyond the first step: either show arithmetic regularity for \(T_j(A)\) near the home scale persists (enough to reapply the geometric-window argument), or prove a signed per-index inequality uniform in A, guided by the Hamming-sum identity.
3) Prove a central-boundary demand lemma via a six-bit case analysis, quantifying the necessary inner-boundary hits for large decreases at a fixed j.


=== output.md ===
Statements and proofs curated so far

Setup and notation
- Let n=2^d. An array A is a permutation of [0,…,n−1]. For j∈{0,…,d−1}, color each entry of A by the j-th bit of its value and let B_j(A) be the number of monochromatic runs in this 2-coloring. Let T_j(A)⊆{1,…,n−1} be the set of indices i where the j-color flips between positions i and i+1 (so |T_j(A)|=B_j(A)−1). A single step A→A′ is a parallel block transposition (PBT): a product of disjoint swaps of adjacent contiguous interval pairs (L,R). Such a step changes adjacencies only at the three interface indices of each pair (left outer, inner, right outer; omitting outer ones at the array ends).

Theorem 1 (Model equivalence to PBT). A single step of the model (swapping a family of disjoint adjacent interval pairs in parallel) is exactly a parallel block transposition (PBT) step.
Proof. A step chooses disjoint adjacent pairs (L_k,R_k) of intervals and swaps each pair simultaneously, leaving all other positions untouched. This is precisely a product of disjoint adjacent block transpositions. Conversely, any product of disjoint adjacent block transpositions can be realized by choosing those pairs. ∎

Theorem 2 (Endpoint run-counts). Let n=2^d and A_0 be the bit-reversal permutation of [0,…,n−1]. For j∈{0,…,d−1}:
- B_j(A_0)=2^{j+1}.
- For the fully sorted order A_*=[0,1,…,n−1], B_j(A_*)=2^{d−j}.
Consequently, with D_j(A):=|log_2 B_j(A) − (d−j)|, one has Σ_{j=0}^{d−1} D_j(A_0)=Θ(d^2) and Σ_{j=0}^{d−1} D_j(A_*)=0.
Proof. In A_0, the j-bit of the value at position i equals the (d−1−j)-th bit of i; thus along positions 0,…,n−1 this bit is constant on runs of length 2^{d−1−j} and alternates every such block, giving exactly 2^{j+1} runs. In A_*, the j-bit is constant on blocks of length 2^j and alternates every 2^j positions, yielding 2^{d−j} runs. The Θ(d^2) sum follows from Σ_{j=0}^{d−1} |2j+1−d| = Θ(d^2) by symmetry around (d−1)/2. ∎

Lemma 3 (Toggle-locality identity). Let A→A′ be one PBT step and let S be the set of indices whose adjacency changes in this step (the three interfaces per pair). Then for every j,
  B_j(A′) − B_j(A) = |T_j(A′) ∩ S| − |T_j(A) ∩ S|.
In particular, Decrease_j := max{0, B_j(A) − B_j(A′)} ≤ |T_j(A) ∩ S| and Increase_j := max{0, B_j(A′) − B_j(A)} ≤ |S \ T_j(A)|.
Proof. If i∉S then the adjacent entries across i are the same in A and A′, hence i∈T_j(A) iff i∈T_j(A′). Thus T_j(A′) Δ T_j(A) ⊆ S and
|T_j(A′)|−|T_j(A)| = |T_j(A′)∩S| − |T_j(A)∩S|.
Since B_j(·)=|T_j(·)|+1, the displayed identity follows; the one-sided bounds are immediate. ∎

Lemma 4 (Per-pair ±2 bound at a fixed level). Fix j and a single swapped pair (L,R). Let Δ_pair be its contribution to ΔB_j. Then |Δ_pair| ≤ 2. Moreover, if the union U=L∪R is j-monochromatic (equivalently, contains no index of T_j(A)), then Δ_pair=0.
Proof. Only the three interface indices can change their boundary status. Let a_L be the j-color of the neighbor immediately left of L, a_R the j-color of the neighbor immediately right of R; let L_1,L_k be the first/last j-colors in L and R_1,R_m the first/last j-colors in R. Writing [·] for the indicator of inequality, the total contribution before the swap equals
  X := [a_L≠L_1] + [L_k≠R_1] + [R_m≠a_R],
and after the swap equals
  Y := [a_L≠R_1] + [R_m≠L_1] + [L_k≠a_R].
Thus Δ_pair = X − Y. Using the inequality [q≠x] − [q≠y] ≤ [x≠y] twice gives
  Δ_pair ≤ [L_1≠R_1] + [R_m≠L_k] + ([L_k≠R_1] − [R_m≠L_1]).
The binary 4-cycle inequality [p≠q]+[q≠r]+[r≠s]−[s≠p] ≤ 2, applied to (p,q,r,s)=(L_1,R_1,L_k,R_m), yields Δ_pair ≤ 2. The lower bound follows symmetrically (or by applying the argument to the inverse swap). If U is j-monochromatic then L_1=L_k=R_1=R_m and all three interface indicators are unchanged, so Δ_pair=0. ∎

Theorem 5 (Per-level factor-3 cap per step). For any array A, any j, and any single PBT step A→A′,
  B_j(A′) ≤ 3·B_j(A) and B_j(A) ≤ 3·B_j(A′).
Equivalently, |log_2 B_j| changes by at most log_2 3 in one step.
Proof. Let M_j(A) be the set of swapped pairs whose union U is not j-monochromatic in A. By disjointness of the unions, each U∈M_j(A) contains at least one index of T_j(A), and distinct U’s receive distinct such indices; hence |M_j(A)| ≤ |T_j(A)| = B_j(A)−1. Summing Lemma 4 over pairs gives
  |B_j(A′) − B_j(A)| ≤ Σ_{pairs} |Δ_pair| ≤ 2·|M_j(A)| ≤ 2(B_j(A)−1).
Therefore B_j(A′) ≤ B_j(A) + 2(B_j(A)−1) ≤ 3B_j(A). Applying the same bound to the inverse step A′→A yields B_j(A) ≤ 3B_j(A′). ∎

Theorem 6 (Dyadic alignment for A_0; weighted form). Let G_j⊆{1,…,n−1} be the set of j-run boundary indices in A_0. Then G_j = { i : 2^{d−1−j} divides i }. For any set S⊆{1,…,n−1},
  Σ_{j=0}^{d−1} |S ∩ G_j| = Σ_{i∈S} (1 + v_2(i)).
More generally, for any weights a_j≥0,
  Σ_{j=0}^{d−1} a_j·|S ∩ G_j| = Σ_{i∈S} Σ_{j: 2^{d−1−j} | i} a_j.
Proof. In A_0 the j-bit is periodic with period 2^{d−j}, so boundaries occur exactly at indices i that are multiples of 2^{d−1−j}. For fixed i, the set of j with i∈G_j has size 1+v_2(i); the weighted identity is immediate by exchanging sums. ∎

Corollary 6.1 (Weighted decrease bound from A_0). In one step A_0→A′ with changed-index set S, and any weights a_j≥0,
  Σ_{j} a_j·Decrease_j ≤ Σ_{i∈S} Σ_{j: i∈G_j} a_j.
In particular, with a_j=2^{−(j+1)} and v_2(i)=t,
  Σ_{j} 2^{−(j+1)}·Decrease_j ≤ Σ_{i∈S} 2^{−(d−t−1)}(1−2^{−(t+1)}) ≤ Σ_{i∈S} 2^{−d+t+1}.
Proof. Combine Lemma 3 with Theorem 6 and use nonnegativity of the weights; the explicit sum for a_j=2^{−(j+1)} is a direct geometric series. ∎
Theorem 7 (Hamming-sum identity across levels).
Let A be any permutation of [0,…,n−1]. For i∈{1,…,n−1}, let HD_A(i) be the Hamming distance in d-bit binary between the values at positions i and i+1. Then
- Σ_{j=0}^{d−1} (B_j(A) − 1) = Σ_{i=1}^{n−1} HD_A(i).
Moreover, for any single PBT step A→A′ with changed-adjacency set S,
- Σ_{j=0}^{d−1} (B_j(A′) − B_j(A)) = Σ_{i∈S} (HD_{A′}(i) − HD_A(i)).
Proof. For fixed i, the indicator that i∈T_j(A) is exactly the indicator that the j-th bits of the adjacent values differ; summing over j gives HD_A(i). Summing over i yields the first identity. Subtracting the identity for A from that for A′ gives Σ_j(B_j(A′)−B_j(A)) = Σ_i(HD_{A′}(i)−HD_A(i)). Since HD is unchanged outside S, the sum over all i reduces to the sum over i∈S. ∎

Corollary 7.1 (Pair-budget demand for decreases).
Let a step use m disjoint pairs and S be its set of changed indices. Then for every j,
- Decrease_j ≤ |T_j(A)∩S| ≤ |S| ≤ 3m.
In particular, achieving Decrease_j ≥ θ·B_j(A) in one step requires m ≥ (θ/3)·B_j(A).
Proof. The first inequality is Lemma 3; |S|≤3m since each pair contributes at most three changed indices. The demand bound is immediate. ∎

Lemma 7.2 (A_0 sub-run per-pair decrease bound).
Let A=A_0. Fix j and its run length L_j=2^{d−1−j}. Consider a single swapped pair (L,R) whose union U has length s< L_j, and let S_pair be the three changed indices contributed by this pair. Then |T_j(A_0)∩S_pair|≤1; consequently the per-pair decrease at level j in this step satisfies Decrease_j ≤ 1.
Proof. The three changed indices lie between the left-outer and right-outer interfaces; this integer interval has length s< L_j and hence contains at most one multiple of L_j. Since G_j=T_j(A_0) is exactly the set of multiples of L_j, at most one of the three changed indices lies in G_j. Toggle-locality gives Decrease_j ≤ |T_j(A_0)∩S_pair| ≤ 1. ∎

Theorem 8 (Large-scale weighted decrease bound from A_0).
Let A=A_0 and L=2^ℓ. For any PBT step A→A′ with changed-index set S,
- Σ_{j: L_j≥L} (L/L_j)·Decrease_j ≤ 2|S|.
Consequently, if the step uses m pairs then Σ_{j: L_j≥L} (L/L_j)·Decrease_j ≤ 6m. If, moreover, all pair lengths lie in [L,2L), then m≤n/L and hence Σ_{j: L_j≥L} (L/L_j)·Decrease_j ≤ 6n/L.
Proof. By Lemma 3 and Theorem 6 (weighted form), for any nonnegative weights a_j,
  Σ_j a_j·Decrease_j ≤ Σ_{i∈S} Σ_{j: i∈G_j} a_j.
Take a_j = (L/L_j)·1_{L_j≥L}. For i with 2-adic valuation v_2(i)=t, the inner sum equals Σ_{s=ℓ}^{t} 2^{ℓ−s} ≤ 2 (empty if t<ℓ). Summing over i∈S gives Σ_{j: L_j≥L} (L/L_j)·Decrease_j ≤ 2|S|. The two corollaries follow from |S|≤3m and, under equal-scale [L,2L) pairs, m≤n/L. ∎
Lemma 9 (Extremal 2-adic sum bound).
Let N\ge 1 and S\subseteq\{1,\dots,N\} with |S|=K\ge 1. Then
\[\sum_{i\in S} 2^{v_2(i)} \le N\,H_K,\]
where \(H_K=\sum_{\ell=1}^K 1/\ell\) is the K-th harmonic number.
Proof. Order the weights \(w(i):=2^{v_2(i)}\) in nonincreasing order as \(s_1\ge s_2\ge\cdots\ge s_N\). For each integer \(t\ge 0\), at most \(\lfloor N/2^t\rfloor\) integers have \(v_2\ge t\), hence at most \(\lfloor N/2^t\rfloor\) weights are \(\ge 2^t\). Therefore, for every \(\ell\ge 1\),
\[s_\ell\le \max\{2^t: N/2^t\ge \ell\}\le N/\ell.\]
Thus \(\sum_{i\in S}2^{v_2(i)}\le \sum_{\ell=1}^K s_\ell\le \sum_{\ell=1}^K (N/\ell) = N H_K.\quad\square\)

Theorem 9 (Small-scale fractional decrease bound at A_0).
Let \(n=2^d\), \(A=A_0\) (bit-reversal), and \(L=2^\ell\). For any single PBT step \(A_0\to A'\) with changed-index set \(S\subseteq\{1,\dots,n-1\}\),
\[\sum_{j: L_j<L} \frac{\mathrm{Decrease}_j}{B_j(A_0)} \le \frac{2}{nL}\sum_{i\in S} 2^{v_2(i)}.\]
Proof. By toggle-locality (Lemma 3) and the weighted dyadic identity (Theorem 6), for nonnegative weights \(a_j\),
\[\sum_j a_j\,\mathrm{Decrease}_j \le \sum_{i\in S}\sum_{j: i\in G_j} a_j.\]
Choose \(a_j=(1/L)\,\mathbf{1}_{\{L_j<L\}}\,2^{-(j+1)}=(1/L)\,\mathbf{1}_{\{d-1-j<\ell\}}\,2^{-(j+1)}\). For fixed \(i\) with \(v_2(i)=t\), the inner sum is
\[(1/L)\sum_{j: i\in G_j,\;L_j<L} 2^{-(j+1)}= (1/L)\,2^{-d}\sum_{s=0}^{\min\{t,\ell-1\}}2^s \le (1/L)\,2^{-d}\sum_{s=0}^{t}2^s \le (1/L)\,2^{t+1-d}.\]
Summing over \(i\in S\) gives
\(\sum_{j: L_j<L} \mathrm{Decrease}_j/B_j(A_0) \le (2/(nL))\sum_{i\in S}2^{v_2(i)}\).\quad\square

Corollary 9.1 (Extremal control and equal-scale specialization).
With notation as in Theorem 9, let \(K=|S|\). Then
\[\sum_{j: L_j<L} \frac{\mathrm{Decrease}_j}{B_j(A_0)} \le \frac{2}{nL}\,(n-1)\,H_K \le \frac{2}{L}\,H_K.\]
In particular, if the step uses \(m\) disjoint pairs then \(K\le 3m\) and
\[\sum_{j: L_j<L} \frac{\mathrm{Decrease}_j}{B_j(A_0)} \le \frac{2}{L}\,H_{3m}=O\!\left(\frac{\log m}{L}\right).\]
If, moreover, all pair lengths lie in \([L,2L)\) (equal-scale), then \(m\le n/L\), hence
\[\sum_{j: L_j<L} \frac{\mathrm{Decrease}_j}{B_j(A_0)} = O\!\left(\frac{\log(n/L)}{L}\right).\]
Proof. Apply Lemma 9 with \(N=n-1\), then use \(K\le 3m\) and \(m\le n/L\).\quad\square

Corollary 9.2 (Counting active small-scale levels).
Fix \(\theta\in(0,1]\). Under the hypotheses of Theorem 9, the number of indices \(j\) with \(L_j<L\) and \(\mathrm{Decrease}_j\ge \theta\,B_j(A_0)\) is at most \(\frac{2}{\theta L}H_K\); in particular, in equal-scale steps it is \(O((\log(n/L))/(\theta L))\).
Proof. By Markov’s inequality on the nonnegative sum in Theorem 9 combined with Corollary 9.1.\quad\square

Theorem 10 (Geometric-window weighted cross-level bound at A_0).
Fix \(\beta\in(0,1/2)\) and a home scale \(L=2^\ell\). Define weights \(a_j(L):=\beta^{\,| (d-1-j) - \ell |}/2^{j+1}\). For any single PBT step \(A_0\to A'\) with changed-index set \(S\),
\[\sum_{j=0}^{d-1} a_j(L)\,\mathrm{Decrease}_j \le C_\beta\,(L/n)\,|S|,\quad\text{where}\quad C_\beta:=\frac{1}{1-\beta/2}+\frac{1}{1-2\beta}.\]
In particular, if all pair lengths lie in \([L,2L)\), then \(|S|\le 3m\le 3n/L\) and thus \(\sum_j a_j(L)\,\mathrm{Decrease}_j\le 3C_\beta=O(1)\).
Proof. By Lemma 3 and Theorem 6 with weights \(a_j(L)\),
\[\sum_j a_j(L)\,\mathrm{Decrease}_j \le \sum_{i\in S}\sum_{j: i\in G_j} a_j(L).\]
For \(i\) with \(v_2(i)=t\), writing \(s=d-1-j\),
\[\sum_{j: i\in G_j} a_j(L)=\sum_{s=0}^{t} \beta^{\,|s-\ell|}\,2^{s-d}=2^{-d}\Big(\sum_{s=0}^{\ell} \beta^{\ell-s}2^{s}+\sum_{s=\ell}^{t} \beta^{s-\ell}2^{s}\Big)\le 2^{-d}\,2^{\ell}\Big(\tfrac{1}{1-\beta/2}+\tfrac{1}{1-2\beta}\Big)=C_\beta\,(L/n).\]
Summing over \(i\in S\) yields the claim; the equal-scale consequence follows from \(|S|\le 3m\le 3n/L\).\quad\square


=== 2311.08727v1.pdf ===

--- Page 1 ---
The Hierarchy of Hereditary Sorting Operators
Vít Jelínek∗1, Michal Opler†2, and Jakub Pekárek1
1Charles University, Czechia
2Czech Technical University in Prague, Czechia
Abstract
We consider the following general model of a sorting procedure: we fix a
hereditary permutation class C, which corresponds to the operations that the
procedure is allowed to perform in a single step. The input of sorting is a
permutation π of the set rns “ t1, 2, . . . , nu, i.e., a sequence where each element
of rns appears once. In every step, the sorting procedure picks a permutation
σ of length n from C, and rearranges the current permutation of numbers by
composing it with σ. The goal is to transform the input π into the sorted
sequence 1, 2, . . . , n in as few steps as possible.
Formally, for a hereditary permutation class C and a permutation π of rns,
we say that C can sort π in k steps, if the inverse of π can be obtained by
composing k (not necessarily distinct) permutations from C. The C-sorting time
of π, denoted stpC; πq, is the smallest k such that C can sort π in k steps; if no
such k exists, we put stpC; πq “ `8. For an integer n, the worst-case C-sorting
time, denoted wstpC; nq, is the maximum of stpC; πq over all permutations π of
rns.
This model of sorting captures not only classical sorting algorithms, like
insertion sort or bubble sort, but also sorting by series of devices, like stacks or
parallel queues, as well as sorting by block operations commonly considered,
e.g., in the context of genome rearrangement.
Our goal is to describe the possible asymptotic behavior of the function
wstpC; nq, and relate it to structural properties of C. As the main result, we
show that any hereditary permutation class C falls into one of the following
five categories:
• wstpC; nq “ `8 for n large enough,
• wstpC; nq “ Θpn2q,
• Ωp?nq ď wstpC; nq ď Opnq,
• Ωplog nq ď wstpC; nq ď Oplog2 nq, or
• wstpC; nq “ 1 for all n ě 2.
In addition, we characterize the permutation classes in each of the five
categories.
∗Supported by the Czech Science Foundation under the grant agreement no. 23-04949X.
†Supported by the Czech Science Foundation Grant no. 22-19557S.
1
arXiv:2311.08727v1  [math.CO]  15 Nov 2023

--- Page 2 ---
1
Introduction
Sorting is, needless to stress, a central concept in computer science. The aim of
this paper is to study a general way to formalize the notion of sorting, based upon
the concept of hereditary permutation classes. In this approach, we fix a hereditary
class C of permutations, which corresponds to the operations that we are allowed to
perform in a single step of sorting. Given an input sequence of n distinct values, itself
viewed as a permutation, we aim to sort it into an increasing sequence by a sequence
of steps, where in each step we compose the current sequence with an element of C.
The goal is to minimize the number of steps for a given input, and to determine the
worst-case number of steps C needs on inputs of size n. This last quantity, which we
call the worst-case sorting time of the class C, is the main focus of this paper.
Our formalism is general enough to encompass standard sorting procedures, like
sorting by adjacent transpositions (“bubble-sort”) or sorting by insertions (“insertion
sort”), as well as parallel procedures like Habermann’s “parallel neighbor sort” [21]
(a.k.a. “odd-even sort”), which allows performing any number of adjacent swaps in a
single step.
Our formalism also models sorting procedures which are described via operations
not on single elements, but on blocks of consecutive elements, e.g. block reversals
or block transpositions. Such block-based sorting occurs, e.g., in the well-known
toy problem known as “pancake sorting” [11, 19], where the goal is to sort the input
by a sequence of prefix reversals. Block operations are also the backbone of the
sorting procedures studied in the context of genome rearrangement research (see,
e.g., [7, 14, 22, 24], or the surveys in [9, 18]).
Finally, we point out that our sorting formalism is closely related to the concept
of sorting networks, an approach which dates back to the works of Knuth [25] and
Tarjan [27] in late 1960s and early 1970s, respectively. A sorting network is an
acyclic directed graph whose every vertex represents a “sorting device” (e.g., a stack,
a queue, a double-ended queue, or a more general “C-container” considered by Albert
et al. [3]). An input sequence enters into the network from a designated source, its
elements can move along the edges and be rearranged by the devices at the vertices,
with the goal that the elements reach a designated sink in ascending order. Since
the action of most sorting devices considered in the literature can be modelled by a
hereditary permutation classes, our sorting formalism can be seen as a serial sorting
network (i.e., the network is a path) in which all the devices are of the same type.
The topic of sorting networks continues to be a major focus of research [10, 12, 13,
17], but we note that most of its previous results address the question of how many
permutations can be sorted by a given fixed network and what these permutations
look like, while our own focus is on finding the shortest serial network that sorts
every permutation of a given length. Additionally, some authors consider sorting
networks where the operation of the devices is restricted by the properties of the
input sequence, e.g., by assuming that a stack may only hold a monotone sequence
of values. These restricted devices no longer fit into our own formalism.
The aim of our paper is neither to improve the analysis of any specific sorting
algorithm, nor to propose a new specific algorithm; instead, our goal is to answer the
general question of which functions can occur as worst-case sorting times of hereditary
2

--- Page 3 ---
permutation classes. Accordingly, we disregard constant multiplicative factors and
focus on asymptotic behavior. Our results show that at this level of detail, the
possible sorting times can be classified into a hierarchy with gaps between individual
levels. Disregarding trivial extreme cases, a worst-case sorting time of a hereditary
class is either Θpn2q, or a function between Opnq and Ωp?nq, or Oplog2 nq, and for
each of these cases we can provide a structural characterization of the corresponding
hereditary classes.
We remark that the assumption of heredity is substantial in our setting. If
we were to consider sorting with an arbitrary set of generators, the sorting-time
problem would be essentially reduced to the problem of determining the diameter of
a Cayley graph in the symmetric group. This is a well-known group-theoretic open
problem, with a conjecture of Babai and Seress [6] stating that the diameter is at
most polynomial.
Let us now introduce the necessary definitions to state our results properly.
Notation, terminology, and the main result
A permutation of size n is a sequence π “ pπp1q, πp2q, . . . , πpnqq in which each
number from the set rns “ t1, 2, . . . , nu appears exactly once. We let Sn be the set
of permutations of size n, Sďn the set of permutations of size at most n, and S the
set Ť
ně1 Sn. We say that a permutation π P Sn contains a permutation σ P Sk if π
contains a subsequence of length k whose elements are in the same relative order as
the elements of σ, or more formally, if there are indices 1 ď i1 ă i2 ă ¨ ¨ ¨ ă ik ď n
such that πpiaq ă πpibq ðñ σpaq ă σpbq for every a, b P rks. If π does not contain
σ, we say it avoids σ.
A hereditary permutation class (or henceforth just class) is a set C Ď S such that
for every π P C and every σ contained in π, σ is also in C. For a permutation class C,
we let Cn denote the set C X Sn.
For a pair of permutations σ, π P Sn, their composition σ ˝ π is the permutation
pσpπp1qq, σpπp2qq, . . . , σpπpnqqq. For a pair of permutation classes A and B, we write
A ˝ B for tα ˝ β; α P A, β P Bu, A˝k for the k-fold composition A ˝ A ˝ ¨ ¨ ¨ ˝ A, and
A˚ for Ť
kě1 A˝k. Note that A ˝ B, A˝k and A˚ are again permutation classes.
The inverse of a permutation π P Sn is the permutation π´1 P Sn such that
π´1 ˝ π is the identity permutation p1, 2, . . . , nq.
Recall that the C-sorting time of π, denoted stpC; πq, is the smallest k such that
π´1 is in C˝k, or `8 if no such k exists. For an integer n, the worst-case C-sorting
time, denoted wstpC; nq, is the maximum of stpC; πq over all permutations π of rns.
We are now ready to recall the main result of this paper.
Theorem 1.1. Every permutation class C falls into one of the following five cate-
gories:
• wstpC; nq “ `8 for n large enough,
• wstpC; nq “ Θpn2q,
• Ωp?nq ď wstpC; nq ď Opnq,
3

--- Page 4 ---
• Ωplog nq ď wstpC; nq ď Oplog2 nq, or
• wstpC; nq “ 1 for all n ě 2.
The rest of this paper is devoted to the proof of this theorem. After we introduce
some more terminology and review some relevant facts about permutation classes
(Section 2), we will proceed by characterizing the classes with infinite sorting time in
Section 3. This is easily done, as it more or less directly follows from previous results
on composition-closed permutation classes. We then show, in Section 4, that if the
sorting time is finite, it is at most Opn2q. Next, in Section 5, we establish the gap
between quadratic and linear sorting times. Our main device is a numerical parameter
called reduced inversion number rinpπq, which we introduce. We show that a class
C has wstpC; nq “ Ωpn2q whenever rinp¨q is bounded on C, and wstpC; nq “ Opnq
otherwise.
The most difficult part of the proof appears in Section 6, where we show that
there are twelve (or four, after we account for symmetries) minimal classes with
sorting time Oplog2 nq, while any class that does not contain one of these twelve as
a subclass has sorting time Ωp?nq. The proof of this lower bound combines a new
structural result on classes avoiding the twelve ‘polylog’ subclasses, an argument
showing that sorting with such a class can be encoded into a specific graph which
has a drawing on a surface of not-too-large genus with not-too-many crossings, and a
bound on the tree-width of a graph that can be drawn on a surface of a given genus
with a given number of crossings.
The short Section 7 contains the proof that any class not containing all permuta-
tions has sorting time Ωplog nq. This is a straightforward counting argument using
the Marcus–Tardos theorem. We conclude in Section 8 with open problems, chief
of which is to close the gaps between Ωp?nq and Opnq, and between Ωplog nq and
Oplog2 nq implied by Theorem 1.1. In fact, for all the classes whose sorting time
we can establish asymptotically tightly, the sorting time is either `8, Θpn2q, Θpnq,
Θplog nq or 1.
2
Permutation classes
We let Avpπ1, π2, . . . , πmq denote the class of permutations that avoid all the per-
mutations π1, . . . , πm. We also use the special notation
for the class Avp21q of
all the increasing permutations, and
for the class Avp12q of all the decreasing
permutations. Let ιk denote the identity permutation p1, 2, . . . , kq, and let δk be the
decreasing permutation pk, k ´ 1, . . . , 1q.
It is often convenient to represent a permutation π P Sn by its diagram, which is
the point set Dpπq “ tpi, πpiq; i P rnsu.
Apart from the inverse π´1 introduced before, we will need several other operations
on a permutation π “ pπp1q, . . . , πpnqq. Its reverse, denoted πr, is the permutation
pπpnq, πpn´1q, . . . , πp1qq, its complement πc is the permutation pn`1´πp1q, n`1´
πp2q, . . . , n`1´πpnqq. Finally, the flip of π, denoted πf, is defined as πf “ ppπrq´1qr.
In terms of permutation diagrams, the reverse corresponds to reflection over a
vertical line, the complement corresponds to reflection over a horizontal line, the
4

--- Page 5 ---
inverse corresponds to reflection over the diagonal line y “ x, and flip corresponds
to reflection over the line y “ n ` 1 ´ x.
For a set of permutations C, we write Cr “ tπr; π P Cu, Cc “ tπc; π P Cu,
C´1 “ tπ´1; π P Cu and Cf “ tπf; π P Cu. Note that if C is a class, then so are Cr,
Cc, C´1 and Cf.
For a pair of permutations α P Sk and β P Sℓ, their direct sum α ‘ β is the
permutation pαp1q, αp2q, . . . , αpkq, k ` βp1q, k ` βp2q, . . . , k ` βpℓqq, and their skew
sum α a β is the permutation pℓ` αp1q, ℓ` αp2q, . . . , ℓ` αpkq, βp1q, βp2q, . . . , βpℓqq.
We let Àm α denote the direct sum α ‘ α ‘ ¨ ¨ ¨ ‘ α with m summands, and Ám α
is defined similarly. For a set of permutations C, its sum-closure À C is the set of all
the permutations that can be obtained as a direct sum of a finite number of (not
necessarily distinct) elements of C. Similarly, we define the skew-closure Á C. If C is
a class, then so are À C and Á C.
Before we proceed, let us collect several simple observations related to sorting
times of various classes.
Observation 2.1. For any two permutations σ and π of size n, we have pσ ˝ πq´1 “
π´1 ˝ σ´1 and pσ ˝ πqf “ πf ˝ σf.
Consequently, for any permutation class C
and any permutation τ, stpC; τq “ stpC´1; τ ´1q “ stpCf; τ fq, and in particular,
wstpC; nq “ wstpC´1; nq “ wstpCf; nq.
Observation 2.2. If A and B are permutation classes such that A Ď B˝k and π is
any permutation, then stpB; πq ď k ¨ stpA; πq, and hence wstpB; nq ď k ¨ wstpA; nq.
Observation 2.3. Let C be a class containing
as a subclass. Then Cr “ C˝
Ď C˝2,
and in particular, by Observation 2.2, wstpC; nq ď 2wstpCr; nq. Similarly, wstpC; nq ď
2wstpCc; nq.
Griddings and grid classes
We say that a set P of points in the plane is in general position if no two points of P
are on the same horizontal or vertical line. We say that two finite point sets P and
Q in general position are order-isomorphic, if there is a bijection from P to Q which
preserves both the left-to-right and the bottom-to-top order of the points. Note that
any finite set P of points in general position is order-isomorphic to a permutation
diagram of a unique permutation α; we than say that P induces a copy of α.
Let π P Sn be a permutation with a permutation diagram Dpπq. A k ˆ ℓgridding
of π is a set of k ` 1 vertical lines v0, v1, . . . , vk numbered left to right and ℓ` 1
horizontal lines h0, h1, . . . , hℓnumbered bottom to top, such that Dpπq is inside the
rectangle bounded by v0, vk, h0 and hℓ, and no point of Dpπq lies on any of the
k ` ℓlines of the gridding. For i P rks and j P rℓs, the cell pi, jq of the gridding,
denoted is the rectangle bounded by the lines vi´1, vi, hj´1 and hj. A permutation
together with its gridding is referred to as a gridded permutation. If π is a gridded
permutation and X a cell of its gridding, we let πrXs denote the set Dpπq X X, and
the permutation induced by this set is simply referred to as the subpermutation of π
induced by X.
A gridding matrix is a matrix M whose every entry is a permutation class; see
Figure 1 for an example. For consistency with the Cartesian coordinates we use for
5

--- Page 6 ---
Figure 1: Left: a 4 ˆ 3 gridding matrix M; by convention, we assume that the empty
cells represent the permutation class that only contains the empty permutation.
Right: an example of an M-gridded permutation, represented by its diagram.
permutation diagrams, we will assume that rows in a matrix are numbered bottom
to top, and we let Mi,j denote the entry in column i and row j of the matrix M.
Suppose M is a gridding matrix with k columns and ℓrows. An M-gridding of a
permutation π is a k ˆ ℓgridding with the property that for every pi, jq P rks ˆ rℓs,
the cell pi, jq of the gridding induces in π a permutation belonging to the class Mi,j.
The grid class determined by M, denoted GridpMq, is the set of those permutations
π that admit an M-gridding.
An important special case of grid classes are the so-called monotone juxtapositions,
whose gridding matrices have shape 2 ˆ 1 or 1 ˆ 2, and each of their two entries is
or
. In particular, there are eight monotone juxtapositions.
2.1
Some notable classes
We will now introduce several permutation classes that will play an important role
in our results. See Figure 2 for some examples and Table 1 for a complete list.
The class of layered permutations, denoted L, is the sum-closure of the class
.
Equivalently, it can be defined as Avp231, 312q. We remark that sorting by layered
permutations is equivalent by sorting with a series of so-called pop-stacks.
The Fibonacci class, denoted F, is the sum-closure of the set t1, 21u, or equiva-
lently the class of 321-avoiding layered permutations. Its name refers to the fact that
|Fn| is the n-th Fibonacci number. Sorting with the Fibonacci class F corresponds to
sorting where in each step we perform parallel transpositions of disjoint adjacent pairs
of elements. This includes, as a special case, an algorithm known as odd-even sort
(also known as parallel neighbor-sort), introduced and analyzed by Habermann [21],
who showed that the algorithm requires n rounds in the worst case. This implies
that wstpF; nq “ Opnq. This is asymptotically tight since, e.g., any permutation π
with πpnq “ 1 requires at least n ´ 1 F-steps to be sorted. Thus, wstpF; nq “ Θpnq.
The rotation class is the class R :“ tιa a ιb; a, b P N0u. Note that for ρ P Rn and
π P Sn, π ˝ ρ is a cyclic rotation of the sequence π. We will also consider the class
RR :“ R Y Rr, corresponding to rotations and their reversals. Both these classes
are composition closed, and in particular have infinite sorting time, as they cannot
sort any permutation that does not belong to the class.
The parallel block transposition class, denoted PBT , is the sum-closure of R. To
our knowledge, this class has not been considered before, but it emerges naturally in
6

--- Page 7 ---
Figure 2: From left to right: diagram of a layered permutation, diagram of a
permutation from the Fibonacci class F, and a diagram of a permutation from the
class PBT .
our results as one of the twelve minimal classes with polylogarithmic sorting time.
The class CBub :“ tιa ‘ 21 ‘ ιb; a, b P N0u Y
corresponds to sorting by adjacent
transpositions. This includes, e.g., the classical bubble sort algorithm. It can be
easily seen that wstpCBub; nq “
`n
2
˘
. A slight modification yields the class T :“
tιa ‘ 21 ‘ ιb; a, b P N0u Y t1 a ιc a 1; c P N0u Y
, which corresponds to cyclic
adjacent transpositions, where positions 1 and n are treated as adjacent.
The class k-Fringe :“ tπ‘ιa‘σ; a P N0, |σ| ď k, |π| ď ku contains permutations
in which only the prefix of length k and the suffix of length k can be permuted. We
also define k-RFringe :“ k-Fringe Y pk-Fringeqr.
The grid class CPan “ Grid
´
¯
corresponds to sorting where in each step, we
reverse the prefix of the permutation being sorted. This is known in the literature as
pancake sorting. It is well known that wstpCPan; nq “ Θpnq. It is easy to see that the
same asymptotic estimate also applies to Cr
Pan, Cc
Pan and Cf
Pan.
The grid class
CIns “ Grid
¨
˝‚
˛
‚
corresponds to sorting where in each step, we take the first element of the input and
insert it to an arbitrary position i, while moving the elements in positions 2, 3, . . . , i
one step to the left. This corresponds to the classical insertion sort algorithm. The
standard application of the algorithm can sort any input in n´1 steps, by maintaining
the invariant that after k steps, the final k `1 elements are in increasing order; hence,
wstpCIns; nq ď n ´ 1. This bound is tight, since any permutation π with πpnq “ 1
requires n ´ 1 steps to be sorted.
3
Classes that cannot sort
Let us say that a class C cannot sort, if wstpC; nq “ `8 for some n. Note that this
is equivalent to C˚
n ‰ Sn. Moreover, if C˚
n is different from Sn for some n, then for
any m ě n, C˚
m is different from Sm, since C˚ is a permutation class.
7

--- Page 8 ---
Notation
Description
L
À
F
Àt1, 12u “ L X Avp321q
R
Grid
ˆ
˙
RR
R Y Rr
PBT
À R
CBub
Grid
¨
˚
˚
˝
‚
‚
˛
‹‹‚
Notation
Description
T
CBub Y Grid
¨
˝
‚
‚
˛
‚
k-Fringe
Grid
¨
˝
Sďk
Sďk
˛
‚
k-RFringe
k-Fringe Y k-Fringer
CPan
Grid
ˆ
˙
CIns
Grid
¨
˝‚
˛
‚
Table 1: A summary of relevant permutation classes
When seeking to characterize the maximal classes that cannot sort, we may
restrict our attention to the classes C that are composition closed, that is, those that
satisfy C “ C˚. Composition closed permutation classes have been characterized by
Atkinson and Beals [4]. Translating their results into our terminology, we obtain the
following proposition.
Proposition 3.1. A permutation class C cannot sort if and only if it satisfies, for
some k P N, one of the following two conditions:
1. C is a subclass of RR Y Sďk, or
2. C is a subclass of k-RFringe.
4
From infinity to Opn2q
Let us now focus on showing that any class that can sort has at most quadratic
sorting time. Our key concept will be the notion of peg class, which is a grid class
with a gridding matrix whose every row and column has exactly one nonempty cell,
and each nonempty cell is either the singleton class t1u or one of the two monotone
classes
and
.
Peg classes have been previously studied mostly in the context of enumeration [2,
23, 22]. Indeed, it is known that a permutation class has polynomial growth rate
if and only if it is a finite union of peg classes. For our purposes, we will use the
following result.
Fact 4.1 (Homberger–Vatter [22, Theorem 3.1]). If a permutation class C does not
contain as a subclass any monotone juxtaposition, nor F nor Fr, then C is a finite
union of peg classes.
8

--- Page 9 ---
Ca “ Grid
¨
˝
‚
‚
˛
‚, Cb “ Grid
¨
˝
‚
‚
˛
‚, Cc “ Grid
¨
˝
‚
‚
˛
‚,
Cd “ Grid
¨
˚
˚
˝
‚
‚
˛
‹‹‚, Ce “ Grid
¨
˚
˚
˝
‚
‚
‚
˛
‹‹‚.
Figure 3: Five peg classes that can sort in quadratic time.
It is not hard to see that any monotone juxtaposition has worst-case sorting time
of order Oplog nq; we later prove this in Proposition 6.11. Also for the Fibonacci
class F, we have already pointed out that wstpF; nq “ Θpnq, and we may easily
observe that wstpFr; nq “ Opnq.
Thus, if a class C has at least quadratic wstpC; nq, it cannot contain any monotone
juxtaposition and any symmetry of F as a subclass. Thus, by Fact 4.1, such a class
C can be written as a finite union of peg classes.
Lemma 4.2. Let C be a peg class. If C can sort, then wstpC; nq “ Opn2q.
Proof. If the gridding matrix of C contains a cell equal to
as well as a cell equal to
, then C contains CPan “
‘
or one of its symmetries as a subclass, and with the
help of Observation 2.3 we easily conclude that wstpC; nq “ Opnq.
Suppose then that at most one of the two classes
and
occurs in the gridding
of C. If
occurs, then by Observation 2.3, wstpC; nq ď 2wstpCr; nq, and Cr is a peg
class whose gridding matrix contains
. It is therefore enough to deal with peg
classes whose gridding matrix contains
but not
. We assume from now on that C
is such a peg class.
Let M be the gridding matrix of the class C, and assume that M has been chosen
to have the smallest possible number of rows and columns. In particular, this means
that if Mi,j “
for some i and j, then either the cell Mi,j is in the last column or
last row of M, or the cell Mi`1,j`1 is empty. If not, then we could delete column
i ` 1 and row j ` 1 from M to obtain a smaller gridding matrix representing the
same class C. By the same reasoning, if Mi,j “
for some i ą 1 and j ą 1, then
Mi´1,j´1 is empty.
Consider now the five peg classes from Figure 3. We claim that all these classes,
and therefore also their inverses and flips, have at most quadratic sorting time.
Consider the class Ca, which corresponds to sorting where in every step we either
move the first element of the input to the last position, shifting the remaining
elements one step forward, or we move the first two elements to the end, while
simultaneously changing their relative position. We may easily see that by a sequence
of at most n steps of Ca, we may simulate a single step of the class F of parallel
adjacent transpositions on an input of size n. As we pointed out in Section 2,
wstpF; nq “ Opnq. It follows that wstpCa; nq “ wstpC´1
a ; nq “ wstpCf
a; nq “ Opn2q.
The same argument also applies to the remaining classes Cb, Cc, Cd and Ce.
9

--- Page 10 ---
Consider again the peg class C from our lemma, with its gridding matrix M. We
will show that C either contains, as a subclass, one of the classes Ca, . . . , Ce from
Figure 3 or its inverse or flip. We know that M contains at least one entry equal to
,
so let us fix one such entry Mi,j. We now let MTL, MTR, MBL and MBR denote the
submatrices of M formed be the cells strictly to the top-left, top-right, bottom-left
and bottom-right of the cell Mi,j, respectively; for instance MBL is formed by the
intersection of the leftmost i ´ 1 columns and bottommost j ´ 1 rows of M.
If both MTL and MBR contain a non-empty cell, then C contains Cb as a subclass,
so suppose this is not the case, and assume, without loss of generality, that MBR
only contains empty cells. If the grid class of MTL contains 21, then C contains Ca
and we are done, so we assume from now on that MTL generates a (possibly empty)
subclass of
. It follows that at least one of MBL and MTR must contain a nonempty
cell, otherwise C would be a subclass of R and it could not sort.
Suppose without loss of generality that MTR contains at least as many
-cells as
MBL, and in case neither MTR nor MBL contains any
-cell, suppose that MTR has
at least one nonempty cell. Let Mi`1,k be a nonempty cell in the column of M right
next to Mi,j. Note that k is at least j ` 2, since MBR only has empty cells and if
the cell Mi`1,j`1 were nonempty, we could combine it with Mi,j contradicting the
minimality of M.
Let Mℓ,j`1 be a nonempty cell of M in the row above Mi,j. If Mℓ,j`1 is inside
MTL, then C contains Cc as a subclass, so suppose that Mℓ,j`1 is inside MTR. If at
least one of the two cells Mi`1,k and Mℓ,j`1 is equal to
, then C contains either Cf
c
or pCf
c q´1 as a subclass and we are done. Suppose that this is not the case. Since C
is not a subclass of k-Fringe for any fixed k, there must be either a nonempty cell
in MTL or a cell equal to
in MTR. In the former case, C contains as a subclass
either Cc or Cf
e . In the latter case, it contains either Cd or a class symmetric to Cc as
a subclass.
In all the cases considered, we found that C contains a class symmetric to one of
Ca, . . . , Ce as a subclass, proving that wstpC; nq “ Opn2q as claimed.
Lemma 4.2 shows that a peg class that can sort has at most quadratic sorting
time. We now turn our attention to classes that can be expressed as unions of two or
more peg classes. The goal is to show that even if the individual peg classes cannot
sort, as long as their union can sort, it has at most quadratic sorting time.
Lemma 4.3. Assume that a class C is a subclass of RRYSďk for some k, but is not
a subclass of k-RFringe for any k, and that a class D is a subclass of k-RFringe
for some k, but not a subclass of RR Y Sďk for any k. Then wstpC Y D; nq “ Opn2q.
Proof. By assumption, C contains infinitely many permutations that belong to RR
but not to 0-RFringe “ Avp21q Y Avp12q. Any such permutation has the form
ιa a ιb or δa ‘ δb for some a, b ą 0. It follows that C contains as a subclass the peg
class Grid
` ‚
˘
or one of its symmetries.
Similarly, the class D contains, for some k, infinitely many permutations belonging
to k-RFringe but not to RR. From this, we easily deduce that D contains as a
subclass the peg class Grid
´
‚
‚
¯
or one of its symmetries.
10

--- Page 11 ---
We may then easily check that any permutation from the class Fn can be obtained
by composing Opnq permutations from C Y D, implying that wstpC Y D; nq “
Opn2q.
Combining the previous arguments, we reach the main result of this section.
Proposition 4.4. A class C that can sort satisfies wstpC; nq “ Opn2q.
Proof. Suppose that C can sort. If C contains a monotone juxtaposition or any
symmetry of the class F as a subclass, then its worst-case sorting time is Opnq.
Otherwise, C can be written as a union of finitely many peg classes C1, . . . , Ct, as
shown by Albert et al. and Homberger–Vatter [2, 22]. If any of the peg classes Ci can
sort, then wstpC; nq ď wstpCi; nq “ Opn2q by Lemma 4.2. Suppose then that none of
the peg classes C1, . . . , Ct can sort, and in particular, by Proposition 3.1, each Ci is
either a subclass of RR Y Sďk or a subclass of k-RFringe for some k.
If all of C1, . . . , Ct are subclasses of k-RFringe, or all of them are subclasses of
RR Y Sďk, then C cannot sort by Proposition 3.1. Otherwise there is a Ci which is
not a subclass of RR Y Sďk for any k, and a Cj which is not a subclass of k-RFringe
for any k, and by Lemma 4.3, wstpC; nq ď wstpCi Y Cj; nq “ Opn2q.
5
From quadratic to linear
Recall that T denotes the class of cyclic adjacent transpositions. To show there is a
gap between quadratic and linear worst-case sorting times, and to describe the classes
with quadratic time, we need to introduce another concept: the reduced inversion
number of a permutation π, denoted rinpπq, is the smallest integer k P N0 such that
π belongs to T ˝k ˝ RR.
The reduced inversion number rinpπq is inspired by the (better-known) inversion
number of a permutation π, which can be defined as the smallest k such that π
belongs to C˝k
Bub. Observe that the inversion number is an upper bound for the reduced
inversion number.
Lemma 5.1. For any α, β P RRn and any π P Sn, rinpα ˝ π ˝ βq “ rinpπq.
Proof. First, notice that RR ˝ T “ T ˝ RR; in other words, a permutation obtained
by composing a rotation (with optional reversal) with a cyclic transposition can also
be obtained by performing a cyclic transposition first followed by a rotation (with
optional reversal), and vice versa. It is also easy to see that RR ˝ RR “ RR, that
is, the class RR is closed under compositions.
Suppose now that we are given α, β and π as above, and let k :“ rinpπq. Let σ
be the permutation α ˝ π ˝ β. Then π belongs to T ˝k ˝ RR, and hence σ belongs to
RR ˝ T ˝k ˝ RR˝2 “ T ˝k ˝ RR. This shows that rinpσq ď rinpπq. Conversely, π is
equal to α´1 ˝ σ ˝ β´1, and since α´1 and β´1 both belong to RR, we may repeat
the above argument to show that rinpπq ď rinpσq. We conclude that rinpπq “ rinpσq,
as claimed.
Lemma 5.2. For any σ, π P Sn,
rinpπ ˝ σq ď rinpπq ` rinpσq.
11

--- Page 12 ---
Proof. Let k :“ rinpσq and ℓ:“ rinpπq. Then σ ˝ π belongs to the class T ˝k ˝ RR ˝
T ˝ℓ˝ RR “ T ˝pk`ℓq ˝ RR, hence rinpσ ˝ πq ď k ` ℓ.
For a class C and n P N, let us define rinpC; nq :“ maxtrinpσq; σ P Cnu. As
a direct consequence of Lemma 5.2, we obtain the following relationship between
sorting time and reduced inversion number.
Corollary 5.3. For any class C and any π P Sn,
stpC; πq ě
rinpπq
rinpC; nq.
To make use of this corollary, we need to show that there are permutations π P Sn
of large rinpπq.
Lemma 5.4. We have rinpS; nq “ Θpn2q.
Proof. A permutation π of length n has inversion number at most
`n
2
˘
, and hence
rinpS; nq ď
`n
2
˘
. For a lower bound, we first introduce some auxiliary notions. For
two numbers i, j P rns, we define their cyclic distance cdpi, jq by
cdpi, jq “ mint|i ´ j|, n ´ |i ´ j|u,
and for a permutation π P Sn, define its total cyclic distance tcdpπq by
tcdpπq “ cd
`
πp1q, πpnq
˘
`
n´1
ÿ
i“1
cd
`
πpiq, πpi ` 1q
˘
.
Observe that for any ρ P RR and π P Sn, both tcdpπ ˝ ρq and tcdpρ ˝ πq are equal
to tcdpπq. Observe also that for any σ P T , we have tcdpσ ˝ πq ď tcdpπq ` 4.
Consequently, given that the identity permutation ιn satisfies tcdpιnq “ n, we see
that for any π P T ˝k we have tcdpπq ď n ` 4k. Combining these observations, we
see that any π P Sn satisfies tcdpπq ď n ` 4 rinpπq.
To prove the desired lower bound rinpS, nq “ Ωpn2q, it is enough to find a
permutation π P Sn with tcdpπq “ Ωpn2q. An example can be the permutation
π “ p1, rn{2s ` 1, 2, rn{2s ` 2, 3, rn{2s ` 3, . . . q obtained by interleaving the two
sequences p1, 2, 3, . . . , rn{2sq and prn{2s ` 1, rn{2s ` 2, . . . , nq.
Combining Corollary 5.3 and Lemma 5.4, we obtain the following bound.
Corollary 5.5. For any class C,
wstpC; nq ě Ω
ˆ
n2
rinpC; nq
˙
.
For a gridding matrix M with m rows and n columns, the reversal of M, denoted
M r, is the gridding matrix obtained by replacing each individual entry C “ Mi,j
with its reversal Cr, and then reversing the order of columns of the whole matrix M;
formally, if Mi,j “ C, then M r
n´i`1,j “ Cr. Note that the permutations in the class
GridpM rq are precisely the reverses of those in GridpMq.
12

--- Page 13 ---
CIns “ Grid
¨
˝‚
˛
‚,
C1 “ Grid
¨
˝
‚
˛
‚,
C2 “ Grid
¨
˝
‚
˛
‚
Figure 4: Three classes with congruent gridding matrices, all with linear sorting time
Let M be a gridding matrix. The column rotation of M is the operation that
transforms M into the matrix M 1 of the same size, where the first column of M is
equal to the last column of M 1, and for each i ą 1 the i-th column of M is equal to the
pi´1q-th column of M 1. The row rotation of M is defined analogously. We say that a
gridding matrix M is congruent to a matrix M 1, if M can be transformed into M 1 by
a sequence of column rotations, row rotations and reversals. Note that if M and M 1
are congruent, then for any π P GridpMq there are permutations ρ, ρ1 P RR such that
ρ ˝ π ˝ ρ1 belongs to GridpM 1q. In particular, rinpGridpMq; nq “ rinpGridpM 1q; nq.
Lemma 5.6. For any peg class C, either rinpC; nq is bounded, or wstpC; nq “ Opnq.
Proof. Let C be a peg class with a gridding matrix M, and suppose that rinpC; nq is
unbounded. In particular, M contains at least one entry equal to
or to
. Let M 1
be a gridding matrix congruent to M whose top-right entry is equal to
.
Suppose that M 1 contains an entry equal to
. Then GridpM 1q contains, as a
subclass, the peg class CPan “ Grid
´
¯
, and C contains one of the symmetries of
this class. Since all the symmetries of CPan have linear worst-case sorting time, we
conclude that wstpC; nq “ Opnq.
Suppose then that M 1 does not contain
. Let M 1
i,j be an entry of M 1 equal to
.
If M 1 contains a nonempty entry strictly to the left and above M 1
i,j, then GridpM 1q
contains CIns as a subclass. It follows that C contains as a subclass one of the three
classes from Figure 4 or one its symmetries. Noting that CIns Ď C˝2
1 and CIns Ď C˝2
2 ,
and applying Observation 2.3 if needed, we easily conclude that wstpC; nq “ Opnq.
An analogous argument applies when M 1 has a nonzero entry to the right and
below M 1
i,j.
Finally, suppose that no entry of M 1 equal to
has any nonzero entry to the left
and above, or to the right and below of itself. It follows that all the entries of M 1
equal to
appear on the main diagonal, and M 1 is a block-diagonal matrix whose
every block consists either of a single entry
, or a submatrix that has no entry
equal to
. It then easily follows that rinpGridpM 1q; nq is bounded, and rinpC; nq is
bounded as well.
Proposition 5.7. For a class C, the following are equivalent:
1. wstpC; nq “ opn2q,
2. wstpC; nq “ Opnq, and
3. rinpC; nq is unbounded as n Ñ 8.
13

--- Page 14 ---
Proof. By Corollary 5.5, if rinpC; nq is bounded then wstpC; nq “ Ωpn2q. This shows
the implication 1 ùñ 3.
To prove 3 ùñ 2, suppose now that rinpC; nq is unbounded for a class C. If
C contains as a subclass a monotone juxtaposition or its inverse or if it contains
the Fibonacci class F or its reverse, then clearly wstpC; nq “ Opnq. On the other
hand, if C contains no such subclass, then it can be expressed as a union of finitely
many peg classes C1, . . . , Ck. Since rinpC; nq is unbounded, there must be an i P rks
such that rinpCi; nq is unbounded. By Lemma 5.6, wstpCi; nq “ Opnq, and therefore
wstpC; nq “ Opnq. This proves the implication 3 ùñ 2.
The implication 2 ùñ 1 is trivial.
6
From Ωp?nq to polylog
The most difficult part of our argument deals with the gap between sorting times
Oplog2 nq and Ωp?nq. The criterion distinguishing the two types of classes is rather
simple to state, though. For ease of notation, let X be the set of permutation classes
that contains the eight monotone juxtapositions and the four classes L, Lr, PBT
and PBT r. We say that a permutation class C is X-avoiding if it does not contain
any class from X as a subclass, otherwise we say that it is X-containing.
Theorem 6.1. Any X-avoiding class C satisfies wstpC; nq “ Ωp?nq, while any
X-containing class C satisfies wstpC; nq “ Oplog2 nq.
The rest of this section is devoted to a detailed proof of Theorem 6.1. We first
focus on showing that every X-avoiding class C satisfies wstpC; nq “ Ωp?nq.
An inversion in a permutation π is a decreasing subsequence of length 2, i.e., a
pair pπpiq, πpjqq such that i ă j and πpiq ą πpjq. The first ingredient in the proof of
Theorem 6.1 is a structural result characterizing permutation classes admitting a
linear bound on the number of inversions.
Proposition 6.2. For a permutation class C, the following statements are equivalent:
1. Neither R nor
is a subclass of C.
2. There is a k P N such that every permutation in C avoids both δk and ιk a ιk.
3. There is a Q P N such that every permutation π P C of size n has at most Qn
inversions.
Proof. The implication 3 ñ 1 is clear, since both
and R contain permutations of
size n with Ωpn2q inversions, namely δn and ιtn{2u a ιrn{2s. Likewise, the implication
1 ñ 2 follows directly from the fact that any permutation in R is a subpermutation
of ιk a ιk for some k.
It remains to prove 2 ñ 3. Fix k such that every permutation of C avoids both
δk and ιk a ιk, and let π be a permutation of size n in C. Since π avoids δk, it can be
partitioned into k ´ 1 increasing subsequences I1, . . . , Ik´1. We will show that π has
at most pk ´ 1q3n inversions.
Suppose that pπpiq, πpjqq is an inversion, that is, i ă j and πpiq ą πpjq. We say
that the inversion has type pa, bq if πpiq belongs to Ia and πpjq belongs to Ib. Note
14

--- Page 15 ---
that this implies a ‰ b. We will show that for any pa, bq P rk ´ 1s ˆ rk ´ 1s there are
at most pk ´ 1qn inversions of type pa, bq. To this end, we define a graph Ga,b on
the vertex set Ia Y Ib whose edges are the pairs of vertices that form an inversion of
type pa, bq. We claim that the graph Ga,b is pk ´ 1q-degenerate, that is, each of its
nonempty subgraphs has a vertex of degree at most k ´ 1.
Suppose for contradiction that Ga,b has a nonempty subgraph G1 whose every
vertex has degree at least k. The vertex set of G1 has the form I1
a Y I1
b for some
I1
a Ď Ia and I1
b Ď Ib. Let x1 be the rightmost vertex in I1
a, and let Npx1q be the
vertices of I1
b adjacent to x1. By assumption, |Npx1q| ě k. Let y1 be the rightmost
(and therefore also topmost) vertex in Npx1q, and let Npy1q Ď I1
a be its neighbors.
Since any vertex in Npx1q is to the right of x1, it follows that any vertex in Npx1q is
to the right of all the vertices in Npy1q (recall that x1 is the rightmost vertex of I1
a).
Moreover, since y1 is topmost in Npx1q, all the vertices of Npx1q are below all the
vertices in Npy1q. It follows that the set Npx1q Y Npy1q induces in π a permutation
containing ιk a ιk, which is a contradiction.
We conclude that the graph Ga,b is pk´1q-degenerate for any pa, bq P rk´1sˆrk´1s,
and therefore has at most pk ´ 1qp|Ia| ` |Ib|q ď pk ´ 1qn edges. Summing over all
values of a and b, we conclude that π has at most pk ´ 1q3n inversions.
The key part in the proof of Theorem 6.1 is a structural characterization of
X-avoiding classes. To state it, we need to introduce some terminology.
An integer interval (or just interval, if there is no risk of confusion) is a finite
set of consecutive positive integers, i.e., a set of the form ti P N; a ď i ď bu for some
a, b P N. For a finite set X Ď N, its intervalicity, denoted IntpXq, is the smallest
k P N0 such that X can be expressed as a union of k integer intervals. For a finite
point set P Ď N ˆ N, we let P|x and P|y denote its projections to the x-axis and to
the y-axis, respectively. The intervalicity of the point set P, denoted again IntpPq,
is the maximum of IntpP|xq and IntpP|yq.
Proposition 6.3. For every X-avoiding class C there is a constant K ” KpCq, such
that every π P C admits a gridding with at most K rows and K columns such that
for every cell X of the gridding, the following holds:
1. the point set πrXs has intervalicity at most K,
2. the permutation induced by πrXs avoids at least one of ιK and δK,
3. the permutation induced by πrXs avoids both ιK a ιK and δK ‘ δK, and
4. if nX is the number of elements in πrXs, then either πrXs or its reverse has
at most K ¨ nX inversions.
Before we prove the proposition, let us collect several known facts about permu-
tation classes.
Fact 6.4 (Vatter [29, Corollary 5]). For every permutation class C that does not con-
tain L or Lr as a subclass, there is a constant K “ K6.4 such that every permutation
π P C is a union of at most K monotone subsequences.
15

--- Page 16 ---
Fact 6.5 (Vatter [28, Theorem 3.1]). Let C be a permutation class, and let α be a
permutation. The following two statements are equivalent:
• There is a constant K “ K6.5 such that every permutation in C has a gridding
of size K ˆ K in which every cell induces a permutation that avoids α.
• There is a constant Q such that neither ÀQ α nor ÁQ α belongs to C.
A horizontal alternation is a permutation in which all the odd values appear to
the left of all the even values or vice versa. A vertical alternation is an inverse of a
horizontal alternation. An alternation is a horizontal or vertical alternation.
Fact 6.6 (Huczynska–Vatter [23, Proposition 3.2]). For a permutation class C
that does not contain any monotone juxtaposition as a subclass there is a constant
K “ K6.6 such that C does not contain any alternation of size K.
Proof of Proposition 6.3. Let C be an X-avoiding class, and fix π P C.
By Fact 6.6, there is a constant K6.6 such that C does not contain any alternation
of size K6.6 or more. We claim that this implies that in any gridding of π, every cell
has intervalicity less than K6.6. To see this, suppose for contradiction that there
is a cell X such that the projection of πrXs on the horizontal or vertical axis has
intervalicity at least K6.6. Without loss of generality, suppose that the projection
is onto the horizontal axis, let ℓě K6.6 be its intervalicity, and let P1, P2, . . . , Pℓbe
the intervals, numbered left to right, whose union is the projection of πrXs. For any
i P rℓ´ 1s, fix an integer ji such that max Pi ă ji ă min Pi`1. Since πpjiq is not in
πrXs, it is either smaller than all the values in πrXs or larger than all the values
in πrXs. Without loss of generality, there are at least pℓ´ 1q{2 values of i P rℓ´ 1s
for which πpjiq is larger than all the values in πrXs. We can then choose at least
pℓ` 1q{2 values in πrXs which form a vertical alternation with these pℓ´ 1q{2 ‘large’
values πpjiq, showing that π has an alternation of size ℓě K6.6, which is impossible.
Thus, in any gridding of π, every cell has intervalicity less than K6.6.
By Fact 6.4, there is a constant K6.4 such that every permutation of C is a union
of at most K6.4 monotone sequences. Let us therefore fix such a partition of π into
monotone sequences, and suppose that the partition contains p increasing sequences
I1, . . . , Ip and q decreasing sequences D1, . . . , Dq, for some p ` q ď K6.4. Define
IY “ Ťp
i“1 Ii and DY “ Ťq
i“1 Di. Notice that IY avoids δp`1 and DY avoids ιq`1.
We will now show that π has a gridding with bounded number of cells in which
each cell is either disjoint from IY or disjoint from DY. For any choice of i P rps
and j P rqs, we can easily construct a 2 ˆ 2 gridding of π such that the increasing
subsequence Ii intersects neither the top-left nor the bottom-right cell, while Dj
intersects neither the bottom-left nor the top-right cells. Combining such griddings for
all the choices of pi, jq P rpsˆrqs, we obtain a single gridding of size ppq`1qˆppq`1q
in which every cell avoids either IY or DY, and in particular, every cell avoids ιq`1
or δp`1.
For the next step, we note that there are constants A, B such that neither
ÀApιB a ιBq nor ÁApιB a ιBq belongs to C. Indeed, if C contained ÀApιB a ιBq
for each A and B, then C would contain PBT as a subclass, and if C contained
ÁApιB aιBq for all A, B, then C would contain Lr as a subclass. By Fact 6.5 applied
16

--- Page 17 ---
to α “ ιB a ιB, we can refine the gridding of π obtained in the previous step by
adding at most K6.5 rows and columns to obtain a gridding in which no cell contains
ιB a ιB. By a symmetric argument, another round of refinement ensures that no cell
of the gridding contains δB ‘ δB for a constant B.
Invoking Proposition 6.2 (or its symmetric version) to each cell of the resulting
gridding, and choosing K large enough in terms of the constants appearing in the
previous arguments, we conclude that the gridding obtained by this procedure has
all the properties from the statement of the proposition.
For a permutation π, the adjacency graph Gpπq is a graph whose vertices are
the elements of π, and two vertices are connected by an edge if and only if the
corresponding two elements have adjacent positions or adjacent values. In particular,
the adjacency graph is a union of two paths, one visiting the vertices in left-to-right
order, and the other in bottom-to-top order.
The tree-width of the permutation π, denoted twpπq, is then defined as the
tree-width of Gpπq. Note that there are permutations of size n with tree-width
Ωpnq [1].
Now, we introduce the concept of sorting diagram, which will offer a convenient
way to represent a sequence of steps performed during the sorting of a sequence. Let
t and n be positive integers, and let ⃗σ “ pσ1, σ2, . . . , σtq be a t-tuple of permutations
of rns. Define the permutation π “ σt ˝ σt´1 ˝ ¨ ¨ ¨ ˝ σ2 ˝ σ1. In particular, by applying
the steps σ1, . . . , σt in this order, we would sort the sequence π´1 into an increasing
sequence.
Let P be the set rpt ` 1qns ˆ rpt ` 1qns, viewed as an integer grid in the plane.
We partition P into blocks of size n ˆ n as follows: for a, b P rt ` 1s, let Pa,b be the
set tpi, jq P P; pa ´ 1qn ă i ď an ^ pb ´ 1qn ă j ď bnu. For a permutation σ P Sn,
let Pa,brσs denote the set of n points forming a translated copy of the diagram of σ
inside the block Pa,b; formally,
Pa,brσs “
␣`
pa ´ 1qn ` i, pb ´ 1qn ` σpiq
˘
; i P rns
(
.
We are now ready to describe the sorting diagram of the t-tuple of permutations
⃗σ “ pσ1, σ2, . . . , σtq; refer to Figure 5. Recall that ιn is the increasing permutation
p1, 2, . . . , nq. The sorting diagram of the t-tuple ⃗σ “ pσ1, . . . , σtq, denoted SD ”
SDp⃗σq, is the graph whose vertex set is the point set
V pSDq “
t`1
ď
i“1
Pt`2´i,irιns Y
tď
i“1
Pt`2´i,i`1rσis.
In particular, the vertex set consists of t ` 1 copies of the diagram of ιn inside the
blocks forming the decreasing diagonal of P, together with the copies of the diagrams
of σ1, . . . , σt, appearing right-to-left inside the blocks just above the decreasing
diagonal. We refer to the n vertices inside the bottom-right block Pt`1,1 as starting
vertices, and we label them s1, . . . , sn in left-to-right order. Similarly, the vertices
inside the top-left block P1,t`1 are the terminal vertices, and are labelled t1, . . . , tn in
left-to-right order. The edge set of SD is determined as follows:
17

--- Page 18 ---
Figure 5: The sorting diagram of the triple of permutations σ1 “ 2413, σ2 “
3214, σ3 “ 3412.
• Any two vertices of V pSDq that lie on the same horizontal line are connected
by an edge. We call these edges horizontal edges. Note that every vertex is
incident to a unique horizontal edge, except for the n starting vertices.
• Any two vertices of V pSDq that lie on the same vertical line are connected by
an edge. We call these edges vertical edges. Note that every vertex is incident
to a unique vertical edge, except for the n terminal vertices. Note also that
the horizontal and vertical edges together form n vertex-disjoint paths, each
connecting a starting vertex to a distinct terminal vertex, with the vertex si
being connected to tπpiq, where π “ σt ˝ ¨ ¨ ¨ ˝ σ1.
• Finally, for any i P rn ´ 1s, the vertex si is connected to si`1 and ti to ti`1. We
call these edges as the diagonal edges.
This completes the description of the graph SD.
Lemma 6.7. For a t-tuple of permutations ⃗σ “ pσ1, . . . , σtq and their composition
π “ σt˝¨ ¨ ¨˝σ1, the tree-width of the graph SDp⃗σq is at least as large as the tree-width
of the incidence graph Gpπq of π.
Proof. The graph Gpπq is a minor of SDp⃗σq, since by contracting all the horizontal
and vertical edges in SDp⃗σq, we obtain precisely the graph Gpπq. The lemma follows,
since tree-width is minor-monotone.
Proposition 6.8. Let C be an X-avoiding class. There are constants Q and R, such
that for any t P N, any n P N, and any t-tuple ⃗σ “ pσ1, . . . , σtq of permutations from
Cn, the sorting diagram SDp⃗σq can be drawn on a surface of genus at most Q ¨ t with
at most R ¨ t ¨ n edge-crossings.
18

--- Page 19 ---
Di
Di+1
Si
Figure 6: A fragment of a sorting diagram, induced by three consecutive blocks Di,
Si and Di`1. The light gray rectangle is a cell of the gridding of σi. The four dark
gray rectangles represent the two horizontal and two vertical handles attached to
this cell.
Proof. The definition of the graph SD “ SDp⃗σq already implies a drawing in the
plane, where vertices are points and edges are straight-line segments. Unfortunately,
such a drawing may have too many edge-crossings. Our strategy is to insert handles
and cross-caps into this drawing, so that we eliminate enough of the crossings, without
increasing the genus of the surface too much.
Recall from the definition of sorting diagram that the vertices of SD are organized
into 2t ` 1 square blocks, which include t ` 1 diagonal blocks Pt`1,1, Pt,2, . . . , P1,t`1,
as well as t blocks right above the diagonal, namely Pt`1,2, Pt,3, . . . , P2,t`1. For ease
of notation, for i P rt ` 1s let Di refer to the diagonal block Pt`2´i,i, and for i P rts
let Si refer to the block right above Di, i.e., Pt`2´i,i`1. The vertices of SD induce a
copy of ιn inside every Di, and a copy of σi inside Si.
In the straight-line drawing of SD, the only edge-crossings that occur are inside
the blocks Si, between a vertical edge connecting a vertex x from Di to a vertex
y in Si, and a horizontal edge connecting a vertex x1 in Si to a vertex y1 in Di`1.
Notice that such a pair of edges has a crossing if and only if py, x1q corresponds to a
decreasing subsequence of σi. We will now modify the drawing of edges (and the
surface they are drawn upon) inside each block Si for i P rts, while the parts of the
drawing inside the Di’s are unaffected.
Fix i P rts. Let K “ KpCq be the constant from Proposition 6.3. As the first
step, apply to the copy of σi inside Si the gridding described by Proposition 6.3. We
will now add handles to our surface, and route the edges along these handles, to
ensure that no two edges cross, unless they have endpoint inside the same cell of the
gridding. Refer to Figure 6.
Let X be a cell of the gridding of σi. By Proposition 6.3, σirXs has intervalicity
at most K. In particular, there are K disjoint intervals I1, . . . , IK (some possibly
empty) such that a vertical edge from Di to Si has an endpoint in X if and only
if its projection to the x-axis is a point from I1 Y I2 Y ¨ ¨ ¨ Y IK. For each j P rKs
such that Ij ‰ H, we attach a new handle H|
j to our surface, oriented vertically,
whose bottom end is near the bottom edge of Si, the top end is near the bottom
edge of X, and its horizontal position corresponds to the interval Ij (in case X is in
the bottom row of the gridding, we omit these handles and leave the vertical edges
19

--- Page 20 ---
p1
p2
p3
e1
e2
e3
p1
p2
p3
e1
e2
e3
Figure 7: A modification of horizontal edges inside a cell X of the gridding of σi.
The gray rectangles represent the handles adjacent to X, and the circle near the top
boundary of the modified drawing represents a cross-cap.
into X unchanged). All the vertical edges whose projection on the x-axis lies in Ij
are then routed through H|
j, from the point when they cross the boundary from Di
to Si, till the point when they reach the bottom of edge of the cell X. This way,
we remove any crossing between a vertical edge incident with a point in X and a
horizontal edge incident with a cell X1 in the gridding which lies below X.
We perform an analogous operation with the horizontal edges. Again, for a cell
X, the projection of σirXs on the y-axis forms K intervals J1, . . . , JK, and for each
such nonempty interval Jℓwe attach a horizontal handle H´
ℓ, whose left endpoint is
near the boundary between Si and Di`1 and its right endpoint is near the left edge
of X; if X is in the leftmost column of the gridding, these handles are omitted. The
horizontal edges projecting into Jℓare then routed through the handle H´
ℓ.
For each i P rts, this operation adds at most K vertical and K horizontal handles
incident to any given cell X of the gridding of σi, so at most 2K3t handles overall.
After these handles are added, a vertical edge from Di to Si may cross a horizontal
edge from Si to Di`1 only if their endpoints inside Si belong to the same cell of the
gridding of σi. Unfortunately, there may still be too many such edge-crossings, and
so we may need to perform additional modifications inside a cell X to reduce the
number of crossings. The goal is for the number of crossings inside X to be linear in
the size of σirXs.
Consider again a cell X of the gridding of σi, and let nX be the size of σirXs.
Observe that at this point, the number of edge-crossings inside X is equal to the
number of decreasing subsequences of length 2 in σirXs. By Proposition 6.3, σirXs
contains either at most K ¨nX decreasing subsequences of length 2, or at most K ¨nX
increasing subsequences of length 2. In the former case, we do not need to modify
the drawing of the edges incident to X any further. Consider now that the second
situation occurs; refer to Figure 7.
Let p1, . . . , pnX be the points of σirXs, numbered bottom to top, and let ej be
the horizontal edge incident to pj. We will modify the drawings of all the horizontal
edges inside X as follows: the edge ej, instead of heading straight to the left from
pj towards the horizontal handle leading to Di`1, will instead head straight to the
right from pj, until it reaches close to the right edge of X, then it will turn upwards,
follow the right edge towards the top-right corner of X, then turn left and follow
the top edge of X. All the horizontal edges will perform this ‘U-turn’, keeping their
20

--- Page 21 ---
mutual positions so that they do not introduce any mutual crossings. In particular,
as the edges reach the top edge of X and head to the left, the edge e1 will be the
topmost, followed by e2, e3 etc. However, we need the edges to reach the handles in
the opposite bottom-to-top order. To fix this, we attach a cross-cap near the top
edge of X and let all the edges ei pass through it. This reverses their bottom-to-top
order, and it is easy to then extend the edges along the top and left edge of X
towards their designated handles, without introducing any new crossings. After this
modification, an edge ej crosses a vertical edge incident to a vertex pk if and only if
ppj, pkq form an increasing subsequence of length 2 in σirXs. In particular, there are
now at most K ¨ nX crossings inside X.
In the end, we obtain a drawing of SDp⃗σq on a surface with at most 2K3t handles
and at most K2t cross-caps, and in particular, the genus of the surface is at most
p4K3 ` K2qt. Each block Si contains at most Kn edge-crossings, so there are at
most Knt edge-crossings overall.
Our next tool is an inequality that relates the genus, the crossing number and
the tree-width of a graph. Its proof is based an idea of Dujmović, Eppstein and
Wood [15].
Proposition 6.9. Every graph on n vertices that can be drawn on a surface of genus
g with at most x edge-crossings has treewidth O
´a
pg ` 1qpn ` xq
¯
.
Proof. Suppose a graph G on n vertices has been drawn on a surface of genus g with
x edge-crossings. Let us orient the edges of G arbitrarily, so that each edge e has
a designated tail te and head he. Next, let us replace each edge-crossing by a new
vertex, thereby obtaining a crossing-free drawing of a new graph H with nH “ n ` x
vertices. Since H can be drawn on a surface of genus g, it has treewidth at most
Op?g ¨ nHq “ Op
a
gpn ` xqq [16, 20]. Let us fix an optimal tree decomposition
pTH, βHq of the graph H, where TH is the corresponding decomposition tree, and
βH : V pTHq Ñ 2V pHq is the function that assigns to each node q of TH a bag βpqq of
vertices of H of size at most Op
a
gpn ` xqq.
We now modify this decomposition to a tree decomposition of G, as follows. Let
w be any vertex of H that is not a vertex of G. This means that in the original
drawing of G, w corresponded to a crossing of a pair of edges e and f. Let te and tf
be the tails of the two edges. We modify the decomposition pTH, βq by replacing any
occurrence of the vertex w in any of the bags by the two vertices te and tf. After we
perform these replacements for every vertex w P V pHqzV pGq, we may easily check
that we obtain a tree decomposition of G of width at most twice as large as the
width of pTH, βq (see Dujmović et al. [15] for details).
We now have all the ingredients to prove the harder part of Theorem 6.1.
Proposition 6.10. Any X-avoiding class C has wstpC; nq “ Ωp?nq.
Proof. Let π P Sn be a permutation of tree-width Ωpnq (such permutations exist by
a result of Ahal and Rabinovich [1, Theorem 3.4 and Proposition 3.6]). Let us put
t :“ stpC; πq, and let ⃗σ “ pσ1, . . . , σtq be a t-tuple of permutations from C such that
π “ σt ˝ σt´1 ˝ ¨ ¨ ¨ ˝ σ1.
21

--- Page 22 ---
Consider the sorting diagram SD “ SDp⃗σq. By Lemma 6.7, twpSDq ě twpπq “
Ωpnq. On the other hand, SD has p2t ` 1qn vertices, and by Proposition 6.8, it
can be drawn on a surface of genus Optq with Optnq edge-crossings. Therefore, by
Proposition 6.9, SD has tree-width Opt?nq. Combining these bounds, we conclude
that
wstpC; nq ě stpC; πq “ t “ Ωp?nq,
proving the proposition.
To complete the proof of Theorem 6.1, we now turn to upper bounds.
Proposition 6.11. Any X-containing class C has wstpC; nq “ Oplog2 nq.
Proof. It is clearly enough to prove the proposition for a class C that belongs to X.
Let us first consider the monotone juxtapositions, starting with C1 “ Grid
´
¯
. We
may easily observe that wstpC1; nq “ Oplog nq, e.g., by considering the elements of
rns as binary strings of length Oplog nq and sort them using radix-sort, which can be
performed by Oplog nq operations of C1.
With the help of Observation 2.3, we conclude that also the classes Cr
1, C´1
1 , and
pCr
1q´1 have worst-case sorting time Oplog nq.
Consider now the class C2 “ Grid
´
¯
. Notice that C1 Ď C˝2
2 , which implies
wstpC2; nq “ Oplog nq via Observation 2.2. Again, the same bound applies to all
the four symmetries of C2, showing that all the eight monotone juxtapositions have
worst-case sorting time Oplog nq.
We now deal with the four classes L, Lr, PBT and PBT r. Noting that PBT Ď
L˝2, it is enough to prove that wstpPBT ; nq “ Oplog2 nq, and invoke Observations 2.2
and 2.3 to see that the same upper bound applies to the other three classes as well.
Composing a sequence π with a permutation σ P PBT corresponds to parti-
tioning π into an even number of blocks B1B2B3B4 ¨ ¨ ¨ B2k´1B2k, each block being
a (possibly empty) subsequence of consecutive entries of π, and then exchanging
the position of B2j´1 and B2j for each j P rks.
For instance, the permutation
π “ p3, 8, 1, 6, 2, 5, 9, 4, 7q P S9 can be partitioned as B1 “ p3, 8q, B2 “ p1q, B3 “ H,
B4 “ p6, 2q, B5 “ p5, 9, 4q and B6 “ p7q, which after exchanging adjacent odd and
even blocks yields the permutation B2B1B4B3B6B5 “ p1, 3, 8, 6, 2, 7, 5, 9, 4q, which
is equal to σ ˝ π for σ “ p3, 1, 2, 4, 5, 9, 6, 7, 8q P PBT 9.
We now describe a strategy to sort an arbitrary π P Sn by Oplog2 nq steps of the
form described above. We say that an entry πpiq is small if πpiq ď n{2, otherwise it
is large. We will use a divide-and-conquer approach, where in the initial phase, which
will take Oplog nq steps, we move all the small entries to the left of all the large ones,
and then proceed recursively to separately and concurrently sort the small entries
and the large ones.
In the initial phase, in every step we first partition the current input sequence
π1 into small runs and large runs, where a small run is a maximal sequence of
consecutive small values, and a large run is defined similarly. Suppose π1 starts
with a small element, the other case being analogous. It is then partitioned as
S1L1S2L2 ¨ ¨ ¨ SkLk, where each Sj is a small run and Lj a large run, with Lk possibly
empty. Then in a single sorting step, for every even j P rks we exchange the positions
22

--- Page 23 ---
of the Lj´1 and Sj, leaving all the other runs unaffected. In this manner, Sj becomes
adjacent to Sj´1 and Lj (if it exists) to Lj´1. Thus, every small and large run will
merge with another run of the same type, except perhaps the rightmost small run
and the rightmost large run. In Oplog nq steps, we reach a permutation with only a
single small run and a single large run, which can be swapped to ensure that the
small run is to the left of the large one.
We then recursively apply the same strategy to concurrently sort the tn{2u
small elements and the rn{2s large ones. In Oplog2 nq steps, the entire sequence is
sorted.
Propositions 6.10 and 6.11 together prove Theorem 6.1.
We remark that sorting by layered permutations corresponds to sorting by a
sequence of pop-stacks in “genuine series”, which has been considered (for two
pop-stacks) by Atkinson and Stitt [5].
We also note that sorting by layered permutations is related to the setting of
sorting by length-weighted reversals with linear weights, considered by Bender et
al. [8]. More precisely, a single step of sorting by layered permutations can be
simulated by a sequence of length-weighted reversals of total cost Opnq in the linear-
weight setting of [8], and in particular, an improvement to the Oplog2 nq upper bound
for wstpL; nq would also improve the bounds in [8].
7
From Ωplog nq to 1
A simple counting argument, combined with the famous Marcus–Tardos theorem [26]
shows that any proper permutation class C, i.e., a class C not containing all permu-
tations, has at least logarithmic worst-case sorting time.
Proposition 7.1. If C is a permutation class that does not contain all permutations,
then wstpC; nq “ Ωplog nq.
Proof. By the Marcus–Tardos theorem, there is a constant c ą 0 such that |Cn| ď cn
for all n. Consequently, |C˝k
n | ď ckn for any k ě 1. Taking k :“ wstpC; nq yields
n! “ |Sn| “
ˇˇˇˇˇ
kď
m“1
C˝m
n
ˇˇˇˇˇ ď
kÿ
m“1
|C˝m
n | ď kckn,
which implies k “ Ωplog nq.
Obviously, if C is the class of all permutations, then wstpC; nq “ 1 for all n ě 2.
This completes the proof of Theorem 1.1.
8
Conclusion and open problems
The two main open problems concern the two levels of our hierarchy where we do
not have matching upper and lower bounds. Recall that the set X contains the eight
monotone juxtapositions, the class L of layered permutations, its reverse Lr, the
class PBT of parallel block transpositions, and its reversal PBT r. We know that
23

--- Page 24 ---
for any monotone juxtaposition, the worst-case sorting time is Θplog nq, but for L,
PBT and their symmetries, we only have a lower bound of order Ωplog nq and an
upper bound of order Oplog2 nq.
Note that Observations 2.2 and 2.3 imply that wstpL; nq “ ΘpwstpLr; nqq,
wstpPBT ; nq “ ΘpwstpPBT r; nqq, and wstpL; nq “ OpwstpPBT ; nqq. We can there-
fore restrict our attention to L and PBT .
Problem 8.1. What is the worst-case sorting time of the class L of layered permu-
tations, and of the class PBT of parallel block transpositions?
Another gap in our bounds concerns the broad family of X-avoiding classes.
We proved that any X-avoiding class has worst-case sorting time of order Ωp?nq.
However, every example of such a class that we know of has worst-case sorting time
of order Ωpnq, suggesting that the lower bound can be further improved.
Problem 8.2. Is there an X-avoiding class C with wstpC; nq “ opnq?
References
[1] S. Ahal and Y. Rabinovich.
On complexity of the subpattern problem.
SIAM Journal on Discrete Mathematics, 22(2):629–649, 2008. doi:10.1137/
S0895480104444776.
[2] M. H. Albert, M. D. Atkinson, M. Bouvel, N. Ruškuc, and V. Vatter. Geometric
grid classes of permutations. Trans. Amer. Math. Soc., 365(11):5859–5881, 2013.
doi:10.1090/S0002-9947-2013-05804-7.
[3] M. H. Albert, C. Homberger, J. Pantone, N. Shar, and V. Vatter. Generating
permutations with restricted containers. Journal of Combinatorial Theory,
Series A, 157:205–232, 2018. doi:10.1016/j.jcta.2018.02.006.
[4] M. D. Atkinson and R. Beals. Permutation involvement and groups. Q. J.
Math., 52(4):415–421, 2001. doi:10.1093/qjmath/52.4.415.
[5] M. D. Atkinson and T. Stitt. Restricted permutations and the wreath product.
Discrete Math., 259(1-3):19–36, 2002. doi:10.1016/S0012-365X(02)00443-0.
[6] L. Babai and Ákos Seress. On the diameter of Cayley graphs of the symmetric
group. Journal of Combinatorial Theory, Series A, 49(1):175–179, 1988. doi:
10.1016/0097-3165(88)90033-7.
[7] V. Bafna and P. A. Pevzner. Genome rearrangements and sorting by reversals.
In 34th Annual Symposium on Foundations of Computer Science (Palo Alto,
CA, 1993), pages 148–157. IEEE Comput. Soc. Press, Los Alamitos, CA, 1993.
doi:10.1109/SFCS.1993.366872.
[8] M. A. Bender, D. Ge, S. He, H. Hu, R. Y. Pinter, S. Skiena, and F. Swidan.
Improved bounds on sorting by length-weighted reversals. J. Comput. System
Sci., 74(5):744–774, 2008. doi:10.1016/j.jcss.2007.08.008.
24

--- Page 25 ---
[9] S. Bhatia, P. Feijão, and A. R. Francis. Position and content paradigms in
genome rearrangements: the wild and crazy world of permutations in genomics.
Bull. Math. Biol., 80(12):3227–3246, 2018. doi:10.1007/s11538-018-0514-3.
[10] M. Bóna. A survey of stack-sorting disciplines. Electron. J. Combin., 9(2):Article
1, 16, 2002/03. Permutation patterns (Otago, 2003). doi:10.37236/1693.
[11] L. Bulteau, G. Fertin, and I. Rusu. Pancake flipping is hard. J. Comput. System
Sci., 81(8):1556–1574, 2015. doi:10.1016/j.jcss.2015.02.003.
[12] G. Cerbai, A. Claesson, and L. Ferrari. Stack sorting with restricted stacks.
J. Combin. Theory Ser. A, 173:105230, 19, 2020. doi:10.1016/j.jcta.2020.
105230.
[13] G. Cerbai, A. Claesson, L. Ferrari, and E. Steingrímsson. Sorting with pattern-
avoiding stacks: the 132-machine. Electron. J. Combin., 27(3):Paper No. 3.32,
27, 2020. doi:10.37236/9642.
[14] G. Cerbai and L. Ferrari.
Permutation patterns in genome rearrangement
problems: The reversal model. Discrete Applied Mathematics, 279:34–48, 2020.
doi:10.1016/j.dam.2019.10.012.
[15] V. Dujmović, D. Eppstein, and D. R. Wood. Structure of graphs with locally
restricted crossings. SIAM J. Discrete Math., 31(2):805–824, 2017. doi:10.
1137/16M1062879.
[16] Z. Dvořák and S. Norin. Treewidth of graphs with balanced separations. Journal
of Combinatorial Theory, Series B, 137:137–144, 2019. doi:10.1016/j.jctb.
2018.12.007.
[17] A. Elvey Price and A. J. Guttmann. Permutations sortable by two stacks in
series. Advances in Applied Mathematics, 83:81–96, 2017. doi:10.1016/j.aam.
2016.09.003.
[18] G. Fertin, A. Labarre, I. Rusu, E. Tannier, and S. Vialette. Combinatorics
of genome rearrangements.
Computational Molecular Biology. MIT Press,
Cambridge, MA, 2009. doi:10.7551/mitpress/9780262062824.001.0001.
[19] W. H. Gates and C. H. Papadimitriou. Bounds for sorting by prefix reversal.
Discrete Math., 27(1):47–57, 1979. doi:10.1016/0012-365X(79)90068-2.
[20] J. R. Gilbert, J. P. Hutchinson, and R. E. Tarjan. A separator theorem for
graphs of bounded genus. Journal of Algorithms, 5(3):391–407, 1984. doi:
10.1016/0196-6774(84)90019-1.
[21] N. Habermann. Parallel neighbor-sort (or the glory of the induction principle).
Technical Report, 1972.
[22] C. Homberger and V. Vatter. On the effective and automatic enumeration of
polynomial permutation classes. J. Symbolic Comput., 76:84–96, 2016. doi:
10.1016/j.jsc.2015.11.019.
25

--- Page 26 ---
[23] S. Huczynska and V. Vatter. Grid classes and the Fibonacci dichotomy for
restricted permutations. Electron. J. Combin., 13(1):Research Paper 54, 14,
2006. doi:10.37236/1080.
[24] J. Kececioglu and D. Sankoff. Exact and approximation algorithms for sorting
by reversals, with application to genome rearrangement. Algorithmica, 13(1-
2):180–210, 1995. doi:10.1007/BF01188586.
[25] D. E. Knuth. The Art of Computer Programming, Volume I: Fundamental
Algorithms. Addison-Wesley, 1968.
[26] A. Marcus and G. Tardos. Excluded permutation matrices and the Stanley-Wilf
conjecture. J. Combin. Theory Ser. A, 107(1):153–160, 2004. doi:10.1016/j.
jcta.2004.04.002.
[27] R. Tarjan. Sorting using networks of queues and stacks. J. Assoc. Comput.
Mach., 19:341–346, 1972. doi:10.1145/321694.321704.
[28] V. Vatter. Small permutation classes. Proc. Lond. Math. Soc. (3), 103(5):879–
921, 2011. doi:10.1112/plms/pdr017.
[29] V. Vatter. An Erdős-Hajnal analogue for permutation classes. Discrete Math.
Theor. Comput. Sci., 18(2):Paper No. 4, 5, 2016. doi:10.46298/dmtcs.1328.
26


=== round-0004/verifier.feedback.md ===
Overall assessment: both reports contain useful and largely correct ideas; Prover 02’s two lemmas are clean, correct, and directly curatable. Prover 01’s main structural inequality (the small-scale fractional bound at A0 using the 2-adic weights) is also essentially correct, but two technical slips need correction, and the claimed layer-cake bound has a wrong logarithmic dependence.

Specific audits and corrections
- Small-scale fractional bound (01): The derivation using toggle-locality and the weighted dyadic identity at A0 is sound with weights a_j=(1/L)·1_{L_j<L}·2^{-(j+1)}. However, when moving to the inner sum over j for a fixed i, the indicator 1_{L_j<L} was dropped as “=” instead of “≤”. The correct chain is Σ_{j: L_j<L} Decrease_j/B_j(A0) ≤ (1/L) Σ_{i∈S} Σ_{j: i∈G_j, L_j<L} 2^{-(j+1)} ≤ (1/L) Σ_{i∈S} Σ_{j: i∈G_j} 2^{-(j+1)} = (2/(nL)) Σ_{i∈S} 2^{v_2(i)}. This yields the claimed (2/(nL)) multiplier.
- 2-adic layer-cake bound (01): The counting trick is fine, but the final estimate should scale like n·(1+log m), not n·(1+log(n/m)). Indeed, with |S|≤3m and letting N=n−1, one finds Σ_{i∈S}2^{v_2(i)} ≤ 2·[3m·2^{t_0+1}+N·(T−t_0)] = O(N + N·log(3m)) = O(n·log m), where T≈log_2 N and t_0≈log_2(N/(3m)). Prover 02’s extremal bound Σ_{i∈S}2^{v_2(i)} ≤ N·H_{|S|} subsumes this and is sharp up to constant factors.
- Equal-scale specialization (01): From the corrected inequality Σ_{j: L_j<L} Decrease_j/B_j(A0) ≤ (2/(nL)) Σ_{i∈S}2^{v_2(i)} and the extremal bound with K=|S|≤3m≤3n/L, the correct consequence is Σ_{j: L_j<L} Decrease_j/B_j(A0) ≤ O((log(n/L))/L). The claimed O((log L)/L) does not follow in general (log(n/m)≥log L for m≤n/L).
- Extremal 2-adic bound (02): The proof via ordering the weights w(i)=2^{v_2(i)} and using s_ℓ≤N/ℓ is correct and sharp. It fills the missing technical step needed to bound Σ_i 2^{v_2(i)}.
- Geometric-window lemma (02): The per-index bound Σ_{j: i∈G_j} a_j(L) ≤ C_β·(L/n), with β∈(0,1/2), is correct; splitting the sum at s=ℓ and summing two geometric series yields the stated constant C_β=1/(1−β/2)+1/(1−2β). This gives an O(1) bound per equal-scale step from A0.

What we curate now
- We add (i) the extremal 2-adic sum bound; (ii) the small-scale fractional decrease bound at A0 with its corollaries (including the equal-scale O((log(n/L))/L) version); and (iii) the geometric-window weighted cross-level bound at A0.

Promising directions and next steps
- Equal-scale phase potential: combine Theorem 8 (large-scale weighted decreases) with the new small-scale O((log(n/L))/L) bound and the geometric-window lemma to define a geometric, scale-centered potential that drops by O(1) per equal-scale phase. Make the treatment of large relative drops precise using the factor-3 cap.
- Beyond the first step: pursue (a) persistence of arithmetic regularity of T_j(A) near the home scale after a near-L step, and (b) a signed per-index inequality (via Hamming-sum ideas) that is uniform in A. Either would let us iterate the O(1) per-phase drop without re-initializing at A0.
- Central-boundary demand: carry out the six-bit case analysis to prove that large decreases at level j require Ω(B_j) inner-boundary hits, enabling stronger control of which indices in S matter.
- Sanity checks: small-n experiments to probe tightness of the O((log(n/L))/L) bound and the constants in the geometric-window lemma.


=== notes.md ===
Setting and notation
- Input size n=2^d. The specific permutation A_0 is bit-reversal order of [0,…,n−1]. For j∈{0,…,d−1} we color elements by their j-th bit and denote by B_j(A) the number of monochromatic runs (contiguous blocks of equal j-bit) in the array A. Let T_j(A)⊆{1,…,n−1} be the set of j-run boundary indices (|T_j(A)|=B_j(A)−1). We consider one-step operations that swap a family of disjoint adjacent interval pairs in parallel.
- Our model of one step coincides with PBT (parallel adjacent block transpositions). One step chooses disjoint pairs (L_k,R_k) of adjacent contiguous intervals and swaps every chosen pair simultaneously.

Endpoint calibration (bit-reversal vs sorted)
- For A_0 (bit-reversal), B_j(A_0)=2^{j+1}. For the fully sorted order A_* = [0,1,…,n−1], B_j(A_*)=2^{d−j}. Consequently, the potential Φ(A):=Σ_{j=0}^{d−1} |log_2 B_j(A) − (d−j)| satisfies Φ(A_0)=Θ(d^2) and Φ(A_*)=0.

Locality of changes per pair and a safe per-level cap
- A single swapped pair (L,R) can alter adjacency only at three indices: the left outer boundary before L, the inner boundary between L and R, and the right outer boundary after R. For a fixed level j, if the union L∪R contains no j-boundary of the current array A, then all three affected adjacencies are between same colors both before and after; hence this pair produces no change in B_j.
- Therefore only pairs whose union contains at least one element of T_j(A) can affect B_j. Because the pair unions are disjoint, the number of such pairs is at most |T_j(A)|=B_j(A)−1. Each such pair contributes at most 3 to |B_j(A′)−B_j(A)|. Hence for every j and every PBT step A→A′,
  |B_j(A′) − B_j(A)| ≤ 3(B_j(A) − 1),
  which implies the multiplicative cap B_j(A′) ≤ 4·B_j(A) and B_j(A) ≤ 4·B_j(A′). In particular, |Δ log_2 B_j| ≤ 2 per step.

Dyadic alignment for A_0
- Let G_j denote the j-run boundary set in A_0. Then G_j = { i∈{1,…,n−1} : 2^{d−1−j} divides i }. For any set S of cut indices used in a step, one has
  Σ_{j=0}^{d−1} |S ∩ G_j| = Σ_{i∈S} (1 + v_2(i)) ≤ |S| (1 + ⌊log_2(n−1)⌋),
  since the number of j for which i∈G_j equals 1+v_2(i).

Caveats and corrections to earlier sketches
- The previously proposed “useful boundary” set U_j (indices in or adjacent to T_j(A)) is not a valid certificate for where toggles can occur: the post-step adjacency at a changed index depends on elements imported from potentially far away; mere distance-1 proximity to T_j(A) is insufficient to characterize where toggles can or cannot happen. We avoid using U_j.
- A claimed “size lemma” of the form Δ_j ≤ C·Σ_p min{1, s(p)/L_j} is false deterministically. Short pairs can be aligned to j-gridlines so that Δ_j ≍ n/L_j while the RHS is ≍ n/L_j^2. Any valid size-sensitive bound must use a different aggregation (see Next steps).
- Edge-to-level weighting that relies on fixed dyadic gridlines E_j holds at A_0 but not after the array evolves; after one step the j-boundaries are no longer constrained to those gridlines.

Next steps (program)
1) Try to sharpen the per-level cap to factor 2: Show |B_j(A′)−B_j(A)| ≤ c·|T_j(A)∪T_j(A′)| with small c (ideally c=1 or 2) by charging every toggling edge to a unique j-boundary contained in the union of the pair in either A or A′.
2) Demand for central matches: Prove that achieving a constant-factor decrease of B_j in one step requires Θ(B_j) central-boundary alignments (inner boundaries of swapped pairs) with j-run boundaries of A; outer-boundary hits alone cannot effect global coalescence. Make this precise and robust to local cancellations.
3) Cross-level scarcity via “home levels”: For each pair p of total size s(p), assign h(p) with L_{h(p)}≈s(p). Prove that constant-factor progress at level j needs Σ_{p: h(p)=j} Ω(1) contribution. Since Σ_p s(p) ≤ n and the sets {p: h(p)=j} are disjoint across j, only O(1) levels can make factor-≥2 progress in the same step. First prove the equal-scale special case (all pairs have sizes within ×2 of some L), which should already yield an Ω(log^2 n) lower bound for that restricted class.
4) Use the dyadic structure of G_j at A_0 to formalize a “central-boundary alignment trade-off” across levels: matched central boundaries that effect progress for one j are largely incompatible with those needed for many other j due to disjointness and dyadic spacing.
5) Perform small-n experiments (n=16,32) to estimate the maximal number of levels that can experience ≥2× change in B_j in one step and to guide constants.
New: toggle-locality identity and consequences
- Let A→A′ be one PBT step and let S⊆{1,…,n−1} be the set of indices whose adjacency changes in this step (exactly three per matched pair: left outer, inner, right outer; omit outer ones at array ends if absent). For each j, let T_j(A) be the set of j-run boundary indices (|T_j(A)|=B_j(A)−1).
- Identity (toggle-locality). For every j,
  B_j(A′) − B_j(A) = |T_j(A′) ∩ S| − |T_j(A) ∩ S|.
  Reason: outside S, adjacencies (and hence boundary membership) are identical in A and A′, so T_j(A′) Δ T_j(A) ⊆ S, which implies the stated cardinality identity.
- Corollary (one-sided bounds). For every j,
  Decrease_j := max{0, B_j(A) − B_j(A′)} ≤ |T_j(A) ∩ S|,
  Increase_j := max{0, B_j(A′) − B_j(A)} ≤ |S \ T_j(A)|.
  Interpretation: shrinking B_j by Δ forces at least Δ of the changed indices to land on current j-boundaries.

Improved per-level cap via per-pair ±2
- Per pair (L,R) and fixed j, define Δ_pair as the change in the number of j-boundaries attributable to that pair; then |Δ_pair| ≤ 2 (prove by the binary 4-cycle inequality on the three interfaces). In addition, only pairs whose union is non-monochromatic at level j can contribute, and such pairs are at most |T_j(A)| by disjointness (charge to an internal j-boundary index).
- Summing gives |B_j(A′)−B_j(A)| ≤ 2·|T_j(A)| = 2(B_j(A)−1). Applying the bound to the inverse step yields the multiplicative cap B_j(A′) ≤ 3B_j(A) and B_j(A) ≤ 3B_j(A′). Thus |Δ log_2 B_j| ≤ log_2 3 per step.

Weighted dyadic alignment at A_0 and a corrected weighted bound
- For A_0, G_j = T_j(A_0) is the dyadic grid {i: 2^{d−1−j} | i}. For any set S of changed indices, Σ_j |S∩G_j| = Σ_{i∈S} (1+v_2(i)). More generally, for nonnegative weights a_j, Σ_j a_j·|S∩G_j| = Σ_{i∈S} Σ_{j: i∈G_j} a_j.
- Combining with toggle-locality yields the exact inequality Σ_j a_j·Decrease_j ≤ Σ_{i∈S} Σ_{j: i∈G_j} a_j. For the specific weights a_j=2^{−(j+1)}, if v_2(i)=t then Σ_{j: i∈G_j} 2^{−(j+1)} = 2^{−(d−t−1)}(1−2^{−(t+1)}) ≤ 2^{−d+t+1}. Thus Σ_j 2^{−(j+1)}·Decrease_j ≤ Σ_{i∈S} 2^{−d+v_2(i)+1}. (This corrects a factor-2 slip in an earlier draft.)

Caution on “equal-scale first-step scarcity from A_0”
- The claim “if L_j > s then every union U=L∪R is j-monochromatic in A_0” is false. Counterexample (n=8, j=0): L_j=4; a union U of size s=2 that straddles the unique G_0 index at 4 is not monochromatic.
- What does hold: the per-pair ±2 bound implies |ΔB_j| ≤ 2m ≤ 2n/s for any j. From A_0 this yields that if L_j ≪ s then |ΔB_j|/B_j(A_0) ≤ O(L_j/s)=o(1), so constant-factor decreases at such j are impossible in that step. This does not preclude large changes when L_j ≫ s; additional structure (e.g., grid-aligned inner boundaries) seems necessary to prove an O(1) cap on the number of “active levels”.

Planned direction: equal-scale, grid-aligned scarcity
- Assume an L-aligned step: pair sizes in [L,2L) and all inner boundaries on the L-grid. For A starting at A_0, use arithmetic progression intersections to show that for off-scale j (2^{d−1−j} far from L) the proportion |S∩G_j|/B_j is o(1); combine with toggle-locality to rule out constant-factor decreases at those j. Only O(1) consecutive j with 2^{d−1−j}∈[L/2,2L] can be “active”. Control outer-boundary contributions by noting they contribute only O(#pairs) points, spread over a constant number of L-residue classes.

Next steps (actionable)
1) Write the full aligned-scarcity proof, including the precise bounds on |S∩G_j| and |S\G_j| for off-scale j.
2) Extend to near-alignment by averaging over residues modulo L to extract a constant-aligned subfamily.
3) Develop a central-vs-outer charging lemma: quantify the fraction of Decrease_j that must be paid by inner boundaries hitting T_j(A), uniformly over steps. This will dovetail with a home-level charging scheme for pairs.
4) Continue small-n experiments (n=32,64,128) to probe the number of levels with ≥ constant-factor decreases under equal-scale steps.
New exact identities, corrections, and scale-weighted constraints

1) Exact Hamming-sum identity across levels
- For any array A, define HD_A(i) as the Hamming distance (in d bits) between the values at positions i and i+1. Then for all A,
  Σ_{j=0}^{d−1} (B_j(A) − 1) = Σ_{i=1}^{n−1} HD_A(i).
- Across one step A→A′ with changed-adjacency set S (three per pair),
  Σ_{j=0}^{d−1} (B_j(A′) − B_j(A)) = Σ_{i∈S} (HD_{A′}(i) − HD_A(i)).
Explanation: For each i, the indicator that i∈T_j(A) is exactly the indicator that the j-th bits at i and i+1 differ; summing over j gives HD_A(i). Subtracting two arrays and noting HD is unchanged outside S yields the step identity. This is complementary to toggle-locality and shows per changed index the total boundary mass across all levels changes by at most d.

2) Sub-run regime from A_0: corrected one-sided statement
- Setup: A=A_0, fix j and its run length L_j=2^{d−1−j}. Consider a single pair (L,R) with union U of length s=|U|.
- Fact (geometry on G_j): If s<L_j then among the three changed indices of this pair (left outer, inner, right outer), at most one index belongs to G_j=T_j(A_0). Indeed, the three indices lie in an index interval of length s, which contains at most one multiple of L_j.
- Consequence (decrease-only). For such a pair and level j, the per-pair j-decrease is ≤1 (toggle-locality gives Decrease_j ≤ |T_j(A_0)∩S_pair| ≤ 1). Caution: increases can be as large as +2 in this regime (e.g., when the pair straddles a single j-boundary), so |Δ_pair(j)| is not ≤1 in general.
- Counterexample to the |Δ_pair(j)|≤1 claim: Let L be the last item of a j-run and R the first item of the next j-run in A_0; then s=2<L_j. Before the swap, only the inner interface is a j-boundary; after swapping, all three interfaces are j-boundaries, so the per-pair change is Δ_pair(j)=−2 (B_j increases by 2).

3) “Decrease-only alignment bound” as stated is false
- The claim “if all pair boundaries lie on the L-grid then for j with L_j∤L one has Decrease_j=0” does not hold. Even if S⊆{multiples of L}, S can still contain indices that are also multiples of L_j (e.g., multiples of lcm(L,L_j)), so |G_j∩S| may be nonempty. Toggle-locality alone cannot force Decrease_j=0 under this assumption. Any valid one-sided alignment bound must add further structure about which L-residue classes are used by S.

4) A clean large-scale weighted inequality from A_0
- For A=A_0 and any power-of-two L=2^ℓ,
  Σ_{j: L_j≥L} (L/L_j)·Decrease_j ≤ 2|S|.
  In steps with m pairs, this gives Σ_{j: L_j≥L} (L/L_j)·Decrease_j ≤ 6m. If in addition all pair lengths lie in [L,2L), then m≤n/L, yielding Σ_{j: L_j≥L} (L/L_j)·Decrease_j ≤ 6n/L.
- Proof idea: Combine toggle-locality with the dyadic alignment of G_j in A_0; for i with v_2(i)=t, the inner sum Σ_{j: i∈G_j, L_j≥L} (L/L_j)=Σ_{s=ℓ}^{t}2^{ℓ−s}≤2.

5) On small-scale control (sketch; not yet curated)
- Using weights w_j:=1/B_j(A_0)=L_j/n, toggle-locality and dyadic alignment give
  Σ_j w_j·Decrease_j ≤ (2/n)·Σ_{i∈S} 2^{v_2(i)}.
- Two routes to control the RHS:
  (a) General extremal bound: For any K-subset S⊆{1,…,n−1}, prove Σ_{i∈S}2^{v_2(i)} ≤ C K log(2n/K). With K≤|S|≤3m≤3n/L this yields Σ_{j: L_j<L} Decrease_j/B_j(A_0) ≤ O((log L)/L).
  (b) L-grid inner-boundary route: If a “central-boundary demand” lemma shows small-scale decreases must be paid mostly by inner boundaries, then restricting to S_inner⊆{multiples of L} gives Σ_{i∈S_inner}2^{v_2(i)} ≤ 2^ℓ·Σ_{k≤n/L}2^{v_2(k)} = O(n·log(n/L)), hence Σ_j Decrease_j/B_j(A_0) ≤ O(log(n/L)/L).
- Either route needs a complete proof before inclusion in output.

6) Reassessment of the “O(1) active levels per step)” heuristic
- In aligned steps at very small scale (e.g., L=1), S can intersect G_j at Θ(B_j(A_0)) for Θ(log n) many j simultaneously, so any argument purely bounding the number of active levels is untenable. Scale-sensitive weighted bounds (as above) are the right replacements.

7) Restricted-phase milestone
- For algorithms operating in phases with pair sizes in [L_t,2L_t) and inner L_t-grid alignment, define a phase-weighted potential Ψ_t(A) concentrated near the home scale L_t. Combine the large-scale inequality in (4) with a proved small-scale control to show O(1) drop per phase, yielding Ω(log^2 n) steps across scales.

Actionable next steps
- Prove a sharp bound on Σ_{i∈S}2^{v_2(i)} via route (a) or (b) above.
- Complete a per-pair six-bit case analysis; extract a “central-boundary demand” lemma quantifying the necessary contribution of the inner boundary for large decreases at a fixed j.
- Design signed cross-level weights using the Hamming-sum identity to bound per-index signed contributions by O(1). Validate on small-n instances.
New rigorously verified bounds from A_0 (bit-reversal start)

- Extremal 2-adic sum bound. For N≥1 and any K-subset S⊆{1,…,N}, one has
  \[\sum_{i\in S} 2^{v_2(i)} \le N\,H_K,\]
  where H_K is the K-th harmonic number. This is sharp up to constants and will be our default way to control 2-adic weighted sums over changed indices.

- Small-scale fractional decrease bound (first step from A_0). For L=2^\ell,
  \[\sum_{j: L_j<L} \frac{\mathrm{Decrease}_j}{B_j(A_0)} \le \frac{2}{nL}\sum_{i\in S} 2^{v_2(i)}.\]
  Combining with the extremal bound and |S|=K≤3m gives
  \[\sum_{j: L_j<L} \frac{\mathrm{Decrease}_j}{B_j(A_0)} \le \frac{2}{L} H_K \le \frac{2}{L} H_{3m}=O\!\left(\frac{\log m}{L}\right).\]
  Under equal-scale steps (all pair lengths in [L,2L)), we have m≤n/L and thus
  \[\sum_{j: L_j<L} \frac{\mathrm{Decrease}_j}{B_j(A_0)} = O\!\left(\frac{\log(n/L)}{L}\right).\]
  Immediate counting corollary: for any \(\theta\in(0,1]\), the number of levels j with L_j<L and \(\mathrm{Decrease}_j \ge \theta\,B_j(A_0)\) is at most \(O((\log(n/L))/(\theta L))\).

- Geometric-window weighted decrease (first step from A_0). Fix \(\beta\in(0,1/2)\) and a home scale L=2^\ell. Define weights \(a_j(L):=\beta^{\,| (d-1-j) - \ell |}/2^{j+1}\). Then
  \[\sum_j a_j(L)\,\mathrm{Decrease}_j \le C_\beta\,(L/n)\,|S|,\quad C_\beta=\frac{1}{1-\beta/2}+\frac{1}{1-2\beta}.\]
  In equal-scale steps, \(|S|\le 3m\le 3n/L\), so \(\sum_j a_j(L)\,\mathrm{Decrease}_j\le 3C_\beta=O(1)\).

Corrections to earlier sketches
- A previously claimed “layer-cake” estimate \(\sum_{i\in S}2^{v_2(i)}\le C n (1+\log(n/m))\) is not tight and in general false for large m; the correct universal upper bound is \(\sum_{i\in S}2^{v_2(i)}\le (n-1) H_{|S|}=O(n\log|S|)=O(n\log m)\).
- The specialization \(O((\log L)/L)\) for \(\sum_{j: L_j<L}\mathrm{Decrease}_j/B_j(A_0)\) does not follow in general; the correct equal-scale bound is \(O((\log(n/L))/L)\).

How these fit the program
- Together with Theorem 8 (large-scale weighted decreases), the new small-scale bound pinches progress from both sides at a chosen L, and the geometric-window lemma concentrates the accounting near L with an O(1) per-step cap (from A_0). This strongly motivates a phase potential centered at L and a proof of O(1) drop per equal-scale phase.

Next steps (refined)
1) Formalize an equal-scale phase potential that combines Theorem 8 with the small-scale bound and handles large relative drops via the factor-3 cap; target an O(1) drop per phase starting at A_0.
2) Extend beyond the first step: either show arithmetic regularity for \(T_j(A)\) near the home scale persists (enough to reapply the geometric-window argument), or prove a signed per-index inequality uniform in A, guided by the Hamming-sum identity.
3) Prove a central-boundary demand lemma via a six-bit case analysis, quantifying the necessary inner-boundary hits for large decreases at a fixed j.


=== output.md ===
Statements and proofs curated so far

Setup and notation
- Let n=2^d. An array A is a permutation of [0,…,n−1]. For j∈{0,…,d−1}, color each entry of A by the j-th bit of its value and let B_j(A) be the number of monochromatic runs in this 2-coloring. Let T_j(A)⊆{1,…,n−1} be the set of indices i where the j-color flips between positions i and i+1 (so |T_j(A)|=B_j(A)−1). A single step A→A′ is a parallel block transposition (PBT): a product of disjoint swaps of adjacent contiguous interval pairs (L,R). Such a step changes adjacencies only at the three interface indices of each pair (left outer, inner, right outer; omitting outer ones at the array ends).

Theorem 1 (Model equivalence to PBT). A single step of the model (swapping a family of disjoint adjacent interval pairs in parallel) is exactly a parallel block transposition (PBT) step.
Proof. A step chooses disjoint adjacent pairs (L_k,R_k) of intervals and swaps each pair simultaneously, leaving all other positions untouched. This is precisely a product of disjoint adjacent block transpositions. Conversely, any product of disjoint adjacent block transpositions can be realized by choosing those pairs. ∎

Theorem 2 (Endpoint run-counts). Let n=2^d and A_0 be the bit-reversal permutation of [0,…,n−1]. For j∈{0,…,d−1}:
- B_j(A_0)=2^{j+1}.
- For the fully sorted order A_*=[0,1,…,n−1], B_j(A_*)=2^{d−j}.
Consequently, with D_j(A):=|log_2 B_j(A) − (d−j)|, one has Σ_{j=0}^{d−1} D_j(A_0)=Θ(d^2) and Σ_{j=0}^{d−1} D_j(A_*)=0.
Proof. In A_0, the j-bit of the value at position i equals the (d−1−j)-th bit of i; thus along positions 0,…,n−1 this bit is constant on runs of length 2^{d−1−j} and alternates every such block, giving exactly 2^{j+1} runs. In A_*, the j-bit is constant on blocks of length 2^j and alternates every 2^j positions, yielding 2^{d−j} runs. The Θ(d^2) sum follows from Σ_{j=0}^{d−1} |2j+1−d| = Θ(d^2) by symmetry around (d−1)/2. ∎

Lemma 3 (Toggle-locality identity). Let A→A′ be one PBT step and let S be the set of indices whose adjacency changes in this step (the three interfaces per pair). Then for every j,
  B_j(A′) − B_j(A) = |T_j(A′) ∩ S| − |T_j(A) ∩ S|.
In particular, Decrease_j := max{0, B_j(A) − B_j(A′)} ≤ |T_j(A) ∩ S| and Increase_j := max{0, B_j(A′) − B_j(A)} ≤ |S \ T_j(A)|.
Proof. If i∉S then the adjacent entries across i are the same in A and A′, hence i∈T_j(A) iff i∈T_j(A′). Thus T_j(A′) Δ T_j(A) ⊆ S and
|T_j(A′)|−|T_j(A)| = |T_j(A′)∩S| − |T_j(A)∩S|.
Since B_j(·)=|T_j(·)|+1, the displayed identity follows; the one-sided bounds are immediate. ∎

Lemma 4 (Per-pair ±2 bound at a fixed level). Fix j and a single swapped pair (L,R). Let Δ_pair be its contribution to ΔB_j. Then |Δ_pair| ≤ 2. Moreover, if the union U=L∪R is j-monochromatic (equivalently, contains no index of T_j(A)), then Δ_pair=0.
Proof. Only the three interface indices can change their boundary status. Let a_L be the j-color of the neighbor immediately left of L, a_R the j-color of the neighbor immediately right of R; let L_1,L_k be the first/last j-colors in L and R_1,R_m the first/last j-colors in R. Writing [·] for the indicator of inequality, the total contribution before the swap equals
  X := [a_L≠L_1] + [L_k≠R_1] + [R_m≠a_R],
and after the swap equals
  Y := [a_L≠R_1] + [R_m≠L_1] + [L_k≠a_R].
Thus Δ_pair = X − Y. Using the inequality [q≠x] − [q≠y] ≤ [x≠y] twice gives
  Δ_pair ≤ [L_1≠R_1] + [R_m≠L_k] + ([L_k≠R_1] − [R_m≠L_1]).
The binary 4-cycle inequality [p≠q]+[q≠r]+[r≠s]−[s≠p] ≤ 2, applied to (p,q,r,s)=(L_1,R_1,L_k,R_m), yields Δ_pair ≤ 2. The lower bound follows symmetrically (or by applying the argument to the inverse swap). If U is j-monochromatic then L_1=L_k=R_1=R_m and all three interface indicators are unchanged, so Δ_pair=0. ∎

Theorem 5 (Per-level factor-3 cap per step). For any array A, any j, and any single PBT step A→A′,
  B_j(A′) ≤ 3·B_j(A) and B_j(A) ≤ 3·B_j(A′).
Equivalently, |log_2 B_j| changes by at most log_2 3 in one step.
Proof. Let M_j(A) be the set of swapped pairs whose union U is not j-monochromatic in A. By disjointness of the unions, each U∈M_j(A) contains at least one index of T_j(A), and distinct U’s receive distinct such indices; hence |M_j(A)| ≤ |T_j(A)| = B_j(A)−1. Summing Lemma 4 over pairs gives
  |B_j(A′) − B_j(A)| ≤ Σ_{pairs} |Δ_pair| ≤ 2·|M_j(A)| ≤ 2(B_j(A)−1).
Therefore B_j(A′) ≤ B_j(A) + 2(B_j(A)−1) ≤ 3B_j(A). Applying the same bound to the inverse step A′→A yields B_j(A) ≤ 3B_j(A′). ∎

Theorem 6 (Dyadic alignment for A_0; weighted form). Let G_j⊆{1,…,n−1} be the set of j-run boundary indices in A_0. Then G_j = { i : 2^{d−1−j} divides i }. For any set S⊆{1,…,n−1},
  Σ_{j=0}^{d−1} |S ∩ G_j| = Σ_{i∈S} (1 + v_2(i)).
More generally, for any weights a_j≥0,
  Σ_{j=0}^{d−1} a_j·|S ∩ G_j| = Σ_{i∈S} Σ_{j: 2^{d−1−j} | i} a_j.
Proof. In A_0 the j-bit is periodic with period 2^{d−j}, so boundaries occur exactly at indices i that are multiples of 2^{d−1−j}. For fixed i, the set of j with i∈G_j has size 1+v_2(i); the weighted identity is immediate by exchanging sums. ∎

Corollary 6.1 (Weighted decrease bound from A_0). In one step A_0→A′ with changed-index set S, and any weights a_j≥0,
  Σ_{j} a_j·Decrease_j ≤ Σ_{i∈S} Σ_{j: i∈G_j} a_j.
In particular, with a_j=2^{−(j+1)} and v_2(i)=t,
  Σ_{j} 2^{−(j+1)}·Decrease_j ≤ Σ_{i∈S} 2^{−(d−t−1)}(1−2^{−(t+1)}) ≤ Σ_{i∈S} 2^{−d+t+1}.
Proof. Combine Lemma 3 with Theorem 6 and use nonnegativity of the weights; the explicit sum for a_j=2^{−(j+1)} is a direct geometric series. ∎
Theorem 7 (Hamming-sum identity across levels).
Let A be any permutation of [0,…,n−1]. For i∈{1,…,n−1}, let HD_A(i) be the Hamming distance in d-bit binary between the values at positions i and i+1. Then
- Σ_{j=0}^{d−1} (B_j(A) − 1) = Σ_{i=1}^{n−1} HD_A(i).
Moreover, for any single PBT step A→A′ with changed-adjacency set S,
- Σ_{j=0}^{d−1} (B_j(A′) − B_j(A)) = Σ_{i∈S} (HD_{A′}(i) − HD_A(i)).
Proof. For fixed i, the indicator that i∈T_j(A) is exactly the indicator that the j-th bits of the adjacent values differ; summing over j gives HD_A(i). Summing over i yields the first identity. Subtracting the identity for A from that for A′ gives Σ_j(B_j(A′)−B_j(A)) = Σ_i(HD_{A′}(i)−HD_A(i)). Since HD is unchanged outside S, the sum over all i reduces to the sum over i∈S. ∎

Corollary 7.1 (Pair-budget demand for decreases).
Let a step use m disjoint pairs and S be its set of changed indices. Then for every j,
- Decrease_j ≤ |T_j(A)∩S| ≤ |S| ≤ 3m.
In particular, achieving Decrease_j ≥ θ·B_j(A) in one step requires m ≥ (θ/3)·B_j(A).
Proof. The first inequality is Lemma 3; |S|≤3m since each pair contributes at most three changed indices. The demand bound is immediate. ∎

Lemma 7.2 (A_0 sub-run per-pair decrease bound).
Let A=A_0. Fix j and its run length L_j=2^{d−1−j}. Consider a single swapped pair (L,R) whose union U has length s< L_j, and let S_pair be the three changed indices contributed by this pair. Then |T_j(A_0)∩S_pair|≤1; consequently the per-pair decrease at level j in this step satisfies Decrease_j ≤ 1.
Proof. The three changed indices lie between the left-outer and right-outer interfaces; this integer interval has length s< L_j and hence contains at most one multiple of L_j. Since G_j=T_j(A_0) is exactly the set of multiples of L_j, at most one of the three changed indices lies in G_j. Toggle-locality gives Decrease_j ≤ |T_j(A_0)∩S_pair| ≤ 1. ∎

Theorem 8 (Large-scale weighted decrease bound from A_0).
Let A=A_0 and L=2^ℓ. For any PBT step A→A′ with changed-index set S,
- Σ_{j: L_j≥L} (L/L_j)·Decrease_j ≤ 2|S|.
Consequently, if the step uses m pairs then Σ_{j: L_j≥L} (L/L_j)·Decrease_j ≤ 6m. If, moreover, all pair lengths lie in [L,2L), then m≤n/L and hence Σ_{j: L_j≥L} (L/L_j)·Decrease_j ≤ 6n/L.
Proof. By Lemma 3 and Theorem 6 (weighted form), for any nonnegative weights a_j,
  Σ_j a_j·Decrease_j ≤ Σ_{i∈S} Σ_{j: i∈G_j} a_j.
Take a_j = (L/L_j)·1_{L_j≥L}. For i with 2-adic valuation v_2(i)=t, the inner sum equals Σ_{s=ℓ}^{t} 2^{ℓ−s} ≤ 2 (empty if t<ℓ). Summing over i∈S gives Σ_{j: L_j≥L} (L/L_j)·Decrease_j ≤ 2|S|. The two corollaries follow from |S|≤3m and, under equal-scale [L,2L) pairs, m≤n/L. ∎
Lemma 9 (Extremal 2-adic sum bound).
Let N\ge 1 and S\subseteq\{1,\dots,N\} with |S|=K\ge 1. Then
\[\sum_{i\in S} 2^{v_2(i)} \le N\,H_K,\]
where \(H_K=\sum_{\ell=1}^K 1/\ell\) is the K-th harmonic number.
Proof. Order the weights \(w(i):=2^{v_2(i)}\) in nonincreasing order as \(s_1\ge s_2\ge\cdots\ge s_N\). For each integer \(t\ge 0\), at most \(\lfloor N/2^t\rfloor\) integers have \(v_2\ge t\), hence at most \(\lfloor N/2^t\rfloor\) weights are \(\ge 2^t\). Therefore, for every \(\ell\ge 1\),
\[s_\ell\le \max\{2^t: N/2^t\ge \ell\}\le N/\ell.\]
Thus \(\sum_{i\in S}2^{v_2(i)}\le \sum_{\ell=1}^K s_\ell\le \sum_{\ell=1}^K (N/\ell) = N H_K.\quad\square\)

Theorem 9 (Small-scale fractional decrease bound at A_0).
Let \(n=2^d\), \(A=A_0\) (bit-reversal), and \(L=2^\ell\). For any single PBT step \(A_0\to A'\) with changed-index set \(S\subseteq\{1,\dots,n-1\}\),
\[\sum_{j: L_j<L} \frac{\mathrm{Decrease}_j}{B_j(A_0)} \le \frac{2}{nL}\sum_{i\in S} 2^{v_2(i)}.\]
Proof. By toggle-locality (Lemma 3) and the weighted dyadic identity (Theorem 6), for nonnegative weights \(a_j\),
\[\sum_j a_j\,\mathrm{Decrease}_j \le \sum_{i\in S}\sum_{j: i\in G_j} a_j.\]
Choose \(a_j=(1/L)\,\mathbf{1}_{\{L_j<L\}}\,2^{-(j+1)}=(1/L)\,\mathbf{1}_{\{d-1-j<\ell\}}\,2^{-(j+1)}\). For fixed \(i\) with \(v_2(i)=t\), the inner sum is
\[(1/L)\sum_{j: i\in G_j,\;L_j<L} 2^{-(j+1)}= (1/L)\,2^{-d}\sum_{s=0}^{\min\{t,\ell-1\}}2^s \le (1/L)\,2^{-d}\sum_{s=0}^{t}2^s \le (1/L)\,2^{t+1-d}.\]
Summing over \(i\in S\) gives
\(\sum_{j: L_j<L} \mathrm{Decrease}_j/B_j(A_0) \le (2/(nL))\sum_{i\in S}2^{v_2(i)}\).\quad\square

Corollary 9.1 (Extremal control and equal-scale specialization).
With notation as in Theorem 9, let \(K=|S|\). Then
\[\sum_{j: L_j<L} \frac{\mathrm{Decrease}_j}{B_j(A_0)} \le \frac{2}{nL}\,(n-1)\,H_K \le \frac{2}{L}\,H_K.\]
In particular, if the step uses \(m\) disjoint pairs then \(K\le 3m\) and
\[\sum_{j: L_j<L} \frac{\mathrm{Decrease}_j}{B_j(A_0)} \le \frac{2}{L}\,H_{3m}=O\!\left(\frac{\log m}{L}\right).\]
If, moreover, all pair lengths lie in \([L,2L)\) (equal-scale), then \(m\le n/L\), hence
\[\sum_{j: L_j<L} \frac{\mathrm{Decrease}_j}{B_j(A_0)} = O\!\left(\frac{\log(n/L)}{L}\right).\]
Proof. Apply Lemma 9 with \(N=n-1\), then use \(K\le 3m\) and \(m\le n/L\).\quad\square

Corollary 9.2 (Counting active small-scale levels).
Fix \(\theta\in(0,1]\). Under the hypotheses of Theorem 9, the number of indices \(j\) with \(L_j<L\) and \(\mathrm{Decrease}_j\ge \theta\,B_j(A_0)\) is at most \(\frac{2}{\theta L}H_K\); in particular, in equal-scale steps it is \(O((\log(n/L))/(\theta L))\).
Proof. By Markov’s inequality on the nonnegative sum in Theorem 9 combined with Corollary 9.1.\quad\square

Theorem 10 (Geometric-window weighted cross-level bound at A_0).
Fix \(\beta\in(0,1/2)\) and a home scale \(L=2^\ell\). Define weights \(a_j(L):=\beta^{\,| (d-1-j) - \ell |}/2^{j+1}\). For any single PBT step \(A_0\to A'\) with changed-index set \(S\),
\[\sum_{j=0}^{d-1} a_j(L)\,\mathrm{Decrease}_j \le C_\beta\,(L/n)\,|S|,\quad\text{where}\quad C_\beta:=\frac{1}{1-\beta/2}+\frac{1}{1-2\beta}.\]
In particular, if all pair lengths lie in \([L,2L)\), then \(|S|\le 3m\le 3n/L\) and thus \(\sum_j a_j(L)\,\mathrm{Decrease}_j\le 3C_\beta=O(1)\).
Proof. By Lemma 3 and Theorem 6 with weights \(a_j(L)\),
\[\sum_j a_j(L)\,\mathrm{Decrease}_j \le \sum_{i\in S}\sum_{j: i\in G_j} a_j(L).\]
For \(i\) with \(v_2(i)=t\), writing \(s=d-1-j\),
\[\sum_{j: i\in G_j} a_j(L)=\sum_{s=0}^{t} \beta^{\,|s-\ell|}\,2^{s-d}=2^{-d}\Big(\sum_{s=0}^{\ell} \beta^{\ell-s}2^{s}+\sum_{s=\ell}^{t} \beta^{s-\ell}2^{s}\Big)\le 2^{-d}\,2^{\ell}\Big(\tfrac{1}{1-\beta/2}+\tfrac{1}{1-2\beta}\Big)=C_\beta\,(L/n).\]
Summing over \(i\in S\) yields the claim; the equal-scale consequence follows from \(|S|\le 3m\le 3n/L\).\quad\square



Current round tag: Round 0005 — 2025-08-27T20:23:14.044613Z
Return ONLY valid JSON with a single field:
{ "progress_md": "<your progress notes for this round>" }

Read output.md. If you spot gaps, errors, or missing justifications in output.md, point them out clearly inside progress_md.
