{
  "progress_md": "Goal and target claim\n- Target we propose to prove: If an LCL \u03a0 on bounded-degree (nonoriented) trees admits a deterministic online-local algorithm with constant locality r = O(1), then \u03a0 has a deterministic LOCAL (message-passing) algorithm with round complexity O(log* n).\n- Why useful: This gives the desired speedup from the online local model to the standard LOCAL model on trees, matching the \u0398(log* n) symmetry-breaking regime and aligning with known classifications (Theorem 2.33 in the attached notes).\n\nIdea in one sentence\n- Reduce a constant-radius deterministic online-local algorithm to a deterministic sequential local algorithm with the same radius, then simulate it in the LOCAL model by (i) computing an O(\u0394^{O(r)})-coloring of the power graph G^r in O(r log* n) rounds and (ii) executing r-round phases by colors; with \u0394 bounded and r = O(1), total is O(log* n).\n\nModel bridging and key lemmas (clean statements with \u201cwhy useful\u201d)\n- Lemma A (Online \u21d2 Sequential local, constant radius): Let \u03a0 be an LCL on bounded-degree graphs. If \u03a0 has a deterministic online local algorithm that (for any adversarial vertex order) decides each vertex\u2019s output using only its r-hop neighborhood and previously fixed outputs within that neighborhood, then \u03a0 admits a deterministic sequential local algorithm of local complexity r (in the sense of Definition 1.3 in the notes).\n  - Why useful here: The simulation framework (Theorem 2.5 in the notes) converts sequential local algorithms to distributed ones. This lemma lets us plug online-local algorithms directly into that framework.\n  - Proof sketch to be formalized: Fix any adversarial order; define the sequential rule to perform exactly the online rule when visiting a vertex, using already determined outputs in its r-hop neighborhood as the online algorithm would. Since the online algorithm must succeed for all orders, the resulting sequential algorithm succeeds for every order.\n\n- Lemma B (Power-graph coloring in O(log* n)): For any bounded-degree graph G and constant r, one can compute in the LOCAL model a proper coloring of G^r with O(\u0394(G^r)^2) = \u0394^{O(r)} colors in O(r log* n) rounds.\n  - Why useful here: The coloring provides a schedule with O(\u0394^{O(r)}) parallel phases in which vertices at pairwise distance > r act simultaneously without conflicts in the sequential simulation.\n  - Support: Linial\u2019s color reduction (Theorem 2.4 in the notes) computes a \u0394(G^r)^{O(1)}-coloring of G^r in O(log* n) rounds on G^r; simulating a G^r round on G costs r rounds \u21d2 total O(r log* n). (Bounded-degree implies \u0394(G^r) \u2264 \u0394^r.)\n\n- Lemma C (Color-phased simulation of sequential local A): Let A be a deterministic sequential local algorithm for \u03a0 of locality r. Given a proper coloring of G^r with c colors, one can simulate A in the LOCAL model in c \u00b7 O(r) additional rounds: process colors 1,2,\u2026,c; in color i, each vertex gathers the outputs (and any auxiliary state) within distance r restricted to colors < i and computes its own output/state by A.\n  - Why useful here: This yields a LOCAL simulation with round complexity c\u00b7O(r) = \u0394^{O(r)} for the simulation after the coloring is available.\n  - Correctness intuition: By definition of G^r-coloring, vertices of the same color are at distance > r, so their simulations do not depend on each other. Sequential local algorithms are defined to succeed regardless of order, so the color order is a valid global order.\n\n- Corollary (Putting B + C together): For bounded-degree graphs and constant r, the LOCAL round complexity is O(r log* n) (coloring) + \u0394^{O(r)}\u00b7O(r) (simulation). With \u0394 constant and r = O(1), this is O(log* n).\n  - Why useful here: It gives the exact O(log* n) bound we want for nonoriented trees (indeed, for any bounded-degree graphs).\n\nClarifying the online-local model assumptions (potential gap to check)\n- We are relying on the version of the deterministic online local model in which:\n  1) Vertices are processed in an adversarial order; upon processing a vertex u, the algorithm can only inspect B(u,r) in the current graph and the already-fixed outputs in that ball; the choice is irrevocable.\n  2) The algorithm must succeed for every adversarial order. \n- This matches the \u201csequential local algorithm\u201d model in Definition 1.3 (deterministic, order-robust) once we fix r. If the online model allowed dependence on future arrivals (it shouldn\u2019t) or only guaranteed success for a specific order, Lemma A would fail. Action item: confirm that the online-local definition we use matches [Akb+23; Chang et al. 2023] for trees.\n\nExamples/sanity checks\n- Example 1: Weak 2-coloring on bounded-degree trees. Known to be solvable in constant locality sequentially; by our pipeline, LOCAL complexity O(log* n) \u2014 consistent with classic results.\n- Example 2: Sinkless orientation on trees. Known deterministic LOCAL lower bound is \u03a9(log n) (Theorem 2.15); thus no constant-radius deterministic online algorithm can exist, consistent with the contrapositive.\n\nObstacles and subtle points\n- Port numbering/orientation: Our argument does not require oriented trees. Linial\u2019s color reduction and the power-graph coloring use unique IDs; they do not need a global orientation. The LCL constraints are checked on unlabeled, port-numbered neighborhoods as usual.\n- Auxiliary state in sequential algorithms: Definition 1.3 allows storing auxiliary state at each step. In the LOCAL simulation, we carry auxiliary state along phases as metadata; only the final \u201coutput label\u201d needs to satisfy \u03a0. This is standard in the Theorem 2.5 simulation.\n- Dependence on \u0394 and r: The number of colors c in the G^r-coloring is \u0394^{O(r)}. Since we restrict to bounded-degree trees and r = O(1), c = O(1); hence the c\u00b7O(r) term is constant, leaving O(log* n) overall due to the coloring step.\n\nRelation to known results (how this fits in the literature)\n- This is a specialization of Theorem 2.5 (sequential \u21d2 distributed simulation via coloring) to the case t = r = O(1), plus Lemma A to bridge from online-local to sequential-local. The resulting O(log* n) bound recovers the symmetry-breaking regime on trees (Theorem 2.33), and works in the nonoriented setting.\n- Note: The statement actually holds on any bounded-degree graph, not only trees; we emphasized trees to match the task wording.\n\nActionable next steps to move to output.md\n- Formalize Lemma A with a precise definition of the deterministic online-local model; include a short proof that it induces a deterministic sequential local algorithm of the same locality r.\n- State and prove Lemma B with an explicit citation to Linial\u2019s color reduction and the simulation overhead to work on G instead of G^r.\n- State and prove Lemma C (the color-phased simulation) carefully, including the auxiliary state bookkeeping and the per-phase O(r) implementation details (what needs to be communicated each phase).\n- Combine the lemmas into the main theorem for bounded-degree (nonoriented) trees, explicitly tracking constants: total rounds O(r log* n) + \u0394^{O(r)}\u00b7O(r) = O(log* n).\n\nNotes on gaps/missing justifications in output.md\n- There is currently no output.md provided; hence no curated results to audit. When drafting output.md, please include: (i) precise model definitions, (ii) the three lemmas above with proofs, (iii) the combined theorem, and (iv) a short remark that the proof does not use orientation of the tree.\n"
}