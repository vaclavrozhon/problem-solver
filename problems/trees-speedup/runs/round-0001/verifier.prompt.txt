--- SYSTEM ---
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (summary so far)
- output.md (rigorously proven results so far)

Guidelines:
- notes.md: should be a readable running log of interesting work. Prefer appending. Replace only if old notes are clearly misleading. Remember -- notes should be self-contained and should make sense even without seeing outputs of past provers. 
- output.md: should be concise and rigorous. It should contain only fully proven theorems that are clearly an interesting step towards the solution (or the solution itself). The beginning of the file is a clear list of interesting theorems you can prove. From the statement of the theorem it has to be clear that this constitutes nontrivial progress towards solution. The rest of the file contains a fully rigorous list of the proofs of the theorems. Keep only proven theorems with clear proofs. If a statement is flawed and you cannot fix it, remove it from output.md and instead add it to notes.md with explanation.
- Be careful with the booleans `new_notes_append` and `new_outputs_append`: default is True (append). Use False only when deliberately rewriting everything.

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (â‰¥200 words). Include concrete next-step suggestions. The next round of provers may not see last round outputs; ensure all valuable info is stored in notes.",
  "new_notes_md": "Markdown (KaTeX allowed). Usually appended to notes.",
  "new_notes_append": "True|False",
  "new_outputs_md": "Markdown (KaTeX allowed). Usually appended to output.md.",
  "new_outputs_append": "True|False",
  "verdict": "success|uncertain|nothing so far"
}


--- USER ---
You receive multiple prover reports. Evaluate correctness, value, and pick promising directions. Update notes.md (append/replace) with useful ideas and update output.md (append/replace) ONLY with rigorously verified results.

Prover reports (JSON):
[{"prover_id": "01", "progress_md": "Goal and target claim\n- Target we propose to prove: If an LCL \u03a0 on bounded-degree (nonoriented) trees admits a deterministic online-local algorithm with constant locality r = O(1), then \u03a0 has a deterministic LOCAL (message-passing) algorithm with round complexity O(log* n).\n- Why useful: This gives the desired speedup from the online local model to the standard LOCAL model on trees, matching the \u0398(log* n) symmetry-breaking regime and aligning with known classifications (Theorem 2.33 in the attached notes).\n\nIdea in one sentence\n- Reduce a constant-radius deterministic online-local algorithm to a deterministic sequential local algorithm with the same radius, then simulate it in the LOCAL model by (i) computing an O(\u0394^{O(r)})-coloring of the power graph G^r in O(r log* n) rounds and (ii) executing r-round phases by colors; with \u0394 bounded and r = O(1), total is O(log* n).\n\nModel bridging and key lemmas (clean statements with \u201cwhy useful\u201d)\n- Lemma A (Online \u21d2 Sequential local, constant radius): Let \u03a0 be an LCL on bounded-degree graphs. If \u03a0 has a deterministic online local algorithm that (for any adversarial vertex order) decides each vertex\u2019s output using only its r-hop neighborhood and previously fixed outputs within that neighborhood, then \u03a0 admits a deterministic sequential local algorithm of local complexity r (in the sense of Definition 1.3 in the notes).\n  - Why useful here: The simulation framework (Theorem 2.5 in the notes) converts sequential local algorithms to distributed ones. This lemma lets us plug online-local algorithms directly into that framework.\n  - Proof sketch to be formalized: Fix any adversarial order; define the sequential rule to perform exactly the online rule when visiting a vertex, using already determined outputs in its r-hop neighborhood as the online algorithm would. Since the online algorithm must succeed for all orders, the resulting sequential algorithm succeeds for every order.\n\n- Lemma B (Power-graph coloring in O(log* n)): For any bounded-degree graph G and constant r, one can compute in the LOCAL model a proper coloring of G^r with O(\u0394(G^r)^2) = \u0394^{O(r)} colors in O(r log* n) rounds.\n  - Why useful here: The coloring provides a schedule with O(\u0394^{O(r)}) parallel phases in which vertices at pairwise distance > r act simultaneously without conflicts in the sequential simulation.\n  - Support: Linial\u2019s color reduction (Theorem 2.4 in the notes) computes a \u0394(G^r)^{O(1)}-coloring of G^r in O(log* n) rounds on G^r; simulating a G^r round on G costs r rounds \u21d2 total O(r log* n). (Bounded-degree implies \u0394(G^r) \u2264 \u0394^r.)\n\n- Lemma C (Color-phased simulation of sequential local A): Let A be a deterministic sequential local algorithm for \u03a0 of locality r. Given a proper coloring of G^r with c colors, one can simulate A in the LOCAL model in c \u00b7 O(r) additional rounds: process colors 1,2,\u2026,c; in color i, each vertex gathers the outputs (and any auxiliary state) within distance r restricted to colors < i and computes its own output/state by A.\n  - Why useful here: This yields a LOCAL simulation with round complexity c\u00b7O(r) = \u0394^{O(r)} for the simulation after the coloring is available.\n  - Correctness intuition: By definition of G^r-coloring, vertices of the same color are at distance > r, so their simulations do not depend on each other. Sequential local algorithms are defined to succeed regardless of order, so the color order is a valid global order.\n\n- Corollary (Putting B + C together): For bounded-degree graphs and constant r, the LOCAL round complexity is O(r log* n) (coloring) + \u0394^{O(r)}\u00b7O(r) (simulation). With \u0394 constant and r = O(1), this is O(log* n).\n  - Why useful here: It gives the exact O(log* n) bound we want for nonoriented trees (indeed, for any bounded-degree graphs).\n\nClarifying the online-local model assumptions (potential gap to check)\n- We are relying on the version of the deterministic online local model in which:\n  1) Vertices are processed in an adversarial order; upon processing a vertex u, the algorithm can only inspect B(u,r) in the current graph and the already-fixed outputs in that ball; the choice is irrevocable.\n  2) The algorithm must succeed for every adversarial order. \n- This matches the \u201csequential local algorithm\u201d model in Definition 1.3 (deterministic, order-robust) once we fix r. If the online model allowed dependence on future arrivals (it shouldn\u2019t) or only guaranteed success for a specific order, Lemma A would fail. Action item: confirm that the online-local definition we use matches [Akb+23; Chang et al. 2023] for trees.\n\nExamples/sanity checks\n- Example 1: Weak 2-coloring on bounded-degree trees. Known to be solvable in constant locality sequentially; by our pipeline, LOCAL complexity O(log* n) \u2014 consistent with classic results.\n- Example 2: Sinkless orientation on trees. Known deterministic LOCAL lower bound is \u03a9(log n) (Theorem 2.15); thus no constant-radius deterministic online algorithm can exist, consistent with the contrapositive.\n\nObstacles and subtle points\n- Port numbering/orientation: Our argument does not require oriented trees. Linial\u2019s color reduction and the power-graph coloring use unique IDs; they do not need a global orientation. The LCL constraints are checked on unlabeled, port-numbered neighborhoods as usual.\n- Auxiliary state in sequential algorithms: Definition 1.3 allows storing auxiliary state at each step. In the LOCAL simulation, we carry auxiliary state along phases as metadata; only the final \u201coutput label\u201d needs to satisfy \u03a0. This is standard in the Theorem 2.5 simulation.\n- Dependence on \u0394 and r: The number of colors c in the G^r-coloring is \u0394^{O(r)}. Since we restrict to bounded-degree trees and r = O(1), c = O(1); hence the c\u00b7O(r) term is constant, leaving O(log* n) overall due to the coloring step.\n\nRelation to known results (how this fits in the literature)\n- This is a specialization of Theorem 2.5 (sequential \u21d2 distributed simulation via coloring) to the case t = r = O(1), plus Lemma A to bridge from online-local to sequential-local. The resulting O(log* n) bound recovers the symmetry-breaking regime on trees (Theorem 2.33), and works in the nonoriented setting.\n- Note: The statement actually holds on any bounded-degree graph, not only trees; we emphasized trees to match the task wording.\n\nActionable next steps to move to output.md\n- Formalize Lemma A with a precise definition of the deterministic online-local model; include a short proof that it induces a deterministic sequential local algorithm of the same locality r.\n- State and prove Lemma B with an explicit citation to Linial\u2019s color reduction and the simulation overhead to work on G instead of G^r.\n- State and prove Lemma C (the color-phased simulation) carefully, including the auxiliary state bookkeeping and the per-phase O(r) implementation details (what needs to be communicated each phase).\n- Combine the lemmas into the main theorem for bounded-degree (nonoriented) trees, explicitly tracking constants: total rounds O(r log* n) + \u0394^{O(r)}\u00b7O(r) = O(log* n).\n\nNotes on gaps/missing justifications in output.md\n- There is currently no output.md provided; hence no curated results to audit. When drafting output.md, please include: (i) precise model definitions, (ii) the three lemmas above with proofs, (iii) the combined theorem, and (iv) a short remark that the proof does not use orientation of the tree.\n"}, {"prover_id": "02", "progress_md": "Ideas and goal\n- Target claim (tree version of \u201cspeedup\u201d): Let \u03a0 be an LCL on bounded-degree, unoriented trees. If \u03a0 has a deterministic online-LOCAL algorithm with constant round complexity t = O(1), then \u03a0 has a deterministic LOCAL (standard distributed) algorithm with round complexity O(log* n).\n- Intuition: Fix any online algorithm A that works for every arrival order. We will impose an artificial arrival order derived from a distance-(2t) vertex coloring and then simulate A in phases of colors. Computing such a distance coloring takes O(t\u00b7log* n) rounds in LOCAL on bounded-degree graphs (via Linial\u2019s color reductions on the power graph). The phase-by-phase simulation of A costs O(1) additional rounds since the number of colors is a \u0394^{O(t)} constant. Therefore, total complexity is O(log* n).\n\nModel alignment and assumptions to state precisely\n- Online-LOCAL (deterministic), following Akbari\u2013Eslami\u2013Lievonen\u2013Melnyk\u2013S\u00e4rkij\u00e4rvi\u2013Suomela (ICALP\u201923): vertices arrive in an adversarial order; when a vertex v arrives, edges to previously arrived neighbors are revealed; the algorithm may perform t synchronous LOCAL rounds on the current revealed graph to decide the output for v (deterministically), and outputs are irrevocable. The LCL \u03a0 has checkability radius r\u03a0.\n- LOCAL (deterministic): standard model with unique IDs from poly(n) and synchronous message passing. We are allowed O(log* n) time. Degree \u0394 is a fixed constant (bounded-degree trees).\n- Nonoriented tree: no global edge orientation is given; port numbers may be arbitrary; our construction does not assume any edge orientation.\n\nKey technical ingredients\n1) Distance-power coloring in O(log* n):\n   - For any fixed k = O(1), we can compute a proper coloring of G^k (i.e., nodes at distance \u2264 k get distinct colors) with C = \u0394^{O(k)} colors in O(k\u00b7log* n) LOCAL rounds. This follows by running Linial\u2019s color reduction (Theorem 2.4 in the Rozho\u0148 notes) on the power graph G^k; one round in G^k is simulated by k rounds in G. For bounded \u0394 and fixed k, the number of colors C is a constant independent of n.\n   - Why useful here: If nodes of the same color are at distance > 2t, then their t-hop neighborhoods in G are disjoint. This enables parallel, interference-free simulation of online steps for all nodes of the same color.\n\n2) Color-phased simulation of an online algorithm:\n   - Let A be a deterministic online-LOCAL t-round algorithm for \u03a0 that succeeds for all arrival orders. Compute a distance-(2t) coloring \u03c6: V\u2192[C]. We define a canonical arrival order compatible with \u03c6: all nodes of color 1 arrive first (in any order), then all of color 2, \u2026, up to color C. Since A works for all orders, it works for this order.\n   - We simulate this order in LOCAL as follows. We proceed in phases i = 1,2,\u2026,C.\n     \u2022 In phase i, all nodes v with \u03c6(v)=i simultaneously \u201carrive\u201d and run A for t rounds, but communication is restricted so that they only exchange messages with already \u201carrived\u201d nodes (colors < i) and other newly arrived nodes in their own radius-t neighborhoods. Nodes of colors > i remain passive.\n     \u2022 Because \u03c6 is a distance-(2t) coloring, for any two nodes v,w with \u03c6(v)=\u03c6(w)=i we have dist(v,w)>2t, so B(v,t) and B(w,t) in G are disjoint. Hence their t-round simulations touch disjoint parts of the revealed subgraph and can be done in parallel without conflicts.\n   - Practical implementation detail: To enforce the restriction \u201conly talk to earlier colors\u201d, each node exchanges color values with neighbors, and in phase i, nodes with colors > i simply ignore messages (remain silent). Nodes of color i can collect all needed information from their radius-t region intersected with colors < i.\n\n3) Inductive correctness of the simulation:\n   - Invariant I(i): After phase i, all nodes with colors \u2264 i have outputs exactly matching those produced by running A on the arrival order in which colors 1,\u2026,i have arrived (in any internal order) and other nodes have not arrived yet.\n   - Base i=0: vacuous. \n   - Step i\u2192i+1: For any v with \u03c6(v)=i+1, the t-round transcript available to v during phase i+1 in our simulation depends only on the already fixed outputs of nodes with colors \u2264 i and the structure of the revealed subgraph within distance t from v. This transcript is identical to what A would see when v arrives next in the chosen arrival order, because nodes with colors \u2264 i have already \u201carrived\u201d (their outputs fixed) and nodes with colors > i+1 have not arrived and remain silent. Since simulations of nodes of color i+1 run in disjoint t-neighborhoods, we can fix their outputs simultaneously without interference. Hence I(i+1) holds.\n   - At the end of phase C, all nodes are assigned outputs equal to running A on the full arrival order determined by colors. Since A is correct for any order, the output labeling satisfies \u03a0.\n\n4) Complexity accounting:\n   - Coloring: O(2t\u00b7log* n) = O(log* n) rounds (since t=O(1)). Number of colors C = \u0394^{O(2t)} = constant (independent of n).\n   - Simulation of phases: C phases, each needing t rounds of local messaging restricted to earlier colors. Total O(C\u00b7t) = O(1).\n   - Overall: O(log* n) deterministic LOCAL algorithm.\n\nFormal statement (to be checked and polished)\nTheorem (Online-to-LOCAL speedup on bounded-degree trees). Let \u03a0 be an LCL with checkability radius r\u03a0 on the class of bounded-degree trees (maximum degree \u0394). Suppose \u03a0 has a deterministic online-LOCAL t-round algorithm A for some constant t. Then \u03a0 has a deterministic LOCAL algorithm with round complexity O(log* n).\n\nSketch proof: As above, using a distance-(2t) coloring of G and phase-by-phase simulation of A. The only model-specific subtlety is ensuring that in phase i, nodes with colors > i are silent so the new nodes only access the \u201crevealed\u201d portion, exactly as in the online process. The distance-(2t) coloring guarantees disjointness of the t-neighborhoods of simultaneously arriving nodes, so their simulations are independent. Since A is deterministic and succeeds for all arrival orders, correctness follows for the specific color-induced order.\n\nNotes and why trees/nonorientation\n- The proof as written uses only bounded degree and does not exploit any particular property of trees beyond the bounded degree. Thus, the same speedup holds for general bounded-degree graphs under the same online-LOCAL definition. Since the task asked for trees, we have specialized the statement, but the argument is robust to extension.\n- No global orientation is required anywhere; we do not require rooted trees or consistent port orderings beyond what standard LOCAL presumes.\n\nExamples / sanity checks\n- If \u03a0 is trivial (e.g., a constant labeling), then the construction yields O(log* n) trivially. \n- If \u03a0 is 2-coloring of bipartite trees, and if there existed a deterministic O(1)-round online algorithm, our reduction would produce an O(log* n)-round LOCAL algorithm, which is consistent with the known \u0398(log* n) bounds on cycles/grids and with tree LCL classifications (Theorem 2.33 in the Rozho\u0148 notes).\n\nPotential obstacles and how we address them\n- Does the online algorithm use global knowledge (e.g., n)? In online-LOCAL as per [Akb+23], nodes do not know n, and here t is constant, so our simulation does not require such knowledge.\n- Does it matter that online processes one vertex at a time while we process an entire color class in parallel? No: distance-(2t) separation ensures that nodes in the same color do not interact within t rounds of A. Hence parallelization is safe.\n- Checkability radius r\u03a0: A may decide at v even if some constraints with not-yet-arrived neighbors cannot be checked yet. Our simulation mirrors the exact run of A under the chosen order, so the final labeling is valid by A\u2019s correctness.\n\nPrecise lemmata proposed for formal write-up\n- Lemma 1 (Distance-power coloring): For fixed k and bounded \u0394, there is a deterministic LOCAL algorithm that computes a proper coloring of G^k with \u0394^{O(k)} colors in O(k\u00b7log* n) rounds.\n- Lemma 2 (Phase-locality): If \u03c6 is a proper coloring of G^{2t}, then for any color i, the t-hop neighborhoods B(v,t) for nodes v with \u03c6(v)=i are pairwise disjoint. \n- Lemma 3 (Faithful phase simulation): Given a deterministic online-LOCAL t-round algorithm A and a color order 1,\u2026,C, the phase i simulation in which nodes of color i interact only with nodes of colors < i for t rounds produces exactly the outputs A would produce if nodes arrived in that color order.\n- Theorem (Speedup): Combine Lemmas 1\u20133 and the \u201cworks for all orders\u201d property.\n\nWhy useful here\n- This yields the desired O(log* n) upper bound from any constant-round deterministic online-LOCAL upper bound. It matches the known folklore that order-based/online constant-time local rules can be turned into LOCAL algorithms with only the symmetry-breaking overhead of computing a distance coloring (O(log* n)).\n\nGaps/open points to clarify in the next round\n- Precisely restate the online-LOCAL model we assume (cite [Akb+23]) and check that the above simulation conforms to it (e.g., whether earlier nodes may continue to communicate after committing their outputs; our simulation allows t rounds of interaction per phase, which matches per-arrival t rounds).\n- Fix exact distance parameter for coloring: 2t suffices for independence of t-neighborhoods; if we prefer extra slack, 2t+1 can be used with identical asymptotics.\n- Make explicit the handling of port numbering and input labels in LCL definition; the proof is oblivious to these details.\n\nRelation to literature\n- The simulation mirrors the sequential-to-distributed simulation principle (Theorem 2.5 in the Rozho\u0148 notes) but replaces \u201csequential local\u201d by \u201conline-LOCAL\u201d and avoids network decomposition; distance-power coloring suffices on bounded-degree graphs to get O(log* n). \n- The distance-power coloring step is a direct application of Linial\u2019s O(log* n) coloring reductions on power graphs (Theorem 2.4), and standard \u201csimulate G^k by k rounds in G\u201d.\n\nStatus of outputs\n- There is no output.md provided; hence no existing curated results to correct. The above provides a concrete reduction plan, key lemmata, and a proof skeleton ready to be formalized.\n\nNext steps\n- Write the full formal proof with the three lemmata and the main theorem, with all radii/constants explicit and a rigorous induction over color phases.\n- Add a short discussion that the same argument actually applies to bounded-degree graphs beyond trees, if desired by the project scope.\n- Consider an extension to randomized online algorithms (expecting a similar speedup to randomized LOCAL with O(log* n) or to deterministic LOCAL via derandomization), and map the exact bounds (optional)."}]

Current notes.md:


Current output.md (if any):

