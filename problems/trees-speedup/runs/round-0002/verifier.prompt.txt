--- SYSTEM ---
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (summary so far)
- output.md (rigorously proven results so far)

Guidelines:
- notes.md: should be a readable running log of interesting work. Prefer appending. Replace only if old notes are clearly misleading. Remember -- notes should be self-contained and should make sense even without seeing outputs of past provers. 
- output.md: should be concise and rigorous. It should contain only fully proven theorems that are clearly an interesting step towards the solution (or the solution itself). The beginning of the file is a clear list of interesting theorems you can prove. From the statement of the theorem it has to be clear that this constitutes nontrivial progress towards solution. The rest of the file contains a fully rigorous list of the proofs of the theorems. Keep only proven theorems with clear proofs. If a statement is flawed and you cannot fix it, remove it from output.md and instead add it to notes.md with explanation.
- Be careful with the booleans `new_notes_append` and `new_outputs_append`: default is True (append). Use False only when deliberately rewriting everything.

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (≥200 words). Include concrete next-step suggestions. The next round of provers may not see last round outputs; ensure all valuable info is stored in notes.",
  "new_notes_md": "Markdown (KaTeX allowed). Usually appended to notes.",
  "new_notes_append": "True|False",
  "new_outputs_md": "Markdown (KaTeX allowed). Usually appended to output.md.",
  "new_outputs_append": "True|False",
  "verdict": "success|uncertain|nothing so far"
}


--- USER ---
You receive multiple prover reports. Evaluate correctness, value, and pick promising directions. Update notes.md (append/replace) with useful ideas and update output.md (append/replace) ONLY with rigorously verified results.

Prover reports (JSON):
[{"prover_id": "01", "progress_md": "Summary of status and gaps\n- The archived output (Theorem A, Lemma 1\u20132, Corollary A) cleanly proves the O(log* n) speedup on bounded-degree trees for the order-robust r-local sequential model (aka \u201cgreedy sequential local\u201d), with the important restriction \u201creads within distance \u2264 r, writes only at the current vertex\u201d. This is correct and standard.\n- However, the task statement requests the speedup for a \u201cdeterministic online local model\u201d. In the literature there are two different models under this name:\n  1) Order-robust r-local sequential model (what we already handled in output.md).\n  2) Online-LOCAL(t) model of Akbari\u2013Eslami\u2013Lievonen\u2013Melnyk\u2013S\u00e4rkij\u00e4rvi\u2013Suomela (ICALP\u201923): when a vertex arrives, the algorithm is allowed t synchronous LOCAL rounds on the subgraph induced by arrived vertices; over many arrivals, long-range state/message propagation can accumulate across arbitrarily many t-round windows.\n- The color-phased simulation we sketched in earlier rounds does not in general simulate (2), due to unbounded long-range state accumulation before a vertex arrives. The output.md already includes a remark acknowledging this gap.\n\nNew incremental results and proposals\n1) Clarify the model target and add a safe variant we can prove now\n- Definition (Output-only Online-LOCAL(t)). A deterministic online algorithm is output-only if an arrived vertex irrevocably sets its output, and thereafter any messages it sends in subsequent arrivals depend only on the underlying graph and the immutable outputs in its radius-t (no auxiliary mutable state beyond fixed outputs; previously arrived vertices do not maintain or evolve additional state across arrivals other than their final output label).\n- Lemma O1 (Output-only online \u21d2 sequential r-local). Let \u03a0 be an LCL on bounded-degree graphs. If \u03a0 has a deterministic output-only Online-LOCAL(t) algorithm, then \u03a0 has a deterministic order-robust r-local sequential algorithm with r = t that reads only B(v,t) and writes only at v.\n  Why useful: This bridges a natural restriction of the online model to the sequential model covered in output.md, yielding O(log* n) LOCAL time on bounded-degree trees.\n  Proof sketch (checkable): Fix any arrival order that first lists all vertices with colors < i, then color i, etc., derived from a proper coloring of G^t. For a vertex v, the t-round transcript relevant to determining v\u2019s output depends only on the outputs within B(v,t), by the output-only restriction. Hence a sequential rule that, upon processing v, gathers outputs in B(v,t) and applies the online decision procedure produces the same output as the online algorithm on any arrival order consistent with those outputs; order-robustness then holds by the online algorithm\u2019s correctness for all orders.\n  Consequence: Combining Lemma O1 with Lemma 1\u20132 from output.md yields an O(log* n) LOCAL algorithm on bounded-degree trees.\n\n2) Minimal counter-scenario illustrating the gap for general Online-LOCAL(t)\n- Consider a path and t = 1. In the genuine online model, before some vertex v arrives, there may have been \u0398(n) earlier arrivals, each granting one synchronous round on the entire arrived subgraph. Information originating far away can propagate one hop per arrival and reach B(v,1) by the time v arrives. In a color-phased simulation that grants only O(1) rounds before v\u2019s phase, such accumulated state within B(v,1) is not reproduced. Hence, without extra assumptions, we cannot claim that our phase simulation computes the same output as the online algorithm would under any fixed arrival order.\n- This shows that to leverage an online algorithm as a black-box subroutine, we need a restriction (like output-only) preventing long-range state effects from being essential to v\u2019s decision.\n\n3) Special-case sanity checks on trees\n- Positive example (fits our proven pipeline): MIS/greedy maximal matching on trees admits a deterministic order-robust sequential r-local algorithm with r = 1 (reads only outputs of earlier neighbors and writes only at v). Our output.md pipeline yields O(log* n) LOCAL as expected.\n- Negative intuition for general Online-LOCAL(t): If an online algorithm uses persistent mutable state at arrived nodes, then even on trees it may encode far-away information inside B(v,t) before v\u2019s arrival. Our current simulation does not account for this. We have not yet constructed a concrete LCL that exploits this to beat O(log* n), and Theorem 2.33 (classification on trees) suggests such a separation is unlikely. Still, a proof that state can be eliminated is needed to complete the general reduction.\n\n4) A concrete \u201cstate-elimination\u201d goal for the full Online-LOCAL(t) model on trees\n- Target Lemma (to prove next): For bounded-degree trees and fixed t = O(1), any deterministic Online-LOCAL(t) algorithm for an LCL \u03a0 can be transformed into an equivalent output-only Online-LOCAL(t) algorithm (or into an order-robust sequential r-local algorithm with r = O(t)), without increasing locality. Intuition: On trees, the influence of nodes outside B(v,2t) on v\u2019s decision must pass through the annulus R = B(v,2t)\\B(v,t). If auxiliary state is unbounded, in principle R could encode arbitrarily long histories. However, because \u03a0 has finite checkability radius and t is constant, we conjecture that for deciding v\u2019s output there exists a constant-size canonical summary of the interface over R, depending only on the final outputs in B(v,2t). If so, auxiliary state can be replaced by a local function of outputs in B(v,2t), and thus eliminated.\n- Why plausible on trees: The absence of cycles suggests a finite \u201ccontext automaton\u201d across a cut; any information flowing from outside must cross the cut and influence the inside only via a constant-depth, constant-degree neighborhood, potentially yielding a finite equivalence of contexts. Yet, the caveat is that nodes in Online-LOCAL(t) have unbounded memory; any proof must show that unbounded histories are irrelevant for the final LCL outputs at constant-radius decisions.\n- Plan to attack: Start with paths and t = 1. Formalize the notion of an \u201cinterface context\u201d at the boundary \u2202B(v,2), and show that for any two online executions producing the same outputs on B(v,2), the set of feasible outputs for v is identical. If this holds, we can define a sequential rule depending only on outputs in B(v,2). Extend to general t by replacing 2 with 2t. If counterexamples exist on paths, we will pivot to a separation attempt.\n\n5) Alternative route (if state-elimination fails): A separation attempt\n- Try to construct an LCL \u03a0 on bounded-degree trees for which there is a constant-t deterministic Online-LOCAL(t) algorithm that crucially uses accumulated mutable state, and yet any order-robust r-local sequential algorithm would require r growing with n (or does not exist). This would invalidate the desired speedup under the full Online-LOCAL(t) definition and justify restricting the theorem to the sequential/greedy or output-only variants.\n- Candidates to explore: LCLs that encode a long-range parity/potential propagated along the tree via mutable state before a node is processed. We will start with paths, try to enforce via local constraints that the propagated value is globally consistent, and test whether this yields any advantage over the standard O(log* n) symmetry-breaking barrier. Given Theorem 2.33, the end complexity class on trees should still be O(log* n), suggesting that either such an LCL cannot benefit from Online-LOCAL(t), or it is simulable by sequential rules of constant radius.\n\nWhat to add/adjust in output.md\n- Make explicit (in the Model and definitions) that the archived Theorem A applies to sequential/greedy, order-robust r-local rules which write only at the current vertex; emphasize that this is the \u201conline local\u201d variant covered.\n- Add Lemma O1 to the archived list as a bridge from an output-only Online-LOCAL(t) algorithm to the sequential model already handled. This covers a meaningful online variant and clarifies the scope.\n- Keep the current remark on the full Online-LOCAL(t) model and expand it with the \u201cstate-elimination\u201d target lemma stated above as an open step.\n\nNext concrete steps\n- Formalize and prove Lemma O1 rigorously (definitions and proof details are straightforward and checkable).\n- Begin the path/t = 1 case study for state-elimination:\n  \u2022 Precisely define the interface \u2202B(v,2) and the annulus R = B(v,2)\\B(v,1).\n  \u2022 Show that if two online executions agree on outputs in B(v,2), then any valid output for v in one execution is valid in the other (towards context-independence of far-away state). If true, set r = 2 for paths.\n  \u2022 Either obtain a proof (yielding an order-robust sequential rule with r = 2 on paths), or construct a counterexample LCL on paths demonstrating dependence on accumulated state inside B(v,1).\n- If the path case succeeds, generalize to trees and t > 1 by induction on t using the same interface argument with \u2202B(v,2t).\n\nReferences and alignment\n- Online-LOCAL(t) model: Akbari et al., ICALP\u201923.\n- Tree LCL classification: Theorem 2.33 in the attached notes; supports the expectation that O(log* n) is the relevant upper bound on trees in the sublogarithmic regime.\n- Our proof tools for the sequential-to-LOCAL step (Linial\u2019s coloring on power graphs) do not use orientations and hence apply directly to nonoriented trees.\n"}, {"prover_id": "02", "progress_md": "Ideas\n- Clarify target model and bridge. The archived Theorem A already proves the O(log* n) speedup from an order-robust r-local sequential algorithm that only writes the output at the current vertex. To reach the stated Online-LOCAL(t) goal, we propose the following incremental plan.\n  1) Define a t-local-dependence property for deterministic Online-LOCAL(t): when vertex v arrives, its output depends only on the induced arrived subgraph inside B(v,t) and the already fixed outputs in that ball (no dependence on mutable state originating outside B(v,t)).\n  2) Lemma (Online-LOCAL(t) with t-local-dependence \u21d2 sequential r-local): Under this property, fixing any arrival order produces a local decision rule of radius r=t that is order-robust and writes only at the current vertex. This drops directly into Theorem A, giving O(log* n) in LOCAL.\n  3) Conversion attempt on trees: For LCLs on bounded-degree trees, try to transform any constant-t Online-LOCAL algorithm into one satisfying t-local-dependence with the same t (or t\u2032=O(t)). Intuition: on trees, arrivals at distance >2t commute (their effects on B(v,t) do not interact), and an adversarial order certification plus a confluence-style argument should let us \u201cerase\u201d far-away influences without affecting correctness.\n\nExamples and sanity checks\n- Toy counterexample to naive phase compression (why we need the extra property). Consider a path and t=1. In a genuine online run that processes almost all nodes on the left before v, one-hop state can per-arrival propagate across the path and reach the neighbors of v before v arrives. A color-phased simulation that grants only O(1) rounds before v\u2019s phase cannot reproduce these accumulated states. Hence the earlier invariant \u201csimulate an identical transcript\u201d fails in the unrestricted online model.\n- Benign class where the reduction works: problems for which nodes never maintain auxiliary state, and per-arrival message contents are functions of already fixed outputs within distance \u2264t (e.g., greedy MIS/Maximal Matching in their purely local sequential guise). These satisfy t-local-dependence and are covered by Theorem A via the proposed Lemma.\n\nObstacles\n- Unrestricted Online-LOCAL(t) admits unbounded many t-round windows before a vertex arrives; local states in B(v,t) may depend on far-away arrivals via long chains of arrived vertices. Without t-local-dependence, a color-phased simulation cannot in general reconstruct the per-arrival transcript or even guarantee correctness.\n- Confluence on trees is nontrivial: While arrivals at distance >2t commute, establishing a global Church\u2013Rosser\u2013type property that yields a canonical local state in B(v,t) independent of far-away order requires careful formalization of the per-arrival t-round \u201crewrite steps\u201d.\n\nProposed lemmas (clean, checkable)\n- Definition (t-local-dependence). A deterministic Online-LOCAL(t) algorithm A has t-local-dependence if, when vertex v arrives, its output is a function of the arrived subgraph induced in B(v,t) and of the already fixed outputs within B(v,t); in particular, it does not depend on any additional mutable states in B(v,t) that could have been imported from beyond B(v,t).\n- Lemma 1 (Bridge under t-local-dependence). If \u03a0 has a deterministic Online-LOCAL(t) algorithm with t-local-dependence, then \u03a0 has a deterministic order-robust t-local sequential algorithm that writes only at the current vertex. Why useful: plugs directly into Theorem A to get O(log* n) LOCAL on bounded-degree graphs.\n  Sketch: Fix any adversarial order. At v, read G[B(v,t)] and the outputs already fixed within B(v,t). By t-local-dependence, this determines exactly the output that A would produce when v arrives under that order; writing only at v yields an order-robust sequential rule.\n- Lemma 2 (Power-graph coloring as in output.md). Already archived; we will use k=r=t.\n- Lemma 3 (Color-phased simulation of order-robust rules). Already archived; note the \u201cwrites only at v\u201d hypothesis. If a rule may write to neighbors, replace G^r-coloring by G^{2r}-coloring; the asymptotics on bounded-degree graphs remain O(log* n).\n\nNext steps (auditable)\n- Formalize Lemma 1 and add to output.md the \u201cwrites only at v\u201d caveat explicitly (or the G^{2r} variant). Provide a crisp proof.\n- Attempt a tree-specific conversion from arbitrary Online-LOCAL(t) to t-local-dependence. Plan: model each arrival as a local rewrite acting on radius-t views; prove commutativity for arrivals at distance >2t; use acyclicity of trees to show that the local state in B(v,t) at the time v arrives has a canonical form depending only on outputs in B(v,t). If successful, this removes the extra assumption on trees.\n- In parallel, explore lower bounds: adapt round-elimination or known hard LCLs on trees (e.g., sinkless orientation) to Online-LOCAL, aiming to show they require \u03a9(log n) even there. This would indirectly support the classification-based route: constant-time Online-LOCAL cannot handle the log n-class, hence any LCL solvable in O(1) Online-LOCAL sits in the O(1)/\u0398(log* n) bucket.\n- Construct toy counterexamples to test necessity/tightness of t-local-dependence: try to design an LCL and an Online-LOCAL(1) algorithm whose output at v provably depends on imported far-away state within B(v,1). If such an LCL exists, then the general reduction needs genuinely new ideas (or must fail for that problem).\n\nNotes on gaps or edits for output.md\n- Lemma 2 currently assumes the sequential rule \u201creads within distance r and writes only at the current node\u201d; mention this hypothesis explicitly. If one wishes to allow writing to neighbors within distance r, modify the coloring to G^{2r} to ensure independence of same-color phases.\n- The remark about Online-LOCAL(t) correctly flags the key gap: unlimited accumulation of state prior to an arrival. We will add Definition/Lemma (t-local-dependence and bridge) if the verifier agrees; this would document a precise condition under which the claimed speedup is valid for online algorithms as well.\n\nWhy this is progress\n- We identified the precise barrier preventing a direct reduction from Online-LOCAL(t) to LOCAL and proposed a concrete, checkable locality-of-dependence condition that suffices to bridge the models.\n- We outlined a tree-specific confluence program that, if proven, removes the extra assumption and would settle the original task.\n- We gave a tight modification to the archived Lemma 2 concerning writing side effects and the need for G^{2r}-coloring, which the verifier can incorporate immediately.\n"}]

Current notes.md:
Context and goal
We study the relationship between online-style constant-locality algorithms for LCLs on bounded-degree, unoriented trees and deterministic LOCAL-time upper bounds. Two notions of “online local” are relevant:
- Sequential local/greedy model (order-robust r-local): when processing a vertex v, the decision at v depends only on the r-hop neighborhood B(v,r) of the underlying graph and on already fixed outputs within B(v,r); the algorithm must succeed for every vertex order. No global mutable state or long-range message accumulation between steps.
- Online-LOCAL(t) (Akbari–Eslami–Lievonen–Melnyk–Särkijärvi–Suomela, ICALP’23): vertices arrive one by one; upon each arrival, the algorithm has t synchronous LOCAL rounds on the subgraph induced by arrived vertices; outputs are irrevocable. Over many arrivals, an unbounded number of communication rounds can occur, enabling long-range state accumulation.

Safe, proven variant (archived below in output.md)
- Theorem (Sequential-local to LOCAL): If an LCL Π on bounded-degree graphs has a deterministic order-robust r-local sequential algorithm (decisions at v depend only on B(v,r) and outputs of earlier vertices in B(v,r), and the rule writes only the output at v), then Π has a deterministic LOCAL algorithm running in O(r log* n + Δ^{O(r)}) rounds. On bounded-degree trees with constant r, this is O(log* n). Proof: compute a proper coloring of G^r in O(r log* n) rounds with Δ^{O(r)} colors; process color classes in order, letting each v gather outputs from B(v,r) restricted to earlier colors and apply the sequential rule. Because nodes of the same color are at distance > r, their decisions do not depend on each other.

Gap for the full Online-LOCAL(t) model
- A direct phase simulation that uses a distance-(2t) coloring and t rounds per color does not generally reproduce the state a node v would see upon arrival in an actual online execution. In a true online run, before v arrives, there may have been Θ(n) earlier arrivals, yielding Θ(n)·t global rounds; information can propagate arbitrarily far and may alter the states within B(v,t). The phase simulation grants only O(1)·t total rounds before v’s phase, so the local states can differ. Hence, without additional constraints, we cannot claim that the phase simulation faithfully reproduces the online run or even yields correctness solely from A’s correctness.

Ways forward for Online-LOCAL(t)
- Add a locality-of-dependence assumption: the t-round transcript that determines v’s output depends only on the arrived subgraph inside distance ≤ t from v and on the outputs of those nodes, not on mutable states imported from farther away. Under this, distance-(2t) coloring plus phase simulation is valid and yields O(log* n).
- Alternatively, seek a structural scheduling/padding argument ensuring that for LCLs on bounded-degree trees, the state within B(v,t) before v’s arrival is independent of far-away arrivals. This is nontrivial; try first on paths/trees with t=1 to see whether accumulation can matter for any LCL.
- Or try to separate the models: construct an LCL that is solvable in constant t in Online-LOCAL but provably not simulable by the above constant-phase compression; if such an LCL exists, the general reduction fails, and the sequential-local variant becomes the correct target.

Remarks
- No global edge orientation is needed anywhere in the reduction we proved; IDs suffice for coloring.
- The archived proof applies to all bounded-degree graphs; we stated trees to match the project focus.


Current output.md (if any):
List of proven results archived here
- Theorem A (Sequential-local to LOCAL on bounded-degree graphs).
- Lemma 1 (Power-graph coloring in O(k log* n)).
- Lemma 2 (Color-phased simulation for order-robust r-local rules).
- Corollary A (Bounded-degree trees, constant r ⇒ O(log* n)).

Model and definitions
- Graphs: finite, simple, maximum degree Δ < ∞ (bounded degree). Nodes have unique IDs from a polynomial range (standard LOCAL assumptions). No global orientation is assumed.
- LCL Π: a locally checkable labeling problem with constant checkability radius r_Π (used only to define the problem; our algorithmic radii below are independent parameters).
- Order-robust r-local sequential algorithm: A deterministic rule A with locality parameter r such that, for any graph G in the class and any vertex order v_1,…,v_n, when processing vertex v_i, A reads G[B(v_i,r)] and the outputs already fixed on vertices in B(v_i,r) ∩ {v_1,…,v_{i-1}}, and writes the output at v_i. The final labeling satisfies Π for every order. (A does not write to any vertex other than the current v_i.)

Lemma 1 (Power-graph coloring in O(k log* n))
Statement. Let G be a bounded-degree graph and k ≥ 1 a constant. There is a deterministic LOCAL algorithm that computes a proper vertex coloring of the power graph G^k with at most C = O(Δ(G^k)^2) colors in O(k log* n) rounds on G. In particular, Δ(G^k) ≤ Δ^k, so C = Δ^{O(k)}.
Proof. It is known that in the LOCAL model one can compute a proper O(Δ(H)^2)-coloring of any graph H in O(log* n) rounds (Linial’s color-reduction). To color G^k while communicating on G, we simulate each round of the O(log* n)-round coloring algorithm on G^k by k rounds on G: in k rounds, every node can learn the IDs and temporary colors of all nodes at distance ≤ k in G, i.e., its neighbors in G^k. Thus, O(log* n) rounds on G^k translate to O(k log* n) rounds on G. The color bound follows from Δ(G^k) ≤ Δ^k. □

Lemma 2 (Color-phased simulation for order-robust r-local rules)
Statement. Let A be an order-robust r-local sequential algorithm for Π. Let φ:V→{1,…,C} be a proper coloring of G^r (i.e., nodes at distance ≤ r have distinct colors). Then there is a deterministic LOCAL simulation that processes colors 1,2,…,C and assigns the same outputs as A would when run on any order that first lists all nodes of color 1 (in any internal order), then color 2, and so on. The simulation uses O(r) rounds per color after φ is known.
Proof. Fix A and φ. Since φ is a proper coloring of G^r, if φ(u)=φ(v) then dist(u,v)>r, so B(u,r) and B(v,r) are disjoint from {v} and {u}, respectively; in particular, the decision at u under A can depend only on outputs of vertices strictly within B(u,r) and, hence, on colors < φ(u) if we process colors in increasing order. The simulation proceeds for i=1,…,C: in phase i, each vertex v with φ(v)=i performs the following in parallel: gather the outputs of vertices in B(v,r) with colors < i (this takes r rounds of communication, as outputs are already fixed for colors < i), then apply A’s local rule to determine v’s output. Because the rule reads only B(v,r) and writes only at v, and B(u,r) contains no vertex of color i other than u, all decisions in phase i are independent and match A’s decisions under any vertex order that respects the color layering. □

Theorem A (Sequential-local to LOCAL on bounded-degree graphs)
Statement. Let Π be an LCL on bounded-degree graphs. Suppose Π admits a deterministic order-robust r-local sequential algorithm A (as defined above). Then Π has a deterministic LOCAL algorithm running in O(r log* n + C·r) rounds, where C = Δ^{O(r)} depends only on Δ and r. In particular, for constant Δ and constant r, the round complexity is O(log* n).
Proof. Use Lemma 1 with k=r to compute a proper coloring φ of G^r in O(r log* n) rounds with C=Δ^{O(r)} colors. Then use Lemma 2 to simulate A by processing colors 1,…,C, spending O(r) rounds per color to collect outputs from earlier colors within distance r and decide the current color’s outputs. The total is O(r log* n + C·r). Correctness follows from Lemma 2. □

Corollary A (Bounded-degree trees, constant locality)
Statement. On bounded-degree, unoriented trees, if Π has a deterministic order-robust r-local sequential algorithm for some constant r, then Π has a deterministic LOCAL algorithm with round complexity O(log* n).
Proof. Trees are bounded-degree graphs; apply Theorem A. No edge orientation is used. □

Remark (about Online-LOCAL(t)). The results above do not cover the full Online-LOCAL(t) model in which each arrival grants t synchronous rounds and nodes may accumulate mutable state across arrivals. In that model, before a vertex arrives, arbitrarily many global t-round windows may have elapsed, potentially allowing long-range information to influence its local neighborhood. The phase-simulation argument requires an extra assumption restricting such long-range dependence (e.g., that a vertex’s output upon arrival depends only on the arrived subgraph within distance ≤ t and previously fixed outputs therein). Proving a general reduction under the unrestricted Online-LOCAL(t) model remains open here.

