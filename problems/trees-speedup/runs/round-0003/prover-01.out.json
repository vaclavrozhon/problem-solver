{
  "progress_md": "Ideas\n- Broadened bridge to capture online algorithms that may commit outputs beyond the arriving vertex. We define an \u201coutput-only, W-write\u201d Online-LOCAL(t) model: upon arrival of v, the algorithm runs t synchronous rounds on the arrived subgraph and irrevocably fixes outputs possibly on the W-neighborhood B(v,W); no other mutable state persists across arrivals and all messages sent by a node during this t-round window are functions only of the graph and currently known outputs within distance \u2264 t from the sender.\n- Why useful: This covers natural online local greedy rules that may finalize a small local patch around the arriving vertex. We prove a clean bridge to sequential-local rules with explicit read/write radii, which then drops into the color-phased LOCAL simulation pipeline.\n\nNew lemmas (clean, checkable)\n- Lemma D (Output-only, W-write Online-LOCAL(t) \u21d2 sequential local with (R,W) = (2t+W,W)).\n  Statement. Let \u03a0 be an LCL on bounded-degree graphs. Suppose there is a deterministic output-only, W-write Online-LOCAL(t) algorithm A that is correct for every arrival order. Then \u03a0 admits a deterministic order-robust sequential rule S that, when processing v, reads only outputs in B(v,2t+W), writes only on vertices in B(v,W), and is correct for every vertex order.\n  Proof sketch. Fix any vertex order \u03c3 = (v1,\u2026,vn). Consider the \u03c6-execution of A with arrivals \u03c3. When vi arrives, during its t-window only nodes u \u2208 B(vi,t) can send messages which reach B(vi,0). Each such u computes its messages as a function of outputs within B(u,t) by the output-only restriction; hence u\u2019s messages to the patch B(vi,W) depend only on outputs in B(vi, t+W) \u222a (\u22c3u\u2208B(vi,t) B(u,t)) \u2286 B(vi,2t+W). Therefore the full t-round transcript relevant to deciding outputs on B(vi,W) in the \u03c3-run depends only on the restriction of the arrived subgraph and already fixed outputs to B(vi,2t+W). Define S as follows: when processing vi in \u03c3, S gathers the outputs already fixed within B(vi,2t+W)\u2229{v1,\u2026,vi\u22121} and deterministically reproduces A\u2019s t-window decision for B(vi,W) given that local view. As A is deterministic and correct for all orders, S reproduces the same patch outputs as A in this order; order-robustness of S follows by the same order-by-color simulation used previously. S is (R,W) = (2t+W,W)-local.\n\n- Lemma E (LOCAL simulation for (R,W)-local sequential rules).\n  Statement. Let S be a deterministic sequential rule that, when processing v, reads only B(v,R) and writes only on B(v,W), for fixed constants R,W \u2265 0. Given a proper coloring of G^{R+W} with C colors, one can simulate S in the LOCAL model by processing colors 1,\u2026,C, using O(R) rounds per color. The simulation outputs exactly what S would produce for any order that respects the color layering.\n  Proof. If dist(u,v) > R+W and \u03c6(u) = \u03c6(v), then (i) B(u,R)\u2229B(v,R) = \u2205 and (ii) B(u,R) is disjoint from the write neighborhood B(v,W), and vice versa. Thus, within one color phase, decisions are independent. Each vertex of color i gathers the outputs written by earlier colors in B(v,R) (O(R) rounds), applies S, and writes within B(v,W). Correctness is identical to Lemma 2\u2019s argument. A coloring of G^{R+W} with C = \u0394^{O(R+W)} colors can be computed in O((R+W)\u00b7log* n) rounds by Lemma 1 simulated on G.\n\nCorollaries (bounded-degree trees \u21d2 O(log* n))\n- Corollary D. On bounded-degree trees, if \u03a0 has a deterministic output-only, W-write Online-LOCAL(t) algorithm with constants t,W, then \u03a0 has a deterministic LOCAL algorithm with round complexity O((2t+W)\u00b7log* n) + O(1) = O(log* n).\n  Reason: Apply Lemma D to get a (R,W)-local sequential rule with R = 2t+W, then Lemma E and Lemma 1.\n- Note existing special cases are recovered: W=0 gives Lemma B (R=2t), and \u201ct-local-dependence\u201d with W=0 gives Lemma C (R=t).\n\nExamples and sanity checks\n- Greedy (\u0394+1)-coloring online variant fixing a constant-radius patch: If at arrival of v the online rule picks a color for v and possibly finalizes colors of uncolored neighbors (W=1) using only the set of colors already fixed in B(v,1), then the rule is output-only, W-write with t=1. Corollary D yields an O(log* n) LOCAL algorithm on bounded-degree trees.\n- Greedy maximal matching: a variant that, at v\u2019s arrival, matches v to a free neighbor and possibly finalizes the matched pair (W=1), while sending messages depending only on currently fixed outputs within distance 1, meets the model; Corollary D applies.\n\nObstacles and model gaps (reiterated crisply)\n- The unrestricted Online-LOCAL(t) model allows arbitrary mutable state and unbounded accumulation of information before v arrives. The path/t=1 counter-scenario still shows naive phase compression is invalid without extra restrictions. Our bridges cover output-only (R=2t or 2t+W) and t-local-dependence (R=t), but the general state-elimination step remains open.\n\nState-elimination program (t=1 on paths) \u2014 concrete, testable steps\n- Formalize the \u201cinterface view\u201d at radius 2: for any vertex v on a path, define the context K(v) := restriction of outputs to B(v,2) at the time v arrives in an online execution. Target claim (Context-invariance): For any two online executions that agree on K(v), the set of outputs that the algorithm may produce at v is the same. If true, define a canonical tie-breaking function on K(v) to derive a sequential rule with R=2 and W determined by the online rule. Action items:\n  1) Model each arrival as a local rewrite on the current output labeling; record that in t=1, only the immediate neighbors of v can send messages to v during the window, and each of those neighbors\u2019 messages are functions of outputs in their own 1-neighborhood.\n  2) Attempt to construct a counterexample LCL where two executions with identical K(v) force different outputs at v. If found, local elimination at radius 2 fails; otherwise, prove the lemma.\n- Generalize: If the t=1 path case succeeds, extend to trees by handling the degree>2 case via boundary decomposition along paths to \u2202B(v,2). For general t, replace 2 by 2t; for W>0, consider K(v) extended to B(v,2t+W).\n\nEditorial notes on output.md\n- The newly added Variant of Lemma 2 for bounded-distance writes aligns with Lemma E above. Suggest adding Lemma D explicitly (output-only, W-write bridge with read radius 2t+W) to make the pipeline fully parametric in W. This will make it transparent how to handle online rules that finalize a constant-radius patch.\n- Minor clarity: In Lemma 1, it may help to note explicitly that in bounded-degree trees with constants \u0394 and k, the color count C = \u0394^{O(k)} is an absolute constant, so the per-color simulation overhead is O(1).\n\nWhy this is progress\n- We extend the safe, proven bridge to cover online rules that finalize constant-radius patches (common in greedy online/local designs), giving an immediate path to O(log* n) LOCAL algorithms on bounded-degree trees.\n- We outline a concrete, falsifiable \u201ccontext-invariance\u201d claim for the state-elimination program on paths with t=1, including what to prove or how to refute it with a counterexample LCL. This isolates the remaining conceptual barrier and provides a roadmap for the next proof or separation.\n\nNext steps (auditable)\n- Add Lemma D to output.md with a full proof (the proof follows the same envelope as Lemma B and is straightforward to formalize).\n- Start the path/t=1 case: either prove the context-invariance claim (produce a short inductive proof or a monotonicity argument) or construct a counterexample LCL. If proven, write the path/t=1 \u201cstate-elimination\u201d lemma; if refuted, document the counterexample precisely.\n- If bounded-distance writes are used (W>0), ensure the simulation uses G^{R+W} coloring (i.e., G^{2t+2W}) consistently; verify radii accounting in each step with small toy instances to avoid off-by-one errors.\n"
}