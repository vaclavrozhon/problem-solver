{"progress_md":"## Round 0003 — sharpening the bridge from Online-LOCAL(t) to LOCAL on trees\n\nSummary of status\n- output.md is now correct regarding the “output-only” bridge: the needed sequential locality is 2t (Lemma B) and can be tightened to t under the stronger t-local-dependence hypothesis (Lemma C). The color-phased simulation and the (R+W)-write variant are also stated cleanly.\n- The remaining gap for the unrestricted Online-LOCAL(t) model is the possibility of unbounded accumulation of mutable state before a vertex v arrives. We need additional structural arguments tailored to trees to remove this dependence.\n\nNew incremental results (clean statements with proofs)\n\n1) Commutativity of independent arrivals (a tool for order normalisation)\n- Lemma D (2t-commutativity of consecutive independent arrivals). Let A be a deterministic Online-LOCAL(t) algorithm on a bounded-degree graph. Consider an arrival sequence σ and two consecutive arrival steps at vertices u and w with dist(u,w) > 2t (distance in the underlying graph G). Let σ′ be obtained by swapping these two steps. Then the states and already-fixed outputs after executing these two steps under σ and under σ′ coincide everywhere; in particular, the outputs on B(u,t) ∪ B(w,t) and outside are identical.\n  - Proof sketch (checkable). In the step when u arrives in σ, A runs t synchronous LOCAL rounds on the current arrived graph G_i. All messages and updates during this window are confined to B(u,t) (messages can travel at most distance t in t rounds). Since dist(u,w) > 2t, we also have B(u,t) ∩ B(w,t) = ∅, and w is absent before either of the two steps in both σ and σ′. Moreover, in both orders, the set of previously arrived vertices intersected with B(u,t) is the same at the time u’s window runs, hence the local t-round transcript at nodes in B(u,t) is identical in σ and σ′, and the same updates occur there. The same argument applies to w’s step. Because the two windows touch disjoint node sets and no messages cross between them within t rounds, their effects commute, and all other nodes remain unaffected. □\n\n- Corollary D.1 (Pushing far-away arrivals past v). Fix v and any arrival sequence. By repeatedly applying Lemma D to adjacent independent steps, one can transform the sequence into another sequence in which (i) all vertices at distance > 2t from v arrive after v, and (ii) the outputs of all nodes and the states at the time v arrives on nodes within B(v,t) are identical to those in the original sequence.\n  - Why useful: It reduces the analysis of v’s decision to local arrival orders that involve only the ball B(v,2t). This finite-horizon reduction is independent of graph orientation and holds on all graphs.\n\n2) Consequence for dependence radius\n- Observation. Under Corollary D.1, we may w.l.o.g. assume that before v arrives, only vertices in B(v,2t) have arrived. Hence any information that can reach v during its t-round window originates within B(v,2t). This is consistent with Lemma B’s 2t radius for the output-only bridge and provides the right target radius for any state-elimination attempt on trees.\n\nNew approach outline: “Interface confluence” on trees for t=1\n- Goal (paths, t=1 case). Prove: For any deterministic Online-LOCAL(1) algorithm A and any LCL Π, after normalising the order as in Corollary D.1, the output at v depends only on (G[B(v,2)], outputs already fixed in B(v,2)]). Equivalently: mutable states of nodes in B(v,1) at v’s arrival can be replaced by canonical functions of outputs in B(v,2).\n- Why plausible on trees: When all arrivals before v lie in B(v,2), any message reaching v during its 1-round window comes from neighbors of v. Each neighbor’s outgoing message is computed using its current state, which itself resulted from arrivals in B(v,2) only. In a tree, one can attempt to summarise the influence of each branch by a finite “interface type” depending only on already-fixed outputs in that branch up to distance 2 from v.\n- Proposed technical route:\n  1) Define, for each neighbor u of v, the 1-hop interface type τ(u→v) as the set of all possible outgoing messages u would send to v at v’s arrival time, over all arrival orders restricted to B(u,1) consistent with the same already-fixed outputs in B(u,2). Show τ(u→v) is a function of the output-labeling of B(u,2) alone.\n  2) Show that the tuple of interface types around v, together with outputs already fixed in B(v,2), determines v’s t=1 transcript and hence v’s output. This would establish the desired (output-only) dependence for t=1 on paths; by a standard tree decomposition at v, extend to general trees.\n  3) Generalise to t > 1 by replacing radii 1 and 2 with t and 2t and defining depth-t interface types.\n- Obstacles: The interface type τ(u→v) as defined must be well-defined (independent of the arrival order within B(u,2)), which requires a local confluence argument. While Lemma D lets us push arrivals at distance > 2t past v, it does not by itself give confluence among different orders internal to B(u,2). Establishing that the set of feasible outgoing messages depends only on outputs (and not on internal mutable state histories) is the crux.\n\nWhy Lemma D is useful even without full state elimination\n- It strictly confines the relevant arrivals to B(v,2t) and eliminates concerns about “long-haul” state injected from beyond that radius. Any further dependence on arrival order or mutable state must be attributable to choices made entirely within B(v,2t). This localises the problem and suggests a finite-case analysis/state-aggregation strategy on trees.\n\nNotes on output.md (gaps and suggestions)\n- The current output.md correctly states and proves the bridges (Lemma B: radius 2t; Lemma C: radius t under t-local-dependence) and the simulation via coloring. No errors spotted.\n- Suggested addition for future versions: include Lemma D (2t-commutativity of independent arrivals) with proof and Corollary D.1. These will be useful scaffolding for the tree-specific state-elimination program, and they are correct for the unrestricted Online-LOCAL(t) model.\n\nExamples/sanity checks\n- Example (commutativity applicability). On a path with t=1, any two consecutive arrivals at nodes with distance ≥ 3 commute. Thus, when analysing v, we can always push all arrivals at distance ≥ 3 past v. The only potentially order-sensitive part is the sequence of arrivals within distance ≤ 2 of v.\n- Consistency with lower bounds. Sinkless orientation requires Ω(log n) deterministic LOCAL rounds on trees; by Corollary D.1, a hypothetical constant-time online algorithm would still have to resolve constraints within B(v,2t), which is consistent with known impossibility: we do not derive a contradiction but focus on the local reduction.\n\nNext steps (auditable action items)\n1) Formalise and prove Lemma D and Corollary D.1 in output.md, including precise quantification over states and message transcripts; this is model-agnostic and verifiable.\n2) Path, t=1 case study for interface confluence:\n   - Precisely define “interface type” and prove monotonicity properties (adding arrivals outside B(u,2) does not change τ(u→v) by Corollary D.1).\n   - Attempt to prove that for fixed outputs on B(u,2), τ(u→v) is a singleton (order-robust), or at least that the set of feasible messages has a canonical choice leading to a valid global solution. If successful, this yields the output-only bridge on paths with r = 2.\n3) If (2) succeeds, generalise to trees (branch-wise independence) and to general t by layered interfaces of depth t. If it fails, craft a concrete LCL counterexample on paths demonstrating genuine dependence on mutable state histories within B(v,2) (which would delimit the scope of the desired speedup).\n4) Keep tracking read/write distances carefully. If any future sequential rule writes within distance W > 0 (e.g., when extracting canonical choices), ensure to schedule by a G^{R+W}-coloring as already anticipated in output.md.\n\nWhy this is progress\n- We added a rigorously provable commutativity lemma (and corollary) that strictly localises the analysis to B(v,2t). This is a necessary stepping stone for any tree-specific state-elimination.\n- We laid out a concrete, checkable interface-aggregation program starting with paths and t=1, with clear success/failure outcomes to be tested next.\n"}