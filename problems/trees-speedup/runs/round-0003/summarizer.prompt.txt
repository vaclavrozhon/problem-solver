--- SYSTEM ---
You are a research **summarizer**. Summarize this *last round only* for a human log.

Include:
- 3–7 bullet **Highlights** (facts learned, reductions, counterexamples, partial bounds).
- 1–3 **Open questions / TODOs** for the next round.
- 1–3 **Citations to files** you relied on (e.g. round files or papers by name).

**Return strictly JSON**:
{
  "summary_md": "Readable summary of the round (≤200 words)",
  "highlights": [],
  "next_questions": []
}

--- USER ---
=== prover-01.out.json (progress_md) ===
Ideas
- Broadened bridge to capture online algorithms that may commit outputs beyond the arriving vertex. We define an “output-only, W-write” Online-LOCAL(t) model: upon arrival of v, the algorithm runs t synchronous rounds on the arrived subgraph and irrevocably fixes outputs possibly on the W-neighborhood B(v,W); no other mutable state persists across arrivals and all messages sent by a node during this t-round window are functions only of the graph and currently known outputs within distance ≤ t from the sender.
- Why useful: This covers natural online local greedy rules that may finalize a small local patch around the arriving vertex. We prove a clean bridge to sequential-local rules with explicit read/write radii, which then drops into the color-phased LOCAL simulation pipeline.

New lemmas (clean, checkable)
- Lemma D (Output-only, W-write Online-LOCAL(t) ⇒ sequential local with (R,W) = (2t+W,W)).
  Statement. Let Π be an LCL on bounded-degree graphs. Suppose there is a deterministic output-only, W-write Online-LOCAL(t) algorithm A that is correct for every arrival order. Then Π admits a deterministic order-robust sequential rule S that, when processing v, reads only outputs in B(v,2t+W), writes only on vertices in B(v,W), and is correct for every vertex order.
  Proof sketch. Fix any vertex order σ = (v1,…,vn). Consider the φ-execution of A with arrivals σ. When vi arrives, during its t-window only nodes u ∈ B(vi,t) can send messages which reach B(vi,0). Each such u computes its messages as a function of outputs within B(u,t) by the output-only restriction; hence u’s messages to the patch B(vi,W) depend only on outputs in B(vi, t+W) ∪ (⋃u∈B(vi,t) B(u,t)) ⊆ B(vi,2t+W). Therefore the full t-round transcript relevant to deciding outputs on B(vi,W) in the σ-run depends only on the restriction of the arrived subgraph and already fixed outputs to B(vi,2t+W). Define S as follows: when processing vi in σ, S gathers the outputs already fixed within B(vi,2t+W)∩{v1,…,vi−1} and deterministically reproduces A’s t-window decision for B(vi,W) given that local view. As A is deterministic and correct for all orders, S reproduces the same patch outputs as A in this order; order-robustness of S follows by the same order-by-color simulation used previously. S is (R,W) = (2t+W,W)-local.

- Lemma E (LOCAL simulation for (R,W)-local sequential rules).
  Statement. Let S be a deterministic sequential rule that, when processing v, reads only B(v,R) and writes only on B(v,W), for fixed constants R,W ≥ 0. Given a proper coloring of G^{R+W} with C colors, one can simulate S in the LOCAL model by processing colors 1,…,C, using O(R) rounds per color. The simulation outputs exactly what S would produce for any order that respects the color layering.
  Proof. If dist(u,v) > R+W and φ(u) = φ(v), then (i) B(u,R)∩B(v,R) = ∅ and (ii) B(u,R) is disjoint from the write neighborhood B(v,W), and vice versa. Thus, within one color phase, decisions are independent. Each vertex of color i gathers the outputs written by earlier colors in B(v,R) (O(R) rounds), applies S, and writes within B(v,W). Correctness is identical to Lemma 2’s argument. A coloring of G^{R+W} with C = Δ^{O(R+W)} colors can be computed in O((R+W)·log* n) rounds by Lemma 1 simulated on G.

Corollaries (bounded-degree trees ⇒ O(log* n))
- Corollary D. On bounded-degree trees, if Π has a deterministic output-only, W-write Online-LOCAL(t) algorithm with constants t,W, then Π has a deterministic LOCAL algorithm with round complexity O((2t+W)·log* n) + O(1) = O(log* n).
  Reason: Apply Lemma D to get a (R,W)-local sequential rule with R = 2t+W, then Lemma E and Lemma 1.
- Note existing special cases are recovered: W=0 gives Lemma B (R=2t), and “t-local-dependence” with W=0 gives Lemma C (R=t).

Examples and sanity checks
- Greedy (Δ+1)-coloring online variant fixing a constant-radius patch: If at arrival of v the online rule picks a color for v and possibly finalizes colors of uncolored neighbors (W=1) using only the set of colors already fixed in B(v,1), then the rule is output-only, W-write with t=1. Corollary D yields an O(log* n) LOCAL algorithm on bounded-degree trees.
- Greedy maximal matching: a variant that, at v’s arrival, matches v to a free neighbor and possibly finalizes the matched pair (W=1), while sending messages depending only on currently fixed outputs within distance 1, meets the model; Corollary D applies.

Obstacles and model gaps (reiterated crisply)
- The unrestricted Online-LOCAL(t) model allows arbitrary mutable state and unbounded accumulation of information before v arrives. The path/t=1 counter-scenario still shows naive phase compression is invalid without extra restrictions. Our bridges cover output-only (R=2t or 2t+W) and t-local-dependence (R=t), but the general state-elimination step remains open.

State-elimination program (t=1 on paths) — concrete, testable steps
- Formalize the “interface view” at radius 2: for any vertex v on a path, define the context K(v) := restriction of outputs to B(v,2) at the time v arrives in an online execution. Target claim (Context-invariance): For any two online executions that agree on K(v), the set of outputs that the algorithm may produce at v is the same. If true, define a canonical tie-breaking function on K(v) to derive a sequential rule with R=2 and W determined by the online rule. Action items:
  1) Model each arrival as a local rewrite on the current output labeling; record that in t=1, only the immediate neighbors of v can send messages to v during the window, and each of those neighbors’ messages are functions of outputs in their own 1-neighborhood.
  2) Attempt to construct a counterexample LCL where two executions with identical K(v) force different outputs at v. If found, local elimination at radius 2 fails; otherwise, prove the lemma.
- Generalize: If the t=1 path case succeeds, extend to trees by handling the degree>2 case via boundary decomposition along paths to ∂B(v,2). For general t, replace 2 by 2t; for W>0, consider K(v) extended to B(v,2t+W).

Editorial notes on output.md
- The newly added Variant of Lemma 2 for bounded-distance writes aligns with Lemma E above. Suggest adding Lemma D explicitly (output-only, W-write bridge with read radius 2t+W) to make the pipeline fully parametric in W. This will make it transparent how to handle online rules that finalize a constant-radius patch.
- Minor clarity: In Lemma 1, it may help to note explicitly that in bounded-degree trees with constants Δ and k, the color count C = Δ^{O(k)} is an absolute constant, so the per-color simulation overhead is O(1).

Why this is progress
- We extend the safe, proven bridge to cover online rules that finalize constant-radius patches (common in greedy online/local designs), giving an immediate path to O(log* n) LOCAL algorithms on bounded-degree trees.
- We outline a concrete, falsifiable “context-invariance” claim for the state-elimination program on paths with t=1, including what to prove or how to refute it with a counterexample LCL. This isolates the remaining conceptual barrier and provides a roadmap for the next proof or separation.

Next steps (auditable)
- Add Lemma D to output.md with a full proof (the proof follows the same envelope as Lemma B and is straightforward to formalize).
- Start the path/t=1 case: either prove the context-invariance claim (produce a short inductive proof or a monotonicity argument) or construct a counterexample LCL. If proven, write the path/t=1 “state-elimination” lemma; if refuted, document the counterexample precisely.
- If bounded-distance writes are used (W>0), ensure the simulation uses G^{R+W} coloring (i.e., G^{2t+2W}) consistently; verify radii accounting in each step with small toy instances to avoid off-by-one errors.


=== prover-02.out.json (progress_md) ===
## Round 0003 — sharpening the bridge from Online-LOCAL(t) to LOCAL on trees

Summary of status
- output.md is now correct regarding the “output-only” bridge: the needed sequential locality is 2t (Lemma B) and can be tightened to t under the stronger t-local-dependence hypothesis (Lemma C). The color-phased simulation and the (R+W)-write variant are also stated cleanly.
- The remaining gap for the unrestricted Online-LOCAL(t) model is the possibility of unbounded accumulation of mutable state before a vertex v arrives. We need additional structural arguments tailored to trees to remove this dependence.

New incremental results (clean statements with proofs)

1) Commutativity of independent arrivals (a tool for order normalisation)
- Lemma D (2t-commutativity of consecutive independent arrivals). Let A be a deterministic Online-LOCAL(t) algorithm on a bounded-degree graph. Consider an arrival sequence σ and two consecutive arrival steps at vertices u and w with dist(u,w) > 2t (distance in the underlying graph G). Let σ′ be obtained by swapping these two steps. Then the states and already-fixed outputs after executing these two steps under σ and under σ′ coincide everywhere; in particular, the outputs on B(u,t) ∪ B(w,t) and outside are identical.
  - Proof sketch (checkable). In the step when u arrives in σ, A runs t synchronous LOCAL rounds on the current arrived graph G_i. All messages and updates during this window are confined to B(u,t) (messages can travel at most distance t in t rounds). Since dist(u,w) > 2t, we also have B(u,t) ∩ B(w,t) = ∅, and w is absent before either of the two steps in both σ and σ′. Moreover, in both orders, the set of previously arrived vertices intersected with B(u,t) is the same at the time u’s window runs, hence the local t-round transcript at nodes in B(u,t) is identical in σ and σ′, and the same updates occur there. The same argument applies to w’s step. Because the two windows touch disjoint node sets and no messages cross between them within t rounds, their effects commute, and all other nodes remain unaffected. □

- Corollary D.1 (Pushing far-away arrivals past v). Fix v and any arrival sequence. By repeatedly applying Lemma D to adjacent independent steps, one can transform the sequence into another sequence in which (i) all vertices at distance > 2t from v arrive after v, and (ii) the outputs of all nodes and the states at the time v arrives on nodes within B(v,t) are identical to those in the original sequence.
  - Why useful: It reduces the analysis of v’s decision to local arrival orders that involve only the ball B(v,2t). This finite-horizon reduction is independent of graph orientation and holds on all graphs.

2) Consequence for dependence radius
- Observation. Under Corollary D.1, we may w.l.o.g. assume that before v arrives, only vertices in B(v,2t) have arrived. Hence any information that can reach v during its t-round window originates within B(v,2t). This is consistent with Lemma B’s 2t radius for the output-only bridge and provides the right target radius for any state-elimination attempt on trees.

New approach outline: “Interface confluence” on trees for t=1
- Goal (paths, t=1 case). Prove: For any deterministic Online-LOCAL(1) algorithm A and any LCL Π, after normalising the order as in Corollary D.1, the output at v depends only on (G[B(v,2)], outputs already fixed in B(v,2)]). Equivalently: mutable states of nodes in B(v,1) at v’s arrival can be replaced by canonical functions of outputs in B(v,2).
- Why plausible on trees: When all arrivals before v lie in B(v,2), any message reaching v during its 1-round window comes from neighbors of v. Each neighbor’s outgoing message is computed using its current state, which itself resulted from arrivals in B(v,2) only. In a tree, one can attempt to summarise the influence of each branch by a finite “interface type” depending only on already-fixed outputs in that branch up to distance 2 from v.
- Proposed technical route:
  1) Define, for each neighbor u of v, the 1-hop interface type τ(u→v) as the set of all possible outgoing messages u would send to v at v’s arrival time, over all arrival orders restricted to B(u,1) consistent with the same already-fixed outputs in B(u,2). Show τ(u→v) is a function of the output-labeling of B(u,2) alone.
  2) Show that the tuple of interface types around v, together with outputs already fixed in B(v,2), determines v’s t=1 transcript and hence v’s output. This would establish the desired (output-only) dependence for t=1 on paths; by a standard tree decomposition at v, extend to general trees.
  3) Generalise to t > 1 by replacing radii 1 and 2 with t and 2t and defining depth-t interface types.
- Obstacles: The interface type τ(u→v) as defined must be well-defined (independent of the arrival order within B(u,2)), which requires a local confluence argument. While Lemma D lets us push arrivals at distance > 2t past v, it does not by itself give confluence among different orders internal to B(u,2). Establishing that the set of feasible outgoing messages depends only on outputs (and not on internal mutable state histories) is the crux.

Why Lemma D is useful even without full state elimination
- It strictly confines the relevant arrivals to B(v,2t) and eliminates concerns about “long-haul” state injected from beyond that radius. Any further dependence on arrival order or mutable state must be attributable to choices made entirely within B(v,2t). This localises the problem and suggests a finite-case analysis/state-aggregation strategy on trees.

Notes on output.md (gaps and suggestions)
- The current output.md correctly states and proves the bridges (Lemma B: radius 2t; Lemma C: radius t under t-local-dependence) and the simulation via coloring. No errors spotted.
- Suggested addition for future versions: include Lemma D (2t-commutativity of independent arrivals) with proof and Corollary D.1. These will be useful scaffolding for the tree-specific state-elimination program, and they are correct for the unrestricted Online-LOCAL(t) model.

Examples/sanity checks
- Example (commutativity applicability). On a path with t=1, any two consecutive arrivals at nodes with distance ≥ 3 commute. Thus, when analysing v, we can always push all arrivals at distance ≥ 3 past v. The only potentially order-sensitive part is the sequence of arrivals within distance ≤ 2 of v.
- Consistency with lower bounds. Sinkless orientation requires Ω(log n) deterministic LOCAL rounds on trees; by Corollary D.1, a hypothetical constant-time online algorithm would still have to resolve constraints within B(v,2t), which is consistent with known impossibility: we do not derive a contradiction but focus on the local reduction.

Next steps (auditable action items)
1) Formalise and prove Lemma D and Corollary D.1 in output.md, including precise quantification over states and message transcripts; this is model-agnostic and verifiable.
2) Path, t=1 case study for interface confluence:
   - Precisely define “interface type” and prove monotonicity properties (adding arrivals outside B(u,2) does not change τ(u→v) by Corollary D.1).
   - Attempt to prove that for fixed outputs on B(u,2), τ(u→v) is a singleton (order-robust), or at least that the set of feasible messages has a canonical choice leading to a valid global solution. If successful, this yields the output-only bridge on paths with r = 2.
3) If (2) succeeds, generalise to trees (branch-wise independence) and to general t by layered interfaces of depth t. If it fails, craft a concrete LCL counterexample on paths demonstrating genuine dependence on mutable state histories within B(v,2) (which would delimit the scope of the desired speedup).
4) Keep tracking read/write distances carefully. If any future sequential rule writes within distance W > 0 (e.g., when extracting canonical choices), ensure to schedule by a G^{R+W}-coloring as already anticipated in output.md.

Why this is progress
- We added a rigorously provable commutativity lemma (and corollary) that strictly localises the analysis to B(v,2t). This is a necessary stepping stone for any tree-specific state-elimination.
- We laid out a concrete, checkable interface-aggregation program starting with paths and t=1, with clear success/failure outcomes to be tested next.


=== Verifier (summary_md) ===

=== Verifier (verdict) ===
success

