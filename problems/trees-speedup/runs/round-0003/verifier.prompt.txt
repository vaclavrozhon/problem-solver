--- SYSTEM ---
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (summary so far)
- output.md (rigorously proven results so far)

Guidelines:
- notes.md: should be a readable running log of interesting work. Prefer appending. Replace only if old notes are clearly misleading. Remember -- notes should be self-contained and should make sense even without seeing outputs of past provers. 
- output.md: should be concise and rigorous. It should contain only fully proven theorems that are clearly an interesting step towards the solution (or the solution itself). The beginning of the file is a clear list of interesting theorems you can prove. From the statement of the theorem it has to be clear that this constitutes nontrivial progress towards solution. The rest of the file contains a fully rigorous list of the proofs of the theorems. Keep only proven theorems with clear proofs. If a statement is flawed and you cannot fix it, remove it from output.md and instead add it to notes.md with explanation.
- Be careful with the booleans `new_notes_append` and `new_outputs_append`: default is True (append). Use False only when deliberately rewriting everything.

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (≥200 words). Include concrete next-step suggestions. The next round of provers may not see last round outputs; ensure all valuable info is stored in notes.",
  "new_notes_md": "Markdown (KaTeX allowed). Usually appended to notes.",
  "new_notes_append": "True|False",
  "new_outputs_md": "Markdown (KaTeX allowed). Usually appended to output.md.",
  "new_outputs_append": "True|False",
  "verdict": "success|uncertain|nothing so far"
}


--- USER ---
You receive multiple prover reports. Evaluate correctness, value, and pick promising directions. Update notes.md (append/replace) with useful ideas and update output.md (append/replace) ONLY with rigorously verified results.

Prover reports (JSON):
[{"prover_id": "01", "progress_md": "Ideas\n- Broadened bridge to capture online algorithms that may commit outputs beyond the arriving vertex. We define an \u201coutput-only, W-write\u201d Online-LOCAL(t) model: upon arrival of v, the algorithm runs t synchronous rounds on the arrived subgraph and irrevocably fixes outputs possibly on the W-neighborhood B(v,W); no other mutable state persists across arrivals and all messages sent by a node during this t-round window are functions only of the graph and currently known outputs within distance \u2264 t from the sender.\n- Why useful: This covers natural online local greedy rules that may finalize a small local patch around the arriving vertex. We prove a clean bridge to sequential-local rules with explicit read/write radii, which then drops into the color-phased LOCAL simulation pipeline.\n\nNew lemmas (clean, checkable)\n- Lemma D (Output-only, W-write Online-LOCAL(t) \u21d2 sequential local with (R,W) = (2t+W,W)).\n  Statement. Let \u03a0 be an LCL on bounded-degree graphs. Suppose there is a deterministic output-only, W-write Online-LOCAL(t) algorithm A that is correct for every arrival order. Then \u03a0 admits a deterministic order-robust sequential rule S that, when processing v, reads only outputs in B(v,2t+W), writes only on vertices in B(v,W), and is correct for every vertex order.\n  Proof sketch. Fix any vertex order \u03c3 = (v1,\u2026,vn). Consider the \u03c6-execution of A with arrivals \u03c3. When vi arrives, during its t-window only nodes u \u2208 B(vi,t) can send messages which reach B(vi,0). Each such u computes its messages as a function of outputs within B(u,t) by the output-only restriction; hence u\u2019s messages to the patch B(vi,W) depend only on outputs in B(vi, t+W) \u222a (\u22c3u\u2208B(vi,t) B(u,t)) \u2286 B(vi,2t+W). Therefore the full t-round transcript relevant to deciding outputs on B(vi,W) in the \u03c3-run depends only on the restriction of the arrived subgraph and already fixed outputs to B(vi,2t+W). Define S as follows: when processing vi in \u03c3, S gathers the outputs already fixed within B(vi,2t+W)\u2229{v1,\u2026,vi\u22121} and deterministically reproduces A\u2019s t-window decision for B(vi,W) given that local view. As A is deterministic and correct for all orders, S reproduces the same patch outputs as A in this order; order-robustness of S follows by the same order-by-color simulation used previously. S is (R,W) = (2t+W,W)-local.\n\n- Lemma E (LOCAL simulation for (R,W)-local sequential rules).\n  Statement. Let S be a deterministic sequential rule that, when processing v, reads only B(v,R) and writes only on B(v,W), for fixed constants R,W \u2265 0. Given a proper coloring of G^{R+W} with C colors, one can simulate S in the LOCAL model by processing colors 1,\u2026,C, using O(R) rounds per color. The simulation outputs exactly what S would produce for any order that respects the color layering.\n  Proof. If dist(u,v) > R+W and \u03c6(u) = \u03c6(v), then (i) B(u,R)\u2229B(v,R) = \u2205 and (ii) B(u,R) is disjoint from the write neighborhood B(v,W), and vice versa. Thus, within one color phase, decisions are independent. Each vertex of color i gathers the outputs written by earlier colors in B(v,R) (O(R) rounds), applies S, and writes within B(v,W). Correctness is identical to Lemma 2\u2019s argument. A coloring of G^{R+W} with C = \u0394^{O(R+W)} colors can be computed in O((R+W)\u00b7log* n) rounds by Lemma 1 simulated on G.\n\nCorollaries (bounded-degree trees \u21d2 O(log* n))\n- Corollary D. On bounded-degree trees, if \u03a0 has a deterministic output-only, W-write Online-LOCAL(t) algorithm with constants t,W, then \u03a0 has a deterministic LOCAL algorithm with round complexity O((2t+W)\u00b7log* n) + O(1) = O(log* n).\n  Reason: Apply Lemma D to get a (R,W)-local sequential rule with R = 2t+W, then Lemma E and Lemma 1.\n- Note existing special cases are recovered: W=0 gives Lemma B (R=2t), and \u201ct-local-dependence\u201d with W=0 gives Lemma C (R=t).\n\nExamples and sanity checks\n- Greedy (\u0394+1)-coloring online variant fixing a constant-radius patch: If at arrival of v the online rule picks a color for v and possibly finalizes colors of uncolored neighbors (W=1) using only the set of colors already fixed in B(v,1), then the rule is output-only, W-write with t=1. Corollary D yields an O(log* n) LOCAL algorithm on bounded-degree trees.\n- Greedy maximal matching: a variant that, at v\u2019s arrival, matches v to a free neighbor and possibly finalizes the matched pair (W=1), while sending messages depending only on currently fixed outputs within distance 1, meets the model; Corollary D applies.\n\nObstacles and model gaps (reiterated crisply)\n- The unrestricted Online-LOCAL(t) model allows arbitrary mutable state and unbounded accumulation of information before v arrives. The path/t=1 counter-scenario still shows naive phase compression is invalid without extra restrictions. Our bridges cover output-only (R=2t or 2t+W) and t-local-dependence (R=t), but the general state-elimination step remains open.\n\nState-elimination program (t=1 on paths) \u2014 concrete, testable steps\n- Formalize the \u201cinterface view\u201d at radius 2: for any vertex v on a path, define the context K(v) := restriction of outputs to B(v,2) at the time v arrives in an online execution. Target claim (Context-invariance): For any two online executions that agree on K(v), the set of outputs that the algorithm may produce at v is the same. If true, define a canonical tie-breaking function on K(v) to derive a sequential rule with R=2 and W determined by the online rule. Action items:\n  1) Model each arrival as a local rewrite on the current output labeling; record that in t=1, only the immediate neighbors of v can send messages to v during the window, and each of those neighbors\u2019 messages are functions of outputs in their own 1-neighborhood.\n  2) Attempt to construct a counterexample LCL where two executions with identical K(v) force different outputs at v. If found, local elimination at radius 2 fails; otherwise, prove the lemma.\n- Generalize: If the t=1 path case succeeds, extend to trees by handling the degree>2 case via boundary decomposition along paths to \u2202B(v,2). For general t, replace 2 by 2t; for W>0, consider K(v) extended to B(v,2t+W).\n\nEditorial notes on output.md\n- The newly added Variant of Lemma 2 for bounded-distance writes aligns with Lemma E above. Suggest adding Lemma D explicitly (output-only, W-write bridge with read radius 2t+W) to make the pipeline fully parametric in W. This will make it transparent how to handle online rules that finalize a constant-radius patch.\n- Minor clarity: In Lemma 1, it may help to note explicitly that in bounded-degree trees with constants \u0394 and k, the color count C = \u0394^{O(k)} is an absolute constant, so the per-color simulation overhead is O(1).\n\nWhy this is progress\n- We extend the safe, proven bridge to cover online rules that finalize constant-radius patches (common in greedy online/local designs), giving an immediate path to O(log* n) LOCAL algorithms on bounded-degree trees.\n- We outline a concrete, falsifiable \u201ccontext-invariance\u201d claim for the state-elimination program on paths with t=1, including what to prove or how to refute it with a counterexample LCL. This isolates the remaining conceptual barrier and provides a roadmap for the next proof or separation.\n\nNext steps (auditable)\n- Add Lemma D to output.md with a full proof (the proof follows the same envelope as Lemma B and is straightforward to formalize).\n- Start the path/t=1 case: either prove the context-invariance claim (produce a short inductive proof or a monotonicity argument) or construct a counterexample LCL. If proven, write the path/t=1 \u201cstate-elimination\u201d lemma; if refuted, document the counterexample precisely.\n- If bounded-distance writes are used (W>0), ensure the simulation uses G^{R+W} coloring (i.e., G^{2t+2W}) consistently; verify radii accounting in each step with small toy instances to avoid off-by-one errors.\n"}, {"prover_id": "02", "progress_md": "## Round 0003 \u2014 sharpening the bridge from Online-LOCAL(t) to LOCAL on trees\n\nSummary of status\n- output.md is now correct regarding the \u201coutput-only\u201d bridge: the needed sequential locality is 2t (Lemma B) and can be tightened to t under the stronger t-local-dependence hypothesis (Lemma C). The color-phased simulation and the (R+W)-write variant are also stated cleanly.\n- The remaining gap for the unrestricted Online-LOCAL(t) model is the possibility of unbounded accumulation of mutable state before a vertex v arrives. We need additional structural arguments tailored to trees to remove this dependence.\n\nNew incremental results (clean statements with proofs)\n\n1) Commutativity of independent arrivals (a tool for order normalisation)\n- Lemma D (2t-commutativity of consecutive independent arrivals). Let A be a deterministic Online-LOCAL(t) algorithm on a bounded-degree graph. Consider an arrival sequence \u03c3 and two consecutive arrival steps at vertices u and w with dist(u,w) > 2t (distance in the underlying graph G). Let \u03c3\u2032 be obtained by swapping these two steps. Then the states and already-fixed outputs after executing these two steps under \u03c3 and under \u03c3\u2032 coincide everywhere; in particular, the outputs on B(u,t) \u222a B(w,t) and outside are identical.\n  - Proof sketch (checkable). In the step when u arrives in \u03c3, A runs t synchronous LOCAL rounds on the current arrived graph G_i. All messages and updates during this window are confined to B(u,t) (messages can travel at most distance t in t rounds). Since dist(u,w) > 2t, we also have B(u,t) \u2229 B(w,t) = \u2205, and w is absent before either of the two steps in both \u03c3 and \u03c3\u2032. Moreover, in both orders, the set of previously arrived vertices intersected with B(u,t) is the same at the time u\u2019s window runs, hence the local t-round transcript at nodes in B(u,t) is identical in \u03c3 and \u03c3\u2032, and the same updates occur there. The same argument applies to w\u2019s step. Because the two windows touch disjoint node sets and no messages cross between them within t rounds, their effects commute, and all other nodes remain unaffected. \u25a1\n\n- Corollary D.1 (Pushing far-away arrivals past v). Fix v and any arrival sequence. By repeatedly applying Lemma D to adjacent independent steps, one can transform the sequence into another sequence in which (i) all vertices at distance > 2t from v arrive after v, and (ii) the outputs of all nodes and the states at the time v arrives on nodes within B(v,t) are identical to those in the original sequence.\n  - Why useful: It reduces the analysis of v\u2019s decision to local arrival orders that involve only the ball B(v,2t). This finite-horizon reduction is independent of graph orientation and holds on all graphs.\n\n2) Consequence for dependence radius\n- Observation. Under Corollary D.1, we may w.l.o.g. assume that before v arrives, only vertices in B(v,2t) have arrived. Hence any information that can reach v during its t-round window originates within B(v,2t). This is consistent with Lemma B\u2019s 2t radius for the output-only bridge and provides the right target radius for any state-elimination attempt on trees.\n\nNew approach outline: \u201cInterface confluence\u201d on trees for t=1\n- Goal (paths, t=1 case). Prove: For any deterministic Online-LOCAL(1) algorithm A and any LCL \u03a0, after normalising the order as in Corollary D.1, the output at v depends only on (G[B(v,2)], outputs already fixed in B(v,2)]). Equivalently: mutable states of nodes in B(v,1) at v\u2019s arrival can be replaced by canonical functions of outputs in B(v,2).\n- Why plausible on trees: When all arrivals before v lie in B(v,2), any message reaching v during its 1-round window comes from neighbors of v. Each neighbor\u2019s outgoing message is computed using its current state, which itself resulted from arrivals in B(v,2) only. In a tree, one can attempt to summarise the influence of each branch by a finite \u201cinterface type\u201d depending only on already-fixed outputs in that branch up to distance 2 from v.\n- Proposed technical route:\n  1) Define, for each neighbor u of v, the 1-hop interface type \u03c4(u\u2192v) as the set of all possible outgoing messages u would send to v at v\u2019s arrival time, over all arrival orders restricted to B(u,1) consistent with the same already-fixed outputs in B(u,2). Show \u03c4(u\u2192v) is a function of the output-labeling of B(u,2) alone.\n  2) Show that the tuple of interface types around v, together with outputs already fixed in B(v,2), determines v\u2019s t=1 transcript and hence v\u2019s output. This would establish the desired (output-only) dependence for t=1 on paths; by a standard tree decomposition at v, extend to general trees.\n  3) Generalise to t > 1 by replacing radii 1 and 2 with t and 2t and defining depth-t interface types.\n- Obstacles: The interface type \u03c4(u\u2192v) as defined must be well-defined (independent of the arrival order within B(u,2)), which requires a local confluence argument. While Lemma D lets us push arrivals at distance > 2t past v, it does not by itself give confluence among different orders internal to B(u,2). Establishing that the set of feasible outgoing messages depends only on outputs (and not on internal mutable state histories) is the crux.\n\nWhy Lemma D is useful even without full state elimination\n- It strictly confines the relevant arrivals to B(v,2t) and eliminates concerns about \u201clong-haul\u201d state injected from beyond that radius. Any further dependence on arrival order or mutable state must be attributable to choices made entirely within B(v,2t). This localises the problem and suggests a finite-case analysis/state-aggregation strategy on trees.\n\nNotes on output.md (gaps and suggestions)\n- The current output.md correctly states and proves the bridges (Lemma B: radius 2t; Lemma C: radius t under t-local-dependence) and the simulation via coloring. No errors spotted.\n- Suggested addition for future versions: include Lemma D (2t-commutativity of independent arrivals) with proof and Corollary D.1. These will be useful scaffolding for the tree-specific state-elimination program, and they are correct for the unrestricted Online-LOCAL(t) model.\n\nExamples/sanity checks\n- Example (commutativity applicability). On a path with t=1, any two consecutive arrivals at nodes with distance \u2265 3 commute. Thus, when analysing v, we can always push all arrivals at distance \u2265 3 past v. The only potentially order-sensitive part is the sequence of arrivals within distance \u2264 2 of v.\n- Consistency with lower bounds. Sinkless orientation requires \u03a9(log n) deterministic LOCAL rounds on trees; by Corollary D.1, a hypothetical constant-time online algorithm would still have to resolve constraints within B(v,2t), which is consistent with known impossibility: we do not derive a contradiction but focus on the local reduction.\n\nNext steps (auditable action items)\n1) Formalise and prove Lemma D and Corollary D.1 in output.md, including precise quantification over states and message transcripts; this is model-agnostic and verifiable.\n2) Path, t=1 case study for interface confluence:\n   - Precisely define \u201cinterface type\u201d and prove monotonicity properties (adding arrivals outside B(u,2) does not change \u03c4(u\u2192v) by Corollary D.1).\n   - Attempt to prove that for fixed outputs on B(u,2), \u03c4(u\u2192v) is a singleton (order-robust), or at least that the set of feasible messages has a canonical choice leading to a valid global solution. If successful, this yields the output-only bridge on paths with r = 2.\n3) If (2) succeeds, generalise to trees (branch-wise independence) and to general t by layered interfaces of depth t. If it fails, craft a concrete LCL counterexample on paths demonstrating genuine dependence on mutable state histories within B(v,2) (which would delimit the scope of the desired speedup).\n4) Keep tracking read/write distances carefully. If any future sequential rule writes within distance W > 0 (e.g., when extracting canonical choices), ensure to schedule by a G^{R+W}-coloring as already anticipated in output.md.\n\nWhy this is progress\n- We added a rigorously provable commutativity lemma (and corollary) that strictly localises the analysis to B(v,2t). This is a necessary stepping stone for any tree-specific state-elimination.\n- We laid out a concrete, checkable interface-aggregation program starting with paths and t=1, with clear success/failure outcomes to be tested next.\n"}]

Current notes.md:
Context and goal
We study the relationship between online-style constant-locality algorithms for LCLs on bounded-degree, unoriented trees and deterministic LOCAL-time upper bounds. Two notions of “online local” are relevant:
- Sequential local/greedy model (order-robust r-local): when processing a vertex v, the decision at v depends only on the r-hop neighborhood B(v,r) of the underlying graph and on already fixed outputs within B(v,r); the algorithm must succeed for every vertex order. No global mutable state or long-range message accumulation between steps.
- Online-LOCAL(t) (Akbari–Eslami–Lievonen–Melnyk–Särkijärvi–Suomela, ICALP’23): vertices arrive one by one; upon each arrival, the algorithm has t synchronous LOCAL rounds on the subgraph induced by arrived vertices; outputs are irrevocable. Over many arrivals, an unbounded number of communication rounds can occur, enabling long-range state accumulation.

Safe, proven variant (archived below in output.md)
- Theorem (Sequential-local to LOCAL): If an LCL Π on bounded-degree graphs has a deterministic order-robust r-local sequential algorithm (decisions at v depend only on B(v,r) and outputs of earlier vertices in B(v,r), and the rule writes only the output at v), then Π has a deterministic LOCAL algorithm running in O(r log* n + Δ^{O(r)}) rounds. On bounded-degree trees with constant r, this is O(log* n). Proof: compute a proper coloring of G^r in O(r log* n) rounds with Δ^{O(r)} colors; process color classes in order, letting each v gather outputs from B(v,r) restricted to earlier colors and apply the sequential rule. Because nodes of the same color are at distance > r, their decisions do not depend on each other.

Gap for the full Online-LOCAL(t) model
- A direct phase simulation that uses a distance-(2t) coloring and t rounds per color does not generally reproduce the state a node v would see upon arrival in an actual online execution. In a true online run, before v arrives, there may have been Θ(n) earlier arrivals, yielding Θ(n)·t global rounds; information can propagate arbitrarily far and may alter the states within B(v,t). The phase simulation grants only O(1)·t total rounds before v’s phase, so the local states can differ. Hence, without additional constraints, we cannot claim that the phase simulation faithfully reproduces the online run or even yields correctness solely from A’s correctness.

Ways forward for Online-LOCAL(t)
- Add a locality-of-dependence assumption: the t-round transcript that determines v’s output depends only on the arrived subgraph inside distance ≤ t from v and on the outputs of those nodes, not on mutable states imported from farther away. Under this, distance-(2t) coloring plus phase simulation is valid and yields O(log* n).
- Alternatively, seek a structural scheduling/padding argument ensuring that for LCLs on bounded-degree trees, the state within B(v,t) before v’s arrival is independent of far-away arrivals. This is nontrivial; try first on paths/trees with t=1 to see whether accumulation can matter for any LCL.
- Or try to separate the models: construct an LCL that is solvable in constant t in Online-LOCAL but provably not simulable by the above constant-phase compression; if such an LCL exists, the general reduction fails, and the sequential-local variant becomes the correct target.

Remarks
- No global edge orientation is needed anywhere in the reduction we proved; IDs suffice for coloring.
- The archived proof applies to all bounded-degree graphs; we stated trees to match the project focus.
Refinements on bridging Online-LOCAL(t) to sequential local rules
- Definitions (recap and refinement):
  • Online-LOCAL(t): vertices arrive one by one; upon each arrival we have t synchronous LOCAL rounds on the subgraph induced by arrived vertices; outputs are irrevocably set at arrival; in the general model, nodes may maintain unbounded mutable state across arrival windows.
  • Output-only Online-LOCAL(t): the only persistent state at nodes is the immutable output label after it is set; between windows there is no other state; in any t-round window, messages sent by a node are functions only of the underlying graph and the currently known outputs within its distance-t neighborhood (no dependence on farther outputs or on pre-window mutable state).
  • t-local-dependence at v: when v arrives, its output depends only on the arrived subgraph restricted to B(v,t) and outputs of the arrived nodes within B(v,t).

- Correct radius accounting:
  • At v’s arrival with window length t, nodes within B(v,t) can influence v. A node u ∈ B(v,t) may compute its messages based on outputs within B(u,t), which is contained in B(v,2t). Thus, in the output-only model, v’s output depends only on the graph structure and outputs within B(v,2t). Consequently, the correct bridge is to a sequential rule of radius 2t (not t). If we assume t-local-dependence at v, the bridge tightens to radius t.

- Minimal counter-scenario (why naive phase-compression fails for the unrestricted online model):
  Consider a path with t=1. In a genuine online run, before a vertex v arrives, Θ(n) earlier arrivals can propagate state one hop per window across the path; by the time v arrives, its neighbors may carry information injected far away. A color-phased simulation that offers only O(1) windows before v’s phase cannot reproduce these accumulated states. This shows that without output-only or t-local-dependence, we cannot black-box simulate arbitrary Online-LOCAL(t) runs by a constant number of phases.

- Practical takeaway for reductions:
  • If your online algorithm is output-only, design the sequential rule to read B(v,2t) and write only at v; then apply the G^{2t} coloring pipeline to get O(log* n) on bounded-degree trees.
  • If your online algorithm satisfies t-local-dependence at v, the sequential rule needs only B(v,t).

- Next-step plan (state elimination on trees):
  • Start on paths with t=1. Define the interface ∂B(v,2) and annulus R=B(v,2)\B(v,1). Attempt to prove: if two online executions agree on outputs over B(v,2), then they allow exactly the same outputs at v. If proven, extend to trees and t by replacing 2 with 2t. If refuted, crystallize a separation example.
  • Track read/write radii for any sequential rules that go beyond “write only at v”; use distance-(R+W) colorings for phase independence.


Current output.md (if any):
List of proven results archived here
- Theorem A (Sequential-local to LOCAL on bounded-degree graphs).
- Lemma 1 (Power-graph coloring in O(k log* n)).
- Lemma 2 (Color-phased simulation for order-robust r-local rules).
- Corollary A (Bounded-degree trees, constant r ⇒ O(log* n)).

Model and definitions
- Graphs: finite, simple, maximum degree Δ < ∞ (bounded degree). Nodes have unique IDs from a polynomial range (standard LOCAL assumptions). No global orientation is assumed.
- LCL Π: a locally checkable labeling problem with constant checkability radius r_Π (used only to define the problem; our algorithmic radii below are independent parameters).
- Order-robust r-local sequential algorithm: A deterministic rule A with locality parameter r such that, for any graph G in the class and any vertex order v_1,…,v_n, when processing vertex v_i, A reads G[B(v_i,r)] and the outputs already fixed on vertices in B(v_i,r) ∩ {v_1,…,v_{i-1}}, and writes the output at v_i. The final labeling satisfies Π for every order. (A does not write to any vertex other than the current v_i.)

Lemma 1 (Power-graph coloring in O(k log* n))
Statement. Let G be a bounded-degree graph and k ≥ 1 a constant. There is a deterministic LOCAL algorithm that computes a proper vertex coloring of the power graph G^k with at most C = O(Δ(G^k)^2) colors in O(k log* n) rounds on G. In particular, Δ(G^k) ≤ Δ^k, so C = Δ^{O(k)}.
Proof. It is known that in the LOCAL model one can compute a proper O(Δ(H)^2)-coloring of any graph H in O(log* n) rounds (Linial’s color-reduction). To color G^k while communicating on G, we simulate each round of the O(log* n)-round coloring algorithm on G^k by k rounds on G: in k rounds, every node can learn the IDs and temporary colors of all nodes at distance ≤ k in G, i.e., its neighbors in G^k. Thus, O(log* n) rounds on G^k translate to O(k log* n) rounds on G. The color bound follows from Δ(G^k) ≤ Δ^k. □

Lemma 2 (Color-phased simulation for order-robust r-local rules)
Statement. Let A be an order-robust r-local sequential algorithm for Π. Let φ:V→{1,…,C} be a proper coloring of G^r (i.e., nodes at distance ≤ r have distinct colors). Then there is a deterministic LOCAL simulation that processes colors 1,2,…,C and assigns the same outputs as A would when run on any order that first lists all nodes of color 1 (in any internal order), then color 2, and so on. The simulation uses O(r) rounds per color after φ is known.
Proof. Fix A and φ. Since φ is a proper coloring of G^r, if φ(u)=φ(v) then dist(u,v)>r, so B(u,r) and B(v,r) are disjoint from {v} and {u}, respectively; in particular, the decision at u under A can depend only on outputs of vertices strictly within B(u,r) and, hence, on colors < φ(u) if we process colors in increasing order. The simulation proceeds for i=1,…,C: in phase i, each vertex v with φ(v)=i performs the following in parallel: gather the outputs of vertices in B(v,r) with colors < i (this takes r rounds of communication, as outputs are already fixed for colors < i), then apply A’s local rule to determine v’s output. Because the rule reads only B(v,r) and writes only at v, and B(u,r) contains no vertex of color i other than u, all decisions in phase i are independent and match A’s decisions under any vertex order that respects the color layering. □

Theorem A (Sequential-local to LOCAL on bounded-degree graphs)
Statement. Let Π be an LCL on bounded-degree graphs. Suppose Π admits a deterministic order-robust r-local sequential algorithm A (as defined above). Then Π has a deterministic LOCAL algorithm running in O(r log* n + C·r) rounds, where C = Δ^{O(r)} depends only on Δ and r. In particular, for constant Δ and constant r, the round complexity is O(log* n).
Proof. Use Lemma 1 with k=r to compute a proper coloring φ of G^r in O(r log* n) rounds with C=Δ^{O(r)} colors. Then use Lemma 2 to simulate A by processing colors 1,…,C, spending O(r) rounds per color to collect outputs from earlier colors within distance r and decide the current color’s outputs. The total is O(r log* n + C·r). Correctness follows from Lemma 2. □

Corollary A (Bounded-degree trees, constant locality)
Statement. On bounded-degree, unoriented trees, if Π has a deterministic order-robust r-local sequential algorithm for some constant r, then Π has a deterministic LOCAL algorithm with round complexity O(log* n).
Proof. Trees are bounded-degree graphs; apply Theorem A. No edge orientation is used. □

Remark (about Online-LOCAL(t)). The results above do not cover the full Online-LOCAL(t) model in which each arrival grants t synchronous rounds and nodes may accumulate mutable state across arrivals. In that model, before a vertex arrives, arbitrarily many global t-round windows may have elapsed, potentially allowing long-range information to influence its local neighborhood. The phase-simulation argument requires an extra assumption restricting such long-range dependence (e.g., that a vertex’s output upon arrival depends only on the arrived subgraph within distance ≤ t and previously fixed outputs therein). Proving a general reduction under the unrestricted Online-LOCAL(t) model remains open here.
New definitions (for bridging lemmas)
- Online-LOCAL(t). An arrival sequence v_1,…,v_n is fixed. At step i, the subgraph G_i induced by {v_1,…,v_i} becomes available. The algorithm performs t synchronous LOCAL rounds on G_i (messages along edges of G_i, arbitrary local computation). The output label of v_i must be irrevocably fixed by the end of these t rounds. Previously arrived nodes’ outputs are irrevocable. In the general model, nodes may maintain arbitrary local state across steps.
- Output-only Online-LOCAL(t). Same as above, except that the only state that persists across arrival steps is the immutable output label of each node. In any t-round window, all messages and local computations at a node x may depend on the underlying graph and the currently known outputs within distance ≤ t from x, but not on any other mutable state from prior steps.
- t-local-dependence (at v). An Online-LOCAL(t) algorithm has t-local-dependence if, when v arrives, the output chosen for v is a function only of the induced arrived subgraph on B(v,t) and of the outputs of the arrived nodes in B(v,t); in particular, it does not depend on any additional mutable state or on outputs outside B(v,t).

Lemma B (Output-only Online-LOCAL(t) ⇒ order-robust sequential with radius 2t)
Statement. Let Π be an LCL on bounded-degree graphs. Suppose there is a deterministic output-only Online-LOCAL(t) algorithm that is correct for every arrival order. Then Π admits a deterministic order-robust sequential algorithm that, when processing v, reads only B(v,2t) and the outputs already fixed within B(v,2t), writes only at v, and produces a correct global labeling for every vertex order.
Proof. Fix any vertex order σ = (v_1,…,v_n). Define the sequential rule S as follows. When processing v_i, collect the subgraph induced by B(v_i,2t) and the set of outputs already fixed among vertices in B(v_i,2t) ∩ {v_1,…,v_{i-1}}. Consider the online execution whose arrival order equals σ. In the output-only model, at the time v_i arrives, during its t-round window, only nodes within distance ≤ t from v_i can send messages that reach v_i. Each such node u ∈ B(v_i,t) computes its messages as a function of outputs in B(u,t) (by output-only), and B(u,t) ⊆ B(v_i,2t). Hence the entire t-round transcript observed by v_i, and thus v_i’s output, is a function of the restriction of the arrived subgraph and outputs to B(v_i,2t). The restriction seen by S (earlier outputs in B(v_i,2t) under order σ) coincides with the restriction seen by the online algorithm at the moment v_i arrives in the σ-arrival run. Therefore S produces exactly the same output for v_i as the online algorithm in that run. Determinism and the online algorithm’s correctness for every arrival order imply that, for every σ, the sequential execution under S yields a labeling satisfying Π. S reads only B(v_i,2t) and writes only at v_i, so S is an order-robust 2t-local sequential algorithm. □

Lemma C (Bridge under t-local-dependence: radius t)
Statement. Let Π be an LCL on bounded-degree graphs. Suppose there is a deterministic Online-LOCAL(t) algorithm with t-local-dependence (at every v) that is correct for every arrival order. Then Π admits a deterministic order-robust sequential algorithm that, when processing v, reads only B(v,t) and the outputs already fixed within B(v,t), writes only at v, and is correct for every vertex order.
Proof. Fix any vertex order σ and define the sequential rule S analogously to Lemma B but with radius t. By t-local-dependence, in the σ-arrival online execution the output of v_i depends only on the arrived subgraph restricted to B(v_i,t) and the outputs of arrived nodes in B(v_i,t). This restriction matches exactly the information available to S at v_i under σ. Hence S reproduces the online output at v_i for the σ-arrival run. Correctness and locality properties follow as in Lemma B. □

Corollary B (Bounded-degree trees, constant t ⇒ O(log* n) LOCAL)
Statement. On bounded-degree trees, if Π has a deterministic output-only Online-LOCAL(t) algorithm for constant t, then Π has a deterministic LOCAL algorithm with round complexity O(log* n). The same holds if Π has a deterministic Online-LOCAL(t) algorithm with t-local-dependence.
Proof. Combine Lemma B (resp. Lemma C) with Theorem A. On trees with constant Δ and constant t, r ∈ {2t,t} is constant; Theorem A yields O(log* n). □

Variant of Lemma 2 (allowing bounded-distance writes)
Statement. Let A be an order-robust sequential rule that, when processing v, reads only B(v,R) and may write outputs on vertices within distance ≤ W of v (for some fixed constants R,W≥0). Let φ be a proper coloring of G^{R+W}. Then processing colors 1,…,C according to φ simulates any vertex order that respects the color layering: decisions in each color class are independent and match A for any such order.
Proof. If dist(u,v) > R+W and φ(u)=φ(v), then (i) the read ball B(u,R) is disjoint from the write neighborhood of v and vice versa, and (ii) B(u,R)∩B(v,R)=∅. Thus, within a single color phase, the read/write effects of different vertices cannot interfere, and each vertex’s decision under A depends only on outputs fixed in earlier color phases within its read radius. The standard argument of Lemma 2 then applies. Computing φ takes O((R+W) log* n) rounds by Lemma 1 with k=R+W. □

Remark (scope relative to unrestricted Online-LOCAL(t)). The lemmas above cover two restricted variants: output-only (radius 2t) and t-local-dependence (radius t). For the full Online-LOCAL(t) model with arbitrary persistent mutable state, reducing to order-robust sequential rules remains open here; the known obstruction is that long chains of arrivals can accumulate state in B(v,t) before v arrives, which a constant number of phases cannot reproduce. The path/t=1 counter-scenario illustrates this limitation.
