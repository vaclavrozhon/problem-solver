--- SYSTEM ---
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (summary so far)
- output.md (rigorously proven results so far)

Guidelines:
- notes.md: should be a readable running log of interesting work. Prefer appending. Replace only if old notes are clearly misleading. Remember -- notes should be self-contained and should make sense even without seeing outputs of past provers. 
- output.md:  Think twice before you add something to this file. Everything here should be rigorous, almost publication-ready. It should contain only fully proven theorems that are clearly an interesting step towards the solution (or the solution itself). The beginning of the file is a clear list of interesting theorems you can prove, together with a discussion about why it is relevant. From the statement of the theorem it has to be clear that this constitutes nontrivial progress towards solution. The rest of the file contains a fully rigorous list of the proofs of the theorems. Keep only proven theorems with clear proofs. If a statement in that file is flawed / unprecise and you cannot fix it on the spot, remove it from output.md and instead add it to notes.md with explanation.
- Be careful with the booleans `new_notes_append` and `new_outputs_append`: default is True (append). Use False only when deliberately rewriting everything.

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (≥200 words). Include concrete next-step suggestions. The next round of provers may not see last round outputs; ensure all valuable info is stored in notes.",
  "new_notes_md": "Markdown (KaTeX allowed). Usually appended to notes.",
  "new_notes_append": "True|False",
  "new_outputs_md": "Markdown (KaTeX allowed). Usually appended to output.md.",
  "new_outputs_append": "True|False",
  "verdict": "success|partial success|nothing so far"
}

**Verdict definitions**:
- **success**: Something that one could publish, even if it is not the full solution (e.g., significant theorem, key lemma, novel technique, partial solution with clear path forward)
- **partial success**: Something worthy enough to write into output.md (e.g., correct but preliminary results, useful technical lemmas, validated approaches that advance understanding)
- **nothing so far**: No meaningful mathematical progress or only exploratory work


--- USER ---
You receive multiple prover reports. Evaluate correctness, value, and pick promising directions. Update notes.md (append/replace) with useful ideas and update output.md (append/replace) ONLY with rigorously verified results.

Prover reports (JSON):
[{"prover_id": "01", "progress_md": "Status check and scope\n- The curated output.md now includes the corrected bounded-writes simulation (color G^K with K = max(2W, R+W)), the output-only bridges (W=0 and W>0), and the 2t-commutativity/cutoff lemma. This fixes the earlier flaw flagged by the verifier (using G^{R+W} was insufficient) and provides a complete O(log* n) pipeline for the output-only (and t-local-dependence) online models on bounded-degree trees.\n- The main open gap remains the unrestricted Online-LOCAL(t) model: unlimited mutable state can accumulate across many arrivals before v, and our color-phased simulation need not reproduce these states. The commutativity lemma localizes influence to B(v,2t), but internal nonconfluence within B(v,2t) is unresolved.\n\nNew micro-lemmas (formal and checkable)\n- Lemma 8 (Strong witness-localization at v). Let A be a deterministic Online-LOCAL(t) algorithm and \u03c3 any arrival sequence. For any vertex v, there exists a sequence \u03c3_v obtained from \u03c3 by swapping adjacent arrivals at distance > 2t such that (i) all arrivals before v in \u03c3_v occur at vertices in B(v,2t), (ii) the arrived subgraph just before v arrives is G[B(v,2t)]\u2229{arrived}, and (iii) the local states and fixed outputs on B(v,t) at the time v arrives are identical in \u03c3 and \u03c3_v.\n  Proof idea: Iteratively apply Lemma 7 to push every arrival at distance > 2t from v past v. Each swap preserves the state within B(v,t) at the time v arrives; hence (iii) holds. Statements (i)\u2013(ii) then follow by construction.\n- Lemma 9 (Finite local enumeration for t=1 on paths). On a path, for any vertex v, the set of arrival orders restricted to B(v,2) is finite with size bounded by a constant c(\u0394) independent of n; hence the set of possible transcripts/messages seen by v under any normalized \u03c3_v is finite. This is an accounting lemma (use \u0394 \u2264 2 on paths) and will be useful if a local confluence/summary argument can be established.\n\nPath, t=1 interface program \u2014 sharpening targets\n- Definitions (interface types). For a path and t=1, define K(v) to be the restriction of already-fixed outputs just before v arrives to B(v,2). For each neighbor u \u2208 N(v), define the interface type \u03c4(u\u2192v) as the set of all outgoing 1-round messages that u can send to v at the start of v\u2019s window, ranging over all normalized arrival orders \u03c3_v consistent with K(v). Note that \u03c4(u\u2192v) depends a priori on the internal states at u caused by earlier arrivals within B(v,2), not just on outputs.\n- Target Claim C1 (context-invariance). For any deterministic Online-LOCAL(1) algorithm A that is correct for all orders on paths, \u03c4(u\u2192v) is a function only of K(v). If C1 holds, then the pair of types (\u03c4(left\u2192v), \u03c4(right\u2192v)) together with K(v) determines v\u2019s 1-round transcript and thus v\u2019s output; consequently, v\u2019s output can be written as f(K(v)), yielding a sequential rule with read radius R=2 (W depending on A).\n- Why plausible: Lemma 8 restricts all relevant pre-v activity to B(v,2). Correctness-for-all-orders constrains the variability of \u03c4(u\u2192v): in particular, if two normalized local histories share K(v), any divergence in \u03c4 would imply two global normalized executions that share K(v) but force different decisions at v under the same neighbor messages\u2014this is the crux to be formalized.\n\nObstacles and what fails without extra structure\n- Messages are unbounded in LOCAL, hence in principle \u03c4(u\u2192v) could be infinite and depend on arbitrary pre-window states, even if K(v) is fixed. Without additional constraints, direct finiteness/regularity arguments (e.g., Myhill\u2013Nerode\u2013style) are unavailable.\n- Local confluence inside B(v,2) is not implied by 2t-commutativity (which only handles dist > 2t). For t=1, arrivals at distance 2 can causally affect a neighbor\u2019s 1-round message to v, and these steps need not commute.\n\nWhy the current bridges suffice in natural cases\n- The output-only model (and its W-write variant) sidesteps the obstacles: each neighbor\u2019s outgoing message during v\u2019s window is a function of outputs within distance 1 of the sender; by Lemma 6, v\u2019s decision depends only on outputs in B(v,2) (or B(v,2+W) for bounded writes), and the color-phased simulation gives O(log* n).\n- The t-local-dependence variant provides an even tighter radius (R=t) and is common for greedy \u201cdecide-at-current-node\u201d online rules.\n\nActionable next steps (auditable)\n1) Formalize C1 or refute it on paths:\n   - Set up the precise semantics of \u03c4(u\u2192v): enumerate all normalized permutations of arrivals in B(v,2), run A on each (local simulation of a finite tree of executions), and collect the set of possible messages. Prove (or disprove by counterexample) that \u03c4(u\u2192v) depends only on K(v).\n   - If C1 holds, define f(K(v)) by simulating v\u2019s 1-window using any representative execution consistent with K(v); argue that f yields a well-defined (R=2, W as needed) sequential rule S. Then invoke Lemma 5 to obtain O(log* n) in LOCAL on bounded-degree trees.\n2) If C1 fails, attempt a weaker canonicalization:\n   - Show existence of a canonical choice g(K(v)) \u2208 \u03c4(u\u2192v) for each interface that still yields a valid global labeling when composed across vertices via color-phased scheduling (this would be a \u201clocal mending\u201d style selection).\n3) Extend Lemma 8 to quantify the precise bound on the number of arrival steps that can affect v: for general t and degree \u0394, |B(v,2t)| \u2264 \u0394^{O(t)}; record this bound for use in exhaustive local simulations.\n4) Strengthen output.md with an explicit remark that the main theorem presently holds under output-only (and t-local-dependence) hypotheses and that unrestricted Online-LOCAL(t) is open; add Lemma 8 and Lemma 9 as formal tools for the path-interface program.\n\nNotes on output.md (gaps/edits)\n- The listed lemmas are correct as stated. To support the path-interface program, we suggest adding:\n  \u2022 Lemma 8 (strong witness-localization at v) with proof.\n  \u2022 A short bound on |B(v,2t)| and the induced finite enumeration of normalized local orders (Lemma 9).\n- Clarify in Corollary B that the overall runtime is O((2t+2W)\u00b7log* n + O(1)) and dominated by the coloring step for constant \u0394, t, W.\n\nWhy this round is progress\n- We strengthened the normalization toolkit (Lemma 8), formalized the interface-type notion for the path/t=1 case, and articulated a precise, falsifiable claim (C1) whose resolution would close the remaining gap. We also scoped a concrete finite-enumeration approach to test C1 and outlined fallback strategies if it fails. These are incremental, auditable steps towards eliminating mutable-state dependence inside B(v,2t) on trees."}, {"prover_id": "02", "progress_md": "Ideas (closing the main gap)\n- New lemma (faithful phase simulation for arbitrary deterministic Online-LOCAL(t), no extra restrictions): Fix any proper coloring \u03c6 of G^{2t}. There is a deterministic LOCAL simulation that, in O(t\u00b7log* n) (to compute \u03c6) + C\u00b7t rounds (C = \u0394^{O(t)} colors), reproduces exactly the outputs that the online algorithm A would produce on the arrival order that processes color classes 1,2,\u2026,C, with ties inside a color class resolved arbitrarily. On bounded-degree graphs with constant t, this is O(log* n).\n  \u2022 Why this suffices for the task: The online model requires A to succeed for every adversarial order; hence it certainly succeeds for the specific \u201ccolor-by-color\u201d order. Our LOCAL simulation reproduces that run, up to perfect fidelity, yet at a cost of O(log* n) rounds. This directly proves: Any LCL solvable in O(1) rounds in deterministic Online-LOCAL(t) on bounded-degree trees (indeed, bounded-degree graphs) can be solved in O(log* n) rounds in the standard LOCAL model.\n\n- Key observation resolving the prior concern (barrier of unbounded state accumulation): In the color-by-color arrival order, before a vertex v arrives, only vertices of earlier colors have arrived. The online algorithm must work for this order. During phase i, we need to execute the t-round \u201carrival-window\u201d for all vertices v with \u03c6(v)=i. Even though an online execution would conceptually perform these windows sequentially (one at a time), the union of active parts of the system involved in each individual t-window is B(v,t) and, since \u03c6 colors G^{2t}, these t-balls are pairwise disjoint for same-color vertices. Therefore we can execute all these t-windows concurrently in exactly t LOCAL rounds, without interference. No \u201ck\u00b7t\u201d overhead arises, even if the color class has k\u226b1 vertices.\n\nClean statement (to add as a new lemma in output.md)\n- Lemma F (Faithful color-phased simulation of arbitrary deterministic Online-LOCAL(t), W=0). Let A be any deterministic Online-LOCAL(t) algorithm (arrived vertex decides its own output; all previously arrived vertices may maintain arbitrary state across arrivals and participate in the t rounds of subsequent arrivals). Let \u03c6 be a proper coloring of G^{2t} with C colors. There is a deterministic LOCAL algorithm that produces exactly the same outputs as A would produce on the arrival order \u03c3_\u03c6 that processes colors 1,2,\u2026,C, by spending O(t) LOCAL rounds per color and keeping vertices of colors > i passive in phase i. Total round complexity: O(t\u00b7log* n + C\u00b7t) = O(log* n) for bounded \u0394 and constant t.\n  \u2022 Proof sketch (formal details straightforward):\n    1) Compute \u03c6 in O(t\u00b7log* n) rounds (Lemma 1). Fix the arrival order \u03c3_\u03c6: all color-1 vertices arrive first (in any order), then color 2, etc. Since A is correct for every order, it is correct for \u03c3_\u03c6.\n    2) Inductive invariant I(i): After finishing phase i, the global state of all arrived vertices (colors \u2264 i), and the fixed outputs for these vertices, are exactly those that would arise in an online execution of A under \u03c3_\u03c6 after all color-\u2264i vertices have been processed (sequentially in any order within the color), and vertices of colors > i have not yet arrived (absent from the induced subgraph).\n    3) Base i=0: vacuous. Step i\u2192i+1: In phase i+1 we must run the \u201carrival window\u201d (t rounds) for every v with \u03c6(v)=i+1, over the subgraph induced by colors \u2264 i+1, with vertices of colors > i+1 absent. For a single vertex v this t-window involves only nodes in B(v,t); nodes outside B(v,t) cannot influence or be influenced (information cannot travel > t hops in t rounds). If u and v share the same color i+1, then dist(u,v)>2t, hence B(u,t)\u2229B(v,t)=\u2205, and their windows can be executed simultaneously without interference in exactly t rounds. (Previously arrived vertices may participate in these t rounds, but only those inside the corresponding disjoint t-balls.) Therefore, after t rounds, every color-(i+1) vertex has exactly the output it would get in the run of A under \u03c3_\u03c6; all other states/outputs also match, proving I(i+1).\n    4) After phase C we have the outputs A would produce on \u03c3_\u03c6. Since A is correct for all orders, the labeling satisfies \u03a0.\n\n- Variant with bounded writes (optional, for completeness): If A (at arrival of v) may additionally finalize outputs on a patch B(v,W), the same simulation goes through using a proper coloring of G^{2t+2W} (so that the \u201cinfluence regions\u201d B(v,W+t) are disjoint inside a color). In phase i, we run t rounds over the subgraph induced by colors \u2264 i, with vertices of colors > i absent, and let each new vertex v finalize the patch B(v,W). The per-color runtime is still t, and correctness follows by the same invariant. This matches the K = 2t+2W bound already used in Lemma 5/Corollary B.\n\nWhy this closes the loop\n- The main task asks to simulate any O(1)-round deterministic online-local algorithm on bounded-degree trees in O(log* n) LOCAL rounds. Lemma F does exactly that (and for general bounded-degree graphs), relying only on (i) a distance-(2t) coloring and (ii) faithful, batched execution of t-windows per color. No restrictions such as \u201coutput-only\u201d or \u201ct-local-dependence\u201d are needed. The essential ingredient is that A must succeed for every arrival order, so we are free to choose the color-by-color order.\n\nSanity checks and examples\n- Path graph, t=1, \u201clong-haul state accumulation\u201d algorithm A. Even if one can design A so that, under some orders, far-away information travels across many arrivals before a vertex v appears, A must also succeed under order \u03c3_\u03c6, where only O(1) color classes arrive before v. Our simulation reproduces precisely that run of A; hence the output is valid. The earlier apparent obstacle (needing \u0398(n)\u00b7t global rounds pre-arrival) is resolved by choosing a benign order.\n- Toy parallelization check: two new vertices u,v at distance \u22652t in the same phase. In A, if processed sequentially, first arrival\u2019s t rounds touch only B(\u00b7,t), then the second\u2019s t rounds touch only the other t-ball; batching them into one t-round block yields identical transcripts in the two disjoint neighborhoods.\n\nGaps or edits needed in output.md\n- Current output.md (Round 0003) contains:\n  \u2022 Bridges for output-only and for t-local-dependence (Lemmas 3\u20134), the corrected bounded-writes simulation (Lemma 5 with K = max(2W,R+W)), the output-only W-write bridge (Lemma 6), and the commutativity lemma (Lemma 7). All are correct as stated.\n  \u2022 Missing piece: an explicit lemma for the general Online-LOCAL(t) case without extra restrictions (the new Lemma F above). This is the central statement that directly yields the desired O(log* n) upper bound for arbitrary deterministic online-local algorithms on bounded-degree trees.\n- Actionable addition for output.md: Add Lemma F (as above) and its proof. Then state the main theorem as a corollary: On bounded-degree trees (indeed, graphs), any LCL \u03a0 solvable in O(1) rounds in deterministic Online-LOCAL(t) admits an O(log* n) deterministic LOCAL algorithm. Optionally include the bounded-writes variant using a G^{2t+2W}-coloring.\n\nRelation to earlier commutativity tool\n- Lemma 7 and Corollary 7.1 remain useful generally (e.g., for order normalization arguments, or if one prefers a proof with an explicit swapping argument). However, Lemma F gives a simpler, direct construction via a fixed order \u03c3_\u03c6.\n\nObstacles and caveats to keep in mind\n- Model semantics: In each phase we must ensure that vertices of colors > i are \u201cabsent\u201d: they neither send nor receive messages. This is easily enforced in the LOCAL simulation by having these nodes ignore messages (remain silent) until their phase.\n- Independence radius: The 2t separation is tight for W=0. With W>0, use 2t+2W so that the influence regions B(v,W+t) are disjoint inside a color. This matches the corrected K in Lemma 5 (max(2W,R+W) specialized with R=W+t for the online window\u2019s read neighborhood of the patch).\n- Per-phase runtime: Exactly t rounds suffice; we do not need k\u00b7t even if the color class size is k, thanks to disjointness of the active regions.\n\nNext steps (auditable)\n1) Insert Lemma F into output.md with a rigorous inductive proof of invariant I(i); include the bounded-writes variant (coloring G^{2t+2W}).\n2) State the main theorem as a clean corollary and explicitly emphasize that the argument does not rely on orientations (nonoriented trees are fine) nor on tree structure (it works for bounded-degree graphs).\n3) Provide a short \u201cpitfall\u201d remark explaining why the earlier worry about long state accumulation is resolved by choosing a suitable arrival order, and why batching t-windows per color costs only t rounds.\n4) Optionally keep the bridges (Lemmas 3\u20136) as auxiliary tools\u2014they remain correct and are useful independently (e.g., if one wants a sequential-rule perspective).\n\nWhy this is meaningful progress\n- We isolate and formalize the decisive lemma (faithful batched simulation of arbitrary deterministic online-local t-windows by colors), with a tight radius argument and runtime accounting. This cleanly settles the stated task for (nonoriented) bounded-degree trees and, in fact, for bounded-degree graphs. The lemma is ready to be integrated into output.md as a short but complete proof component.\n"}]

Current notes.md:
Context and goal
We study the relationship between online-style constant-locality algorithms for LCLs on bounded-degree, unoriented trees and deterministic LOCAL-time upper bounds. Two notions of “online local” are relevant:
- Sequential local/greedy model (order-robust r-local): when processing a vertex v, the decision at v depends only on the r-hop neighborhood B(v,r) of the underlying graph and on already fixed outputs within B(v,r); the algorithm must succeed for every vertex order. No global mutable state or long-range message accumulation between steps.
- Online-LOCAL(t) (Akbari–Eslami–Lievonen–Melnyk–Särkijärvi–Suomela, ICALP’23): vertices arrive one by one; upon each arrival, the algorithm has t synchronous LOCAL rounds on the subgraph induced by arrived vertices; outputs are irrevocable. Over many arrivals, an unbounded number of communication rounds can occur, enabling long-range state accumulation.

Safe, proven variant (archived below in output.md)
- Theorem (Sequential-local to LOCAL): If an LCL Π on bounded-degree graphs has a deterministic order-robust r-local sequential algorithm (decisions at v depend only on B(v,r) and outputs of earlier vertices in B(v,r), and the rule writes only the output at v), then Π has a deterministic LOCAL algorithm running in O(r log* n + Δ^{O(r)}) rounds. On bounded-degree trees with constant r, this is O(log* n). Proof: compute a proper coloring of G^r in O(r log* n) rounds with Δ^{O(r)} colors; process color classes in order, letting each v gather outputs from B(v,r) restricted to earlier colors and apply the sequential rule. Because nodes of the same color are at distance > r, their decisions do not depend on each other.

Gap for the full Online-LOCAL(t) model
- A direct phase simulation that uses a distance-(2t) coloring and t rounds per color does not generally reproduce the state a node v would see upon arrival in an actual online execution. In a true online run, before v arrives, there may have been Θ(n) earlier arrivals, yielding Θ(n)·t global rounds; information can propagate arbitrarily far and may alter the states within B(v,t). The phase simulation grants only O(1)·t total rounds before v’s phase, so the local states can differ. Hence, without additional constraints, we cannot claim that the phase simulation faithfully reproduces the online run or even yields correctness solely from A’s correctness.

Ways forward for Online-LOCAL(t)
- Add a locality-of-dependence assumption: the t-round transcript that determines v’s output depends only on the arrived subgraph inside distance ≤ t from v and on the outputs of those nodes, not on mutable states imported from farther away. Under this, distance-(2t) coloring plus phase simulation is valid and yields O(log* n).
- Alternatively, seek a structural scheduling/padding argument ensuring that for LCLs on bounded-degree trees, the state within B(v,t) before v’s arrival is independent of far-away arrivals. This is nontrivial; try first on paths/trees with t=1 to see whether accumulation can matter for any LCL.
- Or try to separate the models: construct an LCL that is solvable in constant t in Online-LOCAL but provably not simulable by the above constant-phase compression; if such an LCL exists, the general reduction fails, and the sequential-local variant becomes the correct target.

Remarks
- No global edge orientation is needed anywhere in the reduction we proved; IDs suffice for coloring.
- The archived proof applies to all bounded-degree graphs; we stated trees to match the project focus.
Refinements on bridging Online-LOCAL(t) to sequential local rules
- Definitions (recap and refinement):
  • Online-LOCAL(t): vertices arrive one by one; upon each arrival we have t synchronous LOCAL rounds on the subgraph induced by arrived vertices; outputs are irrevocably set at arrival; in the general model, nodes may maintain unbounded mutable state across arrival windows.
  • Output-only Online-LOCAL(t): the only persistent state at nodes is the immutable output label after it is set; between windows there is no other state; in any t-round window, messages sent by a node are functions only of the underlying graph and the currently known outputs within its distance-t neighborhood (no dependence on farther outputs or on pre-window mutable state).
  • t-local-dependence at v: when v arrives, its output depends only on the arrived subgraph restricted to B(v,t) and outputs of the arrived nodes within B(v,t).

- Correct radius accounting:
  • At v’s arrival with window length t, nodes within B(v,t) can influence v. A node u ∈ B(v,t) may compute its messages based on outputs within B(u,t), which is contained in B(v,2t). Thus, in the output-only model, v’s output depends only on the graph structure and outputs within B(v,2t). Consequently, the correct bridge is to a sequential rule of radius 2t (not t). If we assume t-local-dependence at v, the bridge tightens to radius t.

- Minimal counter-scenario (why naive phase-compression fails for the unrestricted online model):
  Consider a path with t=1. In a genuine online run, before a vertex v arrives, Θ(n) earlier arrivals can propagate state one hop per window across the path; by the time v arrives, its neighbors may carry information injected far away. A color-phased simulation that offers only O(1) windows before v’s phase cannot reproduce these accumulated states. This shows that without output-only or t-local-dependence, we cannot black-box simulate arbitrary Online-LOCAL(t) runs by a constant number of phases.

- Practical takeaway for reductions:
  • If your online algorithm is output-only, design the sequential rule to read B(v,2t) and write only at v; then apply the G^{2t} coloring pipeline to get O(log* n) on bounded-degree trees.
  • If your online algorithm satisfies t-local-dependence at v, the sequential rule needs only B(v,t).

- Next-step plan (state elimination on trees):
  • Start on paths with t=1. Define the interface ∂B(v,2) and annulus R=B(v,2)\B(v,1). Attempt to prove: if two online executions agree on outputs over B(v,2), then they allow exactly the same outputs at v. If proven, extend to trees and t by replacing 2 with 2t. If refuted, crystallize a separation example.
  • Track read/write radii for any sequential rules that go beyond “write only at v”; use distance-(R+W) colorings for phase independence.
Additions and corrections

1) Correct simulation radius for bounded writes.
- When simulating an order-robust sequential rule that reads within B(v,R) and may write within B(v,W), independence within a color class requires both:
  • Write–write disjointness: B(u,W) ∩ B(v,W) = ∅.
  • Read–write disjointness: B(u,R) ∩ B(v,W) = ∅ and B(v,R) ∩ B(u,W) = ∅.
- These are guaranteed if dist(u,v) > max(2W, R+W). Therefore, the correct coloring is a proper coloring of G^K with K = max(2W, R+W). Using G^{R+W} alone is insufficient in general.
- Minimal counterexample to G^{R+W}: Take R=0, W=1 on the path u–x–v. Here dist(u,v)=2>R+W, but B(u,1)∩B(v,1)={x} so simultaneous writes conflict.

2) Output-only, W-write Online-LOCAL(t) ⇒ sequential (R,W) with R=2t+W.
- Model: When v arrives, A runs t rounds and may irrevocably write outputs on B(v,W); messages during this window depend only on the graph and the currently known outputs within distance ≤ t of the sender; no other mutable state persists.
- Radius accounting: To decide outputs on the patch B(v,W) within t rounds, only nodes in B(B(v,W), t) = B(v, W + t) can send messages that reach the patch. Under output-only, each such sender’s messages are functions of outputs in its own t-ball. Hence the decisions on the patch depend only on outputs within B(v, W + 2t) = B(v, 2t + W).
- Sequential rule S: For a given order σ, when processing v, S reads already-fixed outputs in B(v, 2t+W) and deterministically reproduces A’s t-window on the patch, writing only to currently-unset outputs in B(v,W). Because A is deterministic and correct for all orders, S reproduces A’s result for order σ.

3) Commutativity of independent arrivals (unrestricted Online-LOCAL(t)).
- If two consecutive arrivals u and w satisfy dist(u,w) > 2t, swapping their order leaves the t-round transcripts and resulting states identical everywhere. In particular, by repeatedly swapping, one can assume that, when analyzing v, only arrivals within B(v,2t) occur before v. This normalizes the analysis horizon for any state-elimination attempt.

4) State-elimination program on paths (t=1) — concrete targets.
- Define the interface K(v) as the already-fixed outputs on B(v,2) just before v arrives (after normalizing the order so only B(v,2) arrives first). Target claim (context-invariance): The set of feasible outputs/messages at v depends only on K(v). If true, derive a canonical sequential rule of read radius R=2 and (potential) write radius W by reproducing the canonical choice. If false, document a counterexample LCL on paths.

5) Accounting for LOCAL complexity when W>0.
- With (R,W)-local sequential rules, compute a proper coloring of G^{K} with K = max(2W, R+W) in O(K log* n) rounds (Lemma 1 simulated on G), then process colors in O(R) rounds per color. On bounded-degree trees with constant R,W, this gives O(log* n) overall.


Current output.md (if any):
List of proven results archived here
- Lemma 1: Power-graph coloring in O(k log* n).
- Lemma 2: Color-phased simulation for order-robust read-radius r rules that write only at the current node (W=0).
- Theorem A: Sequential-local (W=0) ⇒ LOCAL on bounded-degree graphs.
- Lemma 3: Bridge from output-only Online-LOCAL(t) (W=0) to order-robust sequential with read radius 2t.
- Lemma 4: Bridge under t-local-dependence (W=0) to read radius t.
- Corollary A: On bounded-degree trees, constant r or constant t ⇒ O(log* n) LOCAL.
- Lemma 5: Color-phased simulation for sequential rules with read radius R and write radius W via a G^{K}-coloring with K = max(2W, R+W).
- Lemma 6: Bridge from output-only, W-write Online-LOCAL(t) to an order-robust sequential rule with (R,W) = (2t+W, W).
- Corollary B: On bounded-degree trees, constant t,W in output-only W-write Online-LOCAL(t) ⇒ O(log* n) LOCAL.
- Lemma 7: 2t-commutativity of independent consecutive arrivals in Online-LOCAL(t), and a corollary pushing far-away arrivals past a fixed v.

Model and definitions
- Graphs: finite, simple, maximum degree Δ < ∞ (bounded degree). Nodes have unique IDs from a polynomial range (standard LOCAL assumptions). dist(·,·) is the hop distance; B(v,r) is the radius-r ball around v.
- LCL Π: a locally checkable labeling problem with constant checkability radius r_Π.
- Order-robust sequential rules with bounded writes: A deterministic rule S with read radius R and write radius W is a procedure that, when processing v in a vertex order σ, inspects G[B(v,R)] and the outputs already fixed in B(v,R) ∩ {earlier vertices in σ}, and may irrevocably write outputs on any currently-unset vertices in B(v,W). The final labeling must satisfy Π for every σ. (The special case W=0 writes only at v.)
- Online-LOCAL(t): vertices arrive one by one; at each step the algorithm executes t synchronous LOCAL rounds on the subgraph induced by the arrived vertices; outputs are irrevocable; nodes may maintain arbitrary local state across steps unless otherwise restricted.
- Output-only Online-LOCAL(t): the only persistent state is the immutable output label after it is set; in any t-round window, messages and local computation at a node may depend on the graph and currently known outputs within distance ≤ t from that node, but not on any other mutable state.
- t-local-dependence (at v): upon v’s arrival, its output depends only on the induced arrived subgraph and previously fixed outputs within B(v,t).
- Output-only, W-write Online-LOCAL(t): as output-only above, but when v arrives the algorithm may irrevocably fix outputs on any vertices in B(v,W).

Lemma 1 (Power-graph coloring in O(k log* n))
Statement. Let G be a bounded-degree graph and k ≥ 1 a constant. There is a deterministic LOCAL algorithm that computes a proper vertex coloring of the power graph G^k with at most C = Δ^{O(k)} colors in O(k log* n) rounds on G.
Proof. Standard: simulate an O(log* n)-round O(Δ(G^k)^2)-coloring on G^k by k rounds per step on G; Δ(G^k) ≤ Δ^k, hence C = Δ^{O(k)}. □

Lemma 2 (Color-phased simulation for W=0)
Statement. Let S be an order-robust sequential rule with read radius r that writes only at the current node (W=0). Given a proper coloring of G^r, processing colors 1,…,C in order reproduces S for any order respecting the color layering, using O(r) rounds per color.
Proof. If φ(u)=φ(v) then dist(u,v)>r, hence the decisions in phase i depend only on outputs from earlier colors and do not interfere. Each node gathers outputs in B(·,r) from earlier colors in O(r) rounds and applies S. □

Theorem A (Sequential-local (W=0) ⇒ LOCAL)
Statement. If Π admits an order-robust r-local sequential algorithm (W=0), then Π has a deterministic LOCAL algorithm running in O(r log* n + Δ^{O(r)}·r) rounds. For constant Δ,r: O(log* n).
Proof. Compute a G^r-coloring in O(r log* n) rounds (Lemma 1), then simulate by Lemma 2. □

Lemma 3 (Output-only Online-LOCAL(t), W=0 ⇒ sequential with read radius 2t)
Statement. If Π has a deterministic output-only Online-LOCAL(t) algorithm correct for every arrival order, then Π admits an order-robust sequential algorithm with read radius 2t (W=0) that reproduces the online outputs for any order.
Proof. Fix order σ. When v_i arrives online under σ, only nodes in B(v_i,t) can send messages that reach v_i within t rounds. Under output-only, any such message depends only on outputs within the sender’s B(·,t), all contained in B(v_i,2t). Hence v_i’s t-window transcript and output are functions of the restriction to B(v_i,2t) of the arrived subgraph and outputs. Define the sequential rule to read those and return the same output as the online algorithm would under σ. Correctness and order-robustness follow. □

Lemma 4 (Bridge under t-local-dependence, W=0)
Statement. If Π has a deterministic Online-LOCAL(t) algorithm with t-local-dependence (at every v) that is correct for every arrival order, then Π admits an order-robust sequential algorithm with read radius t (W=0).
Proof. As in Lemma 3, but with t in place of 2t by hypothesis. □

Corollary A (Bounded-degree trees, constant r or t)
Statement. On bounded-degree trees, if Π has either (i) an order-robust r-local sequential algorithm (W=0) with constant r, or (ii) an output-only Online-LOCAL(t) algorithm (W=0) with constant t, or (iii) an Online-LOCAL(t) algorithm with t-local-dependence and constant t, then Π has a deterministic LOCAL algorithm with round complexity O(log* n).
Proof. Combine Theorem A with Lemma 3 or Lemma 4 as applicable; Δ and radii are constants. □

Lemma 5 (Color-phased simulation with bounded writes)
Statement. Let S be an order-robust sequential rule with read radius R and write radius W ≥ 0 (S may write outputs on currently-unset vertices in B(v,W)). Let φ be a proper coloring of G^{K} with K = max(2W, R+W). Then processing colors 1,…,C in order reproduces S for any order that respects the color layering. The per-color communication cost is O(R) rounds after φ is known.
Proof. If φ(u)=φ(v) then dist(u,v) > K ≥ 2W and > R+W. Thus (i) B(u,W) ∩ B(v,W) = ∅ (no write–write conflicts) and (ii) B(u,R) ∩ B(v,W) = ∅ and B(v,R) ∩ B(u,W) = ∅ (no read–write interference). In phase i, each vertex v with φ(v)=i gathers outputs written by earlier colors within B(v,R) and computes its writes; because of (i)–(ii), these writes are independent across same-color vertices and depend only on earlier colors, so the result matches S for any order that lists all lower colors first and then the current color in any internal order. O(R) rounds suffice to gather B(v,R) information. Computing φ takes O(K log* n) rounds by Lemma 1 with k=K. □

Lemma 6 (Output-only, W-write Online-LOCAL(t) ⇒ sequential with (R,W)=(2t+W,W))
Statement. If Π has a deterministic output-only, W-write Online-LOCAL(t) algorithm A correct for every arrival order, then Π admits a deterministic order-robust sequential rule S that, when processing v, reads only B(v, 2t+W), may write on currently-unset vertices in B(v,W), and reproduces A’s outputs for any order.
Proof. Fix order σ = (v_1,…,v_n). Consider A under arrival order σ. When v_i arrives, during its t-round window only nodes within distance ≤ t of the patch B(v_i,W) can send messages that reach the patch; hence all influencing senders lie in N := B(B(v_i,W), t) = B(v_i, W+t). Under output-only, messages sent by any u ∈ N depend only on outputs within B(u,t). Therefore the union of outputs that can affect the patch’s decisions lies in M := ⋃_{u∈N} B(u,t) = B(v_i, W+2t). Consequently, the t-round transcript determining the patch outputs in the σ-run is a function of the restriction of the arrived subgraph and already-fixed outputs to B(v_i, 2t+W). Define S as follows: when processing v_i under σ, S collects the already-fixed outputs within B(v_i, 2t+W) ∩ {v_1,…,v_{i-1}} and deterministically reproduces A’s t-window decisions on the patch given that local view, writing only to vertices in B(v_i,W) whose outputs are not yet fixed. Because A is deterministic and respects irrevocability, this reproduces exactly the same patch outputs as A under σ and never overwrites. As A is correct for every order, S is an order-robust (R,W)-local rule with R=2t+W. □

Corollary B (Bounded-degree trees, output-only W-write ⇒ O(log* n) LOCAL)
Statement. On bounded-degree trees, if Π has a deterministic output-only, W-write Online-LOCAL(t) algorithm with constants t,W, then Π has a deterministic LOCAL algorithm with round complexity O(log* n).
Proof. Apply Lemma 6 to obtain a sequential (R,W)-rule with R=2t+W. Then use Lemma 5 with K = max(2W, R+W) = max(2W, 2t+2W) = 2t+2W to simulate S in the LOCAL model: compute a proper coloring of G^{2t+2W} in O((2t+2W) log* n) rounds, then spend O(R)=O(2t+W) rounds per color. For constant Δ,t,W the total is O(log* n). □

Lemma 7 (2t-commutativity of independent consecutive arrivals)
Statement. Let A be any deterministic Online-LOCAL(t) algorithm (unrestricted mutable state). Consider an arrival sequence σ and two consecutive arrival steps at vertices u and w such that dist(u,w) > 2t. Let σ′ be obtained by swapping these two steps. Then, after these two steps, the states and fixed outputs at all vertices are identical under σ and under σ′.
Proof. Let G_i be the arrived subgraph just before these two steps. In the step when u arrives under σ, A executes t synchronous rounds on G_i ∪ {u}. Messages can traverse at most t hops per window, so only nodes in B(u,t) can be influenced (either by receiving messages or by depending on received messages); nodes outside B(u,t) undergo the same deterministic state updates as they would in any window where they receive the same (empty) messages. Likewise, w’s step affects only B(w,t). Because dist(u,w) > 2t, the balls B(u,t) and B(w,t) are disjoint, and w is absent during u’s step and u is absent during w’s step in both σ and σ′. Therefore the t-round transcripts and resulting updates within B(u,t) (resp. B(w,t)) are identical in σ and σ′, and all other vertices experience no message-dependent changes in either order. Thus the combined effect of the two steps commutes. □

Corollary 7.1 (Pushing far-away arrivals past v)
Statement. Fix v and any arrival sequence. By repeatedly swapping consecutive independent steps via Lemma 7, one can transform the sequence into another in which all vertices at distance > 2t from v arrive after v, without changing any states or outputs within B(v,t) at the time v arrives (or thereafter).
Proof. Iteratively swap any arrival at distance > 2t from v forward past earlier arrivals until it occurs after v; Lemma 7 ensures the swaps preserve the relevant states/outputs. □

Remark. Lemma 5 supersedes the earlier, flawed variant that required only a G^{R+W}-coloring; the counterexample R=0, W=1 on a 3-path shows that G^{R+W} is insufficient because write–write conflicts may occur.

