{"feedback_md":"Summary and triage\n- The previously archived bridge lemmas (sequential rules with bounded reads/writes; output-only and t-local-dependence reductions; corrected K = max(2W, R+W)) remain correct and valuable. They provide a clean O(log* n) pipeline for output-only/t-local-dependence variants.\n\nAudit of Prover 02 (claimed Lemma F: faithful batched simulation for unrestricted Online-LOCAL(t))\n- Core flaw: In the unrestricted Online-LOCAL(t) semantics, during each arrival step the t synchronous rounds execute over all arrived vertices. Even nodes outside B(v,t) of the newly arrived v may update their local state (e.g., by incrementing a counter) despite receiving no messages. In a sequential online run with k arrivals in a color class, every previously arrived node executes k such “idle” updates. The proposed O(t) per-color batched simulation updates those nodes only once, not k times, so the inductive invariant “global state after phase i matches the online run after all arrivals of colors ≤ i” fails in general.\n- Concrete counterexample (sketch; formalized in notes/output): Consider the trivial LCL that accepts any labeling. Online algorithm A(t=1): every arrived node maintains a parity bit p that toggles at every arrival; the newly arrived node v, in 1 round, reads p from a neighbor (if any) and outputs that parity. In the sequential σ_φ-run (colors 1..C, any internal order) the outputs of same-color vertices alternate with the internal order because p toggles each arrival. A batched O(1)-round simulation that processes all same-color vertices simultaneously cannot reproduce these alternating outputs: all these vertices would see the same p originating from earlier colors and output the same bit. Hence “faithful reproduction” is false in general.\n- Where their proof goes wrong: the assertion that “the union of active parts of the system involved in each individual t-window is B(v,t)” is incorrect for unrestricted Online-LOCAL(t). Nodes outside B(v,t) are active and can change state in each step, even if they see no messages. Compressing k steps to 1 step per phase requires knowing k and applying k-fold local updates everywhere; this is not locally computable in o(diameter) rounds in general.\n- Bottom line: Do not add Lemma F. The overall “pick a benign order σ_φ and simulate it with O(t) per color” strategy is invalid without extra structure that prevents or neutralizes “idle” state evolution far from the arriving node.\n\nAudit of Prover 01\n- Lemma 8 (“strong witness localization”) is essentially Corollary 7.1 already present in output.md; it is correct and useful. (We suggest keeping one unified statement; no need to duplicate.)\n- Lemma 9 (“finite local enumeration for t=1 on paths”) is false as stated under standard LOCAL assumptions: messages/states can encode IDs, so even with a constant-size ball B(v,2) and finite permutations of arrivals, the set of possible transcripts seen by v need not be bounded by a constant independent of n. Finite enumeration becomes viable only under additional constraints (e.g., ID-obliviousness, bounded message alphabets, bounded state, or output-only).\n- Claim C1 (“context-invariance” for paths, t=1) is an interesting target but is unlikely to hold without constraints, for the same reason: nodes in B(v,2) can adopt different states/messages that depend on the number of far-away arrivals (step count), even when K(v) (the pattern of fixed outputs in B(v,2)) is the same. If pursued, restrict to regimes where messages/states depend only on local outputs (output-only) or impose quiescence/ID-obliviousness.\n\nPromising directions and concrete next steps\n1) Document and internalize the negative: add a rigorous “pitfall” remark (with counterexample) to output.md preventing reintroduction of the flawed batched-simulation idea for unrestricted Online-LOCAL(t).\n2) If one wants an O(log* n) reduction via batched phases, introduce an explicit quiescence assumption: in every arrival step, nodes outside B(v,t) perform the identity state update (or state evolution independent of the number of steps). Under such a constraint, the per-color t-round batching becomes valid. Formalize and prove this variant if it is of interest; relate it to the already-established output-only and t-local-dependence bridges.\n3) Path/t=1 interface program: proceed with caution. Either:\n   - Prove C1 under added structure (e.g., output-only or bounded-state/ID-oblivious), or\n   - Refute C1 in the unrestricted model by exhibiting a neighbor-interface that depends on step count despite fixed K(v) (build on the parity-counter idea). In both cases, keep the analysis confined to B(v,2) using Corollary 7.1.\n4) Maintain the corrected K = max(2W, R+W) accounting throughout. Optionally add a brief complexity remark to output.md (O((2t+2W)·log* n) dominated by the coloring step for bounded Δ,t,W).\n\nNet assessment\n- Keep all existing rigorous bridges. Do not add Lemma F. Treat Lemma 8 as already covered by Corollary 7.1. Discard Lemma 9 as currently invalid. Focus next on either tightening assumptions (quiescence/output-only) to close the pipeline, or constructing a clean counterexample to Claim C1 in the unrestricted model.","new_notes_md":"Disproof of “faithful color-by-color simulation” for unrestricted Online-LOCAL(t)\nThe tempting idea to fix a proper coloring φ of G^{2t}, choose the arrival order σ_φ that processes color classes 1,2,…,C, and then simulate each color class in O(t) rounds by running all arrivals of that color concurrently, is not valid in the unrestricted Online-LOCAL(t) model.\n\nKey obstruction: In the Online-LOCAL(t) semantics, each arrival triggers t synchronous rounds across the entire arrived subgraph. Nodes outside B(v,t) of the newly arrived vertex v may still update their local state in that step (e.g., increment a local counter) even though they receive no messages. Over k arrivals in a color class, every previously arrived node performs k such \"idle\" updates. Compressing k steps to 1 per color fails to reproduce the global state unless one can apply k-fold local updates everywhere, which is not locally computable in O(1) rounds.\n\nMinimal counterexample (paths, t=1). Consider the trivial LCL Π that accepts any labeling. Define a deterministic Online-LOCAL(1) algorithm A as follows:\n- Every arrived node maintains a parity bit p, initially 0, and toggles p at every arrival step (independently of messages).\n- When a new vertex v arrives, in the 1-round window v queries any neighbor u (if one exists) for p and outputs that bit. (If v has no arrived neighbor, it outputs 0.)\nThis A is correct for Π for every arrival order (Π accepts any labeling). Fix any proper 3-coloring φ of the path’s G^2. In the sequential σ_φ-run that processes all color-1 vertices one by one, p toggles at every arrival, so the outputs of color-1 vertices alternate with their internal order. A batched O(1)-round simulation that processes all color-1 vertices simultaneously cannot reproduce these alternating outputs: all of them see the same parity p from earlier colors and output the same bit. Hence faithful reproduction of the σ_φ-run is impossible in general.\n\nConsequences.\n- The earlier “main gap” (state accumulation across many arrivals) is real for unrestricted Online-LOCAL(t): batched simulation does not, in general, preserve the online run’s state trajectory.\n- To make per-color batching sound, one needs extra structure such as quiescence: outside B(v,t), the per-step state update is the identity (or, more generally, does not depend on the number of arrivals). The output-only and t-local-dependence variants already enforce related constraints.\n\nOn Lemma 8 and local order normalization\n- Our Corollary 7.1 already implies the witness localization needed for per-node analysis: by swapping distant arrivals (dist > 2t), one can assume all arrivals before v occur in B(v,2t) without changing the state in B(v,t) at v’s arrival. This is the appropriate normalization tool for any local confluence/interface analysis.\n\nOn Lemma 9 (finite enumeration claim)\n- As stated (“the set of possible transcripts/messages seen by v is finite”), this is false in the standard LOCAL model due to unbounded message/state spaces and dependence on unique IDs. Finite enumeration becomes viable only if one assumes bounded message alphabets, bounded state, or ID-obliviousness; otherwise, for a fixed constant-size ball B(v,2), the algorithm can encode arbitrarily large ID-dependent information into messages/states.\n\nNext steps for the path/t=1 interface program\n- Either (i) impose output-only (or stronger quiescence/ID-obliviousness) and aim to prove the context-invariance Claim C1 under those constraints, or (ii) build a concrete counterexample to C1 in the unrestricted model by letting neighbors’ 1-round messages to v depend on the number of prior arrivals while keeping K(v) fixed. In both tracks, use Corollary 7.1 to restrict attention to B(v,2).\n\nComplexity reminder for bounded writes\n- With (R,W)-local sequential rules, independence within a color class requires K = max(2W, R+W). Computing a proper coloring of G^{K} costs O(K·log* n) rounds and per-color work is O(R). For bounded Δ, R, W, this yields O(log* n) total complexity dominated by the coloring step.","new_notes_append":"True","new_outputs_md":"Remark (No faithful t-per-color batching for unrestricted Online-LOCAL(t)). There exists a deterministic Online-LOCAL(1) algorithm A and a valid color-by-color arrival order σ_φ (induced by a proper coloring φ of G^2 on a path) such that any LOCAL simulation that processes all vertices of the same color class simultaneously in O(1) rounds cannot reproduce the exact outputs produced by A under the sequential σ_φ-run.\nProof. Consider the trivial LCL Π that accepts any labeling. Algorithm A maintains at each arrived node a parity bit p (initially 0) that toggles at every arrival step (regardless of messages). When a new vertex v arrives, in its 1-round window it reads p from an already-arrived neighbor if one exists and outputs that bit (if v has no arrived neighbor, it outputs 0). Fix any proper 3-coloring φ of the path’s G^2 and let σ_φ process colors 1,2,3 in order, with any internal order inside a color. In the sequential σ_φ-run, the parity p toggles at every arrival, hence the outputs of the vertices of any color class alternate with the internal order. In contrast, if one processes all vertices of a color class simultaneously in a single 1-round batch (keeping not-yet-processed colors absent), all these vertices observe the same parity p from earlier colors and therefore all output the same bit. Thus the batched simulation does not reproduce A’s outputs under σ_φ. □\n\nRemark (Complexity accounting for Lemma 5/Corollary B). On bounded-degree graphs with constants t,W, the coloring step on G^{K} (K = max(2W, R+W), with R = 2t+W in Corollary B) costs O(K·log* n) rounds and yields C = Δ^{O(K)} colors; the per-color work is O(R). Hence the total complexity is O(log* n), dominated by the coloring step.","new_outputs_append":"True","verdict":"nothing so far"}