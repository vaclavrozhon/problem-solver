{
  "progress_md": "High-level status and target\n- We now have a clean O(log* n) pipeline when the online algorithm satisfies output-only (with or without bounded writes) or the stronger t-local-dependence property. The bounded-writes scheduling radius K = max(2W, R+W) is correctly recorded. We also have a rigorously stated obstacle: faithful per-color batching is invalid in the unrestricted Online-LOCAL(t) due to idle state evolution; the minimal parity-counter example documents this.\n- To settle the task in full generality for arbitrary deterministic Online-LOCAL(t) on bounded-degree trees, a remaining route is to separate the \u201clog n-hard\u201d class from the online-constant domain (showing those cannot have t = O(1)), and hence, by the tree-LCL classification, any LCL with Online-LOCAL(t)=O(1) must lie in the O(1)/\u0398(log* n) class, yielding the desired O(log* n) deterministic LOCAL upper bound non-constructively. Below we formulate this lower-bound program precisely and propose a safe additional \u201cquiescent\u201d bridge that can be added to output.md.\n\nNew definitions and lemmas (clean statements, why useful)\n- Definition (Quiescent Online-LOCAL(t)). An online algorithm is quiescent if, at the arrival of v, during the t synchronous rounds, nodes outside B(v,t) do not change their local state (they may ignore all computation/messages and remain idle). Why useful: This explicitly rules out the idle-update obstruction in unrestricted online runs and subsumes output-only as a special case with W=0.\n- Lemma Q (Quiescent \u21d2 O(log* n) LOCAL). If an LCL \u03a0 on bounded-degree graphs has a deterministic quiescent Online-LOCAL(t) algorithm (t=O(1)), then \u03a0 has a deterministic LOCAL algorithm running in O(t\u00b7log* n + \u0394^{O(t)}\u00b7t) = O(log* n) rounds. Sketch: Fix a proper coloring of G^{2t} (Lemma 1). Process color classes 1,\u2026,C. In phase i, all vertices v of color i execute their t-window in parallel. Quiescence ensures that only nodes in the disjoint balls {B(v,t)} may change state during phase i, so per-color cost is exactly t and no cross-interference occurs. Correctness holds for the specific \u201ccolor-by-color\u201d arrival order. This is a safe, self-contained variant to include in output.md.\n- Open transformation target (state-elimination to quiescent on trees). Goal: Given any deterministic Online-LOCAL(t) algorithm A for an LCL \u03a0 on bounded-degree trees, construct a quiescent Online-LOCAL(t) algorithm A\u2032 that reproduces A\u2019s outputs for all arrival orders. Why useful: Combined with Lemma Q, this would close the full generality gap. Status: nontrivial; obstacles below.\n\nLower-bound program: excluding the log n-hard class from constant-t Online-LOCAL on trees\n- Goal LB (Online lower bound for sinkless orientation). Prove: On bounded-degree trees, sinkless orientation cannot be solved by any deterministic Online-LOCAL(t) algorithm with constant t (for adversarial arrival orders). Why useful: By Theorem 2.33 (tree LCL classification), the log n-hard class is exemplified by sinkless orientation. If it requires t growing with n even in Online-LOCAL, then any LCL solvable in O(1) online rounds cannot be in the log n-hard class; hence, by the classification, it must have a deterministic LOCAL algorithm in O(1) or \u0398(log* n) time, giving the desired O(log* n) bound existentially.\n- Toolkit already in output.md: Lemma 7 (2t-commutativity) and Corollary 7.1 (push far-away arrivals past v). These localize pre-v influences to B(v,2t) without assuming quiescence. This is exactly the horizon needed for adapting the round-elimination proof scheme.\n- Proposed Lemma LB.1 (Online node\u2192edge reduction in a localized ball). On a \u0394-regular tree with an ID-graph H as in Theorem 2.16, suppose a deterministic Online-LOCAL(t) algorithm A solves node-centered edge-grabbing (the node form of sinkless orientation) for all arrival orders. For any edge e = uv, after normalizing the prefix so only B(e,2t) arrives first (Cor. 7.1), one can define an edge-centered (t\u22121/2)-local reduction (within B(e,2t)) that decides the orientation of e by exhaustively considering consistent local arrival orders in B(e,2t). This faithfully mirrors Lemma 2.17 in the classical round-elimination proof but with the normalization step replacing global bounds. Why useful: It sets up a t\u2192t\u22121/2 elimination inside a fixed-radius ball for the online model.\n- Proposed Lemma LB.2 (Iterated elimination yields a 0-round contradiction). Iterating the node\u2194edge localized elimination 2t times yields a 0-round edge-centered algorithm on B(e,2t), hence a 0-round global prescription depending only on the ID-graph labels at the edge. As in Theorem 2.15, this contradicts the ID-graph property (Definition 2.16), showing that no constant-t Online-LOCAL algorithm can solve sinkless orientation. Why useful: This delivers the desired lower bound LB.\n- Plan to formalize LB.1\u2013LB.2 (next steps): (i) Specify the semantics of \u201cconsider all consistent local arrival orders within B(e,2t)\u201d and show feasibility because the prefix is normalized and the ball is finite. (ii) Show that any conflict (both endpoints deciding to grab uv) witnessed by two such locally consistent extensions implies an actual global input and arrival order (gluing them into B(e,2t)) under which A fails, contradicting A\u2019s correctness. (iii) Carry the induction to 0 rounds and invoke the ID-graph argument. These steps closely parallel the classical proof and are amenable to rigorous write-up.\n\nObstacles and clarifications\n- Why quiescent reduction from arbitrary online A is hard: Without constraints, idle state updates outside B(v,t) can influence future behaviors inside the next B(\u00b7,t) even after normalization (the influence can be funneled through nodes that will later fall inside B(v,t)). Hence, a priori, replacing such idle updates by identity is not obviously sound. We therefore propose the classification-based route above as a robust way to separate out the hard class.\n- On the path/t=1 \u201cinterface\u201d program: The parity-counter example shows that without constraints, the realized output at v can depend on the number of prior arrivals even with identical K(v). However, to formally refute the context-invariance Claim C1 one needs two normalized histories with the same K(v) but different sets of feasible outputs; constructing such an LCL in the unrestricted model may require additional care (bounded-state/ID-obliviousness would make enumeration finite and C1 provable; otherwise, the set may be infinite). We suggest postponing this until the LB program is resolved.\n\nEdits and additions suggested for output.md\n- Add Lemma Q (Quiescent \u21d2 O(log* n)) with a short proof. It clearly delineates a safe class where per-color batching works.\n- Consider adding a short \u201cRoadmap to online lower bound\u201d remark: explain how Lemma 7/Cor. 7.1 enable localizing the round-elimination to B(e,2t), and outline the forthcoming Lemmas LB.1\u2013LB.2 for sinkless orientation. This prepares for integrating a full proof that Online-LOCAL(t)=O(1) cannot solve the log n-hard LCLs on trees.\n- Keep the existing negative \u201cno faithful batching\u201d remark; it prevents misuse of per-color batching outside quiescent/output-only models.\n\nConcrete next steps (auditable)\n1) Write and insert Lemma Q (quiescent bridge) into output.md, including the bounded-writes variant (color G^{2t+2W}).\n2) Formalize Lemma LB.1 (localized node\u2192edge elimination) and Lemma LB.2 (iteration to 0 rounds) for Online-LOCAL on \u0394-regular trees with an ID-graph H. Provide full proofs, borrowing structure from Theorem 2.15 and leveraging Cor. 7.1.\n3) Conclude the Online-LOCAL lower bound for sinkless orientation on trees: no deterministic constant-t algorithm exists. State the non-constructive corollary: Any LCL on bounded-degree trees solvable in deterministic Online-LOCAL(t) with constant t must admit an O(log* n) deterministic LOCAL algorithm by Theorem 2.33.\n4) Optionally, explore whether the quiescent transformation can be proven for special online designs (e.g., finite-state or ID-oblivious algorithms), which would yield a constructive black-box simulation in those regimes.\n\nNotes on gaps/errors\n- No new errors spotted in output.md; the negative remark correctly blocks earlier flawed batching. Lemma 7 and Cor. 7.1 provide the localization tool we need for the online lower bound program. The quiescent variant is not yet present and can be safely added.\n"
}