--- SYSTEM ---
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (summary so far)
- output.md (rigorously proven results so far)

Guidelines:
- notes.md: should be a readable running log of interesting work. Prefer appending. Replace only if old notes are clearly misleading. Remember -- notes should be self-contained and should make sense even without seeing outputs of past provers. 
- output.md:  Think twice before you add something to this file. Everything here should be rigorous, almost publication-ready. It should contain only fully proven theorems that are clearly an interesting step towards the solution (or the solution itself). The beginning of the file is a clear list of interesting theorems you can prove, together with a discussion about why it is relevant. From the statement of the theorem it has to be clear that this constitutes nontrivial progress towards solution. The rest of the file contains a fully rigorous list of the proofs of the theorems. Keep only proven theorems with clear proofs. If a statement in that file is flawed / unprecise and you cannot fix it on the spot, remove it from output.md and instead add it to notes.md with explanation.
- Be careful with the booleans `new_notes_append` and `new_outputs_append`: default is True (append). Use False only when deliberately rewriting everything.

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (≥200 words). Include concrete next-step suggestions. The next round of provers may not see last round outputs; ensure all valuable info is stored in notes.",
  "new_notes_md": "Markdown (KaTeX allowed). Usually appended to notes.",
  "new_notes_append": "True|False",
  "new_outputs_md": "Markdown (KaTeX allowed). Usually appended to output.md.",
  "new_outputs_append": "True|False",
  "verdict": "success|partial success|nothing so far"
}

**Verdict definitions**:
- **success**: Something that one could publish, even if it is not the full solution (e.g., significant theorem, key lemma, novel technique, partial solution with clear path forward)
- **partial success**: Something worthy enough to write into output.md (e.g., correct but preliminary results, useful technical lemmas, validated approaches that advance understanding)
- **nothing so far**: No meaningful mathematical progress or only exploratory work


--- USER ---
You receive multiple prover reports. Evaluate correctness, value, and pick promising directions. Update notes.md (append/replace) with useful ideas and update output.md (append/replace) ONLY with rigorously verified results.

Prover reports (JSON):
[{"prover_id": "01", "progress_md": "Headlines for this round\n- We isolate and formalize a natural \u201cquiescence\u201d hypothesis for Online-LOCAL(t) that precisely removes the idle-state accumulation pitfall flagged by the verifier, and prove a clean O(log* n) LOCAL simulation under this assumption (also with bounded writes W). This subsumes the output-only bridges and matches many natural online greedy designs.\n- We explain why the existing Lemma 7 (2t-commutativity) remains valid despite unrestricted mutable state, and we suggest a small wording clarification to pre-empt confusion.\n- We outline a concrete program to either (i) transform any Online-LOCAL(t) algorithm for LCLs on trees into a quiescent one (state-elimination-by-quiescence), or (ii) find a counterexample LCL on paths showing that such a transformation is impossible.\n\nNew definition and lemma: quiescent Online-LOCAL(t)\n- Definition (quiescent outside the active ball). A deterministic Online-LOCAL(t) algorithm A is quiescent if, at the arrival of v, the only nodes whose local state may change during the ensuing t synchronous rounds are those in B(v,t). Equivalently, for every arrival step, nodes u with dist(u,v) > t do not modify their state (they may send/receive no messages anyway).\n  \u2022 Bounded-writes extension (W-write): If A, at arrival of v, may irrevocably fix outputs within B(v,W), we say A is (W,t)-quiescent if only nodes in the active region B(v,W+t) may change state during the t-round window.\n  \u2022 Relationship to prior models: Output-only is a special case of quiescence (no mutable state remains, hence trivially no changes outside the active region). The t-local-dependence property is about read-dependence; quiescence is about state updates and complements it.\n\n- Lemma Q (Quiescent Online-LOCAL(t) \u21d2 O(log* n) LOCAL). Let \u03a0 be an LCL on bounded-degree graphs. If \u03a0 has a deterministic quiescent Online-LOCAL(t) algorithm (W=0), then \u03a0 has a deterministic LOCAL algorithm with round complexity O(log* n). More generally, if \u03a0 has a deterministic (W,t)-quiescent Online-LOCAL(t) algorithm, then \u03a0 has a deterministic LOCAL algorithm with round complexity O((2t+2W)\u00b7log* n) = O(log* n) for constant \u0394, t, W.\n  \u2022 Proof sketch (auditable).\n    1) Compute a proper coloring \u03c6 of G^{K} with K = 2t (or K = 2t+2W when W>0) using Lemma 1 in O(K\u00b7log* n) rounds; the color count C = \u0394^{O(K)} is a constant for fixed \u0394, t, W.\n    2) Process color classes 1,2,\u2026,C. In phase i, we simulate, in parallel, the t-round \u201carrival window\u201d of every vertex v with \u03c6(v)=i over the subgraph induced by already-arrived colors \u2264 i (nodes of colors > i stay absent and silent). Because \u03c6 colors G^{2t} (resp. G^{2t+2W}), the active regions B(v,t) (resp. B(v,W+t)) are pairwise disjoint for same-color vertices. Thus the per-phase parallel simulation costs exactly t rounds and there is no inter-phase interference.\n    3) Quiescence guarantees that nodes outside unions of active regions do not change state in a phase. Hence the sequence of states/output labels after finishing phase i exactly matches the sequential online run that processes arrival order \u03c3_\u03c6: first all color-1 vertices in any internal order, then color-2, etc. Induction on i (standard color-phased invariant) completes the argument. Correctness follows from the online algorithm\u2019s correctness for every order; runtime is O(K\u00b7log* n + C\u00b7t)=O(log* n).\n  \u2022 Radii accounting (W>0). Independence of same-color arrivals needs disjointness of the active regions B(v,W+t), hence K = 2t+2W, consistent with Lemma 5\u2019s write\u2013write and read\u2013write separation bound K = max(2W, R+W) with R=W+t here.\n\nWhy this is useful\n- This lemma cleanly fixes the flaw in the previously proposed \u201cfaithful t-rounds-per-color\u201d batching: the failure stemmed from idle updates at distant nodes; quiescence explicitly rules those out. It generalizes the output-only bridges (Lemmas 3 and 6) and conveniently captures many practical online-local designs in which only the newly active t-neighborhood ever changes state.\n- Examples (fit quiescence): Greedy MIS, greedy maximal matching (with W=1), and (\u0394+1)-coloring variants that only modify states/labels within distance 1 of the arriving vertex; in all such rules, no node outside the local t-ball modifies its state during an arrival step.\n\nClarification about Lemma 7 (2t-commutativity)\n- Status: Lemma 7 in output.md is sound even under unrestricted mutable state. The proof informally remarks that nodes outside B(u,t) \u201cundergo the same deterministic state updates as they would in any window where they receive the same (empty) messages\u201d. A potential confusion was whether state updates could depend on the identity of the arriving vertex or a global step counter. Swapping two consecutive arrivals at u and w: (i) nodes outside B(u,t)\u222aB(w,t) experience two consecutive steps with empty incoming messages in both orders, hence perform the same pair of updates (possibly depending on step index), and (ii) nodes in B(u,t) (resp. B(w,t)) are unaffected by the arrival at w (resp. u) due to t-hop message speed, hence their transcripts in the two orders are identical. Therefore, the combined effect commutes.\n- Suggestion for output.md: Add a sentence noting explicitly that the argument allows arbitrary deterministic updates of \u201cidle\u201d nodes that depend on the step index but not on messages; since the number and positions of the two steps are the same after swapping, their updates coincide.\n\nRelationship to the current archive (output.md)\n- The new Lemma Q can be added as a sibling of Lemmas 3\u20136. It strictly subsumes Lemma 3 (output-only, W=0) and Lemma 6 (output-only, W>0): output-only implies quiescence, so Q re-derives Corollary B. It also clearly separates the regimes: unrestricted Online-LOCAL(t) (with idle updates) does not admit the batched simulation (see the parity-counter counterexample already added as a remark), whereas quiescent Online-LOCAL(t) does.\n- No changes are needed to Lemma 5\u2019s coloring radius K = max(2W, R+W); here R = W+t in the (W,t)-quiescent case, giving K = 2t+2W, as used in the proof.\n\nState-elimination-by-quiescence program on trees (next objective)\n- Goal: Show that for LCLs on bounded-degree trees, any deterministic Online-LOCAL(t) algorithm can be transformed into an equivalent quiescent Online-LOCAL(t) algorithm (or into an order-robust sequential (R,W)-local rule). This would remove the extra assumption and settle the main task in full generality.\n- Rationale. For LCLs, correctness depends only on the final labeling and local constraints. On trees, Corollary 7.1 localizes pre-arrival influence to B(v,2t). We conjecture that any dependence on idle state accumulation outside active balls can be compiled away without affecting the final outputs: replace far-away idle dynamics by a canonical, inert behavior (quiescence) together with a localized interface summary at \u2202B(v,2t), sufficient to reconstruct any messages that matter for v\u2019s decision.\n- Concrete plan (auditable, starting with paths, t=1):\n  1) Normalize the arrival order using Corollary 7.1 so that only vertices in B(v,2) are processed before v.\n  2) For each neighbor u of v, define the interface relation \u03a3(u\u2192v): the set of possible neighbor-to-v messages u can send at the start of v\u2019s window over all normalized executions consistent with the same already-fixed outputs on B(v,2). Try to prove that \u03a3(u\u2192v) depends only on those outputs (context-invariance), not on internal mutable state histories. This is exactly the step where idle updates must be shown irrelevant for LCLs.\n  3) If successful, define a canonical message selector and hence a quiescent rule (no far-away updates) that reproduces the same outputs; if not, construct a counterexample LCL on paths demonstrating that idle updates can alter \u03a3(u\u2192v) despite fixed B(v,2) outputs.\n\nExamples and sanity checks\n- MIS and matching (greedy, patch-based): These are (W,t)-quiescent with W=1, t=1. Lemma Q immediately yields O(log* n) LOCAL.\n- (\u0394+1)-vertex-coloring with an arriving-vertex patch that finalizes the vertex and possibly one-hop neighbors (W=1, t=1): also (W,t)-quiescent. Lemma Q applies.\n- Non-quiescent toy algorithm (not an LCL witness): The parity-toggling construction in output.md shows that faithful batching fails without quiescence, but since it targets a trivial LCL, it does not refute the existence of some other correct batched simulation. This underscores the need for either a quiescentization proof or a genuine LCL counterexample.\n\nGaps or edits to output.md\n- Add Lemma Q (Quiescent Online-LOCAL(t) \u21d2 O(log* n), with the W-write extension) including the exact radius/coloring parameters: K = 2t (W=0) and K = 2t+2W (W>0), per-phase time t, total O(log* n) on bounded-degree graphs.\n- After Lemma 7, include a brief clarifying remark that idle updates depending only on step index are handled by the swap argument (as noted above).\n- Keep the existing \u201cNo faithful t-per-color batching for unrestricted Online-LOCAL(t)\u201d remark; it documents the core obstruction and motivates the quiescence hypothesis.\n\nObstacles and risks\n- Quiescence is a strong assumption; while it matches many natural greedy rules, it may not cover all constant-time online algorithms. The main technical challenge is to either justify that quiescence is without loss of generality for LCLs on trees (state-elimination), or exhibit a separating LCL.\n- The interface-invariance step on paths, t=1, may fail in the unrestricted model due to unbounded state+IDs; if so, we will aim to craft an explicit LCL that requires such dependence.\n\nNext steps (concrete)\n1) Integrate Lemma Q (statement and proof) into output.md and explicitly note that it subsumes the output-only bridges.\n2) Begin the path/t=1 state-elimination-by-quiescence attempt:\n   - Precisely formalize \u03a3(u\u2192v) and the notion of \u201cconsistent normalized executions\u201d (after Corollary 7.1).\n   - Try to prove context-invariance of \u03a3(u\u2192v) under the LCL constraint (messages that affect v depend only on B(v,2) already-fixed outputs). If successful, define a canonical quiescent neighbor interface and derive a quiescent online rule.\n   - In parallel, explore candidate LCLs that might violate context-invariance by encoding a step-count into neighbor messages without affecting B(v,2) outputs.\n3) Maintain radii accounting: for any (R,W)-local sequential rule extracted from a quiescent online rule, ensure simulation by a G^{K} coloring with K = max(2W, R+W) as in Lemma 5.\n\nWhy this is progress\n- The quiescence lemma pinpoints a precise, verifiable condition under which the O(log* n) speedup holds for arbitrary deterministic Online-LOCAL(t) algorithms (bounded-degree trees or graphs), consolidating and extending the previously archived bridges.\n- It gives a crisp target for the remaining open part: either prove quiescence w.l.o.g. for LCLs on trees (closing the task) or demonstrate a tight counterexample.\n"}, {"prover_id": "02", "progress_md": "High-level status and target\n- We now have a clean O(log* n) pipeline when the online algorithm satisfies output-only (with or without bounded writes) or the stronger t-local-dependence property. The bounded-writes scheduling radius K = max(2W, R+W) is correctly recorded. We also have a rigorously stated obstacle: faithful per-color batching is invalid in the unrestricted Online-LOCAL(t) due to idle state evolution; the minimal parity-counter example documents this.\n- To settle the task in full generality for arbitrary deterministic Online-LOCAL(t) on bounded-degree trees, a remaining route is to separate the \u201clog n-hard\u201d class from the online-constant domain (showing those cannot have t = O(1)), and hence, by the tree-LCL classification, any LCL with Online-LOCAL(t)=O(1) must lie in the O(1)/\u0398(log* n) class, yielding the desired O(log* n) deterministic LOCAL upper bound non-constructively. Below we formulate this lower-bound program precisely and propose a safe additional \u201cquiescent\u201d bridge that can be added to output.md.\n\nNew definitions and lemmas (clean statements, why useful)\n- Definition (Quiescent Online-LOCAL(t)). An online algorithm is quiescent if, at the arrival of v, during the t synchronous rounds, nodes outside B(v,t) do not change their local state (they may ignore all computation/messages and remain idle). Why useful: This explicitly rules out the idle-update obstruction in unrestricted online runs and subsumes output-only as a special case with W=0.\n- Lemma Q (Quiescent \u21d2 O(log* n) LOCAL). If an LCL \u03a0 on bounded-degree graphs has a deterministic quiescent Online-LOCAL(t) algorithm (t=O(1)), then \u03a0 has a deterministic LOCAL algorithm running in O(t\u00b7log* n + \u0394^{O(t)}\u00b7t) = O(log* n) rounds. Sketch: Fix a proper coloring of G^{2t} (Lemma 1). Process color classes 1,\u2026,C. In phase i, all vertices v of color i execute their t-window in parallel. Quiescence ensures that only nodes in the disjoint balls {B(v,t)} may change state during phase i, so per-color cost is exactly t and no cross-interference occurs. Correctness holds for the specific \u201ccolor-by-color\u201d arrival order. This is a safe, self-contained variant to include in output.md.\n- Open transformation target (state-elimination to quiescent on trees). Goal: Given any deterministic Online-LOCAL(t) algorithm A for an LCL \u03a0 on bounded-degree trees, construct a quiescent Online-LOCAL(t) algorithm A\u2032 that reproduces A\u2019s outputs for all arrival orders. Why useful: Combined with Lemma Q, this would close the full generality gap. Status: nontrivial; obstacles below.\n\nLower-bound program: excluding the log n-hard class from constant-t Online-LOCAL on trees\n- Goal LB (Online lower bound for sinkless orientation). Prove: On bounded-degree trees, sinkless orientation cannot be solved by any deterministic Online-LOCAL(t) algorithm with constant t (for adversarial arrival orders). Why useful: By Theorem 2.33 (tree LCL classification), the log n-hard class is exemplified by sinkless orientation. If it requires t growing with n even in Online-LOCAL, then any LCL solvable in O(1) online rounds cannot be in the log n-hard class; hence, by the classification, it must have a deterministic LOCAL algorithm in O(1) or \u0398(log* n) time, giving the desired O(log* n) bound existentially.\n- Toolkit already in output.md: Lemma 7 (2t-commutativity) and Corollary 7.1 (push far-away arrivals past v). These localize pre-v influences to B(v,2t) without assuming quiescence. This is exactly the horizon needed for adapting the round-elimination proof scheme.\n- Proposed Lemma LB.1 (Online node\u2192edge reduction in a localized ball). On a \u0394-regular tree with an ID-graph H as in Theorem 2.16, suppose a deterministic Online-LOCAL(t) algorithm A solves node-centered edge-grabbing (the node form of sinkless orientation) for all arrival orders. For any edge e = uv, after normalizing the prefix so only B(e,2t) arrives first (Cor. 7.1), one can define an edge-centered (t\u22121/2)-local reduction (within B(e,2t)) that decides the orientation of e by exhaustively considering consistent local arrival orders in B(e,2t). This faithfully mirrors Lemma 2.17 in the classical round-elimination proof but with the normalization step replacing global bounds. Why useful: It sets up a t\u2192t\u22121/2 elimination inside a fixed-radius ball for the online model.\n- Proposed Lemma LB.2 (Iterated elimination yields a 0-round contradiction). Iterating the node\u2194edge localized elimination 2t times yields a 0-round edge-centered algorithm on B(e,2t), hence a 0-round global prescription depending only on the ID-graph labels at the edge. As in Theorem 2.15, this contradicts the ID-graph property (Definition 2.16), showing that no constant-t Online-LOCAL algorithm can solve sinkless orientation. Why useful: This delivers the desired lower bound LB.\n- Plan to formalize LB.1\u2013LB.2 (next steps): (i) Specify the semantics of \u201cconsider all consistent local arrival orders within B(e,2t)\u201d and show feasibility because the prefix is normalized and the ball is finite. (ii) Show that any conflict (both endpoints deciding to grab uv) witnessed by two such locally consistent extensions implies an actual global input and arrival order (gluing them into B(e,2t)) under which A fails, contradicting A\u2019s correctness. (iii) Carry the induction to 0 rounds and invoke the ID-graph argument. These steps closely parallel the classical proof and are amenable to rigorous write-up.\n\nObstacles and clarifications\n- Why quiescent reduction from arbitrary online A is hard: Without constraints, idle state updates outside B(v,t) can influence future behaviors inside the next B(\u00b7,t) even after normalization (the influence can be funneled through nodes that will later fall inside B(v,t)). Hence, a priori, replacing such idle updates by identity is not obviously sound. We therefore propose the classification-based route above as a robust way to separate out the hard class.\n- On the path/t=1 \u201cinterface\u201d program: The parity-counter example shows that without constraints, the realized output at v can depend on the number of prior arrivals even with identical K(v). However, to formally refute the context-invariance Claim C1 one needs two normalized histories with the same K(v) but different sets of feasible outputs; constructing such an LCL in the unrestricted model may require additional care (bounded-state/ID-obliviousness would make enumeration finite and C1 provable; otherwise, the set may be infinite). We suggest postponing this until the LB program is resolved.\n\nEdits and additions suggested for output.md\n- Add Lemma Q (Quiescent \u21d2 O(log* n)) with a short proof. It clearly delineates a safe class where per-color batching works.\n- Consider adding a short \u201cRoadmap to online lower bound\u201d remark: explain how Lemma 7/Cor. 7.1 enable localizing the round-elimination to B(e,2t), and outline the forthcoming Lemmas LB.1\u2013LB.2 for sinkless orientation. This prepares for integrating a full proof that Online-LOCAL(t)=O(1) cannot solve the log n-hard LCLs on trees.\n- Keep the existing negative \u201cno faithful batching\u201d remark; it prevents misuse of per-color batching outside quiescent/output-only models.\n\nConcrete next steps (auditable)\n1) Write and insert Lemma Q (quiescent bridge) into output.md, including the bounded-writes variant (color G^{2t+2W}).\n2) Formalize Lemma LB.1 (localized node\u2192edge elimination) and Lemma LB.2 (iteration to 0 rounds) for Online-LOCAL on \u0394-regular trees with an ID-graph H. Provide full proofs, borrowing structure from Theorem 2.15 and leveraging Cor. 7.1.\n3) Conclude the Online-LOCAL lower bound for sinkless orientation on trees: no deterministic constant-t algorithm exists. State the non-constructive corollary: Any LCL on bounded-degree trees solvable in deterministic Online-LOCAL(t) with constant t must admit an O(log* n) deterministic LOCAL algorithm by Theorem 2.33.\n4) Optionally, explore whether the quiescent transformation can be proven for special online designs (e.g., finite-state or ID-oblivious algorithms), which would yield a constructive black-box simulation in those regimes.\n\nNotes on gaps/errors\n- No new errors spotted in output.md; the negative remark correctly blocks earlier flawed batching. Lemma 7 and Cor. 7.1 provide the localization tool we need for the online lower bound program. The quiescent variant is not yet present and can be safely added.\n"}]

Current notes.md:
Context and goal
We study the relationship between online-style constant-locality algorithms for LCLs on bounded-degree, unoriented trees and deterministic LOCAL-time upper bounds. Two notions of “online local” are relevant:
- Sequential local/greedy model (order-robust r-local): when processing a vertex v, the decision at v depends only on the r-hop neighborhood B(v,r) of the underlying graph and on already fixed outputs within B(v,r); the algorithm must succeed for every vertex order. No global mutable state or long-range message accumulation between steps.
- Online-LOCAL(t) (Akbari–Eslami–Lievonen–Melnyk–Särkijärvi–Suomela, ICALP’23): vertices arrive one by one; upon each arrival, the algorithm has t synchronous LOCAL rounds on the subgraph induced by arrived vertices; outputs are irrevocable. Over many arrivals, an unbounded number of communication rounds can occur, enabling long-range state accumulation.

Safe, proven variant (archived below in output.md)
- Theorem (Sequential-local to LOCAL): If an LCL Π on bounded-degree graphs has a deterministic order-robust r-local sequential algorithm (decisions at v depend only on B(v,r) and outputs of earlier vertices in B(v,r), and the rule writes only the output at v), then Π has a deterministic LOCAL algorithm running in O(r log* n + Δ^{O(r)}) rounds. On bounded-degree trees with constant r, this is O(log* n). Proof: compute a proper coloring of G^r in O(r log* n) rounds with Δ^{O(r)} colors; process color classes in order, letting each v gather outputs from B(v,r) restricted to earlier colors and apply the sequential rule. Because nodes of the same color are at distance > r, their decisions do not depend on each other.

Gap for the full Online-LOCAL(t) model
- A direct phase simulation that uses a distance-(2t) coloring and t rounds per color does not generally reproduce the state a node v would see upon arrival in an actual online execution. In a true online run, before v arrives, there may have been Θ(n) earlier arrivals, yielding Θ(n)·t global rounds; information can propagate arbitrarily far and may alter the states within B(v,t). The phase simulation grants only O(1)·t total rounds before v’s phase, so the local states can differ. Hence, without additional constraints, we cannot claim that the phase simulation faithfully reproduces the online run or even yields correctness solely from A’s correctness.

Ways forward for Online-LOCAL(t)
- Add a locality-of-dependence assumption: the t-round transcript that determines v’s output depends only on the arrived subgraph inside distance ≤ t from v and on the outputs of those nodes, not on mutable states imported from farther away. Under this, distance-(2t) coloring plus phase simulation is valid and yields O(log* n).
- Alternatively, seek a structural scheduling/padding argument ensuring that for LCLs on bounded-degree trees, the state within B(v,t) before v’s arrival is independent of far-away arrivals. This is nontrivial; try first on paths/trees with t=1 to see whether accumulation can matter for any LCL.
- Or try to separate the models: construct an LCL that is solvable in constant t in Online-LOCAL but provably not simulable by the above constant-phase compression; if such an LCL exists, the general reduction fails, and the sequential-local variant becomes the correct target.

Remarks
- No global edge orientation is needed anywhere in the reduction we proved; IDs suffice for coloring.
- The archived proof applies to all bounded-degree graphs; we stated trees to match the project focus.
Refinements on bridging Online-LOCAL(t) to sequential local rules
- Definitions (recap and refinement):
  • Online-LOCAL(t): vertices arrive one by one; upon each arrival we have t synchronous LOCAL rounds on the subgraph induced by arrived vertices; outputs are irrevocably set at arrival; in the general model, nodes may maintain unbounded mutable state across arrival windows.
  • Output-only Online-LOCAL(t): the only persistent state at nodes is the immutable output label after it is set; between windows there is no other state; in any t-round window, messages sent by a node are functions only of the underlying graph and the currently known outputs within its distance-t neighborhood (no dependence on farther outputs or on pre-window mutable state).
  • t-local-dependence at v: when v arrives, its output depends only on the arrived subgraph restricted to B(v,t) and outputs of the arrived nodes within B(v,t).

- Correct radius accounting:
  • At v’s arrival with window length t, nodes within B(v,t) can influence v. A node u ∈ B(v,t) may compute its messages based on outputs within B(u,t), which is contained in B(v,2t). Thus, in the output-only model, v’s output depends only on the graph structure and outputs within B(v,2t). Consequently, the correct bridge is to a sequential rule of radius 2t (not t). If we assume t-local-dependence at v, the bridge tightens to radius t.

- Minimal counter-scenario (why naive phase-compression fails for the unrestricted online model):
  Consider a path with t=1. In a genuine online run, before a vertex v arrives, Θ(n) earlier arrivals can propagate state one hop per window across the path; by the time v arrives, its neighbors may carry information injected far away. A color-phased simulation that offers only O(1) windows before v’s phase cannot reproduce these accumulated states. This shows that without output-only or t-local-dependence, we cannot black-box simulate arbitrary Online-LOCAL(t) runs by a constant number of phases.

- Practical takeaway for reductions:
  • If your online algorithm is output-only, design the sequential rule to read B(v,2t) and write only at v; then apply the G^{2t} coloring pipeline to get O(log* n) on bounded-degree trees.
  • If your online algorithm satisfies t-local-dependence at v, the sequential rule needs only B(v,t).

- Next-step plan (state elimination on trees):
  • Start on paths with t=1. Define the interface ∂B(v,2) and annulus R=B(v,2)\B(v,1). Attempt to prove: if two online executions agree on outputs over B(v,2), then they allow exactly the same outputs at v. If proven, extend to trees and t by replacing 2 with 2t. If refuted, crystallize a separation example.
  • Track read/write radii for any sequential rules that go beyond “write only at v”; use distance-(R+W) colorings for phase independence.
Additions and corrections

1) Correct simulation radius for bounded writes.
- When simulating an order-robust sequential rule that reads within B(v,R) and may write within B(v,W), independence within a color class requires both:
  • Write–write disjointness: B(u,W) ∩ B(v,W) = ∅.
  • Read–write disjointness: B(u,R) ∩ B(v,W) = ∅ and B(v,R) ∩ B(u,W) = ∅.
- These are guaranteed if dist(u,v) > max(2W, R+W). Therefore, the correct coloring is a proper coloring of G^K with K = max(2W, R+W). Using G^{R+W} alone is insufficient in general.
- Minimal counterexample to G^{R+W}: Take R=0, W=1 on the path u–x–v. Here dist(u,v)=2>R+W, but B(u,1)∩B(v,1)={x} so simultaneous writes conflict.

2) Output-only, W-write Online-LOCAL(t) ⇒ sequential (R,W) with R=2t+W.
- Model: When v arrives, A runs t rounds and may irrevocably write outputs on B(v,W); messages during this window depend only on the graph and the currently known outputs within distance ≤ t of the sender; no other mutable state persists.
- Radius accounting: To decide outputs on the patch B(v,W) within t rounds, only nodes in B(B(v,W), t) = B(v, W + t) can send messages that reach the patch. Under output-only, each such sender’s messages are functions of outputs in its own t-ball. Hence the decisions on the patch depend only on outputs within B(v, W + 2t) = B(v, 2t + W).
- Sequential rule S: For a given order σ, when processing v, S reads already-fixed outputs in B(v, 2t+W) and deterministically reproduces A’s t-window on the patch, writing only to currently-unset outputs in B(v,W). Because A is deterministic and correct for all orders, S reproduces A’s result for order σ.

3) Commutativity of independent arrivals (unrestricted Online-LOCAL(t)).
- If two consecutive arrivals u and w satisfy dist(u,w) > 2t, swapping their order leaves the t-round transcripts and resulting states identical everywhere. In particular, by repeatedly swapping, one can assume that, when analyzing v, only arrivals within B(v,2t) occur before v. This normalizes the analysis horizon for any state-elimination attempt.

4) State-elimination program on paths (t=1) — concrete targets.
- Define the interface K(v) as the already-fixed outputs on B(v,2) just before v arrives (after normalizing the order so only B(v,2) arrives first). Target claim (context-invariance): The set of feasible outputs/messages at v depends only on K(v). If true, derive a canonical sequential rule of read radius R=2 and (potential) write radius W by reproducing the canonical choice. If false, document a counterexample LCL on paths.

5) Accounting for LOCAL complexity when W>0.
- With (R,W)-local sequential rules, compute a proper coloring of G^{K} with K = max(2W, R+W) in O(K log* n) rounds (Lemma 1 simulated on G), then process colors in O(R) rounds per color. On bounded-degree trees with constant R,W, this gives O(log* n) overall.
Disproof of “faithful color-by-color simulation” for unrestricted Online-LOCAL(t)
The tempting idea to fix a proper coloring φ of G^{2t}, choose the arrival order σ_φ that processes color classes 1,2,…,C, and then simulate each color class in O(t) rounds by running all arrivals of that color concurrently, is not valid in the unrestricted Online-LOCAL(t) model.

Key obstruction: In the Online-LOCAL(t) semantics, each arrival triggers t synchronous rounds across the entire arrived subgraph. Nodes outside B(v,t) of the newly arrived vertex v may still update their local state in that step (e.g., increment a local counter) even though they receive no messages. Over k arrivals in a color class, every previously arrived node performs k such "idle" updates. Compressing k steps to 1 per color fails to reproduce the global state unless one can apply k-fold local updates everywhere, which is not locally computable in O(1) rounds.

Minimal counterexample (paths, t=1). Consider the trivial LCL Π that accepts any labeling. Define a deterministic Online-LOCAL(1) algorithm A as follows:
- Every arrived node maintains a parity bit p, initially 0, and toggles p at every arrival step (independently of messages).
- When a new vertex v arrives, in the 1-round window v queries any neighbor u (if one exists) for p and outputs that bit. (If v has no arrived neighbor, it outputs 0.)
This A is correct for Π for every arrival order (Π accepts any labeling). Fix any proper 3-coloring φ of the path’s G^2. In the sequential σ_φ-run that processes all color-1 vertices one by one, p toggles at every arrival, so the outputs of color-1 vertices alternate with their internal order. A batched O(1)-round simulation that processes all color-1 vertices simultaneously cannot reproduce these alternating outputs: all of them see the same parity p from earlier colors and output the same bit. Hence faithful reproduction of the σ_φ-run is impossible in general.

Consequences.
- The earlier “main gap” (state accumulation across many arrivals) is real for unrestricted Online-LOCAL(t): batched simulation does not, in general, preserve the online run’s state trajectory.
- To make per-color batching sound, one needs extra structure such as quiescence: outside B(v,t), the per-step state update is the identity (or, more generally, does not depend on the number of arrivals). The output-only and t-local-dependence variants already enforce related constraints.

On Lemma 8 and local order normalization
- Our Corollary 7.1 already implies the witness localization needed for per-node analysis: by swapping distant arrivals (dist > 2t), one can assume all arrivals before v occur in B(v,2t) without changing the state in B(v,t) at v’s arrival. This is the appropriate normalization tool for any local confluence/interface analysis.

On Lemma 9 (finite enumeration claim)
- As stated (“the set of possible transcripts/messages seen by v is finite”), this is false in the standard LOCAL model due to unbounded message/state spaces and dependence on unique IDs. Finite enumeration becomes viable only if one assumes bounded message alphabets, bounded state, or ID-obliviousness; otherwise, for a fixed constant-size ball B(v,2), the algorithm can encode arbitrarily large ID-dependent information into messages/states.

Next steps for the path/t=1 interface program
- Either (i) impose output-only (or stronger quiescence/ID-obliviousness) and aim to prove the context-invariance Claim C1 under those constraints, or (ii) build a concrete counterexample to C1 in the unrestricted model by letting neighbors’ 1-round messages to v depend on the number of prior arrivals while keeping K(v) fixed. In both tracks, use Corollary 7.1 to restrict attention to B(v,2).

Complexity reminder for bounded writes
- With (R,W)-local sequential rules, independence within a color class requires K = max(2W, R+W). Computing a proper coloring of G^{K} costs O(K·log* n) rounds and per-color work is O(R). For bounded Δ, R, W, this yields O(log* n) total complexity dominated by the coloring step.

Current output.md (if any):
List of proven results archived here
- Lemma 1: Power-graph coloring in O(k log* n).
- Lemma 2: Color-phased simulation for order-robust read-radius r rules that write only at the current node (W=0).
- Theorem A: Sequential-local (W=0) ⇒ LOCAL on bounded-degree graphs.
- Lemma 3: Bridge from output-only Online-LOCAL(t) (W=0) to order-robust sequential with read radius 2t.
- Lemma 4: Bridge under t-local-dependence (W=0) to read radius t.
- Corollary A: On bounded-degree trees, constant r or constant t ⇒ O(log* n) LOCAL.
- Lemma 5: Color-phased simulation for sequential rules with read radius R and write radius W via a G^{K}-coloring with K = max(2W, R+W).
- Lemma 6: Bridge from output-only, W-write Online-LOCAL(t) to an order-robust sequential rule with (R,W) = (2t+W, W).
- Corollary B: On bounded-degree trees, constant t,W in output-only W-write Online-LOCAL(t) ⇒ O(log* n) LOCAL.
- Lemma 7: 2t-commutativity of independent consecutive arrivals in Online-LOCAL(t), and a corollary pushing far-away arrivals past a fixed v.

Model and definitions
- Graphs: finite, simple, maximum degree Δ < ∞ (bounded degree). Nodes have unique IDs from a polynomial range (standard LOCAL assumptions). dist(·,·) is the hop distance; B(v,r) is the radius-r ball around v.
- LCL Π: a locally checkable labeling problem with constant checkability radius r_Π.
- Order-robust sequential rules with bounded writes: A deterministic rule S with read radius R and write radius W is a procedure that, when processing v in a vertex order σ, inspects G[B(v,R)] and the outputs already fixed in B(v,R) ∩ {earlier vertices in σ}, and may irrevocably write outputs on any currently-unset vertices in B(v,W). The final labeling must satisfy Π for every σ. (The special case W=0 writes only at v.)
- Online-LOCAL(t): vertices arrive one by one; at each step the algorithm executes t synchronous LOCAL rounds on the subgraph induced by the arrived vertices; outputs are irrevocable; nodes may maintain arbitrary local state across steps unless otherwise restricted.
- Output-only Online-LOCAL(t): the only persistent state is the immutable output label after it is set; in any t-round window, messages and local computation at a node may depend on the graph and currently known outputs within distance ≤ t from that node, but not on any other mutable state.
- t-local-dependence (at v): upon v’s arrival, its output depends only on the induced arrived subgraph and previously fixed outputs within B(v,t).
- Output-only, W-write Online-LOCAL(t): as output-only above, but when v arrives the algorithm may irrevocably fix outputs on any vertices in B(v,W).

Lemma 1 (Power-graph coloring in O(k log* n))
Statement. Let G be a bounded-degree graph and k ≥ 1 a constant. There is a deterministic LOCAL algorithm that computes a proper vertex coloring of the power graph G^k with at most C = Δ^{O(k)} colors in O(k log* n) rounds on G.
Proof. Standard: simulate an O(log* n)-round O(Δ(G^k)^2)-coloring on G^k by k rounds per step on G; Δ(G^k) ≤ Δ^k, hence C = Δ^{O(k)}. □

Lemma 2 (Color-phased simulation for W=0)
Statement. Let S be an order-robust sequential rule with read radius r that writes only at the current node (W=0). Given a proper coloring of G^r, processing colors 1,…,C in order reproduces S for any order respecting the color layering, using O(r) rounds per color.
Proof. If φ(u)=φ(v) then dist(u,v)>r, hence the decisions in phase i depend only on outputs from earlier colors and do not interfere. Each node gathers outputs in B(·,r) from earlier colors in O(r) rounds and applies S. □

Theorem A (Sequential-local (W=0) ⇒ LOCAL)
Statement. If Π admits an order-robust r-local sequential algorithm (W=0), then Π has a deterministic LOCAL algorithm running in O(r log* n + Δ^{O(r)}·r) rounds. For constant Δ,r: O(log* n).
Proof. Compute a G^r-coloring in O(r log* n) rounds (Lemma 1), then simulate by Lemma 2. □

Lemma 3 (Output-only Online-LOCAL(t), W=0 ⇒ sequential with read radius 2t)
Statement. If Π has a deterministic output-only Online-LOCAL(t) algorithm correct for every arrival order, then Π admits an order-robust sequential algorithm with read radius 2t (W=0) that reproduces the online outputs for any order.
Proof. Fix order σ. When v_i arrives online under σ, only nodes in B(v_i,t) can send messages that reach v_i within t rounds. Under output-only, any such message depends only on outputs within the sender’s B(·,t), all contained in B(v_i,2t). Hence v_i’s t-window transcript and output are functions of the restriction to B(v_i,2t) of the arrived subgraph and outputs. Define the sequential rule to read those and return the same output as the online algorithm would under σ. Correctness and order-robustness follow. □

Lemma 4 (Bridge under t-local-dependence, W=0)
Statement. If Π has a deterministic Online-LOCAL(t) algorithm with t-local-dependence (at every v) that is correct for every arrival order, then Π admits an order-robust sequential algorithm with read radius t (W=0).
Proof. As in Lemma 3, but with t in place of 2t by hypothesis. □

Corollary A (Bounded-degree trees, constant r or t)
Statement. On bounded-degree trees, if Π has either (i) an order-robust r-local sequential algorithm (W=0) with constant r, or (ii) an output-only Online-LOCAL(t) algorithm (W=0) with constant t, or (iii) an Online-LOCAL(t) algorithm with t-local-dependence and constant t, then Π has a deterministic LOCAL algorithm with round complexity O(log* n).
Proof. Combine Theorem A with Lemma 3 or Lemma 4 as applicable; Δ and radii are constants. □

Lemma 5 (Color-phased simulation with bounded writes)
Statement. Let S be an order-robust sequential rule with read radius R and write radius W ≥ 0 (S may write outputs on currently-unset vertices in B(v,W)). Let φ be a proper coloring of G^{K} with K = max(2W, R+W). Then processing colors 1,…,C in order reproduces S for any order that respects the color layering. The per-color communication cost is O(R) rounds after φ is known.
Proof. If φ(u)=φ(v) then dist(u,v) > K ≥ 2W and > R+W. Thus (i) B(u,W) ∩ B(v,W) = ∅ (no write–write conflicts) and (ii) B(u,R) ∩ B(v,W) = ∅ and B(v,R) ∩ B(u,W) = ∅ (no read–write interference). In phase i, each vertex v with φ(v)=i gathers outputs written by earlier colors within B(v,R) and computes its writes; because of (i)–(ii), these writes are independent across same-color vertices and depend only on earlier colors, so the result matches S for any order that lists all lower colors first and then the current color in any internal order. O(R) rounds suffice to gather B(v,R) information. Computing φ takes O(K log* n) rounds by Lemma 1 with k=K. □

Lemma 6 (Output-only, W-write Online-LOCAL(t) ⇒ sequential with (R,W)=(2t+W,W))
Statement. If Π has a deterministic output-only, W-write Online-LOCAL(t) algorithm A correct for every arrival order, then Π admits a deterministic order-robust sequential rule S that, when processing v, reads only B(v, 2t+W), may write on currently-unset vertices in B(v,W), and reproduces A’s outputs for any order.
Proof. Fix order σ = (v_1,…,v_n). Consider A under arrival order σ. When v_i arrives, during its t-round window only nodes within distance ≤ t of the patch B(v_i,W) can send messages that reach the patch; hence all influencing senders lie in N := B(B(v_i,W), t) = B(v_i, W+t). Under output-only, messages sent by any u ∈ N depend only on outputs within B(u,t). Therefore the union of outputs that can affect the patch’s decisions lies in M := ⋃_{u∈N} B(u,t) = B(v_i, W+2t). Consequently, the t-round transcript determining the patch outputs in the σ-run is a function of the restriction of the arrived subgraph and already-fixed outputs to B(v_i, 2t+W). Define S as follows: when processing v_i under σ, S collects the already-fixed outputs within B(v_i, 2t+W) ∩ {v_1,…,v_{i-1}} and deterministically reproduces A’s t-window decisions on the patch given that local view, writing only to vertices in B(v_i,W) whose outputs are not yet fixed. Because A is deterministic and respects irrevocability, this reproduces exactly the same patch outputs as A under σ and never overwrites. As A is correct for every order, S is an order-robust (R,W)-local rule with R=2t+W. □

Corollary B (Bounded-degree trees, output-only W-write ⇒ O(log* n) LOCAL)
Statement. On bounded-degree trees, if Π has a deterministic output-only, W-write Online-LOCAL(t) algorithm with constants t,W, then Π has a deterministic LOCAL algorithm with round complexity O(log* n).
Proof. Apply Lemma 6 to obtain a sequential (R,W)-rule with R=2t+W. Then use Lemma 5 with K = max(2W, R+W) = max(2W, 2t+2W) = 2t+2W to simulate S in the LOCAL model: compute a proper coloring of G^{2t+2W} in O((2t+2W) log* n) rounds, then spend O(R)=O(2t+W) rounds per color. For constant Δ,t,W the total is O(log* n). □

Lemma 7 (2t-commutativity of independent consecutive arrivals)
Statement. Let A be any deterministic Online-LOCAL(t) algorithm (unrestricted mutable state). Consider an arrival sequence σ and two consecutive arrival steps at vertices u and w such that dist(u,w) > 2t. Let σ′ be obtained by swapping these two steps. Then, after these two steps, the states and fixed outputs at all vertices are identical under σ and under σ′.
Proof. Let G_i be the arrived subgraph just before these two steps. In the step when u arrives under σ, A executes t synchronous rounds on G_i ∪ {u}. Messages can traverse at most t hops per window, so only nodes in B(u,t) can be influenced (either by receiving messages or by depending on received messages); nodes outside B(u,t) undergo the same deterministic state updates as they would in any window where they receive the same (empty) messages. Likewise, w’s step affects only B(w,t). Because dist(u,w) > 2t, the balls B(u,t) and B(w,t) are disjoint, and w is absent during u’s step and u is absent during w’s step in both σ and σ′. Therefore the t-round transcripts and resulting updates within B(u,t) (resp. B(w,t)) are identical in σ and σ′, and all other vertices experience no message-dependent changes in either order. Thus the combined effect of the two steps commutes. □

Corollary 7.1 (Pushing far-away arrivals past v)
Statement. Fix v and any arrival sequence. By repeatedly swapping consecutive independent steps via Lemma 7, one can transform the sequence into another in which all vertices at distance > 2t from v arrive after v, without changing any states or outputs within B(v,t) at the time v arrives (or thereafter).
Proof. Iteratively swap any arrival at distance > 2t from v forward past earlier arrivals until it occurs after v; Lemma 7 ensures the swaps preserve the relevant states/outputs. □

Remark. Lemma 5 supersedes the earlier, flawed variant that required only a G^{R+W}-coloring; the counterexample R=0, W=1 on a 3-path shows that G^{R+W} is insufficient because write–write conflicts may occur.
Remark (No faithful t-per-color batching for unrestricted Online-LOCAL(t)). There exists a deterministic Online-LOCAL(1) algorithm A and a valid color-by-color arrival order σ_φ (induced by a proper coloring φ of G^2 on a path) such that any LOCAL simulation that processes all vertices of the same color class simultaneously in O(1) rounds cannot reproduce the exact outputs produced by A under the sequential σ_φ-run.
Proof. Consider the trivial LCL Π that accepts any labeling. Algorithm A maintains at each arrived node a parity bit p (initially 0) that toggles at every arrival step (regardless of messages). When a new vertex v arrives, in its 1-round window it reads p from an already-arrived neighbor if one exists and outputs that bit (if v has no arrived neighbor, it outputs 0). Fix any proper 3-coloring φ of the path’s G^2 and let σ_φ process colors 1,2,3 in order, with any internal order inside a color. In the sequential σ_φ-run, the parity p toggles at every arrival, hence the outputs of the vertices of any color class alternate with the internal order. In contrast, if one processes all vertices of a color class simultaneously in a single 1-round batch (keeping not-yet-processed colors absent), all these vertices observe the same parity p from earlier colors and therefore all output the same bit. Thus the batched simulation does not reproduce A’s outputs under σ_φ. □

Remark (Complexity accounting for Lemma 5/Corollary B). On bounded-degree graphs with constants t,W, the coloring step on G^{K} (K = max(2W, R+W), with R = 2t+W in Corollary B) costs O(K·log* n) rounds and yields C = Δ^{O(K)} colors; the per-color work is O(R). Hence the total complexity is O(log* n), dominated by the coloring step.
