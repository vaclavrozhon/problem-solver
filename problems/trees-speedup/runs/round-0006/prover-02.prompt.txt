--- SYSTEM ---
You are a research mathematician. 

You are being run in a loop with a verifier that checks rigor. Your goal is to make **incremental, auditable progress**. You are not expected to solve the problem at once, but to generate new, testable ideas.

Inputs: 
- task statement 
- notes.md (summary of past progress; optional) 
- output.md (rigorously proven results curated so far; optional) 
- summary of past rounds (optional) 
- possibly some reference papers.

What counts as progress:
- Extract small lemmas/heuristics from literature and state them cleanly with one-line "why useful here".
- Explore small examples & try to break your own claims with toy counterexamples.
- Prove special cases or nontrivial bounds.
- If an approach fails, explain crisply why.
- Point out flaws in notes.md or output.md (but do not rewrite output.md yourself).

**Discipline.** 
- Read notes, outputs, summaries carefully before proposing new work. 
- Reference papers if relevant, but focus on *incremental, checkable steps*. 
- Do not output Markdown code fences, only raw JSON. 
- Length: at least ~200 words. 
- Organize your reasoning with short headings (Ideas, Examples, Obstacles, Next steps), make clear what your claims are and how they are supported. 
- Remember: the verifier curates notes and outputs, you only suggest.

**Return strictly JSON**:
{
  "progress_md": "Your progress notes for this round in Markdown (KaTeX allowed). Point out any gaps in output.md clearly. Do not modify output.md directly."
}


--- USER ---
Work on this problem context:

=== task.md ===
Generalize the speedup theorem Theorem 1.5 from the attached paper to (nonoriented) trees. 

It is enough to prove the following: Any LCL solvable in O(1) rounds in deterministic online local model on bounded-degree trees can be solved in O(log* n) rounds of standard local model.


=== progress.md ===
...
window only nodes u ∈ B(vi,t) can send messages which reach B(vi,0). Each such u computes its messages as a function of outputs within B(u,t) by the output-only restriction; hence u’s messages to the patch B(vi,W) depend only on outputs in B(vi, t+W) ∪ (⋃u∈B(vi,t) B(u,t)) ⊆ B(vi,2t+W). Therefore the full t-round transcript relevant to deciding outputs on B(vi,W) in the σ-run depends only on the restriction of the arrived subgraph and already fixed outputs to B(vi,2t+W). Define S as follows: when processing vi in σ, S gathers the outputs already fixed within B(vi,2t+W)∩{v1,…,vi−1} and deterministically reproduces A’s t-window decision for B(vi,W) given that local view. As A is deterministic and correct for all orders, S reproduces the same patch outputs as A in this order; order-robustness of S follows by the same order-by-color simulation used previously. S is (R,W) = (2t+W,W)-local.

- Lemma E (LOCAL simulation for (R,W)-local sequential rules).
  Statement. Let S be a deterministic sequential rule that, when processing v, reads only B(v,R) and writes only on B(v,W), for fixed constants R,W ≥ 0. Given a proper coloring of G^{R+W} with C colors, one can simulate S in the LOCAL model by processing colors 1,…,C, using O(R) rounds per color. The simulation outputs exactly what S would produce for any order that respects the color layering.
  Proof. If dist(u,v) > R+W and φ(u) = φ(v), then (i) B(u,R)∩B(v,R) = ∅ and (ii) B(u,R) is disjoint from the write neighborhood B(v,W), and vice versa. Thus, within one color phase, decisions are independent. Each vertex of color i gathers the outputs written by earlier colors in B(v,R) (O(R) rounds), applies S, and writes within B(v,W). Correctness is identical to Lemma 2’s argument. A coloring of G^{R+W} with C = Δ^{O(R+W)} colors can be computed in O((R+W)·log* n) rounds by Lemma 1 simulated on G.

Corollaries (bounded-degree trees ⇒ O(log* n))
- Corollary D. On bounded-degree trees, if Π has a deterministic output-only, W-write Online-LOCAL(t) algorithm with constants t,W, then Π has a deterministic LOCAL algorithm with round complexity O((2t+W)·log* n) + O(1) = O(log* n).
  Reason: Apply Lemma D to get a (R,W)-local sequential rule with R = 2t+W, then Lemma E and Lemma 1.
- Note existing special cases are recovered: W=0 gives Lemma B (R=2t), and “t-local-dependence” with W=0 gives Lemma C (R=t).

Examples and sanity checks
- Greedy (Δ+1)-coloring online variant fixing a constant-radius patch: If at arrival of v the online rule picks a color for v and possibly finalizes colors of uncolored neighbors (W=1) using only the set of colors already fixed in B(v,1), then the rule is output-only, W-write with t=1. Corollary D yields an O(log* n) LOCAL algorithm on bounded-degree trees.
- Greedy maximal matching: a variant that, at v’s arrival, matches v to a free neighbor and possibly finalizes the matched pair (W=1), while sending messages depending only on currently fixed outputs within distance 1, meets the model; Corollary D applies.

Obstacles and model gaps (reiterated crisply)
- The unrestricted Online-LOCAL(t) model allows arbitrary mutable state and unbounded accumulation of information before v arrives. The path/t=1 counter-scenario still shows naive phase compression is invalid without extra restrictions. Our bridges cover output-only (R=2t or 2t+W) and t-local-dependence (R=t), but the general state-elimination step remains open.

State-elimination program (t=1 on paths) — concrete, testable steps
- Formalize the “interface view” at radius 2: for any vertex v on a path, define the context K(v) := restriction of outputs to B(v,2) at the time v arrives in an online execution. Target claim (Context-invariance): For any two online executions that agree on K(v), the set of outputs that the algorithm may produce at v is the same. If true, define a canonical tie-breaking function on K(v) to derive a sequential rule with R=2 and W determined by the online rule. Action items:
  1) Model each arrival as a local rewrite on the current output labeling; record that in t=1, only the immediate neighbors of v can send messages to v during the window, and each of those neighbors’ messages are functions of outputs in their own 1-neighborhood.
  2) Attempt to construct a counterexample LCL where two executions with identical K(v) force different outputs at v. If found, local elimination at radius 2 fails; otherwise, prove the lemma.
- Generalize: If the t=1 path case succeeds, extend to trees by handling the degree>2 case via boundary decomposition along paths to ∂B(v,2). For general t, replace 2 by 2t; for W>0, consider K(v) extended to B(v,2t+W).

Editorial notes on output.md
- The newly added Variant of Lemma 2 for bounded-distance writes aligns with Lemma E above. Suggest adding Lemma D explicitly (output-only, W-write bridge with read radius 2t+W) to make the pipeline fully parametric in W. This will make it transparent how to handle online rules that finalize a constant-radius patch.
- Minor clarity: In Lemma 1, it may help to note explicitly that in bounded-degree trees with constants Δ and k, the color count C = Δ^{O(k)} is an absolute constant, so the per-color simulation overhead is O(1).

Why this is progress
- We extend the safe, proven bridge to cover online rules that finalize constant-radius patches (common in greedy online/local designs), giving an immediate path to O(log* n) LOCAL algorithms on bounded-degree trees.
- We outline a concrete, falsifiable “context-invariance” claim for the state-elimination program on paths with t=1, including what to prove or how to refute it with a counterexample LCL. This isolates the remaining conceptual barrier and provides a roadmap for the next proof or separation.

Next steps (auditable)
- Add Lemma D to output.md with a full proof (the proof follows the same envelope as Lemma B and is straightforward to formalize).
- Start the path/t=1 case: either prove the context-invariance claim (produce a short inductive proof or a monotonicity argument) or construct a counterexample LCL. If proven, write the path/t=1 “state-elimination” lemma; if refuted, document the counterexample precisely.
- If bounded-distance writes are used (W>0), ensure the simulation uses G^{R+W} coloring (i.e., G^{2t+2W}) consistently; verify radii accounting in each step with small toy instances to avoid off-by-one errors.

## Round 0003 — sharpening the bridge from Online-LOCAL(t) to LOCAL on trees

Summary of status
- output.md is now correct regarding the “output-only” bridge: the needed sequential locality is 2t (Lemma B) and can be tightened to t under the stronger t-local-dependence hypothesis (Lemma C). The color-phased simulation and the (R+W)-write variant are also stated cleanly.
- The remaining gap for the unrestricted Online-LOCAL(t) model is the possibility of unbounded accumulation of mutable state before a vertex v arrives. We need additional structural arguments tailored to trees to remove this dependence.

New incremental results (clean statements with proofs)

1) Commutativity of independent arrivals (a tool for order normalisation)
- Lemma D (2t-commutativity of consecutive independent arrivals). Let A be a deterministic Online-LOCAL(t) algorithm on a bounded-degree graph. Consider an arrival sequence σ and two consecutive arrival steps at vertices u and w with dist(u,w) > 2t (distance in the underlying graph G). Let σ′ be obtained by swapping these two steps. Then the states and already-fixed outputs after executing these two steps under σ and under σ′ coincide everywhere; in particular, the outputs on B(u,t) ∪ B(w,t) and outside are identical.
  - Proof sketch (checkable). In the step when u arrives in σ, A runs t synchronous LOCAL rounds on the current arrived graph G_i. All messages and updates during this window are confined to B(u,t) (messages can travel at most distance t in t rounds). Since dist(u,w) > 2t, we also have B(u,t) ∩ B(w,t) = ∅, and w is absent before either of the two steps in both σ and σ′. Moreover, in both orders, the set of previously arrived vertices intersected with B(u,t) is the same at the time u’s window runs, hence the local t-round transcript at nodes in B(u,t) is identical in σ and σ′, and the same updates occur there. The same argument applies to w’s step. Because the two windows touch disjoint node sets and no messages cross between them within t rounds, their effects commute, and all other nodes remain unaffected. □

- Corollary D.1 (Pushing far-away arrivals past v). Fix v and any arrival sequence. By repeatedly applying Lemma D to adjacent independent steps, one can transform the sequence into another sequence in which (i) all vertices at distance > 2t from v arrive after v, and (ii) the outputs of all nodes and the states at the time v arrives on nodes within B(v,t) are identical to those in the original sequence.
  - Why useful: It reduces the analysis of v’s decision to local arrival orders that involve only the ball B(v,2t). This finite-horizon reduction is independent of graph orientation and holds on all graphs.

2) Consequence for dependence radius
- Observation. Under Corollary D.1, we may w.l.o.g. assume that before v arrives, only vertices in B(v,2t) have arrived. Hence any information that can reach v during its t-round window originates within B(v,2t). This is consistent with Lemma B’s 2t radius for the output-only bridge and provides the right target radius for any state-elimination attempt on trees.

New approach outline: “Interface confluence” on trees for t=1
- Goal (paths, t=1 case). Prove: For any deterministic Online-LOCAL(1) algorithm A and any LCL Π, after normalising the order as in Corollary D.1, the output at v depends only on (G[B(v,2)], outputs already fixed in B(v,2)]). Equivalently: mutable states of nodes in B(v,1) at v’s arrival can be replaced by canonical functions of outputs in B(v,2).
- Why plausible on trees: When all arrivals before v lie in B(v,2), any message reaching v during its 1-round window comes from neighbors of v. Each neighbor’s outgoing message is computed using its current state, which itself resulted from arrivals in B(v,2) only. In a tree, one can attempt to summarise the influence of each branch by a finite “interface type” depending only on already-fixed outputs in that branch up to distance 2 from v.
- Proposed technical route:
  1) Define, for each neighbor u of v, the 1-hop interface type τ(u→v) as the set of all possible outgoing messages u would send to v at v’s arrival time, over all arrival orders restricted to B(u,1) consistent with the same already-fixed outputs in B(u,2). Show τ(u→v) is a function of the output-labeling of B(u,2) alone.
  2) Show that the tuple of interface types around v, together with outputs already fixed in B(v,2), determines v’s t=1 transcript and hence v’s output. This would establish the desired (output-only) dependence for t=1 on paths; by a standard tree decomposition at v, extend to general trees.
  3) Generalise to t > 1 by replacing radii 1 and 2 with t and 2t and defining depth-t interface types.
- Obstacles: The interface type τ(u→v) as defined must be well-defined (independent of the arrival order within B(u,2)), which requires a local confluence argument. While Lemma D lets us push arrivals at distance > 2t past v, it does not by itself give confluence among different orders internal to B(u,2). Establishing that the set of feasible outgoing messages depends only on outputs (and not on internal mutable state histories) is the crux.

Why Lemma D is useful even without full state elimination
- It strictly confines the relevant arrivals to B(v,2t) and eliminates concerns about “long-haul” state injected from beyond that radius. Any further dependence on arrival order or mutable state must be attributable to choices made entirely within B(v,2t). This localises the problem and suggests a finite-case analysis/state-aggregation strategy on trees.

Notes on output.md (gaps and suggestions)
- The current output.md correctly states and proves the bridges (Lemma B: radius 2t; Lemma C: radius t under t-local-dependence) and the simulation via coloring. No errors spotted.
- Suggested addition for future versions: include Lemma D (2t-commutativity of independent arrivals) with proof and Corollary D.1. These will be useful scaffolding for the tree-specific state-elimination program, and they are correct for the unrestricted Online-LOCAL(t) model.

Examples/sanity checks
- Example (commutativity applicability). On a path with t=1, any two consecutive arrivals at nodes with distance ≥ 3 commute. Thus, when analysing v, we can always push all arrivals at distance ≥ 3 past v. The only potentially order-sensitive part is the sequence of arrivals within distance ≤ 2 of v.
- Consistency with lower bounds. Sinkless orientation requires Ω(log n) deterministic LOCAL rounds on trees; by Corollary D.1, a hypothetical constant-time online algorithm would still have to resolve constraints within B(v,2t), which is consistent with known impossibility: we do not derive a contradiction but focus on the local reduction.

Next steps (auditable action items)
1) Formalise and prove Lemma D and Corollary D.1 in output.md, including precise quantification over states and message transcripts; this is model-agnostic and verifiable.
2) Path, t=1 case study for interface confluence:
   - Precisely define “interface type” and prove monotonicity properties (adding arrivals outside B(u,2) does not change τ(u→v) by Corollary D.1).
   - Attempt to prove that for fixed outputs on B(u,2), τ(u→v) is a singleton (order-robust), or at least that the set of feasible messages has a canonical choice leading to a valid global solution. If successful, this yields the output-only bridge on paths with r = 2.
3) If (2) succeeds, generalise to trees (branch-wise independence) and to general t by layered interfaces of depth t. If it fails, craft a concrete LCL counterexample on paths demonstrating genuine dependence on mutable state histories within B(v,2) (which would delimit the scope of the desired speedup).
4) Keep tracking read/write distances carefully. If any future sequential rule writes within distance W > 0 (e.g., when extracting canonical choices), ensure to schedule by a G^{R+W}-coloring as already anticipated in output.md.

Why this is progress
- We added a rigorously provable commutativity lemma (and corollary) that strictly localises the analysis to B(v,2t). This is a necessary stepping stone for any tree-specific state-elimination.
- We laid out a concrete, checkable interface-aggregation program starting with paths and t=1, with clear success/failure outcomes to be tested next.

## Round 0004 — 2025-08-27T18:51:19.565901Z

Status check and scope
- The curated output.md now includes the corrected bounded-writes simulation (color G^K with K = max(2W, R+W)), the output-only bridges (W=0 and W>0), and the 2t-commutativity/cutoff lemma. This fixes the earlier flaw flagged by the verifier (using G^{R+W} was insufficient) and provides a complete O(log* n) pipeline for the output-only (and t-local-dependence) online models on bounded-degree trees.
- The main open gap remains the unrestricted Online-LOCAL(t) model: unlimited mutable state can accumulate across many arrivals before v, and our color-phased simulation need not reproduce these states. The commutativity lemma localizes influence to B(v,2t), but internal nonconfluence within B(v,2t) is unresolved.

New micro-lemmas (formal and checkable)
- Lemma 8 (Strong witness-localization at v). Let A be a deterministic Online-LOCAL(t) algorithm and σ any arrival sequence. For any vertex v, there exists a sequence σ_v obtained from σ by swapping adjacent arrivals at distance > 2t such that (i) all arrivals before v in σ_v occur at vertices in B(v,2t), (ii) the arrived subgraph just before v arrives is G[B(v,2t)]∩{arrived}, and (iii) the local states and fixed outputs on B(v,t) at the time v arrives are identical in σ and σ_v.
  Proof idea: Iteratively apply Lemma 7 to push every arrival at distance > 2t from v past v. Each swap preserves the state within B(v,t) at the time v arrives; hence (iii) holds. Statements (i)–(ii) then follow by construction.
- Lemma 9 (Finite local enumeration for t=1 on paths). On a path, for any vertex v, the set of arrival orders restricted to B(v,2) is finite with size bounded by a constant c(Δ) independent of n; hence the set of possible transcripts/messages seen by v under any normalized σ_v is finite. This is an accounting lemma (use Δ ≤ 2 on paths) and will be useful if a local confluence/summary argument can be established.

Path, t=1 interface program — sharpening targets
- Definitions (interface types). For a path and t=1, define K(v) to be the restriction of already-fixed outputs just before v arrives to B(v,2). For each neighbor u ∈ N(v), define the interface type τ(u→v) as the set of all outgoing 1-round messages that u can send to v at the start of v’s window, ranging over all normalized arrival orders σ_v consistent with K(v). Note that τ(u→v) depends a priori on the internal states at u caused by earlier arrivals within B(v,2), not just on outputs.
- Target Claim C1 (context-invariance). For any deterministic Online-LOCAL(1) algorithm A that is correct for all orders on paths, τ(u→v) is a function only of K(v). If C1 holds, then the pair of types (τ(left→v), τ(right→v)) together with K(v) determines v’s 1-round transcript and thus v’s output; consequently, v’s output can be written as f(K(v)), yielding a sequential rule with read radius R=2 (W depending on A).
- Why plausible: Lemma 8 restricts all relevant pre-v activity to B(v,2). Correctness-for-all-orders constrains the variability of τ(u→v): in particular, if two normalized local histories share K(v), any divergence in τ would imply two global normalized executions that share K(v) but force different decisions at v under the same neighbor messages—this is the crux to be formalized.

Obstacles and what fails without extra structure
- Messages are unbounded in LOCAL, hence in principle τ(u→v) could be infinite and depend on arbitrary pre-window states, even if K(v) is fixed. Without additional constraints, direct finiteness/regularity arguments (e.g., Myhill–Nerode–style) are unavailable.
- Local confluence inside B(v,2) is not implied by 2t-commutativity (which only handles dist > 2t). For t=1, arrivals at distance 2 can causally affect a neighbor’s 1-round message to v, and these steps need not commute.

Why the current bridges suffice in natural cases
- The output-only model (and its W-write variant) sidesteps the obstacles: each neighbor’s outgoing message during v’s window is a function of outputs within distance 1 of the sender; by Lemma 6, v’s decision depends only on outputs in B(v,2) (or B(v,2+W) for bounded writes), and the color-phased simulation gives O(log* n).
- The t-local-dependence variant provides an even tighter radius (R=t) and is common for greedy “decide-at-current-node” online rules.

Actionable next steps (auditable)
1) Formalize C1 or refute it on paths:
   - Set up the precise semantics of τ(u→v): enumerate all normalized permutations of arrivals in B(v,2), run A on each (local simulation of a finite tree of executions), and collect the set of possible messages. Prove (or disprove by counterexample) that τ(u→v) depends only on K(v).
   - If C1 holds, define f(K(v)) by simulating v’s 1-window using any representative execution consistent with K(v); argue that f yields a well-defined (R=2, W as needed) sequential rule S. Then invoke Lemma 5 to obtain O(log* n) in LOCAL on bounded-degree trees.
2) If C1 fails, attempt a weaker canonicalization:
   - Show existence of a canonical choice g(K(v)) ∈ τ(u→v) for each interface that still yields a valid global labeling when composed across vertices via color-phased scheduling (this would be a “local mending” style selection).
3) Extend Lemma 8 to quantify the precise bound on the number of arrival steps that can affect v: for general t and degree Δ, |B(v,2t)| ≤ Δ^{O(t)}; record this bound for use in exhaustive local simulations.
4) Strengthen output.md with an explicit remark that the main theorem presently holds under output-only (and t-local-dependence) hypotheses and that unrestricted Online-LOCAL(t) is open; add Lemma 8 and Lemma 9 as formal tools for the path-interface program.

Notes on output.md (gaps/edits)
- The listed lemmas are correct as stated. To support the path-interface program, we suggest adding:
  • Lemma 8 (strong witness-localization at v) with proof.
  • A short bound on |B(v,2t)| and the induced finite enumeration of normalized local orders (Lemma 9).
- Clarify in Corollary B that the overall runtime is O((2t+2W)·log* n + O(1)) and dominated by the coloring step for constant Δ, t, W.

Why this round is progress
- We strengthened the normalization toolkit (Lemma 8), formalized the interface-type notion for the path/t=1 case, and articulated a precise, falsifiable claim (C1) whose resolution would close the remaining gap. We also scoped a concrete finite-enumeration approach to test C1 and outlined fallback strategies if it fails. These are incremental, auditable steps towards eliminating mutable-state dependence inside B(v,2t) on trees.

## Round 0004 — 2025-08-27T18:52:06.648937Z

Ideas (closing the main gap)
- New lemma (faithful phase simulation for arbitrary deterministic Online-LOCAL(t), no extra restrictions): Fix any proper coloring φ of G^{2t}. There is a deterministic LOCAL simulation that, in O(t·log* n) (to compute φ) + C·t rounds (C = Δ^{O(t)} colors), reproduces exactly the outputs that the online algorithm A would produce on the arrival order that processes color classes 1,2,…,C, with ties inside a color class resolved arbitrarily. On bounded-degree graphs with constant t, this is O(log* n).
  • Why this suffices for the task: The online model requires A to succeed for every adversarial order; hence it certainly succeeds for the specific “color-by-color” order. Our LOCAL simulation reproduces that run, up to perfect fidelity, yet at a cost of O(log* n) rounds. This directly proves: Any LCL solvable in O(1) rounds in deterministic Online-LOCAL(t) on bounded-degree trees (indeed, bounded-degree graphs) can be solved in O(log* n) rounds in the standard LOCAL model.

- Key observation resolving the prior concern (barrier of unbounded state accumulation): In the color-by-color arrival order, before a vertex v arrives, only vertices of earlier colors have arrived. The online algorithm must work for this order. During phase i, we need to execute the t-round “arrival-window” for all vertices v with φ(v)=i. Even though an online execution would conceptually perform these windows sequentially (one at a time), the union of active parts of the system involved in each individual t-window is B(v,t) and, since φ colors G^{2t}, these t-balls are pairwise disjoint for same-color vertices. Therefore we can execute all these t-windows concurrently in exactly t LOCAL rounds, without interference. No “k·t” overhead arises, even if the color class has k≫1 vertices.

Clean statement (to add as a new lemma in output.md)
- Lemma F (Faithful color-phased simulation of arbitrary deterministic Online-LOCAL(t), W=0). Let A be any deterministic Online-LOCAL(t) algorithm (arrived vertex decides its own output; all previously arrived vertices may maintain arbitrary state across arrivals and participate in the t rounds of subsequent arrivals). Let φ be a proper coloring of G^{2t} with C colors. There is a deterministic LOCAL algorithm that produces exactly the same outputs as A would produce on the arrival order σ_φ that processes colors 1,2,…,C, by spending O(t) LOCAL rounds per color and keeping vertices of colors > i passive in phase i. Total round complexity: O(t·log* n + C·t) = O(log* n) for bounded Δ and constant t.
  • Proof sketch (formal details straightforward):
    1) Compute φ in O(t·log* n) rounds (Lemma 1). Fix the arrival order σ_φ: all color-1 vertices arrive first (in any order), then color 2, etc. Since A is correct for every order, it is correct for σ_φ.
    2) Inductive invariant I(i): After finishing phase i, the global state of all arrived vertices (colors ≤ i), and the fixed outputs for these vertices, are exactly those that would arise in an online execution of A under σ_φ after all color-≤i vertices have been processed (sequentially in any order within the color), and vertices of colors > i have not yet arrived (absent from the induced subgraph).
    3) Base i=0: vacuous. Step i→i+1: In phase i+1 we must run the “arrival window” (t rounds) for every v with φ(v)=i+1, over the subgraph induced by colors ≤ i+1, with vertices of colors > i+1 absent. For a single vertex v this t-window involves only nodes in B(v,t); nodes outside B(v,t) cannot influence or be influenced (information cannot travel > t hops in t rounds). If u and v share the same color i+1, then dist(u,v)>2t, hence B(u,t)∩B(v,t)=∅, and their windows can be executed simultaneously without interference in exactly t rounds. (Previously arrived vertices may participate in these t rounds, but only those inside the corresponding disjoint t-balls.) Therefore, after t rounds, every color-(i+1) vertex has exactly the output it would get in the run of A under σ_φ; all other states/outputs also match, proving I(i+1).
    4) After phase C we have the outputs A would produce on σ_φ. Since A is correct for all orders, the labeling satisfies Π.

- Variant with bounded writes (optional, for completeness): If A (at arrival of v) may additionally finalize outputs on a patch B(v,W), the same simulation goes through using a proper coloring of G^{2t+2W} (so that the “influence regions” B(v,W+t) are disjoint inside a color). In phase i, we run t rounds over the subgraph induced by colors ≤ i, with vertices of colors > i absent, and let each new vertex v finalize the patch B(v,W). The per-color runtime is still t, and correctness follows by the same invariant. This matches the K = 2t+2W bound already used in Lemma 5/Corollary B.

Why this closes the loop
- The main task asks to simulate any O(1)-round deterministic online-local algorithm on bounded-degree trees in O(log* n) LOCAL rounds. Lemma F does exactly that (and for general bounded-degree graphs), relying only on (i) a distance-(2t) coloring and (ii) faithful, batched execution of t-windows per color. No restrictions such as “output-only” or “t-local-dependence” are needed. The essential ingredient is that A must succeed for every arrival order, so we are free to choose the color-by-color order.

Sanity checks and examples
- Path graph, t=1, “long-haul state accumulation” algorithm A. Even if one can design A so that, under some orders, far-away information travels across many arrivals before a vertex v appears, A must also succeed under order σ_φ, where only O(1) color classes arrive before v. Our simulation reproduces precisely that run of A; hence the output is valid. The earlier apparent obstacle (needing Θ(n)·t global rounds pre-arrival) is resolved by choosing a benign order.
- Toy parallelization check: two new vertices u,v at distance ≥2t in the same phase. In A, if processed sequentially, first arrival’s t rounds touch only B(·,t), then the second’s t rounds touch only the other t-ball; batching them into one t-round block yields identical transcripts in the two disjoint neighborhoods.

Gaps or edits needed in output.md
- Current output.md (Round 0003) contains:
  • Bridges for output-only and for t-local-dependence (Lemmas 3–4), the corrected bounded-writes simulation (Lemma 5 with K = max(2W,R+W)), the output-only W-write bridge (Lemma 6), and the commutativity lemma (Lemma 7). All are correct as stated.
  • Missing piece: an explicit lemma for the general Online-LOCAL(t) case without extra restrictions (the new Lemma F above). This is the central statement that directly yields the desired O(log* n) upper bound for arbitrary deterministic online-local algorithms on bounded-degree trees.
- Actionable addition for output.md: Add Lemma F (as above) and its proof. Then state the main theorem as a corollary: On bounded-degree trees (indeed, graphs), any LCL Π solvable in O(1) rounds in deterministic Online-LOCAL(t) admits an O(log* n) deterministic LOCAL algorithm. Optionally include the bounded-writes variant using a G^{2t+2W}-coloring.

Relation to earlier commutativity tool
- Lemma 7 and Corollary 7.1 remain useful generally (e.g., for order normalization arguments, or if one prefers a proof with an explicit swapping argument). However, Lemma F gives a simpler, direct construction via a fixed order σ_φ.

Obstacles and caveats to keep in mind
- Model semantics: In each phase we must ensure that vertices of colors > i are “absent”: they neither send nor receive messages. This is easily enforced in the LOCAL simulation by having these nodes ignore messages (remain silent) until their phase.
- Independence radius: The 2t separation is tight for W=0. With W>0, use 2t+2W so that the influence regions B(v,W+t) are disjoint inside a color. This matches the corrected K in Lemma 5 (max(2W,R+W) specialized with R=W+t for the online window’s read neighborhood of the patch).
- Per-phase runtime: Exactly t rounds suffice; we do not need k·t even if the color class size is k, thanks to disjointness of the active regions.

Next steps (auditable)
1) Insert Lemma F into output.md with a rigorous inductive proof of invariant I(i); include the bounded-writes variant (coloring G^{2t+2W}).
2) State the main theorem as a clean corollary and explicitly emphasize that the argument does not rely on orientations (nonoriented trees are fine) nor on tree structure (it works for bounded-degree graphs).
3) Provide a short “pitfall” remark explaining why the earlier worry about long state accumulation is resolved by choosing a suitable arrival order, and why batching t-windows per color costs only t rounds.
4) Optionally keep the bridges (Lemmas 3–6) as auxiliary tools—they remain correct and are useful independently (e.g., if one wants a sequential-rule perspective).

Why this is meaningful progress
- We isolate and formalize the decisive lemma (faithful batched simulation of arbitrary deterministic online-local t-windows by colors), with a tight radius argument and runtime accounting. This cleanly settles the stated task for (nonoriented) bounded-degree trees and, in fact, for bounded-degree graphs. The lemma is ready to be integrated into output.md as a short but complete proof component.

## Round 0005 — 2025-08-27T19:02:02.024427Z

High-level status and target
- We now have a clean O(log* n) pipeline when the online algorithm satisfies output-only (with or without bounded writes) or the stronger t-local-dependence property. The bounded-writes scheduling radius K = max(2W, R+W) is correctly recorded. We also have a rigorously stated obstacle: faithful per-color batching is invalid in the unrestricted Online-LOCAL(t) due to idle state evolution; the minimal parity-counter example documents this.
- To settle the task in full generality for arbitrary deterministic Online-LOCAL(t) on bounded-degree trees, a remaining route is to separate the “log n-hard” class from the online-constant domain (showing those cannot have t = O(1)), and hence, by the tree-LCL classification, any LCL with Online-LOCAL(t)=O(1) must lie in the O(1)/Θ(log* n) class, yielding the desired O(log* n) deterministic LOCAL upper bound non-constructively. Below we formulate this lower-bound program precisely and propose a safe additional “quiescent” bridge that can be added to output.md.

New definitions and lemmas (clean statements, why useful)
- Definition (Quiescent Online-LOCAL(t)). An online algorithm is quiescent if, at the arrival of v, during the t synchronous rounds, nodes outside B(v,t) do not change their local state (they may ignore all computation/messages and remain idle). Why useful: This explicitly rules out the idle-update obstruction in unrestricted online runs and subsumes output-only as a special case with W=0.
- Lemma Q (Quiescent ⇒ O(log* n) LOCAL). If an LCL Π on bounded-degree graphs has a deterministic quiescent Online-LOCAL(t) algorithm (t=O(1)), then Π has a deterministic LOCAL algorithm running in O(t·log* n + Δ^{O(t)}·t) = O(log* n) rounds. Sketch: Fix a proper coloring of G^{2t} (Lemma 1). Process color classes 1,…,C. In phase i, all vertices v of color i execute their t-window in parallel. Quiescence ensures that only nodes in the disjoint balls {B(v,t)} may change state during phase i, so per-color cost is exactly t and no cross-interference occurs. Correctness holds for the specific “color-by-color” arrival order. This is a safe, self-contained variant to include in output.md.
- Open transformation target (state-elimination to quiescent on trees). Goal: Given any deterministic Online-LOCAL(t) algorithm A for an LCL Π on bounded-degree trees, construct a quiescent Online-LOCAL(t) algorithm A′ that reproduces A’s outputs for all arrival orders. Why useful: Combined with Lemma Q, this would close the full generality gap. Status: nontrivial; obstacles below.

Lower-bound program: excluding the log n-hard class from constant-t Online-LOCAL on trees
- Goal LB (Online lower bound for sinkless orientation). Prove: On bounded-degree trees, sinkless orientation cannot be solved by any deterministic Online-LOCAL(t) algorithm with constant t (for adversarial arrival orders). Why useful: By Theorem 2.33 (tree LCL classification), the log n-hard class is exemplified by sinkless orientation. If it requires t growing with n even in Online-LOCAL, then any LCL solvable in O(1) online rounds cannot be in the log n-hard class; hence, by the classification, it must have a deterministic LOCAL algorithm in O(1) or Θ(log* n) time, giving the desired O(log* n) bound existentially.
- Toolkit already in output.md: Lemma 7 (2t-commutativity) and Corollary 7.1 (push far-away arrivals past v). These localize pre-v influences to B(v,2t) without assuming quiescence. This is exactly the horizon needed for adapting the round-elimination proof scheme.
- Proposed Lemma LB.1 (Online node→edge reduction in a localized ball). On a Δ-regular tree with an ID-graph H as in Theorem 2.16, suppose a deterministic Online-LOCAL(t) algorithm A solves node-centered edge-grabbing (the node form of sinkless orientation) for all arrival orders. For any edge e = uv, after normalizing the prefix so only B(e,2t) arrives first (Cor. 7.1), one can define an edge-centered (t−1/2)-local reduction (within B(e,2t)) that decides the orientation of e by exhaustively considering consistent local arrival orders in B(e,2t). This faithfully mirrors Lemma 2.17 in the classical round-elimination proof but with the normalization step replacing global bounds. Why useful: It sets up a t→t−1/2 elimination inside a fixed-radius ball for the online model.
- Proposed Lemma LB.2 (Iterated elimination yields a 0-round contradiction). Iterating the node↔edge localized elimination 2t times yields a 0-round edge-centered algorithm on B(e,2t), hence a 0-round global prescription depending only on the ID-graph labels at the edge. As in Theorem 2.15, this contradicts the ID-graph property (Definition 2.16), showing that no constant-t Online-LOCAL algorithm can solve sinkless orientation. Why useful: This delivers the desired lower bound LB.
- Plan to formalize LB.1–LB.2 (next steps): (i) Specify the semantics of “consider all consistent local arrival orders within B(e,2t)” and show feasibility because the prefix is normalized and the ball is finite. (ii) Show that any conflict (both endpoints deciding to grab uv) witnessed by two such locally consistent extensions implies an actual global input and arrival order (gluing them into B(e,2t)) under which A fails, contradicting A’s correctness. (iii) Carry the induction to 0 rounds and invoke the ID-graph argument. These steps closely parallel the classical proof and are amenable to rigorous write-up.

Obstacles and clarifications
- Why quiescent reduction from arbitrary online A is hard: Without constraints, idle state updates outside B(v,t) can influence future behaviors inside the next B(·,t) even after normalization (the influence can be funneled through nodes that will later fall inside B(v,t)). Hence, a priori, replacing such idle updates by identity is not obviously sound. We therefore propose the classification-based route above as a robust way to separate out the hard class.
- On the path/t=1 “interface” program: The parity-counter example shows that without constraints, the realized output at v can depend on the number of prior arrivals even with identical K(v). However, to formally refute the context-invariance Claim C1 one needs two normalized histories with the same K(v) but different sets of feasible outputs; constructing such an LCL in the unrestricted model may require additional care (bounded-state/ID-obliviousness would make enumeration finite and C1 provable; otherwise, the set may be infinite). We suggest postponing this until the LB program is resolved.

Edits and additions suggested for output.md
- Add Lemma Q (Quiescent ⇒ O(log* n)) with a short proof. It clearly delineates a safe class where per-color batching works.
- Consider adding a short “Roadmap to online lower bound” remark: explain how Lemma 7/Cor. 7.1 enable localizing the round-elimination to B(e,2t), and outline the forthcoming Lemmas LB.1–LB.2 for sinkless orientation. This prepares for integrating a full proof that Online-LOCAL(t)=O(1) cannot solve the log n-hard LCLs on trees.
- Keep the existing negative “no faithful batching” remark; it prevents misuse of per-color batching outside quiescent/output-only models.

Concrete next steps (auditable)
1) Write and insert Lemma Q (quiescent bridge) into output.md, including the bounded-writes variant (color G^{2t+2W}).
2) Formalize Lemma LB.1 (localized node→edge elimination) and Lemma LB.2 (iteration to 0 rounds) for Online-LOCAL on Δ-regular trees with an ID-graph H. Provide full proofs, borrowing structure from Theorem 2.15 and leveraging Cor. 7.1.
3) Conclude the Online-LOCAL lower bound for sinkless orientation on trees: no deterministic constant-t algorithm exists. State the non-constructive corollary: Any LCL on bounded-degree trees solvable in deterministic Online-LOCAL(t) with constant t must admit an O(log* n) deterministic LOCAL algorithm by Theorem 2.33.
4) Optionally, explore whether the quiescent transformation can be proven for special online designs (e.g., finite-state or ID-oblivious algorithms), which would yield a constructive black-box simulation in those regimes.

Notes on gaps/errors
- No new errors spotted in output.md; the negative remark correctly blocks earlier flawed batching. Lemma 7 and Cor. 7.1 provide the localization tool we need for the online lower bound program. The quiescent variant is not yet present and can be safely added.

## Round 0005 — 2025-08-27T19:41:15.598712Z

Headlines for this round
- We isolate and formalize a natural “quiescence” hypothesis for Online-LOCAL(t) that precisely removes the idle-state accumulation pitfall flagged by the verifier, and prove a clean O(log* n) LOCAL simulation under this assumption (also with bounded writes W). This subsumes the output-only bridges and matches many natural online greedy designs.
- We explain why the existing Lemma 7 (2t-commutativity) remains valid despite unrestricted mutable state, and we suggest a small wording clarification to pre-empt confusion.
- We outline a concrete program to either (i) transform any Online-LOCAL(t) algorithm for LCLs on trees into a quiescent one (state-elimination-by-quiescence), or (ii) find a counterexample LCL on paths showing that such a transformation is impossible.

New definition and lemma: quiescent Online-LOCAL(t)
- Definition (quiescent outside the active ball). A deterministic Online-LOCAL(t) algorithm A is quiescent if, at the arrival of v, the only nodes whose local state may change during the ensuing t synchronous rounds are those in B(v,t). Equivalently, for every arrival step, nodes u with dist(u,v) > t do not modify their state (they may send/receive no messages anyway).
  • Bounded-writes extension (W-write): If A, at arrival of v, may irrevocably fix outputs within B(v,W), we say A is (W,t)-quiescent if only nodes in the active region B(v,W+t) may change state during the t-round window.
  • Relationship to prior models: Output-only is a special case of quiescence (no mutable state remains, hence trivially no changes outside the active region). The t-local-dependence property is about read-dependence; quiescence is about state updates and complements it.

- Lemma Q (Quiescent Online-LOCAL(t) ⇒ O(log* n) LOCAL). Let Π be an LCL on bounded-degree graphs. If Π has a deterministic quiescent Online-LOCAL(t) algorithm (W=0), then Π has a deterministic LOCAL algorithm with round complexity O(log* n). More generally, if Π has a deterministic (W,t)-quiescent Online-LOCAL(t) algorithm, then Π has a deterministic LOCAL algorithm with round complexity O((2t+2W)·log* n) = O(log* n) for constant Δ, t, W.
  • Proof sketch (auditable).
    1) Compute a proper coloring φ of G^{K} with K = 2t (or K = 2t+2W when W>0) using Lemma 1 in O(K·log* n) rounds; the color count C = Δ^{O(K)} is a constant for fixed Δ, t, W.
    2) Process color classes 1,2,…,C. In phase i, we simulate, in parallel, the t-round “arrival window” of every vertex v with φ(v)=i over the subgraph induced by already-arrived colors ≤ i (nodes of colors > i stay absent and silent). Because φ colors G^{2t} (resp. G^{2t+2W}), the active regions B(v,t) (resp. B(v,W+t)) are pairwise disjoint for same-color vertices. Thus the per-phase parallel simulation costs exactly t rounds and there is no inter-phase interference.
    3) Quiescence guarantees that nodes outside unions of active regions do not change state in a phase. Hence the sequence of states/output labels after finishing phase i exactly matches the sequential online run that processes arrival order σ_φ: first all color-1 vertices in any internal order, then color-2, etc. Induction on i (standard color-phased invariant) completes the argument. Correctness follows from the online algorithm’s correctness for every order; runtime is O(K·log* n + C·t)=O(log* n).
  • Radii accounting (W>0). Independence of same-color arrivals needs disjointness of the active regions B(v,W+t), hence K = 2t+2W, consistent with Lemma 5’s write–write and read–write separation bound K = max(2W, R+W) with R=W+t here.

Why this is useful
- This lemma cleanly fixes the flaw in the previously proposed “faithful t-rounds-per-color” batching: the failure stemmed from idle updates at distant nodes; quiescence explicitly rules those out. It generalizes the output-only bridges (Lemmas 3 and 6) and conveniently captures many practical online-local designs in which only the newly active t-neighborhood ever changes state.
- Examples (fit quiescence): Greedy MIS, greedy maximal matching (with W=1), and (Δ+1)-coloring variants that only modify states/labels within distance 1 of the arriving vertex; in all such rules, no node outside the local t-ball modifies its state during an arrival step.

Clarification about Lemma 7 (2t-commutativity)
- Status: Lemma 7 in output.md is sound even under unrestricted mutable state. The proof informally remarks that nodes outside B(u,t) “undergo the same deterministic state updates as they would in any window where they receive the same (empty) messages”. A potential confusion was whether state updates could depend on the identity of the arriving vertex or a global step counter. Swapping two consecutive arrivals at u and w: (i) nodes outside B(u,t)∪B(w,t) experience two consecutive steps with empty incoming messages in both orders, hence perform the same pair of updates (possibly depending on step index), and (ii) nodes in B(u,t) (resp. B(w,t)) are unaffected by the arrival at w (resp. u) due to t-hop message speed, hence their transcripts in the two orders are identical. Therefore, the combined effect commutes.
- Suggestion for output.md: Add a sentence noting explicitly that the argument allows arbitrary deterministic updates of “idle” nodes that depend on the step index but not on messages; since the number and positions of the two steps are the same after swapping, their updates coincide.

Relationship to the current archive (output.md)
- The new Lemma Q can be added as a sibling of Lemmas 3–6. It strictly subsumes Lemma 3 (output-only, W=0) and Lemma 6 (output-only, W>0): output-only implies quiescence, so Q re-derives Corollary B. It also clearly separates the regimes: unrestricted Online-LOCAL(t) (with idle updates) does not admit the batched simulation (see the parity-counter counterexample already added as a remark), whereas quiescent Online-LOCAL(t) does.
- No changes are needed to Lemma 5’s coloring radius K = max(2W, R+W); here R = W+t in the (W,t)-quiescent case, giving K = 2t+2W, as used in the proof.

State-elimination-by-quiescence program on trees (next objective)
- Goal: Show that for LCLs on bounded-degree trees, any deterministic Online-LOCAL(t) algorithm can be transformed into an equivalent quiescent Online-LOCAL(t) algorithm (or into an order-robust sequential (R,W)-local rule). This would remove the extra assumption and settle the main task in full generality.
- Rationale. For LCLs, correctness depends only on the final labeling and local constraints. On trees, Corollary 7.1 localizes pre-arrival influence to B(v,2t). We conjecture that any dependence on idle state accumulation outside active balls can be compiled away without affecting the final outputs: replace far-away idle dynamics by a canonical, inert behavior (quiescence) together with a localized interface summary at ∂B(v,2t), sufficient to reconstruct any messages that matter for v’s decision.
- Concrete plan (auditable, starting with paths, t=1):
  1) Normalize the arrival order using Corollary 7.1 so that only vertices in B(v,2) are processed before v.
  2) For each neighbor u of v, define the interface relation Σ(u→v): the set of possible neighbor-to-v messages u can send at the start of v’s window over all normalized executions consistent with the same already-fixed outputs on B(v,2). Try to prove that Σ(u→v) depends only on those outputs (context-invariance), not on internal mutable state histories. This is exactly the step where idle updates must be shown irrelevant for LCLs.
  3) If successful, define a canonical message selector and hence a quiescent rule (no far-away updates) that reproduces the same outputs; if not, construct a counterexample LCL on paths demonstrating that idle updates can alter Σ(u→v) despite fixed B(v,2) outputs.

Examples and sanity checks
- MIS and matching (greedy, patch-based): These are (W,t)-quiescent with W=1, t=1. Lemma Q immediately yields O(log* n) LOCAL.
- (Δ+1)-vertex-coloring with an arriving-vertex patch that finalizes the vertex and possibly one-hop neighbors (W=1, t=1): also (W,t)-quiescent. Lemma Q applies.
- Non-quiescent toy algorithm (not an LCL witness): The parity-toggling construction in output.md shows that faithful batching fails without quiescence, but since it targets a trivial LCL, it does not refute the existence of some other correct batched simulation. This underscores the need for either a quiescentization proof or a genuine LCL counterexample.

Gaps or edits to output.md
- Add Lemma Q (Quiescent Online-LOCAL(t) ⇒ O(log* n), with the W-write extension) including the exact radius/coloring parameters: K = 2t (W=0) and K = 2t+2W (W>0), per-phase time t, total O(log* n) on bounded-degree graphs.
- After Lemma 7, include a brief clarifying remark that idle updates depending only on step index are handled by the swap argument (as noted above).
- Keep the existing “No faithful t-per-color batching for unrestricted Online-LOCAL(t)” remark; it documents the core obstruction and motivates the quiescence hypothesis.

Obstacles and risks
- Quiescence is a strong assumption; while it matches many natural greedy rules, it may not cover all constant-time online algorithms. The main technical challenge is to either justify that quiescence is without loss of generality for LCLs on trees (state-elimination), or exhibit a separating LCL.
- The interface-invariance step on paths, t=1, may fail in the unrestricted model due to unbounded state+IDs; if so, we will aim to craft an explicit LCL that requires such dependence.

Next steps (concrete)
1) Integrate Lemma Q (statement and proof) into output.md and explicitly note that it subsumes the output-only bridges.
2) Begin the path/t=1 state-elimination-by-quiescence attempt:
   - Precisely formalize Σ(u→v) and the notion of “consistent normalized executions” (after Corollary 7.1).
   - Try to prove context-invariance of Σ(u→v) under the LCL constraint (messages that affect v depend only on B(v,2) already-fixed outputs). If successful, define a canonical quiescent neighbor interface and derive a quiescent online rule.
   - In parallel, explore candidate LCLs that might violate context-invariance by encoding a step-count into neighbor messages without affecting B(v,2) outputs.
3) Maintain radii accounting: for any (R,W)-local sequential rule extracted from a quiescent online rule, ensure simulation by a G^{K} coloring with K = max(2W, R+W) as in Lemma 5.

Why this is progress
- The quiescence lemma pinpoints a precise, verifiable condition under which the O(log* n) speedup holds for arbitrary deterministic Online-LOCAL(t) algorithms (bounded-degree trees or graphs), consolidating and extending the previously archived bridges.
- It gives a crisp target for the remaining open part: either prove quiescence w.l.o.g. for LCLs on trees (closing the task) or demonstrate a tight counterexample.



=== summary.md ===

## round-0002 — model summary — 2025-08-27T05:52:12.777564Z
In Round 0002, the focus was on generalizing Theorem 1.5 and its implications for trees. The approach shows promise, but careful interpretation of the theorem is crucial to avoid misapplication. Key properties of bounded-degree trees were identified as significant for generalization, and existing results for LCL problems were examined in relation to nonoriented trees. A comprehensive proof strategy is necessary to cover all cases, and relevant counterexamples must be constructed to demonstrate the theorem's limitations effectively.

## round-0001 — model summary — 2025-08-27T15:17:35.242254Z
Both prover outputs present the same reduction: any deterministic constant-radius (t=O(1)) online-LOCAL algorithm for an LCL Π on bounded-degree, unoriented trees yields a deterministic LOCAL algorithm with O(log* n) rounds. The pipeline is (1) view the online algorithm as a sequential-local algorithm (order-robust), (2) compute a distance-(2t) coloring of G^{2t} in O(t·log* n) rounds via Linial-style color reduction on the power graph, and (3) simulate the sequential/local run in color phases — vertices of one color run the t-round local decision in parallel because their t-neighborhoods are disjoint. For bounded Δ and constant t this gives O(log* n) total time; the argument needs the online model to succeed for every adversarial arrival order. Action items are to formalize the three lemmas (online⇒sequential, power-graph coloring, color-phased simulation), track constants/auxiliary state, and confirm the exact online-LOCAL definition matches the cited literature. Cited files: prover-01.out.json, prover-02.out.json.

## round-0002 — model summary — 2025-08-27T15:24:40.987416Z
This round clarified a precise gap between the archived O(log* n) speedup (Theorem A, Lemma 1–2, Corollary A) — which is correct for the order-robust r-local sequential model that reads B(v,r) and writes only at v — and the stronger “Online-LOCAL(t)” model used in ICALP’23. Two useful restricted variants were proposed and connected to the archived proof: (i) output-only Online-LOCAL(t) (arrived vertices fix immutable outputs and send messages that depend only on graph + those outputs in B(v,t)), and (ii) t-local-dependence (v’s decision depends only on arrived subgraph and fixed outputs in B(v,t)). Lemma O1 / Bridge lemmas show these restrictions imply an order-robust sequential r-local rule (r=t), hence the archived O(log* n) result applies. A minimal counter-scenario on a path (t=1) demonstrates why unrestricted Online-LOCAL(t) can accumulate long-range mutable state that breaks the color-phased simulation. The main open technical direction is a tree-specific “state-elimination” program (start with paths t=1, prove a canonical interface on ∂B(v,2t) or exhibit a separating LCL). Files cited: prover-01.out.json, prover-02.out.json; refs: Akbari et al. (ICALP’23), Theorem 2.33 (tree LCL classification).

## round-0003 — model summary — 2025-08-27T15:51:38.251697Z
Round 0003 (prover-02) establishes a provable commutativity lemma (Lemma D) showing that two consecutive arrivals at distance > 2t commute, and derives Corollary D.1 which lets us push all arrivals beyond radius 2t past a focal vertex v. This localises any information that can affect v during its t-window to the finite ball B(v,2t), matching the 2t read-radius in the earlier bridge. The round proposes an “interface-confluence” program for t=1 on paths: define per-neighbor interface types τ(u→v) depending only on outputs in B(u,2), then show the tuple of these types plus existing outputs in B(v,2) determines v’s transcript and output; extend by branch decomposition to trees and by scaling radii for general t. The main remaining obstacle is internal non-confluence inside B(u,2): Lemma D removes long-range effects but does not force order-robustness of local histories. Next actions are to formalise Lemma D/Corollary D.1 in output.md, carry out the path t=1 interface analysis (prove or find a counterexample), and then generalise or document the limitation. Files: prover-02.out.json (Round 0003, main), prover-01.out.json (background bridges).

## round-0004 — model summary — 2025-08-27T19:00:14.808982Z
This round produced two complementary advances. prover-01 strengthened the normalization toolkit (Lemma 8: strong witness-localization at v) and gave a finite-enumeration lemma for t=1 on paths (Lemma 9), defined interface types τ(u→v) and posed Claim C1 (τ depends only on K(v)) as a focal, testable route to convert arbitrary Online-LOCAL(1) rules on paths into sequential rules. prover-02 answered the main gap directly: Lemma F shows a faithful color-phased simulation for any deterministic Online-LOCAL(t) by choosing the color-by-color arrival order σ_φ (coloring G^{2t}) and executing each color’s t-round windows in parallel. This reproduces A’s outputs exactly and yields an O(t·log* n + C·t) = O(log* n) LOCAL algorithm for bounded-degree constant-t graphs; bounded-writes extend via coloring G^{2t+2W}. In short: the main open concern about long-range mutable-state accumulation is resolved by simulating a specific benign order. Next steps: integrate Lemma F into output.md and resolve/prove or refute C1 for the path t=1 program. Citations: prover-01.out.json, prover-02.out.json.

## round-0005 — model summary — 2025-08-27T19:49:16.143991Z
This round isolated a clean “quiescence” condition that blocks the idle-state accumulation failure of the earlier batching idea and proved a tight Local simulation under that assumption. Quiescent Online-LOCAL(t) means that when vertex v arrives only nodes in B(v,t) may change state (with a W-write variant allowing irrevocable outputs in B(v,W)). Lemma Q: any LCL with a deterministic quiescent Online-LOCAL(t) (W=0) yields a deterministic LOCAL algorithm in O(log* n) rounds; more generally, (W,t)-quiescent gives O((2t+2W)·log* n) via a G^{K}-coloring with K=2t (or 2t+2W). The round also confirms that Lemma 7 (2t-commutativity) remains valid even with deterministic idle updates that depend on step index. Two routes remain to close the full result: (A) transform arbitrary Online-LOCAL(t) on trees into a quiescent version (state-elimination), or (B) prove a lower bound (via localized round-elimination for sinkless orientation) showing constant-t online cannot solve the log-n-hard class, which combined with tree LCL classification gives the O(log* n) corollary. Verifier: partial success.



=== notes.md ===
Context and goal
We study the relationship between online-style constant-locality algorithms for LCLs on bounded-degree, unoriented trees and deterministic LOCAL-time upper bounds. Two notions of “online local” are relevant:
- Sequential local/greedy model (order-robust r-local): when processing a vertex v, the decision at v depends only on the r-hop neighborhood B(v,r) of the underlying graph and on already fixed outputs within B(v,r); the algorithm must succeed for every vertex order. No global mutable state or long-range message accumulation between steps.
- Online-LOCAL(t) (Akbari–Eslami–Lievonen–Melnyk–Särkijärvi–Suomela, ICALP’23): vertices arrive one by one; upon each arrival, the algorithm has t synchronous LOCAL rounds on the subgraph induced by arrived vertices; outputs are irrevocable. Over many arrivals, an unbounded number of communication rounds can occur, enabling long-range state accumulation.

Safe, proven variant (archived below in output.md)
- Theorem (Sequential-local to LOCAL): If an LCL Π on bounded-degree graphs has a deterministic order-robust r-local sequential algorithm (decisions at v depend only on B(v,r) and outputs of earlier vertices in B(v,r), and the rule writes only the output at v), then Π has a deterministic LOCAL algorithm running in O(r log* n + Δ^{O(r)}) rounds. On bounded-degree trees with constant r, this is O(log* n). Proof: compute a proper coloring of G^r in O(r log* n) rounds with Δ^{O(r)} colors; process color classes in order, letting each v gather outputs from B(v,r) restricted to earlier colors and apply the sequential rule. Because nodes of the same color are at distance > r, their decisions do not depend on each other.

Gap for the full Online-LOCAL(t) model
- A direct phase simulation that uses a distance-(2t) coloring and t rounds per color does not generally reproduce the state a node v would see upon arrival in an actual online execution. In a true online run, before v arrives, there may have been Θ(n) earlier arrivals, yielding Θ(n)·t global rounds; information can propagate arbitrarily far and may alter the states within B(v,t). The phase simulation grants only O(1)·t total rounds before v’s phase, so the local states can differ. Hence, without additional constraints, we cannot claim that the phase simulation faithfully reproduces the online run or even yields correctness solely from A’s correctness.

Ways forward for Online-LOCAL(t)
- Add a locality-of-dependence assumption: the t-round transcript that determines v’s output depends only on the arrived subgraph inside distance ≤ t from v and on the outputs of those nodes, not on mutable states imported from farther away. Under this, distance-(2t) coloring plus phase simulation is valid and yields O(log* n).
- Alternatively, seek a structural scheduling/padding argument ensuring that for LCLs on bounded-degree trees, the state within B(v,t) before v’s arrival is independent of far-away arrivals. This is nontrivial; try first on paths/trees with t=1 to see whether accumulation can matter for any LCL.
- Or try to separate the models: construct an LCL that is solvable in constant t in Online-LOCAL but provably not simulable by the above constant-phase compression; if such an LCL exists, the general reduction fails, and the sequential-local variant becomes the correct target.

Remarks
- No global edge orientation is needed anywhere in the reduction we proved; IDs suffice for coloring.
- The archived proof applies to all bounded-degree graphs; we stated trees to match the project focus.
Refinements on bridging Online-LOCAL(t) to sequential local rules
- Definitions (recap and refinement):
  • Online-LOCAL(t): vertices arrive one by one; upon each arrival we have t synchronous LOCAL rounds on the subgraph induced by arrived vertices; outputs are irrevocably set at arrival; in the general model, nodes may maintain unbounded mutable state across arrival windows.
  • Output-only Online-LOCAL(t): the only persistent state at nodes is the immutable output label after it is set; between windows there is no other state; in any t-round window, messages sent by a node are functions only of the underlying graph and the currently known outputs within its distance-t neighborhood (no dependence on farther outputs or on pre-window mutable state).
  • t-local-dependence at v: when v arrives, its output depends only on the arrived subgraph restricted to B(v,t) and outputs of the arrived nodes within B(v,t).

- Correct radius accounting:
  • At v’s arrival with window length t, nodes within B(v,t) can influence v. A node u ∈ B(v,t) may compute its messages based on outputs within B(u,t), which is contained in B(v,2t). Thus, in the output-only model, v’s output depends only on the graph structure and outputs within B(v,2t). Consequently, the correct bridge is to a sequential rule of radius 2t (not t). If we assume t-local-dependence at v, the bridge tightens to radius t.

- Minimal counter-scenario (why naive phase-compression fails for the unrestricted online model):
  Consider a path with t=1. In a genuine online run, before a vertex v arrives, Θ(n) earlier arrivals can propagate state one hop per window across the path; by the time v arrives, its neighbors may carry information injected far away. A color-phased simulation that offers only O(1) windows before v’s phase cannot reproduce these accumulated states. This shows that without output-only or t-local-dependence, we cannot black-box simulate arbitrary Online-LOCAL(t) runs by a constant number of phases.

- Practical takeaway for reductions:
  • If your online algorithm is output-only, design the sequential rule to read B(v,2t) and write only at v; then apply the G^{2t} coloring pipeline to get O(log* n) on bounded-degree trees.
  • If your online algorithm satisfies t-local-dependence at v, the sequential rule needs only B(v,t).

- Next-step plan (state elimination on trees):
  • Start on paths with t=1. Define the interface ∂B(v,2) and annulus R=B(v,2)\B(v,1). Attempt to prove: if two online executions agree on outputs over B(v,2), then they allow exactly the same outputs at v. If proven, extend to trees and t by replacing 2 with 2t. If refuted, crystallize a separation example.
  • Track read/write radii for any sequential rules that go beyond “write only at v”; use distance-(R+W) colorings for phase independence.
Additions and corrections

1) Correct simulation radius for bounded writes.
- When simulating an order-robust sequential rule that reads within B(v,R) and may write within B(v,W), independence within a color class requires both:
  • Write–write disjointness: B(u,W) ∩ B(v,W) = ∅.
  • Read–write disjointness: B(u,R) ∩ B(v,W) = ∅ and B(v,R) ∩ B(u,W) = ∅.
- These are guaranteed if dist(u,v) > max(2W, R+W). Therefore, the correct coloring is a proper coloring of G^K with K = max(2W, R+W). Using G^{R+W} alone is insufficient in general.
- Minimal counterexample to G^{R+W}: Take R=0, W=1 on the path u–x–v. Here dist(u,v)=2>R+W, but B(u,1)∩B(v,1)={x} so simultaneous writes conflict.

2) Output-only, W-write Online-LOCAL(t) ⇒ sequential (R,W) with R=2t+W.
- Model: When v arrives, A runs t rounds and may irrevocably write outputs on B(v,W); messages during this window depend only on the graph and the currently known outputs within distance ≤ t of the sender; no other mutable state persists.
- Radius accounting: To decide outputs on the patch B(v,W) within t rounds, only nodes in B(B(v,W), t) = B(v, W + t) can send messages that reach the patch. Under output-only, each such sender’s messages are functions of outputs in its own t-ball. Hence the decisions on the patch depend only on outputs within B(v, W + 2t) = B(v, 2t + W).
- Sequential rule S: For a given order σ, when processing v, S reads already-fixed outputs in B(v, 2t+W) and deterministically reproduces A’s t-window on the patch, writing only to currently-unset outputs in B(v,W). Because A is deterministic and correct for all orders, S reproduces A’s result for order σ.

3) Commutativity of independent arrivals (unrestricted Online-LOCAL(t)).
- If two consecutive arrivals u and w satisfy dist(u,w) > 2t, swapping their order leaves the t-round transcripts and resulting states identical everywhere. In particular, by repeatedly swapping, one can assume that, when analyzing v, only arrivals within B(v,2t) occur before v. This normalizes the analysis horizon for any state-elimination attempt.

4) State-elimination program on paths (t=1) — concrete targets.
- Define the interface K(v) as the already-fixed outputs on B(v,2) just before v arrives (after normalizing the order so only B(v,2) arrives first). Target claim (context-invariance): The set of feasible outputs/messages at v depends only on K(v). If true, derive a canonical sequential rule of read radius R=2 and (potential) write radius W by reproducing the canonical choice. If false, document a counterexample LCL on paths.

5) Accounting for LOCAL complexity when W>0.
- With (R,W)-local sequential rules, compute a proper coloring of G^{K} with K = max(2W, R+W) in O(K log* n) rounds (Lemma 1 simulated on G), then process colors in O(R) rounds per color. On bounded-degree trees with constant R,W, this gives O(log* n) overall.
Disproof of “faithful color-by-color simulation” for unrestricted Online-LOCAL(t)
The tempting idea to fix a proper coloring φ of G^{2t}, choose the arrival order σ_φ that processes color classes 1,2,…,C, and then simulate each color class in O(t) rounds by running all arrivals of that color concurrently, is not valid in the unrestricted Online-LOCAL(t) model.

Key obstruction: In the Online-LOCAL(t) semantics, each arrival triggers t synchronous rounds across the entire arrived subgraph. Nodes outside B(v,t) of the newly arrived vertex v may still update their local state in that step (e.g., increment a local counter) even though they receive no messages. Over k arrivals in a color class, every previously arrived node performs k such "idle" updates. Compressing k steps to 1 per color fails to reproduce the global state unless one can apply k-fold local updates everywhere, which is not locally computable in O(1) rounds.

Minimal counterexample (paths, t=1). Consider the trivial LCL Π that accepts any labeling. Define a deterministic Online-LOCAL(1) algorithm A as follows:
- Every arrived node maintains a parity bit p, initially 0, and toggles p at every arrival step (independently of messages).
- When a new vertex v arrives, in the 1-round window v queries any neighbor u (if one exists) for p and outputs that bit. (If v has no arrived neighbor, it outputs 0.)
This A is correct for Π for every arrival order (Π accepts any labeling). Fix any proper 3-coloring φ of the path’s G^2. In the sequential σ_φ-run that processes all color-1 vertices one by one, p toggles at every arrival, so the outputs of color-1 vertices alternate with their internal order. A batched O(1)-round simulation that processes all color-1 vertices simultaneously cannot reproduce these alternating outputs: all of them see the same parity p from earlier colors and output the same bit. Hence faithful reproduction of the σ_φ-run is impossible in general.

Consequences.
- The earlier “main gap” (state accumulation across many arrivals) is real for unrestricted Online-LOCAL(t): batched simulation does not, in general, preserve the online run’s state trajectory.
- To make per-color batching sound, one needs extra structure such as quiescence: outside B(v,t), the per-step state update is the identity (or, more generally, does not depend on the number of arrivals). The output-only and t-local-dependence variants already enforce related constraints.

On Lemma 8 and local order normalization
- Our Corollary 7.1 already implies the witness localization needed for per-node analysis: by swapping distant arrivals (dist > 2t), one can assume all arrivals before v occur in B(v,2t) without changing the state in B(v,t) at v’s arrival. This is the appropriate normalization tool for any local confluence/interface analysis.

On Lemma 9 (finite enumeration claim)
- As stated (“the set of possible transcripts/messages seen by v is finite”), this is false in the standard LOCAL model due to unbounded message/state spaces and dependence on unique IDs. Finite enumeration becomes viable only if one assumes bounded message alphabets, bounded state, or ID-obliviousness; otherwise, for a fixed constant-size ball B(v,2), the algorithm can encode arbitrarily large ID-dependent information into messages/states.

Next steps for the path/t=1 interface program
- Either (i) impose output-only (or stronger quiescence/ID-obliviousness) and aim to prove the context-invariance Claim C1 under those constraints, or (ii) build a concrete counterexample to C1 in the unrestricted model by letting neighbors’ 1-round messages to v depend on the number of prior arrivals while keeping K(v) fixed. In both tracks, use Corollary 7.1 to restrict attention to B(v,2).

Complexity reminder for bounded writes
- With (R,W)-local sequential rules, independence within a color class requires K = max(2W, R+W). Computing a proper coloring of G^{K} costs O(K·log* n) rounds and per-color work is O(R). For bounded Δ, R, W, this yields O(log* n) total complexity dominated by the coloring step.
New bridge via quiescence (precise form) and radius accounting
- Definition (quiescent Online-LOCAL(t), standard LOCAL timing). In each arrival step for v, the algorithm runs t synchronous LOCAL rounds on the arrived subgraph. Messages sent in round r depend only on the node’s state at the start of round r; at the end of the round, nodes update their state based on received messages. The algorithm is quiescent if, during the t rounds triggered by v’s arrival, every node u with dist(u,v) > t does not change its state in any of these t rounds. (Under the above timing, such u cannot forward newly received information in subsequent rounds because its outgoing messages in round r depend only on its unchanged state.)
- (W,t)-quiescent: If the algorithm may irrevocably write outputs on a patch B(v,W) during v’s window, we call it (W,t)-quiescent if only nodes in B(v,W+t) may change state in that window.

- Correct separation for parallel batching: To parallelize all same-color windows for t rounds without interference, it is necessary to forbid any edge between distinct active regions. For W=0 the active region for v is B(v,t). Thus, a proper coloring of G^{2t+1} (not merely G^{2t}) guarantees that for same-color u,v, dist(u,v) ≥ 2t+2, hence dist(B(u,t), B(v,t)) ≥ 2. This eliminates one-hop coupling across region boundaries. With W>0, color G^{2t+2W+1} so that distinct active regions B(·,W+t) have mutual distance ≥ 2.

- Why quiescence removes the “idle-accumulation” pitfall: In the unrestricted model, nodes can encode the number of prior arrivals into their state and/or messages, letting each new window see different ambient information; batching then fails. Under quiescence, any vertex whose t-window has not yet been processed cannot track steps that do not involve it, so its local view (modulo the already-arrived graph and earlier colors) is invariant across the internal order within a color class. Combined with the ≥2 separation between active regions, the parallel t-round simulation per color faithfully matches any sequential permutation of that color.

- Examples that fit quiescence: Greedy MIS and greedy maximal matching on bounded-degree graphs (W=1, t=1) where only the newly active 1-neighborhood changes, and (Δ+1)-vertex-coloring rules that finalize a 1-hop patch around the arrival.

Remark on Lemma 7 (2t-commutativity)
- The lemma remains valid even if nodes outside B(u,t) ∪ B(w,t) perform deterministic updates depending only on the global step index (and not on messages). Those nodes experience the same two consecutive step indices before and after the swap; hence their pair of updates is identical.

Lower-bound program (outline) for Online-LOCAL on trees
- Target: Prove that sinkless orientation on bounded-degree trees admits no deterministic Online-LOCAL(t)=O(1) algorithm (adversarial arrival). Use Lemma 7/Cor. 7.1 to normalize prefixes so that only B(e,2t) arrives before deciding edge e. Then adapt the node↔edge round-elimination locally inside B(e,2t), iterating 2t times to obtain a 0-round contradiction with the ID-graph property. Formalizing this (LB.1–LB.2) would non-constructively imply: any LCL with constant-t Online-LOCAL on trees lies in the O(1)/Θ(log* n) class, so there exists an O(log* n) deterministic LOCAL algorithm.

Next steps
- Integrate the quiescent bridge with K=2t+1 (resp. 2t+2W+1) into output.md.
- Begin the path (t=1) state-elimination-by-quiescence attempt with a precise interface Σ(u→v) and normalized histories (via Cor. 7.1). Either prove context-invariance or extract a counterexample LCL.
- In parallel, formalize LB.1–LB.2 for sinkless orientation as described above.

=== output.md ===
List of proven results archived here
- Lemma 1: Power-graph coloring in O(k log* n).
- Lemma 2: Color-phased simulation for order-robust read-radius r rules that write only at the current node (W=0).
- Theorem A: Sequential-local (W=0) ⇒ LOCAL on bounded-degree graphs.
- Lemma 3: Bridge from output-only Online-LOCAL(t) (W=0) to order-robust sequential with read radius 2t.
- Lemma 4: Bridge under t-local-dependence (W=0) to read radius t.
- Corollary A: On bounded-degree trees, constant r or constant t ⇒ O(log* n) LOCAL.
- Lemma 5: Color-phased simulation for sequential rules with read radius R and write radius W via a G^{K}-coloring with K = max(2W, R+W).
- Lemma 6: Bridge from output-only, W-write Online-LOCAL(t) to an order-robust sequential rule with (R,W) = (2t+W, W).
- Corollary B: On bounded-degree trees, constant t,W in output-only W-write Online-LOCAL(t) ⇒ O(log* n) LOCAL.
- Lemma 7: 2t-commutativity of independent consecutive arrivals in Online-LOCAL(t), and a corollary pushing far-away arrivals past a fixed v.

Model and definitions
- Graphs: finite, simple, maximum degree Δ < ∞ (bounded degree). Nodes have unique IDs from a polynomial range (standard LOCAL assumptions). dist(·,·) is the hop distance; B(v,r) is the radius-r ball around v.
- LCL Π: a locally checkable labeling problem with constant checkability radius r_Π.
- Order-robust sequential rules with bounded writes: A deterministic rule S with read radius R and write radius W is a procedure that, when processing v in a vertex order σ, inspects G[B(v,R)] and the outputs already fixed in B(v,R) ∩ {earlier vertices in σ}, and may irrevocably write outputs on any currently-unset vertices in B(v,W). The final labeling must satisfy Π for every σ. (The special case W=0 writes only at v.)
- Online-LOCAL(t): vertices arrive one by one; at each step the algorithm executes t synchronous LOCAL rounds on the subgraph induced by the arrived vertices; outputs are irrevocable; nodes may maintain arbitrary local state across steps unless otherwise restricted.
- Output-only Online-LOCAL(t): the only persistent state is the immutable output label after it is set; in any t-round window, messages and local computation at a node may depend on the graph and currently known outputs within distance ≤ t from that node, but not on any other mutable state.
- t-local-dependence (at v): upon v’s arrival, its output depends only on the induced arrived subgraph and previously fixed outputs within B(v,t).
- Output-only, W-write Online-LOCAL(t): as output-only above, but when v arrives the algorithm may irrevocably fix outputs on any vertices in B(v,W).

Lemma 1 (Power-graph coloring in O(k log* n))
Statement. Let G be a bounded-degree graph and k ≥ 1 a constant. There is a deterministic LOCAL algorithm that computes a proper vertex coloring of the power graph G^k with at most C = Δ^{O(k)} colors in O(k log* n) rounds on G.
Proof. Standard: simulate an O(log* n)-round O(Δ(G^k)^2)-coloring on G^k by k rounds per step on G; Δ(G^k) ≤ Δ^k, hence C = Δ^{O(k)}. □

Lemma 2 (Color-phased simulation for W=0)
Statement. Let S be an order-robust sequential rule with read radius r that writes only at the current node (W=0). Given a proper coloring of G^r, processing colors 1,…,C in order reproduces S for any order respecting the color layering, using O(r) rounds per color.
Proof. If φ(u)=φ(v) then dist(u,v)>r, hence the decisions in phase i depend only on outputs from earlier colors and do not interfere. Each node gathers outputs in B(·,r) from earlier colors in O(r) rounds and applies S. □

Theorem A (Sequential-local (W=0) ⇒ LOCAL)
Statement. If Π admits an order-robust r-local sequential algorithm (W=0), then Π has a deterministic LOCAL algorithm running in O(r log* n + Δ^{O(r)}·r) rounds. For constant Δ,r: O(log* n).
Proof. Compute a G^r-coloring in O(r log* n) rounds (Lemma 1), then simulate by Lemma 2. □

Lemma 3 (Output-only Online-LOCAL(t), W=0 ⇒ sequential with read radius 2t)
Statement. If Π has a deterministic output-only Online-LOCAL(t) algorithm correct for every arrival order, then Π admits an order-robust sequential algorithm with read radius 2t (W=0) that reproduces the online outputs for any order.
Proof. Fix order σ. When v_i arrives online under σ, only nodes in B(v_i,t) can send messages that reach v_i within t rounds. Under output-only, any such message depends only on outputs within the sender’s B(·,t), all contained in B(v_i,2t). Hence v_i’s t-window transcript and output are functions of the restriction to B(v_i,2t) of the arrived subgraph and outputs. Define the sequential rule to read those and return the same output as the online algorithm would under σ. Correctness and order-robustness follow. □

Lemma 4 (Bridge under t-local-dependence, W=0)
Statement. If Π has a deterministic Online-LOCAL(t) algorithm with t-local-dependence (at every v) that is correct for every arrival order, then Π admits an order-robust sequential algorithm with read radius t (W=0).
Proof. As in Lemma 3, but with t in place of 2t by hypothesis. □

Corollary A (Bounded-degree trees, constant r or t)
Statement. On bounded-degree trees, if Π has either (i) an order-robust r-local sequential algorithm (W=0) with constant r, or (ii) an output-only Online-LOCAL(t) algorithm (W=0) with constant t, or (iii) an Online-LOCAL(t) algorithm with t-local-dependence and constant t, then Π has a deterministic LOCAL algorithm with round complexity O(log* n).
Proof. Combine Theorem A with Lemma 3 or Lemma 4 as applicable; Δ and radii are constants. □

Lemma 5 (Color-phased simulation with bounded writes)
Statement. Let S be an order-robust sequential rule with read radius R and write radius W ≥ 0 (S may write outputs on currently-unset vertices in B(v,W)). Let φ be a proper coloring of G^{K} with K = max(2W, R+W). Then processing colors 1,…,C in order reproduces S for any order that respects the color layering. The per-color communication cost is O(R) rounds after φ is known.
Proof. If φ(u)=φ(v) then dist(u,v) > K ≥ 2W and > R+W. Thus (i) B(u,W) ∩ B(v,W) = ∅ (no write–write conflicts) and (ii) B(u,R) ∩ B(v,W) = ∅ and B(v,R) ∩ B(u,W) = ∅ (no read–write interference). In phase i, each vertex v with φ(v)=i gathers outputs written by earlier colors within B(v,R) and computes its writes; because of (i)–(ii), these writes are independent across same-color vertices and depend only on earlier colors, so the result matches S for any order that lists all lower colors first and then the current color in any internal order. O(R) rounds suffice to gather B(v,R) information. Computing φ takes O(K log* n) rounds by Lemma 1 with k=K. □

Lemma 6 (Output-only, W-write Online-LOCAL(t) ⇒ sequential with (R,W)=(2t+W,W))
Statement. If Π has a deterministic output-only, W-write Online-LOCAL(t) algorithm A correct for every arrival order, then Π admits a deterministic order-robust sequential rule S that, when processing v, reads only B(v, 2t+W), may write on currently-unset vertices in B(v,W), and reproduces A’s outputs for any order.
Proof. Fix order σ = (v_1,…,v_n). Consider A under arrival order σ. When v_i arrives, during its t-round window only nodes within distance ≤ t of the patch B(v_i,W) can send messages that reach the patch; hence all influencing senders lie in N := B(B(v_i,W), t) = B(v_i, W+t). Under output-only, messages sent by any u ∈ N depend only on outputs within B(u,t). Therefore the union of outputs that can affect the patch’s decisions lies in M := ⋃_{u∈N} B(u,t) = B(v_i, W+2t). Consequently, the t-round transcript determining the patch outputs in the σ-run is a function of the restriction of the arrived subgraph and already-fixed outputs to B(v_i, 2t+W). Define S as follows: when processing v_i under σ, S collects the already-fixed outputs within B(v_i, 2t+W) ∩ {v_1,…,v_{i-1}} and deterministically reproduces A’s t-window decisions on the patch given that local view, writing only to vertices in B(v_i,W) whose outputs are not yet fixed. Because A is deterministic and respects irrevocability, this reproduces exactly the same patch outputs as A under σ and never overwrites. As A is correct for every order, S is an order-robust (R,W)-local rule with R=2t+W. □

Corollary B (Bounded-degree trees, output-only W-write ⇒ O(log* n) LOCAL)
Statement. On bounded-degree trees, if Π has a deterministic output-only, W-write Online-LOCAL(t) algorithm with constants t,W, then Π has a deterministic LOCAL algorithm with round complexity O(log* n).
Proof. Apply Lemma 6 to obtain a sequential (R,W)-rule with R=2t+W. Then use Lemma 5 with K = max(2W, R+W) = max(2W, 2t+2W) = 2t+2W to simulate S in the LOCAL model: compute a proper coloring of G^{2t+2W} in O((2t+2W) log* n) rounds, then spend O(R)=O(2t+W) rounds per color. For constant Δ,t,W the total is O(log* n). □

Lemma 7 (2t-commutativity of independent consecutive arrivals)
Statement. Let A be any deterministic Online-LOCAL(t) algorithm (unrestricted mutable state). Consider an arrival sequence σ and two consecutive arrival steps at vertices u and w such that dist(u,w) > 2t. Let σ′ be obtained by swapping these two steps. Then, after these two steps, the states and fixed outputs at all vertices are identical under σ and under σ′.
Proof. Let G_i be the arrived subgraph just before these two steps. In the step when u arrives under σ, A executes t synchronous rounds on G_i ∪ {u}. Messages can traverse at most t hops per window, so only nodes in B(u,t) can be influenced (either by receiving messages or by depending on received messages); nodes outside B(u,t) undergo the same deterministic state updates as they would in any window where they receive the same (empty) messages. Likewise, w’s step affects only B(w,t). Because dist(u,w) > 2t, the balls B(u,t) and B(w,t) are disjoint, and w is absent during u’s step and u is absent during w’s step in both σ and σ′. Therefore the t-round transcripts and resulting updates within B(u,t) (resp. B(w,t)) are identical in σ and σ′, and all other vertices experience no message-dependent changes in either order. Thus the combined effect of the two steps commutes. □

Corollary 7.1 (Pushing far-away arrivals past v)
Statement. Fix v and any arrival sequence. By repeatedly swapping consecutive independent steps via Lemma 7, one can transform the sequence into another in which all vertices at distance > 2t from v arrive after v, without changing any states or outputs within B(v,t) at the time v arrives (or thereafter).
Proof. Iteratively swap any arrival at distance > 2t from v forward past earlier arrivals until it occurs after v; Lemma 7 ensures the swaps preserve the relevant states/outputs. □

Remark. Lemma 5 supersedes the earlier, flawed variant that required only a G^{R+W}-coloring; the counterexample R=0, W=1 on a 3-path shows that G^{R+W} is insufficient because write–write conflicts may occur.
Remark (No faithful t-per-color batching for unrestricted Online-LOCAL(t)). There exists a deterministic Online-LOCAL(1) algorithm A and a valid color-by-color arrival order σ_φ (induced by a proper coloring φ of G^2 on a path) such that any LOCAL simulation that processes all vertices of the same color class simultaneously in O(1) rounds cannot reproduce the exact outputs produced by A under the sequential σ_φ-run.
Proof. Consider the trivial LCL Π that accepts any labeling. Algorithm A maintains at each arrived node a parity bit p (initially 0) that toggles at every arrival step (regardless of messages). When a new vertex v arrives, in its 1-round window it reads p from an already-arrived neighbor if one exists and outputs that bit (if v has no arrived neighbor, it outputs 0). Fix any proper 3-coloring φ of the path’s G^2 and let σ_φ process colors 1,2,3 in order, with any internal order inside a color. In the sequential σ_φ-run, the parity p toggles at every arrival, hence the outputs of the vertices of any color class alternate with the internal order. In contrast, if one processes all vertices of a color class simultaneously in a single 1-round batch (keeping not-yet-processed colors absent), all these vertices observe the same parity p from earlier colors and therefore all output the same bit. Thus the batched simulation does not reproduce A’s outputs under σ_φ. □

Remark (Complexity accounting for Lemma 5/Corollary B). On bounded-degree graphs with constants t,W, the coloring step on G^{K} (K = max(2W, R+W), with R = 2t+W in Corollary B) costs O(K·log* n) rounds and yields C = Δ^{O(K)} colors; the per-color work is O(R). Hence the total complexity is O(log* n), dominated by the coloring step.
Definition (Quiescent Online-LOCAL(t) and (W,t)-quiescent)
Consider the standard LOCAL timing in an arrival step: in each of t synchronous rounds, each arrived node first sends messages as a (deterministic) function of its current state, then receives messages from neighbors, and finally updates its state as a (deterministic) function of its current state and the received messages.
- An Online-LOCAL(t) algorithm A is quiescent if, upon the arrival of v, during the ensuing t rounds every node u with dist(u,v) > t does not change its state in any of these t rounds.
- More generally, A is (W,t)-quiescent if, upon the arrival of v, during the ensuing t rounds only nodes in the active region B(v, W+t) may change their state; nodes outside B(v,W+t) do not change state.

Lemma 8 (Quiescent Online-LOCAL(t) ⇒ O(log* n) LOCAL; bounded-writes variant)
Let Π be an LCL on bounded-degree graphs. Suppose Π has a deterministic quiescent Online-LOCAL(t) algorithm A with constant t.
(i) Then Π admits a deterministic LOCAL algorithm with round complexity O((2t+1)·log* n + t·Δ^{O(t)}) = O(log* n).
(ii) More generally, if A is (W,t)-quiescent with constants W,t, then Π admits a deterministic LOCAL algorithm with round complexity O((2t+2W+1)·log* n + t·Δ^{O(t+W)}) = O(log* n).

Proof.
Fix K := 2t+1 in case (i), and K := 2t+2W+1 in case (ii). By Lemma 1, compute a proper coloring φ of G^{K} with C = Δ^{O(K)} colors in O(K·log* n) rounds. We process the colors in increasing order i = 1,2,…,C in phases; at the start of phase i, exactly the vertices of colors < i are considered “already arrived,” and vertices of colors ≥ i are “not yet arrived.”

In phase i we simulate, in parallel, the t-round online arrival window of every vertex v with φ(v)=i, on the subgraph induced by vertices of colors ≤ i, as follows: (a) we declare all vertices of color i to “arrive” at the beginning of the phase, and (b) we perform t synchronous LOCAL rounds on that induced subgraph. During this phase, the algorithm A is executed faithfully at every vertex, except that vertices of colors > i are absent.

Let R_v denote the active region of v during this phase: R_v = B(v,t) in case (i) and R_v = B(v, W+t) in case (ii). Because φ colors G^{K} with K as above, for any two distinct same-color vertices v,w we have dist(v,w) ≥ K+1, hence dist(R_v, R_w) ≥ 2. In particular, there is no edge between R_v and R_w.

Quiescence and the LOCAL timing imply two key facts within phase i:
1) Only nodes in R := ⋃_{φ(v)=i} R_v may change state during the t rounds of phase i; all nodes outside R keep their state fixed throughout the phase. Since messages sent in a round depend only on the sender’s current state at the start of that round, such outside nodes cannot forward newly received information in subsequent rounds. Consequently, there is no causal influence along any path that leaves one R_v and re-enters another R_w within the t rounds, because such a path must traverse at least one node outside R which cannot propagate new information.
2) Since dist(R_v, R_w) ≥ 2, there is neither an edge nor a length-1 path between distinct active regions.

From 1)–2) it follows that, during phase i, the evolution of each R_v is identical to what would occur if we executed only v’s t-round window in isolation (with all other color-i vertices absent), given the same boundary states on the external neighborhood of R_v (which are precisely the states fixed by earlier colors). Formally, this can be proved by induction on the round counter r=1,…,t, using the domain-of-dependence that is confined to R_v together with outside nodes whose states remain constant.

Therefore, the combined effect of phase i equals the composition of the individual “v-arrival” windows over all vertices v with φ(v)=i, in any internal order. By induction on i, after finishing phase i the global state/output coincides with the online execution that processes first all color-1 vertices (in an arbitrary order), then all color-2 vertices, and so on. Since A is correct for every arrival order, the final labeling after phase C is legal for Π.

The complexity is O(K·log* n) to obtain φ and t rounds per color, i.e., O(t·C) additional rounds. For constant Δ, t, W, we have C = Δ^{O(K)} = O(1), so the total is O(log* n). □

Remark (on the choice of K). The choice K = 2t (resp. 2t+2W) is insufficient for the parallel phase: if dist(v,w)=2t+1 (resp. 2t+2W+1), then R_v and R_w are disjoint but may be adjacent by an edge, allowing one-round coupling between the two active regions. The value K = 2t+1 (resp. 2t+2W+1) guarantees dist(R_v, R_w) ≥ 2, which prevents such coupling and makes the above proof sound.

Remark after Lemma 7 (idle updates depending on step index). In Lemma 7, nodes outside B(u,t) ∪ B(w,t) may perform deterministic updates that depend on the global step counter but not on messages. When two consecutive arrivals at u and w with dist(u,w) > 2t are swapped, those nodes still undergo the same two consecutive step indices in the same order, so their pair of updates is unchanged. This clarifies that Lemma 7 tolerates such idle updates.

=== 2406.19430v2.pdf ===

--- Page 1 ---
Invitation to Local Algorithms
Václav Rozhoň
December 2023
Abstract
This text provides an introduction to the field of distributed local algorithms – an area at the in-
tersection of theoretical computer science and discrete mathematics. We collect many recent results in
the area and demonstrate how they lead to a clean theory. We also discuss many connections of local
algorithms to areas such as parallel, distributed, and sublinear algorithms, or descriptive combinatorics.
Contents
1
Local Complexity Fundamentals
2
1.1
First Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2
1.2
Formal Definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3
1.3
Sequential vs Distributed Local Complexity . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6
1.4
Derandomization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8
1.5
Network Decompositions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
10
1.6
Bounds for Concrete Problems
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
14
1.6.1
Maximal Independent Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
14
2
The Bounded-Degree Regime
15
2.1
The Symmetry-Breaking Regime . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
15
2.1.1
Fast Coloring Algorithm and its Implications . . . . . . . . . . . . . . . . . . . . . . .
16
2.1.2
Lower bound for coloring via round elimination . . . . . . . . . . . . . . . . . . . . . .
18
2.2
The Lovász Local Lemma Regime . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20
2.2.1
Fast Algorithms for the Local Lemma . . . . . . . . . . . . . . . . . . . . . . . . . . .
21
2.2.2
Lower Bound via Round Elimination . . . . . . . . . . . . . . . . . . . . . . . . . . . .
24
2.3
Speedups and Slowdowns
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
27
2.3.1
Slowdowns
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
27
2.3.2
Speedups
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
28
2.4
Classification of Local Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
32
2.4.1
Sequential local complexities
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
33
2.4.2
Classification of Local Problems for Concrete Graph Classes . . . . . . . . . . . . . . .
34
3
Applications
36
3.1
Distributed Computing (CONGEST) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
36
3.2
Local Computation Algorithms and the Volume Model . . . . . . . . . . . . . . . . . . . . . .
37
3.3
PRAM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
38
3.4
Massively Parallel Computing (MPC)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
38
3.5
Descriptive Combinatorics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
39
3.6
Other Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
40
1
arXiv:2406.19430v2  [cs.DC]  21 Nov 2024

--- Page 2 ---
1
Local Complexity Fundamentals
The field of local algorithms is an area on the border of theoretical computer science and discrete mathematics
where a lot of progress has happened in the past decade. This text is trying to serve as an introductory
material presenting a certain view of the field. It aims to be helpful to beginning researchers in the area or
researchers working in adjacent areas.
There are already many resources on various aspects of local algorithms: the classical book of Peleg
[Pel00], survey of Suomela [Suo13], book of Barenboim and Elkin [BE13], lecture notes by Ghaffari, Mohsen
[Gha20], introductory text of Suomela [Suo20], or a recent book by Hirvonen and Suomela [HS20]. Unlike
other texts, this one primarily explores the field’s conceptual framework and complexity-theoretical aspects,
rather than delving into individual problems. If you find errors in the text, please let me know – this is the
first version of it so there will be many! Several researchers generously gave me feedback on a preliminary
version of this text; my thanks go to Anton Bernshteyn, Yi-Jun Chang, Jan Grebík, Yannic Maus, Seth
Pettie, Jukka Suomela, and Goran Zuzic, and especially to Mohsen Ghaffari and Seri Khoury.
In the first section, we introduce local algorithms and local problems in Section 1.1. We then carefully
discuss the appropriate formal definitions in Section 1.2. The following sections Sections 1.3 to 1.5 discuss
the basic theory of local algorithms and aim to convey that we are after a very clean, fundamental, and
robust concept. Finally, Section 1.6 surveys some known results for concrete local problems.
1.1
First Example
Consider a very long oriented cycle that we want to properly color with as few colors as possible (see Figure 1).
Two colors are enough if the number of vertices n is even, otherwise we need three colors. However, there is
something uneasy about the 2-coloring solution even when it is possible – the solution lacks any flexibility.
A decision to color any particular vertex with one of the two colors already implies how all the other vertices
are going to be colored.
This lack of flexibility can be undesirable for all kinds of reasons, typically when we want to design a
coloring algorithm that is in some way parallel or distributed. If we enlarge our palette to three colors, the
problem seems to go away though: Now, coloring one vertex red still implies that its neighbors are not red,
but other vertices can have an arbitrary color.
Imagine that there is a computer in every vertex of the cycle and neighboring computers can communicate.
The computers are trying to solve the coloring problem together. How many rounds of communication are
needed until each computer outputs its color? A message-passing algorithm of this sort is known as a local
algorithm and we define it formally in Section 1.2.
It is possible to convince oneself that in the case of the 2-coloring problem, at least around n{4 rounds
are necessary to solve it, even if n is divisible by two.1 But what about the 3-coloring scenario? Can we
solve that problem in 10 rounds of communication? Or Oplog nq? Or is it similarly hard to 2-coloring?
There indeed is a simple randomized local algorithm that solves our 3-coloring problem after Oplog nq
rounds of exchanging messages. Let’s describe it next. The algorithm should serve as an example that
nontrivial local algorithms are indeed possible, though we will later see a better algorithm for the coloring
problem.
The 3-coloring algorithm has two phases. In the first phase, every computer flips a coin and selects itself
with probability 1/2 (top picture in Figure 1). Subsequently, the vertex asks its neighbors whether they are
also selected. If at least one neighbor is selected, the vertex unselects itself (middle picture in Figure 1).
In the second phase of the algorithm, every selected vertex first colors itself red. Then, it is responsible for
coloring the yet uncolored vertices until the next red vertex. The red node sends a message in the direction
of edges, asking the subsequent vertices to color themselves by alternating the two remaining colors (see the
bottom picture in Figure 1). This algorithm properly colors the oriented cycle with 3 colors and the number
of communication rounds that it needs is asymptotically at most as large as the length of the longest run of
non-red vertices in our coloring.
1Consider two opposing nodes u, v in the cycle graph: In less than n{4 rounds of communication, there is no third node that
could send a message to both u and v. Intuitively, the two vertices then cannot know whether their distance is even or odd.
This argument can be made into a rigorous lower bound after the model of local algorithms is properly defined in Section 1.2.
2

--- Page 3 ---
Random selection
Unselect if you have neighbors
Fill in the gap to the next selected node
Figure 1: An example local algorithm that uses three colors to color a long cycle, a small part of which is shown.
First, every vertex flips a coin and selects itself with probability 1{2. Second, a vertex unselects itself whenever a
neighbor is selected. Third, selected vertices color themselves red and each selected vertex is then responsible for
coloring the subsequent vertices until the next selected one with alternating colors.
To understand this quantity, consider any run of ℓconsecutive nodes and let us upper bound the proba-
bility that the run does not contain any red node. This is done by splitting the run into consecutive triples
of vertices. For every triple, we know that with probability 1{8, its middle node is initially selected, while its
two neighbors are not. The selected middle node then remains selected after the end of the first phase and is
colored red. Making this argument for every triple and using that the appropriate events are independent,
we conclude that the probability of no red node in the run is at most p7{8qtℓ{3u. Taking ℓ“ Oplog nq and
union bounding over all n different runs of vertices of length ℓ, we conclude that all of them contain at least
one red node with 1 ´ 1{ polypnq probability. We will call this guarantee “with high probability” later on.
That is, our algorithm finishes after Oplog nq communication rounds, with high probability.
Surprisingly, the fastest local algorithm for the 3-coloring problem has a much better, albeit not constant
complexity of Oplog˚ nq.2 However, instead of focusing on specific algorithms, this text is trying to give a
bit more general understanding of what is going on here. For example, it turns out that if we come up with
any local algorithm with complexity Oplog nq for any reasonable problem defined on the cycle as we just did,
there is a general theory that can turn this algorithm into a faster, Oplog˚ nq-round, algorithm for the very
same problem (see Theorem 2.30). Clearly, something interesting is going on here!
1.2
Formal Definitions
In this section, we formally define local problems and algorithms.
Local problems: We will be mostly interested in the so-called local problems. Informally speaking, these
are the problems on graphs such that if the solution is incorrect, we can find out by looking at a small
neighborhood of one vertex.
Given a graph G and its node u P V pGq, the ball BGpu, rq3 around u of radius r is the subgraph of nodes
around u up to distance r. More generally, an r-hop neighborhood is a graph with one highlighted node v
such that the radius of that graph measured from v is at most r.
Definition 1.1 (A local problem). Local problem4 Π with checkability radius r is formally a triplet pS, r, Pq.
Here, S is a finite set of allowed labels and each P is a set of allowed S-colored r-hop neighborhoods. A
solution to Π in a graph G is an assignment of color from S to every vertex of G such that for every u P V pGq
we have BGpu, rq P P.
2The function log˚ n measures how many times we need to take the logarithm of n until we get a value of size at most 2,
i.e., log˚ 22 “ 1, log˚ 222 “ 2 and so on.
3We write Bpu, rq when G is clear from the context.
4Our definition is a simplified variant of the definition of the so-called locally checkable labeling problem by Naor and
Stockmeyer [NS95], discussed later in Section 2.4.2.
3

--- Page 4 ---
42
69
73
47
3
42
77
43
12
3
...
Function from local neighborhoods to output labels
Message-passing distributed algorithm
42
77
43
8
42
77
43
12
3
8
Figure 2: This picture shows the two fundamentally different ways of understanding local algorithms.
Left: A tpnq-round local algorithm can be seen as a distributed protocol where in each round, each node can send
any message to any of its neighbors. The computers start with the knowledge of their unique identifier (or a random
string).
Right: A local algorithm with round complexity tpnq can be seen as a function that maps each possible tpnq-hop
neighborhood to an output label. Applying this function to every vertex of the input graph always has to solve our
problem: For example, if our problem is a coloring problem, the first two local neighborhoods in the above table need
to map the two vertices with labels 77 and 43 to different colors, since the two labeled 2-hop neighborhoods could be
a part of the same graph (which is, in fact, shown on the left).
For example, 3-coloring is a local problem for S “ tR, G, Bu, r “ 1, and P containing all properly colored
1-hop neighborhoods. On the other hand, a non-example of a local problem is coloring an input graph
on n vertices with n colors: the local problem should not have different constraints for graphs of different
sizes. Of course, while the theory of local algorithms is simplest for local problems as we defined them, the
applications of local algorithms are not limited to local problems.
Local algorithms: There are two equivalent ways of thinking about local algorithms5 and both of them
are important (see Figure 2). An intuitive, algorithmic definition was already sketched in Section 1.1: We
assume that there is a computing device at every node. For simplicity, these devices are assumed to have
unbounded computational power, thus excluding Turing machines from the definitions. A tpnq-round local
algorithm is a protocol where these devices communicate for tpnq synchronous message-passing rounds using
the edges of the input graph to send messages. At the beginning, the device in each node starts only with
the information about its identifier/random string and the size of the graph, n. When the protocol finishes,
each device outputs its part of the solution (e.g., its color).
It will also be helpful to understand an alternative and equivalent definition that extracts the essence of
what we are measuring with local algorithms. In this alternative definition, a local algorithm with round
complexity tpnq is simply a function that we can apply to every ball Bpu, tpnqq of the input graph to compute
the output at a given node u. Let us state it formally.
Definition 1.2 (Local algorithm). A local algorithm A with a round complexity of tpnq is a function that
accepts two inputs: firstly, the value n, and secondly, a labeled tpnq-hop neighborhood.
5In the literature, these algorithms are often referred to as “distributed algorithms in the LOCAL model of computing”. We
use the shorter and less formal term “local algorithm” for better readability.
4

--- Page 5 ---
When we use this second definition, running a local algorithm on an input graph G simply means
coloring each node u P V pGq with the output of AnpBGpu, tpnqqq where we used the first parameter of a local
algorithm, the size of the underlying graph n “ |V pGq|, as a subscript. Solving a problem Π on G simply
means that after running An on G, the output colors satisfy constraints P on all vertices of G.
Moreover, in the case of deterministic local algorithms, we assume that the nodes of the input graph
are additionally labeled with unique identifiers from the range rnOp1qs “ t1, 2, . . . , nOp1qu.6 In the case of
randomized local algorithms, we assume that the nodes of the input graph are labeled with infinite bit
strings. Solving a problem then means solving it with overall error probability at most 1{nOp1q, if the bit
strings are sampled independently randomly.7
We notice that if there is a deterministic local algorithm solving some problem with round complexity
tpnq, there is also a randomized local algorithm solving the same problem with the same round complexity.
This is because any randomized algorithm can start by each node generating a random identifier from
the range rnCs: The probability that these identifiers are not unique, i.e., some two nodes have the same
identifier, is at most n2 ¨
1
nC . Choosing C large enough, this error probability can be made as small as any
polynomial function of n.
Finally, we remark that we can talk about local algorithms solving problems on graphs with additional
structure (e.g. directed graphs) or on concrete graph classes. For example, in our introductory example from
Section 1.1, it makes sense to think of all definitions relative not to the class of all graphs but to the class
of graphs that are oriented paths. One interesting setup that we discuss mostly in Section 2 is the class of
bounded-degree graphs where we fix some constant ∆and analyze the class of graphs of degree at most ∆.
Notice that on these graphs, the set P from the definition of local problems, as well as the support of the
function A from the definition of local algorithms, are finite.
Equivalence of the two definitions: Let’s see a proof sketch of why the two definitions are equivalent.
On the one hand, let’s say we are given a function A that maps tpnq-hop neighborhoods to output labels and
we want to construct a tpnq-round message-passing protocol. Consider the protocol where in the i-th round,
each vertex u sends its neighbors everything there is to know about the ball Bpu, iq: How the graph looks
like and the values of identifiers/random strings at every node of Bpu, iq. Each node v can then internally
use this information from its neighbors to learn everything there is to know about the ball Bpu, i ` 1q. After
tpnq rounds of communication, each vertex v thus knows its whole tpnq-hop neighborhood Bpv, tpnqq. At this
point, the vertices stop communicating and each one applies the function A locally to its ball which solves
the problem solved by A.
On the other hand, assume that we have a tpnq-round communication protocol and want to turn it into a
function A that takes tpnq-hop neighborhood as inputs. We notice that if we know the tpnq-hop neighborhood
Bpu, tpnqq of a node u, we can simulate the first round of the protocol in that ball and get to know the state
of all vertices in Bpu, tpnq ´ 1q after the first round. Continuing like this inductively, we conclude that
starting with the knowledge of Bpu, tpnqq, we can learn the state of the protocol at the center node u after
tpnq rounds.
There are two different but equivalent ways of understanding local algorithms.
1. They are message-passing protocols running for some number of rounds.
2. The output at each node is a function of its local neighborhood.
Importantly, it will be very helpful for us to keep both definitions in mind: When we design local
algorithms, the message-passing definition is more helpful as it is natural to think as “first, we run the
protocol A1, then the protocol A2”. On the other hand, when we prove lower bounds, the formal definition of
Definition 1.2 is easier to use. When we think of applications to distributed/parallel algorithms, the protocol-
design definition is preferable since this is how the actual parallel/distributed algorithms are implemented.
6While assuming polynomial-range identifiers may look a bit arbitrary, we will see in Section 2 that the notion of deterministic
algorithms is very robust. We simply need a way of breaking the potential symmetry of the input graph – think of what happens
when you run a local algorithm on a vertex-transitive graph such as a cycle without any identifiers or randomness!
7Formally-minded readers may feel uneasy about the definitions not specifying the constant in the nOp1q expressions. We
will see later in Theorem 2.20 that the exact constant in the definition typically does not matter. Formally, when we say that
there is a local algorithm, it means that for every C there is an algorithm in the setup where we require the size of identifiers
to be at most nC (or the error probability to be at most 1{nC).
5

--- Page 6 ---
In some other applications, like applications to descriptive combinatorics, the formal definition is perhaps a
bit more natural.
1.3
Sequential vs Distributed Local Complexity
This section presents one of the most fundamental results in the area of local algorithms. Currently, it may be
very unclear what kind of problems can be solved with a local algorithm of round complexity, say, poly log n.
This will become much clearer, since we will next see that, up to poly log n, the model of local algorithms is
the same as the model of so-called sequential local algorithms that are much easier to understand.
The case of maximal independent set: As an example, let’s think of a concrete local problem known
as the maximal independent set problem. In this problem, every node must be labeled either selected or
unselected. The constraint is that each selected node should not neighbor any other selected node,
while each unselected node should neighbor at least one selected node8.
Is there a local algorithm constructing a maximal independent set in a polylogarithmic number of rounds?
This is not clear at all! The answer to this question is positive, and perhaps the simplest algorithm is the
randomized algorithm of Luby [Lub86; ABI86]. This algorithm in fact served as the foundational example
that later led Linial [Lin92] to define local algorithms. But Luby’s algorithm is a non-trivial algorithm9 and
just by staring at the maximal independent set problem, it is quite unclear whether a fast local algorithm
exists, or not.
This stands in stark contrast with the “sequential” world: If we do not care about all vertices outputting
the answer “at once”, we can compute a maximal independent set with the following simple algorithm: We
choose any order of vertices and iterate over them in that order. Whenever we consider a vertex u, we look
at its neighbors, and if at least one of them is already selected, we mark u as unselected. Otherwise, we
mark u as selected.
Here is a curious property of the above algorithm: We can still think of it as a “local” algorithm. Indeed,
each node makes its decision by examining its 1-hop neighborhood. The only difference is that the algorithm
is a sequential local algorithm where we iterate over nodes in an arbitrary order, not a distributed local
algorithm10 as we defined it in Definition 1.2 where all nodes have to output their answer at once.
A fundamental result of local complexity is the fact that these two definitions are equally powerful, up
to polylogarithmic factors. Hence, in the concrete example of the maximal independent set, we can think of
this problem as being “easy” not because of a clever algorithm like Luby’s, but because of the above simple
sequential algorithm.
The distributed round complexity of any local problem equals its sequential local complexity,
up to poly logpnq.
Formal definition of sequential local algorithms: We next make this principle formal. We need to
start by defining a general sequential local algorithm. Here is a definition of a deterministic sequential local
algorithm, made slightly more powerful than the maximal-independent-set algorithm by allowing the output
of each node to be not just the final color, but the node can also keep additional information that future
vertices can read from that node.
Definition 1.3 (Sequential local algorithms). A sequential local algorithm of local complexity tpnq is a
function A that takes two inputs, n and a labeled tpnq-hop neighborhood.
Its output for a neighborhood
Bpu, tpnqq around a node u is a pair ps, tq, with s being the output at u and t being additional information
stored at u. An input neighborhood to A has some nodes labeled by these pairs.
8This is a much easier problem than the maximum independent set problem where we additionally maximize the number
of selected nodes.
9We can briefly describe the algorithm: It runs in Oplog nq rounds and in each round, every vertex chooses a random number
from r0, 1s. If its number is the largest among its neighbors, the vertex goes in the independent set and is removed from future
iterations, together with its neighbors. After Oplog nq rounds, all vertices are removed with high probability and the algorithm
terminates.
10We sometimes use the name distributed local algorithm to stress that we are talking about a local algorithm and not a
sequential local one.
6

--- Page 7 ---
Running a sequential local algorithm on a graph means iterating over its vertices in some order and each
time applying A to produce the answer at the particular vertex. When we run A on a node v, the algorithm
has access to all already produced pairs ps, tq at the vertices in Bpu, tpnqq on which A has already been run.
Solving a problem with a sequential local algorithm means that regardless of the order in which we choose
the vertices, this process results in a solution to the problem.
Notice that we do not require unique identifiers in the definition; we will see later in Theorem 2.7 that
they are not needed for local problems. We can also define (oblivious) randomized algorithms where first an
adversary chooses an order in which we iterate over vertices; then we sample random bits in each vertex and
run our sequential local algorithm.
We will next prove the following theorem by Ghaffari, Kuhn, and Maus [GKM17].
Theorem 1.4 (Ghaffari, Kuhn, and Maus [GKM17]). Let A be a deterministic (randomized) sequential local
algorithm with local complexity tpnq. Then, there is a deterministic (or randomized, respectively) distributed
local algorithm simulating A with round complexity tpnq ¨ rOplog3pnqq.11
We note that it is known that there are local problems such that their sequential and distributed local
complexity differ by a factor of Ωplog n{ log log nq. [Gav+09]
Network decompositions: A crucial tool that we will rely on in this section and the next one is the
concept of a network decomposition. Network decomposition is a clustering of the input graph into clusters
of small diameter12 (see Figure 3).
Definition 1.5 (Network decomposition). A pc, dq-network decomposition of a graph G is a coloring of G
with c colors. We require that vertices of each color induce a graph such that each of its connected components
(that we call clusters) has diameter at most d.
We defer the discussion about the existence of network decompositions to Section 1.5. For now, we will
simply state the guarantees of the currently best deterministic network decomposition construction.
Theorem 1.6 ([GG24]). There is a deterministic local algorithm that outputs a (Oplog nq, Oplog nq)-network
decomposition in rOplog2 nq rounds.
Proof of Theorem 1.4: Armed with the algorithm for network decomposition, from Theorem 1.6, let us
prove Theorem 1.4.
Proof of Theorem 1.4. An important concept employed throughout this text is working within the power
graph: Given a graph G and a parameter r, we define the power graph Gr to be the graph with V pGrq “ V pGq
where two vertices are connected whenever their distance in Gr is at most r.
We start with a sequential local algorithm A of complexity tpnq.
We will work in the power graph
Gtpnq and construct a network decomposition in it with c “ Oplog nq colors and diameter d1 “ rOplog nq in
Gtpnq via Theorem 1.6. Consider this network decomposition in the context of the original graph G: We
constructed clusters of actual diameter d ď tpnq ¨ d1 “ tpnq ¨ rOplog nq in G. Moreover, two clusters from the
same color class have distance at least tpnq ` 1 in G. Finally, since every communication round in Gr can be
simulated in r communication rounds in G, the round complexity of constructing our network decomposition
is tpnq ¨ rOplog3 nq by Theorem 1.6.
We will now use our clustering to simulate A. We will simulate an order of iterating over the vertices
where we first iterate over all the vertices in the first color class, then all the vertices in the second color
class, and so on. For a fixed color class, we will arbitrarily simulate the algorithm A in each cluster C
independently of all other clusters of the same color (see Figure 3).
Notice that every two clusters C1, C2 of the same color i are far enough so that the tpnq-hop neighborhood
of any vertex u P C1 never contains a vertex u1 P C2. Hence, simulations in different clusters of the i-th color
do not interact and our simulation is a faithful simulation of iterating over all the vertices of G in a certain
order and applying the sequential algorithm A to them.
11We use rOptpnqq to denote the complexity Optpnq ¨ logOp1q tpnqq.
12A diameter of a graph G is defined as maxu,v dGpu, vq where dGpu, vq is the distance between u and v in G.
7

--- Page 8 ---
1.
2.
11.
12.
1.
13.
4.
7.
2.
5.
14.
8.
9.
15.
3.
6.
1.
2.
1.
1.
1.
1.
2.
2.
2.
2.
3.
3.
3.
3.
4.
10.
Figure 3: This picture shows a network decomposition with c “ 2 color classes and d “ 2 diameter. It also shows how
network decomposition is used to convert an input sequential local algorithm (of local complexity 1) into a distributed
local algorithm in Theorem 1.4.
Left: The color classes of the network decompositions are ordered as (red, blue). We iterate over the color classes
and in one iteration, we consider each cluster separately and simulate an input sequential local algorithm in it (see
the node ordering inside each cluster). When the algorithm is simulated in blue clusters, it has access to the output
of neighboring red vertices.
Right: The partial simulations of the sequential local algorithm in each cluster are consistent with a single run of
that algorithm over all vertices.
Finally, let us discuss how the simulation of A is implemented with a local algorithm. Our local algorithm
simulating A is a message-passing protocol with c phases where in the i-th phase, each cluster C of color
i first chooses a leader node, e.g., the node with the smallest identifier. This node collects all information
about the output of A so far up to the distance tpnq from C. Then, the leader node internally simulates A
on C and sends the result of that simulation back to all nodes in C. All this can be done in a number of
rounds proportional to the diameter of C and tpnq. Thus, the overall round complexity of the simulation is
c ¨ tpnq ¨ rOplog nq “ tpnq ¨ rOplog2 nq.
1.4
Derandomization
By now, we understand that the sequential local complexity is closely related to the distributed round
complexity. However, we still do not understand the power of randomness. There might be scenarios where a
problem’s randomized (sequential or distributed) local complexity is significantly lower than its deterministic
(sequential or distributed) complexity. Interestingly, this never happens for local problems. Distributed local
algorithms for them can be derandomized with poly logpnq slowdown in round complexity.13
Any local problem has the same deterministic and randomized round complexity,
up to poly logpnq.
Before proving this result, let us contemplate how it fits into the big picture. Thus far, we have seen
six plausible definitions of how to measure the local complexity of a problem. There are the following three
different ways of thinking about it, and for each one of them, we can define both the deterministic and the
randomized complexity:
1. (distributed protocol) There are computers at nodes, we design a message-passing protocol, and we
measure the number of rounds of this protocol.
2. (distributed local complexity) Output at each node is a function of its local neighborhood.
3. (sequential local complexity) We iterate over the nodes in an arbitrary order and settle each output at
a node by looking at its local neighborhood.
13It is important to restrict ourselves to local problems. Otherwise, consider the following silly counterexample problem: We
are to mark some vertices of the input graph so that at least n{3 but at most 2n{3 vertices are marked. Using randomness,
this problem can be solved in 0 round complexity: every vertex simply flips a coin. But imagine trying to solve the problem
deterministically: If the input graph has no edges, we are pretty screwed!
8

--- Page 9 ---
We now understand that all of these definitions are equivalent, up to poly logpnq and for local problems.
Formal statement of derandomization: Formally, we will prove the following statement by Ghaffari,
Harris, and Kuhn [GHK18], using the derandomization method of conditional expectations.
Theorem 1.7 (Ghaffari, Harris, and Kuhn [GHK18]). Let Π be any local problem of randomized round
complexity tpnq. Then, its deterministic sequential local complexity is Optpnqq.
Proof. We are given a randomized local algorithm A with round complexity tpnq for a local problem Π “
pS, Pq with checkability radius r. We will next describe a deterministic sequential local algorithm that writes
an infinite sequence of bits into each node u of the input graph G so that if we then simulate A with these
bits, it solves Π.
For a vertex u P V pGq, define the failure indicator Xpuq as the indicator random variable for the event
that if we run A with random bits, it fails at u at solving the local problem Π “ pS, Pq. By failure at u we
mean that Bpu, rq R P. We notice that Xpuq depends only on the output of A at an r-hop neighborhood of
u, and thus it ultimately depends only on random bits in the pr ` tpnqq-hop neighborhood of u. Moreover,
the probability of failure at u is less than 1{n by A being a randomized algorithm solving Π. This implies
that E
”ř
uPV pGq Xpuq
ı
ă 1.
Next, we will consider the following sequential local algorithm. We iterate over the nodes in an arbitrary
order, and whenever it is a node uk’s turn, we fix the random bits Bpukq at this node to a value bpukq such
that
E
»
–
ÿ
vPV pGq
Xpvq
ˇˇˇ @i P rks : Bpuiq “ bi
fi
fl
ď E
»
–
ÿ
vPV pGq
Xpvq
ˇˇˇ @i P rk ´ 1s : Bpuiq “ bi
fi
fl .
In words, we set the random bits so that the expected number of errors does not increase.
First, such a value bpukq of random bits at uk definitely exists, since the right-hand side of the above
inequality simply averages over many possible instantiations of Bpukq (that is, we rely on the law of total
expectation).
Second, we can compute this value of random bits by looking only at the pr ` tpnqq-hop
neighborhood of uk, since the values Xv for v outside of Bpuk, r ` tpnqq are independent of the choice of
random bits at uk.
After this sequential algorithm with local complexity pr ` tpnqq finishes, we have set the random bits at
every vertex u P V pGq in a way that makes
E
»
–
ÿ
uPV pGq
Xpuq
ˇˇˇ @i P rns : Bpuiq “ bi
fi
fl ă 1.
But all values Xpuq are now deterministic, so we conclude that no failure occurs if we run A with these bits.
Finally, after this derandomization procedure is run, we also have to run A. We will defer the discussion
of how to combine two sequential local algorithms into one to Lemma 1.9. This lemma implies that there
exists a single sequential local algorithm with local complexity Optpnqq that simulates first running the
derandomization procedure and then running A with the bits computed by that procedure.
Putting Theorems 1.4 and 1.8 together, we get the following derandomization theorem for (distributed)
local algorithms.
Theorem 1.8 (Ghaffari, Harris, and Kuhn [GHK18]). Let Π be any local problem of checkability r and
randomized round complexity tpnq. Then, its deterministic round complexity is tpnq ¨ rOplog3 nq.
Conversely, it’s known that for some local problems, the gap between randomized and deterministic local
complexity can be as large as Ωplog n{ log log nq [Bal+20c].
Leftover: composing sequential algorithms: We will briefly discuss how two sequential local algorithms
run one after the other can be composed into a single one of larger local complexity.
9

--- Page 10 ---
Lemma 1.9 (Ghaffari, Kuhn, and Maus [GKM17, Observation 2.1, Lemma 2.2]). Let A1, A2 be two deter-
ministic (randomized) sequential local algorithms with local complexities t1pnq, t2pnq. Then, there is a single
deterministic (randomized, respectively) sequential local algorithm A of complexity 2pt1pnq ` t2pnqq14 that
simulates the output of first running A1, and then running A2 on the output of A1.
Proof. We would like A to work as follows: We iterate over the nodes and when it is the turn of a node u,
we first simulate A1 for all nodes in Bpu, t2pnqq. Then, we use the computed information to simulate A2 at
u to compute the final output at u.
The only difficulty is that once u simulates A1 for a node v P Bpu, t2pnqq, we cannot simulate A1 at v
again in the future since we want to have the guarantee that all simulations of A1 taken together correspond
to a consistent iteration over the nodes of the input graph and running A1 on them.
Thus, our algorithm A will additionally store at u the output of simulations of A1 within Bpu, t2pnqq.
When it is the turn of a vertex u, A starts by looking at its 2t2pnq-hop neighborhood and fixing the answers
of A1 for nodes v P Bpu, t2pnqq at which A1 was already simulated in the past. Only then we simulate
A1 for the rest of the nodes in Bpu, t2pnqq and run A2 after that.
The final local complexity of A is
max pt1pnq ` t2pnq, 2t2pnqq.
1.5
Network Decompositions
Let us recall the definition of a network decomposition:
Definition 1.5 (Network decomposition). A pc, dq-network decomposition of a graph G is a coloring of G
with c colors. We require that vertices of each color induce a graph such that each of its connected components
(that we call clusters) has diameter at most d.
We will next discuss constructions of network decompositions15: the missing piece in proof of Theo-
rems 1.4 and 1.8.
Existence of network decompositions: First of all, it is unclear whether network decomposition of the
input graph, say with parameters c, d “ Oplog nq always exists. Let’s confirm this by constructing it using
the folklore sequential ball-carving algorithm.
Theorem 1.10 (Ball-carving algorithm). An pOplog nq, Oplog nqq-network decomposition exists for any
graph G.
Proof. We will show how to construct the first color class of the network decomposition. In particular, we
will find a family of vertex-sets C “ tC1, C2, . . . , Ctu, where we call each Ci Ď V pGq a cluster, such that:
1. The clusters are not adjacent; i.e., there is no edge uv P EpGq with u P Ci, v P Cj, i ­“ j,
2. each cluster Ci has diameter Oplog nq,
3. at least n{2 vertices are clustered, i.e.,
ˇˇˇŤt
i“1 Ci
ˇˇˇ ě n{2.
To construct the clustering C, we iterate over the vertices of G in an arbitrary order. Each time we are
at a vertex u, we consider the balls Bpu, 0q, Bpu, 1q, . . . of increasing radii around it. In particular, think of
gradually growing larger and larger balls around u, and once the size of the ball does not at least double, i.e.,
once we have |Bpu, i`1q| ď 2¨|Bpu, iq| for the first time, we let Bpu, iq be the next cluster of C. Additionally,
we remove all vertices from the boundary Bpu, i ` 1qzBpu, iq from G. After the ball around u is grown, we
continue this procedure with an arbitrary next vertex of G that was not explored yet.
To analyze this algorithm, first notice that no two clusters are adjacent (Item 1), since after growing each
cluster, we delete its boundary.
Moreover, we claim that all balls have diameter Oplog nq (Item 2). To see this, note that the volume of
each ball Bpu, iq grows as |Bpu, iq| ě 2i until we finish growing. This implies that if we are not finished in
iteration 1 ` log2 n, the ball Bpu, 1 ` log2 nq has to contain more than n vertices, a contradiction.
14In general, k local sequential algorithms can be simulated with complexity 2 řk
i“1 tipnq.
15In the literature, one can very often encounter numerous variants of network decompositions with names like low-diameter
clusterings, padded decompositions, or sparse neighborhood covers.
10

--- Page 11 ---
Finally, we cluster at least half of the vertices (Item 3), because by definition, whenever a ball stops
growing, we have |Bpu, i ` 1qzBpu, iq| ď |Bpu, iq|, so the number of vertices unclustered because of the ball
around u can be charged to the number of vertices clustered around u.
We construct the desired network decomposition by simply repeating the above process log2 n times:
The clustered vertices in the i-th step are removed from the graph and form the i-th color class of the final
decomposition. After log2 n rounds, every vertex gets clustered.
Deterministic distributed algorithms: There is a long line of work on deterministic algorithms for
constructing network decompositions [Awe+89; PS92; RG20; GGR21; CG21; Roz+22a; RHG23; Gha+23;
GG24]. The currently fastest deterministic algorithm for network decomposition is the algorithm by Ghaffari
and Grunau [GG24]. We stated its guarantees in Theorem 1.6.
Perhaps the simplest poly log n-round algorithm is the algorithm of Rozhoň and Ghaffari [RG20] and
its variant by Rozhoň, Haeupler, and Grunau [RHG23]. They both need Oplog7 nq rounds and construct
clusters with diameter Oplog3 nq. We will next explain the construction from [RG20] that in fact outputs
clusters that only have a weaker guarantee of small weak-diameter. A weak-diameter of a cluster C is defined
as maxu,vPC dGpu, vq, as opposed to the (strong-) diameter which is defined as maxu,vPC dGrCspu, vq. That
is, a cluster with a small weak diameter can be even disconnected, we only require that its vertices are close
in the underlying graph G. A small weak-diameter is sufficient for our applications such as the proof of
Theorem 1.4 and we will discuss at the end of this section how one can convert the weak-diameter guarantee
to the strong-diameter one in a black-box way.
Theorem 1.11 (Distributed ball-carving algorithm). There is a local algorithm with round complexity
Oplog7 nq that constructs a network decomposition with c “ Oplog nq colors and d “ Oplog3 nq weak-diameter.
Proof. Similarly to Theorem 1.10, we show how to construct a family of clusters C “ tC1, C2, . . . , Ctu such
that:
1. No two clusters are adjacent,
2. each cluster Ci has weak-diameter Oplog3 nq,
3. at least n{2 vertices are clustered.
Recall that in deterministic local algorithms, every vertex starts with a unique b “ Oplog nq-bit identifier.
Our algorithm has b phases. At the beginning of the algorithm, we start with a clustering C0 that contains
each node of G as a trivial one-vertex cluster. Each cluster C in our clustering is assigned a unique identifier
idpCq – in particular, the identifier of a cluster is set to be the identifier of its unique vertex.
The clustering Ci evolves during the following b phases, with some vertices changing which cluster they
belong to and some vertices being deleted from Ci. We will prove that after each phase i P rbs, the clustering
Ci has the following guarantees:
1. Consider the graph Gi “ GrŤ
CPCi Cs, i.e., the graph induced by vertices that were not deleted yet.
Consider any connected component K of Gi. All clusters present in K have the same first i bits in
their unique identifier.
2. Each cluster C P Ci has weak-diameter i ¨ Oplog2 nq.
3. |V pGiq| ě n ´ i ¨ n
2b.
Plugging i “ b, the inductive guarantees of Items 1 to 3 reduce to the final desired guarantees of Items 1
to 3 from the beginning of the proof. Thus, we only need to show how one phase of the algorithm makes
sure that if we start with the guarantees for some i, they also hold for i ` 1.
At the beginning of each phase i`1 P rbs, we classify each cluster in Ci as either active or inactive, where
a cluster C is active if and only if the pi ` 1q-th bit in idpCq is equal to zero.
Next, we run a variant of the ball-carving algorithm from Theorem 1.7 with t “ 10b log2 n steps. In
each step of this algorithm, each vertex u from some inactive cluster first checks whether it neighbors with
11

--- Page 12 ---
0001
0111
0101
1011
1001
1101
1111
1110
1100
Figure 4: This picture illustrates the second phase of the algorithm from Theorem 1.11, in a simple example graph.
Left: At the beginning of the second phase, the clusters are already separated according to their first bit. In particular,
if the identifier starts with 1, the cluster is in the top connected component, while if the identifier starts with 0, the
corresponding cluster is in one of the two bottom connected components. In the second phase, a cluster is active
(blue) if its second bit in the identifier is 0, and inactive (red) otherwise. In the first step of this phase, each red
vertex proposes to join an arbitrary neighboring blue cluster, provided that there is one (the arrows in the picture).
The active cluster then either decides to grow (cluster 1001) or the vertices that proposed to it are deleted (cluster
1011). Note that if a cluster decides to delete its boundary, it does not neighbor any red nodes from that point on.
Middle: After one step of our algorithm, the inactive cluster with identifier 1111 became disconnected but its weak-
diameter remains the same as at the beginning of the phase. In the second step of this phase, each red vertex again
proposes to join an arbitrary neighboring blue cluster.
Right: The picture shows the resulting clustering after the second phase is finished. Note that the only two adjacent
clusters with identifiers 1011 and 1001 will be separated in the following, third, phase, as their identifiers differ on
the third position.
12

--- Page 13 ---
a vertex that is currently present in an active cluster. If there are more such neighboring vertices, u chooses
an arbitrary such vertex in C and then u proposes to join C.
Next, each cluster C collects how many vertices proposed to join C. If there are at least |C|{p2bq such
vertices, then C decides to grow: All the vertices that proposed to join C leave their original cluster and join
C. On the other hand, if less than |C|{p2bq proposed to join C, all these vertices are deleted; they will not be
present in Ci`1 and they will not participate in the rest of the algorithm. Note that after an active cluster
C decides to delete the proposing vertices, it is neighboring only with nodes from other active clusters and
thus it does not grow anymore in the rest of the phase. This finishes the description of one phase of the
algorithm (see Figure 4 for an illustration).
To analyze the phase, we first check that each cluster stops growing during the phase.
This is true
because otherwise, at the end of the phase, the cluster would have to contain more than
p1 ` 1{p2bqq10b log2 n ą n
nodes. In particular, the weak-diameter of each active cluster grows additively by at most 2 ¨ 10b log2 n “
Oplog2 nq, while the weak-diameter of each inactive cluster does not increase. This proves Item 2.
Next, consider any connected component K of Gi. The clusters in K already agree on the first i bits of
their identifier at the beginning of the phase i`1 by our inductive assumption. Recall that all active clusters
stop growing during the phase and delete the inactive nodes on their boundary; in particular no active and
inactive cluster neighbor at the end of the algorithm. Therefore, in Gi`1 the component K further splits into
connected components K1, K2, . . . such that for each component Ki we have that either all of its clusters
are active or all are inactive. We conclude that clusters in each connected component of Gi`1 agree on the
first i ` 1 bits in their identifier as needed in Item 1.
Finally, whenever a cluster C stops growing, we delete at most |C|{p2bq nodes. Thus, during the phase,
we delete at most n{p2bq nodes which proves Item 3.
Let us discuss the round complexity of the algorithm. The clusters have weak-diameter Oplog3 nq. Hence,
each growing step can be implemented with that round complexity. There are t “ Oplog2 nq steps in one
phase, b “ Oplog nq phases, and we need to repeat the overall algorithm c “ log2 n times. We conclude that
the overall round complexity is Oplog7 nq.
Next, let us show how we can use our current knowledge of local algorithms to construct a local algorithm
for network decomposition with c, d “ Oplog nq.
Corollary 1.12. There is a local algorithm with Oplog9 nq round complexity that constructs a network
decomposition with c “ Oplog nq colors and d “ Oplog nq diameter.
Proof. We observe that the algorithm from Theorem 1.10 can be seen as a sequence of Oplog nq sequential
local algorithms per Definition 1.3, each one with local complexity Oplog nq. Using Lemma 1.9, we can thus
view it as a single sequential local algorithm of local complexity Oplog2 nq.
Thus, we can use Theorem 1.4 to convert this algorithm into a local algorithm.
While we phrased
the guarantees of Theorem 1.4 using the best available network decomposition algorithm, we can plug
in the network decomposition from Theorem 1.11 instead; the reduction holds even if we use a network
decomposition with a weak-diameter guarantee.
Let us briefly go back to the observation from the proof of Corollary 1.12 that the algorithm from
Theorem 1.10 can be viewed as a sequential local algorithm. This observation helps us to appreciate network
decomposition as the “complete” problem for turning sequential local algorithms into distributed ones: On
the one hand, network decomposition allows us to do this task via Theorem 1.4; on the other hand, any
way of proving that theorem leads to a distributed algorithm for network decomposition via the proof of
Corollary 1.12.
Randomized distributed algorithms: There is a classic randomized algorithm by Linial and Saks [LS93]
that constructs an pOplog nq, Oplog nqq-network decomposition in Oplog2 nq distributed rounds. Let us sketch
its beautiful variant by Miller, Peng, and Xu [MPX13] also known as the MPX algorithm:
In their algorithm, every vertex independently chooses a random head start sampled from an exponential
distribution; that is, a head start of each node is 0 with probability 1{2, 1 with probability 1{4, and so
on. Next, we run the breadth-first-search algorithm from all nodes at once with those head starts. That is,
13

--- Page 14 ---
we first choose some number T “ Oplog nq such that with high probability, no node samples a head start
larger than T. Then, we simulate a run of breadth-first search from an additional virtual node u0 which is
connected to every other node u with an oriented edge of length T ´ head startpuq. All vertices reached by
the breadth-first search from the same starting node u form one cluster. The output of the algorithm are
only those vertices such that all their neighbors are from the same cluster.
One can prove that the output clustering from this algorithm contains at least a constant fraction of
all vertices and uses disjoint clusters of diameter Oplog nq, with high probability. We repeat this process
c “ Oplog nq times to construct a network decomposition.
1.6
Bounds for Concrete Problems
This survey emphasizes the general properties of local algorithms, but it is crucial to remember that their
study is rooted in understanding specific local problems. One of the most significant problems that has
driven much of the development in this field is the maximal independent set problem. This problem belongs
to the group of four classical symmetry-breaking problems, along with maximal matching, vertex coloring,
and edge coloring that we discuss later in this section.
1.6.1
Maximal Independent Set
Recall that the maximal independent set problem involves finding a subset of vertices in a graph that
is both independent (no two vertices are adjacent) and maximal (adding any other vertex would violate
independence). The first algorithms for this problem were the randomized algorithms by Luby [Lub86] and
Alon, Babai, and Itai [ABI86], which find a solution in Oplog nq rounds with high probability.16 Around the
same time, Linial introduced the model of local algorithms [Lin92], perhaps influenced by those algorithms.
One of the most important open questions in this area is whether a sublogarithmic-round randomized
algorithm exists for the maximal independent set problem.
Problem 1.13. Is there a randomized oplog nq-round algorithm for the maximal independent set problem?
Is there an rOp?log nq-round algorithm?17
Note that this problem specifically asks for a randomized algorithm. We discuss the deterministic case
shortly.
The second part of the question is motivated by the celebrated lower bound by Kuhn, Moscibroda, and
Wattenhofer [KMW16], which shows that the complexity of the problem is Ω
´b
log n
log log n
¯
. More precisely,
they show that for any maximum degree ∆, we can derive a lower bound of Ω
´
min
´b
log n
log log n,
log ∆
log log ∆
¯¯
for the maximal independent set problem. This motivates analyzing the complexity of the problem both as
a function of n and ∆.
Algorithms for small ∆: An important related question is to understand the complexity of the problem
as a function of the maximum degree, ∆. In this context, remarkable progress has been made using the so-
called shattering framework. The main idea is to develop fast randomized algorithms that solve the problem
for most vertices, leaving only small “islands” of unsolved vertices to be resolved later by an appropriate
deterministic local algorithm (see Section 2.2 for an example usage of the technique).
This technique,
developed in several papers [Bar+16; FG17; CLP18], culminated in an algorithm by Ghaffari [Gha16] that
solves the problem in Oplog ∆` poly log log nq rounds.
On the lower bound side, the aforementioned bound by Kuhn, Moscibroda, and Wattenhofer [KMW16]
shows that Oplog ∆q complexity cannot be substantially improved for certain ranges of ∆.
Moreover, the celebrated round elimination technique developed over the past decade [Bra19; Bra+16;
Bal+19b; Bal+21a; BO20; Bal+22c; BBO20] (see Sections 2.1 and 2.2 or the survey by Suomela [Suo13])
shows that this complexity is nearly optimal. In particular, Balliu, Brandt, Hirvonen, Olivetti, Rabie, and
Suomela [Bal+19b] use round elimination to establish a lower bound of Ω
´
min
´
∆,
log log n
log log log n
¯¯
. We con-
clude that no algorithm can achieve round complexity Oplog ∆q`o
´
log log n
log log log n
¯
or even op∆q`o
´
log log n
log log log n
¯
.
16Section 1.3 contains additional discussion related to maximal independent set and Luby’s algorithm.
17This text lists some open problems in the area. For a different list, see [Suo23].
14

--- Page 15 ---
Interestingly, a deterministic algorithm by Barenboim, Elkin, and Kuhn [BEK15; BE09; Kuh09] for the
maximal independent set problem runs in Op∆` log˚ nq rounds, which is also tight under this lower bound.
Deterministic algorithms: For deterministic algorithms, the most significant open question is whether
their complexity can match that of Luby’s algorithm.
Problem 1.14. Is there a deterministic rΘplog nq-round algorithm for the maximal independent set problem?
For a long time, the deterministic complexity of the maximal independent set problem paralleled the best-
known algorithms for network decompositions (discussed in Section 1.5), which implies a polylogarithmic
round complexity. Recently, a number of papers developed techniques such as local rounding and distributed
derandomization [HKP01; FGK17; Har19; GK22; Fao+23; GG23]; this lead to decoupling of the complexity
of the maximal independent set from network decomposition.
Currently, the best-known algorithm by
Ghaffari and Grunau [GG24] achieves a complexity of rOplog5{3 nq rounds.
On the lower bound side, Balliu, Brandt, Hirvonen, Olivetti, Rabie, and Suomela [Bal+19b] used
round elimination to show that the deterministic local complexity of finding a maximal independent set
is Ωplog n{ log log nq.
2
The Bounded-Degree Regime
In the previous section, we gained a good understanding of the fundamentals of local complexity – in essence,
if we care about the complexities up to poly log n, there are several equivalent definitions of it with sequential
local algorithms being a particularly helpful model for designing algorithms.
In this section, we will restrict our attention to bounded degree graphs and local problems of subloga-
rithmic complexity. Something surprising is going to happen: We will see that while, a priori, we would
expect all kinds of problem complexities, there are only three distinctive classes of local problems. This
sharp threshold phenomenon is a consequence of remarkable results known as speedup theorems.
As a rough roadmap for the rest of the section, we are going to give a more or less self-contained proof of
the following Theorem 2.1, with Section 2.1 focusing on the symmetry-breaking regime, Section 2.2 focusing
on the Lovász-local-lemma regime, and Section 2.3 focusing on showing that there are gaps in between the
regimes.
Theorem 2.1 (Classification of local problems with oplog nq complexity on bounded degree graphs). Let
us fix any ∆and the class of graphs of degree at most ∆. Then, any local problem with randomized round
complexity oplog nq has one of the following three round complexities.
1. Order-invariant regime: The problem has Op1q deterministic and randomized round complexity.
2. Symmetry-breaking regime: The deterministic and randomized round complexity of the problem lies
between Ωplog log˚ nq and Oplog˚ nq (both the deterministic and the randomized complexity is the same
function).
3. Lovász-local-lemma regime: The problem has deterministic round complexity between Ωplog nq and
rOplog4 nq. Its randomized round complexity is between Ωplog log nq and rOplog4 log nq.
2.1
The Symmetry-Breaking Regime
In the bounded-degree regime, the problems of maximal independent set or the closely related problem of
p∆` 1q-coloring play a bit similar role to network decomposition, as we will see in Theorem 2.5. These
problems are known as basic symmetry-breaking problems. This section shows that the round complexity of
these problems is Θplog˚ nq on bounded-degree graphs.
Basic symmetry breaking problems like maximal independent set and ∆` 1 coloring are
closely related. Their round complexity on bounded degree graphs is Θplog˚ nq.
15

--- Page 16 ---
2.1.1
Fast Coloring Algorithm and its Implications
We will first discuss a classical local coloring algorithm of Linial [Lin92] improving upon earlier work from
[CV86; GPS88]. This algorithm colors a graph of degree at most ∆with Op∆2q many colors in Oplog˚ nq
rounds. We will later see in Theorem 2.5 that this implies that on bounded-degree graphs, the local com-
plexity of constructing the maximal independent set and ∆` 1 coloring is Oplog˚ nq.
The main idea behind Linial’s algorithm is as follows: At the beginning of the algorithm, we will think
of the unique identifiers at the vertices as an input proper coloring with colors from the (very large) range
rnOp1qs. The heart of the proof is to provide a 1-round local algorithm that takes as input a coloring with
colors from a large range rks, and outputs a coloring with colors from a much smaller range rOp∆2 log kqs.
Repeating this process for Oplog˚ nq many rounds, we end up with a coloring with ∆Op1q many colors.
It remains to construct a suitable 1-round algorithm. To do this, we will use the so-called cover-free
families defined below.
Definition 2.2. Given a ground set rk1s, a family of sets S1, . . . , Sk Ď rk1s is called a ∆-cover free family if
for each set of indices i0, i1, . . . , i∆P rks, we have Si0z
´Ť∆
j“1 Sij
¯
­“ H. That is, no set in the family is a
subset of the union of some ∆other sets.
Such families can be constructed with the following parameters.
Lemma 2.3 ([KSS81; EFF82] or see [Gha20, Lemma 1.19, 1.20]). For any k, ∆, there exists a ∆-cover free
family of size k on a ground set of size k1 “ Op∆2 log kq. Moreover, if k ď ∆3, it exists for k1 “ Op∆2q.
We can now state and analyze Linial’s algorithm.
Theorem 2.4 (Linial [Lin92]). The deterministic round complexity of constructing a coloring with Op∆2q
many colors is Oplog˚ nq.
Proof. We will show a one-round algorithm that turns an input proper k-coloring into a proper Op∆2 log kq
coloring. Moreover, in case k ď ∆3, we can turn the k-coloring into an Op∆2q coloring.
The one-round algorithm simply interprets each input color from rks as a set in a ∆-cover free family
over the ground set rk1s for k1 “ Op∆2 log kq (and k1 “ Op∆2q in case k ď ∆3). Such a family exists by
Lemma 2.3. After each vertex u with a color Su learns the colors Sv1, . . . , Svd of its neighbors, it simply
chooses any color in the set Suz
´Ťd
i“1 Svi
¯
as its new color. This set is non-empty by the definition of a
cover-free family, and the new coloring is proper. This finishes the description of our one-round algorithm.
We interpret the input unique identifiers as proper coloring and apply the one-round algorithm Oplog˚ nq
many times. A quick calculation shows that the number of colors then drops to Op∆2 log ∆q. After one more
round and using the case k ď ∆3, the number of colors becomes Op∆2q, as needed. 18
Simulation of sequential local algorithms: We notice that graph coloring can be seen as a special case of
network decomposition discussed in Section 1 where each cluster has diameter 0. In particular, coloring with
a small number of colors allows us to turn sequential local algorithms into distributed local ones similarly to
Theorem 1.4.
Theorem 2.5. Let A be a sequential local algorithm with local complexity tpnq. Then, we can turn it into
a distributed local algorithm of round complexity Op∆Optpnqq ` tpnq ¨ log˚ nq. If the sequential algorithm is
deterministic, so is the distributed one.
18If we do not care about how the resulting number of colors depends on ∆, there is a more self-contained one-round algorithm
going back to Cole and Vishkin [CV86] that does not rely on cover-free families and leads to a coloring with 2Op∆log ∆q many
colors in Oplog˚ nq rounds. The algorithm turns a coloring with 2k colors into a coloring with 2Op∆log kq colors as follows:
Think of the input color of each vertex u as a k-bit string su. The vertex sends this color to all its neighbors. After u receives
d ď ∆strings of its neighbors, s1, s2, . . . , sd, it does the following. For each received si, the node u identifies an index ji where
si differs from its own bit string su. Such an index exists since we assumed that we started with proper coloring. The new color
of u is defined as the concatenation s1
u “ j1 ˝ surj1s ˝ ¨ ¨ ¨ ˝ jd ˝ surjds. That is, the vertex u simply remembers only the values
of bits of su on the positions where those values reveal that su differs from its neighbors. We observe that no two neighboring
vertices can end up with the same string. Moreover, if we write s1
u in binary, it has only Op∆¨ log kq many bits.
16

--- Page 17 ---
Proof. We follow the outline of the proof of Theorem 1.4 that simulated sequential local algorithms using
network decompositions.
To simulate a sequential local algorithm A of local complexity tpnq, we first
construct a coloring of Gtpnq with O
`
∆2pGtpnqq
˘
colors19 using Linial’s algorithm from Theorem 2.4. That
algorithm needs O
`
tpnq ¨ log˚ n
˘
rounds where we multiply by tpnq because one round of communication in
Gtpnq can be simulated in tpnq rounds in G. Subsequently, we iterate over all colors and simulate the sequential
algorithm A as in Theorem 1.4. That simulation takes additional Op∆2pGtpnqqq “ ∆Optpnqq rounds.
As a corollary of Theorem 2.5, we get that maximal independent set or ∆`1-coloring can be constructed
in Oplog˚ nq rounds on bounded-degree graphs.
Corollary 2.6. Sequential local algorithms with local complexity Op1q (such as algorithms for the maximal
independent set or ∆` 1 coloring) can be simulated with round complexity Oplog˚ nq on bounded degree
graphs.
Understanding unique identifiers: Let us now discuss the unique identifiers from the range rnOp1qs in
the definition of deterministic algorithms. We will use our understanding of coloring to see that the strength
of the model of deterministic algorithms remains the same even if the identifiers come from a much larger
range like r2ns or r22ns. Moreover, we will understand why identifiers are not needed in the definition of
sequential local algorithms.
The following theorem will use an instance of a fooling argument, variants of which we will enjoy employing
later on. To motivate it, notice that it is a bit awkward that the definition of a local algorithm talks about
globally unique identifiers. We will next “fool” a given deterministic local algorithm solving a local problem
by supplying to it a distance coloring (i.e., coloring of the power graph) with nOp1q many colors instead of
unique identifiers. The algorithm still has to work since a failure of the algorithm for input distance coloring
would imply a failure for input unique identifiers.
Theorem 2.7. Let A be a deterministic local algorithm of round complexity tpnq for a local problem Π.
Then, given any s “ nωp1q, there is a deterministic local algorithm A1 solving Π in Optpnq¨log˚
npsqq rounds20
and assumes that the identifiers are from range rss.
Similarly, let A be a sequential local algorithm of local complexity tpnq for a local problem Π in a model of
sequential local algorithms where each node has additionally a unique identifier from rnOp1qs. Then there is a
sequential local algorithm A1 for Π of complexity Optpnqq in the standard model of sequential local algorithms
without any identifiers.
Proof. Let A be a deterministic algorithm of round complexity tpnq solving a local problem Π with local
checkability r in the model where the unique identifiers are from rnOp1qs (the constant in the exponent is
assumed to be large enough). We construct a new algorithm A1 that works in the less powerful model with
identifiers from rss as follows. We first compute a coloring of the power graph G2ptpnq`rq with nOp1q many
colors, then we simulate A with that coloring as identifiers.
In particular, the coloring is constructed by iterating color reductions of Linial’s algorithm of Theorem 2.4.
Recall that each color reduction reduces the range of color exponentially, thus after log˚
npsq rounds, we reduce
the input coloring with colors from rss to a coloring with colors of size at most Op∆2pG2ptpnq`rqqq “ nOp1q.
Next, we prove that A1 is correct. Assume that A1 fails to solve Π at a node u. Notice that this failure
depends only on the ptpnq`rq-hop neighborhood of u where the coloring constructed by A1 uses unique colors.
In particular, we can extend this coloring of Bpu, tpnq ` rq to a labeling of every node of the input graph
with unique identifiers. The original algorithm A fails to solve Π at u for these identifiers, a contradiction
with A being correct.
The proof of the second claim in the theorem is very similar and, in fact, easier, since ∆` 1-coloring has
constant sequential local complexity and thus Linial’s color reductions are not needed.
As a helpful corollary of the second part of Theorem 2.7, we can now see that any deterministic local
algorithm A solving some local problem can be converted into a deterministic sequential algorithm of the
same asymptotic local complexity. This was actually not clear until now since our definition of deterministic
sequential algorithms in Definition 1.3 did not contain input unique identifiers.
19The notation ∆pGq stands for the maximum degree of G.
20Here, log˚
npsq returns how many times we need to take the logarithm of s, until its value drops below n, i.e., log˚
np2nq “
1, log˚
np22nq “ 2 and so on.
17

--- Page 18 ---
2.1.2
Lower bound for coloring via round elimination
Finally, let us prove that the log˚ n dependency for constructing maximal independent sets or colorings is
necessary.
Theorem 2.8 (Naor [Nao91] and Linial [Lin92]). The local complexity of computing ∆` 1 coloring is
Ωplog˚ nq, even on graphs that are oriented paths.
There are several known proofs of this theorem [Nao91; Lin92]; we will use the proof of Linial [Lin92]
framed in the language of a powerful technique known as the round elimination (see [Suo13] for an introduc-
tion to it). In essence, given a local problem Π, round elimination is an automated technique that defines a
problem Π1 such that the round complexity of the fastest algorithm for Π1 is exactly one round smaller than
the round complexity of the fastest algorithm for Π (unless the complexity of Π was already zero). This is
very helpful for proving lower bounds: If we start with some problem Π and argue that even after t rounds
of round elimination, the problem Πptq that we end up with is not solvable in zero rounds, we infer that the
local complexity of Π is at least t.
Preparations for the lower bound: We will prove the lower bound in the extremely simple setup where
we are promised that the input graph is an oriented path, i.e., the setup from Section 1.1. The lower bound
will be for deterministic algorithms, so each node starts with a unique identifier. We will make a further
restriction on the identifiers, we require that the input labeling with identifiers is increasing; that is, if for
every oriented edge e “ uv going from u to v, we have IDpuq ă IDpvq.
Next, let us discuss local algorithms. It will be helpful to think about them as functions in the spirit of
Definition 1.2. A subtlety we need to be careful about is that in one step of round elimination, we don’t
want to directly convert a t-round local algorithm (that sees 2t ` 1 vertices) to a t ´ 1 round algorithm (that
sees 2t ´ 1 vertices). Instead, we want to convert an algorithm that sees t vertices to an algorithm that sees
t ´ 1 vertices. To this end, we define an edge-centered pt ` 1{2q-round algorithm A to be a local algorithm
such that for an edge e “ uv, the input to A is the ball Bpuv, t ´ 1q defined as Bpu, t ´ 1q Y Bpv, t ´ 1q. The
output of A is a label for the edge e. For example, 1{2-round local algorithm run on e has access to the two
identifiers IDpuq and IDpvq and it maps the two identifiers to a label of e.
One half-round reduction: Here comes the heart of the proof; we will show that any given t-round local
algorithm for coloring vertices with k colors can be converted to a ppt ´ 1{2qq-round algorithm for coloring
edges with 2k colors.
Lemma 2.9. Assume that for t ą 0 we are given a node-centered t-round deterministic local algorithm A
that outputs a proper coloring with k colors on oriented paths with increasing unique identifiers. Then, there
is an edge-centered ppt ´ 1{2qq-round algorithm A1 that properly colors the edges with 2k colors in the same
setup. Similarly, edge-centered pt ` 1{2q-round algorithms for k-coloring can be converted into node-centered
t-round algorithms for 2k-coloring.
Proof. We will only discuss the conversion of a node-centered algorithm into an edge-centered one, the other
case is very similar.
Given a t-round algorithm A, we define a pt ´ 1{2q-round edge-centered algorithm A1 as follows (see
Figure 5): Given an edge e “ uv so that A1 has access to Bpuv, t ´ 1q, we let A1 to consider all possible
identifiers of the unique node x P Bpv, tqzBpuv, t ´ 1q, i.e., the only node that A sees but A1 doesn’t. For
each possible value of the identifier IDpxq of x (we also consider the option that we are at the end of the
path and the vertex x does not exist), the algorithm A1 simulates A on Bpv, tq and records the color that
A outputs. The final output of A1 is a subset of rks that contains each color c P rks whenever there is an
identifier that makes A output c. Note that we can encode the set with k bits – that is, we view this set of
colors from the range rks itself as a new color from the range r2ks. This finishes the description of A1.
Our task is to prove that A1 returns a proper coloring of edges. Here is what this question reduces to:
Consider any increasing labeling of the oriented path with identifiers and consider any three consecutive
nodes u, v, w (see Figure 6). We again let x be the unique node in Bpv, tqzBpuv, t ´ 1q and y the subsequent
neighbor of x. Consider the new colors C1, C2 P r2ks that A1 outputs on the two edges uv and vw. We need
to prove that the two colors C1, C2 are different. We do that by focusing on the original color c P rks that
A outputs at v.
18

--- Page 19 ---
A′
2
3
5
9
10
11
15
17
18
5
9
10
11
13
A
5
9
10
11
12
A
...
{
}
Figure 5: The definition of the 1.5-round algorithm A1 derived from a 2-round algorithm A: The algorithm A1
considers all compatible one-node extensions of its neighborhood containing 4 nodes to 5-node-neighborhoods (in the
picture, this corresponds to the following node having the identifier 12, 13, . . . , nOp1q, and the possibility that the node
does not exist). The algorithm considers all possible answers that A returns for those neighborhoods (the picture
shows that the red and the blue color are two of those possible answers). The color that A1 uses to color the edge it
is centered on is simply the set of all colors that A returns for some extension (in the picture, it is the set containing
the red and the blue color).
A′
2
3
5
9
10
11
15
17
18
u
v
w
x
y
A′
C1
C2
Figure 6: The situation from the proof of correctness of A1: We need to argue that the two colors C1, C2 are
different. To do so, we define c to be the color that A outputs on the input p5, 9, 10, 11, 15q. By definition, we have
c P C1. On the other hand, if c P C2, we get an existence of an identifier ID1pyq such that A returns c on the
input p9, 10, 11, 15, ID1pyqq. But then we consider the input p5, 9, 10, 11, 15, ID1pyqq and notice that A colors two
consecutive vertices with the same color c, a contradiction with its correctness.
19

--- Page 20 ---
On one hand, notice that c P C1 because the edge-centered algorithm A1 run at uv considers the actual
identifier IDpxq as a possibility and thus includes c in C1.
On the other hand, assume for contradiction that c P C2. That would imply that there is a certain
identifier ID1pyq that makes the output of A at w to be the color c. But now consider changing the valid
increasing labeling of identifiers that we started with by letting the identifier of y be equal to ID1pyq. Let’s
look at all the nodes in Bpvw, tq. The identifiers on them are still a valid increasing identifier sequence.21
But after extending Bpvw, tq and its identifiers to a path on n vertices labeled with increasing identifiers,
A fails to solve k-coloring on that graph since it outputs the same color c at both v and w, a contradiction
with our assumption that A is correct.
We can now prove Theorem 2.8 as follows: Assuming the existence of a t “ oplog˚ nq-round algorithm
for 3-coloring of oriented paths, we apply Lemma 2.9 2t times until we end up with a 0-round algorithm
A0 that colors oriented paths with 22. . .23
ă n colors where the inequality holds because the height of the
exponentiation tower is 2t “ oplog˚ nq. But such A0 is simply a function mapping an input identifier from
the range rnOp1qs to a color in the smaller range rns.
Using the pigeonhole principle, we can find two
identifiers that A0 maps to the same color and argue that if these two identifiers happen to be present at
two neighboring nodes, A0 fails to output proper coloring. 22
2.2
The Lovász Local Lemma Regime
We will next discuss Lovász local lemma, a very expressible local problem closely related to the third regime
of problems from Theorem 2.1.
Definition of Lovász local lemma: Lovász local lemma is the following very general local problem 23. The
problem is formally defined for bipartite graphs in which nodes of one part are labeled as random variables
and the nodes of the other part are labeled as bad events.
We denote the maximum degree of random
variable nodes as ∆r.v. and the maximum degree of bad event nodes as ∆b.e.. Each node u labeled as a
random variable is additionally labeled with a probability space Ωu. To simplify discussions, we will without
loss of generality assume that each probability space is an infinite list of random bits (i.e., it is the uniform
distribution on r0, 1s). Next, each node v labeled as a bad event that neighbors with nodes u1, . . . , ud with
d ď ∆b.e. is additionally labeled with an event Ev on the space śd
i“1 Ωui.
Often, it is useful to work only with a graph induced by bad-event nodes where two bad-event nodes
are connected if they share a common random variable. In that case, we will talk about the dependency-
graph formulation of Lovász local lemma and use ∆to denote its maximum degree. On the other hand, the
setup with a bipartite graph with both bad-event nodes and random-variable nodes will be denoted as the
variable-event-graph.
The crucial ingredient to the Lovász local lemma is a requirement on the bad events that, roughly
speaking, says that we can use the union bound in the dependency-graph neighborhood of every bad event
Ev and conclude that with positive probability, neither Ev, nor its neighboring bad events occur. Namely, in
the tight version of Lovász local lemma, we are given a promise that each bad event Ev has probability at
most p where p is defined by the following Lovász local lemma criterion:
p ¨ p∆` 1q ď 1{e.
(1)
A foundational result of Erdős and Lovász [EL75] is that even in the tight formulation, it is always
possible to solve any instance of the local lemma problem, by which we mean that one can instantiate
random variables so that no bad event occurs.
21This is the place in the argument where we need increasing and not just unique identifiers: With unique identifiers, the
leftmost and the rightmost node of Bpvw, tq could now have the same identifier.
22Round elimination may used both to prove lower bounds and to construct algorithms. In particular, it can be used to
derive that the round complexity of 3-coloring paths in 1
2 log˚ n ˘ Op1q [RS15].
23The Lovász-local-lemma problem does not quite satisfy the requirements for the local problem as we defined it in Defini-
tion 1.1, but, morally speaking, it can be seen as such.
20

--- Page 21 ---
A C-relaxed (or just polynomially-relaxed) version of Lovász local lemma, which is a bit more relevant
to our applications, only requires that
p ¨ ∆C ď 1
(2)
This section will show both fast algorithms and lower bounds for the polynomially-relaxed Lovász local
lemma.
Lovász local lemma is a very versatile and expressible local problem.
Its deterministic
round complexity on bounded degree graphs is Θppoly log nq, and its randomized complexity
Θppoly log log nq.
2.2.1
Fast Algorithms for the Local Lemma
We first discuss how to solve any instance of the local lemma with a fast deterministic local algorithm.
To this end, we will start with a randomized algorithm that we later derandomize by Theorem 1.8. In a
breakthrough result in the area of constructive algorithms for the local lemma, Moser and Tardos [MT10]
presented an algorithm for it in the tight formulation. Moreover, they presented a parallel variant of their
algorithm that can be interpreted as a local algorithm with round complexity Oplog2 nq. This complexity was
later improved by Chung, Pettie, and Su [CPS17b] to Oplog nq rounds on bounded degree graphs. Plugging
their result to Theorem 1.8, we obtain the following theorem.
Theorem 2.10. The deterministic round complexity of solving any instance of the tight version of Lovász
local lemma on bounded degree graphs is rO
`
log4pnq
˘
.
Even faster randomized algorithm: Next, we will show that there is an even exponentially faster
randomized algorithm for the relaxed version of the local lemma. We will discuss the algorithm of Fischer
and Ghaffari [FG17] with round complexity poly log log n which uses shattering, a successful technique (cf.
Section 1.6) that goes back to the work on algorithmic local lemma by Beck [Bec91].
The main idea goes as follows. Our algorithm will have two phases. In the first phase, we use a sequential
local algorithm with constant complexity to do the following. Given an instance of the local lemma, the
algorithm fixes most of the random variables in such a way that most bad events are satisfied (i.e., all random
variables relevant for that bad event are fixed and the event does not occur). More concretely, the fraction
of fixed random variables and satisfied events is 1 ´ 1{∆Op1q. The price for this outcome is that remaining,
unfixed, bad events have their probability slightly increased from 1{∆C to 1{∆C1 for some C1 ă C.
Fortunately, we have an additional guarantee on the unfixed bad events. Due to the very small locality
of the algorithm in the first phase, we can use an independence-like argument to show that the size of the
connected components of unfixed bad events is Op∆Op1q log nq, with high probability (see Figure 7). We also
say that the graph shatters into small components. We can thus run the best deterministic algorithm from
Theorem 2.10 as the second phase of the algorithm, to solve the remaining instance of the C1-relaxed local
lemma. This second phase takes poly log p∆log nq rounds which is also the round complexity of the overall
algorithm.24 We will now make the above discussion formal.
Theorem 2.11 (First phase of Fischer and Ghaffari [FG17]). There is a randomized sequential local algo-
rithm A of constant local complexity that gets as input a variable-event graph of an instance of C-relaxed
Lovász local lemma for some large enough C. The algorithm fixes some bits of each random variable to
concrete values so that conditioned on those fixed bits, we have the following two properties:
1. Each bad event has probability at most 1{p3∆q.
2. Up to 1{ polypnq error probability, the residual dependency graph induced by bad events with non-zero
probability has connected components of size Op∆3 log nq.
24Our example algorithm from Section 1.1 can be seen as a simple shattering algorithm.
21

--- Page 22 ---
Figure 7: This picture shows an example variable-event graph corresponding to an instance of Lovász local lemma; the
circles represent bad events and squares represent random variables. The picture shows the situation after the first
phase of Fischer-Ghaffari algorithm (Theorem 2.11). Most random variables are set to a fixed value (grey squares). A
small proportion of the random variables remains unset (red squares) and the bad events neighboring with an unset
random variable (red circles) form connected components of diameter Oplog nq.
Proof. 25 The algorithm A is defined as follows. We iterate over the random variables and for each random-
variable node u with neighboring bad-event nodes v1, . . . , vd, we perform the following process. We sample
the random bits of Ωu one by one. While we do that, we consider the probabilities of neighboring bad events
PpEi|sampled bitsq for each 1 ď i ď d. The first time it happens that for some i we have PpEi|sampled bitsq ą
1{p6∆q, i.e., the bad-event probability crosses the dangerous threshold of 1{p6∆q, we stop sampling and do
the following.
We label u, together with all other random variables neighboring vi as frozen (if more vi’s jumped over
the dangerous threshold at the same time, we do this to all of them). We never sample bits of frozen random
variables in the future.
In particular, we stop sampling bits of u and continue with the next unfrozen
random variable in the arbitrary order of our sequential local algorithm. This finishes the description of the
algorithm.
To see that each bad event has probability at most 1{p3∆q (the first item in the theorem statement)
during any point throughout the algorithm, we notice that if an event E of probability PpEq “ p depends
on a single bit of randomness b, we have, by Markov’s inequality, that PpE|b “ 0q, PpE|b “ 1q ď 2p. That
is, the bad event probability in our process never increases multiplicatively by a factor larger than 2, which
together with the definition of the dangerous threshold implies the desired bound.
To understand the size of connected components in the residual dependency graph (i.e., components of
bad-event nodes of non-zero probability after we set the random bits), consider any fixed set S of bad-event
nodes with the following two properties:
1. (independence) no two nodes v1, v2 P S are neighboring in the dependency graph G,
2. (connectivity) S is connected in G6.
We will next prove that with high probability, no such set S of size Ωplog nq survives to the residual graph.
First, we use the independence property to prove that the probability that all nodes in a fixed set S
crossed the dangerous threshold during our process is exponentially small in the number of nodes |S|. Let
us contemplate the behavior of the algorithm A with respect to any bad-event node v P S and the random
variables u1, . . . , ud neighboring v in the variable-event graph. We note that if bits b1, . . . , bk´1 were already
sampled and bk is sampled next, we have Ebk rPpEv|b1, . . . , bkqs “ PpEv|b1, . . . , bk´1q. Hence, viewing PpEvq
as a random variable that depends on bits sampled from Ωu, u P V pGq, we conclude that its expectation is
at most 1{∆C and we can thus use Markov’s inequality to conclude that the probability of PpEvq crossing
the dangerous threshold is at most
6∆
∆C “ 6{∆C´1. Moreover, we notice that if we first set the randomness
25The original algorithm and its analysis by Fischer and Ghaffari [FG17] contains subtle flaws. Here, we follow the proof by
Maus [Mau].
22

--- Page 23 ---
of nodes in V 1 “ V pGqzpu1 Y ¨ ¨ ¨ Y udq to whatever values, we can still make above argument and conclude
that for all ways of setting Ωu “ ωu for all u P V 1 we have
PpEv|@u P V 1 : Ωu “ ωuq ď 6{∆C´1.
Since we assumed that S is an independent set of bad-event nodes in the dependency graph, we can thus
inductively prove that the probability of all nodes in S crossing the dangerous threshold is at most
`
6
∆C´1
˘|S|.
We next count the number of possible sets S of size t that satisfy the connectivity property: Each such
S can be specified by fixing any node u P S, and then specifying how one can walk for 2p|S| ´ 1q steps
in G6 so that the walk defines a spanning tree of G6rSs. Hence, the number of sets S of size t is at most
n ¨ p2∆6q2pt´1q. We can thus upper bound the existence of some connected surviving set S of size t as
n ¨ p2∆q12t ¨
ˆ
6
∆C´1
˙t
.
Choosing C “ Op1q and t “ Oplog nq large enough, we conclude that the size of this expression is at most
1{nOp1q.
Finally, for t “ Oplog nq from the above argument, consider any connected subset S of G of size at least
p2∆q3 ¨ t and assume that S survived to the residual dependency graph. Then, we can find its subset S1 Ď S
of size at least |S1| ě t where S1 is independent in G3, yet S1 is connected in G4. To see this, consider a
greedy algorithm that starts with S1 “ tuu for arbitrary u P S, iterates through vertices of S and while
we still can add at least one node v P S to S1 and keep the independence property, we choose any v with
distance 4 to S1 and add it to S1. One can see that the final set S1 has to be connected in G4. Also, |S1| ě t
because adding a vertex to S1 disqualifies at most p2∆3q vertices to be added to S1 in the future.
If all nodes of S survived to the residual dependency graph, it means that every node in S1 has to have
a neighboring node that crossed the dangerous threshold. The set S1 thus gives rise to a set S2 of size
|S2| “ |S1| ě t of nodes that all crossed the dangerous threshold. Moreover, by S1 being independent in G3,
we conclude that S2 is independent in G. Since S1 was connected in G4, S2 is connected in G6. The set S2
thus satisfies the requirements of a set that, as we have proven, does not occur in the residual graph with
high probability and we can thus conclude the same for the original connected set S.
Putting Theorem 2.11 (simulated as a distributed algorithm by Theorem 2.5) together with Theorem 2.10,
we conclude that the following result holds.
Theorem 2.12 (Fischer and Ghaffari [FG17]). There exists a constant C such that the randomized round
complexity of any instance of the C-relaxed Lovász local lemma on bounded-degree graphs is rO
`
log4 log n
˘
.
The dependency on ∆in the round complexity of Fischer-Ghaffari algorithm is polynomial. It is unknown
whether this polynomial dependency can be improved to logarithmic.
Problem 2.13. Is there a randomized local algorithm for relaxed Lovász local lemma with round complexity
Oppoly log ∆` poly log log nq?
Conjecture of Chang and Pettie [CP19]: We note that Chang and Pettie [CP19, Conjecture 1] conjec-
ture that any instance of the relaxed local lemma can be solved with randomized Oplog log nq complexity.
Problem 2.14 (Chang-Pettie Conjecture). Is it true that the randomized round complexity of C-relaxed
Lovász Local Lemma for some large enough C is Θplog log nq on bounded degree graphs?
We will see later in Section 2.3.2 that the randomized round complexity Oplog log nq implies the deter-
ministic round complexity of Oplog nq via Theorem 2.21.
Self-contained algorithm: A bit unfortunate property of Theorem 2.12 is that it relies on the random-
ized entropy-compression algorithms from Moser and Tardos [MT10] or Chung, Pettie, and Su [CPS17b].
However, we can prove Theorem 2.12 also in a self-contained way: First, we observe that after the first
23

--- Page 24 ---
phase of the Fischer-Ghaffari algorithm finished, each surviving bad event simply collects the whole con-
nected component of the residual graph; then we solve the problem in each residual component by applying
the standard, existential, Lovász local lemma. This new randomized algorithm has complexity Oplog nq on
bounded degree graphs since this is the maximum diameter of residual components, with high probability.
We can derandomize this algorithm using Theorem 1.8 and use the resulting deterministic algorithm instead
of the algorithm of Chung, Pettie, and Su [CPS17b] in the second phase of our shattering algorithm. This
way, we get a simpler and more self-contained algorithm. Its downside is a worse value of C and a worse
dependence of round complexity on ∆.
2.2.2
Lower Bound via Round Elimination
Next, we will show that the deterministic local complexity of solving a certain specific instance of Lovász local
lemma is Ωplog nq. Later, we will prove in Theorem 2.21 that this also implies a randomized lower bound
of Ωplog log nq, thus showing that the round complexity of Fischer-Ghaffari algorithm from Theorem 2.12 is
close to tight.
The problem we choose for the lower bound is sinkless orientation. We will define the problem only on
trees of degree at most ∆where it is already hard. The task is to orient all the edges of the input tree so
that no node is a sink, which is defined as a node such that all ∆neighboring edges point towards it (nodes
of degree less than ∆are not constrained in any way).
Sinkless orientation can be seen as a specific instance of the local lemma: orienting each edge randomly
corresponds to a random variable at each edge. Then, a vertex becoming a sink corresponds to a bad event
of probability 2´∆. For large enough ∆, this is much smaller than the polynomial criterion 1{∆C from
Equation (2) which makes this problem a valid instance of the local lemma. We will next prove the following
theorem.
Theorem 2.15 (Brandt, Fischer, Hirvonen, Keller, Lempiäinen, Rybicki, Suomela, and Uitto [Bra+16]).
For any constant ∆, the sinkless orientation problem has deterministic round complexity Ωplog nq on the
class of trees of degree at most ∆.
Preparations: As in Theorem 2.8, we will want to replace the uniqueness of identifiers with local con-
straints that imply that they are unique. In the proof of Theorem 2.8, we worked with identifiers that were
monotonically increasing (which implied they were unique), this time we will work with identifiers that are
consistent with a so-called ID graph [Kor+21; Bal+23b; Bra+22]. 26
Definition 2.16 (ID graph). Given a parameter ∆, an ID graph H is a graph on a set rns that we associate
with unique identifiers. Every edge of the graph is colored with one of ∆many colors and we write Hi for
the graph induced by the i-th color. We require that:
1. The girth of H, i.e., the length of the shortest cycle in H, is at least γ log∆n for some fixed γ ą 0.
2. Each independent set of each Hi has less than n{∆vertices.
Such a graph exists, which can be proven using the same argument as how one proves that high-girth
high-chromatic graphs exist [Bra+22; Kor+21].
We will fix any ID graph and work in a model relative to that ID graph. Here is what that means. First,
we will assume that the input graph G is always a tree of degree at most ∆such that its edges are, moreover,
properly ∆-colored on the input (i.e., each vertex is incident to edges of different colors). Additionally, we
require that if two nodes u, v neighbor in G with an edge of color i, then their identifiers IDpuq, IDpvq
neighbor in Hi.
We notice that this is a local constraint on input identifiers that does not imply they are unique. However,
notice that whenever two vertices u, v P V pGq have the same identifier, we can consider the path between u
and v in G and how it maps to a walk in H that starts in IDpuq and finishes in IDpvq “ IDpuq. The proper
edge-coloring of G implies that the walk never goes from x P V pHq to y P V pHq and then back to x in the
subsequent step. This implies that the walk contains a cycle, thus the distance of u and v is at least as large
26The usual usage of round elimination is for randomized algorithms instead of using the ID graph, but this would require
a longer setup and more calculations.
24

--- Page 25 ---
as the girth of H. That is, the identifiers are unique up to a large distance which is pretty much the same
as them being unique (cf. Theorem 2.7).
Similarly to the lower bound of Theorem 2.8, we will work with node-centered and edge-centered algo-
rithms. For node-centered algorithms, solving sinkless orientation means that the algorithm outputs one of
∆many input edge colors at each node. Outputting a color i means that u decides that the edge of the
color i goes outwards from u. The local constraint on this output vertex-coloring is that no two neighboring
nodes should select the same edge going in between. We will call this variant of the problem edge-grabbing.
On the other hand, edge-centered algorithms will solve the sinkless orientation as we described the problem:
Each edge simply outputs how it is oriented and we have a local constraint at each vertex, requiring that it
has at least one outgoing edge.
Round elimination: We proceed with performing the actual round elimination. Notice that the spirit of
the following proof is very similar to the proof of Lemma 2.9.
Lemma 2.17. Assume that we are given a node-centered deterministic t-round local algorithm A of round
complexity at most t ď log∆n ´ 1 that solves the edge-grabbing problem on trees of degree at most ∆relative
to some fixed ID graph H. Then, there is a t ´ 1{2-round edge-centered deterministic local algorithm A1 that
solves sinkless orientation in the same setup.
Similarly, t ` 1{2-round edge-centered algorithm for sinkless orientation implies a t-round node-centered
algorithm for edge-grabbing.
Proof. We prove just the first part of the statement, the proof of the second part is similar, and doing it is
a good exercise.
We start with any node-centered algorithm A with round complexity t that solves the edge-grabbing
problem. We define the edge-centered algorithm A1 of round complexity t ´ 1{2 as follows. For an edge
e “ uv, the algorithm first considers all the possible extensions of the (known) ball Bpuv, t ´ 1q to the ball
Bpu, tq that is known to A when it is run on u. By an extension, we mean first how the graph looks like
(e.g., maybe some vertices on the boundary of Bpuv, t ´ 1q turn out to be leaves), and second, what the
identifiers are (they have to be consistent with H). We consider all valid extensions and if at least one of
them leads to A grabbing the edge uv from u, then A1 orients the edge uv from u to v. After this is done,
the algorithm makes an analogous reasoning for v; again, whenever at least one extension of Bpuv, t ´ 1q
to Bpv, tq decides to grab the edge uv, A1 orients it from v to u. If no vertex ever decides to grab uv, A1
decides to orient it arbitrarily. This finishes the description of A1 (see Figure 8).
To make sure that A1 is well-defined, we need to prove that it never happens that there is an extension
of Bpuv, t ´ 1q to both Bpu, tq and Bpv, tq such that A run on Bpu, tq decides to grab the edge uv and run
on Bpv, tq, it decides to grab the edge vu. To see this, notice that putting the two extensions Bpu, tq, Bpv, tq
together, the graph Bpuv, tq has at most n nodes and its identifiers respect H.27 We observe that in case A1
is not well-defined, A fails to solve edge-grabbing on Bpuv, tq, a contradiction with the assumed correctness
of A.
Moreover, the algorithm A1 solves sinkless orientation: For any node u of full degree ∆, the original
algorithm A decided to grab a certain edge uv. When we run A1 on uv, A1 will by definition orient this edge
from u to v, thus u cannot be a sink.
Finishing the proof: Let us finish the proof of Theorem 2.15.
Proof of Theorem 2.15. Consider an input graph G which is a branching tree with ε log n layers and every
non-leaf vertex has degree ∆. Note that for small enough ε ą 0, the girth property of the ID graph implies
that any labeling of G with identifiers from rns that respects a fixed ID graph H has unique identifiers. On
the other hand, G has O
`
∆ε log n˘
nodes, so the range from which the identifiers are coming is |V pGq|Op1q.
Therefore, a deterministic local algorithm for sinkless orientation on G implies a local algorithm for that
problem on G with identifiers consistent with H.
But Lemma 2.17 shows that any oplog nq-round algorithm that works relative to H can be sped up to 0
round complexity. A 0-round algorithm A0 is simply a function that maps an input identifier to one of ∆
many colors, i.e., which edge the vertex decides to grab. We can thus think of A0 as a coloring of H with ∆
27This part of the argument needs to work with the ID graph instead of unique identifiers.
25

--- Page 26 ---
u
v
A
A
A′
B(u, t)
B(v, t)
B(uv, t −1)
Figure 8: The picture shows the definition of the algorithm A1 for t “ 2. Notice that our setup is a large ∆-regular
tree with edges colored with ∆colors.
The algorithm A1 has access only to the identifiers in Bpuv, t ´ 1q (the
intersection of the red and the blue ball). To decide on the orientation of the edge uv, the algorithm considers all
possible identifier extensions of Bpuv, t ´ 1q to Bpu, tq (the red ball), and if at least one such extension makes A run
at u grab the edge uv, A1 orients that edge towards v. We analogously orient this edge towards u if at least one
extension of Bpuv, t ´ 1q to Bpv, tq (the blue ball) makes A run at v grab the edge uv.
We notice that it cannot happen that A1 wants to orient the edge uv in both directions: that would imply the
existence of an identifier-labeling of Bpuv, tq on which A is incorrect.
many colors. But notice that for any such vertex coloring, we can consider the largest color class i that has
at least n{∆colors. Then, we use the independence property of ID graphs from Definition 2.16 to infer that
the set of vertices of color i cannot be independent in Hi, i.e., there is an edge uv in H where both u and
v, as well as the edge uv are colored by the color i. We thus found two vertices that may be neighboring in
the input graph G and the algorithm A0 decides to grab the edge connecting them from both endpoints of
that edge, a contradiction with A0 being correct.
Sinkless orientation as the “simplest hard problem”: Notice that if we formulate sinkless orientation as
an instance of Lovász local lemma, the bad event probability is equal to 2´∆, that is, the bad event probability
is exponentially small compared to the polynomial guarantee in the relaxed criterion of Equation (2). It
turns out that this is the threshold where an instance of the local lemma is still “hard”.
Theorem 2.18 ([Bra+16; BMU19; BGR20]). On one hand, there is an instance of Lovász local lemma
(namely sinkless orientation) with the criterion p ¨ 2∆ď 1 that has deterministic round complexity Ωplog nq.
On the other hand, any instance of Lovász local lemma with the criterion p ¨ 2∆ă 1 has deterministic round
complexity Oplog˚ nq.
A similar threshold phenomenon holds also if we work in the variable-event graph.
Theorem 2.19 ([FG17, Theorem 3.5], [Ber23b, Corollary 1.8]). On one hand, there is an instance of Lovász
local lemma28 with the criterion p ¨ ∆∆b.e.
r.v.
ď 1 has deterministic round complexity Ωplog nq. On the other
hand, any instance of Lovász local lemma with the criterion p¨∆∆b.e.
r.v.
ă 1 has deterministic round complexity
Oplog˚ nq.
28The instance is sinkless orientation on trees where one color class has degree ∆r.v. and the other has degree ∆b.e.. One
formulates it as an instance of the local lemma by letting each vertex of one color class grab a random outgoing edge. The
proof that this variant of sinkless orientation is still hard seems to be missing in the literature.
26

--- Page 27 ---
2.3
Speedups and Slowdowns
The following section covers speedup and slowdown theorems which are at the heart of why we understand
that there are sharp thresholds in the local complexities in Theorem 2.1.
The elegant idea behind speedups and slowdowns is that we can simply “lie” to algorithms about the
size of the input graph, an idea closely related to the fooling argument we have already seen in the proof
of Theorem 2.7. To understand this technique, it may be useful to briefly recall that in Definition 1.2, we
defined a local algorithm as a function that takes two inputs. Firstly, it is n, the size of the input graph,
and secondly, it is a tpnq-hop neighborhood of a vertex that is additionally labeled by unique identifiers or
random strings. We will use the notation An to denote the algorithm A when the first input is n, i.e., we
will view A as a sequence of functions A1, A2, . . . In this section, we will contemplate what happens if we
run An on a graph of size n1 ­“ n. If n1 ą n, we are “speeding up” A, while if n1 ă n, we are “slowing it
down”.
2.3.1
Slowdowns
Let’s first see why slowdowns may be useful. As a first application, let us recall that we defined deterministic
and randomized round complexities in Definition 1.1 by requiring unique identifiers from the range rnOp1qs
or error probability at most 1{nOp1q. We will next see that for algorithms with sufficiently small round
complexity, we can replace nOp1q by n in the definition without changing its strength. For deterministic
algorithms, this complements Theorem 2.7 that shows how to replace very large identifiers with polynomially-
sized ones. This follows by plugging in fpnq “ nOp1q into the following slowdown theorem.
Theorem 2.20 (Chang, Kopelowitz, and Pettie [CKP19]). Let f be any increasing function with fpnq ě n,
let Π be any local problem, and let us use tfpnqpnq to denote the deterministic (randomized) round complexity
of solving Π if the input identifiers are from the range rfpnqs (the error probability is required to be 1{fpnq,
respectively). Then,
tnpnq ď tfpnqpnq ď tnpfpnqq.
The theorem holds for local complexities defined with respect to any subclass of graphs closed on adding
isolated vertices. 29
Proof. We will prove just the deterministic version of the theorem. Notice that tnpnq ď tfpnqpnq follows
directly from our assumption fpnq ě n and the definition: any algorithm expecting identifiers from the
range rfpnqs certainly works if they happen to be from the smaller range rns.
Next, consider any deterministic algorithm A that solves Π if the identifiers are from rns in round
complexity tpnq. Our goal is to turn it into an algorithm A1 with round complexity t1pnq that works if the
identifiers are from rfpnqs. Think of A as a sequence A1, A2, . . . for each n P N. We define A1 by setting for
each n that A1
n :“ Afpnq. That is, we “lie” to the algorithm A, telling it that the size of the graph is larger
(namely fpnq) than what it actually is (namely n). Since the round complexity of A on fpnq-sized instances
is tpfpnqq, for the complexity of A1 on n-sized instances we have t1pnq “ tpfpnqq.
Moreover, since Afpnq assumes that the unique identifiers are from rfpnqs, A1
n also assumes that the
unique identifiers from rfpnqs, making it a well-defined algorithm for the definition of local algorithm where
identifiers are supposed to be from rfpnqs on instances of size n.
Finally, we claim that A1 is a correct algorithm. To see this, suppose that A1
n fails to solve Π on some
graph G with n vertices labeled with unique identifiers from rfpnqs. Then, we go back to A and run it on a
graph G1 defined as G together with fpnq ´ n additional isolated vertices, all labeled with unique identifiers
from rfpnqs. We notice that since Π is a local problem, a failure in G implies a failure in G1, and we get a
contradiction with A being correct.
As an example of a non-local problem where the range of identifiers matters, consider the leader-election
problem30 where exactly one node of the input graph is to be selected. If the identifiers are from rns, we
can simply select the node with identifier 1. Otherwise, there is no local algorithm for it if the input graph
is empty.
29Looking at the proof, it is hard to come up with a reasonable class of graphs where the theorem does not apply.
30This is a fundamental problem in the broader area of distributed computing. The maximal independent set problem can
be seen as a local variant of this problem.
27

--- Page 28 ---
A similar argument to the proof of Theorem 2.20 can be used to prove another sleep-well-at-night result:
any local algorithm A with round complexity tpnq solving some local problem can be turned into an algorithm
A1 of round complexity t1pnq ď tpnq which is a non-decreasing function of n.
The randomized version of Theorem 2.20 turns out to be particularly interesting. Chang, Kopelowitz,
and Pettie [CKP19] used it to show that any randomized algorithm can be derandomized, if we appropriately
slow down its complexity. 31
Theorem 2.21 (Chang, Kopelowitz, and Pettie [CKP19]). If a local problem Π has randomized round
complexity tpnq, its deterministic round complexity is t
´
2Opn2q¯
.
The theorem holds for any class of graphs closed on adding isolated vertices.
Proof. Let A be a randomized local algorithm with error 1{nOp1q and round complexity tpnq solving Π. We
start by applying Theorem 2.20 with fpnq “ 2Opn2q to slow down A to complexity t
´
2Opn2q¯
while pushing
the error probability down to 2´Ωpn2q. We still call this new algorithm A.
The deterministic algorithm A1 for Π will work as follows. Let C be such that the unique identifiers
are coming from rnCs. We will use a certain function h (a hash function that we soon specify) that maps
each identifier from rnCs to an infinite bit string. We define A1 as follows: It first uses h to map each input
identifier to an infinite bit string, and next it simulates A using each bit string as the string of random bits.
To construct the function h that makes A1 correct, we simply choose a random one and notice that on
any concrete graph, A1 fails to solve Π with probability at most 2´Ωpn2q with the randomness over the choice
of h. This is because on any concrete graph, A1 with random h is equivalent to running A. But notice that
the number of distinct graphs on n vertices labeled with polynomial identifiers is 2Opn2q ¨ pnCqn “ 2Opn2q.
Hence, choosing the failure probability small enough, we can union-bound over all distinct labeled graphs
and still get that random h works, with positive probability. We thus conclude that for some h, A1 is a valid
deterministic algorithm for Π, as needed.
As a nice corollary, we are getting a very precise understanding of what is happening for the random-
ized round complexity of Lovász local lemma: On one hand, we have seen a randomized algorithm with
round complexity poly log logpnq (Theorem 2.12) that used a deterministic algorithm with round complexity
poly logpnq (Theorem 2.10) as a subroutine. But we can now see that any poly log logpnq round randomized
algorithm would imply a poly logpnq-round deterministic one via Theorem 2.21. A similar observation applies
not just for the local lemma, but for many other problems with randomized algorithms based on shattering
(see Section 1.6). This explains why in local complexity deterministic algorithms are a big deal – not only
they are used as subroutines of randomized algorithms, but we in fact understand that to make progress in
the randomized world, progress in the deterministic world is often necessary.
2.3.2
Speedups
While slowdowns are very useful, the real fun starts when we try to speed up algorithms by lying to them
that the size of the graph is smaller than it actually is. In fact, what can possibly go wrong if we tell an
algorithm that the size of the graph is constant, i.e., we claim that n “ Op1q? As it turns out, not much!
One potential problem is that the algorithm may find out that its tpnq-hop neighborhood contains more
than n nodes and “crash”. The other problem is that the algorithm now requires very small identifiers (if we
started with a deterministic algorithm) or that the failure probability of the algorithm increased to constant
(if we started with a randomized one). This is where our story connects with our discussions of coloring and
Lovász local lemma.
Theorem 2.22 (Chang and Pettie [CP19] and Chang, Kopelowitz, and Pettie [CKP19]). Let A be a local
algorithm for a local problem Π with round complexity tpnq “ oplog nq. Then there is a local algorithm A1
solving Π such that
1. If A was deterministic, so is A1 and its round complexity is Oplog˚ nq.
31Their technique is similar to Adelman’s theorem that proves that BPP Ď P{poly. See [AB09, Theorem 7.14].
28

--- Page 29 ---
A
The size of the graph is n0.
3
1
1
14
33
15
15
2
14
4
4
5
18
6
7
7
8
8
20
11
13
11
1
3
2
4
16
17
5
6
19
8
9
10
21
Figure 9: To speed up an algorithm A, we tell it that the size of the graph is some constant n0, whatever the true
size n is. In this case, the round complexity of the algorithm becomes 2 (see the smaller ball in the picture) and we
assume that the checkability radius of the local problem solved by A is 1.
The algorithm A assumes that the identifiers are unique numbers of size up to nOp1q
0
. Since n " n0, we cannot supply
such identifiers. However, we notice that if A is supplied with nOp1q
0
-sized identifiers that are unique only in every
ball of radius 3 (see the larger ball in the picture), the algorithm still has to work. This is because a failure of A
around some node u implies a failure of A on the graph Bpu, 3q which has size at most n0 and is labeled with unique
identifiers.
2. If A was randomized, so is A1 and its round complexity is the same as the randomized complexity of
solving relaxed Lovász local lemma, i.e., it is rO
`
log4 logpnq
˘
.
The theorem holds for the class of bounded degree graphs and any of its subclasses closed on taking
subgraphs and adding isolated vertices. More generally, for round complexities defined relative to a subclass
of bounded degree graphs of restricted growth, the complexity tpnq needs to be such that we always have
|Bpu, tpnqq| “ opnq for any node u.
Proof. Let Π be a local problem with a checkability radius of r and A be a deterministic (randomized) local
algorithm for Π. We will assume that the identifiers are coming from a range rnCs (alternatively, the failure
probability is 1{nC) for sufficiently large C. We will view A as a sequence A1, A2, . . . , and we start by
choosing n0 to be a large enough constant so that
∆0 ` ∆1 ` ¨ ¨ ¨ ` ∆tpn0q`r ď n0.
(3)
We notice that such an n0 exists by the requirement tpnq “ oplog nq. Our algorithm A1 will simulate An0
for any input n (for n ă n0 we define A1
n “ An).
Let us first handle the case of deterministic algorithms (see Figure 9). There, A1 needs to supply identifiers
to its simulation of An0. This is done as follows. We compute a p∆pG1q ` 1q-coloring of the power graph
G1 “ G2ptpn0q`rq such that the number of colors used is ∆pG1q ` 1 “ ∆Optpn0q`rq ď nC
0 where we used that
C is large enough. We use those colors as identifiers for our simulation of An0. This finishes the description
of A1.
On one hand, the round complexity of the overall algorithm is Oplog˚ nq on bounded-degree graphs. On
the other hand, suppose that A1 fails to solve the problem Π at some node u. We notice that Equation (3)
yields that the ptpn0q ` rq-hop neighborhood of u contains at most n0 nodes. Moreover, this neighborhood
is colored by A1 with unique colors from the range rnC
0 s. Recall that An0 is defined on neighborhoods with
at most n0 nodes labeled with identifiers from rnC
0 s. Thus the algorithm A1 is well-defined. Additionally,
a failure of A1 at u would imply a failure of A on a neighborhood of size at most n0 labeled with some
29

--- Page 30 ---
unique identifiers from rnC
0 s. Adding isolated vertices to that neighborhood to make its size n0, we reach a
contradiction with An0 being correct on n0-sized instances.
We handle the case of randomized algorithms similarly: We again try to simulate An0 for large enough
n0. We notice that we do not need to supply any identifiers in the simulation. However, if we simply simulate
A, we fail to solve Π at any fixed vertex u with probability 1{nC
0 as this is the failure probability of An0.
Thus, we instead formulate the process of simulating A as an instance of Lovász local lemma on a new
variable-event graph G1 as follows. Any original vertex u of the input graph G will be thought of as two
new vertices in G1. One vertex, ur.v, is a random-variable vertex, and it corresponds to the random string
at u. The other vertex, ub.e., corresponds to the event that if we run An0 at u and use the random strings
sampled from the random-variable vertices vr.v. P Bpub.e., tpn0qq, An0 fails to solve Π at u.
We notice that the event at ub.e. depends only on the ptpn0q ` rq-hop neighborhood of u in G. Thus the
degree of this local-lemma instance (in the sense of its dependency-graph formulation) is at most ∆0 ` ∆1 `
¨ ¨ ¨ ` ∆tpn0q`r which is in turn at most n0 by Equation (3). On the other hand, the probability of each bad
event is at most 1{nC
0 . We can thus formulate the simulation of An0 as an instance of a C-relaxed local
lemma. For large enough C, we can then apply Theorem 2.12 to solve that instance.
Finally, we notice that both in the deterministic and the randomize case, we can generalize the requirement
tpnq “ oplog nq to requiring that t satisfies for each u that |Bpu, tpnqq| “ opnq.
We note that in the statement of Theorem 2.22, we do not literally require tpnq “ oplog nq (or |Bpu, tpnqq| “
opnq), it should just be that for some large enough n0, we have tpn0q ď ε log n0, where ε is some small constant
which is a function of ∆, r, and C.
Additional intuition yielded by the proof: The proof of Theorem 2.22 tells us a bit more: Basically, it
allows us to think of local problems with deterministic round complexity oplog nq or, equivalently, Oplog˚ nq,
as “those problems that can be solved in a constant number of rounds, after we compute a distance coloring”.
Moreover, the problems with randomized round complexity oplog nq or, equivalently poly log log n, can be
thought of as “those problems that we can view as an instance of the local lemma”.
Problems with deterministic round complexity oplog nq can be, in fact, solved in constantly
many rounds, after a suitable coloring used as “fake identifiers” is computed.
Problems with randomized round complexity oplog nq can be formulated as instances of poly-
nomially relaxed Lovász local lemma.
Speedup below log˚ n: We will next sketch how one can speed up algorithms with round complexity
oplog log˚ nq to complexity Op1q. Why the weird complexity oplog log˚ nq? The following speedup argument
relies more on the volume than on the radius32, so the importance of radius oplog log˚ nq is that the number
of nodes the algorithm sees is ∆oplog log˚ nq “ oplog˚ nq. The log˚ n volume is then the right threshold for
which we can argue that any deterministic algorithm can be turned into a drastically simpler order-invariant
algorithm. 33
An order-invariant algorithm is a deterministic local algorithm with an additional restriction: it does
not have direct access to the identifiers written on the nodes; it only knows their order, meaning that it
can only compare their relative size. A bit more formally, while an input to a classical local algorithm is a
graph G together with a map f : V pGq Ñ rnOp1qs that maps vertices to unique identifiers, an input to an
order-invariant algorithm is G together with a function f 1 : V pGq ˆ V pGq Ñ tă, ąu that is consistent with
a total linear order on V pGq and that can tell the algorithm for each pair of nodes which one is larger. Of
course, tpnq-round algorithm run at u only has access to f 1 restricted to Bpu, tpnqq ˆ Bpu, tpnqq.
For example, in the setup of Theorem 2.8 where we worked with an oriented path with increasing labels,
an order-invariant algorithm would see the same input order at every vertex.
This already shows that
order-invariant algorithms struggle to solve interesting local problems on graphs that are paths.
32Compare with Theorem 3.2 classifying volume complexities where we have oplog˚ nq speedup instead.
33While the name order-invariant suggests that the algorithm may not care about the order of identifiers in some way, it is
the other way around, the algorithm cares only about the order of the identifiers in its neighborhood. That is, the algorithm
is comparison-based.
30

--- Page 31 ---
Theorem 2.23 (Naor and Stockmeyer [NS95] and Chang, Kopelowitz, and Pettie [CKP19]). Let A be a
deterministic local algorithm for a local problem Π with round complexity oplog log˚ nq. Then, there is a
deterministic local algorithm A1 solving Π with local complexity Op1q.
The theorem holds for any subclass of bounded-degree graphs closed on taking subgraphs and adding isolated
nodes.
Proof Sketch. We will sketch how any deterministic local algorithm A with round complexity tpnq “ oplog log˚ nq
can be turned into an order-invariant algorithm A1, using the hypergraph Ramsey theorem34. Fix an algo-
rithm A and consider the set B “ rnOp1qs of identifiers that A expects on input. Next, consider any subset
S Ď B of size p2∆qtpnq “ oplog˚ nq. Here, we have chosen the function p2∆qtpnq because it upper-bounds the
maximum number of nodes in any tpnq-hop neighborhood that A can see as its input.
Next, let us define the color of S. To do so, first consider the set H of all possible tpnq-hop neighborhoods.
Moreover, for each (unlabeled) neighborhood H P H, consider all of at most |S|! ways in which the identifiers
from S can be assigned to the vertices of H. For each labeled neighborhood, we record the output of A when
it is run on it, and the color of S is defined to be the complete list of all such outputs.
We note that the number of possible colors of a set S Ď B is relatively small, and in particular it can be
upper-bounded by 22Oplog˚ nq2
. Recalling that we use r to denote the checkability radius of Π, we aim to find
a medium-sized set M Ď B of size p2∆qtpnq`r “ oplog˚ nq such that all subsets S Ď M have the same color.
The known bounds for hypergraph Ramsey numbers [GRS91, §1, Theorem 2] allow us to conclude that B is
large enough to always contain such a set M.
We notice that the algorithm A behaves in the order-invariant way if the input identifiers are coming
from the set M. This allows us to define an order-invariant tpnq-round algorithm A1 for Π as follows. Given
an input order on the vertices of Bpu, tpnqq, the algorithm A1 chooses an arbitrary subset S Ď M and maps
the identifiers in S to vertices of Bpu, tpnqq in the unique order-preserving way. Concretely, whenever v1 ă v2
according to the input order, we also have IDpv1q ă IDpv2q. Our algorithm then simply outputs what A
would output on this input. This finishes the description of A1.
To see that we are on the right track, we first notice that it does not matter which subset S Ď M we
choose above; since all subsets S have the same color, they all lead to the same output.
Next, to see that A1 is valid, we assume for contradiction that it fails at a vertex u in some graph G
equipped with some input order. We consider the ball Bpu, tpnq`rq and the restriction of the input order to
this ball. Consider the following thought experiment: In the ball Bpu, tpnq ` rq, we replace the input order
with identifiers from M. We do it in the unique way that preserves the original order; that is, if v1 ă v2 in
the original order, then IDpv1q ă IDpv2q. We observe that for any vertex v P Bpu, rq, the algorithm A1 run
on v with access to the original input order returns the same as A run on v with access to the identifiers
from M. This is because A1 returns the same answer, whatever identifiers from M are chosen to replace the
input order.
But this means that the original algorithm A also fails at the node u for the specific choice of identifiers
from M above. After adding isolated nodes to the ball Bpu, tpnqq equipped with these identifiers, we find a
graph on n vertices where A fails and we thus reach a contradiction.
Finally, let us contemplate the proof of Theorem 2.22 again. The only reason why we could speedup
oplog nq-round deterministic algorithm only to Oplog˚ nq instead of Op1q was the necessity to compute a
coloring that served as “fake” identifiers supplied to the simulation of an algorithm An0. But for order-
invariant algorithms, this is not necessary. We can simply give An0 exactly the same order as the order that
appears on input; thus order-invariant algorithms can be sped up to complexity Op1q and this finishes the
proof.
Tower-sized identifiers: We can wonder what would happen if we wanted to make the above proof
of Theorem 2.23 work for all deterministic local algorithms, not just those that encounter only oplog˚ nq
vertices.
This would force us to change the small-set size from oplog˚ nq to n in the proof.
Since the
hypergraph Ramsey numbers grow roughly as a tower function of the small-set size, this means that to make
the proof work, we would have to start with unique identifiers from the range which is contains numbers
34Recall that in hypergraph Ramsey theorem we have a big set B, we color its small subsets S and we want to find a
medium-sized set M such that all its small subsets S Ď M have the same color.
31

--- Page 32 ---
as large as the tower function of n. The rest of the proof then goes through and allows us to speed up
oplog nq-round algorithms to Op1q-round order-invariant algorithms.
This observation nicely complements Theorem 2.7: While it is true that exponentially-, doubly-exponentially-
, etc. sized identifiers have the same power as polynomially-sized ones, there is a transition somewhere
around tower-function-sized identifiers. From then on, deterministic algorithms of oplog nq complexity with
such huge identifiers can be turned into order-invariant ones. In other words, the identifiers are so large that
no oplog nq-round algorithm can extract any meaningful information from them other than their relative
order.
2.4
Classification of Local Problems
We can now put all the pieces together and prove Theorem 2.1. Let’s restate it here for convenience.
Theorem 2.1 (Classification of local problems with oplog nq complexity on bounded degree graphs). Let
us fix any ∆and the class of graphs of degree at most ∆. Then, any local problem with randomized round
complexity oplog nq has one of the following three round complexities.
1. Order-invariant regime: The problem has Op1q deterministic and randomized round complexity.
2. Symmetry-breaking regime: The deterministic and randomized round complexity of the problem lies
between Ωplog log˚ nq and Oplog˚ nq (both the deterministic and the randomized complexity is the same
function).
3. Lovász-local-lemma regime: The problem has deterministic round complexity between Ωplog nq and
rOplog4 nq. Its randomized round complexity is between Ωplog log nq and rOplog4 log nq.
Proof. Let Π be any local problem of randomized local complexity tpnq “ oplog nq. We can use Theorem 2.22
to formulate Π as an instance of Lovász local lemma. This instance is then solved either with the determin-
istic rOplog4 nq-round algorithm from Theorem 2.10, or the randomized rOplog4 log nq-round algorithm from
Theorem 2.12.
Next, let us assume that the randomized round complexity of Π is even oplog log nq. Then, we can use
the derandomization of Theorem 2.21 to conclude that the deterministic round complexity is oplog nq. This
allows us to use the speedup theorem of Theorem 2.23 to conclude that the deterministic round complexity
of Π is Oplog˚ nq. Moreover, we notice that for any increasing function tpnq “ Oplog˚ nq, we have tp2Opn2qq “
Optpnqq; this means that the derandomization from Theorem 2.21 tells us that randomized and deterministic
round complexities of Π are the same.
Finally, assume that the randomized local complexity of Π is even oplog log˚ nq.
Then, we can use
Theorem 2.23 to find an order-invariant constant-round local algorithm for Π via Theorem 2.23.
Local problems with complexities below oplog nq are of three types:
1. Those that can be solved in constant rounds by order-invariant algorithms,
2. those that are roughly as hard as the basic symmetry-breaking problems such as coloring
or maximal independent set,
3. those that can be viewed as instances of Lovász local lemma.
Improvements to Theorem 2.1: Can we improve Theorem 2.1? The conjecture of Chang and Pettie
[CP19] (Problem 2.14) suggests that in the local lemma regime, we may get rid of the polynomial gap between
the lower and upper bounds. According to our current knowledge, there could be a local problem with
deterministic and randomized round complexities tdpnq, trpnq for any tdpnq “ Ωplog nq, tdpnq “ rOplog4 nq,
trpnq “ Ωplog log nq, trpnq “ rOplog4 log nq, and tdpnq “ Optrp2nqq, where the last constraint follows from
Theorem 2.20.
On the other hand, it is known [Bal+18] that the (extremely narrow) regime between Ωplog log˚ nq and
Oplog˚ nq is densely populated by certain (artificial) local problems.
32

--- Page 33 ---
2.4.1
Sequential local complexities
Let us now discuss how sequential local complexities fit into the picture painted by Theorem 2.1. We will
first observe that the first two classes from our classification in Theorem 2.1, i.e., Op1q and Oplog˚ nq round
complexities, are equal to the class of problems solvable with the sequential local complexity is Op1q.
Theorem 2.24. On bounded degree graphs, local problems with round complexity Oplog˚ nq are exactly those
whose sequential local complexity is Op1q.
Proof sketch. On one hand, consider any local problem with constant sequential local complexity. We can
use Theorem 2.5 to simulate it with a distributed local algorithm in Oplog˚ nq rounds.
On the other hand, consider any local problem Π with local checkability r solvable in Oplog˚ nq round
complexity. Recall that the proof of Theorem 2.22 says that Π can in fact be solved with a local algorithm A
of round complexity t “ Op1q on any graph G if we are provided a proper coloring of a suitable power graph
G2pt`rq. Recall that p∆` 1q-coloring has sequential local complexity Op1q, meaning that we can construct
a sequential local algorithm of constant complexity for Π.
Next, we will show how our distributed speedup theorems imply speedups in the sequential world.
Theorem 2.25. Let A be a sequential local algorithm solving a local problem Π on bounded degree graphs.
Assume that either
1. A is deterministic and its sequential local complexity is oplog log nq,
2. or A is randomized and its sequential local complexity is oplog log log nq.
Then, there is a distributed local algorithm A1 that solves Π in Oplog˚ nq round complexity.
Proof. If A is a deterministic sequential algorithm of local complexity tpnq “ oplog log nq, we can simulate it
with a distributed local algorithm via Theorem 2.5. We get a deterministic algorithm with local complexity
∆Optpnqq ` Optpnq log˚ nq “ logop1q n “ oplog nq. Such an algorithm is then sped up to Oplog˚ nq complexity
using Theorem 2.22.
Similarly, if A is randomized sequential algorithm of local complexity oplog log log nq, Theorem 2.5 implies
that we get a randomized distributed local algorithm with logop1q log n “ oplog log nq round complexity. Such
an algorithm can then be derandomized by Theorem 2.21 into a deterministic algorithm of local complexity
oplog nq which is in turn sped up to Oplog˚ nq using Theorem 2.22.
Finally, we sketch how one can construct very fast sequential local algorithms for instances of the local
lemma.
Theorem 2.26. Let Π be a C-relaxed Lovász local lemma for sufficiently large C. Then, its deterministic se-
quential local complexity is rOplog4 log nq and its randomized sequential local complexity is rOplog4 log log nq35,
on bounded degree graphs.
Proof Sketch. To prove the first part of the theorem, we consider the randomized distributed local algorithm
for local lemma from Theorem 2.12. We turn it into a deterministic sequential local algorithm of the same
complexity by the derandomization result of Theorem 1.7.
To prove the second part of the theorem, we notice that our randomized distributed local algorithm from
Theorem 2.12 can certainly be implemented in the model of randomized sequential local algorithms. Recall
that the algorithm reduces an instance of the local lemma to instances on graphs of size Oplog nq, as proven
in Theorem 2.11. Then, the best deterministic algorithm is applied to those instances to finish the job.
While Theorem 2.11 is stated as reducing from C-relaxed local lemma with some large C to local lemma
with condition p ď 1{p3∆q, we can generalize it to show that starting with a very large C1, we can reduce
an instance of C1-relaxed local lemma to C-relaxed local lemma for C that is still arbitrarily large.
This allows us to run the deterministic sequential algorithm with complexity rOplog4 log nq constructed in
the first part of the proof instead of using the deterministic Oppoly log nq-round algorithm from Theorem 2.10.
The final randomized sequential local complexity is thus rOplog4 log log nq.
35It is an interesting exercise to open up the proof that the randomized sequential local complexity of local lemma is
Θppoly log log log nq and try to think of theorems we have seen so far that do not go into that proof.
33

--- Page 34 ---
We note that for problems like sinkless orientation for which an Oplog log nq-round randomized algorithm
is known [GHK18], the proofs of above Theorems 2.25 and 2.26 imply tight bounds of Θplog log nq and
Θplog log log nq deterministic and randomized sequential local complexity on bounded degree graphs. In the
case of sinkless orientation, the same bounds are also known even on unbounded degree graphs [GHK18]. If
the conjecture of Chang and Pettie [CP19] (Problem 2.14) is true, then there is no gap between Theorems 2.25
and 2.26.
We also note that Theorems 2.25 and 2.26 show that while one can turn randomized distributed local
algorithms into sequential deterministic ones via Theorem 1.7, it is not possible to turn randomized sequential
local algorithms into deterministic sequential local ones, without loss in their local complexity.
Putting everything together, we get the following refined classification theorem that also includes sequen-
tial local complexities.
Theorem 2.27 (Refined classification of local problems). Let us fix any ∆and any class of graphs G of
degree at most ∆that is closed under taking subgraphs and adding isolated nodes. Let tpnq be a function
such that for any node u in some graph in G we have |Bpu, tpnqq| “ opnq.
Then, any local problem with randomized round complexity at most tpnq has one of the following three
complexities.
1. Order-invariant regime: The problem has Op1q deterministic (or randomized) round complexity and
sequential local complexity.
2. Symmetry-breaking regime: The deterministic and randomized round complexity of the problem lies
between Ωplog log˚ nq and Oplog˚ nq (both the deterministic and the randomized complexity is the same
function). Moreover, the sequential local complexity is Op1q.
3. Lovász-local-lemma regime: The problem has the following complexities:
(a) deterministic round complexity is between Ωplog nq and rOplog4 nq,
(b) randomized round complexity and deterministic sequential local complexity is between Ωplog log nq
and rOplog4 log nq,
(c) randomized sequential local complexity is between Ωplog log log nq and rOplog4 log log nq.
Moreover, if any graph from the class satisfies that for any node u, we have |Bpu, rq| “ 2Opr0.249q, then there
are no local problems in the third class of problems.
The last part of the theorem follows by applying Theorem 2.22: We know that every local problem in
the local-lemma regime can be solved with a deterministic local algorithm of round complexity rOplog4 nq;
since 2p r
Oplog4 nqq
0.249
“ opnq, the speedup to Oplog˚ nq complexity can be applied. If the conjecture of Chang
and Pettie [CP19] (Problem 2.14) is true, we can get rid of the polynomial slack in the local-lemma regime
complexities and the whole local-lemma class of problems is then empty for the class of subexponential
growth graphs (see Section 2.4.2).
Problem 2.28. Can local problem solvable with deterministic sequential local complexity oplog nq be sped up
to poly log log n deterministic sequential complexity (i.e., to the local-lemma regime)? What about problems
with randomized sequential local complexity oplog nq?
2.4.2
Classification of Local Problems for Concrete Graph Classes
This section compiles results from a long line of work trying to extend the classification of local problems on
bounded-degree graphs, i.e., Theorem 2.1, to more specific graph classes. For some simple graph classes, we
now have an almost complete understanding of the local complexity classes that go even beyond the log n
local complexity threshold.
Locally checkable labeling problems: The theorems below are proven for the so-called locally checkable
labeling problems. These are local problems that additionally allow one of the finitely many input colors
on each node of the input graph. For example, a list coloring is an example of a locally checkable labeling
problem.
34

--- Page 35 ---
Definition 2.29. A locally checkable labeling problem (LCL) Π is formally a quintuple pSin, Sout, r, ∆, Pq.
Here, Sin is the finite set of input labels, Sout is the finite set of output labels, and P is the set of allowed
neighborhoods: Each neighborhood has maximum degree ∆, radius r, and each node is labeled with a label
from Sin and Sout. Given an input graph of degree at most ∆and any input coloring of its nodes with Sin,
the task is to find an output coloring by colors from Sout so that the r-hop neighborhood of each node is in
P.
We did not have to distinguish between our definition of a local problem from Definition 1.1 and the
locally checkable labelings since, in the general graph classes like the class of all graphs or all bounded-degree
graphs, it is straightforward to encode input labels as a part of the input graph. We thus chose the simpler
definition that also allowed us to talk about local problems even outside of the setup of bounded-degree
graphs. In the following theorems, especially for very restrictive classes like paths or grids, the difference
between the two definitions matters, since the possibility of allowing inputs may substantially enlarge the
number of possible local problems.
In the following theorems, we will always implicitly assume that they are for solvable locally checkable
labelings, i.e., for problems where the solution is always guaranteed to exist. Otherwise, the problem does
not have a well-defined local complexity class.
Computational aspect: We note that an additional dimension for all classification results below is the
computational complexity of the classification problem, where the input is a description of locally checkable
labeling, and the output is which class it belongs to. On the one hand, it is known that the classification
problem is decidable on paths, albeit PSPACE-hard [Bal+19a]. On the other hand, the classification problem
is undecidable even for grids [Bra+17]. The decidability on trees is open; see Problem 2.34. We will not
discuss this dimension in the following theorem statements for brevity.
Additional remarks: We list the concrete classification theorems below.
Unless stated otherwise, the
deterministic and the randomized round complexity of the problem is always the same. We are always citing
papers proving results specific to the given graph class, for example, general speedup and slowdown theorems
of Chang and Pettie [CP19] and Chang, Kopelowitz, and Pettie [CKP19] are as a rule of thumb always an
important part of the proof. Also, not all the papers we cite prove a part of the given theorem. Some of
them only provide building blocks, analyze the computational complexity of the classification, etc.
List of known classifications: Let us now list known classification theorems on concrete graph classes.
Theorem 2.30 (Classification of local problems on paths [Bra+17; Bal+19a]). Any solvable locally checkable
labeling problem on oriented or unoriented paths with inputs has one of the following round complexities:
1. Op1q,
2. Θplog˚ nq,
3. Θpnq.
Theorem 2.31 (Classification of local problems on grids [NS95; Bra+17; CKP19; GRB22]). Any solvable
locally checkable labeling problem on d-dimensional oriented grids36 has one of the following local complexities:
1. Op1q,
2. Θplog˚ nq,
3. Θpn1{dq.
We note that on unoriented grids, the full classification is not known [GRB22].
Theorem 2.32 (Classification of local problems on bounded-degree rooted regular trees [Bal+21b; Bal+22a]).
Any solvable locally checkable labeling problem on bounded-degree rooted regular trees37 has one of the fol-
lowing round complexities:
36The edges of the input grid are consistently oriented.
37Edges are oriented such that every vertex has at most one ingoing edge.
35

--- Page 36 ---
1. Op1q,
2. Θplog˚ nq,
3. Θplog nq,
4. Θpn1{kq for some k P N.
Theorem 2.33 (Classification of local problems on bounded-degree trees [MR89; CP19; Bal+18; Cha20;
Bal+20b; GRB22; Bal+22a; Bal+20a]). Any solvable locally checkable labeling problem on trees has one of
the following local complexities:
1. Op1q,
2. Θplog˚ nq,
3. Θplog log nq randomized, Θplog nq deterministic,
4. Θplog nq (both randomized and deterministic),
5. Θpn1{kq for some k P N.
Problem 2.34. Given an input locally checkable labeling problem on bounded-degree trees, is it decidable
which class in Theorem 2.33 it belongs to?
More Classifications: It is an intriguing question of how far these classifications can be extended, see e.g.
the recent work extending the theory to minor-closed classes [Cha24] or extending the theory to unbounded-
degree graphs [LPS23].
Another interesting class is the class of subexponential growth graphs, i.e., the class of bounded degree
graphs where for every ε ą 0 we can find r such that |Bpu, rq| ď p1 ` εqr 38. In this class of graphs, we
can apply Theorem 2.22 to speed up deterministic algorithms of complexity Oplog nq (instead of oplog nq)
to Oplog˚ nq. If the conjecture of [CP19] (Problem 2.14) is true, this has an interesting corollary: the local
lemma regime from the classification theorem of Theorem 2.1 would then not be present in this class of
graphs and there would only two classes of local problems there (see Theorem 2.27). This leads to the
following special case of Problem 2.14:
Problem 2.35. Is there a C such that all instances of the C-relaxed Lovász local lemma can be solved with
round complexity Θplog˚ nq on any class of graphs of subexponential growth?
Some implications of a positive answer to this problem are known [Csó+22; BD23].
3
Applications
While the previous two sections, Sections 1 and 2, discussed the general theory of local algorithms, the
following section considers various popular models of distributed, parallel, or sublinear algorithms, as well
as the field of descriptive combinatorics, and briefly discusses how techniques from local algorithms can help
there, discussing a few cherry-picked examples per section. These sections are heavily influenced by the
author’s particular interests; a different author would choose different applications.
3.1
Distributed Computing (CONGEST)
The CONGEST model [Pel00] is a model of distributed computing that is extremely tightly connected to
local algorithms39 Starting from the definition of a local algorithm as a message-passing protocol between
nodes in a graph, the CONGEST model adds an additional requirement that each message is supposed to
38Formally, this is a family of classes, with one class for each possible dependency r “ rpεq.
39Local algorithms are often referred to as “distributed algorithms in the LOCAL model of distributed computing”.
36

--- Page 37 ---
be small. In particular, it should fit into Oplog nq bits. For example, a node can send its unique identifier in
one round.
Many local algorithms in the literature are in fact stated as CONGEST algorithms since a number of
local algorithms are readily implemented in the CONGEST model. However, not all of them. For example,
the problem of counting for each node the number of triangles that contain it is a trivial problem for local
algorithms but a very complex problem in the CONGEST model, where it requires polynomially many
rounds [CPZ19; CS19]. The general derandomization technique of Ghaffari, Harris, and Kuhn [GHK18]
from Theorem 1.8 is also not directly applicable to the CONGEST model, since computing conditional
expectations in a neighborhood of a node requires collecting a lot of information from that neighborhood.
However, the general approach is still helpful, and it was used to derandomize concrete problems like maximal
independent set [CPS17a] or ∆` 1-coloring [BKM20].
It is an interesting question for which classes of graphs the definitions of local and CONGEST algorithms
coincide for local problems. It is known that this is the case for local problems on trees [Bal+21c].
3.2
Local Computation Algorithms and the Volume Model
The model of local computation algorithms [Rub+11; Alo+12], often denoted as LCA, is a model of sublinear
algorithms closely related to the local model. We will first explain its variant, known as the Volume model
by Rosenbaum and Suomela [RS20]. This model is very similar to local algorithms, but we measure the
volume instead of the radius. A volume algorithm run at a node u starts with a set S0 “ tuu and in the
i-th step, the algorithm can pick a node ui P Si and an arbitrary index 1 ď j ď d where d is the degree of
ui. Then, it learns the identifier of the j-th neighbor v of ui. We then set Si`1 “ Si Y tvu. The volume
complexity of the algorithm is the number of queries it makes until it decides to finish and output the label
for u.
In particular, we note that for graphs of maximum degree ∆, any tpnq-round local algorithm can be
turned into a volume algorithm of complexity p2∆qtpnq as the volume algorithm at u can simply query all
the nodes in the tpnq-hop neighborhood of u [PR07].
A local computational algorithm may have several definitions. The stateless local computation algorithm
is defined as follows: we start with the definition of the volume model and add the additional requirement
that the nodes start with unique identifiers from the range rns, even for randomized algorithms. In each
query, the algorithm can additionally ask for the node with the identifier j for any 1 ď j ď n. The node ui
with identifier j is then added to the set of already seen nodes Si. That is, the algorithm can use additional
global queries that are, however, “blind”.
It is unclear whether global queries can help with solutions to local problems. We know that they do not
help for very fast randomized local computation algorithms [Göö+16].
Problem 3.1. Is there a local problem that distinguishes (either randomized or deterministic) Local compu-
tation algorithms and Volume models with respect to a natural class of graphs?
As an example problem considered in the LCA model, there is a long line of work on local computation
algorithms for maximal independent set and related problems [NO08; YYI09; Ona+12; Beh22; Rub+11;
Alo+12; LRY15; Gha16; RV16; GU19; Gha22] culminating with the randomized algorithm of Ghaffari
[Gha22] with volume complexity polyp∆log nq.
For constant degree graphs, we can try to prove classification results similar to the classification of local
problem complexities from Theorem 2.1. We have some understanding of the volume complexities of the
three important local complexity classes from Theorem 2.1:
Theorem 3.2 ([PR07; EMR14; RS20; GRB22; BGR21]). In the class of bounded-degree graphs, each local
problem satisfies the following:
1. If its round complexity is Op1q (order-invariant regime), then its randomized/deterministic volume
complexity is Op1q.
2. If its randomized/deterministic round complexity is ωp1q and Oplog˚ nq (symmetry-breaking regime),
its randomized/deterministic volume complexity is Θplog˚ nq.
37

--- Page 38 ---
3. If its randomized local complexity is ωplog˚ nq but oplog nq (Lovász local lemma regime), its randomized
volume complexity is between Ωp?log nq and Oplog nq.
We note that as far as we know, all local problems in the local-lemma regime have randomized volume
complexity of Θplog nq. In particular, sinkless orientation has this randomized volume complexity [BGR21].
Problem 3.3 (See Conjecture 1.3 in [BGR21]). Is it true on bounded degree graphs that local problems from
the local-lemma regime have randomized volume complexity Θplog nq?
We also note that in the model of deterministic volume complexity where the identifiers come from expo-
nential, instead of polynomial range, we can prove that only the volume complexities Op1q, Θplog˚ nq, Θpnq
are possible [BGR21]. The same could be the case also for the standard, polynomial-range, identifiers.
Problem 3.4. Are there any local problems such that their deterministic volume complexity (with polynomial-
sized identifiers) on bounded degree graphs is ωplog˚ nq but opnq?
Equivalently, we could have asked whether there is a local problem whose deterministic volume complexity
is different for polynomial-sized and exponential-sized identifiers.
3.3
PRAM
PRAM is a classical model of parallel algorithms studied extensively in the past 40 years [JáJ92]. It simplifies
the complexity of practical parallel computing by assuming a simple model of a machine with multiple
processors sharing a common memory. There are two complexity measures: work, i.e., the total number of
instructions made by all processors together throughout the execution, and depth, i.e., the number of rounds
necessary to finish the computation in the case that the machine is equipped with as many processors as the
algorithm requires.
Many techniques developed for distributed and local algorithms are useful in the design of parallel algo-
rithms. As an example application for a local problem, Ghaffari and Haeupler [GH21] develop a randomized
algorithm for maximal independent set on the so-called EREW variant of the PRAM model with the optimal
depth Oplog nq and Opm log2 nq work, building on top of the local maximal independent set algorithm of
Ghaffari [Gha16].
As another example application for a non-local problem, we note that one can generalize deterministic
local algorithms for network decompositions discussed in Section 1.5 to get various clustering results for
weighted undirected graphs like the following one.
Theorem 3.5 (Deterministic low-diameter clustering [Roz+22a]). Let G be a graph and w its nonnegative
weights. Then, there is a parallel algorithm with rOpm`nq work and rOp1q depth such that, given a parameter
R ą 0, it splits vertices of G into clusters such that
1. Each cluster has weighted diameter rOpRq,
2. The total weight of edges that cross between different clusters is at most
1
R
ř
ePEpGq wpeq.
Variants of this clustering result can be used for the design of deterministic parallel algorithms for the
approximate shortest path problem or various metric embedding problems [Roz+22b; Roz+22a].
3.4
Massively Parallel Computing (MPC)
The final parallel model we discuss is the model of Massively parallel computing (MPC) [KSV10], the
theoretical model behind the popular programming framework MapReduce and its variants.
While the
previous PRAM model focuses on the total work done by processors and ignores the cost of communication,
the MPC model ignores the work done by processors and focuses on the communication cost.
Concretely, let us explain the so-called low-memory regime of MPC: At the beginning of any graph
algorithm, the edges of the input graph are split into many machines, each capable of storing Opnεq bits in
its memory. In one round, each machine can perform an arbitrary computation on its edges, and then it
sends arbitrary information to any of its neighbors (the total information sent and received per machine is
Opnεq). We measure the number of rounds until the solution is computed.
38

--- Page 39 ---
Chang, Fischer, Ghaffari, Uitto, and Zheng [Cha+19a] constructed a randomized massively parallel
algorithm for ∆`1-coloring that works in Oplog log log nq rounds by simulating the fastest randomized local
algorithm for coloring of round complexity poly log log n (see Section 3) with exponential speedup. This result
is complemented by the work of Ghaffari, Kuhn, and Uitto [GKU19] that showed that this result cannot be
improved, conditioned on a certain conjecture. Notice how understanding where the three logarithms are
coming from requires an extensive understanding of coloring with local algorithms: The way we arrive at
this complexity is that, first, starting with the trivial constant-round sequential local algorithm for coloring,
we turn it into a deterministic distributed poly log n-round local algorithm using the general translation of
Theorem 1.4. Next, this algorithm can be turned into an exponentially faster randomized algorithm using
the shattering technique [CLP18]. Finally, this randomized algorithm is simulated, again with exponential
speedup, in the massively parallel model.
There is also a line of work aiming to extend the classification of local problems to the massively parallel
algorithms model, though the complexity landscape there is currently much less understood [Bal+22b].
3.5
Descriptive Combinatorics
Descriptive combinatorics [Mik90; MU17; LAO17; DF92; MU16; Gab00; ASS99; Mar16; CM17; CGP24;
Csó+22; Ber23a] is an area at the intersection of combinatorics, measure theory, and set theory (see e.g. the
surveys [KM16; Pik21; Ber22b]). It studies graphs that arise when one manipulates uncountably-infinitely
large mathematical objects equipped with measure.
The main object of interest is a measurable graph.
Instead of a formal definition, let us discuss a particular example.
An example of a measurable graph: Consider a circle, i.e., a set of points of distance 1 from the origin
in the plane R2. A rotation of this circle by 1 radian counterclockwise induces a graph G0: We can draw
an oriented edge from each point v on the circle to the point v1 such that the rotation maps v to v1. This
graph has uncountably many connected components, each of which is a doubly-infinite oriented path: this is
because 1 is an irrational multiple of 2π and thus if we start “jumping” from v around the cycle with jumps
of length 1, we never return to v. Moreover, the standard Lebesgue measure on the circle is telling us which
subsets of vertices of G0 we are “allowed to talk about”. The graph G0, together with the measure on top of
it, is an example of a measurable graph.
Given a local problem Π, we can now ask whether it can be solved on a particular measurable graph.
For example, consider the following problem: Color each vertex of G0 with one of c colors such that the
coloring is proper and each set of vertices of the same color is measurable. It is a folklore fact that this type
of coloring is not possible with c “ 2 colors, but it is possible with c “ 3 colors (this is a special case of the
following Theorem 3.6).
Formal connection between the two worlds: There is a close connection between local algorithms
and descriptive combinatorics. Although this was to some extent understood earlier (see Elek and Lippner
[EL10], Lovász [Lov12, Chapter 23.3]), it was only a breakthrough paper of Bernshteyn [Ber23a] that first
realized the full power of the connection. Bernshteyn was able to prove general theorems of the type “if a
local problem Π can be solved with a local algorithm of round complexity Oplog˚ nq, then any measurable
graph admits a Borel solution to Π”.
As we did not define the terms “measurable graph” or “Borel solution” precisely, we will next only state
perhaps the simplest concrete example manifesting the connection, and we point an interested reader to the
recent survey of Bernshteyn [Ber22b] that covers this very exciting and recent topic in depth.
Theorem 3.6 ([GR21]). Let Π be any local problem (without inputs). Then, the following two statements
are equivalent:
1. There exists an opnq-round local algorithm solving Π on sufficiently large oriented cycles.
2. One can label each vertex of G0 with a label of Π such that all vertices satisfy the constraints of Π, and
for each label ℓ, the set of vertices with that label is Lebesgue-measurable40.
By now, we know of several more results of this type, both for general bounded-degree graphs [Ber23a;
Ber23b] and for special cases like trees [Bra+21] and grids [Gao+18; GR23].
40One can replace “Lebesgue measurable” with “a union of finitely many intervals” and the theorem still holds.
39

--- Page 40 ---
Transfer of techniques: Many recent results in the area of descriptive combinatorics are adopting tech-
niques from local algorithms that are, by now, familiar to readers of this text: network decomposition [BY23],
Lovász local lemma [Ber23a; Ber23b; Csó+22; BW23; BY23], derandomizations [Ber23b; GR23], ID graphs
[Bra+22; Bra+21], and others.
This connection also led to some progress in the area of local algorithms.
For example, Bernshteyn
[Ber22a] used ideas from a measurable Vizing theorem of Grebík and Pikhurko [GP20] to construct a fast
local algorithm for p∆`1q-edge coloring problem. Brandt, Chang, Grebík, Grunau, Rozhoň, and Vidnyánszky
[Bra+22] adapted a lower bound of Marks [Mar16] to give a different (and similarly simple) lower bound for
sinkless orientation from Theorem 2.15.
3.6
Other Models
There are many more models of local/distributed/parallel/sublinear computation that are, in one way or
another, related to local algorithms. In many of these models, it not only makes sense to try to solve concrete
problems but often, one can also hope that the theory of local algorithms, such as the classification of the
local problems on bounded-degree graphs, can be extended similarly to, e.g., Theorem 3.2.
Uniform algorithms: One favorite model of the author is the model of uniform local complexity.
In
this model, a randomized local algorithm does not know the size of the input graph, n. It simply looks at
larger and larger neighborhoods of a given vertex, until it decides that it has seen enough to compute the
output label at the node. This model was independently studied by local algorithms community [KSV12]
and community of probabilists [HSW17; Hol17; Spi20] where it is known as finitary factors of i.i.d.
In the oplog nq-local-complexity regime, uniform algorithms can be seen as a more powerful version of
classical local algorithms. This is because there are certain local problems such that their solution requires
a few nodes to see the whole graph, while most of the nodes can output their solution after seeing their
Op1q-radius neighborhood [GR23]. On the other hand, local problems solvable by uniform local algorithms
still often admit measurable solutions defined in descriptive combinatorics [GR21; GR23; Bra+22]. Thus,
uniform local algorithms can be seen as interpolating between the extremely clean picture painted by the
classification of oplog nq-round algorithms (Theorem 2.1), and the much less well-understood complexity
classes coming from descriptive combinatorics.
The connection between classical local algorithms and uniform ones would be much cleaner if the following
problem was resolved (see [Bra+22]):
Problem 3.7. Is there a C and a uniform randomized local algorithm on bounded degree graphs for C-relaxed
Lovász local lemma such that after poly log logp1{εq rounds, at least 1´ε fraction of nodes know the solution?
Other models: There are many more models of locality studied in the literature.
Let us list a sam-
ple of them.
The list includes the averaged local complexity [Feu17; BT19; CGP20; Bal+23a] (closely
connected to uniform algorithms), online local model [Akb+23; Cha+23; Akb+24], dynamic local model
[Akb+23; Akb+24], local mending model [MSV23], supported local model [SS13; Kor+21], quantum local
model [GKM09; LNR19; Coi+22; Akb+24], awake (energy) complexity [Cha+19b; Cha+20; CGP20; GP22;
GP23], local certification [GS11; FHK12; Fra+13; Feu21], finitely dependent colorings [HL+15; Hol23], or
computable combinatorics [QW22].
Final Remarks
This text aims to present the area of local algorithms in a way that highlights what the author sees as its
key aspect: Unlike typical subareas of computer science and discrete mathematics that are usually unified
by a set of useful techniques and important results, the area of local algorithms extends beyond this norm.
We have a clean theory of the model of local algorithms that leads to a clear complexity-theoretical picture.
We also understand that local algorithms have applications to a number of other models studied by the
broader algorithmic community. In this sense, local complexity is similar to much more established fields
like communication complexity. The author believes that the theory has the potential for diverse extensions
and applications and encourages the reader to identify and explore the next one.
40

--- Page 41 ---
References
[Akb+24]
Amirreza Akbari, Xavier Coiteux-Roy, Francesco d’Amore, François Le Gall, Henrik Lievonen,
Darya Melnyk, Augusto Modanese, Shreyas Pai, Marc-Olivier Renou, Václav Rozhoň, et al.
“Online Locality Meets Distributed Quantum Computing”. In: arXiv preprint arXiv:2403.01903
(2024).
[Akb+23]
Amirreza Akbari, Navid Eslami, Henrik Lievonen, Darya Melnyk, Joona Särkijärvi, and Jukka
Suomela. “Locality in Online, Dynamic, Sequential, and Distributed Graph Algorithms”. In:
50th International Colloquium on Automata, Languages, and Programming (ICALP 2023). Ed.
by Kousha Etessami, Uriel Feige, and Gabriele Puppis. Vol. 261. Leibniz International Pro-
ceedings in Informatics (LIPIcs). Dagstuhl, Germany: Schloss Dagstuhl – Leibniz-Zentrum für
Informatik, 2023, 10:1–10:20. isbn: 978-3-95977-278-5. doi: 10.4230/LIPIcs.ICALP.2023.10.
url: https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ICALP.2023.10.
[ASS99]
Alexander S. Kechris, Sławomir Solecki, and Stevo Todorčević. “Borel chromatic numbers.” In:
Adv. Math. 141.1 (1999), pp. 1–44.
[ABI86]
Noga Alon, Laszlo Babai, and Alon Itai. “A Fast and Simple Randomized Parallel Algorithm
for the Maximal Independent Set Problem”. In: Journal of Algorithms 7.4 (1986), pp. 567–583.
[Alo+12]
Noga Alon, Ronitt Rubinfeld, Shai Vardi, and Ning Xie. “Space-efficient local computation
algorithms”. In: Proceedings of the twenty-third annual ACM-SIAM symposium on Discrete
Algorithms. SIAM. 2012, pp. 1132–1139.
[AB09]
Sanjeev Arora and Boaz Barak. Computational complexity: a modern approach. Cambridge
University Press, 2009.
[Awe+89]
Baruch Awerbuch, Andrew V. Goldberg, Michael Luby, and Serge A. Plotkin. “Network Decom-
position and Locality in Distributed Computation”. In: Proc. 30th IEEE Symp. on Foundations
of Computer Science (FOCS). 1989, pp. 364–369.
[Bal+19a]
Alkida Balliu, Sebastian Brandt, Yi-Jun Chang, Dennis Olivetti, Mikaël Rabie, and Jukka
Suomela. “The Distributed Complexity of Locally Checkable Problems on Paths is Decidable”.
In: Proceedings of the 2019 ACM Symposium on Principles of Distributed Computing. PODC
’19. Toronto ON, Canada: Association for Computing Machinery, 2019, pp. 262–271. isbn:
9781450362177.
[Bal+22a]
Alkida Balliu, Sebastian Brandt, Yi-Jun Chang, Dennis Olivetti, Jan Studený, and Jukka
Suomela. “Efficient Classification of Locally Checkable Problems in Regular Trees”. In: 36th
International Symposium on Distributed Computing. 2022.
[Bal+20a]
Alkida Balliu, Sebastian Brandt, Yuval Efron, Juho Hirvonen, Yannic Maus, Dennis Olivetti,
and Jukka Suomela. “Classification of Distributed Binary Labeling Problems”. In: 34th Interna-
tional Symposium on Distributed Computing (DISC 2020). Schloss Dagstuhl-Leibniz-Zentrum
für Informatik. 2020.
[Bal+22b]
Alkida Balliu, Sebastian Brandt, Manuela Fischer, Rustam Latypov, Yannic Maus, Dennis
Olivetti, and Jara Uitto. “Exponential Speedup over Locality in MPC with Optimal Memory.”
In: 36th International Symposium on Distributed Computing: DISC 2022. Schloss Dagstuhl-
Leibniz-Zentrum für Informatik. 2022, pp. 9–1.
[Bal+19b]
Alkida Balliu, Sebastian Brandt, Juho Hirvonen, Dennis Olivetti, Mikaël Rabie, and Jukka
Suomela. “Lower bounds for maximal matchings and maximal independent sets”. In: Proc. Foun-
dations of Computer Science (FOCS). 2019.
[Bal+22c]
Alkida Balliu, Sebastian Brandt, Fabian Kuhn, and Dennis Olivetti. “Distributed ∆-coloring
plays hide-and-seek”. In: Proceedings of the 54th Annual ACM SIGACT Symposium on Theory
of Computing. 2022, pp. 464–477.
[Bal+21a]
Alkida Balliu, Sebastian Brandt, Fabian Kuhn, and Dennis Olivetti. “Improved distributed
lower bounds for MIS and bounded (out-) degree dominating sets in trees”. In: Proceedings of
the 2021 ACM Symposium on Principles of Distributed Computing. 2021, pp. 283–293.
41

--- Page 42 ---
[Bal+23a]
Alkida Balliu, Sebastian Brandt, Fabian Kuhn, Dennis Olivetti, and Gustav Schmid. “On the
Node-Averaged Complexity of Locally Checkable Problems on Trees”. In: 37th International
Symposium on Distributed Computing. 2023.
[BBO20]
Alkida Balliu, Sebastian Brandt, and Dennis Olivetti. “Distributed Lower Bounds for Ruling
Sets”. In: 61st IEEE Annual Symposium on Foundations of Computer Science, FOCS 2020,
Durham, NC, USA, November 16-19, 2020. 2020, pp. 365–376. doi: 10.1109/FOCS46700.
2020.00042. url: https://doi.org/10.1109/FOCS46700.2020.00042.
[Bal+21b]
Alkida Balliu, Sebastian Brandt, Dennis Olivetti, Jan Studený, Jukka Suomela, and Aleksandr
Tereshchenko. “Locally checkable problems in rooted trees”. In: Proceedings of the 2021 ACM
Symposium on Principles of Distributed Computing. 2021, pp. 263–272.
[Bal+20b]
Alkida Balliu, Sebastian Brandt, Dennis Olivetti, and Jukka Suomela. “Almost global problems
in the LOCAL model”. In: Distributed Computing (2020), pp. 1–23.
[Bal+20c]
Alkida Balliu, Sebastian Brandt, Dennis Olivetti, and Jukka Suomela. “How Much Does Ran-
domness Help with Locally Checkable Problems?” In: Proceedings of the 39th Symposium on
Principles of Distributed Computing. PODC ’20. Virtual Event, Italy: Association for Comput-
ing Machinery, 2020, pp. 299–308. isbn: 9781450375825.
[Bal+21c]
Alkida Balliu, Keren Censor-Hillel, Yannic Maus, Dennis Olivetti, and Jukka Suomela. “Locally
Checkable Labelings with Small Messages”. In: 35th International Symposium on Distributed
Computing. 2021.
[Bal+18]
Alkida Balliu, Juho Hirvonen, Janne H Korhonen, Tuomo Lempiäinen, Dennis Olivetti, and
Jukka Suomela. “New classes of distributed time complexity”. In: Proceedings of the 50th Annual
ACM SIGACT Symposium on Theory of Computing. 2018, pp. 1307–1318.
[Bal+23b]
Alkida Balliu, Janne H Korhonen, Fabian Kuhn, Henrik Lievonen, Dennis Olivetti, Shreyas Pai,
Ami Paz, Joel Rybicki, Stefan Schmid, Jan Studený, et al. “Sinkless Orientation Made Simple”.
In: Symposium on Simplicity in Algorithms (SOSA). SIAM. 2023, pp. 175–191.
[BKM20]
Philipp Bamberger, Fabian Kuhn, and Yannic Maus. “Efficient Deterministic Distributed Col-
oring with Small Bandwidth”. In: Proc. Principles of Distributed Computing (PODC). 2020, to
appear, arXiv:1912.02814.
[BE09]
Leonid Barenboim and Michael Elkin. “Distributed (delta+1)-coloring in linear (in delta) time”.
In: Proceedings of the 41st Annual ACM Symposium on Theory of Computing, STOC 2009,
Bethesda, MD, USA, May 31 - June 2, 2009. Ed. by Michael Mitzenmacher. ACM, 2009,
pp. 111–120. doi: 10.1145/1536414.1536432. url: https://doi.org/10.1145/1536414.
1536432.
[BE13]
Leonid Barenboim and Michael Elkin. Distributed Graph Coloring: Fundamentals and Recent
Developments. Morgan & Claypool Publishers, 2013.
[BEK15]
Leonid Barenboim, Michael Elkin, and Fabian Kuhn. “Distributed p∆` 1q-Coloring in Linear
(in ∆) Time”. In: SIAM Journal on Computing 43.1 (2015), pp. 72–95.
[Bar+16]
Leonid Barenboim, Michael Elkin, Seth Pettie, and Johannes Schneider. “The Locality of Dis-
tributed Symmetry Breaking”. In: Journal of the ACM 63 (3 2016), 20:1–20:45.
[BT19]
Leonid Barenboim and Yaniv Tzur. “Distributed symmetry-breaking with improved vertex-
averaged complexity”. In: 20th International Conference on Distributed Computing and Net-
working, ICDCN 2019. Association for Computing Machinery. 2019, pp. 31–40.
[Bec91]
József Beck. “An algorithmic approach to the Lovász local lemma. I”. In: Random Structures &
Algorithms 2.4 (1991), pp. 343–365.
[Beh22]
Soheil Behnezhad. “Time-optimal sublinear algorithms for matching and vertex cover”. In: 2021
IEEE 62nd Annual Symposium on Foundations of Computer Science (FOCS). IEEE. 2022,
pp. 873–884.
[Ber22a]
Anton Bernshteyn. “A fast distributed algorithm for (∆+ 1)-edge-coloring”. In: Journal of Com-
binatorial Theory, Series B 152 (2022), pp. 319–352.
42

--- Page 43 ---
[Ber22b]
Anton Bernshteyn. “Descriptive combinatorics and distributed algorithms”. In: NOTICES OF
THE AMERICAN MATHEMATICAL SOCIETY 69.9 (2022).
[Ber23a]
Anton Bernshteyn. “Distributed algorithms, the Lovász Local Lemma, and descriptive combi-
natorics”. In: Inventiones mathematicae 233.2 (2023), pp. 495–542.
[Ber23b]
Anton Bernshteyn. “Probabilistic constructions in continuous combinatorics and a bridge to
distributed algorithms”. In: Advances in Mathematics 415 (2023), p. 108895.
[BD23]
Anton Bernshteyn and Abhishek Dhawan. “Borel Vizing’s Theorem for Graphs of Subexponen-
tial Growth”. In: arXiv e-prints (2023), arXiv–2307.
[BW23]
Anton Bernshteyn and Felix Weilacher. “Borel versions of the Local Lemma and LOCAL algo-
rithms for graphs of finite asymptotic separation index”. In: arXiv preprint arXiv:2308.14941
(2023).
[BY23]
Anton Bernshteyn and Jing Yu. “Coarse embeddings into grids and asymptotic dimension for
Borel graphs of polynomial growth”. In: arXiv preprint arXiv:2302.04727 (2023).
[Bra+16]
S. Brandt, O. Fischer, J. Hirvonen, B. Keller, T. Lempiäinen, J. Rybicki, J. Suomela, and J.
Uitto. “A lower bound for the distributed Lovász local lemma”. In: Proc. 48th ACM Symp. on
Theory of Computing (STOC). 2016, pp. 479–488.
[Bra19]
Sebastian Brandt. “An automatic speedup theorem for distributed problems”. In: Proceedings
of the 2019 ACM Symposium on Principles of Distributed Computing. 2019, pp. 379–388.
[Bra+22]
Sebastian Brandt, Yi-Jun Chang, Jan Grebík, Christoph Grunau, Václav Rozhoň, and Zoltán
Vidnyánszky. “Local Problems on Trees from the Perspectives of Distributed Algorithms, Fini-
tary Factors, and Descriptive Combinatorics”. In: 13th Innovations in Theoretical Computer
Science Conference (ITCS 2022). Schloss Dagstuhl-Leibniz-Zentrum für Informatik. 2022.
[Bra+21]
Sebastian Brandt, Yi-Jun Chang, Jan Grebík, Christoph Grunau, Václav Rozhoň, and Zoltán
Vidnyánszky. “On homomorphism graphs”. In: arXiv preprint arXiv:2111.03683 (2021).
[BGR20]
Sebastian Brandt, Christoph Grunau, and Václav Rozhoň. “Generalizing the Sharp Threshold
Phenomenon for the Distributed Complexity of the Lovász Local Lemma”. In: Proceedings of
the 39th Symposium on Principles of Distributed Computing. 2020, pp. 329–338.
[BGR21]
Sebastian Brandt, Christoph Grunau, and Václav Rozhoň. “The randomized local computa-
tion complexity of the Lovász local lemma”. In: Proceedings of the 2021 ACM Symposium on
Principles of Distributed Computing. 2021, pp. 307–317.
[Bra+17]
Sebastian Brandt, Juho Hirvonen, Janne H. Korhonen, Tuomo Lempiäinen, Patric R.J. Östergård,
Christopher Purcell, Joel Rybicki, Jukka Suomela, and Przemysław Uznański. “LCL Problems
on Grids”. In: Proceedings of the ACM Symposium on Principles of Distributed Computing.
PODC ’17. Washington, DC, USA: Association for Computing Machinery, 2017, pp. 101–110.
isbn: 9781450349925.
[BMU19]
Sebastian Brandt, Yannic Maus, and Jara Uitto. “A sharp threshold phenomenon for the dis-
tributed complexity of the lovász local lemma”. In: Proceedings of the 2019 ACM Symposium
on Principles of Distributed Computing. 2019, pp. 389–398.
[BO20]
Sebastian Brandt and Dennis Olivetti. “Truly tight-in-δ bounds for bipartite maximal matching
and variants”. In: Proceedings of the 39th Symposium on Principles of Distributed Computing.
2020, pp. 69–78.
[CPS17a]
Keren Censor-Hillel, Merav Parter, and Gregory Schwartzman. “Derandomizing Local Dis-
tributed Algorithms under Bandwidth Restrictions”. In: 31st International Symposium on Dis-
tributed Computing (DISC 2017). Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik. 2017.
[Cha20]
Yi-Jun Chang. “The Complexity Landscape of Distributed Locally Checkable Problems on
Trees”. In: 34th International Symposium on Distributed Computing (DISC 2020). Ed. by Hagit
Attiya. Vol. 179. Leibniz International Proceedings in Informatics (LIPIcs). Dagstuhl, Germany:
Schloss Dagstuhl–Leibniz-Zentrum für Informatik, 2020, 18:1–18:17. isbn: 978-3-95977-168-9.
doi: 10.4230/LIPIcs.DISC.2020.18. url: https://drops.dagstuhl.de/opus/volltexte/
2020/13096.
43

--- Page 44 ---
[Cha24]
Yi-Jun Chang. “The Distributed Complexity of Locally Checkable Labeling Problems Beyond
Paths and Trees”. In: 15th Innovations in Theoretical Computer Science Conference (ITCS
2024). Schloss-Dagstuhl-Leibniz Zentrum für Informatik. 2024.
[Cha+20]
Yi-Jun Chang, Varsha Dani, Thomas P Hayes, and Seth Pettie. “The energy complexity of
BFS in radio networks”. In: Proceedings of the 39th Symposium on Principles of Distributed
Computing. 2020, pp. 273–282.
[Cha+19a]
Yi-Jun Chang, Manuela Fischer, Mohsen Ghaffari, Jara Uitto, and Yufan Zheng. “The Complex-
ity of (∆+ 1) Coloring in Congested Clique, Massively Parallel Computation, and Centralized
Local Computation”. In: Proceedings of the 2019 ACM Symposium on Principles of Distributed
Computing. ACM. 2019, pp. 471–480.
[CG21]
Yi-Jun Chang and Mohsen Ghaffari. “Strong-Diameter Network Decomposition”. In: Proceedings
of the 2021 ACM Symposium on Principles of Distributed Computing. PODC’21. Virtual Event,
Italy: Association for Computing Machinery, 2021, pp. 273–281. isbn: 9781450385480.
[CKP19]
Yi-Jun Chang, Tsvi Kopelowitz, and Seth Pettie. “An Exponential Separation between Ran-
domized and Deterministic Complexity in the LOCAL Model”. In: SIAM Journal on Computing
48.1 (2019), pp. 122–143.
[Cha+19b]
Yi-Jun Chang, Tsvi Kopelowitz, Seth Pettie, Ruosong Wang, and Wei Zhan. “Exponential
separations in the energy complexity of leader election”. In: ACM Transactions on Algorithms
(TALG) 15.4 (2019), pp. 1–31.
[CLP18]
Yi-Jun Chang, Wenzheng Li, and Seth. Pettie. “An Optimal Distributed p∆` 1q-Coloring
Algorithm?” In: Proc. 50th ACM Symp. on Theory of Computing (STOC). 2018.
[Cha+23]
Yi-Jun Chang, Gopinath Mishra, Hung Thuan Nguyen, Mingyang Yang, and Yu-Cheng Yeh.
“A Tight Lower Bound for 3-Coloring Grids in the Online-LOCAL Model”. In: arXiv preprint
arXiv:2312.01384 (2023).
[CP19]
Yi-Jun Chang and Seth Pettie. “A Time Hierarchy Theorem for the LOCAL Model”. In: SIAM
Journal on Computing 48.1 (2019), pp. 33–69.
[CPZ19]
Yi-Jun Chang, Seth Pettie, and Hengjie Zhang. “Distributed triangle detection via expander
decomposition”. In: Proceedings of the Thirtieth Annual ACM-SIAM Symposium on Discrete
Algorithms. SIAM. 2019, pp. 821–840.
[CS19]
Yi-Jun Chang and Thatchaphol Saranurak. “Improved distributed expander decomposition and
nearly optimal triangle enumeration”. In: Proceedings of the 2019 ACM Symposium on Princi-
ples of Distributed Computing. 2019, pp. 66–73.
[CGP20]
Soumyottam Chatterjee, Robert Gmyr, and Gopal Pandurangan. “Sleeping is efficient: Mis
in o (1)-rounds node-averaged awake complexity”. In: Proceedings of the 39th Symposium on
Principles of Distributed Computing. 2020, pp. 99–108.
[CPS17b]
Kai-Min Chung, Seth Pettie, and Hsin-Hao Su. “Distributed algorithms for the Lovász local
lemma and graph coloring”. In: Distributed Computing 30.4 (2017), pp. 261–280.
[Coi+22]
Xavier Coiteux-Roy, Francesco d’Amore, Rishikesh Gajjala, Fabian Kuhn, François Le Gall,
Henrik Lievonen, Augusto Modanese, Marc-Olivier Renou, Gustav Schmid, and Jukka Suomela.
“No distributed quantum advantage for approximate graph coloring.” In: Quantum Information
and Computation 22.15&16 (2022), pp. 1261–1279.
[CV86]
Richard Cole and Uzi Vishkin. “Deterministic Coin Tossing with Applications to Optimal Par-
allel List Ranking”. In: Information and Control 70.1 (1986), pp. 32–53.
[CGP24]
Clinton T Conley, Jan Grebík, and Oleg Pikhurko. “Divisibility of spheres with measurable
pieces”. In: L’Enseignement Mathématique (2024).
[CM17]
Clinton T. Conley and Benjamin D. Miller. “Measure reducibility of countable Borel equivalence
relations”. In: Ann. of Math. (2) 185.2 (2017), pp. 347–402. issn: 0003-486X.
44

--- Page 45 ---
[Csó+22]
Endre Csóka, Łukasz Grabowski, András Máthé, Oleg Pikhurko, and Konstantinos Tyros.
“Moser-Tardos Algorithm with small number of random bits”. In: arXiv preprint arXiv:2203.05888
(2022).
[DF92]
Randall Dougherty and Matthew Foreman. “Banach-Tarski paradox using pieces with the prop-
erty of Baire”. In: Proc. Nat. Acad. Sci. U.S.A. 89.22 (1992), pp. 10726–10728. issn: 0027-8424.
[EL10]
Gábor Elek and Gábor Lippner. “Borel oracles. An analytical approach to constant-time algo-
rithms”. In: Proceedings of the American Mathematical Society 138.8 (2010), pp. 2939–2947.
[EFF82]
Paul Erdös, Peter Frankl, and Zoltán Füredi. “Families of finite sets in which no set is covered
by the union of two others”. In: Journal of Combinatorial Theory, Series A 33.2 (1982), pp. 158–
166.
[EL75]
Paul Erdős and László Lovász. “Problems and results on 3-chromatic hypergraphs and some
related questions”. In: Infinite and finite sets 10.2 (1975), pp. 609–627.
[EMR14]
Guy Even, Moti Medina, and Dana Ron. “Deterministic stateless centralized local algorithms
for bounded degree graphs”. In: European Symposium on Algorithms. Springer. 2014, pp. 394–
405.
[Fao+23]
Salwa Faour, Mohsen Ghaffari, Christoph Grunau, Fabian Kuhn, and Václav Rozhoň. “Local
distributed rounding: Generalized to mis, matching, set cover, and beyond”. In: Proceedings
of the 2023 Annual ACM-SIAM Symposium on Discrete Algorithms (SODA). SIAM. 2023,
pp. 4409–4447.
[Feu17]
Laurent Feuilloley. “How long it takes for an ordinary node with an ordinary ID to output?” In:
International Colloquium on Structural Information and Communication Complexity. Springer.
2017, pp. 263–282.
[Feu21]
Laurent Feuilloley. “Introduction to local certification”. In: Discrete Mathematics & Theoretical
Computer Science 23.Distributed Computing and Networking (2021).
[FG17]
Manuela Fischer and Mohsen Ghaffari. “Sublogarithmic Distributed Algorithms for Lovász Lo-
cal Lemma, and the Complexity Hierarchy”. In: 31 International Symposium on Distributed
Computing. 2017.
[FGK17]
Manuela Fischer, Mohsen Ghaffari, and Fabian Kuhn. “Deterministic Distributed Edge-Coloring
via Hypergraph Maximal Matching”. In: Proc. 58th IEEE Symp. on Foundations of Computer
Science (FOCS). 2017.
[Fra+13]
Pierre Fraigniaud, Mika Göös, Amos Korman, and Jukka Suomela. “What Can Be Decided
Locally without Identifiers?” In: Proceedings of the 2013 ACM Symposium on Principles of
Distributed Computing. PODC ’13. Montréal, Québec, Canada: Association for Computing Ma-
chinery, 2013, pp. 157–165. isbn: 9781450320658.
[FHK12]
Pierre Fraigniaud, Magnús M Halldórsson, and Amos Korman. “On the impact of identifiers on
local decision”. In: International Conference On Principles Of Distributed Systems. Springer.
2012, pp. 224–238.
[Gab00]
Damien Gaboriau. “Coût des relations d’équivalence et des groupes”. In: Invent. Math. 139.1
(2000), pp. 41–98. issn: 0020-9910.
[Gao+18]
Su Gao, Steve Jackson, Edward Krohne, and Brandon Seward. “Continuous combinatorics of
abelian group actions”. In: arXiv preprint arXiv:1803.03872 (2018).
[Gav+09]
Cyril Gavoille, Ralf Klasing, Adrian Kosowski, Łukasz Kuszner, and Alfredo Navarra. “On the
complexity of distributed graph coloring with local minimality constraints”. In: Networks: An
International Journal 54.1 (2009), pp. 12–19.
[GKM09]
Cyril Gavoille, Adrian Kosowski, and Marcin Markiewicz. “What Can Be Observed Locally?
Round-Based Models for Quantum Distributed Computing”. In: Proceedings of the 23rd Inter-
national Conference on Distributed Computing. DISC’09. Elche, Spain: Springer-Verlag, 2009,
pp. 243–257. isbn: 3642043542.
45

--- Page 46 ---
[Gha16]
Mohsen Ghaffari. “An improved distributed algorithm for maximal independent set”. In: Proc.
ACM-SIAM Symp. on Discrete Algorithms (SODA). 2016, pp. 270–277.
[Gha22]
Mohsen Ghaffari. “Local computation of maximal independent set”. In: 2022 IEEE 63rd Annual
Symposium on Foundations of Computer Science (FOCS). IEEE. 2022, pp. 438–449.
[GG23]
Mohsen Ghaffari and Christoph Grunau. “Faster Deterministic Distributed MIS and Approxi-
mate Matching”. In: Proceedings of the 55th Annual ACM Symposium on Theory of Computing.
2023, pp. 1777–1790.
[GG24]
Mohsen Ghaffari and Christoph Grunau. “Near-Optimal Deterministic Network Decomposition
and Ruling Set, and Improved MIS”. In: Proc. 65th IEEE Symp. on Foundations of Computer
Science (FOCS). 2024.
[Gha+23]
Mohsen Ghaffari, Christoph Grunau, Bernhard Haeupler, Saeed Ilchi, and Václav Rozhoň.
“Improved distributed network decomposition, hitting sets, and spanners, via derandomization”.
In: Proceedings of the 2023 Annual ACM-SIAM Symposium on Discrete Algorithms (SODA).
SIAM. 2023, pp. 2532–2566.
[GGR21]
Mohsen Ghaffari, Christoph Grunau, and Václav Rozhoň. “Improved Deterministic Network
Decomposition”. In: Proc. of the 32nd ACM-SIAM Symp. on Discrete Algorithms (SODA). USA:
Society for Industrial and Applied Mathematics, 2021, pp. 2904–2923. isbn: 9781611976465.
[GH21]
Mohsen Ghaffari and Bernhard Haeupler. “A time-optimal randomized parallel algorithm for
mis”. In: Proceedings of the 2021 ACM-SIAM Symposium on Discrete Algorithms (SODA).
SIAM. 2021, pp. 2892–2903.
[GHK18]
Mohsen Ghaffari, David Harris, and Fabian Kuhn. “On derandomizing local distributed algo-
rithms”. In: Proc. Foundations of Computer Science (FOCS). 2018, pp. 662–673.
[GK22]
Mohsen Ghaffari and Fabian Kuhn. “Deterministic distributed vertex coloring: Simpler, faster,
and without network decomposition”. In: 2021 IEEE 62nd Annual Symposium on Foundations
of Computer Science (FOCS). IEEE. 2022, pp. 1009–1020.
[GKM17]
Mohsen Ghaffari, Fabian Kuhn, and Yannic Maus. “On the Complexity of Local Distributed
Graph Problems”. In: Proc. 49th ACM Symp. on Theory of Computing (STOC). 2017, pp. 784–
797.
[GKU19]
Mohsen Ghaffari, Fabian Kuhn, and Jara Uitto. “Conditional Hardness Results for Massively
Parallel Computation from Distributed Lower Bounds”. In: Proc. Foundations of Computer
Science (FOCS). 2019.
[GP22]
Mohsen Ghaffari and Julian Portmann. “Average Awake Complexity of MIS and Matching”.
In: Proceedings of the 34th ACM Symposium on Parallelism in Algorithms and Architectures.
SPAA ’22. Philadelphia, PA, USA: Association for Computing Machinery, 2022, pp. 45–55.
isbn: 9781450391467.
[GP23]
Mohsen Ghaffari and Julian Portmann. “Distributed MIS with Low Energy and Time Complex-
ities”. In: Proceedings of the 2023 ACM Symposium on Principles of Distributed Computing.
PODC ’23. Orlando, FL, USA: Association for Computing Machinery, 2023, pp. 146–156.
[GU19]
Mohsen Ghaffari and Jara Uitto. “Sparsifying distributed algorithms with ramifications in mas-
sively parallel computation and centralized local computation”. In: Proceedings of the Thirtieth
Annual ACM-SIAM Symposium on Discrete Algorithms. SIAM. 2019, pp. 1636–1653.
[Gha20]
Ghaffari, Mohsen. Distributed Graph Algorithms. Lecture notes. 2020. url: https://disco.
ethz.ch/courses/fs20/podc/lecturenotes/DGA.pdf.
[GPS88]
Andrew V. Goldberg, Sergey A. Plotkin, and Gregory E. Shannon. “Parallel Symmetry-Breaking
in Sparse Graphs”. In: SIAM Journal on Discrete Mathematics 1.4 (1988), pp. 434–446.
[Göö+16]
Mika Göös, Juho Hirvonen, Reut Levi, Moti Medina, and Jukka Suomela. “Non-local probes do
not help with many graph problems”. In: Distributed Computing: 30th International Symposium,
DISC 2016, Paris, France, September 27-29, 2016. Proceedings 30. Springer. 2016, pp. 201–214.
46

--- Page 47 ---
[GS11]
Mika Göös and Jukka Suomela. “Locally Checkable Proofs”. In: Proc. 30th Symp. on Principles
of Distributed Computing (PODC). 2011, pp. 159–168.
[GRS91]
Ronald L Graham, Bruce L Rothschild, and Joel H Spencer. Ramsey theory. Vol. 20. John
Wiley & Sons, 1991.
[GP20]
Jan Grebík and Oleg Pikhurko. “Measurable versions of Vizing’s theorem”. In: Advances in
Mathematics 374 (2020), p. 107378.
[GR21]
Jan Grebík and Václav Rozhoň. “Classification of local problems on paths from the perspective
of descriptive combinatorics”. In: Extended Abstracts EuroComb 2021: European Conference on
Combinatorics, Graph Theory and Applications. Springer. 2021, pp. 553–559.
[GR23]
Jan Grebík and Václav Rozhoň. “Local problems on grids from the perspective of distributed
algorithms, finitary factors, and descriptive combinatorics”. In: Advances in Mathematics 431
(2023), p. 109241.
[GRB22]
Christoph Grunau, Václav Rozhoň, and Sebastian Brandt. “The landscape of distributed com-
plexities on trees and beyond”. In: Proceedings of the 2022 ACM Symposium on Principles of
Distributed Computing. 2022, pp. 37–47.
[HKP01]
M. Hańćkowiak, M. Karoński, and A. Panconesi. “On the Distributed Complexity of Computing
Maximal Matchings”. In: SIAM Journal on Discrete Math. 15.1 (2001), pp. 41–57.
[Har19]
David G Harris. “Distributed local approximation algorithms for maximum matching in graphs
and hypergraphs”. In: 2019 IEEE 60th Annual Symposium on Foundations of Computer Science
(FOCS). IEEE. 2019, pp. 700–724.
[HS20]
Juho Hirvonen and Jukka Suomela. “Distributed Algorithms”. In: Textbook, Aalto University
(2020).
[HL+15]
Alexander Holroyd, Thomas Liggett, et al. “Symmetric 1-dependent colorings of the integers”.
In: Electronic Communications in Probability 20 (2015).
[Hol23]
Alexander E Holroyd. “Symmetrization for finitely dependent colouring”. In: arXiv preprint
arXiv:2305.13980 (2023).
[Hol17]
Alexander E. Holroyd. “One-dependent coloring by finitary factors”. In: Annales de l’Institut
Henri Poincaré, Probabilités et Statistiques 53.2 (2017), pp. 753–765.
[HSW17]
Alexander E. Holroyd, Oded Schramm, and David B. Wilson. “Finitary coloring”. In: Ann.
Probab. 45.5 (Sept. 2017), pp. 2867–2898. url: https://doi.org/10.1214/16-AOP1127.
[JáJ92]
Joseph JáJá. An introduction to parallel algorithms. Addison Wesley Longman Publishing Co.,
Inc., 1992.
[KSV10]
Howard Karloff, Siddharth Suri, and Sergei Vassilvitskii. “A model of computation for MapRe-
duce”. In: Proceedings of the twenty-first annual ACM-SIAM symposium on Discrete Algorithms.
SIAM. 2010, pp. 938–948.
[KM16]
Alexander S Kechris and Andrew S Marks. “Descriptive graph combinatorics”. In: preprint
2020.9 (2016).
[KSS81]
Daniel J. Kleitman, J Shearer, and Dean Sturtevant. “Intersections of k-element sets”. In: Com-
binatorica 1.4 (1981), pp. 381–384.
[Kor+21]
Janne H. Korhonen, Ami Paz, Joel Rybicki, Stefan Schmid, and Jukka Suomela. “Brief An-
nouncement: Sinkless Orientation Is Hard Also in the Supported LOCAL Model”. In: 35th In-
ternational Symposium on Distributed Computing (DISC 2021). Ed. by Seth Gilbert. Vol. 209.
Leibniz International Proceedings in Informatics (LIPIcs). Dagstuhl, Germany: Schloss Dagstuhl
– Leibniz-Zentrum für Informatik, 2021, 58:1–58:4. isbn: 978-3-95977-210-5. doi: 10.4230/
LIPIcs.DISC.2021.58. url: https://drops.dagstuhl.de/opus/volltexte/2021/14860.
[KSV12]
Amos Korman, Jean-Sébastien Sereni, and Laurent Viennot. “Toward more localized local algo-
rithms: removing assumptions concerning global knowledge”. In: Distributed Computing 26.5-6
(Sept. 2012), pp. 289–308. issn: 1432-0452. doi: 10.1007/s00446-012-0174-8. url: http:
//dx.doi.org/10.1007/s00446-012-0174-8.
47

--- Page 48 ---
[Kuh09]
Fabian Kuhn. “Local Weak Coloring Algorithms and Implications on Deterministic Symmetry
Breaking”. In: Proc. 21st ACM Symp. on Parallelism in Algorithms and Architectures (SPAA).
2009.
[KMW16]
Fabian Kuhn, Thomas Moscibroda, and Roger Wattenhofer. “Local Computation: Lower and
Upper Bounds”. In: Journal of the ACM 63.2 (2016).
[LNR19]
François Le Gall, Harumichi Nishimura, and Ansis Rosmanis. “Quantum Advantage for the
LOCAL Model in Distributed Computing”. In: 36th International Symposium on Theoretical
Aspects of Computer Science. 2019.
[LRY15]
Reut Levi, Ronitt Rubinfeld, and Anak Yodpinyanee. “Local computation algorithms for graphs
of non-constant degrees”. In: Proceedings of the 27th ACM symposium on Parallelism in Algo-
rithms and Architectures. 2015, pp. 59–61.
[LPS23]
Henrik Lievonen, Timothé Picavet, and Jukka Suomela. “Distributed Binary Labeling Problems
in High-Degree Graphs”. In: arXiv preprint arXiv:2312.12243 (2023).
[Lin92]
Nati Linial. “Locality in Distributed Graph Algorithms”. In: SIAM Journal on Computing 21.1
(1992), pp. 193–201.
[LS93]
Nati Linial and Michael Saks. “Low Diameter Graph Decompositions”. In: Combinatorica 13.4
(1993), pp. 441–454.
[Lov12]
László Lovász. Large networks and graph limits. Vol. 60. American Mathematical Soc., 2012.
[Lub86]
Michael Luby. “A Simple Parallel Algorithm for the Maximal Independent Set Problem”. In:
SIAM Journal on Computing 15 (1986), pp. 1036–1053.
[LAO17]
Lukasz Grabowski, András Máthé, and Oleg Pikhurko. “Measurable circle squaring.” In: Ann.
of Math. 185.2 (2017), pp. 671–710.
[MU16]
Andrew Marks and Spencer Unger. “Baire measurable paradoxical decompositions via match-
ings”. In: Advances in Mathematics 289 (2016), pp. 397–410.
[Mar16]
Andrew S Marks. “A determinacy approach to Borel combinatorics”. In: Journal of the American
Mathematical Society 29.2 (2016), pp. 579–600.
[MU17]
Andrew S Marks and Spencer T Unger. “Borel circle squaring”. In: Annals of Mathematics 186.2
(2017), pp. 581–605.
[Mau]
Y. Maus. personal communication.
[MSV23]
Darya Melnyk, Jukka Suomela, and Neven Villani. “Mending Partial Solutions with Few Changes”.
In: 26th International Conference on Principles of Distributed Systems. 2023.
[Mik90]
Miklós Laczkovich. “Equidecomposability and discrepancy; a solution of Tarski’s circle-squaring
problem.” In: J. Reine Angew. Math. 404 (1990), pp. 77–117.
[MPX13]
Gary L Miller, Richard Peng, and Shen Chen Xu. “Parallel graph decompositions using random
shifts”. In: Proceedings of the twenty-fifth annual ACM symposium on Parallelism in algorithms
and architectures. 2013, pp. 196–203.
[MR89]
Gary L. Miller and John H. Reif. “Parallel Tree Contraction–Part I: Fundamentals”. In: Advances
in Computing Research 5 (1989), pp. 47–72.
[MT10]
Robin A Moser and Gábor Tardos. “A constructive proof of the general Lovász local lemma”.
In: Journal of the ACM (JACM) 57.2 (2010), pp. 1–15.
[Nao91]
Moni Naor. “A lower bound on probabilistic algorithms for distributive ring coloring”. In: SIAM
Journal on Discrete Mathematics 4.3 (1991), pp. 409–412.
[NS95]
Moni Naor and Larry Stockmeyer. “What Can Be Computed Locally?” In: SIAM Journal on
Computing 24.6 (1995), pp. 1259–1277.
[NO08]
Huy N. Nguyen and Krzysztof Onak. “Constant-Time Approximation Algorithms via Local
Improvements”. In: 2008 49th Annual IEEE Symposium on Foundations of Computer Science.
2008, pp. 327–336. doi: 10.1109/FOCS.2008.81.
48

--- Page 49 ---
[Ona+12]
Krzysztof Onak, Dana Ron, Michal Rosen, and Ronitt Rubinfeld. “A near-optimal sublinear-
time algorithm for approximating the minimum vertex cover size”. In: Proceedings of the twenty-
third annual ACM-SIAM symposium on Discrete Algorithms. SIAM. 2012, pp. 1123–1131.
[PS92]
Alessandro Panconesi and Aravind Srinivasan. “Improved distributed algorithms for coloring
and network decomposition problems”. In: Proc. 24th ACM Symp. on Theory of Computing
(STOC). 1992, pp. 581–592.
[PR07]
Michal Parnas and Dana Ron. “Approximating the minimum vertex cover in sublinear time
and a connection to distributed algorithms”. In: Theoretical Computer Science 381.1-3 (2007),
pp. 183–196.
[Pel00]
David Peleg. Distributed Computing: A Locality-Sensitive Approach. SIAM, 2000.
[Pik21]
Oleg Pikhurko. Borel Combinatorics of Locally Finite Graphs. 2021. arXiv: 2009.09113 [math.CO].
[QW22]
Long Qian and Felix Weilacher. “Descriptive Combinatorics, Computable Combinatorics, and
ASI Algorithms”. In: arXiv preprint arXiv:2206.08426 (2022).
[RV16]
Omer Reingold and Shai Vardi. “New techniques and tighter bounds for local computation
algorithms”. In: Journal of Computer and System Sciences 82.7 (2016), pp. 1180–1200.
[RS20]
Will Rosenbaum and Jukka Suomela. “Seeing Far vs. Seeing Wide: Volume Complexity of Local
Graph Problems”. In: Proceedings of the 39th Symposium on Principles of Distributed Comput-
ing. PODC ’20. Virtual Event, Italy: Association for Computing Machinery, 2020, pp. 89–98.
isbn: 9781450375825.
[Roz+22a]
Václav Rozhoň, Michael Elkin, Christoph Grunau, and Bernhard Haeupler. “Deterministic low-
diameter decompositions for weighted graphs and distributed and parallel applications”. In:
2022 IEEE 63rd Annual Symposium on Foundations of Computer Science (FOCS). IEEE. 2022,
pp. 1114–1121.
[RG20]
Václav Rozhoň and Mohsen Ghaffari. “Polylogarithmic-time deterministic network decompo-
sition and distributed derandomization”. In: Proceedings of the 52nd Annual ACM SIGACT
Symposium on Theory of Computing. 2020, pp. 350–363.
[Roz+22b]
Václav Rozhoň, Christoph Grunau, Bernhard Haeupler, Goran Zuzic, and Jason Li. “Undi-
rected (1+eps)-Shortest Paths via Minor-Aggregates: Near-Optimal Deterministic Parallel and
Distributed Algorithms”. In: Proceedings of the 54th Annual ACM SIGACT Symposium on
Theory of Computing. STOC 2022. Rome, Italy: Association for Computing Machinery, 2022,
pp. 478–487. isbn: 9781450392648.
[RHG23]
Václav Rozhoň, Bernhard Haeupler, and Christoph Grunau. “A Simple Deterministic Dis-
tributed Low-Diameter Clustering”. In: Symposium on Simplicity in Algorithms (SOSA). SIAM.
2023, pp. 166–174.
[Rub+11]
Ronitt Rubinfeld, Gil Tamir, Shai Vardi, and Ning Xie. “Fast local computation algorithms”.
In: arXiv preprint arXiv:1104.1377 (2011).
[RS15]
Joel Rybicki and Jukka Suomela. “Exact bounds for distributed graph colouring”. In: Interna-
tional Colloquium on Structural Information and Communication Complexity. Springer. 2015,
pp. 46–60.
[SS13]
Stefan Schmid and Jukka Suomela. “Exploiting Locality in Distributed SDN Control”. In: Pro-
ceedings of the Second ACM SIGCOMM Workshop on Hot Topics in Software Defined Network-
ing. HotSDN ’13. Hong Kong, China: Association for Computing Machinery, 2013, pp. 121–126.
isbn: 9781450321785.
[Spi20]
Yinon Spinka. “Finitely dependent processes are finitary”. In: Ann. Probab. 48.4 (2020), pp. 2088–
2117.
[Suo13]
Jukka Suomela. “Survey of local algorithms”. In: ACM Computing Surveys 45.2 (2013).
[Suo20]
Jukka Suomela. “Using Round Elimination to Understand Locality”. In: SIGACT News 51.3
(Sept. 2020), pp. 63–81. issn: 0163-5700.
49

--- Page 50 ---
[Suo23]
Suomela, Jukka. Open problems related to locality in distributed graph algorithms. 2023. url:
https://jukkasuomela.fi/open/.
[YYI09]
Yuichi Yoshida, Masaki Yamamoto, and Hiro Ito. “An improved constant-time approximation
algorithm for maximum matchings”. In: Proceedings of the forty-first annual ACM symposium
on Theory of computing. 2009, pp. 225–234.
50


=== quantum.pdf ===

--- Page 1 ---
What Can Be Observed Locally?⋆
Round-Based Models for Quantum Distributed Computing
Cyril Gavoille1, Adrian Kosowski1,2, and Marcin Markiewicz3
1 LaBRI - University of Bordeaux
2 Dept of Algorithms and System Modeling, Gda´nsk University of Technology
3 Institute of Theoretical Physics and Astrophysics, University of Gda´nsk
Abstract. We consider the question of locality in distributed comput-
ing in the context of quantum information. Speciﬁcally, we focus on the
round complexity of quantum distributed algorithms, with no bounds
imposed on local computational power or on the bit size of messages.
Linial’s LOCAL model of a distributed system is augmented through
two types of quantum extensions: (1) initialization of the system in a
quantum entangled state, and/or (2) application of quantum communi-
cation channels. For both types of extensions, we discuss proof-of-concept
examples of distributed problems whose round complexity is in fact re-
duced through genuinely quantum eﬀects. Nevertheless, we show that
even such quantum variants of the LOCAL model have non-trivial lim-
itations, captured by a very simple (purely probabilistic) notion which
we call “physical locality” (ϕ-LOCAL). While this is strictly weaker
than the “computational locality” of the classical LOCAL model, it
nevertheless leads to a generic view-based analysis technique for con-
structing lower bounds on round complexity. It turns out that the best
currently known lower time bounds for many distributed combinatorial
optimization problems, such as Maximal Independent Set, bounds cannot
be broken by applying quantum processing, in any conceivable way.
1
Introduction
The introduction of computational models based on quantum computing, start-
ing from the works of Deutsch in the 1980’s [11], has led to the advent of a new
branch of complexity theory. Many studies have for instance focused on the com-
plexity class BQP of problems solvable on a quantum computer in polynomial
time with bounded error probability, and its relation to the classical complex-
ity classes. One of the best known algorithmic results in this respect is Shor’s
polynomial-time method of integer factorization [37] based on the Quantum
Fourier Transform, which has recently been partially tested in an experimental
set-up for very small values of problem input. Nevertheless, application of quan-
tum information in centralized computing scenarios still proves extremely costly
and is riddled with technological diﬃculties resulting from quantum decoherence
⋆Supported by the ANR project “ALADDIN”, by the INRIA ´equipe-project
“C´EPAGE”, and by the KBN Grant 4 T11C 047 25.
I. Keidar (Ed.): DISC 2009, LNCS 5805, pp. 243–257, 2009.
c
⃝Springer-Verlag Berlin Heidelberg 2009

--- Page 2 ---
244
C. Gavoille, A. Kosowski, and M. Markiewicz
eﬀects. On the other hand, in an even wider time-frame, properties of quantum-
mechanical systems have proven to be of interest from the perspective of game
theory [4,13,2], information theory [31,22,3], and distributed systems [4,9].
A major line of study (which we brieﬂy look at in the related work section)
concerns the application of quantum eﬀects to reduce communication complex-
ity, i.e., to decrease the number of communication bits required to solve a speciﬁc
task performed within a system graph with several distributed agents. The in-
ﬂuence of quantum information on the computing power of distributed systems
with node anonymity and distributed systems in the presence of faults has also
been studied.
This paper focuses on a diﬀerent aspect of quantum distributed computing:
we do not impose any bounds on the size of communicated messages, but assume
that the system operates in synchronous rounds, and ask to what extent quantum
eﬀects can reduce the number of rounds required to solve combinatorial optimi-
sation problems. The starting point for considerations is the well-established
LOCAL model a.k.a. Linial’s Free model [25,26]. We provide a comparison of
the “computational power” of the quantum and non-quantum models, formalis-
ing the notion of locality in quantum distributed computing, and showing how
it essentially diﬀers from the understanding of locality in the LOCAL model.
1.1
Related Work
One of the most intensively studied problems related to multi-agent quantum sce-
narios, when expressed in the language of distributed computing, is roughly try-
ing to address the question: Can quantum eﬀects be used to enhance distributed
computations with messages of bounded size, i.e., in settings inspired by the
CONGEST distributed model? (See [35] for an introduction to the CONGEST
model.) The quantum variant of CONGEST , widely studied in physics, is known
as the Local Operations and Classical Communication (LOCC) model. It ex-
ploits the key quantum-mechanical concept of an entangled state (see e.g. [31]).
This is achieved by altering the initialization phase of the system to allow for a
starting state entangled among all the processors, which are locally given quan-
tum computation capabilities; however, communication between processors is
still restricted to the exchange of classical information, only. This application
of pre-entanglement has been shown to decrease the number of communication
bits required to solve certain distributed problems with output collected from
one node, and consequently, to decrease the number of required communication
rounds when message sizes are bounded. The ﬁrst proof-of-concept example was
provided in [6], where the computation of a speciﬁc function of input data dis-
tributed among three parties was shown to require at least 3 communicated bits
in the classical case, but only 2 communicated bits if the system is initialized in
a speciﬁc quantum entangled state. Many related results and reﬁnements of this
scenario are surveyed in e.g. [7,39].
Other works on the subject have focused on characterising the physical evo-
lution of states attainable in the LOCC model [30,32,8], while other authors
have dealt with the combinatorial complexity of distributing the entangled state

--- Page 3 ---
What Can Be Observed Locally?
245
over the whole system in the initialization phase [38]. Other modiﬁcations of
the model attempt to show that a denser coding of information in transmit-
ted messages is possible when using quantum channels, as compared to classical
communication links (see e.g. [5,36]).
Very recently, some authors have begun to study the impact of quantum eﬀects
on fundamental concepts of the theory of distributed computing. An overview of
this line of research is contained in the recent survey paper [9]. The advantages of
applying quantum communication in games against a dynamic adversary are dis-
played in [1], where it is shown that a constant number of computational rounds
is suﬃcient to solve the quantum Byzantine agreement problem for an n-node
system with less than n/3 faulty nodes in such a dynamic setting; corresponding
classical algorithms require Ω(√n) rounds. Another especially interesting result
is that the leader election problem can be solved in distributed systems with
quantum links, but no pre-entanglement [40,23]. Some authors have also claimed
that problems related to leader election [33,12] and distributed consensus [12,21]
can be solved in distributed systems aided by quantum pre-entanglement.
1.2
Outline of the Paper
In Subsection 1.3 we brieﬂy outline the LOCAL model and its extensions,
obtained by modifying the initialization of the system set-up and/or adding
quantum communication capabilities on the edges. Whereas this discussion is
self-contained, we also provide a formal mathematical deﬁnition of the cor-
responding notions in an extended version of the paper [19]. Subsection 1.4
introduces some notation used when comparing computational models.
In Section 2 we compare the computational power of models based on the
proposed extensions of LOCAL. In particular, we prove that adding quantum
extensions to the LOCAL model decreases the round complexity of certain dis-
tributed problems. This is achieved through simple proof-of-concept examples.
Most importantly, in Section 3 we introduce a probabilistic framework for
proving lower bounds on the distributed time complexity of computational prob-
lems in any quantum (or other unconventional) models based on LOCAL. This
is directly applied to obtain such lower bounds for many combinatorial optimiza-
tion problems, including Maximal Independent Set, Greedy Graph Coloring, and
problems of spanner construction. As a side eﬀect, the simple concept of “physi-
cal locality” formulated in this section, leads to the deﬁnition of a computational
model we call ϕ-LOCAL, which appears to be of independent interest.
Finally, in Section 4 we make an attempt to clarify issues with some of the
related work on quantum distributed computing as surveyed by [9]. Making
use of the framework of computational models deﬁned in the previous sections,
we explain why certain claims, saying that problems such as Leader Election
or Distributed Consensus beneﬁt from the application of quantum processing,
should be approached with caution.
Section 5 contains some concluding remarks and suggests directions of future
studies.

--- Page 4 ---
246
C. Gavoille, A. Kosowski, and M. Markiewicz
1.3
Preliminaries: Description of Computation Models
The LOCAL Model. The LOCAL model has been the subject of intensive
study in the last 20 years, starting from the seminal works [25,29]. It is assumed
that the distributed system consists of a set of processors V (with |V | = n) and
operates in a sequence of synchronous rounds, each of which involves unbounded
computations on the local state variables of the processors, and a subsequent ex-
change of messages of arbitrary size between pairs of processors which are con-
nected by links (except for round 0, which involves local computations, only).
Nodes can identify their neighbours using integer labels assigned successively
to communication ports. The local computation procedures encoded in all pro-
cessors are necessarily the same, and initially all local state variables have the
same value for all processors, except for one distinguished local variable x(v) of
each processor v which encodes input data. The input of a problem is deﬁned
in the form of a labeled graph Gx, where G = (V, E) is the system graph, while
x : V →N is an assignment of labels to processors. The output of the algorithm
is given in the form of a vector of local variables y : V →N, and the algorithm
is assumed to terminate once all variables y(v) are deﬁnitely ﬁxed. Herein we
assume that faults do not appear on processors and links, that local computa-
tion procedures may be randomized (with processors having access to their own
generators of random variables), and that the input labels x need not in general
be distinct for all processors.
In our considerations, it is convenient to assume that the set of processors
V is given before the input is deﬁned. This is used for convenience of notation,
and neither aﬀects the model, nor the anonymity of nodes in the considered
problems.
Extensions of System Initialization (+S and +E). In the LOCAL model, it
is assumed that the initial set-up of all the processors is identical. This assump-
tion can be relaxed by allowing the processors to obtain some information from
a central helper, but only before the start of the distributed process (i.e., inde-
pendently of the input Gx). The initialization procedure is an integral part of
the algorithm used for solving the distributed problem. Several diﬀerent forms of
initialization can be naturally deﬁned; for clarity of discussion, we consider only
two extensions of the model: the +S extension (for Separable state), which allows
for the most general form of initialization possible in a classical computational
setting, and the more powerful +E extension (for Entangled state), which allows
for the most general form of initialization available in a quantum distributed
system.
The +S extension. We say that a computational model is equipped with the +S
extension if the following modiﬁcations are introduced:
– For any computational problem, the computational procedure consists of
the distributed algorithm applied by all the processors during the rounds
of computation, and an additional (randomized) procedure executed in a
centralized way in the initialization phase. The result of the initialization

--- Page 5 ---
What Can Be Observed Locally?
247
procedure is an assignment h : V →N of helper variables to the set of
processors. The helper variables are independent1 of the input Gx.
– For each processor v ∈V , at the start of round 0, its input label x(v) is
augmented by the value h(v), stored in a helper register of the local memory.
It is straightforward to show that the above formulation has two equivalent char-
acterizations. From a computational perspective, we may equivalently say that
for each processor v, the helper initialization value h(v) encodes: (1) a unique
identiﬁer of v from the range {1, . . . , n}, (2) the value of n, (3) the value of a
random number, chosen from an arbitrarily large range, and shared by all pro-
cessors. All further helper information is unnecessary, since it can be computed
by the processors in round 0 of the distributed computations (simulation of the
centralized assignment of further helper information can be simulated based on
random bits and starting information which is common to all processors).
Alternatively, we may say that through the randomized initialization, accord-
ing to some probability distribution we choose some deterministic initialization
of the set of states of individual processors. This intuition precisely corresponds
to the notion of a state with uncertainty in classical statistical physics, referred
to in quantum-mechanical discussions as a (mixed) separable state of the sys-
tem. It is obviously true to say that whenever a problem is solved in a model
with the +S extension, it may beneﬁt solely from the modiﬁcation of the system
initialization, and not from the laws of quantum mechanics.
The +E extension. Unlike in classical physics, in quantum mechanics not every
initialization of the system has to follow the above pattern. Consider a scenario in
which we centrally create an initial global state of the whole system of processors,
and spatially distribute “parts” of it to the individual processors (for example,
by sharing out among the nodes a set of quantum-correlated photons). Then,
each of the processors can perform operations on the “part” of the state assigned
to its spatial location; by a loose analogy to processing of classical information,
this is sometimes referred to as each processor “manipulating its own quantum
bits (qubits)”. Given a general initial state of the system, the outcome of such
a physical process, as determined by the processors, may display correlations
which cannot be described using any classical probabilistic framework. Initial
states which can be lead to display such properties are called non-separable, or
entangled states. Quantum entanglement is without doubt one of the predom-
inant topics studied in quantum-mechanical literature of the last decades; we
refer the interested reader to e.g. [31] for an extensive introduction to the topic.
We say that a computational model is equipped with the +E extension if all
processors are equipped with helper quantum information registers h, and the
computational procedure used to solve a problem sets in the initialization phase
in a centralized way some chosen, possibly entangled, quantum state over the
set of quantum information registers h of all processors, in a way independent
of the input graph Gx.
1 Helper variables that do depend on the inputs are referred to in the literature as
Oracles [16,15]. Such extensions are not discussed in this paper.

--- Page 6 ---
248
C. Gavoille, A. Kosowski, and M. Markiewicz
Extension of Communication Capabilities (+Q). Whereas the application
of local quantum operations in each processor does not increase the power of the
LOCAL model as such, the situation changes when the processors can interact
with each other using quantum communication channels. Intuitively, such chan-
nels allow for the distribution of an entangled state by a processor over several
of its neighbours in one communication round; such an eﬀect cannot be achieved
using classical communication links.
We say that a computational model is equipped with the +Q extension if all
communication links between processors in the system graph are replaced by
quantum communication channels.
Models with the Extensions. Modiﬁcations to the initialization and commu-
nication capabilities of the system are completely independent of each other. For
initialization, we can apply no extension, use a separable state (+S), or an en-
tangled state (+E). For communication, we can apply no extension, or use quan-
tum channels (+Q). Hence, we obtain 6 possible models (LOCAL, LOCAL+S,
LOCAL+E, LOCAL+Q, LOCAL+Q+S, LOCAL+Q+E), which are discussed in
the following section. (Some of these models collapse onto each other.)
1.4
Notation for Comparing the Power of Computational Models
In order to compare the computational power of diﬀerent models, we introduce
two basic notions: that of the problem being solved, and of an outcome of the
computational process.
Deﬁnition 1. A problem P is a mapping Gx →{yi}, which assigns to each
input graph Gx a set of permissable output vectors yi : V →N.
Instead of explicitly saying that we are interested in ﬁnding eﬃcient (possibly
randomized) distributed algorithms for solving problems within the considered
computational models, we characterize the behavior of such procedures through
the probability distribution of output vectors which they may lead to, known as
an outcome. In fact, such a probability distribution is necessarily well deﬁned,
whereas formally describing the computational process may be diﬃcult in some
unconventional settings (see e.g. the ϕ-LOCAL model in Section 3).
Deﬁnition 2. An outcome O is a mapping Gx →{(yi, pi)}, which assigns to
each input graph Gx a normalized discrete probability distribution {pi}, such
that: ∀i pi > 0 and 
i pi = 1, with pi representing the probability of obtaining
yi : V →N as the output vector of the distributed system.
Deﬁnition 3. For any outcome O in a computational model M which is a variant
of LOCAL, we will write O ∈M[t] if within model M there exists a distributed
procedure which yields outcome O after at most t rounds of computation.
We will say that an outcome O is a solution to problem P with probability p if
for all Gx, we have: 
{(yi,pi)∈O(Gx) : yi∈P(Gx)} pi ≥p. When p = 1, we will
simply call O a solution to P (with certainty).

--- Page 7 ---
What Can Be Observed Locally?
249
By a slight abuse of notation, for a problem P we will write P ∈M[t] (re-
spectively, P ∈M[t, p]) if there exists an outcome O ∈M[t] which is a solution
to problem P (respectively, a solution to problem P with probability p).
For two computational models M1, M2, we say that M1 is not more powerful
than M2 (denoted M1 ⊆M2) if for every problem P, for all t ∈N and p > 0,
P ∈M1[t, p]
=⇒
P ∈M2[t, p]. The relation ⊆induces a partial order
of models which is naturally extended to say that M1 and M2 are equivalent
(M1 = M2), or that M1 is less powerful than M2 (M1 ⊊M2).
It can easily be proved that M1 ⊆M2 if and only if for every outcome O, for
all t ∈N, O ∈M1[t] =⇒O ∈M2[t]. Such an outcome-based characterisation
of models is occasionally more intuitive, since it is not explicitly parameterised
by probability p.
In all further considerations, when proving that M1 ⊊M2, we will do so in
a stronger, deterministic sense, by showing that there exist a problem P and
t ∈N such that P ∈M2[t] and P /∈M1[t].
2
Hierarchy of Quantum Models
The most natural variants of LOCAL which are based on the extensions proposed
in the previous subsection are the classical model with separable initialization
(LOCAL+S), and quantum models with pre-entanglement at initialization, quan-
tum channels, or both (LOCAL+E, LOCAL+Q, and LOCAL+Q+E, respectively).
The strengths of the models can obviously be ordered as follows: LOCAL ⊆
LOCAL+Q ⊆LOCAL+Q+S ⊆LOCAL+Q+E, and LOCAL ⊆LOCAL+S ⊆
LOCAL+E ⊆LOCAL+Q+E. We now proceed to show that, whereas LOCAL+E =
LOCAL+Q+E, all the remaining inclusions are in fact strict. The hierarchy of the
most important models is shown in Fig. 1.
Proposition 1. LOCAL ⊊LOCAL+S. Moreover, there exists a problem P
such that P ∈LOCAL+S[0] and P ̸∈LOCAL[t] for all t ∈N.
Proof. Any problem, which can be solved when given unique node identiﬁers
from the range {1, . . . , n} is clearly in LOCAL+S[0]. On the other hand, there
are many examples of such problems which are not in LOCAL (or require Ω(n)
rounds assuming that the system graph is connected and node labels are unique),
most trivially the problem P of assigning unique node identiﬁers from the range
{1, . . ., n} to all nodes.
⊓⊔
More interestingly, one can show that LOCAL+S beneﬁts due to the fact that
helper variables h(v) can encode a value which is set in a randomized way.
Consider as a simple example a problem P′ whose input is a graph G = (V, E),
of suﬃciently large order n, with input labels of the nodes encoding unique node
identiﬁers {1, . . . , n} and the value of n; moreover, G is restricted to be the
complete graph Kn minus exactly one edge. The goal is to select an edge of the
graph, i.e., output y must be such that for some two nodes u, v ∈V , with {u, v} ∈
E, we have y(u) = y(v) = 1, and for all other w ∈V we have y(w) = 0. Even

--- Page 8 ---
250
C. Gavoille, A. Kosowski, and M. Markiewicz
Fig. 1. Hierarchy of computational extensions to the LOCAL model. See Section 3 for
a deﬁnition of the ϕ-LOCAL model, and Section 1.3 or the extended version [19] for
deﬁnitions of all other models.
with the knowledge of node identiﬁers and n, in the LOCAL model the problem
cannot be solved with high probability without communication, i.e., within 0
rounds: we have P′ /∈LOCAL[0, e−1] (the proof is technical and postponed to
the extended version [19]). On the other hand, within the LOCAL+S model this
problem admits a solution in 0 rounds with probability arbitrarily close to 1 for
suﬃciently large n. Similar arguments can be applied to display the diﬀerence
between the models for more advanced problems which simulate collaborative
mobile agent scenarios, in particular variants of the cops-and-robbers problems
in graphs.
We now point out the diﬀerence in power between the classical and quantum
models. The proofs proceed by rephrasing one of the best established results of
quantum interferometry, ﬁrst introduced in the context of the so called Bell’s
Theorem without inequalities, for a 3-particle quantum entangled state (cf. [20]
for the original paper or [34] for a contemporary exposition). We use its more
algorithmic modulo-4 sum formulation, similar to that found in [41].
Theorem 1. LOCAL+S ⊊LOCAL+E. Moreover, there exists a problem P
such that P ∈LOCAL+E[0] and P ̸∈LOCAL+S[t] for all t ∈N.
Proof. Let P be a problem deﬁned on a system with 3 nodes. Let the input graph
be empty, and assume that input labels x = (x1, x2, x3) ∈{0, 1}3 of respective
nodes satisfy the condition x1 + x2 + x3 ∈{0, 2}. An output y = (y1, y2, y3) ∈
{0, 1}3 is considered valid for input x if and only if 2(y1+y2+y3) ≡(x1+x2+x3)
mod 4. This problem is not in LOCAL+S, since ﬁnding a solution with certainty
would imply that there exist three deterministic functions Y1, Y2, Y3 : {0, 1} →
{0, 1}, such that for any input vector (x1, x2, x3) satisfying the constraints of
the problem, (Y1(x1), Y2(x2), Y3(x3)) is a valid output vector. It is immediate to
show that this is impossible.
The situation is diﬀerent when the system operates in the LOCAL+E model
starts in an entangled state. The procedure required to obtain a valid solution
is described in detail in [20]. In brief, in the initialization phase we share out
to each of the processors one of 3 entangled qubits, carried e.g. by photons,

--- Page 9 ---
What Can Be Observed Locally?
251
which are in the entangled tripartite state known as the GHZ state (namely
1
√
2(|000⟩+ |111⟩) in Dirac’s notation for pure states). Each of the processors
then performs a simple transformation on “its own” qubit, in a way dependent
only on the processor’s input xi. Finally, a measurement is performed, and it
can be shown that the probability distribution of obtained output vectors (the
outcome) is that stated in Table 1. Since all of the outputs are accepted as valid
for the considered problem P, this implies that P ∈LOCAL+E[0].
⊓⊔
Table 1. An outcome O which is a solution (with certainty) to the modulo-4 sum
problem on the 3-node empty graph, and belongs to LOCAL+E[0] (see Theorem 1)
Input
Probability
Output
(x1, x2, x3)
pi
(yi
1, yi
2, yi
3)
(0, 0, 0)
1/4
(0, 0, 0)
1/4
(0, 1, 1)
1/4
(1, 0, 1)
1/4
(1, 1, 0)
Input
Probability
Output
(x1, x2, x3)
pi
(yi
1, yi
2, yi
3)
(0, 1, 1)
or (1, 0, 1)
or (1, 1, 0)
1/4
(1, 1, 1)
1/4
(1, 0, 0)
1/4
(0, 1, 0)
1/4
(0, 0, 1)
Proposition 2. LOCAL ⊊LOCAL+Q. Moreover, for any t > 0, there exists a
problem P such that P ∈LOCAL+Q[t] and P ̸∈LOCAL[2t −1].
Proof (sketch). The proof proceeds by a modiﬁcation of the argument from The-
orem 1. This time, we consider a system on n = 3k+1 nodes, and an input graph
with the topology of a uniformly subdivided star with a central node of degree 3.
The modiﬁed problem P′ consists in solving the problem from Theorem 1, when
the three input and output values are put on the three leaves of the star. Within
LOCAL, this problem requires 2k rounds to solve, whereas within LOCAL+Q,
k rounds are suﬃcient.
⊓⊔
Whereas the time distinction between LOCAL+S and LOCAL+E given by
Theorem 1 is remarkable (since it considers the feasibility of solving problems,
or when discussing connected graphs, a speed-up from Ω(n) to 0 communication
rounds), the situation is less clear between LOCAL+Q and LOCAL. Although a
speed-up factor of 2 as expressed by Proposition 2 looks like a natural limit, the
authors know of no conclusive arguments to show that it cannot be increased
further.
Finally, following the argumentation of [9], we observe that LOCAL+E =
LOCAL+Q+E, or in other words that, given access to pre-entanglement, it is
possible to simulate quantum links by means of classical ones. The eﬀect used
to achieve this is known as quantum teleportation [34]; by carefully choosing
an entangled state over the whole system, it can be applied even when the
communicating nodes do not yet know their neighbors’ unique identiﬁers. The
amount of pre-entanglement provided at initialization must be suﬃcient to allow
for communication throughout all the rounds of the algorithm.

--- Page 10 ---
252
C. Gavoille, A. Kosowski, and M. Markiewicz
To complete a discussion of Fig. 1, we point out that LOCAL+Q is incom-
parable with LOCAL+S. This is because the problem discussed in the proof of
Proposition 1 belongs to LOCAL+S, but not to LOCAL+Q, and the problem
discussed in the proof of Proposition 2 belongs to LOCAL+Q[1], but not to
LOCAL+S[1].
The LOCAL+Q+S model has been left out from discussion, since it appears
to be of little signiﬁcance. By considering the same problems as before, we have
LOCAL+Q+S ⊊LOCAL+Q+E = LOCAL+E, so LOCAL+Q+S could be placed
directly to the left of LOCAL+E in Fig. 1.
3
Lower Time Bounds Based on Physical Locality
(ϕ-LOCAL)
Proving lower bounds on the power of quantum models is problematic. This
results, in particular, from the fact that there does not exist as yet an easy-to-use
classiﬁcation of entangled states, or of quantum operations (completely positive
maps) which can be performed to transform one quantum state into another.
However, in the context of distributed computing, it is possible to consider a
more general framework of physical locality, leading to the ϕ-LOCAL model
we deﬁne hereafter, which in turn can be used to bound the power of quantum
models.
Within the classical LOCAL model, we can say that the output of any pro-
cessor v after t rounds has to be computed based on the input data which can
be collected from the input graph Gx by performing an exploration up to a
depth of t, starting from node v; we call this the distance-t local view denoted
by Vt(Gx, v). This leads to a simple characterisation of the LOCAL model in
terms of valid outcomes (see the extended version [19] for a formalization).
In order to allow for quantum extensions to local, the assumption of classical
computability needs to be relaxed, while at the same time retaining in some
form the assumption of locality. Given a round-based model with interactions
between nearest neighbors only, the physical understanding of locality is as fol-
lows: Locality is violated if and only if, based on the available output data, we can
conclusively verify that after t rounds some subset S of processors was aﬀected
by input data initially localized outside its view Vt(Gx, S) := 
v∈S Vt(Gx, v).
Using the above intuition, we now formalize this notion to obtain what we
call the ϕ-LOCAL model, i.e., the weakest possible distributed model which still
preserves physical locality. Given an output distribution {(yi, pi)} acting on V ,
for any subset of vertices S ⊆V we deﬁne its marginal distribution on set S,
{(yi, pi)}[S], as the unique distribution {(yj, pj)} acting on S which satisﬁes
the condition pj = 
{i : yj=yi[S]} pi, where yi[S] is the restriction of output
yi : V →N to nodes from subset S ⊆V .
Deﬁnition 4. An outcome Gx →{(yi, pi)} belongs to ϕ-LOCAL[t] if for all sub-
sets S ⊆V , for any pair of inputs G(a)
x , G(b)
x
such that Vt(G(a)
x , S) = Vt(G(b)
x , S),
the output distributions corresponding to these inputs have identical marginal dis-
tributions on set S, i.e., {(yi(a), pi(a))}[S] = {(yi(b), pi(b))}[S].

--- Page 11 ---
What Can Be Observed Locally?
253
Quantum relaxations of the LOCAL model, whether obtained through applica-
tion of pre-entanglement, quantum channels, or both, lie in terms of strength “in
between” the LOCAL and ϕ-LOCAL model. This is expressed by the following
theorem, whose proof is provided in the extended version of the paper [19].
Theorem 2. LOCAL+Q+E ⊆ϕ-LOCAL.
The theorem captures the property of locality of nearest-neighbor interactions
in quantum mechanics, and it does not rely in any way on any other physical
concepts, such as causality or speed of information in the theory of relativity.
Although it is not clear whether the containment in the above theorem is strict
(we leave this as an open question), the ϕ-LOCAL model is still suﬃciently
constrained to preserve many important lower time bounds known from the
LOCAL model, which are based on arguments of indistinguishability of local
views of a node for diﬀerent inputs. In particular, by careful analysis, it is easy
to prove the following statements for the ϕ-LOCAL model.
– The problem of ﬁnding a maximal independent set in the system graph
requires Ω(

log n
log log n) rounds to solve [24].
– The problem of ﬁnding a locally minimal (greedy) coloring of the system
graph requires Ω(
log n
log log n) rounds to solve [18,17].
– The problem of ﬁnding a connected subgraph with O(n1+1/k) edges requires
Ω(k) rounds to solve [10,14].
The matter is less clear in the case of the (Δ + 1)-coloring problem. The proof
of the famous lower bound of 1
2 log∗n −O(1) rounds [26] (and its extension to
randomized algorithms [28]) does not appear to generalize from the LOCAL
model to the ϕ-LOCAL model; we are unaware of any (even constant) bound on
the number of rounds required to ﬁnd a solution to (Δ+1)-coloring in ϕ-LOCAL.
Some indication that the technique of coloring neighborhood graphs, used by
Linial, may not apply in ϕ-LOCAL, is that this technique can likewise be used
to show a lower bound of
 n
2

−1 rounds on the time required for 2-coloring the
cycle Cn, where n is even. However, in ϕ-LOCAL the same problem admits a
solution in fewer rounds.
Theorem 3. The problem of 2-coloring the even cycle Cn (given unique node la-
bels x) belongs to ϕ-LOCAL[⌈n−2
4 ⌉], but does not belong to ϕ-LOCAL[⌈n−2
4 ⌉−1].
Proof (sketch). For the lower bound, consider the local view of two nodes u, v
which still have disjoint views after ⌈n−2
4 ⌉−1 rounds. There are at least two
nodes which belong to neither the view of u nor the view of v; hence, u and v
cannot distinguish whether they are at an even or at an odd distance from each
other in the cycle. This directly leads to the lower bound, since the deﬁnition
condition of ϕ-LOCAL can be shown to be violated for S = {u, v}.
The upper bound is generated by on outcome O of the 2-coloring problem,
given as follows: each of the 2 legal 2-colorings of Cn is used as the output with
probability 1
2. Such an outcome O belongs to ϕ-LOCAL[⌈n−2
4 ⌉]. This can be
easily veriﬁed, since for any subset S ⊆V we either have that S consists of

--- Page 12 ---
254
C. Gavoille, A. Kosowski, and M. Markiewicz
exactly two antipodal nodes of Cn, or the view V⌈n−2
4
⌉(Cnx, S) is simply an arc
of the cycle.
⊓⊔
It would be interesting to ﬁnd a constructive quantum procedure for ﬁnding a
2-coloring of Cn in ⌈n−2
4 ⌉rounds. In particular, we have that 2-coloring of C6
belongs to ϕ-LOCAL[1], does not belong to LOCAL+S[1], and do not know if
it belongs to LOCAL+E[1].
4
Simple Problems in a Quantum Setting
In this section, we have a look at some of the related work on quantum dis-
tributed problems, as outlined in the survey [9]. Whereas the discussion in this
section relies on the results and notation from the preceding sections, it can also
be translated into the (not always precisely described) computational models
studied in the considered related work.
Two problems which have been used to exhibit the diﬀerence between quan-
tum models and non-quantum models are LeaderElection, where the goal is for
exactly one node of the system graph to output a value of 1 whereas all other
nodes output 0, and a problem which we will call BitPicking, where the goal is
for all nodes to return the same output value, either 0 or 1. These discussions
include the concept of fairness, which in the terminology of this paper means
that we are asking not about the problems as such, but about obtaining speciﬁc
(fair) outcomes. More precisely, we will say that FairLeaderElection is the out-
come which puts a uniform probability distribution on the n distinct outputs
valid for LeaderElection (i.e., on all possible leaders), and FairBitPicking is the
outcome which puts a uniform probability distribution on the 2 distinct outputs
valid for BitPicking (i.e., picking 0 or 1).
The focus of [33,12,21] is to show that FairBitPicking and FairLeaderElection
belong to LOCAL+E[0] (even with some additional restrictions on the amount
of allowed pre-entanglement), whereas they do not belong to LOCAL[0]. This
statement is correct, however, this eﬀect is due to the modiﬁcation of initializa-
tion of the system, and not to quantum mechanics. In fact, we can make the
following obvious statement.
Proposition 3. FairBitPicking and FairLeaderElection belong to the non-quantum
class LOCAL+S[0]. Moreover, they can be solved with only one bit of helper infor-
mation per node, at initialization.
Finally, we relate to the recent claims that the DistributedConsensus can be solved
in a quantum setting without communication. Whereas these claims result from
a misunderstanding of the deﬁnition [27] of DistributedConsensus, we point out
that such a result is impossible in any quantum model, since it is even impos-
sible in ϕ-LOCAL (a short proof is provided in the extended version of the
paper [19]). We recall that in DistributedConsensus, given an assignment of input
labels (x1, . . . , xn) to particular processors, the goal is to obtain an output vector
(y, . . . , y), such that y ∈{x1, . . . , xn}.
Proposition 4. DistributedConsensus /∈ϕ-LOCAL[0].

--- Page 13 ---
What Can Be Observed Locally?
255
5
Conclusions and Future Work
We have pointed out that the computational power of quantum variants of the
LOCAL model is strictly greater than that of the classical LOCAL model, or
that of the LOCAL model equipped with helper information such as a pool of
shared random bits. It remains to be seen whether a diﬀerence can be observed
for any problems of practical signiﬁcance. It is potentially possible that certain
combinatorial optimization problems may beneﬁt from quantum extensions to
the LOCAL model. However, we can say that the “view-based” limitations of
the LOCAL model still hold in quantum models. So, one speciﬁc question which
remains open is whether the (Δ+1)-Coloring problem can be solved in a constant
number of rounds in any of the relaxed variants of LOCAL.
Finally, we can ask about a characterization of the limitations of quantum
computability, the most natural question being to establish whether the con-
tainment LOCAL+E ⊆ϕ-LOCAL is strict. As a matter of fact, further studies
of the ϕ-LOCAL model, which can be seen as the weakest distributed local
model, capturing veriﬁability rather than computability of outcomes, appear to
be of interest in their own right.
Acknowledgment. We gratefully thank Pierre Fraigniaud and Zvi Lotker for their
preliminary discussions on the EPR eﬀect and its applicability to Distributed
Computing. We thank Robert Alicki and Wladyslaw Adam Majewski for helpful
discussions concerning quantum dynamic maps, and Marek ˙Zukowski for several
references on quantum information.
References
1. Ben-Or, M., Hassidim, A.: Fast quantum byzantine agreement. In: 37th Annual
ACM Symposium on Theory of Computing (STOC), pp. 481–485. ACM Press,
New York (2005)
2. Benjamin, S.C., Hayden, P.M.: Multiplayer quantum games. Physical Review
A 64(3), 030301 (2001)
3. Bennett, C.H., Shor, P.W.: Quantum information theory. IEEE Transactions on
Information Theory 44, 2724–2742 (1998)
4. Broadbent, A., Tapp, A.: Can quantum mechanics help distributed computing?
ACM SIGACT News - Distributed Computing Column 39(3), 67–76 (2008)
5. Buhrman, H., Cleve, R., Wigderson, A.: Quantum vs. classical communication
and computation. In: 30th Annual ACM Symposium on the Theory of Computing
(STOC), pp. 63–68 (1998)
6. Cleve, R., Buhrman, H.: Substituting quantum entanglement for communication.
Physical Review A 56(2), 1201–1204 (1997)
7. de Wolf, R.: Quantum communication and complexity. Theoretical Computer Sci-
ence 287(1), 337–353 (2002)
8. den Nest, M.V., D¨ur, W., Vidal, G., Briegel, H.: Classical simulation versus uni-
versality in measurement-based quantum computation. Physical Review A 75(1),
012337 (2007)
9. Denchev, V.S., Pandurangan, G.: Distributed quantum computing: A new fron-
tier in distributed systems or science ﬁction? ACM SIGACT News - Distributed
Computing Column 39(3), 77–95 (2008)

--- Page 14 ---
256
C. Gavoille, A. Kosowski, and M. Markiewicz
10. Derbel, B., Gavoille, C., Peleg, D., Viennot, L.: On the locality of distributed
sparse spanner construction. In: 27th Annual ACM Symposium on Principles of
Distributed Computing (PODC), pp. 273–282. ACM Press, New York (2008)
11. Deutsch, D.: Quantum theory, the Church-Turing principle and the universal quan-
tum computer. Proceedings of the Royal Society of London A400, 97–117 (1985)
12. D’Hondt, E., Panangaden, P.: The computational power of the W and GHZ states.
Quantum Information and Computation 6(2), 173–183 (2006)
13. Eisert, J., Wilkens, M., Lewenstein, M.: Quantum games and quantum strategies.
Physical Review Letters 83(11), 3077–3080 (1999)
14. Elkin, M.: A near-optimal fully dynamic distributed algorithm for maintaining
sparse spanners. In: 26th Annual ACM Symposium on Principles of Distributed
Computing (PODC), pp. 195–204. ACM Press, New York (2007)
15. Fraigniaud, P., Gavoille, C., Ilcinkas, D., Pelc, A.: Distributed computing with ad-
vice: Information sensitivity of graph coloring. In: Arge, L., Cachin, C., Jurdzi´nski,
T., Tarlecki, A. (eds.) ICALP 2007. LNCS, vol. 4596, pp. 231–242. Springer, Hei-
delberg (2007)
16. Fraigniaud, P., Ilcinkas, D., Pelc, A.: Oracle size: a new measure of diﬃculty for
communication tasks. In: 25th Annual ACM Symposium on Principles of Dis-
tributed Computing (PODC), pp. 179–187. ACM Press, New York (2006)
17. Gavoille, C., Klasing, R., Kosowski, A., Kuszner, L., Navarra, A.: On the complex-
ity of distributed graph coloring with local minimality constraints. Networks (to
appear, 2009)
18. Gavoille, C., Klasing, R., Kosowski, A., Navarra, A.: Brief announcement: On the
complexity of distributed greedy coloring. In: Pelc, A. (ed.) DISC 2007. LNCS,
vol. 4731, pp. 482–484. Springer, Heidelberg (2007)
19. Gavoille, C., Kosowski, A., Markiewicz, M.: What can be observed locally? Round-
based models for quantum distributed computing. Technical report, arXiv: quant-
ph/0903.1133 (2009)
20. Greenberger, D.M., Horne, M.A., Zeilinger, A.: Going beyond Bell’s Theorem. In:
Bell’s Theorem, Quantum Theory, and Conceptions of the Universe, pp. 69–72.
Kluwer, Dordrecht (1989)
21. Helm, L.: Brief announcement: Quantum distributed consensus. In: 27th Annual
ACM Symposium on Principles of Distributed Computing (PODC), p. 445. ACM
Press, New York (2008)
22. Jaeger, G.: Quantum Information. An Overview. Springer, Heidelberg (2007)
23. Kobayashi, H., Matsumoto, K., Tani, S.: Fast exact quantum leader election on
anonymous rings. In: 8th Asian Conference on Quantum Information Science
(AQIS), August 2008, pp. 157–158 (2008)
24. Kuhn, F., Moscibroda, T., Wattenhofer, R.: What cannot be computed locally!
In. In: 23rd Annual ACM Symposium on Principles of Distributed Computing
(PODC), pp. 300–309. ACM Press, New York (2004)
25. Linial, N.: Distributive graph algorithms - Global solutions from local data. In:
28th Annual IEEE Symposium on Foundations of Computer Science (FOCS), pp.
331–335. IEEE Computer Society Press, Los Alamitos (1987)
26. Linial, N.: Locality in distributed graphs algorithms. SIAM Journal on Comput-
ing 21(1), 193–201 (1992)
27. Lynch, N.: Distributed Algorithms. Morgan Kaufmann Publishers, San Francisco
(1997)
28. Naor, M.: A lower bound on probabilistic algorithms for distributive ring coloring.
SIAM Journal on Discrete Mathematics 4(3), 409–412 (1991)

--- Page 15 ---
What Can Be Observed Locally?
257
29. Naor, M., Stockmeyer, L.: What can be computed locally. SIAM Journal on Com-
puting 24(6), 1259–1277 (1995)
30. Nielsen, M.: Conditions for a class of entanglement transformations. Physical Re-
view Letters 83(2), 436–439 (1999)
31. Nielsen, M., Chuang, I.: Quantum Computation and Quantum Information. Cam-
bridge University Press, Cambridge (2000)
32. Owari, M., Matsumoto, K., Murao, M.: Entanglement convertibility for inﬁnite-
dimensional pure bipartite states. Physical Review A 70(5), 1–4 (2004)
33. Pal, S.P., Singh, S.K., Kumar, S.: Multi-partite quantum entanglement versus ran-
domization: Fair and unbiased leader election in networks. Technical report, arXiv:
quant-ph/0306195v1 (June 2003)
34. Pan, J.-W., Chen, Z.-B., ˙Zukowski, M., Weinfurter, H., Zeilinger, A.: Multi-photon
entanglement and interferometry. Technical report, arXiv: quant-ph/0805.2853v1
(May 2008)
35. Peleg, D.: Proximity-preserving labeling schemes and their applications. In: Wid-
mayer, P., Neyer, G., Eidenbenz, S. (eds.) WG 1999. LNCS, vol. 1665, pp. 30–41.
Springer, Heidelberg (1999)
36. Raz, R.: Exponential separation of quantum and classical communication complex-
ity. In: 31st Annual ACM Symposium on the Theory of Computing (STOC), pp.
358–367 (1999)
37. Shor, P.W.: Polynomial-time algorithms for prime factorization and discrete log-
arithms on a quantum computer. SIAM Journal on Computing 26(5), 1484–1509
(1997)
38. Singh, S.K., Kumar, S., Pal, S.P.: Characterizing the combinatorics of dis-
tributed EPR pairs for multi-partite entanglement. Technical report, arXiv: quant-
ph/0306049v2 (January 2004)
39. Ta-Shma, A.: Classical versus quantum communication complexity. SIGACT
News 30(3), 25–34 (1999)
40. Tani, S., Kobayashi, H., Matsumoto, K.: Exact quantum algorithms for the leader
election problem. In: Diekert, V., Durand, B. (eds.) STACS 2005. LNCS, vol. 3404,
pp. 581–592. Springer, Heidelberg (2005)
41. ˙Zukowski, M.: On Bell’s Theorem, quantum communication, and entanglement
detection. In: Foundations of Probability and Physics 5 (August 2008)


=== round-0005/verifier.feedback.md ===
Overall, both reports identify the same missing ingredient: a condition that blocks the “idle state accumulation” obstruction for arbitrary Online-LOCAL(t). The proposed quiescence hypothesis is a natural and useful way to capture many practical greedy/patch-based online algorithms. There is genuine value here; however, some technical details in the statements need tightening before inclusion in output.md.

Key corrections and clarifications
- Separation radius K: To safely run all same-color arrivals in parallel for t rounds, it is not enough to color G^{2t} (or G^{2t+2W}). If two same-color centers v,w have dist(v,w)=2t+1, their active regions B(v,t) and B(w,t) are disjoint but can be adjacent by an edge. Then, during the t-window, messages can cross that single edge in 1 round and couple the two simulations. To forbid any direct edge between distinct active regions, we need dist(v,w) ≥ 2t+2, i.e., a proper coloring of G^{2t+1} (and, with writes W, G^{2t+2W+1}). This “+1” is necessary for rigorous independence of same-color windows in parallel.
- Message forwarding vs quiescence: In the standard LOCAL round semantics (send at start-of-round from current state; receive; then update state), if nodes outside the active region do not change state during the t rounds, they cannot forward newly received information in subsequent rounds: their outgoing messages in each round depend only on their fixed state. Hence no influence can traverse a path that leaves an active region and re-enters another unless there is an edge directly between the two active regions. This is why the K=2t+1 (resp. 2t+2W+1) separation suffices; we do not additionally need to assume that “idle” nodes send no messages, provided we adhere to the standard LOCAL timing semantics and the “no state change outside” clause.
- Step-index dependence and Lemma 7: The commutativity lemma remains sound even if idle nodes apply deterministic updates depending on the global step index. After swapping two consecutive steps, idle nodes still experience exactly the same two step indices in the same order; hence their sequence of updates is identical. It is good to add a clarifying remark to pre-empt confusion.

With these fixes, the quiescent bridge can be safely added to output.md. It properly generalizes the earlier output-only bridges and cleanly delineates where batching works.

Promising directions and next steps
1) Integrate the corrected quiescent bridge. Use K=2t+1 (or 2t+2W+1) and be explicit about the LOCAL round semantics used in the proof. State that disjoint active regions at distance ≥2 and quiescence forbid cross-talk in the t-window.
2) State-elimination-by-quiescence on trees (start with paths, t=1): precisely formalize the interface Σ(u→v) and “normalized executions” (via Cor. 7.1). Try to prove context-invariance: fixing outputs on B(v,2) fixes the feasible behaviors/messages toward v. If this holds, define a canonical interface and obtain a quiescent rule; if not, produce a counterexample LCL on paths.
3) Lower bound track (as in Prover 02): Formalize LB.1 (localized node↔edge elimination within B(e,2t)) and LB.2 (iteration to 0 rounds) for sinkless orientation on trees under Online-LOCAL(t). Cor. 7.1 gives the needed normalization. This would non-constructively imply that any LCL with constant-t Online-LOCAL on trees lies in the O(1)/Θ(log* n) class, giving the desired O(log* n) LOCAL bound.

All these items are complementary; we can make immediate progress by adding the quiescent bridge (with the corrected K) and then pursue either the transformation-to-quiescence or the lower-bound route.

=== notes.md ===
Context and goal
We study the relationship between online-style constant-locality algorithms for LCLs on bounded-degree, unoriented trees and deterministic LOCAL-time upper bounds. Two notions of “online local” are relevant:
- Sequential local/greedy model (order-robust r-local): when processing a vertex v, the decision at v depends only on the r-hop neighborhood B(v,r) of the underlying graph and on already fixed outputs within B(v,r); the algorithm must succeed for every vertex order. No global mutable state or long-range message accumulation between steps.
- Online-LOCAL(t) (Akbari–Eslami–Lievonen–Melnyk–Särkijärvi–Suomela, ICALP’23): vertices arrive one by one; upon each arrival, the algorithm has t synchronous LOCAL rounds on the subgraph induced by arrived vertices; outputs are irrevocable. Over many arrivals, an unbounded number of communication rounds can occur, enabling long-range state accumulation.

Safe, proven variant (archived below in output.md)
- Theorem (Sequential-local to LOCAL): If an LCL Π on bounded-degree graphs has a deterministic order-robust r-local sequential algorithm (decisions at v depend only on B(v,r) and outputs of earlier vertices in B(v,r), and the rule writes only the output at v), then Π has a deterministic LOCAL algorithm running in O(r log* n + Δ^{O(r)}) rounds. On bounded-degree trees with constant r, this is O(log* n). Proof: compute a proper coloring of G^r in O(r log* n) rounds with Δ^{O(r)} colors; process color classes in order, letting each v gather outputs from B(v,r) restricted to earlier colors and apply the sequential rule. Because nodes of the same color are at distance > r, their decisions do not depend on each other.

Gap for the full Online-LOCAL(t) model
- A direct phase simulation that uses a distance-(2t) coloring and t rounds per color does not generally reproduce the state a node v would see upon arrival in an actual online execution. In a true online run, before v arrives, there may have been Θ(n) earlier arrivals, yielding Θ(n)·t global rounds; information can propagate arbitrarily far and may alter the states within B(v,t). The phase simulation grants only O(1)·t total rounds before v’s phase, so the local states can differ. Hence, without additional constraints, we cannot claim that the phase simulation faithfully reproduces the online run or even yields correctness solely from A’s correctness.

Ways forward for Online-LOCAL(t)
- Add a locality-of-dependence assumption: the t-round transcript that determines v’s output depends only on the arrived subgraph inside distance ≤ t from v and on the outputs of those nodes, not on mutable states imported from farther away. Under this, distance-(2t) coloring plus phase simulation is valid and yields O(log* n).
- Alternatively, seek a structural scheduling/padding argument ensuring that for LCLs on bounded-degree trees, the state within B(v,t) before v’s arrival is independent of far-away arrivals. This is nontrivial; try first on paths/trees with t=1 to see whether accumulation can matter for any LCL.
- Or try to separate the models: construct an LCL that is solvable in constant t in Online-LOCAL but provably not simulable by the above constant-phase compression; if such an LCL exists, the general reduction fails, and the sequential-local variant becomes the correct target.

Remarks
- No global edge orientation is needed anywhere in the reduction we proved; IDs suffice for coloring.
- The archived proof applies to all bounded-degree graphs; we stated trees to match the project focus.
Refinements on bridging Online-LOCAL(t) to sequential local rules
- Definitions (recap and refinement):
  • Online-LOCAL(t): vertices arrive one by one; upon each arrival we have t synchronous LOCAL rounds on the subgraph induced by arrived vertices; outputs are irrevocably set at arrival; in the general model, nodes may maintain unbounded mutable state across arrival windows.
  • Output-only Online-LOCAL(t): the only persistent state at nodes is the immutable output label after it is set; between windows there is no other state; in any t-round window, messages sent by a node are functions only of the underlying graph and the currently known outputs within its distance-t neighborhood (no dependence on farther outputs or on pre-window mutable state).
  • t-local-dependence at v: when v arrives, its output depends only on the arrived subgraph restricted to B(v,t) and outputs of the arrived nodes within B(v,t).

- Correct radius accounting:
  • At v’s arrival with window length t, nodes within B(v,t) can influence v. A node u ∈ B(v,t) may compute its messages based on outputs within B(u,t), which is contained in B(v,2t). Thus, in the output-only model, v’s output depends only on the graph structure and outputs within B(v,2t). Consequently, the correct bridge is to a sequential rule of radius 2t (not t). If we assume t-local-dependence at v, the bridge tightens to radius t.

- Minimal counter-scenario (why naive phase-compression fails for the unrestricted online model):
  Consider a path with t=1. In a genuine online run, before a vertex v arrives, Θ(n) earlier arrivals can propagate state one hop per window across the path; by the time v arrives, its neighbors may carry information injected far away. A color-phased simulation that offers only O(1) windows before v’s phase cannot reproduce these accumulated states. This shows that without output-only or t-local-dependence, we cannot black-box simulate arbitrary Online-LOCAL(t) runs by a constant number of phases.

- Practical takeaway for reductions:
  • If your online algorithm is output-only, design the sequential rule to read B(v,2t) and write only at v; then apply the G^{2t} coloring pipeline to get O(log* n) on bounded-degree trees.
  • If your online algorithm satisfies t-local-dependence at v, the sequential rule needs only B(v,t).

- Next-step plan (state elimination on trees):
  • Start on paths with t=1. Define the interface ∂B(v,2) and annulus R=B(v,2)\B(v,1). Attempt to prove: if two online executions agree on outputs over B(v,2), then they allow exactly the same outputs at v. If proven, extend to trees and t by replacing 2 with 2t. If refuted, crystallize a separation example.
  • Track read/write radii for any sequential rules that go beyond “write only at v”; use distance-(R+W) colorings for phase independence.
Additions and corrections

1) Correct simulation radius for bounded writes.
- When simulating an order-robust sequential rule that reads within B(v,R) and may write within B(v,W), independence within a color class requires both:
  • Write–write disjointness: B(u,W) ∩ B(v,W) = ∅.
  • Read–write disjointness: B(u,R) ∩ B(v,W) = ∅ and B(v,R) ∩ B(u,W) = ∅.
- These are guaranteed if dist(u,v) > max(2W, R+W). Therefore, the correct coloring is a proper coloring of G^K with K = max(2W, R+W). Using G^{R+W} alone is insufficient in general.
- Minimal counterexample to G^{R+W}: Take R=0, W=1 on the path u–x–v. Here dist(u,v)=2>R+W, but B(u,1)∩B(v,1)={x} so simultaneous writes conflict.

2) Output-only, W-write Online-LOCAL(t) ⇒ sequential (R,W) with R=2t+W.
- Model: When v arrives, A runs t rounds and may irrevocably write outputs on B(v,W); messages during this window depend only on the graph and the currently known outputs within distance ≤ t of the sender; no other mutable state persists.
- Radius accounting: To decide outputs on the patch B(v,W) within t rounds, only nodes in B(B(v,W), t) = B(v, W + t) can send messages that reach the patch. Under output-only, each such sender’s messages are functions of outputs in its own t-ball. Hence the decisions on the patch depend only on outputs within B(v, W + 2t) = B(v, 2t + W).
- Sequential rule S: For a given order σ, when processing v, S reads already-fixed outputs in B(v, 2t+W) and deterministically reproduces A’s t-window on the patch, writing only to currently-unset outputs in B(v,W). Because A is deterministic and correct for all orders, S reproduces A’s result for order σ.

3) Commutativity of independent arrivals (unrestricted Online-LOCAL(t)).
- If two consecutive arrivals u and w satisfy dist(u,w) > 2t, swapping their order leaves the t-round transcripts and resulting states identical everywhere. In particular, by repeatedly swapping, one can assume that, when analyzing v, only arrivals within B(v,2t) occur before v. This normalizes the analysis horizon for any state-elimination attempt.

4) State-elimination program on paths (t=1) — concrete targets.
- Define the interface K(v) as the already-fixed outputs on B(v,2) just before v arrives (after normalizing the order so only B(v,2) arrives first). Target claim (context-invariance): The set of feasible outputs/messages at v depends only on K(v). If true, derive a canonical sequential rule of read radius R=2 and (potential) write radius W by reproducing the canonical choice. If false, document a counterexample LCL on paths.

5) Accounting for LOCAL complexity when W>0.
- With (R,W)-local sequential rules, compute a proper coloring of G^{K} with K = max(2W, R+W) in O(K log* n) rounds (Lemma 1 simulated on G), then process colors in O(R) rounds per color. On bounded-degree trees with constant R,W, this gives O(log* n) overall.
Disproof of “faithful color-by-color simulation” for unrestricted Online-LOCAL(t)
The tempting idea to fix a proper coloring φ of G^{2t}, choose the arrival order σ_φ that processes color classes 1,2,…,C, and then simulate each color class in O(t) rounds by running all arrivals of that color concurrently, is not valid in the unrestricted Online-LOCAL(t) model.

Key obstruction: In the Online-LOCAL(t) semantics, each arrival triggers t synchronous rounds across the entire arrived subgraph. Nodes outside B(v,t) of the newly arrived vertex v may still update their local state in that step (e.g., increment a local counter) even though they receive no messages. Over k arrivals in a color class, every previously arrived node performs k such "idle" updates. Compressing k steps to 1 per color fails to reproduce the global state unless one can apply k-fold local updates everywhere, which is not locally computable in O(1) rounds.

Minimal counterexample (paths, t=1). Consider the trivial LCL Π that accepts any labeling. Define a deterministic Online-LOCAL(1) algorithm A as follows:
- Every arrived node maintains a parity bit p, initially 0, and toggles p at every arrival step (independently of messages).
- When a new vertex v arrives, in the 1-round window v queries any neighbor u (if one exists) for p and outputs that bit. (If v has no arrived neighbor, it outputs 0.)
This A is correct for Π for every arrival order (Π accepts any labeling). Fix any proper 3-coloring φ of the path’s G^2. In the sequential σ_φ-run that processes all color-1 vertices one by one, p toggles at every arrival, so the outputs of color-1 vertices alternate with their internal order. A batched O(1)-round simulation that processes all color-1 vertices simultaneously cannot reproduce these alternating outputs: all of them see the same parity p from earlier colors and output the same bit. Hence faithful reproduction of the σ_φ-run is impossible in general.

Consequences.
- The earlier “main gap” (state accumulation across many arrivals) is real for unrestricted Online-LOCAL(t): batched simulation does not, in general, preserve the online run’s state trajectory.
- To make per-color batching sound, one needs extra structure such as quiescence: outside B(v,t), the per-step state update is the identity (or, more generally, does not depend on the number of arrivals). The output-only and t-local-dependence variants already enforce related constraints.

On Lemma 8 and local order normalization
- Our Corollary 7.1 already implies the witness localization needed for per-node analysis: by swapping distant arrivals (dist > 2t), one can assume all arrivals before v occur in B(v,2t) without changing the state in B(v,t) at v’s arrival. This is the appropriate normalization tool for any local confluence/interface analysis.

On Lemma 9 (finite enumeration claim)
- As stated (“the set of possible transcripts/messages seen by v is finite”), this is false in the standard LOCAL model due to unbounded message/state spaces and dependence on unique IDs. Finite enumeration becomes viable only if one assumes bounded message alphabets, bounded state, or ID-obliviousness; otherwise, for a fixed constant-size ball B(v,2), the algorithm can encode arbitrarily large ID-dependent information into messages/states.

Next steps for the path/t=1 interface program
- Either (i) impose output-only (or stronger quiescence/ID-obliviousness) and aim to prove the context-invariance Claim C1 under those constraints, or (ii) build a concrete counterexample to C1 in the unrestricted model by letting neighbors’ 1-round messages to v depend on the number of prior arrivals while keeping K(v) fixed. In both tracks, use Corollary 7.1 to restrict attention to B(v,2).

Complexity reminder for bounded writes
- With (R,W)-local sequential rules, independence within a color class requires K = max(2W, R+W). Computing a proper coloring of G^{K} costs O(K·log* n) rounds and per-color work is O(R). For bounded Δ, R, W, this yields O(log* n) total complexity dominated by the coloring step.
New bridge via quiescence (precise form) and radius accounting
- Definition (quiescent Online-LOCAL(t), standard LOCAL timing). In each arrival step for v, the algorithm runs t synchronous LOCAL rounds on the arrived subgraph. Messages sent in round r depend only on the node’s state at the start of round r; at the end of the round, nodes update their state based on received messages. The algorithm is quiescent if, during the t rounds triggered by v’s arrival, every node u with dist(u,v) > t does not change its state in any of these t rounds. (Under the above timing, such u cannot forward newly received information in subsequent rounds because its outgoing messages in round r depend only on its unchanged state.)
- (W,t)-quiescent: If the algorithm may irrevocably write outputs on a patch B(v,W) during v’s window, we call it (W,t)-quiescent if only nodes in B(v,W+t) may change state in that window.

- Correct separation for parallel batching: To parallelize all same-color windows for t rounds without interference, it is necessary to forbid any edge between distinct active regions. For W=0 the active region for v is B(v,t). Thus, a proper coloring of G^{2t+1} (not merely G^{2t}) guarantees that for same-color u,v, dist(u,v) ≥ 2t+2, hence dist(B(u,t), B(v,t)) ≥ 2. This eliminates one-hop coupling across region boundaries. With W>0, color G^{2t+2W+1} so that distinct active regions B(·,W+t) have mutual distance ≥ 2.

- Why quiescence removes the “idle-accumulation” pitfall: In the unrestricted model, nodes can encode the number of prior arrivals into their state and/or messages, letting each new window see different ambient information; batching then fails. Under quiescence, any vertex whose t-window has not yet been processed cannot track steps that do not involve it, so its local view (modulo the already-arrived graph and earlier colors) is invariant across the internal order within a color class. Combined with the ≥2 separation between active regions, the parallel t-round simulation per color faithfully matches any sequential permutation of that color.

- Examples that fit quiescence: Greedy MIS and greedy maximal matching on bounded-degree graphs (W=1, t=1) where only the newly active 1-neighborhood changes, and (Δ+1)-vertex-coloring rules that finalize a 1-hop patch around the arrival.

Remark on Lemma 7 (2t-commutativity)
- The lemma remains valid even if nodes outside B(u,t) ∪ B(w,t) perform deterministic updates depending only on the global step index (and not on messages). Those nodes experience the same two consecutive step indices before and after the swap; hence their pair of updates is identical.

Lower-bound program (outline) for Online-LOCAL on trees
- Target: Prove that sinkless orientation on bounded-degree trees admits no deterministic Online-LOCAL(t)=O(1) algorithm (adversarial arrival). Use Lemma 7/Cor. 7.1 to normalize prefixes so that only B(e,2t) arrives before deciding edge e. Then adapt the node↔edge round-elimination locally inside B(e,2t), iterating 2t times to obtain a 0-round contradiction with the ID-graph property. Formalizing this (LB.1–LB.2) would non-constructively imply: any LCL with constant-t Online-LOCAL on trees lies in the O(1)/Θ(log* n) class, so there exists an O(log* n) deterministic LOCAL algorithm.

Next steps
- Integrate the quiescent bridge with K=2t+1 (resp. 2t+2W+1) into output.md.
- Begin the path (t=1) state-elimination-by-quiescence attempt with a precise interface Σ(u→v) and normalized histories (via Cor. 7.1). Either prove context-invariance or extract a counterexample LCL.
- In parallel, formalize LB.1–LB.2 for sinkless orientation as described above.

=== output.md ===
List of proven results archived here
- Lemma 1: Power-graph coloring in O(k log* n).
- Lemma 2: Color-phased simulation for order-robust read-radius r rules that write only at the current node (W=0).
- Theorem A: Sequential-local (W=0) ⇒ LOCAL on bounded-degree graphs.
- Lemma 3: Bridge from output-only Online-LOCAL(t) (W=0) to order-robust sequential with read radius 2t.
- Lemma 4: Bridge under t-local-dependence (W=0) to read radius t.
- Corollary A: On bounded-degree trees, constant r or constant t ⇒ O(log* n) LOCAL.
- Lemma 5: Color-phased simulation for sequential rules with read radius R and write radius W via a G^{K}-coloring with K = max(2W, R+W).
- Lemma 6: Bridge from output-only, W-write Online-LOCAL(t) to an order-robust sequential rule with (R,W) = (2t+W, W).
- Corollary B: On bounded-degree trees, constant t,W in output-only W-write Online-LOCAL(t) ⇒ O(log* n) LOCAL.
- Lemma 7: 2t-commutativity of independent consecutive arrivals in Online-LOCAL(t), and a corollary pushing far-away arrivals past a fixed v.

Model and definitions
- Graphs: finite, simple, maximum degree Δ < ∞ (bounded degree). Nodes have unique IDs from a polynomial range (standard LOCAL assumptions). dist(·,·) is the hop distance; B(v,r) is the radius-r ball around v.
- LCL Π: a locally checkable labeling problem with constant checkability radius r_Π.
- Order-robust sequential rules with bounded writes: A deterministic rule S with read radius R and write radius W is a procedure that, when processing v in a vertex order σ, inspects G[B(v,R)] and the outputs already fixed in B(v,R) ∩ {earlier vertices in σ}, and may irrevocably write outputs on any currently-unset vertices in B(v,W). The final labeling must satisfy Π for every σ. (The special case W=0 writes only at v.)
- Online-LOCAL(t): vertices arrive one by one; at each step the algorithm executes t synchronous LOCAL rounds on the subgraph induced by the arrived vertices; outputs are irrevocable; nodes may maintain arbitrary local state across steps unless otherwise restricted.
- Output-only Online-LOCAL(t): the only persistent state is the immutable output label after it is set; in any t-round window, messages and local computation at a node may depend on the graph and currently known outputs within distance ≤ t from that node, but not on any other mutable state.
- t-local-dependence (at v): upon v’s arrival, its output depends only on the induced arrived subgraph and previously fixed outputs within B(v,t).
- Output-only, W-write Online-LOCAL(t): as output-only above, but when v arrives the algorithm may irrevocably fix outputs on any vertices in B(v,W).

Lemma 1 (Power-graph coloring in O(k log* n))
Statement. Let G be a bounded-degree graph and k ≥ 1 a constant. There is a deterministic LOCAL algorithm that computes a proper vertex coloring of the power graph G^k with at most C = Δ^{O(k)} colors in O(k log* n) rounds on G.
Proof. Standard: simulate an O(log* n)-round O(Δ(G^k)^2)-coloring on G^k by k rounds per step on G; Δ(G^k) ≤ Δ^k, hence C = Δ^{O(k)}. □

Lemma 2 (Color-phased simulation for W=0)
Statement. Let S be an order-robust sequential rule with read radius r that writes only at the current node (W=0). Given a proper coloring of G^r, processing colors 1,…,C in order reproduces S for any order respecting the color layering, using O(r) rounds per color.
Proof. If φ(u)=φ(v) then dist(u,v)>r, hence the decisions in phase i depend only on outputs from earlier colors and do not interfere. Each node gathers outputs in B(·,r) from earlier colors in O(r) rounds and applies S. □

Theorem A (Sequential-local (W=0) ⇒ LOCAL)
Statement. If Π admits an order-robust r-local sequential algorithm (W=0), then Π has a deterministic LOCAL algorithm running in O(r log* n + Δ^{O(r)}·r) rounds. For constant Δ,r: O(log* n).
Proof. Compute a G^r-coloring in O(r log* n) rounds (Lemma 1), then simulate by Lemma 2. □

Lemma 3 (Output-only Online-LOCAL(t), W=0 ⇒ sequential with read radius 2t)
Statement. If Π has a deterministic output-only Online-LOCAL(t) algorithm correct for every arrival order, then Π admits an order-robust sequential algorithm with read radius 2t (W=0) that reproduces the online outputs for any order.
Proof. Fix order σ. When v_i arrives online under σ, only nodes in B(v_i,t) can send messages that reach v_i within t rounds. Under output-only, any such message depends only on outputs within the sender’s B(·,t), all contained in B(v_i,2t). Hence v_i’s t-window transcript and output are functions of the restriction to B(v_i,2t) of the arrived subgraph and outputs. Define the sequential rule to read those and return the same output as the online algorithm would under σ. Correctness and order-robustness follow. □

Lemma 4 (Bridge under t-local-dependence, W=0)
Statement. If Π has a deterministic Online-LOCAL(t) algorithm with t-local-dependence (at every v) that is correct for every arrival order, then Π admits an order-robust sequential algorithm with read radius t (W=0).
Proof. As in Lemma 3, but with t in place of 2t by hypothesis. □

Corollary A (Bounded-degree trees, constant r or t)
Statement. On bounded-degree trees, if Π has either (i) an order-robust r-local sequential algorithm (W=0) with constant r, or (ii) an output-only Online-LOCAL(t) algorithm (W=0) with constant t, or (iii) an Online-LOCAL(t) algorithm with t-local-dependence and constant t, then Π has a deterministic LOCAL algorithm with round complexity O(log* n).
Proof. Combine Theorem A with Lemma 3 or Lemma 4 as applicable; Δ and radii are constants. □

Lemma 5 (Color-phased simulation with bounded writes)
Statement. Let S be an order-robust sequential rule with read radius R and write radius W ≥ 0 (S may write outputs on currently-unset vertices in B(v,W)). Let φ be a proper coloring of G^{K} with K = max(2W, R+W). Then processing colors 1,…,C in order reproduces S for any order that respects the color layering. The per-color communication cost is O(R) rounds after φ is known.
Proof. If φ(u)=φ(v) then dist(u,v) > K ≥ 2W and > R+W. Thus (i) B(u,W) ∩ B(v,W) = ∅ (no write–write conflicts) and (ii) B(u,R) ∩ B(v,W) = ∅ and B(v,R) ∩ B(u,W) = ∅ (no read–write interference). In phase i, each vertex v with φ(v)=i gathers outputs written by earlier colors within B(v,R) and computes its writes; because of (i)–(ii), these writes are independent across same-color vertices and depend only on earlier colors, so the result matches S for any order that lists all lower colors first and then the current color in any internal order. O(R) rounds suffice to gather B(v,R) information. Computing φ takes O(K log* n) rounds by Lemma 1 with k=K. □

Lemma 6 (Output-only, W-write Online-LOCAL(t) ⇒ sequential with (R,W)=(2t+W,W))
Statement. If Π has a deterministic output-only, W-write Online-LOCAL(t) algorithm A correct for every arrival order, then Π admits a deterministic order-robust sequential rule S that, when processing v, reads only B(v, 2t+W), may write on currently-unset vertices in B(v,W), and reproduces A’s outputs for any order.
Proof. Fix order σ = (v_1,…,v_n). Consider A under arrival order σ. When v_i arrives, during its t-round window only nodes within distance ≤ t of the patch B(v_i,W) can send messages that reach the patch; hence all influencing senders lie in N := B(B(v_i,W), t) = B(v_i, W+t). Under output-only, messages sent by any u ∈ N depend only on outputs within B(u,t). Therefore the union of outputs that can affect the patch’s decisions lies in M := ⋃_{u∈N} B(u,t) = B(v_i, W+2t). Consequently, the t-round transcript determining the patch outputs in the σ-run is a function of the restriction of the arrived subgraph and already-fixed outputs to B(v_i, 2t+W). Define S as follows: when processing v_i under σ, S collects the already-fixed outputs within B(v_i, 2t+W) ∩ {v_1,…,v_{i-1}} and deterministically reproduces A’s t-window decisions on the patch given that local view, writing only to vertices in B(v_i,W) whose outputs are not yet fixed. Because A is deterministic and respects irrevocability, this reproduces exactly the same patch outputs as A under σ and never overwrites. As A is correct for every order, S is an order-robust (R,W)-local rule with R=2t+W. □

Corollary B (Bounded-degree trees, output-only W-write ⇒ O(log* n) LOCAL)
Statement. On bounded-degree trees, if Π has a deterministic output-only, W-write Online-LOCAL(t) algorithm with constants t,W, then Π has a deterministic LOCAL algorithm with round complexity O(log* n).
Proof. Apply Lemma 6 to obtain a sequential (R,W)-rule with R=2t+W. Then use Lemma 5 with K = max(2W, R+W) = max(2W, 2t+2W) = 2t+2W to simulate S in the LOCAL model: compute a proper coloring of G^{2t+2W} in O((2t+2W) log* n) rounds, then spend O(R)=O(2t+W) rounds per color. For constant Δ,t,W the total is O(log* n). □

Lemma 7 (2t-commutativity of independent consecutive arrivals)
Statement. Let A be any deterministic Online-LOCAL(t) algorithm (unrestricted mutable state). Consider an arrival sequence σ and two consecutive arrival steps at vertices u and w such that dist(u,w) > 2t. Let σ′ be obtained by swapping these two steps. Then, after these two steps, the states and fixed outputs at all vertices are identical under σ and under σ′.
Proof. Let G_i be the arrived subgraph just before these two steps. In the step when u arrives under σ, A executes t synchronous rounds on G_i ∪ {u}. Messages can traverse at most t hops per window, so only nodes in B(u,t) can be influenced (either by receiving messages or by depending on received messages); nodes outside B(u,t) undergo the same deterministic state updates as they would in any window where they receive the same (empty) messages. Likewise, w’s step affects only B(w,t). Because dist(u,w) > 2t, the balls B(u,t) and B(w,t) are disjoint, and w is absent during u’s step and u is absent during w’s step in both σ and σ′. Therefore the t-round transcripts and resulting updates within B(u,t) (resp. B(w,t)) are identical in σ and σ′, and all other vertices experience no message-dependent changes in either order. Thus the combined effect of the two steps commutes. □

Corollary 7.1 (Pushing far-away arrivals past v)
Statement. Fix v and any arrival sequence. By repeatedly swapping consecutive independent steps via Lemma 7, one can transform the sequence into another in which all vertices at distance > 2t from v arrive after v, without changing any states or outputs within B(v,t) at the time v arrives (or thereafter).
Proof. Iteratively swap any arrival at distance > 2t from v forward past earlier arrivals until it occurs after v; Lemma 7 ensures the swaps preserve the relevant states/outputs. □

Remark. Lemma 5 supersedes the earlier, flawed variant that required only a G^{R+W}-coloring; the counterexample R=0, W=1 on a 3-path shows that G^{R+W} is insufficient because write–write conflicts may occur.
Remark (No faithful t-per-color batching for unrestricted Online-LOCAL(t)). There exists a deterministic Online-LOCAL(1) algorithm A and a valid color-by-color arrival order σ_φ (induced by a proper coloring φ of G^2 on a path) such that any LOCAL simulation that processes all vertices of the same color class simultaneously in O(1) rounds cannot reproduce the exact outputs produced by A under the sequential σ_φ-run.
Proof. Consider the trivial LCL Π that accepts any labeling. Algorithm A maintains at each arrived node a parity bit p (initially 0) that toggles at every arrival step (regardless of messages). When a new vertex v arrives, in its 1-round window it reads p from an already-arrived neighbor if one exists and outputs that bit (if v has no arrived neighbor, it outputs 0). Fix any proper 3-coloring φ of the path’s G^2 and let σ_φ process colors 1,2,3 in order, with any internal order inside a color. In the sequential σ_φ-run, the parity p toggles at every arrival, hence the outputs of the vertices of any color class alternate with the internal order. In contrast, if one processes all vertices of a color class simultaneously in a single 1-round batch (keeping not-yet-processed colors absent), all these vertices observe the same parity p from earlier colors and therefore all output the same bit. Thus the batched simulation does not reproduce A’s outputs under σ_φ. □

Remark (Complexity accounting for Lemma 5/Corollary B). On bounded-degree graphs with constants t,W, the coloring step on G^{K} (K = max(2W, R+W), with R = 2t+W in Corollary B) costs O(K·log* n) rounds and yields C = Δ^{O(K)} colors; the per-color work is O(R). Hence the total complexity is O(log* n), dominated by the coloring step.
Definition (Quiescent Online-LOCAL(t) and (W,t)-quiescent)
Consider the standard LOCAL timing in an arrival step: in each of t synchronous rounds, each arrived node first sends messages as a (deterministic) function of its current state, then receives messages from neighbors, and finally updates its state as a (deterministic) function of its current state and the received messages.
- An Online-LOCAL(t) algorithm A is quiescent if, upon the arrival of v, during the ensuing t rounds every node u with dist(u,v) > t does not change its state in any of these t rounds.
- More generally, A is (W,t)-quiescent if, upon the arrival of v, during the ensuing t rounds only nodes in the active region B(v, W+t) may change their state; nodes outside B(v,W+t) do not change state.

Lemma 8 (Quiescent Online-LOCAL(t) ⇒ O(log* n) LOCAL; bounded-writes variant)
Let Π be an LCL on bounded-degree graphs. Suppose Π has a deterministic quiescent Online-LOCAL(t) algorithm A with constant t.
(i) Then Π admits a deterministic LOCAL algorithm with round complexity O((2t+1)·log* n + t·Δ^{O(t)}) = O(log* n).
(ii) More generally, if A is (W,t)-quiescent with constants W,t, then Π admits a deterministic LOCAL algorithm with round complexity O((2t+2W+1)·log* n + t·Δ^{O(t+W)}) = O(log* n).

Proof.
Fix K := 2t+1 in case (i), and K := 2t+2W+1 in case (ii). By Lemma 1, compute a proper coloring φ of G^{K} with C = Δ^{O(K)} colors in O(K·log* n) rounds. We process the colors in increasing order i = 1,2,…,C in phases; at the start of phase i, exactly the vertices of colors < i are considered “already arrived,” and vertices of colors ≥ i are “not yet arrived.”

In phase i we simulate, in parallel, the t-round online arrival window of every vertex v with φ(v)=i, on the subgraph induced by vertices of colors ≤ i, as follows: (a) we declare all vertices of color i to “arrive” at the beginning of the phase, and (b) we perform t synchronous LOCAL rounds on that induced subgraph. During this phase, the algorithm A is executed faithfully at every vertex, except that vertices of colors > i are absent.

Let R_v denote the active region of v during this phase: R_v = B(v,t) in case (i) and R_v = B(v, W+t) in case (ii). Because φ colors G^{K} with K as above, for any two distinct same-color vertices v,w we have dist(v,w) ≥ K+1, hence dist(R_v, R_w) ≥ 2. In particular, there is no edge between R_v and R_w.

Quiescence and the LOCAL timing imply two key facts within phase i:
1) Only nodes in R := ⋃_{φ(v)=i} R_v may change state during the t rounds of phase i; all nodes outside R keep their state fixed throughout the phase. Since messages sent in a round depend only on the sender’s current state at the start of that round, such outside nodes cannot forward newly received information in subsequent rounds. Consequently, there is no causal influence along any path that leaves one R_v and re-enters another R_w within the t rounds, because such a path must traverse at least one node outside R which cannot propagate new information.
2) Since dist(R_v, R_w) ≥ 2, there is neither an edge nor a length-1 path between distinct active regions.

From 1)–2) it follows that, during phase i, the evolution of each R_v is identical to what would occur if we executed only v’s t-round window in isolation (with all other color-i vertices absent), given the same boundary states on the external neighborhood of R_v (which are precisely the states fixed by earlier colors). Formally, this can be proved by induction on the round counter r=1,…,t, using the domain-of-dependence that is confined to R_v together with outside nodes whose states remain constant.

Therefore, the combined effect of phase i equals the composition of the individual “v-arrival” windows over all vertices v with φ(v)=i, in any internal order. By induction on i, after finishing phase i the global state/output coincides with the online execution that processes first all color-1 vertices (in an arbitrary order), then all color-2 vertices, and so on. Since A is correct for every arrival order, the final labeling after phase C is legal for Π.

The complexity is O(K·log* n) to obtain φ and t rounds per color, i.e., O(t·C) additional rounds. For constant Δ, t, W, we have C = Δ^{O(K)} = O(1), so the total is O(log* n). □

Remark (on the choice of K). The choice K = 2t (resp. 2t+2W) is insufficient for the parallel phase: if dist(v,w)=2t+1 (resp. 2t+2W+1), then R_v and R_w are disjoint but may be adjacent by an edge, allowing one-round coupling between the two active regions. The value K = 2t+1 (resp. 2t+2W+1) guarantees dist(R_v, R_w) ≥ 2, which prevents such coupling and makes the above proof sound.

Remark after Lemma 7 (idle updates depending on step index). In Lemma 7, nodes outside B(u,t) ∪ B(w,t) may perform deterministic updates that depend on the global step counter but not on messages. When two consecutive arrivals at u and w with dist(u,w) > 2t are swapped, those nodes still undergo the same two consecutive step indices in the same order, so their pair of updates is unchanged. This clarifies that Lemma 7 tolerates such idle updates.


Current round tag: Round 0006 — 2025-08-27T19:49:16.190148Z
Return ONLY valid JSON with a single field:
{ "progress_md": "<your progress notes for this round>" }

Read output.md. If you spot gaps, errors, or missing justifications in output.md, point them out clearly inside progress_md.
