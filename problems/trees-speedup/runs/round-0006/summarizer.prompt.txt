--- SYSTEM ---
You are a research **summarizer**. Summarize this *last round only* for a human log.

Include:
- 3–7 bullet **Highlights** (facts learned, reductions, counterexamples, partial bounds).
- 1–3 **Open questions / TODOs** for the next round.
- 1–3 **Citations to files** you relied on (e.g. round files or papers by name).

**Return strictly JSON**:
{
  "summary_md": "Readable summary of the round (≤200 words)",
  "highlights": [],
  "next_questions": []
}

--- USER ---
=== prover-01.out.json (progress_md) ===
Status and aim
- Goal: Prove that any LCL solvable in O(1) rounds in deterministic Online-LOCAL(t) on bounded-degree (nonoriented) trees is solvable in O(log* n) rounds in LOCAL.
- Current archive: We have complete bridges for (i) output-only (with/without bounded writes) and (ii) t-local-dependence, plus the commutativity lemma (2t) and a quiescent bridge (Lemma 8) with the corrected separation K = 2t+1 (or 2t+2W+1) for safe per-color batching. We also documented why unrestricted Online-LOCAL(t) cannot be faithfully batched without extra structure.

New incremental results (clean statements and proofs)

1) Strong witness-localization (model-agnostic; to support localized arguments)
- Lemma 9 (Strong witness-localization at v). Let A be a deterministic Online-LOCAL(t) algorithm (no restrictions), G a bounded-degree graph, and σ any arrival sequence. For any vertex v, there exists a sequence σ_v obtained from σ by repeatedly swapping adjacent arrivals at distance > 2t such that:
  (i) All arrivals before v in σ_v are at vertices in B(v,2t).
  (ii) The arrived subgraph just before v arrives in σ_v equals the restriction of the original arrived subgraph to B(v,2t).
  (iii) The entire state on B(v,t) at the moment v arrives (including fixed outputs and any mutable state) is identical under σ and σ_v.
- Why useful here: It confines all pre-v influences to a finite ball, enabling local case analyses and localized reductions (e.g., round-elimination inside B(v,2t)) without assumptions like quiescence.
- Proof sketch (checkable). Swap adjacent independent arrivals (distance > 2t) using Lemma 7. Each swap preserves states in B(v,t) at the time v arrives because neither swapped step can influence B(v,t) in t rounds. Iterating, push every pre-v arrival outside B(v,2t) past v. The arrived subgraph outside B(v,2t) is absent before v in σ_v, establishing (i)–(ii). Preservation of states in B(v,t) at v’s arrival is maintained by each swap, giving (iii).

2) Quiescent domain-of-dependence inside a phase (tightening Lemma 8’s core invariant)
- Lemma 10 (Phase-locality under quiescence). Consider a (W,t)-quiescent Online-LOCAL(t) algorithm A. Fix a proper coloring φ of G^{K} with K = 2t+2W+1, and simulate phase i as in Lemma 8: all vertices v with φ(v)=i arrive simultaneously, and we run t LOCAL rounds over the induced subgraph of colors ≤ i. For each such v, let R_v = B(v,W+t).
  Claim: During phase i, the state evolution on R_v depends only on (a) the initial states on R_v ∪ ∂R_v at the start of the phase (i.e., after phase i−1), and (b) the algorithm A, and it is identical to executing v’s t-window in isolation with those boundary states. In particular, the combined effect of the phase equals the composition (in any order) of the individual arrival-windows of vertices of color i.
- Why useful here: This is the precise “active-region independence” that makes Lemma 8’s batching sound; it also clarifies why the +1 in K is necessary.
- Proof (detailed induction). Because dist(R_v,R_w) ≥ 2 for distinct same-color v,w when K = 2t+2W+1, there is no edge between different active regions. Quiescence implies nodes outside R := ⋃_{φ(v)=i} R_v do not change state during the t rounds of the phase, and under standard LOCAL timing (send from current state; receive; update) such nodes cannot forward any newly received messages in later rounds—outgoing messages depend only on their unchanged state at the start of each round. Hence, any path starting in R_v and reaching a node in R_w would have to traverse at least one node outside R that cannot propagate new information; therefore, no causal influence can cross from one active region to another within the t rounds. Induction on the round counter r=1,…,t shows that the transcript inside each R_v is identical to that of running v’s window alone with the same boundary states (states on ∂R_v are frozen during the phase). Therefore, the phase equals the composition of independent arrival windows of its color-class.

3) Localized round-elimination for Online-LOCAL(t) on trees (lower-bound track)
We formalize the key step needed to show that log n-hard LCLs (e.g., sinkless orientation) cannot have deterministic constant-t Online-LOCAL algorithms on bounded-degree trees. This, combined with the tree LCL classification, would imply the desired O(log* n) LOCAL upper bound for the class “Online-LOCAL(t)=O(1) on trees”.

- Setup and notation. Work on a Δ-regular infinite tree T_Δ (or large finite high-girth trees) with an ID-graph H as in Definition 2.16 (girth ≥ γ log_Δ n; color-classes Hi with each independent set < n/Δ). Consider deterministic Online-LOCAL(t) A that solves sinkless orientation (or its node-form edge-grabbing) for all arrival orders. Use Lemma 9 to localize to a finite ball and the ID-graph framework to avoid reliance on global unique IDs.

- Lemma LB.1 (Online node→edge reduction within a fixed ball). Suppose A solves node-form edge-grabbing in Online-LOCAL(t) on Δ-regular trees for all arrival orders. Fix an edge e = uv and normalize so that before the decisive steps at u and v, all prior arrivals lie in B(e,2t) (by Lemma 9). There exists a deterministic edge-centered Online-LOCAL(t−1/2) rule A′ on B(e,2t) that orients e based solely on the local neighborhood B(e,2t) and consistent arrival orders inside that ball. Formally: define A′ so that e is oriented from u→v if and only if there exists a pre-v normalized arrival order inside B(u,t) consistent with the current arrived subgraph in B(e,2t) leading A at u to grab e; similarly for v→u. These definitions are non-conflicting and well-defined.
  Why useful: This is the Online analogue of the one-half round-elimination step (node-to-edge), localized within a bounded-radius ball. It sets up the iterative descent to 0-round.
  Proof idea (verifiable conditions). The only obstruction would be “double grab”: both u and v have consistent local histories leading to grabbing e. But then we can glue the two histories into a single normalized local execution inside B(e,2t), and extend to a global arrival sequence (complete T_Δ outside the ball; push all outside arrivals after the decision via Lemma 9) that makes A grab e from both ends—contradiction with correctness. The gluing is feasible because arrivals are confined to B(e,2t), each endpoint’s t-window depends only on B(endpoint,t), and the union remains within B(e,2t); overlapping influences are identical by determinism, and no information from outside the ball is needed (by Lemma 9). The reduction is edge-centered and costs one half-step of dependence radius.

- Lemma LB.2 (Iterated localized elimination to 0 rounds). Starting from a node-centered Online-LOCAL(t) solution for sinkless orientation on Δ-regular trees, iterate LB.1 and its symmetric edge→node reduction (the standard pair in round elimination) within B(·,2t). After 2t iterations, obtain a 0-round edge-centered rule A^{(0)} on B(e,2t) deciding the orientation of e as a function only of the local ID labels on B(e,2t).
  Why useful: A^{(0)} induces a 0-round global labeling depending only on the ID-graph labels, contradicting the ID-graph property (Definition 2.16) exactly as in the classical proof for LOCAL. Hence, no deterministic constant-t Online-LOCAL algorithm solves sinkless orientation on trees.
  Proof idea (structure mirrors classical). The normalized-balls argument (Lemma 9) ensures that at each step, all needed information is inside a constant-radius ball; determinism plus the non-conflict property from LB.1 and its converse allow well-defined round-elimination steps. The finite number (2t) of steps yields a 0-round prescription; the ID-graph contradiction follows because such a prescription would color H with Δ colors avoiding monochromatic edges within Hi, impossible by the independence bound in Definition 2.16.

- Corollary LB (Non-existence of constant-t online for log n-hard LCLs). Sinkless orientation has no deterministic Online-LOCAL(t)=O(1) algorithm on bounded-degree trees. By Theorem 2.33 (classification on trees), any LCL with O(1) online complexity cannot be in the log n-hard class; thus it lies in the O(1)/Θ(log* n) class. Therefore, any LCL solvable in O(1) deterministic Online-LOCAL(t) on bounded-degree trees admits an O(log* n) deterministic LOCAL algorithm (existentially).

Why these are progress
- Lemma 9 and Lemma 10 make the previously informal core invariants fully explicit and reusable: (i) state confinement to B(v,2t) for unrestricted online, and (ii) phase-wise active-region independence under quiescence.
- Lemmas LB.1–LB.2 provide the localized round-elimination scheme needed for the lower-bound path. The statements are precise and reduce the remaining work to filling in the standard gluing construction and the symmetric edge→node half-step, both classical in flavor but with the normalized-ball twist (Lemma 9).

Examples and sanity checks
- Minimal K for quiescent batching: Two same-color centers at distance 2t+1 have disjoint active regions B(·,t) but these can be adjacent by one edge. In round 1, a message can cross that edge, coupling the evolutions. Hence K = 2t is insufficient; K = 2t+1 ensures ≥2-hop separation.
- Typical quiescent online rules: Greedy MIS and maximal matching with W=1, t=1 modify only B(v,1) at each arrival; they are (W,t)-quiescent. Lemma 8 yields O(log* n) LOCAL as already recorded.

Obstacles and open items
- For LB.1, the “gluing” step must be spelled out so that any two locally consistent normalized histories can be realized inside B(e,2t) without conflict. This uses determinism and the 2t horizon; we need to check corner cases where the two histories interact through nodes at distance exactly t from both u and v. The conflict-freedom argument via contradiction is standard but must be carefully written.
- The symmetric edge→node reduction (half-step) must be stated and proved in the online setting, paralleling LB.1. This is straightforward but needs a clean write-up.
- State-elimination (constructive simulation) on trees without quiescence remains open. The lower-bound program bypasses constructive simulation but proves the target speedup existentially by excluding the log n-hard class.

Edits and additions suggested for output.md
- Add Lemma 9 (Strong witness-localization at v) with full proof. It is model-agnostic and will be useful for both the lower-bound program and any future interface-invariance attempts.
- In Lemma 8’s proof, we already included the K = 2t+1 (or 2t+2W+1) separation and the standard LOCAL round semantics. We recommend explicitly stating the two facts used in Lemma 10 (active-region independence and non-forwarding by quiescent outside nodes) as a short standalone claim, to make the dependency clear.
- Create a new subsection “Online round-elimination on trees” with precise statements of Lemmas LB.1 and LB.2 (as above) and a roadmap to the ID-graph contradiction. This does not change any prior result but clarifies the pathway to the main theorem under unrestricted Online-LOCAL(t).

Next steps (auditable)
1) Write the full proof of Lemma 9 and add it to output.md. (Most of the argument is already implicit in Corollary 7.1; formalize items (ii)–(iii) carefully.)
2) Insert Lemma 10’s phrasing (active-region domain-of-dependence) as a paragraph in Lemma 8’s proof, with a short inductive argument per round.
3) Formalize LB.1 (node→edge) and the symmetric edge→node step for Online-LOCAL(t) on Δ-regular trees with ID-graph H. Carefully define “locally consistent normalized arrivals” inside B(e,2t) and the gluing argument.
4) Complete LB.2 to 0 rounds and the ID-graph contradiction, giving the lower bound for sinkless orientation. State the existential corollary for the main task (O(log* n) LOCAL for any LCL with O(1) Online-LOCAL(t) on trees).
5) Optionally, continue exploring the constructive path: try to establish interface invariance on paths for t=1 under extra constraints (bounded-state or ID-obliviousness), or produce a counterexample LCL under unrestricted online showing that quiescence is not w.l.o.g.

Gaps or errors spotted in output.md
- None critical. The separation radii for quiescent batching (K = 2t+1 and 2t+2W+1) are correctly recorded with an explanatory remark. Lemma 5’s K = max(2W, R+W) is appropriate for sequential rules (no extra +1 needed). The commutativity lemma includes the clarifying remark about deterministic step-index updates. We suggest adding the standalone formalization of Lemma 9 and the localized round-elimination lemmas LB.1–LB.2 as described above.

=== prover-02.out.json (progress_md) ===
Status and alignment with task
- The curated output.md now contains: (i) the output-only bridges (W=0 and W>0), (ii) the read/write simulation with the corrected K = max(2W, R+W), (iii) a 2t-commutativity lemma that localizes influence to B(·,2t), and (iv) a new quiescent bridge (Lemma 8) with the corrected separation K = 2t+1 (or 2t+2W+1) and a proof that respects standard LOCAL round timing. These cover an O(log* n) simulation for output-only and for (W,t)-quiescent Online-LOCAL(t).
- The remaining open gap is the unrestricted deterministic Online-LOCAL(t) on trees, where idle state accumulation across many arrivals can foil color-phased batching.

Gaps or clarifications in output.md (minor and easy to address)
- Corollary B vs Lemma 8 radii: Corollary B uses K = 2t+2W (no +1), which is correct because it simulates a derived sequential (R,W)-rule via Lemma 5, not batched online windows. Lemma 8 requires +1 since it parallelizes online t-windows per color and must forbid a single edge between active regions. Consider adding a one-sentence remark after Corollary B explaining why there is no +1 there but there is in Lemma 8.
- Hypotheses of Lemma 8: It may help to restate explicitly that the standard LOCAL round timing is assumed (send based on current state, receive, then update), and that nodes outside the active region do not change their state; hence they cannot forward newly received information in later rounds. This explains the domain-of-dependence argument used in the proof.

New incremental, testable steps towards closing the unrestricted case on trees
A) Localized round-elimination for Online-LOCAL(t) on trees (lower-bound route)
- Goal: Show that sinkless orientation does not admit deterministic Online-LOCAL(t) with constant t on bounded-degree trees. Then, by the tree-LCL classification (Theorem 2.33), any LCL solvable in constant Online-LOCAL(t) lies in the O(1)/Θ(log* n) class, implying the required O(log* n) deterministic LOCAL upper bound.
- Tool already in output.md: Lemma 7 and Cor. 7.1 localize pre-decision influence to B(e,2t). We leverage this to run a localized node↔edge round-elimination inside a fixed ball.
- Lemma LB.1 (Node→edge localization). On a Δ-regular tree with an ID-graph H as in Def. 2.16, assume A is a deterministic Online-LOCAL(t) algorithm that solves node-centered edge grabbing for all arrival orders. Fix an edge e = uv and normalize the prefix by Cor. 7.1 so that only B(e,2t) arrives before deciding e. Then there is an edge-centered (t−1/2)-local reduction that determines the orientation of e by exhaustively considering all normalized local arrival orders within B(e,2t) consistent with the fixed ID labels on the ball. Why sound: any two “local witnesses” that would force opposite decisions for e can be extended to global inputs and arrival orders (by pushing all other arrivals past e using Cor. 7.1), contradicting correctness of A.
- Lemma LB.2 (Iterated elimination). Iterating LB.1 and its converse edge→node step 2t times yields a 0-round edge-centered algorithm tied to an ID-graph labeling, contradicting the ID-graph property (Def. 2.16) as in the classical proof. Hence no deterministic constant-t Online-LOCAL algorithm can solve sinkless orientation on trees.
- Why checkable: Both lemmas operate entirely inside B(e,2t), a finite object for fixed Δ,t. The “glueability” claim (extending consistent local arrival orders to a global order) is justified by Cor. 7.1 and the tree structure (no cycles) and can be written as a standalone lemma (Normalization-and-extension lemma) for verification.

B) Strengthening the quiescent bridge (positive route)
- Interface-of-boundary states lemma. In Lemma 8’s proof, one may formalize the dependency as: for v in phase i, the transcript in R_v depends only on the boundary states on ∂R_v at the start of the phase. Because boundary nodes do not change state during the phase and dist(R_v,R_w) ≥ 2 for v≠w of the same color, transcripts in distinct active regions are independent and coincide with any sequential permutation. This lemma can be added as a short formal claim nested in Lemma 8.
- Special case W=0 on trees: give a tiny sanity example (path, t=1) showing necessity of K=2t+1 by constructing two same-color centers at distance 2t+1=3; an edge between the two radius-1 regions permits one-round coupling if K=2t.

C) Path, t=1 interface program (state-elimination-by-quiescence attempt)
- Definitions: For a path and t=1, let K(v) be the restriction of already fixed outputs to B(v,2) just before v arrives, after normalizing arrivals via Cor. 7.1. For each neighbor u of v, define Σ(u→v;K) as the set of outgoing 1-round messages u can send to v over all normalized arrival orders within B(v,2) consistent with K.
- Target (context-invariance on paths): Prove that Σ(u→v;K) depends only on K (not on deeper mutable histories). If true, choose a canonical selector g(K) ∈ Σ(u→v;K) and define a quiescent online rule A′ whose neighbor interfaces are g. This would yield a quiescent Online-LOCAL(1) algorithm equivalent on paths, extendable to trees by branch decomposition, and to general t by replacing radii 1,2 with t,2t.
- Why auditable: All normalized histories live in the finite ball B(v,2); we can try to either prove invariance or build an explicit LCL counterexample where Σ differs while K is fixed.

Sanity checks, tiny examples
- Necessity of +1 in Lemma 8: On a path, t=1, pick two centers at distance 3. Their B(·,1) balls are disjoint but adjacent; if nodes outside active balls may not change state but still send messages based on (fixed) state, a single cross-edge allows a one-round signal between regions, so K=2t would be unsafe. K=2t+1 forbids such an edge.
- Consistency of radii across the pipeline: Output-only W-write bridge first derives a sequential rule with R=2t+W, then simulates it with K=max(2W,R+W)=2t+2W (no +1). The +1 appears only in Lemma 8, which batches online windows per color.

Why this is progress
- We provide concrete, local lemmas (LB.1–LB.2) that, once formalized, would rule out constant-t Online-LOCAL for the log n-hard class (sinkless orientation), thereby establishing the desired O(log* n) LOCAL upper bound for any LCL solvable in constant Online-LOCAL(t) on bounded-degree trees.
- We sharpen the quiescent bridge with a boundary-state lemma and sanity examples, reinforcing its correctness and clarifying the role of K.
- We outline an auditable path/t=1 program to try to compile arbitrary Online-LOCAL into a quiescent one via local interface canonicalization; this has clear success/failure outcomes confined to constant-radius balls.

Next steps (actionable)
1) Write formal proofs of LB.1 and LB.2 in output.md, including the normalization-and-extension lemma (any local arrival order inside B(e,2t) extends to some global order without altering states inside B(e,t) up to e’s decision time).
2) Augment Lemma 8 with a brief “boundary-state sufficiency” sub-lemma and add a short remark after Corollary B about why the +1 is unnecessary there but needed in Lemma 8.
3) Start the path, t=1 interface analysis: (i) define Σ(u→v;K) precisely, (ii) attempt a proof of context-invariance, or (iii) construct a minimal LCL counterexample on a path if invariance fails. Document either outcome.
4) Double-check all radius constants with toy graphs to prevent off-by-one mistakes (in particular, re-verify K=2t+2W+1 for (W,t)-quiescent and K=max(2W, R+W) for sequential (R,W)-simulation).


=== Verifier (summary_md) ===

=== Verifier (verdict) ===
partial success

