--- SYSTEM ---
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (summary so far)
- output.md (rigorously proven results so far)

Guidelines:
- notes.md: should be a readable running log of interesting work. Prefer appending. Replace only if old notes are clearly misleading. Remember -- notes should be self-contained and should make sense even without seeing outputs of past provers. 
- output.md:  Think twice before you add something to this file. Everything here should be rigorous, almost publication-ready. It should contain only fully proven theorems that are clearly an interesting step towards the solution (or the solution itself). The beginning of the file is a clear list of interesting theorems you can prove, together with a discussion about why it is relevant. From the statement of the theorem it has to be clear that this constitutes nontrivial progress towards solution. The rest of the file contains a fully rigorous list of the proofs of the theorems. Keep only proven theorems with clear proofs. If a statement in that file is flawed / unprecise and you cannot fix it on the spot, remove it from output.md and instead add it to notes.md with explanation.
- Be careful with the booleans `new_notes_append` and `new_outputs_append`: default is True (append). Use False only when deliberately rewriting everything.

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (≥200 words). Include concrete next-step suggestions. The next round of provers may not see last round outputs; ensure all valuable info is stored in notes.",
  "new_notes_md": "Markdown (KaTeX allowed). Usually appended to notes.",
  "new_notes_append": "True|False",
  "new_outputs_md": "Markdown (KaTeX allowed). Usually appended to output.md.",
  "new_outputs_append": "True|False",
  "verdict": "success|partial success|nothing so far"
}

**Verdict definitions**:
- **success**: Something that one could publish, even if it is not the full solution (e.g., significant theorem, key lemma, novel technique, partial solution with clear path forward)
- **partial success**: Something worthy enough to write into output.md (e.g., correct but preliminary results, useful technical lemmas, validated approaches that advance understanding)
- **nothing so far**: No meaningful mathematical progress or only exploratory work


--- USER ---
You receive multiple prover reports. Evaluate correctness, value, and pick promising directions. Update notes.md (append/replace) with useful ideas and update output.md (append/replace) ONLY with rigorously verified results.

Prover reports (JSON):
[{"prover_id": "01", "progress_md": "Status and aim\n- Goal: Prove that any LCL solvable in O(1) rounds in deterministic Online-LOCAL(t) on bounded-degree (nonoriented) trees is solvable in O(log* n) rounds in LOCAL.\n- Current archive: We have complete bridges for (i) output-only (with/without bounded writes) and (ii) t-local-dependence, plus the commutativity lemma (2t) and a quiescent bridge (Lemma 8) with the corrected separation K = 2t+1 (or 2t+2W+1) for safe per-color batching. We also documented why unrestricted Online-LOCAL(t) cannot be faithfully batched without extra structure.\n\nNew incremental results (clean statements and proofs)\n\n1) Strong witness-localization (model-agnostic; to support localized arguments)\n- Lemma 9 (Strong witness-localization at v). Let A be a deterministic Online-LOCAL(t) algorithm (no restrictions), G a bounded-degree graph, and \u03c3 any arrival sequence. For any vertex v, there exists a sequence \u03c3_v obtained from \u03c3 by repeatedly swapping adjacent arrivals at distance > 2t such that:\n  (i) All arrivals before v in \u03c3_v are at vertices in B(v,2t).\n  (ii) The arrived subgraph just before v arrives in \u03c3_v equals the restriction of the original arrived subgraph to B(v,2t).\n  (iii) The entire state on B(v,t) at the moment v arrives (including fixed outputs and any mutable state) is identical under \u03c3 and \u03c3_v.\n- Why useful here: It confines all pre-v influences to a finite ball, enabling local case analyses and localized reductions (e.g., round-elimination inside B(v,2t)) without assumptions like quiescence.\n- Proof sketch (checkable). Swap adjacent independent arrivals (distance > 2t) using Lemma 7. Each swap preserves states in B(v,t) at the time v arrives because neither swapped step can influence B(v,t) in t rounds. Iterating, push every pre-v arrival outside B(v,2t) past v. The arrived subgraph outside B(v,2t) is absent before v in \u03c3_v, establishing (i)\u2013(ii). Preservation of states in B(v,t) at v\u2019s arrival is maintained by each swap, giving (iii).\n\n2) Quiescent domain-of-dependence inside a phase (tightening Lemma 8\u2019s core invariant)\n- Lemma 10 (Phase-locality under quiescence). Consider a (W,t)-quiescent Online-LOCAL(t) algorithm A. Fix a proper coloring \u03c6 of G^{K} with K = 2t+2W+1, and simulate phase i as in Lemma 8: all vertices v with \u03c6(v)=i arrive simultaneously, and we run t LOCAL rounds over the induced subgraph of colors \u2264 i. For each such v, let R_v = B(v,W+t).\n  Claim: During phase i, the state evolution on R_v depends only on (a) the initial states on R_v \u222a \u2202R_v at the start of the phase (i.e., after phase i\u22121), and (b) the algorithm A, and it is identical to executing v\u2019s t-window in isolation with those boundary states. In particular, the combined effect of the phase equals the composition (in any order) of the individual arrival-windows of vertices of color i.\n- Why useful here: This is the precise \u201cactive-region independence\u201d that makes Lemma 8\u2019s batching sound; it also clarifies why the +1 in K is necessary.\n- Proof (detailed induction). Because dist(R_v,R_w) \u2265 2 for distinct same-color v,w when K = 2t+2W+1, there is no edge between different active regions. Quiescence implies nodes outside R := \u22c3_{\u03c6(v)=i} R_v do not change state during the t rounds of the phase, and under standard LOCAL timing (send from current state; receive; update) such nodes cannot forward any newly received messages in later rounds\u2014outgoing messages depend only on their unchanged state at the start of each round. Hence, any path starting in R_v and reaching a node in R_w would have to traverse at least one node outside R that cannot propagate new information; therefore, no causal influence can cross from one active region to another within the t rounds. Induction on the round counter r=1,\u2026,t shows that the transcript inside each R_v is identical to that of running v\u2019s window alone with the same boundary states (states on \u2202R_v are frozen during the phase). Therefore, the phase equals the composition of independent arrival windows of its color-class.\n\n3) Localized round-elimination for Online-LOCAL(t) on trees (lower-bound track)\nWe formalize the key step needed to show that log n-hard LCLs (e.g., sinkless orientation) cannot have deterministic constant-t Online-LOCAL algorithms on bounded-degree trees. This, combined with the tree LCL classification, would imply the desired O(log* n) LOCAL upper bound for the class \u201cOnline-LOCAL(t)=O(1) on trees\u201d.\n\n- Setup and notation. Work on a \u0394-regular infinite tree T_\u0394 (or large finite high-girth trees) with an ID-graph H as in Definition 2.16 (girth \u2265 \u03b3 log_\u0394 n; color-classes Hi with each independent set < n/\u0394). Consider deterministic Online-LOCAL(t) A that solves sinkless orientation (or its node-form edge-grabbing) for all arrival orders. Use Lemma 9 to localize to a finite ball and the ID-graph framework to avoid reliance on global unique IDs.\n\n- Lemma LB.1 (Online node\u2192edge reduction within a fixed ball). Suppose A solves node-form edge-grabbing in Online-LOCAL(t) on \u0394-regular trees for all arrival orders. Fix an edge e = uv and normalize so that before the decisive steps at u and v, all prior arrivals lie in B(e,2t) (by Lemma 9). There exists a deterministic edge-centered Online-LOCAL(t\u22121/2) rule A\u2032 on B(e,2t) that orients e based solely on the local neighborhood B(e,2t) and consistent arrival orders inside that ball. Formally: define A\u2032 so that e is oriented from u\u2192v if and only if there exists a pre-v normalized arrival order inside B(u,t) consistent with the current arrived subgraph in B(e,2t) leading A at u to grab e; similarly for v\u2192u. These definitions are non-conflicting and well-defined.\n  Why useful: This is the Online analogue of the one-half round-elimination step (node-to-edge), localized within a bounded-radius ball. It sets up the iterative descent to 0-round.\n  Proof idea (verifiable conditions). The only obstruction would be \u201cdouble grab\u201d: both u and v have consistent local histories leading to grabbing e. But then we can glue the two histories into a single normalized local execution inside B(e,2t), and extend to a global arrival sequence (complete T_\u0394 outside the ball; push all outside arrivals after the decision via Lemma 9) that makes A grab e from both ends\u2014contradiction with correctness. The gluing is feasible because arrivals are confined to B(e,2t), each endpoint\u2019s t-window depends only on B(endpoint,t), and the union remains within B(e,2t); overlapping influences are identical by determinism, and no information from outside the ball is needed (by Lemma 9). The reduction is edge-centered and costs one half-step of dependence radius.\n\n- Lemma LB.2 (Iterated localized elimination to 0 rounds). Starting from a node-centered Online-LOCAL(t) solution for sinkless orientation on \u0394-regular trees, iterate LB.1 and its symmetric edge\u2192node reduction (the standard pair in round elimination) within B(\u00b7,2t). After 2t iterations, obtain a 0-round edge-centered rule A^{(0)} on B(e,2t) deciding the orientation of e as a function only of the local ID labels on B(e,2t).\n  Why useful: A^{(0)} induces a 0-round global labeling depending only on the ID-graph labels, contradicting the ID-graph property (Definition 2.16) exactly as in the classical proof for LOCAL. Hence, no deterministic constant-t Online-LOCAL algorithm solves sinkless orientation on trees.\n  Proof idea (structure mirrors classical). The normalized-balls argument (Lemma 9) ensures that at each step, all needed information is inside a constant-radius ball; determinism plus the non-conflict property from LB.1 and its converse allow well-defined round-elimination steps. The finite number (2t) of steps yields a 0-round prescription; the ID-graph contradiction follows because such a prescription would color H with \u0394 colors avoiding monochromatic edges within Hi, impossible by the independence bound in Definition 2.16.\n\n- Corollary LB (Non-existence of constant-t online for log n-hard LCLs). Sinkless orientation has no deterministic Online-LOCAL(t)=O(1) algorithm on bounded-degree trees. By Theorem 2.33 (classification on trees), any LCL with O(1) online complexity cannot be in the log n-hard class; thus it lies in the O(1)/\u0398(log* n) class. Therefore, any LCL solvable in O(1) deterministic Online-LOCAL(t) on bounded-degree trees admits an O(log* n) deterministic LOCAL algorithm (existentially).\n\nWhy these are progress\n- Lemma 9 and Lemma 10 make the previously informal core invariants fully explicit and reusable: (i) state confinement to B(v,2t) for unrestricted online, and (ii) phase-wise active-region independence under quiescence.\n- Lemmas LB.1\u2013LB.2 provide the localized round-elimination scheme needed for the lower-bound path. The statements are precise and reduce the remaining work to filling in the standard gluing construction and the symmetric edge\u2192node half-step, both classical in flavor but with the normalized-ball twist (Lemma 9).\n\nExamples and sanity checks\n- Minimal K for quiescent batching: Two same-color centers at distance 2t+1 have disjoint active regions B(\u00b7,t) but these can be adjacent by one edge. In round 1, a message can cross that edge, coupling the evolutions. Hence K = 2t is insufficient; K = 2t+1 ensures \u22652-hop separation.\n- Typical quiescent online rules: Greedy MIS and maximal matching with W=1, t=1 modify only B(v,1) at each arrival; they are (W,t)-quiescent. Lemma 8 yields O(log* n) LOCAL as already recorded.\n\nObstacles and open items\n- For LB.1, the \u201cgluing\u201d step must be spelled out so that any two locally consistent normalized histories can be realized inside B(e,2t) without conflict. This uses determinism and the 2t horizon; we need to check corner cases where the two histories interact through nodes at distance exactly t from both u and v. The conflict-freedom argument via contradiction is standard but must be carefully written.\n- The symmetric edge\u2192node reduction (half-step) must be stated and proved in the online setting, paralleling LB.1. This is straightforward but needs a clean write-up.\n- State-elimination (constructive simulation) on trees without quiescence remains open. The lower-bound program bypasses constructive simulation but proves the target speedup existentially by excluding the log n-hard class.\n\nEdits and additions suggested for output.md\n- Add Lemma 9 (Strong witness-localization at v) with full proof. It is model-agnostic and will be useful for both the lower-bound program and any future interface-invariance attempts.\n- In Lemma 8\u2019s proof, we already included the K = 2t+1 (or 2t+2W+1) separation and the standard LOCAL round semantics. We recommend explicitly stating the two facts used in Lemma 10 (active-region independence and non-forwarding by quiescent outside nodes) as a short standalone claim, to make the dependency clear.\n- Create a new subsection \u201cOnline round-elimination on trees\u201d with precise statements of Lemmas LB.1 and LB.2 (as above) and a roadmap to the ID-graph contradiction. This does not change any prior result but clarifies the pathway to the main theorem under unrestricted Online-LOCAL(t).\n\nNext steps (auditable)\n1) Write the full proof of Lemma 9 and add it to output.md. (Most of the argument is already implicit in Corollary 7.1; formalize items (ii)\u2013(iii) carefully.)\n2) Insert Lemma 10\u2019s phrasing (active-region domain-of-dependence) as a paragraph in Lemma 8\u2019s proof, with a short inductive argument per round.\n3) Formalize LB.1 (node\u2192edge) and the symmetric edge\u2192node step for Online-LOCAL(t) on \u0394-regular trees with ID-graph H. Carefully define \u201clocally consistent normalized arrivals\u201d inside B(e,2t) and the gluing argument.\n4) Complete LB.2 to 0 rounds and the ID-graph contradiction, giving the lower bound for sinkless orientation. State the existential corollary for the main task (O(log* n) LOCAL for any LCL with O(1) Online-LOCAL(t) on trees).\n5) Optionally, continue exploring the constructive path: try to establish interface invariance on paths for t=1 under extra constraints (bounded-state or ID-obliviousness), or produce a counterexample LCL under unrestricted online showing that quiescence is not w.l.o.g.\n\nGaps or errors spotted in output.md\n- None critical. The separation radii for quiescent batching (K = 2t+1 and 2t+2W+1) are correctly recorded with an explanatory remark. Lemma 5\u2019s K = max(2W, R+W) is appropriate for sequential rules (no extra +1 needed). The commutativity lemma includes the clarifying remark about deterministic step-index updates. We suggest adding the standalone formalization of Lemma 9 and the localized round-elimination lemmas LB.1\u2013LB.2 as described above."}, {"prover_id": "02", "progress_md": "Status and alignment with task\n- The curated output.md now contains: (i) the output-only bridges (W=0 and W>0), (ii) the read/write simulation with the corrected K = max(2W, R+W), (iii) a 2t-commutativity lemma that localizes influence to B(\u00b7,2t), and (iv) a new quiescent bridge (Lemma 8) with the corrected separation K = 2t+1 (or 2t+2W+1) and a proof that respects standard LOCAL round timing. These cover an O(log* n) simulation for output-only and for (W,t)-quiescent Online-LOCAL(t).\n- The remaining open gap is the unrestricted deterministic Online-LOCAL(t) on trees, where idle state accumulation across many arrivals can foil color-phased batching.\n\nGaps or clarifications in output.md (minor and easy to address)\n- Corollary B vs Lemma 8 radii: Corollary B uses K = 2t+2W (no +1), which is correct because it simulates a derived sequential (R,W)-rule via Lemma 5, not batched online windows. Lemma 8 requires +1 since it parallelizes online t-windows per color and must forbid a single edge between active regions. Consider adding a one-sentence remark after Corollary B explaining why there is no +1 there but there is in Lemma 8.\n- Hypotheses of Lemma 8: It may help to restate explicitly that the standard LOCAL round timing is assumed (send based on current state, receive, then update), and that nodes outside the active region do not change their state; hence they cannot forward newly received information in later rounds. This explains the domain-of-dependence argument used in the proof.\n\nNew incremental, testable steps towards closing the unrestricted case on trees\nA) Localized round-elimination for Online-LOCAL(t) on trees (lower-bound route)\n- Goal: Show that sinkless orientation does not admit deterministic Online-LOCAL(t) with constant t on bounded-degree trees. Then, by the tree-LCL classification (Theorem 2.33), any LCL solvable in constant Online-LOCAL(t) lies in the O(1)/\u0398(log* n) class, implying the required O(log* n) deterministic LOCAL upper bound.\n- Tool already in output.md: Lemma 7 and Cor. 7.1 localize pre-decision influence to B(e,2t). We leverage this to run a localized node\u2194edge round-elimination inside a fixed ball.\n- Lemma LB.1 (Node\u2192edge localization). On a \u0394-regular tree with an ID-graph H as in Def. 2.16, assume A is a deterministic Online-LOCAL(t) algorithm that solves node-centered edge grabbing for all arrival orders. Fix an edge e = uv and normalize the prefix by Cor. 7.1 so that only B(e,2t) arrives before deciding e. Then there is an edge-centered (t\u22121/2)-local reduction that determines the orientation of e by exhaustively considering all normalized local arrival orders within B(e,2t) consistent with the fixed ID labels on the ball. Why sound: any two \u201clocal witnesses\u201d that would force opposite decisions for e can be extended to global inputs and arrival orders (by pushing all other arrivals past e using Cor. 7.1), contradicting correctness of A.\n- Lemma LB.2 (Iterated elimination). Iterating LB.1 and its converse edge\u2192node step 2t times yields a 0-round edge-centered algorithm tied to an ID-graph labeling, contradicting the ID-graph property (Def. 2.16) as in the classical proof. Hence no deterministic constant-t Online-LOCAL algorithm can solve sinkless orientation on trees.\n- Why checkable: Both lemmas operate entirely inside B(e,2t), a finite object for fixed \u0394,t. The \u201cglueability\u201d claim (extending consistent local arrival orders to a global order) is justified by Cor. 7.1 and the tree structure (no cycles) and can be written as a standalone lemma (Normalization-and-extension lemma) for verification.\n\nB) Strengthening the quiescent bridge (positive route)\n- Interface-of-boundary states lemma. In Lemma 8\u2019s proof, one may formalize the dependency as: for v in phase i, the transcript in R_v depends only on the boundary states on \u2202R_v at the start of the phase. Because boundary nodes do not change state during the phase and dist(R_v,R_w) \u2265 2 for v\u2260w of the same color, transcripts in distinct active regions are independent and coincide with any sequential permutation. This lemma can be added as a short formal claim nested in Lemma 8.\n- Special case W=0 on trees: give a tiny sanity example (path, t=1) showing necessity of K=2t+1 by constructing two same-color centers at distance 2t+1=3; an edge between the two radius-1 regions permits one-round coupling if K=2t.\n\nC) Path, t=1 interface program (state-elimination-by-quiescence attempt)\n- Definitions: For a path and t=1, let K(v) be the restriction of already fixed outputs to B(v,2) just before v arrives, after normalizing arrivals via Cor. 7.1. For each neighbor u of v, define \u03a3(u\u2192v;K) as the set of outgoing 1-round messages u can send to v over all normalized arrival orders within B(v,2) consistent with K.\n- Target (context-invariance on paths): Prove that \u03a3(u\u2192v;K) depends only on K (not on deeper mutable histories). If true, choose a canonical selector g(K) \u2208 \u03a3(u\u2192v;K) and define a quiescent online rule A\u2032 whose neighbor interfaces are g. This would yield a quiescent Online-LOCAL(1) algorithm equivalent on paths, extendable to trees by branch decomposition, and to general t by replacing radii 1,2 with t,2t.\n- Why auditable: All normalized histories live in the finite ball B(v,2); we can try to either prove invariance or build an explicit LCL counterexample where \u03a3 differs while K is fixed.\n\nSanity checks, tiny examples\n- Necessity of +1 in Lemma 8: On a path, t=1, pick two centers at distance 3. Their B(\u00b7,1) balls are disjoint but adjacent; if nodes outside active balls may not change state but still send messages based on (fixed) state, a single cross-edge allows a one-round signal between regions, so K=2t would be unsafe. K=2t+1 forbids such an edge.\n- Consistency of radii across the pipeline: Output-only W-write bridge first derives a sequential rule with R=2t+W, then simulates it with K=max(2W,R+W)=2t+2W (no +1). The +1 appears only in Lemma 8, which batches online windows per color.\n\nWhy this is progress\n- We provide concrete, local lemmas (LB.1\u2013LB.2) that, once formalized, would rule out constant-t Online-LOCAL for the log n-hard class (sinkless orientation), thereby establishing the desired O(log* n) LOCAL upper bound for any LCL solvable in constant Online-LOCAL(t) on bounded-degree trees.\n- We sharpen the quiescent bridge with a boundary-state lemma and sanity examples, reinforcing its correctness and clarifying the role of K.\n- We outline an auditable path/t=1 program to try to compile arbitrary Online-LOCAL into a quiescent one via local interface canonicalization; this has clear success/failure outcomes confined to constant-radius balls.\n\nNext steps (actionable)\n1) Write formal proofs of LB.1 and LB.2 in output.md, including the normalization-and-extension lemma (any local arrival order inside B(e,2t) extends to some global order without altering states inside B(e,t) up to e\u2019s decision time).\n2) Augment Lemma 8 with a brief \u201cboundary-state sufficiency\u201d sub-lemma and add a short remark after Corollary B about why the +1 is unnecessary there but needed in Lemma 8.\n3) Start the path, t=1 interface analysis: (i) define \u03a3(u\u2192v;K) precisely, (ii) attempt a proof of context-invariance, or (iii) construct a minimal LCL counterexample on a path if invariance fails. Document either outcome.\n4) Double-check all radius constants with toy graphs to prevent off-by-one mistakes (in particular, re-verify K=2t+2W+1 for (W,t)-quiescent and K=max(2W, R+W) for sequential (R,W)-simulation).\n"}]

Current notes.md:
Context and goal
We study the relationship between online-style constant-locality algorithms for LCLs on bounded-degree, unoriented trees and deterministic LOCAL-time upper bounds. Two notions of “online local” are relevant:
- Sequential local/greedy model (order-robust r-local): when processing a vertex v, the decision at v depends only on the r-hop neighborhood B(v,r) of the underlying graph and on already fixed outputs within B(v,r); the algorithm must succeed for every vertex order. No global mutable state or long-range message accumulation between steps.
- Online-LOCAL(t) (Akbari–Eslami–Lievonen–Melnyk–Särkijärvi–Suomela, ICALP’23): vertices arrive one by one; upon each arrival, the algorithm has t synchronous LOCAL rounds on the subgraph induced by arrived vertices; outputs are irrevocable. Over many arrivals, an unbounded number of communication rounds can occur, enabling long-range state accumulation.

Safe, proven variant (archived below in output.md)
- Theorem (Sequential-local to LOCAL): If an LCL Π on bounded-degree graphs has a deterministic order-robust r-local sequential algorithm (decisions at v depend only on B(v,r) and outputs of earlier vertices in B(v,r), and the rule writes only the output at v), then Π has a deterministic LOCAL algorithm running in O(r log* n + Δ^{O(r)}) rounds. On bounded-degree trees with constant r, this is O(log* n). Proof: compute a proper coloring of G^r in O(r log* n) rounds with Δ^{O(r)} colors; process color classes in order, letting each v gather outputs from B(v,r) restricted to earlier colors and apply the sequential rule. Because nodes of the same color are at distance > r, their decisions do not depend on each other.

Gap for the full Online-LOCAL(t) model
- A direct phase simulation that uses a distance-(2t) coloring and t rounds per color does not generally reproduce the state a node v would see upon arrival in an actual online execution. In a true online run, before v arrives, there may have been Θ(n) earlier arrivals, yielding Θ(n)·t global rounds; information can propagate arbitrarily far and may alter the states within B(v,t). The phase simulation grants only O(1)·t total rounds before v’s phase, so the local states can differ. Hence, without additional constraints, we cannot claim that the phase simulation faithfully reproduces the online run or even yields correctness solely from A’s correctness.

Ways forward for Online-LOCAL(t)
- Add a locality-of-dependence assumption: the t-round transcript that determines v’s output depends only on the arrived subgraph inside distance ≤ t from v and on the outputs of those nodes, not on mutable states imported from farther away. Under this, distance-(2t) coloring plus phase simulation is valid and yields O(log* n).
- Alternatively, seek a structural scheduling/padding argument ensuring that for LCLs on bounded-degree trees, the state within B(v,t) before v’s arrival is independent of far-away arrivals. This is nontrivial; try first on paths/trees with t=1 to see whether accumulation can matter for any LCL.
- Or try to separate the models: construct an LCL that is solvable in constant t in Online-LOCAL but provably not simulable by the above constant-phase compression; if such an LCL exists, the general reduction fails, and the sequential-local variant becomes the correct target.

Remarks
- No global edge orientation is needed anywhere in the reduction we proved; IDs suffice for coloring.
- The archived proof applies to all bounded-degree graphs; we stated trees to match the project focus.
Refinements on bridging Online-LOCAL(t) to sequential local rules
- Definitions (recap and refinement):
  • Online-LOCAL(t): vertices arrive one by one; upon each arrival we have t synchronous LOCAL rounds on the subgraph induced by arrived vertices; outputs are irrevocably set at arrival; in the general model, nodes may maintain unbounded mutable state across arrival windows.
  • Output-only Online-LOCAL(t): the only persistent state at nodes is the immutable output label after it is set; between windows there is no other state; in any t-round window, messages sent by a node are functions only of the underlying graph and the currently known outputs within its distance-t neighborhood (no dependence on farther outputs or on pre-window mutable state).
  • t-local-dependence at v: when v arrives, its output depends only on the arrived subgraph restricted to B(v,t) and outputs of the arrived nodes within B(v,t).

- Correct radius accounting:
  • At v’s arrival with window length t, nodes within B(v,t) can influence v. A node u ∈ B(v,t) may compute its messages based on outputs within B(u,t), which is contained in B(v,2t). Thus, in the output-only model, v’s output depends only on the graph structure and outputs within B(v,2t). Consequently, the correct bridge is to a sequential rule of radius 2t (not t). If we assume t-local-dependence at v, the bridge tightens to radius t.

- Minimal counter-scenario (why naive phase-compression fails for the unrestricted online model):
  Consider a path with t=1. In a genuine online run, before a vertex v arrives, Θ(n) earlier arrivals can propagate state one hop per window across the path; by the time v arrives, its neighbors may carry information injected far away. A color-phased simulation that offers only O(1) windows before v’s phase cannot reproduce these accumulated states. This shows that without output-only or t-local-dependence, we cannot black-box simulate arbitrary Online-LOCAL(t) runs by a constant number of phases.

- Practical takeaway for reductions:
  • If your online algorithm is output-only, design the sequential rule to read B(v,2t) and write only at v; then apply the G^{2t} coloring pipeline to get O(log* n) on bounded-degree trees.
  • If your online algorithm satisfies t-local-dependence at v, the sequential rule needs only B(v,t).

- Next-step plan (state elimination on trees):
  • Start on paths with t=1. Define the interface ∂B(v,2) and annulus R=B(v,2)\B(v,1). Attempt to prove: if two online executions agree on outputs over B(v,2), then they allow exactly the same outputs at v. If proven, extend to trees and t by replacing 2 with 2t. If refuted, crystallize a separation example.
  • Track read/write radii for any sequential rules that go beyond “write only at v”; use distance-(R+W) colorings for phase independence.
Additions and corrections

1) Correct simulation radius for bounded writes.
- When simulating an order-robust sequential rule that reads within B(v,R) and may write within B(v,W), independence within a color class requires both:
  • Write–write disjointness: B(u,W) ∩ B(v,W) = ∅.
  • Read–write disjointness: B(u,R) ∩ B(v,W) = ∅ and B(v,R) ∩ B(u,W) = ∅.
- These are guaranteed if dist(u,v) > max(2W, R+W). Therefore, the correct coloring is a proper coloring of G^K with K = max(2W, R+W). Using G^{R+W} alone is insufficient in general.
- Minimal counterexample to G^{R+W}: Take R=0, W=1 on the path u–x–v. Here dist(u,v)=2>R+W, but B(u,1)∩B(v,1)={x} so simultaneous writes conflict.

2) Output-only, W-write Online-LOCAL(t) ⇒ sequential (R,W) with R=2t+W.
- Model: When v arrives, A runs t rounds and may irrevocably write outputs on B(v,W); messages during this window depend only on the graph and the currently known outputs within distance ≤ t of the sender; no other mutable state persists.
- Radius accounting: To decide outputs on the patch B(v,W) within t rounds, only nodes in B(B(v,W), t) = B(v, W + t) can send messages that reach the patch. Under output-only, each such sender’s messages are functions of outputs in its own t-ball. Hence the decisions on the patch depend only on outputs within B(v, W + 2t) = B(v, 2t + W).
- Sequential rule S: For a given order σ, when processing v, S reads already-fixed outputs in B(v, 2t+W) and deterministically reproduces A’s t-window on the patch, writing only to currently-unset outputs in B(v,W). Because A is deterministic and correct for all orders, S reproduces A’s result for order σ.

3) Commutativity of independent arrivals (unrestricted Online-LOCAL(t)).
- If two consecutive arrivals u and w satisfy dist(u,w) > 2t, swapping their order leaves the t-round transcripts and resulting states identical everywhere. In particular, by repeatedly swapping, one can assume that, when analyzing v, only arrivals within B(v,2t) occur before v. This normalizes the analysis horizon for any state-elimination attempt.

4) State-elimination program on paths (t=1) — concrete targets.
- Define the interface K(v) as the already-fixed outputs on B(v,2) just before v arrives (after normalizing the order so only B(v,2) arrives first). Target claim (context-invariance): The set of feasible outputs/messages at v depends only on K(v). If true, derive a canonical sequential rule of read radius R=2 and (potential) write radius W by reproducing the canonical choice. If false, document a counterexample LCL on paths.

5) Accounting for LOCAL complexity when W>0.
- With (R,W)-local sequential rules, compute a proper coloring of G^{K} with K = max(2W, R+W) in O(K log* n) rounds (Lemma 1 simulated on G), then process colors in O(R) rounds per color. On bounded-degree trees with constant R,W, this gives O(log* n) overall.
Disproof of “faithful color-by-color simulation” for unrestricted Online-LOCAL(t)
The tempting idea to fix a proper coloring φ of G^{2t}, choose the arrival order σ_φ that processes color classes 1,2,…,C, and then simulate each color class in O(t) rounds by running all arrivals of that color concurrently, is not valid in the unrestricted Online-LOCAL(t) model.

Key obstruction: In the Online-LOCAL(t) semantics, each arrival triggers t synchronous rounds across the entire arrived subgraph. Nodes outside B(v,t) of the newly arrived vertex v may still update their local state in that step (e.g., increment a local counter) even though they receive no messages. Over k arrivals in a color class, every previously arrived node performs k such "idle" updates. Compressing k steps to 1 per color fails to reproduce the global state unless one can apply k-fold local updates everywhere, which is not locally computable in O(1) rounds.

Minimal counterexample (paths, t=1). Consider the trivial LCL Π that accepts any labeling. Define a deterministic Online-LOCAL(1) algorithm A as follows:
- Every arrived node maintains a parity bit p, initially 0, and toggles p at every arrival step (independently of messages).
- When a new vertex v arrives, in the 1-round window v queries any neighbor u (if one exists) for p and outputs that bit. (If v has no arrived neighbor, it outputs 0.)
This A is correct for Π for every arrival order (Π accepts any labeling). Fix any proper 3-coloring φ of the path’s G^2. In the sequential σ_φ-run that processes all color-1 vertices one by one, p toggles at every arrival, so the outputs of color-1 vertices alternate with their internal order. A batched O(1)-round simulation that processes all color-1 vertices simultaneously cannot reproduce these alternating outputs: all of them see the same parity p from earlier colors and output the same bit. Hence faithful reproduction of the σ_φ-run is impossible in general.

Consequences.
- The earlier “main gap” (state accumulation across many arrivals) is real for unrestricted Online-LOCAL(t): batched simulation does not, in general, preserve the online run’s state trajectory.
- To make per-color batching sound, one needs extra structure such as quiescence: outside B(v,t), the per-step state update is the identity (or, more generally, does not depend on the number of arrivals). The output-only and t-local-dependence variants already enforce related constraints.

On Lemma 8 and local order normalization
- Our Corollary 7.1 already implies the witness localization needed for per-node analysis: by swapping distant arrivals (dist > 2t), one can assume all arrivals before v occur in B(v,2t) without changing the state in B(v,t) at v’s arrival. This is the appropriate normalization tool for any local confluence/interface analysis.

On Lemma 9 (finite enumeration claim)
- As stated (“the set of possible transcripts/messages seen by v is finite”), this is false in the standard LOCAL model due to unbounded message/state spaces and dependence on unique IDs. Finite enumeration becomes viable only if one assumes bounded message alphabets, bounded state, or ID-obliviousness; otherwise, for a fixed constant-size ball B(v,2), the algorithm can encode arbitrarily large ID-dependent information into messages/states.

Next steps for the path/t=1 interface program
- Either (i) impose output-only (or stronger quiescence/ID-obliviousness) and aim to prove the context-invariance Claim C1 under those constraints, or (ii) build a concrete counterexample to C1 in the unrestricted model by letting neighbors’ 1-round messages to v depend on the number of prior arrivals while keeping K(v) fixed. In both tracks, use Corollary 7.1 to restrict attention to B(v,2).

Complexity reminder for bounded writes
- With (R,W)-local sequential rules, independence within a color class requires K = max(2W, R+W). Computing a proper coloring of G^{K} costs O(K·log* n) rounds and per-color work is O(R). For bounded Δ, R, W, this yields O(log* n) total complexity dominated by the coloring step.
New bridge via quiescence (precise form) and radius accounting
- Definition (quiescent Online-LOCAL(t), standard LOCAL timing). In each arrival step for v, the algorithm runs t synchronous LOCAL rounds on the arrived subgraph. Messages sent in round r depend only on the node’s state at the start of round r; at the end of the round, nodes update their state based on received messages. The algorithm is quiescent if, during the t rounds triggered by v’s arrival, every node u with dist(u,v) > t does not change its state in any of these t rounds. (Under the above timing, such u cannot forward newly received information in subsequent rounds because its outgoing messages in round r depend only on its unchanged state.)
- (W,t)-quiescent: If the algorithm may irrevocably write outputs on a patch B(v,W) during v’s window, we call it (W,t)-quiescent if only nodes in B(v,W+t) may change state in that window.

- Correct separation for parallel batching: To parallelize all same-color windows for t rounds without interference, it is necessary to forbid any edge between distinct active regions. For W=0 the active region for v is B(v,t). Thus, a proper coloring of G^{2t+1} (not merely G^{2t}) guarantees that for same-color u,v, dist(u,v) ≥ 2t+2, hence dist(B(u,t), B(v,t)) ≥ 2. This eliminates one-hop coupling across region boundaries. With W>0, color G^{2t+2W+1} so that distinct active regions B(·,W+t) have mutual distance ≥ 2.

- Why quiescence removes the “idle-accumulation” pitfall: In the unrestricted model, nodes can encode the number of prior arrivals into their state and/or messages, letting each new window see different ambient information; batching then fails. Under quiescence, any vertex whose t-window has not yet been processed cannot track steps that do not involve it, so its local view (modulo the already-arrived graph and earlier colors) is invariant across the internal order within a color class. Combined with the ≥2 separation between active regions, the parallel t-round simulation per color faithfully matches any sequential permutation of that color.

- Examples that fit quiescence: Greedy MIS and greedy maximal matching on bounded-degree graphs (W=1, t=1) where only the newly active 1-neighborhood changes, and (Δ+1)-vertex-coloring rules that finalize a 1-hop patch around the arrival.

Remark on Lemma 7 (2t-commutativity)
- The lemma remains valid even if nodes outside B(u,t) ∪ B(w,t) perform deterministic updates depending only on the global step index (and not on messages). Those nodes experience the same two consecutive step indices before and after the swap; hence their pair of updates is identical.

Lower-bound program (outline) for Online-LOCAL on trees
- Target: Prove that sinkless orientation on bounded-degree trees admits no deterministic Online-LOCAL(t)=O(1) algorithm (adversarial arrival). Use Lemma 7/Cor. 7.1 to normalize prefixes so that only B(e,2t) arrives before deciding edge e. Then adapt the node↔edge round-elimination locally inside B(e,2t), iterating 2t times to obtain a 0-round contradiction with the ID-graph property. Formalizing this (LB.1–LB.2) would non-constructively imply: any LCL with constant-t Online-LOCAL on trees lies in the O(1)/Θ(log* n) class, so there exists an O(log* n) deterministic LOCAL algorithm.

Next steps
- Integrate the quiescent bridge with K=2t+1 (resp. 2t+2W+1) into output.md.
- Begin the path (t=1) state-elimination-by-quiescence attempt with a precise interface Σ(u→v) and normalized histories (via Cor. 7.1). Either prove context-invariance or extract a counterexample LCL.
- In parallel, formalize LB.1–LB.2 for sinkless orientation as described above.

Current output.md (if any):
List of proven results archived here
- Lemma 1: Power-graph coloring in O(k log* n).
- Lemma 2: Color-phased simulation for order-robust read-radius r rules that write only at the current node (W=0).
- Theorem A: Sequential-local (W=0) ⇒ LOCAL on bounded-degree graphs.
- Lemma 3: Bridge from output-only Online-LOCAL(t) (W=0) to order-robust sequential with read radius 2t.
- Lemma 4: Bridge under t-local-dependence (W=0) to read radius t.
- Corollary A: On bounded-degree trees, constant r or constant t ⇒ O(log* n) LOCAL.
- Lemma 5: Color-phased simulation for sequential rules with read radius R and write radius W via a G^{K}-coloring with K = max(2W, R+W).
- Lemma 6: Bridge from output-only, W-write Online-LOCAL(t) to an order-robust sequential rule with (R,W) = (2t+W, W).
- Corollary B: On bounded-degree trees, constant t,W in output-only W-write Online-LOCAL(t) ⇒ O(log* n) LOCAL.
- Lemma 7: 2t-commutativity of independent consecutive arrivals in Online-LOCAL(t), and a corollary pushing far-away arrivals past a fixed v.

Model and definitions
- Graphs: finite, simple, maximum degree Δ < ∞ (bounded degree). Nodes have unique IDs from a polynomial range (standard LOCAL assumptions). dist(·,·) is the hop distance; B(v,r) is the radius-r ball around v.
- LCL Π: a locally checkable labeling problem with constant checkability radius r_Π.
- Order-robust sequential rules with bounded writes: A deterministic rule S with read radius R and write radius W is a procedure that, when processing v in a vertex order σ, inspects G[B(v,R)] and the outputs already fixed in B(v,R) ∩ {earlier vertices in σ}, and may irrevocably write outputs on any currently-unset vertices in B(v,W). The final labeling must satisfy Π for every σ. (The special case W=0 writes only at v.)
- Online-LOCAL(t): vertices arrive one by one; at each step the algorithm executes t synchronous LOCAL rounds on the subgraph induced by the arrived vertices; outputs are irrevocable; nodes may maintain arbitrary local state across steps unless otherwise restricted.
- Output-only Online-LOCAL(t): the only persistent state is the immutable output label after it is set; in any t-round window, messages and local computation at a node may depend on the graph and currently known outputs within distance ≤ t from that node, but not on any other mutable state.
- t-local-dependence (at v): upon v’s arrival, its output depends only on the induced arrived subgraph and previously fixed outputs within B(v,t).
- Output-only, W-write Online-LOCAL(t): as output-only above, but when v arrives the algorithm may irrevocably fix outputs on any vertices in B(v,W).

Lemma 1 (Power-graph coloring in O(k log* n))
Statement. Let G be a bounded-degree graph and k ≥ 1 a constant. There is a deterministic LOCAL algorithm that computes a proper vertex coloring of the power graph G^k with at most C = Δ^{O(k)} colors in O(k log* n) rounds on G.
Proof. Standard: simulate an O(log* n)-round O(Δ(G^k)^2)-coloring on G^k by k rounds per step on G; Δ(G^k) ≤ Δ^k, hence C = Δ^{O(k)}. □

Lemma 2 (Color-phased simulation for W=0)
Statement. Let S be an order-robust sequential rule with read radius r that writes only at the current node (W=0). Given a proper coloring of G^r, processing colors 1,…,C in order reproduces S for any order respecting the color layering, using O(r) rounds per color.
Proof. If φ(u)=φ(v) then dist(u,v)>r, hence the decisions in phase i depend only on outputs from earlier colors and do not interfere. Each node gathers outputs in B(·,r) from earlier colors in O(r) rounds and applies S. □

Theorem A (Sequential-local (W=0) ⇒ LOCAL)
Statement. If Π admits an order-robust r-local sequential algorithm (W=0), then Π has a deterministic LOCAL algorithm running in O(r log* n + Δ^{O(r)}·r) rounds. For constant Δ,r: O(log* n).
Proof. Compute a G^r-coloring in O(r log* n) rounds (Lemma 1), then simulate by Lemma 2. □

Lemma 3 (Output-only Online-LOCAL(t), W=0 ⇒ sequential with read radius 2t)
Statement. If Π has a deterministic output-only Online-LOCAL(t) algorithm correct for every arrival order, then Π admits an order-robust sequential algorithm with read radius 2t (W=0) that reproduces the online outputs for any order.
Proof. Fix order σ. When v_i arrives online under σ, only nodes in B(v_i,t) can send messages that reach v_i within t rounds. Under output-only, any such message depends only on outputs within the sender’s B(·,t), all contained in B(v_i,2t). Hence v_i’s t-window transcript and output are functions of the restriction to B(v_i,2t) of the arrived subgraph and outputs. Define the sequential rule to read those and return the same output as the online algorithm would under σ. Correctness and order-robustness follow. □

Lemma 4 (Bridge under t-local-dependence, W=0)
Statement. If Π has a deterministic Online-LOCAL(t) algorithm with t-local-dependence (at every v) that is correct for every arrival order, then Π admits an order-robust sequential algorithm with read radius t (W=0).
Proof. As in Lemma 3, but with t in place of 2t by hypothesis. □

Corollary A (Bounded-degree trees, constant r or t)
Statement. On bounded-degree trees, if Π has either (i) an order-robust r-local sequential algorithm (W=0) with constant r, or (ii) an output-only Online-LOCAL(t) algorithm (W=0) with constant t, or (iii) an Online-LOCAL(t) algorithm with t-local-dependence and constant t, then Π has a deterministic LOCAL algorithm with round complexity O(log* n).
Proof. Combine Theorem A with Lemma 3 or Lemma 4 as applicable; Δ and radii are constants. □

Lemma 5 (Color-phased simulation with bounded writes)
Statement. Let S be an order-robust sequential rule with read radius R and write radius W ≥ 0 (S may write outputs on currently-unset vertices in B(v,W)). Let φ be a proper coloring of G^{K} with K = max(2W, R+W). Then processing colors 1,…,C in order reproduces S for any order that respects the color layering. The per-color communication cost is O(R) rounds after φ is known.
Proof. If φ(u)=φ(v) then dist(u,v) > K ≥ 2W and > R+W. Thus (i) B(u,W) ∩ B(v,W) = ∅ (no write–write conflicts) and (ii) B(u,R) ∩ B(v,W) = ∅ and B(v,R) ∩ B(u,W) = ∅ (no read–write interference). In phase i, each vertex v with φ(v)=i gathers outputs written by earlier colors within B(v,R) and computes its writes; because of (i)–(ii), these writes are independent across same-color vertices and depend only on earlier colors, so the result matches S for any order that lists all lower colors first and then the current color in any internal order. O(R) rounds suffice to gather B(v,R) information. Computing φ takes O(K log* n) rounds by Lemma 1 with k=K. □

Lemma 6 (Output-only, W-write Online-LOCAL(t) ⇒ sequential with (R,W)=(2t+W,W))
Statement. If Π has a deterministic output-only, W-write Online-LOCAL(t) algorithm A correct for every arrival order, then Π admits a deterministic order-robust sequential rule S that, when processing v, reads only B(v, 2t+W), may write on currently-unset vertices in B(v,W), and reproduces A’s outputs for any order.
Proof. Fix order σ = (v_1,…,v_n). Consider A under arrival order σ. When v_i arrives, during its t-round window only nodes within distance ≤ t of the patch B(v_i,W) can send messages that reach the patch; hence all influencing senders lie in N := B(B(v_i,W), t) = B(v_i, W+t). Under output-only, messages sent by any u ∈ N depend only on outputs within B(u,t). Therefore the union of outputs that can affect the patch’s decisions lies in M := ⋃_{u∈N} B(u,t) = B(v_i, W+2t). Consequently, the t-round transcript determining the patch outputs in the σ-run is a function of the restriction of the arrived subgraph and already-fixed outputs to B(v_i, 2t+W). Define S as follows: when processing v_i under σ, S collects the already-fixed outputs within B(v_i, 2t+W) ∩ {v_1,…,v_{i-1}} and deterministically reproduces A’s t-window decisions on the patch given that local view, writing only to vertices in B(v_i,W) whose outputs are not yet fixed. Because A is deterministic and respects irrevocability, this reproduces exactly the same patch outputs as A under σ and never overwrites. As A is correct for every order, S is an order-robust (R,W)-local rule with R=2t+W. □

Corollary B (Bounded-degree trees, output-only W-write ⇒ O(log* n) LOCAL)
Statement. On bounded-degree trees, if Π has a deterministic output-only, W-write Online-LOCAL(t) algorithm with constants t,W, then Π has a deterministic LOCAL algorithm with round complexity O(log* n).
Proof. Apply Lemma 6 to obtain a sequential (R,W)-rule with R=2t+W. Then use Lemma 5 with K = max(2W, R+W) = max(2W, 2t+2W) = 2t+2W to simulate S in the LOCAL model: compute a proper coloring of G^{2t+2W} in O((2t+2W) log* n) rounds, then spend O(R)=O(2t+W) rounds per color. For constant Δ,t,W the total is O(log* n). □

Lemma 7 (2t-commutativity of independent consecutive arrivals)
Statement. Let A be any deterministic Online-LOCAL(t) algorithm (unrestricted mutable state). Consider an arrival sequence σ and two consecutive arrival steps at vertices u and w such that dist(u,w) > 2t. Let σ′ be obtained by swapping these two steps. Then, after these two steps, the states and fixed outputs at all vertices are identical under σ and under σ′.
Proof. Let G_i be the arrived subgraph just before these two steps. In the step when u arrives under σ, A executes t synchronous rounds on G_i ∪ {u}. Messages can traverse at most t hops per window, so only nodes in B(u,t) can be influenced (either by receiving messages or by depending on received messages); nodes outside B(u,t) undergo the same deterministic state updates as they would in any window where they receive the same (empty) messages. Likewise, w’s step affects only B(w,t). Because dist(u,w) > 2t, the balls B(u,t) and B(w,t) are disjoint, and w is absent during u’s step and u is absent during w’s step in both σ and σ′. Therefore the t-round transcripts and resulting updates within B(u,t) (resp. B(w,t)) are identical in σ and σ′, and all other vertices experience no message-dependent changes in either order. Thus the combined effect of the two steps commutes. □

Corollary 7.1 (Pushing far-away arrivals past v)
Statement. Fix v and any arrival sequence. By repeatedly swapping consecutive independent steps via Lemma 7, one can transform the sequence into another in which all vertices at distance > 2t from v arrive after v, without changing any states or outputs within B(v,t) at the time v arrives (or thereafter).
Proof. Iteratively swap any arrival at distance > 2t from v forward past earlier arrivals until it occurs after v; Lemma 7 ensures the swaps preserve the relevant states/outputs. □

Remark. Lemma 5 supersedes the earlier, flawed variant that required only a G^{R+W}-coloring; the counterexample R=0, W=1 on a 3-path shows that G^{R+W} is insufficient because write–write conflicts may occur.
Remark (No faithful t-per-color batching for unrestricted Online-LOCAL(t)). There exists a deterministic Online-LOCAL(1) algorithm A and a valid color-by-color arrival order σ_φ (induced by a proper coloring φ of G^2 on a path) such that any LOCAL simulation that processes all vertices of the same color class simultaneously in O(1) rounds cannot reproduce the exact outputs produced by A under the sequential σ_φ-run.
Proof. Consider the trivial LCL Π that accepts any labeling. Algorithm A maintains at each arrived node a parity bit p (initially 0) that toggles at every arrival step (regardless of messages). When a new vertex v arrives, in its 1-round window it reads p from an already-arrived neighbor if one exists and outputs that bit (if v has no arrived neighbor, it outputs 0). Fix any proper 3-coloring φ of the path’s G^2 and let σ_φ process colors 1,2,3 in order, with any internal order inside a color. In the sequential σ_φ-run, the parity p toggles at every arrival, hence the outputs of the vertices of any color class alternate with the internal order. In contrast, if one processes all vertices of a color class simultaneously in a single 1-round batch (keeping not-yet-processed colors absent), all these vertices observe the same parity p from earlier colors and therefore all output the same bit. Thus the batched simulation does not reproduce A’s outputs under σ_φ. □

Remark (Complexity accounting for Lemma 5/Corollary B). On bounded-degree graphs with constants t,W, the coloring step on G^{K} (K = max(2W, R+W), with R = 2t+W in Corollary B) costs O(K·log* n) rounds and yields C = Δ^{O(K)} colors; the per-color work is O(R). Hence the total complexity is O(log* n), dominated by the coloring step.
Definition (Quiescent Online-LOCAL(t) and (W,t)-quiescent)
Consider the standard LOCAL timing in an arrival step: in each of t synchronous rounds, each arrived node first sends messages as a (deterministic) function of its current state, then receives messages from neighbors, and finally updates its state as a (deterministic) function of its current state and the received messages.
- An Online-LOCAL(t) algorithm A is quiescent if, upon the arrival of v, during the ensuing t rounds every node u with dist(u,v) > t does not change its state in any of these t rounds.
- More generally, A is (W,t)-quiescent if, upon the arrival of v, during the ensuing t rounds only nodes in the active region B(v, W+t) may change their state; nodes outside B(v,W+t) do not change state.

Lemma 8 (Quiescent Online-LOCAL(t) ⇒ O(log* n) LOCAL; bounded-writes variant)
Let Π be an LCL on bounded-degree graphs. Suppose Π has a deterministic quiescent Online-LOCAL(t) algorithm A with constant t.
(i) Then Π admits a deterministic LOCAL algorithm with round complexity O((2t+1)·log* n + t·Δ^{O(t)}) = O(log* n).
(ii) More generally, if A is (W,t)-quiescent with constants W,t, then Π admits a deterministic LOCAL algorithm with round complexity O((2t+2W+1)·log* n + t·Δ^{O(t+W)}) = O(log* n).

Proof.
Fix K := 2t+1 in case (i), and K := 2t+2W+1 in case (ii). By Lemma 1, compute a proper coloring φ of G^{K} with C = Δ^{O(K)} colors in O(K·log* n) rounds. We process the colors in increasing order i = 1,2,…,C in phases; at the start of phase i, exactly the vertices of colors < i are considered “already arrived,” and vertices of colors ≥ i are “not yet arrived.”

In phase i we simulate, in parallel, the t-round online arrival window of every vertex v with φ(v)=i, on the subgraph induced by vertices of colors ≤ i, as follows: (a) we declare all vertices of color i to “arrive” at the beginning of the phase, and (b) we perform t synchronous LOCAL rounds on that induced subgraph. During this phase, the algorithm A is executed faithfully at every vertex, except that vertices of colors > i are absent.

Let R_v denote the active region of v during this phase: R_v = B(v,t) in case (i) and R_v = B(v, W+t) in case (ii). Because φ colors G^{K} with K as above, for any two distinct same-color vertices v,w we have dist(v,w) ≥ K+1, hence dist(R_v, R_w) ≥ 2. In particular, there is no edge between R_v and R_w.

Quiescence and the LOCAL timing imply two key facts within phase i:
1) Only nodes in R := ⋃_{φ(v)=i} R_v may change state during the t rounds of phase i; all nodes outside R keep their state fixed throughout the phase. Since messages sent in a round depend only on the sender’s current state at the start of that round, such outside nodes cannot forward newly received information in subsequent rounds. Consequently, there is no causal influence along any path that leaves one R_v and re-enters another R_w within the t rounds, because such a path must traverse at least one node outside R which cannot propagate new information.
2) Since dist(R_v, R_w) ≥ 2, there is neither an edge nor a length-1 path between distinct active regions.

From 1)–2) it follows that, during phase i, the evolution of each R_v is identical to what would occur if we executed only v’s t-round window in isolation (with all other color-i vertices absent), given the same boundary states on the external neighborhood of R_v (which are precisely the states fixed by earlier colors). Formally, this can be proved by induction on the round counter r=1,…,t, using the domain-of-dependence that is confined to R_v together with outside nodes whose states remain constant.

Therefore, the combined effect of phase i equals the composition of the individual “v-arrival” windows over all vertices v with φ(v)=i, in any internal order. By induction on i, after finishing phase i the global state/output coincides with the online execution that processes first all color-1 vertices (in an arbitrary order), then all color-2 vertices, and so on. Since A is correct for every arrival order, the final labeling after phase C is legal for Π.

The complexity is O(K·log* n) to obtain φ and t rounds per color, i.e., O(t·C) additional rounds. For constant Δ, t, W, we have C = Δ^{O(K)} = O(1), so the total is O(log* n). □

Remark (on the choice of K). The choice K = 2t (resp. 2t+2W) is insufficient for the parallel phase: if dist(v,w)=2t+1 (resp. 2t+2W+1), then R_v and R_w are disjoint but may be adjacent by an edge, allowing one-round coupling between the two active regions. The value K = 2t+1 (resp. 2t+2W+1) guarantees dist(R_v, R_w) ≥ 2, which prevents such coupling and makes the above proof sound.

Remark after Lemma 7 (idle updates depending on step index). In Lemma 7, nodes outside B(u,t) ∪ B(w,t) may perform deterministic updates that depend on the global step counter but not on messages. When two consecutive arrivals at u and w with dist(u,w) > 2t are swapped, those nodes still undergo the same two consecutive step indices in the same order, so their pair of updates is unchanged. This clarifies that Lemma 7 tolerates such idle updates.
