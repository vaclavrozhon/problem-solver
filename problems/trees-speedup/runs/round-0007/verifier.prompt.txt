--- SYSTEM ---
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (summary so far)
- output.md (rigorously proven results so far)

Guidelines:
- notes.md: should be a readable running log of interesting work. Prefer appending. Replace only if old notes are clearly misleading. Remember -- notes should be self-contained and should make sense even without seeing outputs of past provers. 
- output.md:  Think twice before you add something to this file. Everything here should be rigorous, almost publication-ready. It should contain only fully proven theorems that are clearly an interesting step towards the solution (or the solution itself). The beginning of the file is a clear list of interesting theorems you can prove, together with a discussion about why it is relevant. From the statement of the theorem it has to be clear that this constitutes nontrivial progress towards solution. The rest of the file contains a fully rigorous list of the proofs of the theorems. Keep only proven theorems with clear proofs. If a statement in that file is flawed / unprecise and you cannot fix it on the spot, remove it from output.md and instead add it to notes.md with explanation.
- Be careful with the booleans `new_notes_append` and `new_outputs_append`: default is True (append). Use False only when deliberately rewriting everything.

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (≥200 words). Include concrete next-step suggestions. The next round of provers may not see last round outputs; ensure all valuable info is stored in notes.",
  "new_notes_md": "Markdown (KaTeX allowed). Usually appended to notes.",
  "new_notes_append": "True|False",
  "new_outputs_md": "Markdown (KaTeX allowed). Usually appended to output.md.",
  "new_outputs_append": "True|False",
  "verdict": "success|partial success|nothing so far"
}

**Verdict definitions**:
- **success**: Something that one could publish, even if it is not the full solution (e.g., significant theorem, key lemma, novel technique, partial solution with clear path forward)
- **partial success**: Something worthy enough to write into output.md (e.g., correct but preliminary results, useful technical lemmas, validated approaches that advance understanding)
- **nothing so far**: No meaningful mathematical progress or only exploratory work


--- USER ---
You receive multiple prover reports. Evaluate correctness, value, and pick promising directions. Update notes.md (append/replace) with useful ideas and update output.md (append/replace) ONLY with rigorously verified results.

Prover reports (JSON):
[{"prover_id": "01", "progress_md": "## Status and goals\n- Target: Prove that any LCL solvable in O(1) rounds in deterministic Online-LOCAL(t) on bounded-degree (nonoriented) trees admits an O(log* n) deterministic LOCAL algorithm.\n- Current archive (output.md): Contains the output-only/t-local-dependence bridges, bounded-writes simulation with the corrected K = max(2W, R+W), 2t-commutativity (Lemma 7), the quiescent bridge (Lemma 8) with the necessary +1 in K, strong witness-localization (Lemma 9), and Phase-locality (Claim 8.1). These cover O(log* n) for quiescent and output-only variants.\n- Open gap: the unrestricted Online-LOCAL(t) case. Lower-bound program via localized round-elimination for sinkless orientation needs two missing pieces: a precise normalization-and-extension lemma, and a non-conflict argument in the node\u2192edge step (the earlier sketch was invalid in the node-form).\n\n## New clean tools (ready to archive)\n\n### Lemma NE (Normalization-and-Extension around an edge on trees)\n- Statement. Let A be any deterministic Online-LOCAL(t) algorithm on a bounded-degree tree G, and let e = uv be an edge. Fix any finite arrival sequence prefix \u03c4 consisting of distinct vertices of B(e,2t). There exists a global arrival sequence \u03c3 on V(G) such that:\n  1) The first |\u03c4| steps of \u03c3 equal \u03c4 (same vertices in the same order), and no vertex outside B(e,2t) arrives before those |\u03c4| steps.\n  2) For every 0 \u2264 j \u2264 |\u03c4|, the state and fixed outputs on B(e,t) after j steps of \u03c3 coincide with those obtained by executing exactly the first j steps of \u03c4 (i.e., executing A on the induced subgraph of the arrived vertices inside B(e,2t), with all other vertices absent).\n  Moreover, given any global arrival sequence \u03c30, there exists \u03c31 obtained from \u03c30 by repeatedly swapping adjacent arrivals at distance > 2t such that up to and including the first arrival of the second endpoint of e, no vertex outside B(e,2t) arrives in \u03c31, and the state on B(e,t) at each step up to that time is identical under \u03c30 and \u03c31.\n- Why useful here. This formalizes the exact \u201clocal sandbox\u201d principle needed for localized round-elimination: any normalized local execution inside B(e,2t) is realized by some global schedule and unaffected by outside arrivals; conversely, any global schedule can be normalized so that only B(e,2t) arrives before e is decided without changing B(e,t).\n- Proof sketch (auditable). The second part is Lemma 7 iterated: swap any pre-decision arrival at distance > 2t past the decision time; each swap preserves states in B(e,t). For the first part, define \u03c3 by listing \u03c4 first and then any permutation of V(G)\\B(e,2t). Before the |\u03c4|-th step, no vertex outside B(e,2t) arrives; thus the online runs of A on \u03c3 and on the local \u03c4 coincide on B(e,t), since absent vertices neither send nor receive. \u25a1\n\n### Lemma (+1 minimality re-stated, with a crisp example)\n- Statement. For (W,t)-quiescent batching in Lemma 8, K = 2t+2W is insufficient in general; K = 2t+2W+1 is necessary to forbid one-round coupling across distinct active regions.\n- Proof idea. Path example, W=0, t=1: choose two same-color centers a,b at distance 3. Then B(a,1) and B(b,1) are disjoint but adjacent by a single edge. In the first round of the phase, a boundary node of B(a,1) may send a message to a boundary node of B(b,1); in the second round, that boundary node (if not quiescent) could forward to the interior. Under quiescence, nodes outside the active regions do not change state and cannot forward newly received information, but if K=2t (so dist(R_a,R_b)=1), a single cross-edge allows immediate coupling. K=2t+2W+1 implies dist(R_a,R_b) \u2265 2, forbidding any direct edge between active regions; Claim 8.1 then applies. \u25a1\n\n## Revised formulation of the node\u2192edge elimination (fixing the non-conflict)\nWe adopt a universal-quantifier variant that aligns with classical round-elimination (where labels become sets of allowed labels) and avoids the earlier \u201cdouble-grab is fine\u201d pitfall.\n\n### Definitions (edge-local boundary types and consistency)\n- Fix \u0394, t and a bounded-degree tree G. For an edge e = uv, let B = B(e,2t) and let \u2202B be the set of vertices at exact distance 2t from e. A boundary snapshot \u03b2 consists of: (i) the arrived subgraph inside B just before the (yet-to-be-decided) step at which e will be oriented, (ii) the fixed outputs and internal states on \u2202B at that moment. We say a local arrival schedule \u03c4 inside B (a permutation of some/all vertices of B, ending at or after the arrival of the second endpoint of e) is consistent with \u03b2 if running A on the induced arrived subgraph inside B, starting from \u03b2 with all vertices outside B absent, produces the transcript \u03c4 and preserves the boundary \u03b2 as fixed (i.e., no outside interaction).\n- By Lemma NE, any such \u03c4 is realized as the prefix of some global schedule with the same transcript on B(e,t) up to the decisive step, and any global schedule can be normalized to such a \u03c4 without changing B(e,t) transcripts.\n\n### Universal forcing relation and node\u2192edge step (LB.1u)\n- For each oriented option u\u2192v of e and boundary snapshot \u03b2, define that u universally forces u\u2192v under \u03b2 if for all normalized local arrival schedules \u03c4 inside B consistent with \u03b2 in which both u and v have arrived (i.e., up to and including the step that makes e decidable), the online run of A yields orientation u\u2192v for e (under the natural interpretation of A\u2019s final decision on e at or before the second endpoint\u2019s arrival; if A defers orientation, consider the orientation implied by the first time both endpoints have arrived and message influence can reach e within the remaining steps of \u03c4).\n- Define the derived edge-centered (t\u22121/2)-local rule A\u2032 on B: given \u03b2, set the admissible set S_e(\u03b2) \u2286 {u\u2192v, v\u2192u} by\n  S_e(\u03b2) = { u\u2192v : u universally forces u\u2192v under \u03b2 } \u222a { v\u2192u : v universally forces v\u2192u under \u03b2 }.\n- Non-conflict lemma. For any \u03b2, it is impossible that both u universally forces u\u2192v under \u03b2 and v universally forces v\u2192u under \u03b2. Otherwise, pick any \u03c4 consistent with \u03b2; by universality, e must be oriented both u\u2192v and v\u2192u in the same (normalized) run\u2014a contradiction.\n- Why useful here. A\u2032 assigns, per boundary \u03b2, a set S_e(\u03b2) of admissible orientations; this is the standard \u201cset-valued label\u201d after a half-step of round-elimination. No contradictions arise, and the dependency radius drops by 1/2 (node\u2192edge) while everything remains confined to B(e,2t).\n- Correctness scope. Using Lemma NE, any normalized local schedule realized globally has the same transcripts on B(e,t); thus the admissible set S_e(\u03b2) captures exactly the orientations consistent with all normalized continuations, which is the right notion in round-elimination. This construction is independent of arrivals outside B, thanks to normalization.\n\n### Iteration plan (edge\u2192node universal half-step)\n- Symmetrically, define for a node x the set of admissible incident-edge orientations based on universal quantification over normalized local schedules within B(x,2t\u22121), obtaining a node-centered (t\u22121) rule with set-valued labels.\n- Iterating node\u2194edge 2t times yields a 0-round object in which each edge e has a non-empty set S_e of admissible orientations determined by its constant-radius type (from the ID-graph framework). The contradiction to the ID-graph (Def. 2.16) follows if one shows that these sets cannot be assigned globally without creating a forbidden configuration (as in the classical proof).\n- To do next: formalize the symmetric edge\u2192node universal step and state the precise induction invariant \u201cuniversality is preserved under elimination,\u201d paralleling the classical round-elimination schema with set-valued labels.\n\n## How this addresses the verifier\u2019s concerns\n- The earlier non-conflict gap is eliminated: we no longer claim existential \u201cthere exists a witness\u201d for each direction; instead, we define admissibility via universal quantification over all normalized local schedules given a fixed boundary snapshot \u03b2. Non-conflict is immediate by logic, and the elimination becomes a transformation on sets of allowed labels, i.e., exactly the classical framework.\n- The required normalization-and-extension tool is provided (Lemma NE), ensuring any normalized local schedule and boundary snapshot \u03b2 correspond to some global execution and that outside arrivals can be pushed after without affecting B(e,t).\n\n## Minor clarifications on output.md\n- Lemma 8: The boundary-state sufficiency (Claim 8.1) is correctly stated; it may help to add one explicit sentence that the \u22652 separation is used only to exclude any single cross-edge between distinct active regions, which, together with quiescence and standard LOCAL timing, forbids any causal path between active regions within the t-round phase.\n- Remark after Corollary B vs Lemma 8: The archive already notes why no +1 is needed for sequential (R,W)-simulation. The minimal-path counterexample above motivates the +1 for quiescent batching, with an explicit 2-round signal path ruled out by dist(R_v,R_w) \u2265 2.\n\n## Obstacles and caveats\n- Precise semantics at the \u201cdecisive step for e\u201d: In the universal relation, we appealed to the first moment both endpoints have arrived under \u03c4. This is natural for edge-orientation; still, to be fully rigorous, we will explicitly fix the \u201cdecision time\u201d as the earliest time at which both endpoints are arrived and the remaining rounds of the current window cannot affect the admissible orientation beyond B(e,t) (this is standard in the classical proof and aligns with Lemma NE).\n- Edge\u2192node half-step and preservation of universality: We need to write the exact dual construction and show that the set-valued constraints compose without loss; this mirrors the classical proofs, but we will write it out with the online normalization in place.\n\n## Next steps (auditable)\n1) Write and insert Lemma NE (Normalization-and-Extension around an edge) in output.md with the proof based on Lemma 7 (and its vertex counterpart already archived as Lemma 9).\n2) Restate LB.1 as LB.1u (universal node\u2192edge step) precisely, with the definitions of boundary snapshot \u03b2, normalized local schedules inside B(e,2t), and the universal forcing relation; include the non-conflict lemma and the (t\u2192t\u22121/2) dependency analysis.\n3) Formalize the symmetric edge\u2192node universal step and the induction invariant that the admissible-set semantics is preserved by iteration; then state LB.2 (iteration to 0 rounds) and conclude the ID-graph contradiction.\n4) Optionally, add a brief \u201cmodeling note\u201d explaining that our elimination works with set-valued admissible labels under universal quantification, which is the standard device in classical round-elimination, and that normalization via Lemma NE ensures online effects outside B(e,2t) are irrelevant.\n5) In parallel, continue exploring a constructive positive route under additional hypotheses (finite-state and ID-oblivious algorithms): attempt to prove a path, t=1 interface-invariance lemma via finite enumeration of boundary types; if successful, this yields a quiescentization transform in that regime.\n\n## Why this is progress\n- We provide a rigorous normalization-and-extension lemma tailored to edges, removing ambiguity about embedding local schedules into global runs.\n- We fix the core gap in the lower-bound program by adopting a universal set-valued elimination step (LB.1u), which is standard in classical proofs and avoids the earlier invalid \u201cdouble-grab\u201d argument in the node-form.\n- These pieces are local, finite-radius, and independently checkable, and they pave the way to completing the lower-bound route, which in turn implies the desired O(log* n) LOCAL upper bound for the class Online-LOCAL(t)=O(1) on trees via the known classification.\n"}, {"prover_id": "02", "progress_md": "Status and target\n- Goal: Close the remaining gap for the general Online-LOCAL(t) case on bounded-degree trees by finalizing the lower-bound route (localized round-elimination for sinkless orientation) and by clarifying the decision semantics so that the non-conflict step (\u201cdouble grab implies contradiction\u201d) is valid.\n- What is already archived and solid: Lemma 7 (2t-commutativity), Corollary 7.1 (witness localization), Lemma 8 (quiescent bridge with K = 2t+2W+1), Claim 8.1 (phase-locality inside a color phase), and Lemma 9 (strong witness localization at v). These give an O(log* n) upper bound for quiescent/output-only regimes and the tools needed to localize online effects to B(\u00b7,2t).\n\nGap identified in output.md (lower-bound program)\n- The previously sketched node\u2192edge elimination step (LB.1) for sinkless orientation used the node-form (each node chooses an outgoing edge). As the verifier noted, \u201cdouble witnesses\u201d at the two endpoints of an edge do not contradict node-form feasibility\u2014both endpoints may choose the same edge without violating \u201cnot a sink.\u201d To proceed, we must (i) change to an edge-form LCL with a decisive step at the second endpoint, or (ii) use a universal-quantifier elimination variant that records sets of feasible labels per edge. Below I formalize both options, with a concrete normalization-and-extension lemma that is needed in either case.\n\nNew model ingredient (to make non-conflict well-defined)\n- Edge-decided Online-LOCAL(t) for sinkless orientation. For orientations, we adopt edge-form semantics: an edge e = uv becomes decidable at the moment the second endpoint arrives; in that arrival window (t rounds), the algorithm must irrevocably choose one of the two orientations for e, and encode it redundantly at both endpoints. Earlier arrivals may maintain local state and make temporary proposals, but the only irrevocable decision for e is the orientation made when the second endpoint arrives. The global LCL constraint is: in the final orientation, every vertex has outdegree \u2265 1, and every edge is oriented in exactly one direction.\n- Why useful: Under this semantics, two locally consistent histories that force opposite orientations for the same edge at the same decisive moment are genuinely contradictory; hence a \u201cdouble-witness\u201d proves inconsistency, fixing the non-conflict step in LB.1.\n\nNormalization-and-extension lemma (precise, to use in LB.1)\n- Lemma NE (Extension of localized schedules on trees). Fix an edge e = uv and radius t \u2265 1. Let X := B(e,2t). Consider any arrival schedule \u03c4 on X in which (i) only vertices of X arrive before the decisive step for e (the second of u,v), and (ii) outside vertices V\\X are absent up to that decisive step. Then \u03c4 extends to a global arrival order \n  \n  \u03c4\u0302 on V(G) such that the transcript inside B(e,t) up to and including the decisive step is identical to that under \u03c4.\n- Proof idea (tree + Lemma 7 + Corollary 7.1): Keep all steps on X exactly as in \u03c4 and defer all outside arrivals to after the decisive step. During each arrival inside X, any vertex w \u2208 V\\X is at distance > 2t from both u and v (by definition of X), hence cannot affect B(e,t) within t rounds (Lemma 7). Thus, the absence of outside vertices is consistent and their later arrival cannot retroactively change the transcript in B(e,t). Corollary 7.1 guarantees we can push any stray outside arrival (if any) past the decisive moment without changing states in B(e,t). The tree structure prevents cycles across \u2202X and ensures no \u201cfeedback\u201d from absent nodes. Therefore \u03c4\u0302 exists and preserves the local transcript. (We will write a fully quantified version for output.md; the above captures the key invariants.)\n- Sanity check (t = 1): X = B(e,2) contains u, v, their neighbors, and neighbors\u2019 neighbors. Any path from V\\X to B(e,1) has length \u2265 2. In the 1-round windows of vertices of X, information from V\\X cannot reach B(e,1); hence deferring V\\X is harmless.\n\nLB.1e (node\u2192edge reduction, decisive-edge variant)\n- Statement (existential form). Assume a deterministic Online-LOCAL(t) algorithm A solves sinkless orientation under edge-decided semantics for all arrival orders on bounded-degree trees. Fix an edge e = uv. After normalizing the prefix so that only vertices in X = B(e,2t) may arrive before the decisive step for e (by Cor. 7.1 and Lemma NE), the orientation of e produced by A depends only on the labeled ball X (IDs and port orderings restricted to X). Consequently, there is a well-defined edge-centered (t\u22121/2)-local rule A\u2032 that, given X, outputs the unique orientation of e.\n- Proof sketch (two parts):\n  1) Dependence on X. Suppose there are two normalized schedules \u03c41, \u03c42 on X (with outside vertices absent) that lead A to choose opposite orientations at the decisive step. Apply Lemma NE to extend \u03c41, \u03c42 to global schedules \u03c4\u03021, \u03c4\u03022 that preserve the transcript inside B(e,t) up to the decisive step. Now consider a hybrid schedule that follows \u03c4\u03021 up to the decisive step and \u03c4\u03022 afterward (or vice versa). Since the decisive decision must be made based solely on the state in B(e,t) at that moment, and these states coincide with the ones in \u03c4\u03021 and \u03c4\u03022 respectively, we force A to choose both orientations on the same global input at the same decisive moment\u2014a contradiction. Hence the orientation is unique and depends only on X.\n  2) Radius accounting and \u201c\u22121/2\u201d: The rule is edge-centered because the decisive step is tied to the second endpoint. Looking one \u201chalf layer\u201d beyond B(e,t) suffices to resolve which endpoint arrives second in the normalized view and to collect all causal influences (the classical t\u2192t\u22121/2 descent). The dependence on X = B(e,2t) matches the standard round-elimination radius on trees.\n- Why (t\u22121/2)-local: As in classical round-elimination, the node\u2192edge step consumes half a round because the edge rule skips one endpoint\u2019s final local step and aggregates the two adjacent node views into a single decision.\n\nLB.1u (universal-sets variant\u2014safer and closer to classical elimination)\n- Statement (set labeling). Under the same setup, for each edge e and labeled ball X = B(e,2t), define S_e(X) \u2286 {u\u2192v, v\u2192u} to be the set of orientations that A may choose at the decisive step over all normalized arrival schedules on X consistent with the fixed labels on X (with outside vertices absent). By Lemma NE and Cor. 7.1, S_e(X) depends only on X. Moreover, S_e(X) \u2260 \u2205 (A always orients e when both endpoints have arrived). This yields an edge-centered (t\u22121/2)-local rule that assigns each edge a nonempty set of allowed orientations.\n- Preservation of node constraints under sets. For any vertex w and its incident edges E(w), define the node constraint \u201cno-sink in sets\u201d as: there exists e \u2208 E(w) such that S_e contains an orientation pointing away from w. Suppose, for contradiction, that all S_e forbid an outgoing choice for w. Then, in every normalized local schedule on the union \u22c3_{e\u2208E(w)} B(e,2t) consistent with the same labels, A would be forced to leave w without any outgoing edge at the moment all incident edges become decidable\u2014contradicting correctness. Thus the \u201cno-sink in sets\u201d constraint holds locally for the family {S_e}.\n- Why this variant is attractive: It avoids the non-conflict/gluing subtlety entirely; instead of proving uniqueness, we carry sets of feasible labels as in classical round-elimination. The next elimination step will shrink these sets further.\n\nLB.2 (iteration to 0 rounds and ID-graph contradiction)\n- Statement (outline in the universal-sets framework). Alternating the localized node\u2194edge elimination steps 2t times, we obtain a 0-round edge-centered set-labeling rule S^{(0)} that assigns to each edge e a nonempty subset S^{(0)}_e \u2286 {u\u2192v, v\u2192u}, where S^{(0)}_e depends only on the ID labels in B(e,2t). The node constraints persist at each step (\u201cno-sink in sets\u201d remains satisfiable). As in the classical proof with ID-graphs, this induces a 0-round global prescription depending only on IDs in constant-radius neighborhoods which must satisfy the sinkless-orientation constraints. By the ID-graph property (Def. 2.16), such a 0-round prescription cannot exist, yielding a contradiction. Therefore, no deterministic constant-t Online-LOCAL algorithm (under edge-decided semantics) solves sinkless orientation on bounded-degree trees.\n- Remarks:\n  \u2022 The elimination preserves nonemptiness and the node constraints because both are verified locally on finite balls and follow from correctness of A over all normalized local schedules (by Lemma NE and witness localization).\n  \u2022 The final contradiction for 0 rounds mirrors Theorem 2.15\u2019s ID-graph argument: a 0-round rule reduces to an ID-based choice for each edge with no room for coordination; the girth and independence properties of H forbid satisfying the constraints everywhere.\n\nAuditable components ready to integrate into output.md\n1) Add the new Edge-decided Online-LOCAL(t) semantics for orientations (a brief model paragraph). This cleanly separates edge orientation from node \u201cgrabs\u201d and fixes the earlier non-conflict issue.\n2) Add Lemma NE (Normalization-and-extension of localized schedules) with a complete proof. It relies only on Lemma 7, Corollary 7.1, and the tree structure. We recommend including the explicit t=1 special case as an illustrative sublemma.\n3) Add LB.1u (universal-sets node\u2192edge step) as the main elimination step (safer to verify). State precisely that S_e depends only on X = B(e,2t); prove nonemptiness and the local \u201cno-sink in sets\u201d property.\n4) State LB.2 (iteration to 0 rounds) at the same universal-sets level, and outline the ID-graph contradiction. If desired, include the decisive-edge variant LB.1e as a lemma following from uniqueness; its proof is short once Lemma NE is in place.\n\nSanity checks and small examples\n- t = 1, paths/trees. For e = uv, X = B(e,2) suffices. It is straightforward to enumerate normalized schedules on X and verify that S_e(X) is determined solely by labels on X; any attempted dependence on arrivals outside X would contradict Lemma NE.\n- Why \u201cno-sink in sets\u201d is preserved: If S_e(X) excluded all orientations out of u for e incident to u, then every completion of arrivals consistent with X would leave u sink at the decisive times\u2014contradiction to A\u2019s correctness.\n\nEdits and clarifications suggested for output.md\n- Add a short \u201cOrientation semantics for lower bounds\u201d remark: we work with edge-decided Online-LOCAL(t) for sinkless orientation (orientation fixed at the second endpoint\u2019s arrival). This avoids the double-grab pitfall in the node-form.\n- Insert Lemma NE (Normalization-and-extension lemma) in the \u201cOnline round-elimination on trees\u201d subsection; cite it in LB.1u/LB.2.\n- Present LB.1u (universal-sets node\u2192edge) and LB.2 (iteration) as formal statements; defer the mechanical details of the edge\u2192node half-step to the next iteration (we will mirror the standard set-propagation used in classical elimination and keep all radii explicit).\n\nNext steps (concrete, checkable)\n1) Write the full proof of Lemma NE with explicit quantifiers and a careful boundary argument (no edges across R_v regions for t rounds). Provide the t = 1 special case as a warm-up.\n2) Formalize the edge\u2192node half-step in the universal-sets framework, including its exact radius transformation and the preservation of nonemptiness and node constraints.\n3) Complete the LB.2 write-up: define the inductive family of set rules S^{(k)}, prove invariants, and carry out the final ID-graph contradiction carefully (as in Theorem 2.15), referencing the girth and independence properties.\n4) Optionally, give a short note showing that, if one prefers, LB.1e (decisive-edge uniqueness) can be proven directly for t = 1 (trees), then extended to general t by induction on t using the universal-sets machinery.\n\nAdditional observations (minor)\n- Output.md is consistent on radii: Lemma 8 needs K = 2t+2W+1; Corollary B simulates a derived sequential (R,W)-rule and needs K = max(2W, R+W) (no +1). The explanatory remark is already present\u2014good.\n- No further gaps spotted in the positive (quiescent) route. After integrating the LB lemmas above, we can state the main theorem existentially: Any LCL solvable in O(1) deterministic Online-LOCAL(t) on bounded-degree trees admits an O(log* n) deterministic LOCAL algorithm. (Proof: such an LCL cannot be in the log n-hard class by the lower bound; hence by tree classification it lies in the O(1)/\u0398(log* n) class.)\n"}]

Current notes.md:
Context and goal
We study the relationship between online-style constant-locality algorithms for LCLs on bounded-degree, unoriented trees and deterministic LOCAL-time upper bounds. Two notions of “online local” are relevant:
- Sequential local/greedy model (order-robust r-local): when processing a vertex v, the decision at v depends only on the r-hop neighborhood B(v,r) of the underlying graph and on already fixed outputs within B(v,r); the algorithm must succeed for every vertex order. No global mutable state or long-range message accumulation between steps.
- Online-LOCAL(t) (Akbari–Eslami–Lievonen–Melnyk–Särkijärvi–Suomela, ICALP’23): vertices arrive one by one; upon each arrival, the algorithm has t synchronous LOCAL rounds on the subgraph induced by arrived vertices; outputs are irrevocable. Over many arrivals, an unbounded number of communication rounds can occur, enabling long-range state accumulation.

Safe, proven variant (archived below in output.md)
- Theorem (Sequential-local to LOCAL): If an LCL Π on bounded-degree graphs has a deterministic order-robust r-local sequential algorithm (decisions at v depend only on B(v,r) and outputs of earlier vertices in B(v,r), and the rule writes only the output at v), then Π has a deterministic LOCAL algorithm running in O(r log* n + Δ^{O(r)}) rounds. On bounded-degree trees with constant r, this is O(log* n). Proof: compute a proper coloring of G^r in O(r log* n) rounds with Δ^{O(r)} colors; process color classes in order, letting each v gather outputs from B(v,r) restricted to earlier colors and apply the sequential rule. Because nodes of the same color are at distance > r, their decisions do not depend on each other.

Gap for the full Online-LOCAL(t) model
- A direct phase simulation that uses a distance-(2t) coloring and t rounds per color does not generally reproduce the state a node v would see upon arrival in an actual online execution. In a true online run, before v arrives, there may have been Θ(n) earlier arrivals, yielding Θ(n)·t global rounds; information can propagate arbitrarily far and may alter the states within B(v,t). The phase simulation grants only O(1)·t total rounds before v’s phase, so the local states can differ. Hence, without additional constraints, we cannot claim that the phase simulation faithfully reproduces the online run or even yields correctness solely from A’s correctness.

Ways forward for Online-LOCAL(t)
- Add a locality-of-dependence assumption: the t-round transcript that determines v’s output depends only on the arrived subgraph inside distance ≤ t from v and on the outputs of those nodes, not on mutable states imported from farther away. Under this, distance-(2t) coloring plus phase simulation is valid and yields O(log* n).
- Alternatively, seek a structural scheduling/padding argument ensuring that for LCLs on bounded-degree trees, the state within B(v,t) before v’s arrival is independent of far-away arrivals. This is nontrivial; try first on paths/trees with t=1 to see whether accumulation can matter for any LCL.
- Or try to separate the models: construct an LCL that is solvable in constant t in Online-LOCAL but provably not simulable by the above constant-phase compression; if such an LCL exists, the general reduction fails, and the sequential-local variant becomes the correct target.

Remarks
- No global edge orientation is needed anywhere in the reduction we proved; IDs suffice for coloring.
- The archived proof applies to all bounded-degree graphs; we stated trees to match the project focus.
Refinements on bridging Online-LOCAL(t) to sequential local rules
- Definitions (recap and refinement):
  • Online-LOCAL(t): vertices arrive one by one; upon each arrival we have t synchronous LOCAL rounds on the subgraph induced by arrived vertices; outputs are irrevocably set at arrival; in the general model, nodes may maintain unbounded mutable state across arrival windows.
  • Output-only Online-LOCAL(t): the only persistent state at nodes is the immutable output label after it is set; between windows there is no other state; in any t-round window, messages sent by a node are functions only of the underlying graph and the currently known outputs within its distance-t neighborhood (no dependence on farther outputs or on pre-window mutable state).
  • t-local-dependence at v: when v arrives, its output depends only on the arrived subgraph restricted to B(v,t) and outputs of the arrived nodes within B(v,t).

- Correct radius accounting:
  • At v’s arrival with window length t, nodes within B(v,t) can influence v. A node u ∈ B(v,t) may compute its messages based on outputs within B(u,t), which is contained in B(v,2t). Thus, in the output-only model, v’s output depends only on the graph structure and outputs within B(v,2t). Consequently, the correct bridge is to a sequential rule of radius 2t (not t). If we assume t-local-dependence at v, the bridge tightens to radius t.

- Minimal counter-scenario (why naive phase-compression fails for the unrestricted online model):
  Consider a path with t=1. In a genuine online run, before a vertex v arrives, Θ(n) earlier arrivals can propagate state one hop per window across the path; by the time v arrives, its neighbors may carry information injected far away. A color-phased simulation that offers only O(1) windows before v’s phase cannot reproduce these accumulated states. This shows that without output-only or t-local-dependence, we cannot black-box simulate arbitrary Online-LOCAL(t) runs by a constant number of phases.

- Practical takeaway for reductions:
  • If your online algorithm is output-only, design the sequential rule to read B(v,2t) and write only at v; then apply the G^{2t} coloring pipeline to get O(log* n) on bounded-degree trees.
  • If your online algorithm satisfies t-local-dependence at v, the sequential rule needs only B(v,t).

- Next-step plan (state elimination on trees):
  • Start on paths with t=1. Define the interface ∂B(v,2) and annulus R=B(v,2)\B(v,1). Attempt to prove: if two online executions agree on outputs over B(v,2), then they allow exactly the same outputs at v. If proven, extend to trees and t by replacing 2 with 2t. If refuted, crystallize a separation example.
  • Track read/write radii for any sequential rules that go beyond “write only at v”; use distance-(R+W) colorings for phase independence.
Additions and corrections

1) Correct simulation radius for bounded writes.
- When simulating an order-robust sequential rule that reads within B(v,R) and may write within B(v,W), independence within a color class requires both:
  • Write–write disjointness: B(u,W) ∩ B(v,W) = ∅.
  • Read–write disjointness: B(u,R) ∩ B(v,W) = ∅ and B(v,R) ∩ B(u,W) = ∅.
- These are guaranteed if dist(u,v) > max(2W, R+W). Therefore, the correct coloring is a proper coloring of G^K with K = max(2W, R+W). Using G^{R+W} alone is insufficient in general.
- Minimal counterexample to G^{R+W}: Take R=0, W=1 on the path u–x–v. Here dist(u,v)=2>R+W, but B(u,1)∩B(v,1)={x} so simultaneous writes conflict.

2) Output-only, W-write Online-LOCAL(t) ⇒ sequential (R,W) with R=2t+W.
- Model: When v arrives, A runs t rounds and may irrevocably write outputs on B(v,W); messages during this window depend only on the graph and the currently known outputs within distance ≤ t of the sender; no other mutable state persists.
- Radius accounting: To decide outputs on the patch B(v,W) within t rounds, only nodes in B(B(v,W), t) = B(v, W + t) can send messages that reach the patch. Under output-only, each such sender’s messages are functions of outputs in its own t-ball. Hence the decisions on the patch depend only on outputs within B(v, W + 2t) = B(v, 2t + W).
- Sequential rule S: For a given order σ, when processing v, S reads already-fixed outputs in B(v, 2t+W) and deterministically reproduces A’s t-window on the patch, writing only to currently-unset outputs in B(v,W). Because A is deterministic and correct for all orders, S reproduces A’s result for order σ.

3) Commutativity of independent arrivals (unrestricted Online-LOCAL(t)).
- If two consecutive arrivals u and w satisfy dist(u,w) > 2t, swapping their order leaves the t-round transcripts and resulting states identical everywhere. In particular, by repeatedly swapping, one can assume that, when analyzing v, only arrivals within B(v,2t) occur before v. This normalizes the analysis horizon for any state-elimination attempt.

4) State-elimination program on paths (t=1) — concrete targets.
- Define the interface K(v) as the already-fixed outputs on B(v,2) just before v arrives (after normalizing the order so only B(v,2) arrives first). Target claim (context-invariance): The set of feasible outputs/messages at v depends only on K(v). If true, derive a canonical sequential rule of read radius R=2 and (potential) write radius W by reproducing the canonical choice. If false, document a counterexample LCL on paths.

5) Accounting for LOCAL complexity when W>0.
- With (R,W)-local sequential rules, compute a proper coloring of G^{K} with K = max(2W, R+W) in O(K log* n) rounds (Lemma 1 simulated on G), then process colors in O(R) rounds per color. On bounded-degree trees with constant R,W, this gives O(log* n) overall.
Disproof of “faithful color-by-color simulation” for unrestricted Online-LOCAL(t)
The tempting idea to fix a proper coloring φ of G^{2t}, choose the arrival order σ_φ that processes color classes 1,2,…,C, and then simulate each color class in O(t) rounds by running all arrivals of that color concurrently, is not valid in the unrestricted Online-LOCAL(t) model.

Key obstruction: In the Online-LOCAL(t) semantics, each arrival triggers t synchronous rounds across the entire arrived subgraph. Nodes outside B(v,t) of the newly arrived vertex v may still update their local state in that step (e.g., increment a local counter) even though they receive no messages. Over k arrivals in a color class, every previously arrived node performs k such "idle" updates. Compressing k steps to 1 per color fails to reproduce the global state unless one can apply k-fold local updates everywhere, which is not locally computable in O(1) rounds.

Minimal counterexample (paths, t=1). Consider the trivial LCL Π that accepts any labeling. Define a deterministic Online-LOCAL(1) algorithm A as follows:
- Every arrived node maintains a parity bit p, initially 0, and toggles p at every arrival step (independently of messages).
- When a new vertex v arrives, in the 1-round window v queries any neighbor u (if one exists) for p and outputs that bit. (If v has no arrived neighbor, it outputs 0.)
This A is correct for Π for every arrival order (Π accepts any labeling). Fix any proper 3-coloring φ of the path’s G^2. In the sequential σ_φ-run that processes all color-1 vertices one by one, p toggles at every arrival, so the outputs of color-1 vertices alternate with their internal order. A batched O(1)-round simulation that processes all color-1 vertices simultaneously cannot reproduce these alternating outputs: all of them see the same parity p from earlier colors and output the same bit. Hence faithful reproduction of the σ_φ-run is impossible in general.

Consequences.
- The earlier “main gap” (state accumulation across many arrivals) is real for unrestricted Online-LOCAL(t): batched simulation does not, in general, preserve the online run’s state trajectory.
- To make per-color batching sound, one needs extra structure such as quiescence: outside B(v,t), the per-step state update is the identity (or, more generally, does not depend on the number of arrivals). The output-only and t-local-dependence variants already enforce related constraints.

On Lemma 8 and local order normalization
- Our Corollary 7.1 already implies the witness localization needed for per-node analysis: by swapping distant arrivals (dist > 2t), one can assume all arrivals before v occur in B(v,2t) without changing the state in B(v,t) at v’s arrival. This is the appropriate normalization tool for any local confluence/interface analysis.

On Lemma 9 (finite enumeration claim)
- As stated (“the set of possible transcripts/messages seen by v is finite”), this is false in the standard LOCAL model due to unbounded message/state spaces and dependence on unique IDs. Finite enumeration becomes viable only if one assumes bounded message alphabets, bounded state, or ID-obliviousness; otherwise, for a fixed constant-size ball B(v,2), the algorithm can encode arbitrarily large ID-dependent information into messages/states.

Next steps for the path/t=1 interface program
- Either (i) impose output-only (or stronger quiescence/ID-obliviousness) and aim to prove the context-invariance Claim C1 under those constraints, or (ii) build a concrete counterexample to C1 in the unrestricted model by letting neighbors’ 1-round messages to v depend on the number of prior arrivals while keeping K(v) fixed. In both tracks, use Corollary 7.1 to restrict attention to B(v,2).

Complexity reminder for bounded writes
- With (R,W)-local sequential rules, independence within a color class requires K = max(2W, R+W). Computing a proper coloring of G^{K} costs O(K·log* n) rounds and per-color work is O(R). For bounded Δ, R, W, this yields O(log* n) total complexity dominated by the coloring step.
New bridge via quiescence (precise form) and radius accounting
- Definition (quiescent Online-LOCAL(t), standard LOCAL timing). In each arrival step for v, the algorithm runs t synchronous LOCAL rounds on the arrived subgraph. Messages sent in round r depend only on the node’s state at the start of round r; at the end of the round, nodes update their state based on received messages. The algorithm is quiescent if, during the t rounds triggered by v’s arrival, every node u with dist(u,v) > t does not change its state in any of these t rounds. (Under the above timing, such u cannot forward newly received information in subsequent rounds because its outgoing messages in round r depend only on its unchanged state.)
- (W,t)-quiescent: If the algorithm may irrevocably write outputs on a patch B(v,W) during v’s window, we call it (W,t)-quiescent if only nodes in B(v,W+t) may change state in that window.

- Correct separation for parallel batching: To parallelize all same-color windows for t rounds without interference, it is necessary to forbid any edge between distinct active regions. For W=0 the active region for v is B(v,t). Thus, a proper coloring of G^{2t+1} (not merely G^{2t}) guarantees that for same-color u,v, dist(u,v) ≥ 2t+2, hence dist(B(u,t), B(v,t)) ≥ 2. This eliminates one-hop coupling across region boundaries. With W>0, color G^{2t+2W+1} so that distinct active regions B(·,W+t) have mutual distance ≥ 2.

- Why quiescence removes the “idle-accumulation” pitfall: In the unrestricted model, nodes can encode the number of prior arrivals into their state and/or messages, letting each new window see different ambient information; batching then fails. Under quiescence, any vertex whose t-window has not yet been processed cannot track steps that do not involve it, so its local view (modulo the already-arrived graph and earlier colors) is invariant across the internal order within a color class. Combined with the ≥2 separation between active regions, the parallel t-round simulation per color faithfully matches any sequential permutation of that color.

- Examples that fit quiescence: Greedy MIS and greedy maximal matching on bounded-degree graphs (W=1, t=1) where only the newly active 1-neighborhood changes, and (Δ+1)-vertex-coloring rules that finalize a 1-hop patch around the arrival.

Remark on Lemma 7 (2t-commutativity)
- The lemma remains valid even if nodes outside B(u,t) ∪ B(w,t) perform deterministic updates depending only on the global step index (and not on messages). Those nodes experience the same two consecutive step indices before and after the swap; hence their pair of updates is identical.

Lower-bound program (outline) for Online-LOCAL on trees
- Target: Prove that sinkless orientation on bounded-degree trees admits no deterministic Online-LOCAL(t)=O(1) algorithm (adversarial arrival). Use Lemma 7/Cor. 7.1 to normalize prefixes so that only B(e,2t) arrives before deciding edge e. Then adapt the node↔edge round-elimination locally inside B(e,2t), iterating 2t times to obtain a 0-round contradiction with the ID-graph property. Formalizing this (LB.1–LB.2) would non-constructively imply: any LCL with constant-t Online-LOCAL on trees lies in the O(1)/Θ(log* n) class, so there exists an O(log* n) deterministic LOCAL algorithm.

Next steps
- Integrate the quiescent bridge with K=2t+1 (resp. 2t+2W+1) into output.md.
- Begin the path (t=1) state-elimination-by-quiescence attempt with a precise interface Σ(u→v) and normalized histories (via Cor. 7.1). Either prove context-invariance or extract a counterexample LCL.
- In parallel, formalize LB.1–LB.2 for sinkless orientation as described above.
Additions (witness localization, phase-locality, and LB pitfalls)

1) Strong witness localization at v (unrestricted Online-LOCAL(t)). Using Lemma 7 (2t-commutativity), one can bubble v leftward across any predecessor u with dist(u,v) > 2t. Performing all such swaps yields an arrival sequence in which every predecessor of v lies in B(v,2t). Moreover, the set of predecessors of v inside B(v,2t) is unchanged, so the arrived subgraph just before v equals the restriction of the original arrived subgraph to B(v,2t). Each swap preserves the state on B(v,t) at v’s arrival; hence the state on B(v,t) when v arrives is identical before and after normalization. This refinement is now recorded as Lemma 9 in output.md.

2) Phase-locality under (W,t)-quiescence. In Lemma 8’s color-phase simulation with K = 2t+2W+1 (so that dist(R_v,R_w) ≥ 2 for R_v = B(v,W+t)), nodes outside R := ⋃ R_v keep their state fixed in the t rounds of the phase. Under standard LOCAL timing (send from current state; receive; update), such nodes cannot forward newly received information in later rounds. Therefore, there is no causal influence along any path that leaves one active region and re-enters another within the same phase. The transcript inside each R_v depends only on the initial boundary states, and the effects of different R_v commute. This is now formalized as Claim 8.1 inside Lemma 8’s proof.

3) Localized round-elimination on trees: modeling choices and a gap. The intended LB.1 (node→edge) step asserts that if both endpoints have local witnesses for opposite orientations of an edge e inside B(e,2t), then one can glue these into a single global execution that contradicts correctness. This is not valid for the node-form of sinkless orientation: both endpoints may “grab” e without violating the constraint that every node has at least one outgoing edge. To proceed, adopt one of:
- Edge-form LCL with decisive step at the second endpoint, so “double-witness in opposite directions” is a genuine contradiction; or
- A universal-quantifier version of the elimination step, together with a proof that the universal property is preserved by iteration; and in all cases
- A precise normalization-and-extension lemma: any normalized local arrival order inside B(e,2t) extends to a global order whose transcript inside B(e,t) (up to the decisive step for e) is preserved.

4) Radius sanity. The +1 in K = 2t+2W+1 (for quiescent batching) is necessary to guarantee dist(R_v,R_w) ≥ 2 and exclude one-round coupling across a single cross-edge. In contrast, in Corollary B we simulate a derived sequential (R,W)-rule and only require K = max(2W, R+W) (no +1).

Next steps (crisp):
- Prove the normalization-and-extension lemma for balls B(e,2t) on trees.
- Fix the problem model for the LB route (edge-form with a decisive step, or a universal-quantifier variant) and re-state LB.1/LB.2 accordingly; then supply complete proofs.
- Continue the path, t=1 interface study under quiescence or output-only; either prove context-invariance or give a counterexample LCL confined to B(v,2).


Current output.md (if any):
List of proven results archived here
- Lemma 1: Power-graph coloring in O(k log* n).
- Lemma 2: Color-phased simulation for order-robust read-radius r rules that write only at the current node (W=0).
- Theorem A: Sequential-local (W=0) ⇒ LOCAL on bounded-degree graphs.
- Lemma 3: Bridge from output-only Online-LOCAL(t) (W=0) to order-robust sequential with read radius 2t.
- Lemma 4: Bridge under t-local-dependence (W=0) to read radius t.
- Corollary A: On bounded-degree trees, constant r or constant t ⇒ O(log* n) LOCAL.
- Lemma 5: Color-phased simulation for sequential rules with read radius R and write radius W via a G^{K}-coloring with K = max(2W, R+W).
- Lemma 6: Bridge from output-only, W-write Online-LOCAL(t) to an order-robust sequential rule with (R,W) = (2t+W, W).
- Corollary B: On bounded-degree trees, constant t,W in output-only W-write Online-LOCAL(t) ⇒ O(log* n) LOCAL.
- Lemma 7: 2t-commutativity of independent consecutive arrivals in Online-LOCAL(t), and a corollary pushing far-away arrivals past a fixed v.

Model and definitions
- Graphs: finite, simple, maximum degree Δ < ∞ (bounded degree). Nodes have unique IDs from a polynomial range (standard LOCAL assumptions). dist(·,·) is the hop distance; B(v,r) is the radius-r ball around v.
- LCL Π: a locally checkable labeling problem with constant checkability radius r_Π.
- Order-robust sequential rules with bounded writes: A deterministic rule S with read radius R and write radius W is a procedure that, when processing v in a vertex order σ, inspects G[B(v,R)] and the outputs already fixed in B(v,R) ∩ {earlier vertices in σ}, and may irrevocably write outputs on any currently-unset vertices in B(v,W). The final labeling must satisfy Π for every σ. (The special case W=0 writes only at v.)
- Online-LOCAL(t): vertices arrive one by one; at each step the algorithm executes t synchronous LOCAL rounds on the subgraph induced by the arrived vertices; outputs are irrevocable; nodes may maintain arbitrary local state across steps unless otherwise restricted.
- Output-only Online-LOCAL(t): the only persistent state is the immutable output label after it is set; in any t-round window, messages and local computation at a node may depend on the graph and currently known outputs within distance ≤ t from that node, but not on any other mutable state.
- t-local-dependence (at v): upon v’s arrival, its output depends only on the induced arrived subgraph and previously fixed outputs within B(v,t).
- Output-only, W-write Online-LOCAL(t): as output-only above, but when v arrives the algorithm may irrevocably fix outputs on any vertices in B(v,W).

Lemma 1 (Power-graph coloring in O(k log* n))
Statement. Let G be a bounded-degree graph and k ≥ 1 a constant. There is a deterministic LOCAL algorithm that computes a proper vertex coloring of the power graph G^k with at most C = Δ^{O(k)} colors in O(k log* n) rounds on G.
Proof. Standard: simulate an O(log* n)-round O(Δ(G^k)^2)-coloring on G^k by k rounds per step on G; Δ(G^k) ≤ Δ^k, hence C = Δ^{O(k)}. □

Lemma 2 (Color-phased simulation for W=0)
Statement. Let S be an order-robust sequential rule with read radius r that writes only at the current node (W=0). Given a proper coloring of G^r, processing colors 1,…,C in order reproduces S for any order respecting the color layering, using O(r) rounds per color.
Proof. If φ(u)=φ(v) then dist(u,v)>r, hence the decisions in phase i depend only on outputs from earlier colors and do not interfere. Each node gathers outputs in B(·,r) from earlier colors in O(r) rounds and applies S. □

Theorem A (Sequential-local (W=0) ⇒ LOCAL)
Statement. If Π admits an order-robust r-local sequential algorithm (W=0), then Π has a deterministic LOCAL algorithm running in O(r log* n + Δ^{O(r)}·r) rounds. For constant Δ,r: O(log* n).
Proof. Compute a G^r-coloring in O(r log* n) rounds (Lemma 1), then simulate by Lemma 2. □

Lemma 3 (Output-only Online-LOCAL(t), W=0 ⇒ sequential with read radius 2t)
Statement. If Π has a deterministic output-only Online-LOCAL(t) algorithm correct for every arrival order, then Π admits an order-robust sequential algorithm with read radius 2t (W=0) that reproduces the online outputs for any order.
Proof. Fix order σ. When v_i arrives online under σ, only nodes in B(v_i,t) can send messages that reach v_i within t rounds. Under output-only, any such message depends only on outputs within the sender’s B(·,t), all contained in B(v_i,2t). Hence v_i’s t-window transcript and output are functions of the restriction to B(v_i,2t) of the arrived subgraph and outputs. Define the sequential rule to read those and return the same output as the online algorithm would under σ. Correctness and order-robustness follow. □

Lemma 4 (Bridge under t-local-dependence, W=0)
Statement. If Π has a deterministic Online-LOCAL(t) algorithm with t-local-dependence (at every v) that is correct for every arrival order, then Π admits an order-robust sequential algorithm with read radius t (W=0).
Proof. As in Lemma 3, but with t in place of 2t by hypothesis. □

Corollary A (Bounded-degree trees, constant r or t)
Statement. On bounded-degree trees, if Π has either (i) an order-robust r-local sequential algorithm (W=0) with constant r, or (ii) an output-only Online-LOCAL(t) algorithm (W=0) with constant t, or (iii) an Online-LOCAL(t) algorithm with t-local-dependence and constant t, then Π has a deterministic LOCAL algorithm with round complexity O(log* n).
Proof. Combine Theorem A with Lemma 3 or Lemma 4 as applicable; Δ and radii are constants. □

Lemma 5 (Color-phased simulation with bounded writes)
Statement. Let S be an order-robust sequential rule with read radius R and write radius W ≥ 0 (S may write outputs on currently-unset vertices in B(v,W)). Let φ be a proper coloring of G^{K} with K = max(2W, R+W). Then processing colors 1,…,C in order reproduces S for any order that respects the color layering. The per-color communication cost is O(R) rounds after φ is known.
Proof. If φ(u)=φ(v) then dist(u,v) > K ≥ 2W and > R+W. Thus (i) B(u,W) ∩ B(v,W) = ∅ (no write–write conflicts) and (ii) B(u,R) ∩ B(v,W) = ∅ and B(v,R) ∩ B(u,W) = ∅ (no read–write interference). In phase i, each vertex v with φ(v)=i gathers outputs written by earlier colors within B(v,R) and computes its writes; because of (i)–(ii), these writes are independent across same-color vertices and depend only on earlier colors, so the result matches S for any order that lists all lower colors first and then the current color in any internal order. O(R) rounds suffice to gather B(v,R) information. Computing φ takes O(K log* n) rounds by Lemma 1 with k=K. □

Lemma 6 (Output-only, W-write Online-LOCAL(t) ⇒ sequential with (R,W)=(2t+W,W))
Statement. If Π has a deterministic output-only, W-write Online-LOCAL(t) algorithm A correct for every arrival order, then Π admits a deterministic order-robust sequential rule S that, when processing v, reads only B(v, 2t+W), may write on currently-unset vertices in B(v,W), and reproduces A’s outputs for any order.
Proof. Fix order σ = (v_1,…,v_n). Consider A under arrival order σ. When v_i arrives, during its t-round window only nodes within distance ≤ t of the patch B(v_i,W) can send messages that reach the patch; hence all influencing senders lie in N := B(B(v_i,W), t) = B(v_i, W+t). Under output-only, messages sent by any u ∈ N depend only on outputs within B(u,t). Therefore the union of outputs that can affect the patch’s decisions lies in M := ⋃_{u∈N} B(u,t) = B(v_i, W+2t). Consequently, the t-round transcript determining the patch outputs in the σ-run is a function of the restriction of the arrived subgraph and already-fixed outputs to B(v_i, 2t+W). Define S as follows: when processing v_i under σ, S collects the already-fixed outputs within B(v_i, 2t+W) ∩ {v_1,…,v_{i-1}} and deterministically reproduces A’s t-window decisions on the patch given that local view, writing only to vertices in B(v_i,W) whose outputs are not yet fixed. Because A is deterministic and respects irrevocability, this reproduces exactly the same patch outputs as A under σ and never overwrites. As A is correct for every order, S is an order-robust (R,W)-local rule with R=2t+W. □

Corollary B (Bounded-degree trees, output-only W-write ⇒ O(log* n) LOCAL)
Statement. On bounded-degree trees, if Π has a deterministic output-only, W-write Online-LOCAL(t) algorithm with constants t,W, then Π has a deterministic LOCAL algorithm with round complexity O(log* n).
Proof. Apply Lemma 6 to obtain a sequential (R,W)-rule with R=2t+W. Then use Lemma 5 with K = max(2W, R+W) = max(2W, 2t+2W) = 2t+2W to simulate S in the LOCAL model: compute a proper coloring of G^{2t+2W} in O((2t+2W) log* n) rounds, then spend O(R)=O(2t+W) rounds per color. For constant Δ,t,W the total is O(log* n). □

Lemma 7 (2t-commutativity of independent consecutive arrivals)
Statement. Let A be any deterministic Online-LOCAL(t) algorithm (unrestricted mutable state). Consider an arrival sequence σ and two consecutive arrival steps at vertices u and w such that dist(u,w) > 2t. Let σ′ be obtained by swapping these two steps. Then, after these two steps, the states and fixed outputs at all vertices are identical under σ and under σ′.
Proof. Let G_i be the arrived subgraph just before these two steps. In the step when u arrives under σ, A executes t synchronous rounds on G_i ∪ {u}. Messages can traverse at most t hops per window, so only nodes in B(u,t) can be influenced (either by receiving messages or by depending on received messages); nodes outside B(u,t) undergo the same deterministic state updates as they would in any window where they receive the same (empty) messages. Likewise, w’s step affects only B(w,t). Because dist(u,w) > 2t, the balls B(u,t) and B(w,t) are disjoint, and w is absent during u’s step and u is absent during w’s step in both σ and σ′. Therefore the t-round transcripts and resulting updates within B(u,t) (resp. B(w,t)) are identical in σ and σ′, and all other vertices experience no message-dependent changes in either order. Thus the combined effect of the two steps commutes. □

Corollary 7.1 (Pushing far-away arrivals past v)
Statement. Fix v and any arrival sequence. By repeatedly swapping consecutive independent steps via Lemma 7, one can transform the sequence into another in which all vertices at distance > 2t from v arrive after v, without changing any states or outputs within B(v,t) at the time v arrives (or thereafter).
Proof. Iteratively swap any arrival at distance > 2t from v forward past earlier arrivals until it occurs after v; Lemma 7 ensures the swaps preserve the relevant states/outputs. □

Remark. Lemma 5 supersedes the earlier, flawed variant that required only a G^{R+W}-coloring; the counterexample R=0, W=1 on a 3-path shows that G^{R+W} is insufficient because write–write conflicts may occur.
Remark (No faithful t-per-color batching for unrestricted Online-LOCAL(t)). There exists a deterministic Online-LOCAL(1) algorithm A and a valid color-by-color arrival order σ_φ (induced by a proper coloring φ of G^2 on a path) such that any LOCAL simulation that processes all vertices of the same color class simultaneously in O(1) rounds cannot reproduce the exact outputs produced by A under the sequential σ_φ-run.
Proof. Consider the trivial LCL Π that accepts any labeling. Algorithm A maintains at each arrived node a parity bit p (initially 0) that toggles at every arrival step (regardless of messages). When a new vertex v arrives, in its 1-round window it reads p from an already-arrived neighbor if one exists and outputs that bit (if v has no arrived neighbor, it outputs 0). Fix any proper 3-coloring φ of the path’s G^2 and let σ_φ process colors 1,2,3 in order, with any internal order inside a color. In the sequential σ_φ-run, the parity p toggles at every arrival, hence the outputs of the vertices of any color class alternate with the internal order. In contrast, if one processes all vertices of a color class simultaneously in a single 1-round batch (keeping not-yet-processed colors absent), all these vertices observe the same parity p from earlier colors and therefore all output the same bit. Thus the batched simulation does not reproduce A’s outputs under σ_φ. □

Remark (Complexity accounting for Lemma 5/Corollary B). On bounded-degree graphs with constants t,W, the coloring step on G^{K} (K = max(2W, R+W), with R = 2t+W in Corollary B) costs O(K·log* n) rounds and yields C = Δ^{O(K)} colors; the per-color work is O(R). Hence the total complexity is O(log* n), dominated by the coloring step.
Definition (Quiescent Online-LOCAL(t) and (W,t)-quiescent)
Consider the standard LOCAL timing in an arrival step: in each of t synchronous rounds, each arrived node first sends messages as a (deterministic) function of its current state, then receives messages from neighbors, and finally updates its state as a (deterministic) function of its current state and the received messages.
- An Online-LOCAL(t) algorithm A is quiescent if, upon the arrival of v, during the ensuing t rounds every node u with dist(u,v) > t does not change its state in any of these t rounds.
- More generally, A is (W,t)-quiescent if, upon the arrival of v, during the ensuing t rounds only nodes in the active region B(v, W+t) may change their state; nodes outside B(v,W+t) do not change state.

Lemma 8 (Quiescent Online-LOCAL(t) ⇒ O(log* n) LOCAL; bounded-writes variant)
Let Π be an LCL on bounded-degree graphs. Suppose Π has a deterministic quiescent Online-LOCAL(t) algorithm A with constant t.
(i) Then Π admits a deterministic LOCAL algorithm with round complexity O((2t+1)·log* n + t·Δ^{O(t)}) = O(log* n).
(ii) More generally, if A is (W,t)-quiescent with constants W,t, then Π admits a deterministic LOCAL algorithm with round complexity O((2t+2W+1)·log* n + t·Δ^{O(t+W)}) = O(log* n).

Proof.
Fix K := 2t+1 in case (i), and K := 2t+2W+1 in case (ii). By Lemma 1, compute a proper coloring φ of G^{K} with C = Δ^{O(K)} colors in O(K·log* n) rounds. We process the colors in increasing order i = 1,2,…,C in phases; at the start of phase i, exactly the vertices of colors < i are considered “already arrived,” and vertices of colors ≥ i are “not yet arrived.”

In phase i we simulate, in parallel, the t-round online arrival window of every vertex v with φ(v)=i, on the subgraph induced by vertices of colors ≤ i, as follows: (a) we declare all vertices of color i to “arrive” at the beginning of the phase, and (b) we perform t synchronous LOCAL rounds on that induced subgraph. During this phase, the algorithm A is executed faithfully at every vertex, except that vertices of colors > i are absent.

Let R_v denote the active region of v during this phase: R_v = B(v,t) in case (i) and R_v = B(v, W+t) in case (ii). Because φ colors G^{K} with K as above, for any two distinct same-color vertices v,w we have dist(v,w) ≥ K+1, hence dist(R_v, R_w) ≥ 2. In particular, there is no edge between R_v and R_w.

Quiescence and the LOCAL timing imply two key facts within phase i:
1) Only nodes in R := ⋃_{φ(v)=i} R_v may change state during the t rounds of phase i; all nodes outside R keep their state fixed throughout the phase. Since messages sent in a round depend only on the sender’s current state at the start of that round, such outside nodes cannot forward newly received information in subsequent rounds. Consequently, there is no causal influence along any path that leaves one R_v and re-enters another R_w within the t rounds, because such a path must traverse at least one node outside R which cannot propagate new information.
2) Since dist(R_v, R_w) ≥ 2, there is neither an edge nor a length-1 path between distinct active regions.

From 1)–2) it follows that, during phase i, the evolution of each R_v is identical to what would occur if we executed only v’s t-round window in isolation (with all other color-i vertices absent), given the same boundary states on the external neighborhood of R_v (which are precisely the states fixed by earlier colors). Formally, this can be proved by induction on the round counter r=1,…,t, using the domain-of-dependence that is confined to R_v together with outside nodes whose states remain constant.

Therefore, the combined effect of phase i equals the composition of the individual “v-arrival” windows over all vertices v with φ(v)=i, in any internal order. By induction on i, after finishing phase i the global state/output coincides with the online execution that processes first all color-1 vertices (in an arbitrary order), then all color-2 vertices, and so on. Since A is correct for every arrival order, the final labeling after phase C is legal for Π.

The complexity is O(K·log* n) to obtain φ and t rounds per color, i.e., O(t·C) additional rounds. For constant Δ, t, W, we have C = Δ^{O(K)} = O(1), so the total is O(log* n). □

Remark (on the choice of K). The choice K = 2t (resp. 2t+2W) is insufficient for the parallel phase: if dist(v,w)=2t+1 (resp. 2t+2W+1), then R_v and R_w are disjoint but may be adjacent by an edge, allowing one-round coupling between the two active regions. The value K = 2t+1 (resp. 2t+2W+1) guarantees dist(R_v, R_w) ≥ 2, which prevents such coupling and makes the above proof sound.

Remark after Lemma 7 (idle updates depending on step index). In Lemma 7, nodes outside B(u,t) ∪ B(w,t) may perform deterministic updates that depend on the global step counter but not on messages. When two consecutive arrivals at u and w with dist(u,w) > 2t are swapped, those nodes still undergo the same two consecutive step indices in the same order, so their pair of updates is unchanged. This clarifies that Lemma 7 tolerates such idle updates.
Lemma 9 (Strong witness-localization at a vertex)
Statement. Let A be any deterministic Online-LOCAL(t) algorithm on a bounded-degree graph G, let σ be any arrival sequence, and let v be any vertex. There exists an arrival sequence σ_v obtained from σ by repeatedly swapping adjacent arrivals such that:
(i) Every vertex that arrives before v in σ_v lies in B(v,2t).
(ii) The arrived subgraph just before v arrives in σ_v equals the restriction to B(v,2t) of the arrived subgraph just before v arrives in σ (i.e., the set of predecessors of v inside B(v,2t) is unchanged).
(iii) The entire state and the fixed outputs on B(v,t) at the moment v arrives are identical under σ and under σ_v.

Proof. Starting from σ, repeatedly swap v with its immediate predecessor u whenever dist(u,v) > 2t. Each such swap is between two consecutive arrivals u and v whose t-neighborhoods are disjoint; by Lemma 7 (2t-commutativity), the global state after these two steps is identical independent of their order. After no more such swaps are possible, every predecessor of v has distance ≤ 2t from v, proving (i). During this process, we swap v only with vertices at distance > 2t, so the set of predecessors of v within B(v,2t) is unchanged, and therefore the arrived subgraph in B(v,2t) just before v is the same as in σ; this is (ii). Property (iii) follows because each swap preserves the state on B(v,t) (by Lemma 7), and hence the state on B(v,t) at the time v arrives is invariant under the sequence of swaps. □

Claim 8.1 (Phase-locality under (W,t)-quiescence; to be used within Lemma 8).
Fix a proper coloring φ of G^{K} with K = 2t+2W+1 and consider phase i of the simulation in Lemma 8, where all vertices v with φ(v)=i “arrive” simultaneously and we run t synchronous LOCAL rounds on the subgraph induced by colors ≤ i. For each such v, let R_v = B(v, W+t). Then, during phase i:
(a) Only nodes in R := ⋃_{φ(v)=i} R_v may change state; nodes outside R keep their state fixed throughout the phase.
(b) For each v, the t-round transcript (states and messages) on R_v depends only on A and on the initial states on R_v together with the states on the external neighborhood ∂R_v at the start of the phase (i.e., after phase i−1), and is identical to the transcript obtained by executing only v’s t-round window in isolation with those boundary states.
(c) The combined effect of the phase equals the composition, in any order, of the individual arrival windows of the vertices with φ(v)=i.

Proof. Because φ is a proper coloring of G^{K} with K = 2t+2W+1, any distinct same-color vertices v,w satisfy dist(v,w) ≥ K+1, hence dist(R_v,R_w) ≥ (K+1) − 2(W+t) = 2; in particular, there is no edge between R_v and R_w. By (W,t)-quiescence, during the t rounds of the phase only nodes within distance ≤ t of B(v,W) for some v with φ(v)=i may change state; the union of these sets is precisely R, proving (a). Under the standard LOCAL timing (in each round: send based only on the current state; then receive; then update), a node whose state does not change in a given round cannot make its outgoing messages depend on newly received information in later rounds unless its state changes; thus nodes outside R cannot relay any information originating in one active region to another during the phase. An induction on the round counter r=1,…,t shows that the state/message evolution on each R_v is identical to the evolution when executing only v’s t-round window with the same boundary states (states on ∂R_v are fixed by (a)), establishing (b). Since there is no causal influence between distinct active regions within the phase and no edge between them, the per-region effects commute, yielding (c). □

Remark (Why no +1 in Corollary B but +1 in Lemma 8). In Corollary B we first derive a sequential (R,W)-rule with R = 2t+W from the output-only online algorithm, and then simulate this sequential rule using a proper coloring of G^{K} with K = max(2W, R+W). This simulation does not execute concurrent online t-windows; independence is guaranteed by avoiding read–write and write–write conflicts for the sequential rule, and no extra +1 is needed. In contrast, Lemma 8 batches online t-windows of the same color in parallel; to prevent even a single cross-edge between distinct active regions during the t rounds, we require dist(R_v,R_w) ≥ 2, which is ensured by K = 2t+2W+1 (the +1 is necessary).
