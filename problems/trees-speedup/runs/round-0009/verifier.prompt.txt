--- SYSTEM ---
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (summary so far)
- output.md (rigorously proven results so far)

Guidelines:
- notes.md: should be a readable running log of interesting work. Prefer appending. Replace only if old notes are clearly misleading. Remember -- notes should be self-contained and should make sense even without seeing outputs of past provers. 
- output.md:  Think twice before you add something to this file. Everything here should be rigorous, almost publication-ready. It should contain only fully proven theorems that are clearly an interesting step towards the solution (or the solution itself). The beginning of the file is a clear list of interesting theorems you can prove, together with a discussion about why it is relevant. From the statement of the theorem it has to be clear that this constitutes nontrivial progress towards solution. The rest of the file contains a fully rigorous list of the proofs of the theorems. Keep only proven theorems with clear proofs. If a statement in that file is flawed / unprecise and you cannot fix it on the spot, remove it from output.md and instead add it to notes.md with explanation.
- Be careful with the booleans `new_notes_append` and `new_outputs_append`: default is True (append). Use False only when deliberately rewriting everything.

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (≥200 words). Include concrete next-step suggestions. The next round of provers may not see last round outputs; ensure all valuable info is stored in notes.",
  "new_notes_md": "Markdown (KaTeX allowed). Usually appended to notes.",
  "new_notes_append": "True|False",
  "new_outputs_md": "Markdown (KaTeX allowed). Usually appended to output.md.",
  "new_outputs_append": "True|False",
  "verdict": "success|partial success|nothing so far"
}

**Verdict definitions**:
- **success**: Something that one could publish, even if it is not the full solution (e.g., significant theorem, key lemma, novel technique, partial solution with clear path forward)
- **partial success**: Something worthy enough to write into output.md (e.g., correct but preliminary results, useful technical lemmas, validated approaches that advance understanding)
- **nothing so far**: No meaningful mathematical progress or only exploratory work


--- USER ---
You receive multiple prover reports. Evaluate correctness, value, and pick promising directions. Update notes.md (append/replace) with useful ideas and update output.md (append/replace) ONLY with rigorously verified results.

Prover reports (JSON):
[{"prover_id": "01", "progress_md": "Status and alignment\n- Objective: Prove that any LCL that is solvable in O(1) rounds in the deterministic Online-LOCAL(t) model on bounded-degree (nonoriented) trees admits an O(log* n) deterministic LOCAL algorithm.\n- Archive status: output.md now includes the core positive bridges (sequential simulation; output-only and (W,t)-quiescent pipelines with correct radii and the +1 separation), the commutativity lemma (2t-commutativity), strong vertex-level witness localization (Lemma 9), the \u201cno faithful batching\u201d counterexample for unrestricted Online-LOCAL, and Lemma S (adversarial schedule-localization for an edge). These are consistent and useful.\n- Verifier guidance: The edge-centered universal step S_e based solely on B(e,2t) has a compositionality flaw at nodes; repair by shifting to node-centered admissible sets on U_w := \u22c3_{e\u220bw} B(e,2t), then derive edge-sets from node-sets. Replace intersection-over-orders by union-over-orders. Supply an explicit t=2 example showing the +1 necessity in Lemma 8.\n\nNew contributions this round\n1) Node-centered admissible sets on U_w (finite-type, \u201cno-sink-in-sets\u201d preserved)\n- Setup and notation.\n  \u2022 Model: deterministic Online-LOCAL(t), edge-decided semantics for orientations (an edge is irrevocably oriented when its second endpoint arrives). Graphs are bounded-degree trees with ID-graph framework (port colors, high-girth ID graph H) as in Def. 2.16.\n  \u2022 For a node w, define the localized universe\n    U_w := \u22c3_{e=wx incident to w} B(e, 2t) \u2286 B(w, 2t+1).\n    Let X_w denote the rooted, port-colored, ID-labeled isomorphism type of U_w (root at w); since \u0394,t are constants and H induces finitely many depth-(2t+1) types, the catalogue of X_w is finite.\n  \u2022 Let Ord_w(X_w) be the set of all internal arrival orders \u03c4 of the vertices of U_w that (i) include both endpoints of every edge incident to w by the time \u03c4 ends (so all these edges become decidable), and (ii) list no vertex outside U_w before \u03c4 ends (outside-U_w absent). By Lemma S, each \u03c4 \u2208 Ord_w(X_w) is realized by some global arrival order; conversely, correctness must hold for all \u03c4.\n  \u2022 For \u03c4 \u2208 Ord_w(X_w), write out_A(wx, \u03c4) \u2208 {w\u2192x, x\u2192w} for the orientation that A assigns to edge e=wx at its decision time under \u03c4 (well-defined by edge-decided semantics).\n\n- Definition (node-centered admissible ports).\n  For each node type X_w, define the admissible port set\n  T_w(X_w) := { x \u2208 N(w) : \u2203 \u03c4 \u2208 Ord_w(X_w) with out_A(wx, \u03c4) = w\u2192x }.\n\n- Lemma T (well-definedness and nonemptiness of T_w; \u201cno-sink-in-sets\u201d).\n  Statement. For sinkless orientation on bounded-degree trees under edge-decided semantics:\n  (i) For every node type X_w, T_w(X_w) is well-defined (depends only on X_w) and T_w(X_w) \u2286 N(w).\n  (ii) T_w(X_w) \u2260 \u2205 for all X_w (node-side \u201cno-sink-in-sets\u201d).\n  Proof. (i) The outcomes out_A(wx, \u03c4) for \u03c4 \u2208 Ord_w(X_w) depend only on the execution restricted to U_w with the outside absent, hence only on X_w and \u03c4; thus T_w(X_w) is well-defined. Type finiteness follows from the ID-graph framework and the constant radius 2t+1.\n  (ii) Suppose T_w(X_w) = \u2205 for some X_w. Then for every \u03c4 \u2208 Ord_w(X_w) and every neighbor x, out_A(wx, \u03c4) = x\u2192w, implying that once all edges incident to w are decidable in the \u03c4-run, w has no outgoing edge\u2014w is a sink. As \u03c4 is a valid adversarial schedule with the outside absent (Lemma S), this contradicts correctness. Hence T_w(X_w) \u2260 \u2205. \u25a1\n\n- Why useful here. This node-level construction fixes the compositionality issue flagged by the verifier: all adversarial variability is quantified within U_w (a constant-radius ball), and the \u201cno-sink-in-sets\u201d property holds locally and unconditionally at w. The set semantics use union-over-orders (existential quantification) per port, ensuring nonemptiness at nodes.\n\n2) Deriving edge-centered admissible sets from node-sets (safe composition at nodes)\n- Given T at nodes, define per-edge sets without boundary-freezing:\n  For an edge e=wx, let\n    S_e := { w\u2192x : x \u2208 T_w(X_w) } \u222a { x\u2192w : w \u2208 T_x(X_x) }.\n  Observations:\n  \u2022 S_e depends only on the pair of node types (X_w, X_x); hence S_e is a function of the labeled type of B(e, 2t+1) (the union of B(w, 2t+1) and B(x, 2t+1) overlaps in B(e, 2t)). The catalogue of such edge types is finite.\n  \u2022 Node-side constraint preserved: For any w, by Lemma T there exists x \u2208 T_w(X_w), and hence w\u2192x \u2208 S_{wx}. Thus, for every node w, at least one incident edge set S_e contains an outward orientation for w (no-sink-in-sets at nodes persists via S).\n  \u2022 We do not assert nonemptiness of S_e for every individual edge; this is not needed to preserve the node-side constraint, which is the relevant one for sinkless orientation. (If desired, one can separately argue nonemptiness for an appropriate fraction of edges, but this is not required for the next steps.)\n\n- Why this composition is robust. It uses only node-side admissible information T_w on U_w and T_x on U_x, avoiding any reliance on edge-local schedules that would later be embedded in larger unions (the source of the prior flaw). All dependencies remain confined to constant-radius node types.\n\n3) Radii and finiteness (explicit accounting)\n- Node step: U_w \u2286 B(w, 2t+1); types X_w form a finite set determined by \u0394, t, and the ID-graph H. T_w(X_w) maps each X_w to a nonempty subset of incident port colors of w.\n- Edge step: S_e depends on X_w and X_x; hence S_e depends only on the labeled type of B(e, 2t+1) (finite catalogue).\n- Summary: All admissible-set assignments live over finite type spaces, with explicit constant radii (2t+1 around nodes; 2t+1 around edges).\n\n4) A clean invariant package (to be maintained in further steps)\n- I1 (Type finiteness). The domain of node types X_w (radius 2t+1) and edge types X_e (radius 2t+1) is finite.\n- I2 (Locality). T_w(X_w) and S_e(X_e) depend only on their respective local types.\n- I3 (Node-side no-sink-in-sets). For all node types X_w, T_w(X_w) \u2260 \u2205. Consequently, for all w there exists an incident e with w\u2192\u2022 \u2208 S_e.\n- I4 (Adversarial soundness). T_w(X_w) is defined by existential quantification over all internal orders \u03c4 \u2208 Ord_w(X_w) with outside absent (Lemma S), hence is consistent with correctness for every adversarial arrival order.\n\nThese invariants are precisely the safe replacements for the flawed edge-local universal construction on B(e,2t).\n\n5) Explicit t=2, W=0 path example witnessing the +1 necessity in Lemma 8\n- Instance: Path \u2026 \u2013 p2 \u2013 p1 \u2013 a \u2013 u \u2013 x \u2013 y \u2013 v \u2013 b \u2013 q1 \u2013 q2 \u2013 \u2026 with centers a, b at distance 5. For t=2, the active regions are R_a = B(a,2) = {a, u, x} and R_b = B(b,2) = {b, v, y}. These regions are disjoint but adjacent by the cross-edge x\u2013y (dist(R_a, R_b) = 1). A proper coloring of G^{2t} = G^4 can assign a and b the same color; thus with K=2t the phase may process both regions simultaneously.\n- Quiescent Online-LOCAL(2) algorithm A (W=0): In a phase when all same-color centers \u201carrive,\u201d A runs two synchronous rounds on the induced subgraph of colors \u2264 current, with these rules:\n  \u2022 Round 1: Each boundary node (distance exactly 2 from its center) sends the bit 1 to all neighbors; in particular, x sends 1 to y and y sends 1 to x across the cross-edge. Internal nodes and centers send 0.\n  \u2022 Round 2: Each boundary node forwards to its center the bit it received in Round 1 from the cross-edge neighbor (if any); internal nodes forward towards the center; the center outputs that bit (default 0 if nothing received).\n  \u2022 Quiescence: Only nodes within R := R_a \u222a R_b may change state (W=0); nodes outside R neither change state nor forward information, satisfying the (W,t)-quiescent definition.\n- Effect: In this single phase with K=2t, the output of a depends on y (in R_b) via the 2-hop route y\u2192x\u2192u\u2192a within the two rounds; symmetrically, the output of b depends on x. Hence the transcript in R_a depends on the concurrent activity in R_b, violating the per-region independence that Lemma 8\u2019s proof requires. With K=2t+1, we would have dist(R_a, R_b) \u2265 2 and no cross-edge x\u2013y; the above coupling is impossible, and Claim 8.1\u2019s argument applies. This exhibits the necessity of the \u201c+1\u201d.\n\nAudit of output.md (gaps and suggested insertions)\n- The newly archived Lemma S is correct and well-placed.\n- Missing lower-bound pieces:\n  \u2022 A node-centered \u201cuniversal sets\u201d lemma (Lemma T above) on U_w, with explicit definitions, radius 2t+1, type finiteness, and proof of nonemptiness. This directly addresses the compositionality flaw noted by the verifier for edge-based sets on B(e,2t).\n  \u2022 A safe Node\u2192Edge composition producing S_e from T_w and T_x, together with the preserved node-side \u201cno-sink-in-sets\u201d invariant. This should replace any previous edge-centered set step based on B(e,2t).\n  \u2022 The explicit t=2 path example witnessing the +1 necessity for Lemma 8 (Quiescent batching), as a short proposition/remark after Lemma 8.\n- Open items (not yet in output.md): The symmetric Edge\u2192Node half-step with precise radius evolution and preservation of invariants; the iteration to 0 rounds and the ID-graph contradiction. These remain to be formalized using the adversarial, local-first framework.\n\nWhy this is progress\n- The node-centered admissible set construction T_w(X_w) provides a rigorous and local (finite-type) foundation for a set-valued round-elimination scheme on trees, addressing the verifier\u2019s compositionality concern head-on.\n- The Node\u2192Edge composition yields per-edge sets that preserve the critical node-side \u201cno-sink-in-sets\u201d invariant without relying on any unsafe boundary-freezing assumptions.\n- An explicit, fully specified quiescent W=0, t=2 path example demonstrates the necessity of the +1 in Lemma 8, turning an intuitive remark into a verifiable witness.\n\nObstacles and open questions\n- Edge\u2192Node half-step with radius control: A clean transformation that (ideally) decreases the radius by 1/2 per half-step remains to be designed under the adversarial, local-first semantics, while preserving the invariants I1\u2013I4. A naive T\u2032_w := { x : w\u2192x \u2208 S_{wx} } composes but increases the radius; the universal-quantifier variant may help shrink sets/radius but needs care.\n- Iteration to 0 rounds and ID-graph contradiction: After formalizing the symmetric half-step, we must show that after O(t) alternations we obtain a 0-round set-valued prescription over the ID-graph H that violates the independence constraint (as in Theorem 2.15). This will likely follow the classical scheme once the half-steps are validated.\n- Output-only variant: Redo the lower bound in the simpler output-only model with node-level sets on U_w and union-over-orders admissibility. This is lower risk and should be integrated first.\n\nNext steps (auditable)\n1) Add Lemma T (node-centered admissible ports on U_w) to output.md, with explicit definitions, the proof of nonemptiness, and the finite-type argument via the ID-graph.\n2) Add the Node\u2192Edge composition (from T_w and T_x to S_e) and record the preserved node-side \u201cno-sink-in-sets\u201d property and radii (edge type depends on B(e,2t+1)).\n3) Formalize the symmetric Edge\u2192Node half-step in the same adversarial, local-first framework, aiming for a (t \u2192 t\u22121/2) style radius change or, at minimum, an inductive invariant that enables iteration to a 0-round contradiction.\n4) Integrate the explicit t=2 path example as a short proposition justifying the +1 necessity in Lemma 8.\n5) In parallel, implement the output-only lower bound using node-level sets on U_w (union-over-orders) and state the iteration outline to a 0-round contradiction over H.\n\nAppendix: crisp statements to integrate\n- Lemma T (Node-level admissible ports on U_w): as above.\n- Corollary (Preserved node-side no-sink-in-sets under Node\u2192Edge): For every node w, there exists an incident edge e with w\u2192\u2022 \u2208 S_e.\n- Proposition (+1 necessity for t=2, W=0): The explicit path construction above.\n"}, {"prover_id": "02", "progress_md": "Status and focus\n- Objective: Prove the speedup on bounded-degree (nonoriented) trees: any LCL solvable in O(1) rounds in deterministic Online-LOCAL(t) admits an O(log* n) deterministic LOCAL algorithm.\n- Current archive: Positive bridges are solid (order-robust sequential\u21d2LOCAL; output-only and (W,t)-quiescent bridges with correct radii; Lemma 7 and Lemma 9 for 2t-commutativity/witness localization; Lemma 8 for quiescent batching with K=2t+2W+1). Lower-bound route is partially scaffolded: output.md now contains Lemma S (edge-local adversarial scheduling) but not the elimination steps.\n\nNew clean ingredients (node-centric admissible sets and node-local scheduling)\n- Lemma S_node (Schedule-localization around a node). Let A be any deterministic Online-LOCAL(t) algorithm on a bounded-degree tree G and w any vertex. There exists an arrival schedule \u03c3(w) such that: (i) all vertices of B(w,2t+1) arrive before any vertex outside B(w,2t+1); (ii) all edges incident to w become decidable within this prefix (in edge-decided semantics: by the time both endpoints of each incident edge have arrived); (iii) the entire execution up to the time when all edges incident to w are decided depends only on the labeled type of B(w,2t+1) (graph structure, port colors, IDs) and the internal arrival order within B(w,2t+1); vertices outside are absent and irrelevant up to that time.\n  Why true: This is the node-analogue of Lemma S. List all vertices in B(w,2t+1) first (in any order ending with the last endpoints of incident edges), then list the rest. During the prefix, all signal paths that can influence the decisions on edges incident to w have length \u2264 t within the active regions attached to those edges; the farthest relevant sources lie within distance \u2264 2t+1 from w (union over incident edges), so the outside can be kept absent without loss. This avoids any converse normalization and relies only on adversarial scheduling.\n\n- Definition (U_w and node-type). For a node w and parameter t, define U_w := \u22c3_{e\u220bw} B(e,2t). On a tree, U_w \u2286 B(w,2t+1). Let X_w denote the isomorphism type (structure, port colors, and ID-graph labels) of U_w, taken up to rooted-isomorphism at w.\n\n- Lemma T (Node-centered admissible outward ports). Consider sinkless orientation under edge-decided semantics and a deterministic Online-LOCAL(t) algorithm A on \u0394-bounded trees with the ID-graph framework. For each node w and its type X_w, define T_w(X_w) \u2286 Ports(w) as follows: p \u2208 T_w(X_w) iff there exists an internal arrival order \u03c4 on U_w (with the outside absent) under which A orients the incident edge in direction \u201cout of w along port p,\u201d when all incident edges of w are decided. Then:\n  (a) Well-defined dependence and finiteness: T_w depends only on X_w. The family of possible X_w is finite for fixed \u0394,t via the ID-graph framework.\n  (b) Nonemptiness (node-side \u201cno-sink-in-sets\u201d): For every X_w, T_w(X_w) \u2260 \u2205.\n  Justification: (a) follows from Lemma S_node (the adversary can fix all arrivals to lie inside U_w before any outside node, so the transcript and all incident-edge decisions depend only on the labeled type and internal order). (b) If T_w(X_w)=\u2205, then under every internal order on U_w with the outside absent, A would necessarily decide all incident edges into w, making w a sink\u2014contradicting correctness for some valid arrival order (the one confined to U_w).\n  Remarks: This node-level set construction avoids the compositionality flaw of per-edge sets on B(e,2t): it quantifies over the whole finite neighborhood U_w in which mutual interactions among the incident edges of w can occur before they are decided.\n\nTowards a safe elimination framework (outline acceptable for auditing)\n- Edge\u2192Node half-step (formalizable now). Starting from an Online-LOCAL(t) algorithm A (edge-based semantics), define the node-level set rule T_w on X_w as above. Invariants: (I1) T_w(X_w) is nonempty for all X_w; (I2) Type space is finite (bounded depth 2t+1 in the ID-graph); (I3) The rule depends only on the local type X_w (adversarial scheduling ensures outside is absent). This is the \u201cuniversal union over internal orders\u201d step at node level.\n- Node\u2192Edge half-step (to be completed next round, but scoped). Given node-level sets T_w on U_w, derive per-edge admissible orientation sets S_e on X_e (type of B(e,2t)) as follows: o \u2208 S_e(X_e) if there exists a joint type Z = U_u \u222a U_v (u,v are endpoints of e) and an internal order on Z (outside absent) such that the chosen outward ports at u and v belong to T_u(X_u) and T_v(X_v) respectively, and the resulting orientation of e is o while all incident edges at u and v are decided consistently. We will keep quantification local to Z (radius \u2264 2t+1 around e) and use adversarial scheduling as in Lemma S_node. We will prove: (J1) S_e(X_e) is nonempty; (J2) it depends only on X_e (finite); and (J3) the node-side nonemptiness of T_w is preserved in the next node step. This yields a (t\u22121/2)-step reduction and can be iterated. Details forthcoming.\n\nExplicit tightness example for the \u201c+1\u201d in Lemma 8 (quiescent, W=0, t=2)\n- Proposition (+1 necessity for quiescent batching). On a path, with W=0 and t=2, coloring G^{2t}=G^{4} is insufficient to ensure phase independence under Lemma 8; G^{2t+1}=G^{5} is necessary. Construction:\n  \u2022 Graph and centers: Take a path and choose two centers a,b at distance 2t+1=5. Their active regions are R_a = B(a,2) and R_b = B(b,2), which are disjoint but adjacent by a single cross-edge (x,y) with x \u2208 R_a at dist(a,x)=2 and y \u2208 R_b at dist(b,y)=2.\n  \u2022 Quiescent algorithm A (W=0, t=2): In the 2-round arrival window of color-i vertices, only nodes in the active regions change state; all others are quiescent. Round 1: every node in R := R_a \u222a R_b sends its initial bit b(v) (e.g., computed from ID(v) modulo 2) to all neighbors. Round 1 update: for each v \u2208 R, set s(v) = XOR of received bits. Round 2: each v \u2208 R sends s(v) to neighbors in R; outputs inside R can depend on s(\u00b7). Nodes outside R never change state (quiescent) and cannot forward.\n  \u2022 Coupling via the cross-edge: In round 1, y sends b(y) to x across the single cross-edge (x,y). Thus s(x) depends on b(y) at the end of round 1. In round 2, x propagates s(x) one hop inward within R_a; hence the transcript inside R_a (already at x and its neighbor) depends on b(y), a boundary variable in R_b. This violates the Claim 8.1 independence when K=2t (adjacent active regions). Coloring G^{2t+1} forbids any cross-edge (dist(R_a,R_b) \u2265 2), restoring independence as in Lemma 8.\n  \u2022 Conclusion: The +1 in K=2t+1 is necessary already for t=2 under standard LOCAL timing and quiescence; without it, one-round cross-edge signals couple the regions in the same phase.\n\nWhy these are progress\n- We remove the compositionality bug in the edge-centered sets by moving to node-centered admissible sets T_w on U_w = \u22c3 B(e,2t). This is the correct granularity for capturing all interactions among edges incident to a node before their decisions, and it is compatible with adversarial local-first scheduling (no boundary freezing).\n- We introduce Lemma S_node (node-local scheduling), the exact node analogue of the already archived Lemma S; it is needed to justify that T_w(X_w) depends only on the type X_w.\n- We provide a fully explicit, round-by-round, quiescent W=0, t=2 counterexample establishing the necessity of the +1 in K, ready to be archived as a proposition following Lemma 8.\n\nGaps and corrections suggested for output.md\n- Missing: Node-local adversarial scheduling lemma. Recommend adding Lemma S_node as stated above; its proof mirrors Lemma S by listing B(w,2t+1) first and deferring the outside.\n- Missing: Node-level admissible sets. Add Lemma T (node-centered admissible outward ports) with precise definitions: U_w, X_w, T_w(X_w); prove dependence on X_w and nonemptiness by adversarial schedules and correctness.\n- Lower-bound step caution: Do not add per-edge set S_e based solely on B(e,2t) with a \u201cno-sink-in-sets\u201d argument; as the verifier noted, that argument is non-compositional. Shift the set framework to the node level as above and only then define a safe node\u2192edge half-step over Z = U_u \u222a U_v (to be written next round).\n- +1 tightness: Promote the \u201c+1 is necessary\u201d remark after Lemma 8 to a formal proposition using the explicit t=2 construction above.\n\nObstacles and what remains\n- Formal node\u2192edge half-step: We must define S_e(X_e) using only local data from Z = U_u \u222a U_v (radius \u2264 2t+1), prove nonemptiness and the preservation of node-side invariants when alternating node and edge steps, and quantify exact radius changes (t \u2192 t\u22121/2). This is planned for the next round.\n- Final ID-graph contradiction: After 2t iterations we should obtain a 0-round edge-centered set rule S^{(0)} with nonempty per-edge sets determined by constant-radius types. We then replicate the classical ID-graph contradiction for sinkless orientation. Node-only sets are insufficient for a final contradiction; arriving at edge-level sets is required.\n\nNext steps (auditable)\n1) Archive Lemma S_node (schedule-localization around a node) and Lemma T (node-centered admissible ports) in output.md with full proofs and explicit type finiteness under the ID-graph framework.\n2) Formalize the node\u2192edge universal half-step using Z = U_u \u222a U_v, including: definition of S_e(X_e), proof of nonemptiness and type dependence, and the precise radius drop to 2t (edge-centered). State invariants for iteration.\n3) Add the explicit t=2, W=0, quiescent counterexample as a proposition after Lemma 8, establishing the necessity of K=2t+1.\n4) In a separate subsection, outline the full iteration (2t steps) and the 0-round contradiction via the ID-graph, to conclude the lower bound for sinkless orientation and hence the existential O(log* n) speedup for any O(1)-round Online-LOCAL LCL on trees by Theorem 2.33.\n\nWhy the plan yields the main theorem\n- The node/edge universal elimination (once completed) gives that sinkless orientation has no deterministic constant-t Online-LOCAL algorithm on trees. By the tree LCL classification (Theorem 2.33), any LCL solvable in O(1) Online-LOCAL on trees cannot be in the \u0398(log n) or \u0398(log log n)/\u0398(log n) classes; hence it belongs to the Op1q/\u0398(log* n) class, implying the existence of an O(log* n) deterministic LOCAL algorithm.\n"}]

Current notes.md:
Context and goal
We study the relationship between online-style constant-locality algorithms for LCLs on bounded-degree, unoriented trees and deterministic LOCAL-time upper bounds. Two notions of “online local” are relevant:
- Sequential local/greedy model (order-robust r-local): when processing a vertex v, the decision at v depends only on the r-hop neighborhood B(v,r) of the underlying graph and on already fixed outputs within B(v,r); the algorithm must succeed for every vertex order. No global mutable state or long-range message accumulation between steps.
- Online-LOCAL(t) (Akbari–Eslami–Lievonen–Melnyk–Särkijärvi–Suomela, ICALP’23): vertices arrive one by one; upon each arrival, the algorithm has t synchronous LOCAL rounds on the subgraph induced by arrived vertices; outputs are irrevocable. Over many arrivals, an unbounded number of communication rounds can occur, enabling long-range state accumulation.

Safe, proven variant (archived below in output.md)
- Theorem (Sequential-local to LOCAL): If an LCL Π on bounded-degree graphs has a deterministic order-robust r-local sequential algorithm (decisions at v depend only on B(v,r) and outputs of earlier vertices in B(v,r), and the rule writes only the output at v), then Π has a deterministic LOCAL algorithm running in O(r log* n + Δ^{O(r)}) rounds. On bounded-degree trees with constant r, this is O(log* n). Proof: compute a proper coloring of G^r in O(r log* n) rounds with Δ^{O(r)} colors; process color classes in order, letting each v gather outputs from B(v,r) restricted to earlier colors and apply the sequential rule. Because nodes of the same color are at distance > r, their decisions do not depend on each other.

Gap for the full Online-LOCAL(t) model
- A direct phase simulation that uses a distance-(2t) coloring and t rounds per color does not generally reproduce the state a node v would see upon arrival in an actual online execution. In a true online run, before v arrives, there may have been Θ(n) earlier arrivals, yielding Θ(n)·t global rounds; information can propagate arbitrarily far and may alter the states within B(v,t). The phase simulation grants only O(1)·t total rounds before v’s phase, so the local states can differ. Hence, without additional constraints, we cannot claim that the phase simulation faithfully reproduces the online run or even yields correctness solely from A’s correctness.

Ways forward for Online-LOCAL(t)
- Add a locality-of-dependence assumption: the t-round transcript that determines v’s output depends only on the arrived subgraph inside distance ≤ t from v and on the outputs of those nodes, not on mutable states imported from farther away. Under this, distance-(2t) coloring plus phase simulation is valid and yields O(log* n).
- Alternatively, seek a structural scheduling/padding argument ensuring that for LCLs on bounded-degree trees, the state within B(v,t) before v’s arrival is independent of far-away arrivals. This is nontrivial; try first on paths/trees with t=1 to see whether accumulation can matter for any LCL.
- Or try to separate the models: construct an LCL that is solvable in constant t in Online-LOCAL but provably not simulable by the above constant-phase compression; if such an LCL exists, the general reduction fails, and the sequential-local variant becomes the correct target.

Remarks
- No global edge orientation is needed anywhere in the reduction we proved; IDs suffice for coloring.
- The archived proof applies to all bounded-degree graphs; we stated trees to match the project focus.
Refinements on bridging Online-LOCAL(t) to sequential local rules
- Definitions (recap and refinement):
  • Online-LOCAL(t): vertices arrive one by one; upon each arrival we have t synchronous LOCAL rounds on the subgraph induced by arrived vertices; outputs are irrevocably set at arrival; in the general model, nodes may maintain unbounded mutable state across arrival windows.
  • Output-only Online-LOCAL(t): the only persistent state at nodes is the immutable output label after it is set; between windows there is no other state; in any t-round window, messages sent by a node are functions only of the underlying graph and the currently known outputs within its distance-t neighborhood (no dependence on farther outputs or on pre-window mutable state).
  • t-local-dependence at v: when v arrives, its output depends only on the arrived subgraph restricted to B(v,t) and outputs of the arrived nodes within B(v,t).

- Correct radius accounting:
  • At v’s arrival with window length t, nodes within B(v,t) can influence v. A node u ∈ B(v,t) may compute its messages based on outputs within B(u,t), which is contained in B(v,2t). Thus, in the output-only model, v’s output depends only on the graph structure and outputs within B(v,2t). Consequently, the correct bridge is to a sequential rule of radius 2t (not t). If we assume t-local-dependence at v, the bridge tightens to radius t.

- Minimal counter-scenario (why naive phase-compression fails for the unrestricted online model):
  Consider a path with t=1. In a genuine online run, before a vertex v arrives, Θ(n) earlier arrivals can propagate state one hop per window across the path; by the time v arrives, its neighbors may carry information injected far away. A color-phased simulation that offers only O(1) windows before v’s phase cannot reproduce these accumulated states. This shows that without output-only or t-local-dependence, we cannot black-box simulate arbitrary Online-LOCAL(t) runs by a constant number of phases.

- Practical takeaway for reductions:
  • If your online algorithm is output-only, design the sequential rule to read B(v,2t) and write only at v; then apply the G^{2t} coloring pipeline to get O(log* n) on bounded-degree trees.
  • If your online algorithm satisfies t-local-dependence at v, the sequential rule needs only B(v,t).

- Next-step plan (state elimination on trees):
  • Start on paths with t=1. Define the interface ∂B(v,2) and annulus R=B(v,2)\B(v,1). Attempt to prove: if two online executions agree on outputs over B(v,2), then they allow exactly the same outputs at v. If proven, extend to trees and t by replacing 2 with 2t. If refuted, crystallize a separation example.
  • Track read/write radii for any sequential rules that go beyond “write only at v”; use distance-(R+W) colorings for phase independence.
Additions and corrections

1) Correct simulation radius for bounded writes.
- When simulating an order-robust sequential rule that reads within B(v,R) and may write within B(v,W), independence within a color class requires both:
  • Write–write disjointness: B(u,W) ∩ B(v,W) = ∅.
  • Read–write disjointness: B(u,R) ∩ B(v,W) = ∅ and B(v,R) ∩ B(u,W) = ∅.
- These are guaranteed if dist(u,v) > max(2W, R+W). Therefore, the correct coloring is a proper coloring of G^K with K = max(2W, R+W). Using G^{R+W} alone is insufficient in general.
- Minimal counterexample to G^{R+W}: Take R=0, W=1 on the path u–x–v. Here dist(u,v)=2>R+W, but B(u,1)∩B(v,1)={x} so simultaneous writes conflict.

2) Output-only, W-write Online-LOCAL(t) ⇒ sequential (R,W) with R=2t+W.
- Model: When v arrives, A runs t rounds and may irrevocably write outputs on B(v,W); messages during this window depend only on the graph and the currently known outputs within distance ≤ t of the sender; no other mutable state persists.
- Radius accounting: To decide outputs on the patch B(v,W) within t rounds, only nodes in B(B(v,W), t) = B(v, W + t) can send messages that reach the patch. Under output-only, each such sender’s messages are functions of outputs in its own t-ball. Hence the decisions on the patch depend only on outputs within B(v, W + 2t) = B(v, 2t + W).
- Sequential rule S: For a given order σ, when processing v, S reads already-fixed outputs in B(v, 2t+W) and deterministically reproduces A’s t-window on the patch, writing only to currently-unset outputs in B(v,W). Because A is deterministic and correct for all orders, S reproduces A’s result for order σ.

3) Commutativity of independent arrivals (unrestricted Online-LOCAL(t)).
- If two consecutive arrivals u and w satisfy dist(u,w) > 2t, swapping their order leaves the t-round transcripts and resulting states identical everywhere. In particular, by repeatedly swapping, one can assume that, when analyzing v, only arrivals within B(v,2t) occur before v. This normalizes the analysis horizon for any state-elimination attempt.

4) State-elimination program on paths (t=1) — concrete targets.
- Define the interface K(v) as the already-fixed outputs on B(v,2) just before v arrives (after normalizing the order so only B(v,2) arrives first). Target claim (context-invariance): The set of feasible outputs/messages at v depends only on K(v). If true, derive a canonical sequential rule of read radius R=2 and (potential) write radius W by reproducing the canonical choice. If false, document a counterexample LCL on paths.

5) Accounting for LOCAL complexity when W>0.
- With (R,W)-local sequential rules, compute a proper coloring of G^{K} with K = max(2W, R+W) in O(K log* n) rounds (Lemma 1 simulated on G), then process colors in O(R) rounds per color. On bounded-degree trees with constant R,W, this gives O(log* n) overall.
Disproof of “faithful color-by-color simulation” for unrestricted Online-LOCAL(t)
The tempting idea to fix a proper coloring φ of G^{2t}, choose the arrival order σ_φ that processes color classes 1,2,…,C, and then simulate each color class in O(t) rounds by running all arrivals of that color concurrently, is not valid in the unrestricted Online-LOCAL(t) model.

Key obstruction: In the Online-LOCAL(t) semantics, each arrival triggers t synchronous rounds across the entire arrived subgraph. Nodes outside B(v,t) of the newly arrived vertex v may still update their local state in that step (e.g., increment a local counter) even though they receive no messages. Over k arrivals in a color class, every previously arrived node performs k such "idle" updates. Compressing k steps to 1 per color fails to reproduce the global state unless one can apply k-fold local updates everywhere, which is not locally computable in O(1) rounds.

Minimal counterexample (paths, t=1). Consider the trivial LCL Π that accepts any labeling. Define a deterministic Online-LOCAL(1) algorithm A as follows:
- Every arrived node maintains a parity bit p, initially 0, and toggles p at every arrival step (independently of messages).
- When a new vertex v arrives, in the 1-round window v queries any neighbor u (if one exists) for p and outputs that bit. (If v has no arrived neighbor, it outputs 0.)
This A is correct for Π for every arrival order (Π accepts any labeling). Fix any proper 3-coloring φ of the path’s G^2. In the sequential σ_φ-run that processes all color-1 vertices one by one, p toggles at every arrival, so the outputs of color-1 vertices alternate with their internal order. A batched O(1)-round simulation that processes all color-1 vertices simultaneously cannot reproduce these alternating outputs: all of them see the same parity p from earlier colors and output the same bit. Hence faithful reproduction of the σ_φ-run is impossible in general.

Consequences.
- The earlier “main gap” (state accumulation across many arrivals) is real for unrestricted Online-LOCAL(t): batched simulation does not, in general, preserve the online run’s state trajectory.
- To make per-color batching sound, one needs extra structure such as quiescence: outside B(v,t), the per-step state update is the identity (or, more generally, does not depend on the number of arrivals). The output-only and t-local-dependence variants already enforce related constraints.

On Lemma 8 and local order normalization
- Our Corollary 7.1 already implies the witness localization needed for per-node analysis: by swapping distant arrivals (dist > 2t), one can assume all arrivals before v occur in B(v,2t) without changing the state in B(v,t) at v’s arrival. This is the appropriate normalization tool for any local confluence/interface analysis.

On Lemma 9 (finite enumeration claim)
- As stated (“the set of possible transcripts/messages seen by v is finite”), this is false in the standard LOCAL model due to unbounded message/state spaces and dependence on unique IDs. Finite enumeration becomes viable only if one assumes bounded message alphabets, bounded state, or ID-obliviousness; otherwise, for a fixed constant-size ball B(v,2), the algorithm can encode arbitrarily large ID-dependent information into messages/states.

Next steps for the path/t=1 interface program
- Either (i) impose output-only (or stronger quiescence/ID-obliviousness) and aim to prove the context-invariance Claim C1 under those constraints, or (ii) build a concrete counterexample to C1 in the unrestricted model by letting neighbors’ 1-round messages to v depend on the number of prior arrivals while keeping K(v) fixed. In both tracks, use Corollary 7.1 to restrict attention to B(v,2).

Complexity reminder for bounded writes
- With (R,W)-local sequential rules, independence within a color class requires K = max(2W, R+W). Computing a proper coloring of G^{K} costs O(K·log* n) rounds and per-color work is O(R). For bounded Δ, R, W, this yields O(log* n) total complexity dominated by the coloring step.
New bridge via quiescence (precise form) and radius accounting
- Definition (quiescent Online-LOCAL(t), standard LOCAL timing). In each arrival step for v, the algorithm runs t synchronous LOCAL rounds on the arrived subgraph. Messages sent in round r depend only on the node’s state at the start of round r; at the end of the round, nodes update their state based on received messages. The algorithm is quiescent if, during the t rounds triggered by v’s arrival, every node u with dist(u,v) > t does not change its state in any of these t rounds. (Under the above timing, such u cannot forward newly received information in subsequent rounds because its outgoing messages in round r depend only on its unchanged state.)
- (W,t)-quiescent: If the algorithm may irrevocably write outputs on a patch B(v,W) during v’s window, we call it (W,t)-quiescent if only nodes in B(v,W+t) may change state in that window.

- Correct separation for parallel batching: To parallelize all same-color windows for t rounds without interference, it is necessary to forbid any edge between distinct active regions. For W=0 the active region for v is B(v,t). Thus, a proper coloring of G^{2t+1} (not merely G^{2t}) guarantees that for same-color u,v, dist(u,v) ≥ 2t+2, hence dist(B(u,t), B(v,t)) ≥ 2. This eliminates one-hop coupling across region boundaries. With W>0, color G^{2t+2W+1} so that distinct active regions B(·,W+t) have mutual distance ≥ 2.

- Why quiescence removes the “idle-accumulation” pitfall: In the unrestricted model, nodes can encode the number of prior arrivals into their state and/or messages, letting each new window see different ambient information; batching then fails. Under quiescence, any vertex whose t-window has not yet been processed cannot track steps that do not involve it, so its local view (modulo the already-arrived graph and earlier colors) is invariant across the internal order within a color class. Combined with the ≥2 separation between active regions, the parallel t-round simulation per color faithfully matches any sequential permutation of that color.

- Examples that fit quiescence: Greedy MIS and greedy maximal matching on bounded-degree graphs (W=1, t=1) where only the newly active 1-neighborhood changes, and (Δ+1)-vertex-coloring rules that finalize a 1-hop patch around the arrival.

Remark on Lemma 7 (2t-commutativity)
- The lemma remains valid even if nodes outside B(u,t) ∪ B(w,t) perform deterministic updates depending only on the global step index (and not on messages). Those nodes experience the same two consecutive step indices before and after the swap; hence their pair of updates is identical.

Lower-bound program (outline) for Online-LOCAL on trees
- Target: Prove that sinkless orientation on bounded-degree trees admits no deterministic Online-LOCAL(t)=O(1) algorithm (adversarial arrival). Use Lemma 7/Cor. 7.1 to normalize prefixes so that only B(e,2t) arrives before deciding edge e. Then adapt the node↔edge round-elimination locally inside B(e,2t), iterating 2t times to obtain a 0-round contradiction with the ID-graph property. Formalizing this (LB.1–LB.2) would non-constructively imply: any LCL with constant-t Online-LOCAL on trees lies in the O(1)/Θ(log* n) class, so there exists an O(log* n) deterministic LOCAL algorithm.

Next steps
- Integrate the quiescent bridge with K=2t+1 (resp. 2t+2W+1) into output.md.
- Begin the path (t=1) state-elimination-by-quiescence attempt with a precise interface Σ(u→v) and normalized histories (via Cor. 7.1). Either prove context-invariance or extract a counterexample LCL.
- In parallel, formalize LB.1–LB.2 for sinkless orientation as described above.
Additions (witness localization, phase-locality, and LB pitfalls)

1) Strong witness localization at v (unrestricted Online-LOCAL(t)). Using Lemma 7 (2t-commutativity), one can bubble v leftward across any predecessor u with dist(u,v) > 2t. Performing all such swaps yields an arrival sequence in which every predecessor of v lies in B(v,2t). Moreover, the set of predecessors of v inside B(v,2t) is unchanged, so the arrived subgraph just before v equals the restriction of the original arrived subgraph to B(v,2t). Each swap preserves the state on B(v,t) at v’s arrival; hence the state on B(v,t) when v arrives is identical before and after normalization. This refinement is now recorded as Lemma 9 in output.md.

2) Phase-locality under (W,t)-quiescence. In Lemma 8’s color-phase simulation with K = 2t+2W+1 (so that dist(R_v,R_w) ≥ 2 for R_v = B(v,W+t)), nodes outside R := ⋃ R_v keep their state fixed in the t rounds of the phase. Under standard LOCAL timing (send from current state; receive; update), such nodes cannot forward newly received information in later rounds. Therefore, there is no causal influence along any path that leaves one active region and re-enters another within the same phase. The transcript inside each R_v depends only on the initial boundary states, and the effects of different R_v commute. This is now formalized as Claim 8.1 inside Lemma 8’s proof.

3) Localized round-elimination on trees: modeling choices and a gap. The intended LB.1 (node→edge) step asserts that if both endpoints have local witnesses for opposite orientations of an edge e inside B(e,2t), then one can glue these into a single global execution that contradicts correctness. This is not valid for the node-form of sinkless orientation: both endpoints may “grab” e without violating the constraint that every node has at least one outgoing edge. To proceed, adopt one of:
- Edge-form LCL with decisive step at the second endpoint, so “double-witness in opposite directions” is a genuine contradiction; or
- A universal-quantifier version of the elimination step, together with a proof that the universal property is preserved by iteration; and in all cases
- A precise normalization-and-extension lemma: any normalized local arrival order inside B(e,2t) extends to a global order whose transcript inside B(e,t) (up to the decisive step for e) is preserved.

4) Radius sanity. The +1 in K = 2t+2W+1 (for quiescent batching) is necessary to guarantee dist(R_v,R_w) ≥ 2 and exclude one-round coupling across a single cross-edge. In contrast, in Corollary B we simulate a derived sequential (R,W)-rule and only require K = max(2W, R+W) (no +1).

Next steps (crisp):
- Prove the normalization-and-extension lemma for balls B(e,2t) on trees.
- Fix the problem model for the LB route (edge-form with a decisive step, or a universal-quantifier variant) and re-state LB.1/LB.2 accordingly; then supply complete proofs.
- Continue the path, t=1 interface study under quiescence or output-only; either prove context-invariance or give a counterexample LCL confined to B(v,2).
Critical audit: normalization around an edge and boundary freezing

- Edge-prefix extension (valid). For any edge e=uv and any finite arrival prefix τ consisting of distinct vertices of B(e,2t), there is a global arrival order σ whose first |τ| arrivals are exactly τ, and no vertex outside B(e,2t) arrives before those steps. Running A on σ and on the induced local execution confined to the arrived subgraph inside B(e,2t) produces identical states/outputs on B(e,t) at each of those |τ| steps. This is immediate from the model: outside vertices are simply absent.

- The converse normalization (invalid). It is not generally possible to transform an arbitrary global schedule into one in which no vertex outside B(e,2t) arrives before the decisive moment for e while preserving the state on B(e,t) step-by-step (or even at the decisive moment). The obstruction is that outside arrivals at distance > 2t from e can influence B(e,t) before the second endpoint arrives via chains of arrivals inside B(e,2t), and Lemma 7 (2t-commutativity) allows swaps only for pairs of arrivals at pairwise distance > 2t.

Counterexample (t = 1 on a path). Let the path be … x3 – x2 – x1 – u – v – y1 – y2 – y3 … with e = uv. Consider an Online-LOCAL(1) algorithm A that maintains at each arrived node a persistent bit s (initially 0). Upon an arrival of w, in the single LOCAL round each already-arrived node sends its current s to arrived neighbors; the new node w sets its own s to the parity of the s-values it receives (or 0 if it has no arrived neighbor). Now take the arrival order: x3 (outside B(e,2)), x2, x1, u (first endpoint), v (second endpoint). When x2 arrives, it sets s(x2) based on s(x3); then x1 sets s(x1) based on s(x2); by the time v arrives, s(x1) depends on x3’s early arrival, and the state on B(e,1) at the decisive moment reflects that influence. One cannot push x3 past v by a sequence of swaps allowed by Lemma 7 without encountering swaps with x2 or x1, which are at distance ≤ 2t from x3. Thus the “moreover” normalization fails even on a path.

Implication for elimination. Any node→edge elimination step that freezes a boundary ∂B around e and then quantifies over local schedules inside B must justify why the boundary states are fixed and unaffected by outside arrivals up to the decisive time. In the unrestricted online model, boundary nodes may change state many times before e is decided, driven by outside arrivals; there is no general way to ignore or freeze that evolution. Consequently, the proposed universal set-valued rule that depends only on B(e,2t) and a fixed boundary snapshot is not yet sound.

On finite type spaces. Classical round-elimination relies on a finite set of local types induced by t-round views. Here, without restrictions (output-only, quiescence, finite-state, ID-obliviousness), the set of possible boundary states at distance 2t is unbounded. Any lower-bound scheme must either (i) prove a compaction lemma that only finitely many boundary features can influence the decision at e, or (ii) work within a restricted model where such a bound is immediate.

On the “+1” in K for quiescent batching. The rationale remains correct: to forbid any within-phase signal that leaves one active region and re-enters another, we must ensure there is no single cross-edge between distinct active regions. For W=0, R_v=B(v,t); for general W, R_v=B(v,W+t). A proper coloring of G^{2t+2W+1} guarantees dist(R_v,R_w) ≥ 2 for same-color v≠w, which is exactly what Claim 8.1 uses.

Next steps.
- Keep only the safe edge-prefix extension fact; drop the converse normalization from any formal statements.
- If pursuing elimination, restrict the model to obtain finite boundary types (output-only, (W,t)-quiescent, or finite-state/ID-oblivious), and then formalize universal-set node↔edge steps, including exact radius accounting, preservation of nonemptiness, and node constraints.
- Alternatively, attempt a compaction lemma in the unrestricted model: prove that for sinkless orientation on trees, the orientation at e at the decisive moment depends only on a finite equivalence class of the evolving boundary at radius 2t. If this fails, document a counterexample LCL.
- Optionally, provide a formal tightness example for the +1 in Lemma 8 with t≥2 on paths to complement the existing remark.
New: Adversarial schedule-localization for an edge and audit of edge-centered set steps

Edge-local adversarial scheduling (safe primitive)
- Lemma S (informal). For any edge e=uv and t≥1, the adversary can choose an arrival order in which all vertices of B(e,2t) arrive before any vertex outside B(e,2t). In such a run, the decision that A makes at e at the moment the second endpoint arrives depends only on the labeled type of B(e,2t) and on the internal arrival order within that ball; the outside is simply absent up to that moment.
- Rationale. This is not a transformation of a given schedule but a fresh adversarial choice, fully permitted in the model (A must succeed for all arrival orders). The lemma avoids any boundary-freezing assumption or converse normalization.

Audit: why the proposed node→edge universal set step on B(e,2t) breaks at a node w
- Setup. Prover 01 defines S_e(X_e) for each edge e using only the 2t-ball around e (outside absent) and claims a node-side "no-sink in sets" property: at each w, among incident edges e∋w at least one S_e contains an orientation pointing away from w.
- Issue (non-composability across edges). The proof switches to a schedule over U_w := ⋃_{e∋w} B(e,2t) that decides all edges at w while keeping outside-U_w absent. For a given e=wx, this schedule may include arrivals of vertices in U_w\B(e,2t) before e is decided; their windows can alter states of nodes inside B(e,2t) via boundary interactions over multiple steps. Consequently, the decision at e in this U_w-schedule need not be among those seen when only B(e,2t) is present. Hence one cannot conclude that forbidding “outward at w” in all S_e forces w to be a sink in the U_w-schedule. This breaks the claimed node-side constraint for the S_e defined on B(e,2t).

Fix: define node-centered sets on U_w
- Define U_w as the union of radius-2t edge-balls around edges incident to w. On trees and for fixed Δ,t, U_w has constant size (radius ≈ 2t+1 around w).
- Define a node-centered set T_w(X_w) on the finite type X_w of U_w (port-colored, ID-graph labeled) as the set of incident port directions at w that can be oriented outward under some internal arrival order confined to U_w (outside-U_w absent) while deciding all incident edges. Nonemptiness of T_w follows from correctness: if T_w were empty, then in every internal order on U_w the run would decide all incident edges pointing into w, making w a sink in a valid schedule.
- After this node-side step is formalized, attempt the symmetric derivation of per-edge sets from neighbors’ node-sets, carefully auditing radius changes and ensuring that admissibility and node-side constraints are preserved under the same adversarial scheduling principle.

Output-only variant (repair to LBoo.1)
- Use union-over-orders (not intersection) for admissible sets and work with node-centered T_w on U_w. In output-only, type finiteness is immediate (finite output alphabet; bounded-radius balls). The same composability caveat applies if one insists on per-edge sets based on B(e,2t); prefer node-level sets on U_w for the “no-sink” constraint.

On the +1 in Lemma 8
- The necessity of K=2t+2W+1 is correct in spirit. To promote this to a formal proposition, provide an explicit quiescent (W=0), t=2 algorithm on a path that uses a 2-round relay across a single cross-edge to couple the two active regions when K=2t, thereby violating phase-independence. Until the explicit construction is documented, we retain the existing explanatory remark after Lemma 8.

Action items
- Formalize T_w on U_w (types, finiteness, nonemptiness, and node-side “no-sink”) and then the edge↔node half-step with precise radius accounting.
- For the output-only regime, rework LBoo.1 accordingly and track the invariants under iteration to a 0-round contradiction via the ID-graph.
- Provide the explicit t=2 path example for the +1 necessity.


Current output.md (if any):
List of proven results archived here
- Lemma 1: Power-graph coloring in O(k log* n).
- Lemma 2: Color-phased simulation for order-robust read-radius r rules that write only at the current node (W=0).
- Theorem A: Sequential-local (W=0) ⇒ LOCAL on bounded-degree graphs.
- Lemma 3: Bridge from output-only Online-LOCAL(t) (W=0) to order-robust sequential with read radius 2t.
- Lemma 4: Bridge under t-local-dependence (W=0) to read radius t.
- Corollary A: On bounded-degree trees, constant r or constant t ⇒ O(log* n) LOCAL.
- Lemma 5: Color-phased simulation for sequential rules with read radius R and write radius W via a G^{K}-coloring with K = max(2W, R+W).
- Lemma 6: Bridge from output-only, W-write Online-LOCAL(t) to an order-robust sequential rule with (R,W) = (2t+W, W).
- Corollary B: On bounded-degree trees, constant t,W in output-only W-write Online-LOCAL(t) ⇒ O(log* n) LOCAL.
- Lemma 7: 2t-commutativity of independent consecutive arrivals in Online-LOCAL(t), and a corollary pushing far-away arrivals past a fixed v.

Model and definitions
- Graphs: finite, simple, maximum degree Δ < ∞ (bounded degree). Nodes have unique IDs from a polynomial range (standard LOCAL assumptions). dist(·,·) is the hop distance; B(v,r) is the radius-r ball around v.
- LCL Π: a locally checkable labeling problem with constant checkability radius r_Π.
- Order-robust sequential rules with bounded writes: A deterministic rule S with read radius R and write radius W is a procedure that, when processing v in a vertex order σ, inspects G[B(v,R)] and the outputs already fixed in B(v,R) ∩ {earlier vertices in σ}, and may irrevocably write outputs on any currently-unset vertices in B(v,W). The final labeling must satisfy Π for every σ. (The special case W=0 writes only at v.)
- Online-LOCAL(t): vertices arrive one by one; at each step the algorithm executes t synchronous LOCAL rounds on the subgraph induced by the arrived vertices; outputs are irrevocable; nodes may maintain arbitrary local state across steps unless otherwise restricted.
- Output-only Online-LOCAL(t): the only persistent state is the immutable output label after it is set; in any t-round window, messages and local computation at a node may depend on the graph and currently known outputs within distance ≤ t from that node, but not on any other mutable state.
- t-local-dependence (at v): upon v’s arrival, its output depends only on the induced arrived subgraph and previously fixed outputs within B(v,t).
- Output-only, W-write Online-LOCAL(t): as output-only above, but when v arrives the algorithm may irrevocably fix outputs on any vertices in B(v,W).

Lemma 1 (Power-graph coloring in O(k log* n))
Statement. Let G be a bounded-degree graph and k ≥ 1 a constant. There is a deterministic LOCAL algorithm that computes a proper vertex coloring of the power graph G^k with at most C = Δ^{O(k)} colors in O(k log* n) rounds on G.
Proof. Standard: simulate an O(log* n)-round O(Δ(G^k)^2)-coloring on G^k by k rounds per step on G; Δ(G^k) ≤ Δ^k, hence C = Δ^{O(k)}. □

Lemma 2 (Color-phased simulation for W=0)
Statement. Let S be an order-robust sequential rule with read radius r that writes only at the current node (W=0). Given a proper coloring of G^r, processing colors 1,…,C in order reproduces S for any order respecting the color layering, using O(r) rounds per color.
Proof. If φ(u)=φ(v) then dist(u,v)>r, hence the decisions in phase i depend only on outputs from earlier colors and do not interfere. Each node gathers outputs in B(·,r) from earlier colors in O(r) rounds and applies S. □

Theorem A (Sequential-local (W=0) ⇒ LOCAL)
Statement. If Π admits an order-robust r-local sequential algorithm (W=0), then Π has a deterministic LOCAL algorithm running in O(r log* n + Δ^{O(r)}·r) rounds. For constant Δ,r: O(log* n).
Proof. Compute a G^r-coloring in O(r log* n) rounds (Lemma 1), then simulate by Lemma 2. □

Lemma 3 (Output-only Online-LOCAL(t), W=0 ⇒ sequential with read radius 2t)
Statement. If Π has a deterministic output-only Online-LOCAL(t) algorithm correct for every arrival order, then Π admits an order-robust sequential algorithm with read radius 2t (W=0) that reproduces the online outputs for any order.
Proof. Fix order σ. When v_i arrives online under σ, only nodes in B(v_i,t) can send messages that reach v_i within t rounds. Under output-only, any such message depends only on outputs within the sender’s B(·,t), all contained in B(v_i,2t). Hence v_i’s t-window transcript and output are functions of the restriction to B(v_i,2t) of the arrived subgraph and outputs. Define the sequential rule to read those and return the same output as the online algorithm would under σ. Correctness and order-robustness follow. □

Lemma 4 (Bridge under t-local-dependence, W=0)
Statement. If Π has a deterministic Online-LOCAL(t) algorithm with t-local-dependence (at every v) that is correct for every arrival order, then Π admits an order-robust sequential algorithm with read radius t (W=0).
Proof. As in Lemma 3, but with t in place of 2t by hypothesis. □

Corollary A (Bounded-degree trees, constant r or t)
Statement. On bounded-degree trees, if Π has either (i) an order-robust r-local sequential algorithm (W=0) with constant r, or (ii) an output-only Online-LOCAL(t) algorithm (W=0) with constant t, or (iii) an Online-LOCAL(t) algorithm with t-local-dependence and constant t, then Π has a deterministic LOCAL algorithm with round complexity O(log* n).
Proof. Combine Theorem A with Lemma 3 or Lemma 4 as applicable; Δ and radii are constants. □

Lemma 5 (Color-phased simulation with bounded writes)
Statement. Let S be an order-robust sequential rule with read radius R and write radius W ≥ 0 (S may write outputs on currently-unset vertices in B(v,W)). Let φ be a proper coloring of G^{K} with K = max(2W, R+W). Then processing colors 1,…,C in order reproduces S for any order that respects the color layering. The per-color communication cost is O(R) rounds after φ is known.
Proof. If φ(u)=φ(v) then dist(u,v) > K ≥ 2W and > R+W. Thus (i) B(u,W) ∩ B(v,W) = ∅ (no write–write conflicts) and (ii) B(u,R) ∩ B(v,W) = ∅ and B(v,R) ∩ B(u,W) = ∅ (no read–write interference). In phase i, each vertex v with φ(v)=i gathers outputs written by earlier colors within B(v,R) and computes its writes; because of (i)–(ii), these writes are independent across same-color vertices and depend only on earlier colors, so the result matches S for any order that lists all lower colors first and then the current color in any internal order. O(R) rounds suffice to gather B(v,R) information. Computing φ takes O(K log* n) rounds by Lemma 1 with k=K. □

Lemma 6 (Output-only, W-write Online-LOCAL(t) ⇒ sequential with (R,W)=(2t+W,W))
Statement. If Π has a deterministic output-only, W-write Online-LOCAL(t) algorithm A correct for every arrival order, then Π admits a deterministic order-robust sequential rule S that, when processing v, reads only B(v, 2t+W), may write on currently-unset vertices in B(v,W), and reproduces A’s outputs for any order.
Proof. Fix order σ = (v_1,…,v_n). Consider A under arrival order σ. When v_i arrives, during its t-round window only nodes within distance ≤ t of the patch B(v_i,W) can send messages that reach the patch; hence all influencing senders lie in N := B(B(v_i,W), t) = B(v_i, W+t). Under output-only, messages sent by any u ∈ N depend only on outputs within B(u,t). Therefore the union of outputs that can affect the patch’s decisions lies in M := ⋃_{u∈N} B(u,t) = B(v_i, W+2t). Consequently, the t-round transcript determining the patch outputs in the σ-run is a function of the restriction of the arrived subgraph and already-fixed outputs to B(v_i, 2t+W). Define S as follows: when processing v_i under σ, S collects the already-fixed outputs within B(v_i, 2t+W) ∩ {v_1,…,v_{i-1}} and deterministically reproduces A’s t-window decisions on the patch given that local view, writing only to vertices in B(v_i,W) whose outputs are not yet fixed. Because A is deterministic and respects irrevocability, this reproduces exactly the same patch outputs as A under σ and never overwrites. As A is correct for every order, S is an order-robust (R,W)-local rule with R=2t+W. □

Corollary B (Bounded-degree trees, output-only W-write ⇒ O(log* n) LOCAL)
Statement. On bounded-degree trees, if Π has a deterministic output-only, W-write Online-LOCAL(t) algorithm with constants t,W, then Π has a deterministic LOCAL algorithm with round complexity O(log* n).
Proof. Apply Lemma 6 to obtain a sequential (R,W)-rule with R=2t+W. Then use Lemma 5 with K = max(2W, R+W) = max(2W, 2t+2W) = 2t+2W to simulate S in the LOCAL model: compute a proper coloring of G^{2t+2W} in O((2t+2W) log* n) rounds, then spend O(R)=O(2t+W) rounds per color. For constant Δ,t,W the total is O(log* n). □

Lemma 7 (2t-commutativity of independent consecutive arrivals)
Statement. Let A be any deterministic Online-LOCAL(t) algorithm (unrestricted mutable state). Consider an arrival sequence σ and two consecutive arrival steps at vertices u and w such that dist(u,w) > 2t. Let σ′ be obtained by swapping these two steps. Then, after these two steps, the states and fixed outputs at all vertices are identical under σ and under σ′.
Proof. Let G_i be the arrived subgraph just before these two steps. In the step when u arrives under σ, A executes t synchronous rounds on G_i ∪ {u}. Messages can traverse at most t hops per window, so only nodes in B(u,t) can be influenced (either by receiving messages or by depending on received messages); nodes outside B(u,t) undergo the same deterministic state updates as they would in any window where they receive the same (empty) messages. Likewise, w’s step affects only B(w,t). Because dist(u,w) > 2t, the balls B(u,t) and B(w,t) are disjoint, and w is absent during u’s step and u is absent during w’s step in both σ and σ′. Therefore the t-round transcripts and resulting updates within B(u,t) (resp. B(w,t)) are identical in σ and σ′, and all other vertices experience no message-dependent changes in either order. Thus the combined effect of the two steps commutes. □

Corollary 7.1 (Pushing far-away arrivals past v)
Statement. Fix v and any arrival sequence. By repeatedly swapping consecutive independent steps via Lemma 7, one can transform the sequence into another in which all vertices at distance > 2t from v arrive after v, without changing any states or outputs within B(v,t) at the time v arrives (or thereafter).
Proof. Iteratively swap any arrival at distance > 2t from v forward past earlier arrivals until it occurs after v; Lemma 7 ensures the swaps preserve the relevant states/outputs. □

Remark. Lemma 5 supersedes the earlier, flawed variant that required only a G^{R+W}-coloring; the counterexample R=0, W=1 on a 3-path shows that G^{R+W} is insufficient because write–write conflicts may occur.
Remark (No faithful t-per-color batching for unrestricted Online-LOCAL(t)). There exists a deterministic Online-LOCAL(1) algorithm A and a valid color-by-color arrival order σ_φ (induced by a proper coloring φ of G^2 on a path) such that any LOCAL simulation that processes all vertices of the same color class simultaneously in O(1) rounds cannot reproduce the exact outputs produced by A under the sequential σ_φ-run.
Proof. Consider the trivial LCL Π that accepts any labeling. Algorithm A maintains at each arrived node a parity bit p (initially 0) that toggles at every arrival step (regardless of messages). When a new vertex v arrives, in its 1-round window it reads p from an already-arrived neighbor if one exists and outputs that bit (if v has no arrived neighbor, it outputs 0). Fix any proper 3-coloring φ of the path’s G^2 and let σ_φ process colors 1,2,3 in order, with any internal order inside a color. In the sequential σ_φ-run, the parity p toggles at every arrival, hence the outputs of the vertices of any color class alternate with the internal order. In contrast, if one processes all vertices of a color class simultaneously in a single 1-round batch (keeping not-yet-processed colors absent), all these vertices observe the same parity p from earlier colors and therefore all output the same bit. Thus the batched simulation does not reproduce A’s outputs under σ_φ. □

Remark (Complexity accounting for Lemma 5/Corollary B). On bounded-degree graphs with constants t,W, the coloring step on G^{K} (K = max(2W, R+W), with R = 2t+W in Corollary B) costs O(K·log* n) rounds and yields C = Δ^{O(K)} colors; the per-color work is O(R). Hence the total complexity is O(log* n), dominated by the coloring step.
Definition (Quiescent Online-LOCAL(t) and (W,t)-quiescent)
Consider the standard LOCAL timing in an arrival step: in each of t synchronous rounds, each arrived node first sends messages as a (deterministic) function of its current state, then receives messages from neighbors, and finally updates its state as a (deterministic) function of its current state and the received messages.
- An Online-LOCAL(t) algorithm A is quiescent if, upon the arrival of v, during the ensuing t rounds every node u with dist(u,v) > t does not change its state in any of these t rounds.
- More generally, A is (W,t)-quiescent if, upon the arrival of v, during the ensuing t rounds only nodes in the active region B(v, W+t) may change their state; nodes outside B(v,W+t) do not change state.

Lemma 8 (Quiescent Online-LOCAL(t) ⇒ O(log* n) LOCAL; bounded-writes variant)
Let Π be an LCL on bounded-degree graphs. Suppose Π has a deterministic quiescent Online-LOCAL(t) algorithm A with constant t.
(i) Then Π admits a deterministic LOCAL algorithm with round complexity O((2t+1)·log* n + t·Δ^{O(t)}) = O(log* n).
(ii) More generally, if A is (W,t)-quiescent with constants W,t, then Π admits a deterministic LOCAL algorithm with round complexity O((2t+2W+1)·log* n + t·Δ^{O(t+W)}) = O(log* n).

Proof.
Fix K := 2t+1 in case (i), and K := 2t+2W+1 in case (ii). By Lemma 1, compute a proper coloring φ of G^{K} with C = Δ^{O(K)} colors in O(K·log* n) rounds. We process the colors in increasing order i = 1,2,…,C in phases; at the start of phase i, exactly the vertices of colors < i are considered “already arrived,” and vertices of colors ≥ i are “not yet arrived.”

In phase i we simulate, in parallel, the t-round online arrival window of every vertex v with φ(v)=i, on the subgraph induced by vertices of colors ≤ i, as follows: (a) we declare all vertices of color i to “arrive” at the beginning of the phase, and (b) we perform t synchronous LOCAL rounds on that induced subgraph. During this phase, the algorithm A is executed faithfully at every vertex, except that vertices of colors > i are absent.

Let R_v denote the active region of v during this phase: R_v = B(v,t) in case (i) and R_v = B(v, W+t) in case (ii). Because φ colors G^{K} with K as above, for any two distinct same-color vertices v,w we have dist(v,w) ≥ K+1, hence dist(R_v, R_w) ≥ 2. In particular, there is no edge between R_v and R_w.

Quiescence and the LOCAL timing imply two key facts within phase i:
1) Only nodes in R := ⋃_{φ(v)=i} R_v may change state during the t rounds of phase i; all nodes outside R keep their state fixed throughout the phase. Since messages sent in a round depend only on the sender’s current state at the start of that round, such outside nodes cannot forward newly received information in subsequent rounds. Consequently, there is no causal influence along any path that leaves one R_v and re-enters another R_w within the t rounds, because such a path must traverse at least one node outside R which cannot propagate new information.
2) Since dist(R_v, R_w) ≥ 2, there is neither an edge nor a length-1 path between distinct active regions.

From 1)–2) it follows that, during phase i, the evolution of each R_v is identical to what would occur if we executed only v’s t-round window in isolation (with all other color-i vertices absent), given the same boundary states on the external neighborhood of R_v (which are precisely the states fixed by earlier colors). Formally, this can be proved by induction on the round counter r=1,…,t, using the domain-of-dependence that is confined to R_v together with outside nodes whose states remain constant.

Therefore, the combined effect of phase i equals the composition of the individual “v-arrival” windows over all vertices v with φ(v)=i, in any internal order. By induction on i, after finishing phase i the global state/output coincides with the online execution that processes first all color-1 vertices (in an arbitrary order), then all color-2 vertices, and so on. Since A is correct for every arrival order, the final labeling after phase C is legal for Π.

The complexity is O(K·log* n) to obtain φ and t rounds per color, i.e., O(t·C) additional rounds. For constant Δ, t, W, we have C = Δ^{O(K)} = O(1), so the total is O(log* n). □

Remark (on the choice of K). The choice K = 2t (resp. 2t+2W) is insufficient for the parallel phase: if dist(v,w)=2t+1 (resp. 2t+2W+1), then R_v and R_w are disjoint but may be adjacent by an edge, allowing one-round coupling between the two active regions. The value K = 2t+1 (resp. 2t+2W+1) guarantees dist(R_v, R_w) ≥ 2, which prevents such coupling and makes the above proof sound.

Remark after Lemma 7 (idle updates depending on step index). In Lemma 7, nodes outside B(u,t) ∪ B(w,t) may perform deterministic updates that depend on the global step counter but not on messages. When two consecutive arrivals at u and w with dist(u,w) > 2t are swapped, those nodes still undergo the same two consecutive step indices in the same order, so their pair of updates is unchanged. This clarifies that Lemma 7 tolerates such idle updates.
Lemma 9 (Strong witness-localization at a vertex)
Statement. Let A be any deterministic Online-LOCAL(t) algorithm on a bounded-degree graph G, let σ be any arrival sequence, and let v be any vertex. There exists an arrival sequence σ_v obtained from σ by repeatedly swapping adjacent arrivals such that:
(i) Every vertex that arrives before v in σ_v lies in B(v,2t).
(ii) The arrived subgraph just before v arrives in σ_v equals the restriction to B(v,2t) of the arrived subgraph just before v arrives in σ (i.e., the set of predecessors of v inside B(v,2t) is unchanged).
(iii) The entire state and the fixed outputs on B(v,t) at the moment v arrives are identical under σ and under σ_v.

Proof. Starting from σ, repeatedly swap v with its immediate predecessor u whenever dist(u,v) > 2t. Each such swap is between two consecutive arrivals u and v whose t-neighborhoods are disjoint; by Lemma 7 (2t-commutativity), the global state after these two steps is identical independent of their order. After no more such swaps are possible, every predecessor of v has distance ≤ 2t from v, proving (i). During this process, we swap v only with vertices at distance > 2t, so the set of predecessors of v within B(v,2t) is unchanged, and therefore the arrived subgraph in B(v,2t) just before v is the same as in σ; this is (ii). Property (iii) follows because each swap preserves the state on B(v,t) (by Lemma 7), and hence the state on B(v,t) at the time v arrives is invariant under the sequence of swaps. □

Claim 8.1 (Phase-locality under (W,t)-quiescence; to be used within Lemma 8).
Fix a proper coloring φ of G^{K} with K = 2t+2W+1 and consider phase i of the simulation in Lemma 8, where all vertices v with φ(v)=i “arrive” simultaneously and we run t synchronous LOCAL rounds on the subgraph induced by colors ≤ i. For each such v, let R_v = B(v, W+t). Then, during phase i:
(a) Only nodes in R := ⋃_{φ(v)=i} R_v may change state; nodes outside R keep their state fixed throughout the phase.
(b) For each v, the t-round transcript (states and messages) on R_v depends only on A and on the initial states on R_v together with the states on the external neighborhood ∂R_v at the start of the phase (i.e., after phase i−1), and is identical to the transcript obtained by executing only v’s t-round window in isolation with those boundary states.
(c) The combined effect of the phase equals the composition, in any order, of the individual arrival windows of the vertices with φ(v)=i.

Proof. Because φ is a proper coloring of G^{K} with K = 2t+2W+1, any distinct same-color vertices v,w satisfy dist(v,w) ≥ K+1, hence dist(R_v,R_w) ≥ (K+1) − 2(W+t) = 2; in particular, there is no edge between R_v and R_w. By (W,t)-quiescence, during the t rounds of the phase only nodes within distance ≤ t of B(v,W) for some v with φ(v)=i may change state; the union of these sets is precisely R, proving (a). Under the standard LOCAL timing (in each round: send based only on the current state; then receive; then update), a node whose state does not change in a given round cannot make its outgoing messages depend on newly received information in later rounds unless its state changes; thus nodes outside R cannot relay any information originating in one active region to another during the phase. An induction on the round counter r=1,…,t shows that the state/message evolution on each R_v is identical to the evolution when executing only v’s t-round window with the same boundary states (states on ∂R_v are fixed by (a)), establishing (b). Since there is no causal influence between distinct active regions within the phase and no edge between them, the per-region effects commute, yielding (c). □

Remark (Why no +1 in Corollary B but +1 in Lemma 8). In Corollary B we first derive a sequential (R,W)-rule with R = 2t+W from the output-only online algorithm, and then simulate this sequential rule using a proper coloring of G^{K} with K = max(2W, R+W). This simulation does not execute concurrent online t-windows; independence is guaranteed by avoiding read–write and write–write conflicts for the sequential rule, and no extra +1 is needed. In contrast, Lemma 8 batches online t-windows of the same color in parallel; to prevent even a single cross-edge between distinct active regions during the t rounds, we require dist(R_v,R_w) ≥ 2, which is ensured by K = 2t+2W+1 (the +1 is necessary).
Lemma S (Adversarial schedule-localization for an edge)
Statement. Let A be any deterministic Online-LOCAL(t) algorithm (t ≥ 1) on a bounded-degree graph G, and let e = uv be an edge. Consider any edge-decided LCL semantics in which the label of e is irrevocably fixed at the time the second endpoint of e arrives. Then there exists an arrival sequence σ(e) with the following properties:
(i) All vertices in the ball B(e,2t) arrive before any vertex outside B(e,2t).
(ii) The second endpoint of e arrives within this prefix, so that e’s label is decided within the prefix.
(iii) The entire online execution of A up to the decisive moment for e depends only on the labeled type of B(e,2t) (graph structure, port colors, IDs) and on the internal arrival order of the vertices of B(e,2t); vertices outside B(e,2t) are absent and cannot affect the transcript.

Proof. Fix any ordering τ of the vertices of B(e,2t) in which the second endpoint of e appears last. Define σ(e) by listing the vertices of B(e,2t) according to τ, followed by all vertices of G \ B(e,2t) in any order. During the prefix consisting of B(e,2t), the arrived subgraph equals the induced subgraph on B(e,2t), and each arrival triggers t synchronous LOCAL rounds on that subgraph alone; vertices outside B(e,2t) are absent and neither send nor receive messages. The label of e is decided when its second endpoint arrives (the last vertex of the prefix), and the decision depends only on the labeled type of B(e,2t) and on the internal arrival order τ. This establishes (i)–(iii). □
