=== SYSTEM ===
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md, proofs.md, and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (informal progress & exploratory work so far)
- proofs.md (rigorous proofs & detailed mathematics so far)
- output.md (main results found so far)

**Three-tier file system guidelines**:
- **notes.md**: Readable running log of exploratory work, intuitions, failed attempts, ideas. Prefer appending. Replace only if old notes are clearly misleading. Should be self-contained.
- **proofs.md**: Complete rigorous mathematical proofs with full details. Think twice before adding anything. Contains proven lemmas, theorems, and detailed derivations. Only add mathematically verified content here.
- **output.md**: This is the only file that the user is supposed to read in case your verdict is "promising". It has to be self-contained. It contains ONLY the main problem results, and a discussion why they are relevant. It is extremely selective. Think twice before promoting proofs from proofs.md to output.md. Only if the result marks clear progress on the problem, and only if the proof in proofs.md has been thoroughly vetted by provers and you, it can join output.md. Each result must be followed by a rigorous, self-contained proof that properly defines all objects of interest and is essentially publication-ready. 

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (≥200 words). Include concrete next-step suggestions.",
  "summary_md": "Concise summary of this round's work for summarizer.",
  "verdict": "promising|uncertain|unlikely",
  "blocking_issues": ["List of issues preventing progress"],
  "per_prover": [{"prover_id": "01", "brief_feedback": "feedback", "score": "promising|uncertain|unlikely"}],
  "notes_update": {"action": "append|replace", "content": "Markdown for notes.md"},
  "proofs_update": {"action": "append|replace", "content": "Markdown for proofs.md"}, 
  "output_update": {"action": "append|replace", "content": "Markdown for output.md"}
}

**Verdict definitions**:
- **promising**: Significant mathematical progress, publishable results
- **uncertain**: Some progress you deem nontrivial, but with unresolved issues or incomplete reasoning  
- **unlikely**: No meaningful progress, fundamentally flawed approaches, or just exploratory work

**Update guidelines**:
- Use null for any update field you don't want to modify
- notes_update: Include informal reasoning, failed attempts, intuitions, exploratory work
- proofs_update: Only include complete, rigorous proofs that you have verified
- output_update: Only include main problem results that directly advance toward the solution


=== USER ===
=== Task (txt) ===

# Permutation UB-vs-OPT Separation Problem

**Universe.** Keys are $[n]=\{1,2,\dots,n\}$ with the usual order.
An **instance** is a permutation $\pi=(x_1,\dots,x_n)$ of $[n]$.

## 1) Unified-bound cost on a permutation

For each time $i\in\{1,\dots,n\}$:

* Let $R_i(1),R_i(2),\dots,R_i(i-1)$ be the previously accessed keys ordered by **recency** (so $R_i(1)=x_{i-1}$, $R_i(2)=x_{i-2}$, …).
* Define the **rank distance** $\Delta_i(j) := |\,x_i - R_i(j)\,|$.
* The **per-access unified charge** is

  $$
  \mathrm{UB}_i(\pi)\;:=\;\log\!\Big(1+\min_{1\le j\le i-1}\big(j+\Delta_i(j)\big)\Big),
  $$

  with the convention $\mathrm{UB}_1(\pi):=\log(1+n)$.

The **total unified-bound cost** is

$$
\mathrm{UB}(\pi):=\sum_{i=1}^n \mathrm{UB}_i(\pi).
$$

*(Remarks: logs are base 2; constants are irrelevant for asymptotics. Because $\pi$ is a permutation, “working-set number” equals the recency rank $j$, so this is the standard unified bound specialized to permutations.)*

## 2) Optimal dynamic BST cost on a permutation

We use the standard **dynamic BST model**:

* The algorithm maintains a binary search tree $T$ over $[n]$.
* To access $x_i$, it traverses parent/child pointers from the root to $x_i$; pointer moves and comparisons along the search path each cost 1.
* After (or during) the access, it may perform any number of **rotations**, each costing 1.
* The initial tree is a fixed balanced BST on $[n]$. (Allowing an arbitrary offline choice changes costs by at most an additive $O(n)$ and doesn’t affect asymptotics for this problem.)

For a permutation $\pi$, the **cost of an algorithm $\mathcal A$** is the sum of search-path lengths plus rotations over the $n$ accesses. The **optimal BST cost** is

$$
\mathrm{OPT}_{\mathrm{BST}}(\pi):=\min_{\mathcal A}\;\text{cost}_{\mathcal A}(\pi).
$$

## 3) The separation task

Find an infinite family of permutations $\{\pi_n\}_{n=1}^\infty$, $\pi_n\in S_n$, such that

$$
\mathrm{OPT}_{\mathrm{BST}}(\pi_n)\;=\;o\!\big(\mathrm{UB}(\pi_n)\big)
\quad\text{as }n\to\infty.
$$

A **strong separation** would meet, for some constants $c,C>0$,

$$
\mathrm{OPT}_{\mathrm{BST}}(\pi_n)\;\le\; C n
\qquad\text{and}\qquad
\mathrm{UB}(\pi_n)\;\ge\; c\,n\log n,
$$

i.e., $ \mathrm{OPT}_{\mathrm{BST}}(\pi_n) / \mathrm{UB}(\pi_n) = O(1/\log n)$.

*(Equivalently, in per-access terms: find $\pi_n$ with average BST cost $o(1)\cdot$UB’s average, e.g. $O(1)$ vs $\Omega(\log n)$.)*




=== Notes ===

# Research Notes



# Corrections and guidance

- Bit-reversal UB lower bound (Prover 1): The argument via t = ν2(i−1) shows UB_i ≥ log(min{2^t, 2^{h−t−1}}) = min{t, h−t−1} − O(1). With Pr[t=k]=2^{−(k+1)}, we have E[min{t,h−t−1}] = ∑_{k=0}^{h−1} 2^{−(k+1)} min{k, h−k−1} = O(1). Therefore this line of reasoning yields only UB(π) = Ω(n), not Ω(n log n). The step claiming Θ(h) per step is incorrect.

- DFS UB = Θ(n) (Prover 1): The sketch using UB_i ≤ log(2 + |x_i − x_{i−1}|) is plausible but needs a clean proof. Suggested route: charge log differences to subtree sizes along the DFS traversal and show ∑_v O(log size(v)) = O(n).

- Round-robin block construction (Prover 2): The per-step lower bound min_j (j + |x_i − x_{i−j}|) ≥ ⌊b/2⌋ for all i beyond the first round is false. Counterexample pattern (general b): choose within-block σ_b with (c_2, c_3) = (1, b). For any block B_r at round t=3, let s be the adjacent block that comes after r in ρ_k. Then the last access to B_s was at round t=2 with key c_2=1, so Δ = b + c_2 − c_3 = 1. The corresponding j equals k + pos(r) − pos(s) − 1 ≤ k−1, hence j + Δ ≤ k. When k ≪ b, this is < b/2, contradicting the claimed bound. In fact, many t produce such small witnesses, so UB_i can be O(log k) frequently.

- Fractal 2413 family (Prover 1): BST side is promising if we can cite or prove that Greedy runs in O(n) on permutations whose substitution decomposition uses only simple nodes of size ≤ 4. The UB lower bound must be scale-based: for many i, show that all candidates among the last L (for L ≈ the size of a relevant block scale) are far in key, so min_j (j+Δ) = Ω(L), giving UB_i = Ω(log L). The naive “first-arrival per block” charge yields only O(n) total and is insufficient.

- Next steps:
  1) Provide a rigorous DFS UB=O(n) proof or a citation.
  2) Correct the bit-reversal UB claim; add numerical UB for n = 2^h up to h ≈ 14–16.
  3) For F_h, (a) verify/cite Greedy’s O(n) bound for k-decomposable (k=4), (b) develop and prove a proper scale-based UB lower bound, and (c) compute UB empirically for h up to 8–10.
  4) Abandon the round-robin block family for UB ≈ n log(n/k); its structure lets adjacent-block, previous-round witnesses keep UB_i = O(log k) too often.



=== Current Output ===

# Main Results




=== Prover 1 Output ===

# Ideas

- Correct earlier claims: give a clean lower bound UB(bit-reversal) = Ω(n), withdraw the Θ(n log n) claim pending an upper bound; propose a route to tighten it.
- Put forward a concrete, recursively defined permutation family F_h via 2413-substitution on 4 blocks per level. Prove a scale-based UB lower bound UB(F_h) = Θ(n log n) by exhibiting, for a constant-probability set of positions at each high scale, a window of the last L steps all at rank-distance ≥ L. This avoids the “one first-arrival per block” bottleneck.
- On the BST side, argue that F_h is 4-decomposable (substitution decomposition uses only the size-4 simple permutation 2413), so by known results on Greedy on k-decomposable permutations, OPT_BST(F_h) ≤ O(n). Pin down the precise citation and, if needed, outline a direct structural algorithm.

# Bit-reversal: correction and a rigorous Ω(n) lower bound

Let n = 2^h, index times s = 0,1,…,n−1, and let the permutation be π(s) = rev_h(s) (h-bit reversal; the 1-based version shifts by +1 and does not affect differences). For s ≥ 1 let t = ν_2(s) be the number of trailing zeros of s in binary.

Key identity. rev_h(s) − rev_h(s − 2^t) = 2^{h−1−t}. Proof: s has bit s_t = 1 and s_j = 0 for j < t. Subtracting 2^t zeroes out bit t and leaves all other bits unchanged; upon reversal this flips exactly bit position h−1−t from 1 to 0, hence the stated difference.

Lower bound per step: For any s ≥ 1, among all 1 ≤ j ≤ s, either j ≤ 2^t or j > 2^t. For j ≤ 2^t, the h−t leading bits of rev_h(s) and rev_h(s − j) differ (standard trailing-bit block property), which implies |π(s) − π(s − j)| ≥ 2^{h−t−1}. For j > 2^t, we have j ≥ 2^t. Therefore
min_{1≤j≤s} (j + |π(s) − π(s − j)|) ≥ min{ 2^t, 2^{h−t−1} }.
Taking logs,
UB_{s+1}(π) ≥ min{ t, h−t−1 } − O(1).
Since Pr[t = k] = 2^{−(k+1)} for 0 ≤ k ≤ h−1, we get E[UB_{s+1}] ≥ ∑_{k=0}^{h−1} 2^{−(k+1)} min{k, h−k−1} − O(1) = Ω(1). Summing over s gives UB(π) = Ω(n).

Remark on upper bound. The above identity also gives a trivial UB upper bound UB(π) ≤ O(n log n), but I do not currently derive O(n). Numerics for h up to, say, 14–16 should clarify whether UB(π) is Θ(n) or grows faster; for now I retract the earlier Θ(n log n) claim and retain only UB(π) = Ω(n).

# The fractal 2413 family F_h (n = 4^h): definition

Define F_0 to be the permutation on {1}.
For h ≥ 1, partition [1..4^h] into 4 consecutive key blocks of size 4^{h−1} in key order A < B < C < D. Let σ = 2413 be the simple permutation on 4 symbols, interpreted as the time order B, D, A, C. Define F_h as the concatenation
F_h := F_{h−1} restricted and scaled to B, then F_{h−1} on D, then on A, then on C.
Equivalently, the access-time index t ∈ {0,…,4^h−1} in base-4 encodes the path down the decomposition; the digit at position ℓ (counting from the top) indicates the child among {B,D,A,C} at scale ℓ.

Two structural properties:
- Key intervals at each node are contiguous, with key order A<B<C<D.
- Time order at each node is B, then D, then A, then C, each occupying a contiguous block of length 4^{ℓ} at scale ℓ.

# UB lower bound on F_h: a per-position scale witness that avoids overcounting

We show UB(F_h) = Θ(n log n) by proving E[UB_i] = Θ(h) for i uniformly random. The upper bound UB_i ≤ log(1+n) gives UB(F_h) ≤ n log n, so it suffices to prove UB(F_h) ≥ c n h.

Notation. Fix a level ℓ ∈ {0,…,h−1}. Let M_ℓ := 4^ℓ. At level ℓ, each node’s time block of length 4 M_ℓ is partitioned into 4 consecutive time-blocks, each of length M_ℓ, in order B, D, A, C. Within the D-block, define its first quarter prefix D^{(1)} to be its first M_ℓ/4 positions in time.

Crucial per-level event. For an access x_i occurring at time t, define E_ℓ as: “At level ℓ, t lies in the D-block and, inside that D-block, in its first quarter D^{(1)}.”

Two facts about E_ℓ (independence comes from the base-4 time decomposition):
- Pr[E_ℓ] = 1/16 for every ℓ, because (i) the level-ℓ digit equals D with probability 1/4, and (ii) among the M_ℓ positions in D, the prefix D^{(1)} has size M_ℓ/4.
- For distinct levels, the events {E_ℓ} are independent with respect to the time index t, since they depend on disjoint base-4 digit blocks of t.

Per-step lower bound conditioned on E_ℓ. Fix ℓ and suppose E_ℓ holds. Let s_ℓ ∈ {0,…,M_ℓ/4 − 1} be the offset of t inside D^{(1)} at level ℓ. Then, for every 1 ≤ j ≤ s_ℓ, the access at time t−j is inside the immediately preceding level-ℓ block in time, namely B. Because B and D are not adjacent in key (A<B<C<D), any key from B differs from any key in D by at least |C| = M_ℓ in key rank minus a constant; in particular there is a fixed constant c_0 > 0 such that for all 1 ≤ j ≤ s_ℓ, we have Δ_i(j) ≥ c_0 M_ℓ.
Consequently, for all 1 ≤ j ≤ s_ℓ,
j + Δ_i(j) ≥ max{ j, c_0 M_ℓ } ≥ s_ℓ,
and for j > s_ℓ we have j ≥ s_ℓ trivially. Therefore
min_{1≤j≤i−1} (j + Δ_i(j)) ≥ s_ℓ,
so UB_i ≥ log(1 + s_ℓ).

Distribution of s_ℓ given E_ℓ. Conditioned on E_ℓ, the offset s_ℓ is uniform on {0,…,M_ℓ/4 − 1}, because inside the D-block the first-quarter prefix is a contiguous time interval of length M_ℓ/4 and the lower ℓ base-4 digits of t range uniformly therein, independently of higher-level digits that determine which level-ℓ block we are in.
Therefore
E[ UB_i | E_ℓ ] ≥ (1/(M_ℓ/4)) ∑_{s=1}^{M_ℓ/4 − 1} log(1+s) ≥ c_1 log M_ℓ = c_1 · ℓ · log 4,
for a universal constant c_1>0 (by Stirling, the average of log(1+s) over s=1..Q is Θ(log Q)).

Amplifying via the highest level where E_ℓ holds. Let ℓ† be the maximum level in {0,…,h−1} such that E_ℓ holds for t (if none, set ℓ† = −∞). By independence across levels,
Pr[ℓ† = ℓ] = (1/16) · (15/16)^{(h−1)−ℓ},
so E[ℓ†] = ∑_{ℓ=0}^{h−1} ℓ · (1/16)(15/16)^{(h−1)−ℓ} = (h−1) − (15/16)/(1/16)^2 + o(1) = h − O(1).
Moreover, conditioning on ℓ† = ℓ does not affect the uniformity of s_ℓ because the restriction “no E_{ℓ′} for ℓ′ > ℓ” depends only on higher base-4 digits; the lower-ℓ digits determining s_ℓ remain uniform. Hence
E[ UB_i | ℓ† = ℓ ] ≥ c_1 log M_ℓ = c_2 · ℓ.
Taking expectations,
E[UB_i] ≥ ∑_{ℓ=0}^{h−1} Pr[ℓ† = ℓ] · E[UB_i | ℓ† = ℓ] ≥ c_2 · E[ℓ†] = c_3 h.
Summing over i yields UB(F_h) ≥ c_3 n h = c_3 n log_4 n = Θ(n log n).

Upper bound recap. Trivially UB_i ≤ log(1+n) for all i, so UB(F_h) ≤ n log(1+n) = O(n log n). Combining, UB(F_h) = Θ(n log n).

# BST side for F_h: k-decomposable implies Greedy is linear (to verify)

Claim to be verified. F_h is k-decomposable with k = 4 (every internal substitution node uses a fixed simple pattern of size 4). It is known that the Greedy geometric BST algorithm incurs cost O(n log k) on k-decomposable permutations; for constant k this is O(n). A version of this statement appears in the BST-geometry literature (Greedy upper bounds for decomposable permutations). We propose to locate and cite the precise theorem (attribution likely to Fox, 2011; Demaine et al., 2014), and then conclude OPT_BST(F_h) ≤ O(n).

If desired, we can also attempt a direct structural algorithm: maintain a top-level skeleton realizing the 4 contiguous blocks A,B,C,D; transitions follow B→D→A→C, and recursively within each block maintain the same invariant. A careful charging can bound rotations per access by a constant. We will draft this in a subsequent round if the Greedy citation is unavailable.

# Obstacles

- Bit-reversal upper bound remains unsettled. The identity rev(s)−rev(s−2^t) = 2^{h−1−t} gives only UB ≤ O(n log n) trivially; I do not yet have a matching O(n) upper bound. Numerics will guide the conjecture.
- For F_h, the UB lower bound above hinges on two independence facts: (i) E_ℓ events independent across levels (true via base-4 digit independence), and (ii) s_ℓ uniform conditioned on ℓ† = ℓ (also true since “no higher success” constraints only higher digits). Both should be straightforward to formalize carefully.
- BST side: we need a precise, citable statement that Greedy cost is O(n log k) on k-decomposable permutations, or otherwise produce a tailored algorithm. Without this, we have only the UB half of the separation.

# Next steps

1) Bit-reversal numerics and bounds: compute UB exactly for n = 2^h, h up to 14–16, verify whether UB/n stabilizes to a constant; attempt to prove an O(n) upper bound using a better j-witness than j = 2^t (e.g., show existence of j in [2^t, c·2^t] with |Δ| ≤ c·2^t via bit-pattern arguments).
2) F_h UB proof: write a formal proof from the sketch above, with explicit mapping between time base-4 digits and the E_ℓ events; produce a clean lemma stating Pr[ℓ† = ℓ] and E[log(1+s_ℓ)|ℓ†=ℓ]. This is ready for proofs.md.
3) BST side for F_h: locate the Greedy-on-k-decomposable-permutations theorem and record its precise statement and hypotheses; verify that F_h satisfies them. If citation is elusive, begin drafting a bespoke BST algorithm with a provable O(n) bound exploiting the 4-block recursive structure.
4) If Greedy gives only O(n log 4) = O(n), we obtain a strong separation: OPT_BST(F_h) ≤ C n while UB(F_h) ≥ c n log n.

# Summary of progress

- Fixed the bit-reversal analysis: provided a rigorous Ω(n) lower bound via the rev(s)−rev(s−2^t) identity; withdrew the incorrect Θ(n log n) claim; outlined an approach for an O(n) upper bound (to be validated numerically and then by bit-pattern witnesses).
- Defined the fractal 2413 family F_h (n = 4^h) and proved UB(F_h) = Θ(n log n) by a new scale-witness argument relying on the D-vs-B time/key separation at each level; this overcomes the “first-arrival only” bottleneck that previously gave only O(n).
- Identified the BST route via k-decomposability (k=4) to argue OPT_BST(F_h) = O(n), pending a precise literature citation or a direct construction.
- Outlined concrete next steps to firm up both halves and produce the desired strong separation.


=== Prover 2 Output ===

Ideas

- Abandon round-robin blocks: the previously claimed UB lower bound is false due to adjacent-block, previous-round witnesses. In fact, UB is often O(log k) there. I will not pursue that family.
- Replace it with a recursively interleaved “2413-inflation” family F_h on n=4^h keys. Crucial properties: (i) block contiguity in key order; (ii) time order at each node is 2,4,1,3; (iii) the first element of each child’s block is the child’s midpoint. This prevents adjacent-in-key recent witnesses from being too close.
- UB side: I prove a clean Ω(n log n) lower bound by charging only at child-boundary steps, exactly 3 per internal node of the 4-ary decomposition; the midpoint choice yields a uniform per-boundary lower bound log(Ω(block size)). Summing over all nodes gives Θ(n log n).
- BST side: I prove Wilber-1 = O(n) for F_h with respect to a tailored static reference tree aligning with the decomposition (split halves {1,2} vs {3,4} at each node). Tango trees then give an explicit algorithm with cost O(n log log n), hence OPT_BST ≤ O(n log log n). This already yields a separation OPT/UB = O(log log n / log n) = o(1).

Definitions (the fractal family F_h)

- Let n=4^h. For any interval I=[a..b] with |I| a power of 4, split I into four contiguous, equal subintervals I1<I2<I3<I4. Define midpoint m(I) := ⌊(a+b)/2⌋.
- F_0(I): the unique element of I.
- For t≥1, define F_t(I) as the concatenation of
  S2 := F_{t-1}(I2), then S4 := F_{t-1}(I4), then S1 := F_{t-1}(I1), then S3 := F_{t-1}(I3),
  with the inductive constraint that for every t and every interval J of size 4^t, the first element emitted by F_t(J) is m(J) (this is consistent since F_{t-1}(Jk) starts at m(Jk)).
- Define π_h := F_h([1..4^h]). For general n, take h=⌊log_4 n⌋, use the first 4^h keys, and append the O(n−4^h) tail arbitrarily; this affects UB and OPT by at most O(n), negligible asymptotically.

UB lower bound for π_h

Notation. Let T be the 4-ary decomposition tree; each internal node v corresponds to an interval I_v of size s_v, partitioned into four equal contiguous subintervals I_v(1)<I_v(2)<I_v(3)<I_v(4). The time order inside I_v is S2,S4,S1,S3, where Sk is the subsequence F on I_v(k).

Key structural fact. For each internal v, the subsequence restricted to I_v is exactly the concatenation S2∘S4∘S1∘S3. Each Sk consists of all keys in I_v(k), and no key of I_v(k) appears outside Sk.

Lemma 1 (First-of-child midpoint separation). Fix any internal node v and a child index k∈{1,2,3,4}. Let x be the first key of Sk. Then for any key y∉I_v(k), we have |x−y| ≥ s_v/8.
Proof. The child interval I_v(k) has length s_v/4. Its midpoint x is at distance at least s_v/8 from either boundary of I_v(k). If y lies outside I_v, then |x−y| is at least the distance from x to the nearest boundary of I_v, which is ≥ s_v/8. If y lies in a sibling I_v(k′), the closest such y is at the boundary between I_v(k) and I_v(k′) when k′ is adjacent to k; the distance from x to that boundary is ≥ s_v/8, and non-adjacent siblings are even farther. ∎

Lemma 2 (Per-boundary UB). Let i be the time index of the first element of Sk at node v (i.e., the boundary S?→Sk within I_v). Then
UB_i(π_h) = log(1 + min_{j≤i−1} ( j + |x_i − x_{i−j}| )) ≥ log(1 + s_v/8).
Proof. At time i, no earlier access lies in I_v(k), so all earlier y lie in I_v\I_v(k) or outside I_v. By Lemma 1, for all earlier y we have |x_i−y| ≥ s_v/8. Thus for every j, j+|x_i−x_{i−j}| ≥ s_v/8, so the minimum is ≥ s_v/8. ∎

Counting boundaries. For each internal v, the restricted sequence S2∘S4∘S1∘S3 has exactly three boundaries (S2→S4, S4→S1, S1→S3), each witnessed at a unique global time index i(v,·). Therefore the set of such boundary indices over all v has total cardinality 3·|Int(T)|, where |Int(T)| = (4^h−1)/3.

Theorem 3 (UB lower bound). There exists a universal constant c>0 such that
UB(π_h) ≥ c · n · log n.
Proof. Summing Lemma 2 over all boundaries and using logs base 2,
UB(π_h) ≥ ∑_{v internal} 3·log(1 + s_v/8) ≥ ∑_{v internal} (3·(log s_v − 3))
= 3∑_{ℓ=0}^{h−1} 4^ℓ ( (h−ℓ)·log 4 ) − O(∑_{ℓ=0}^{h−1}4^ℓ)
= Θ( (∑_{ℓ} 4^ℓ)·h ) − O(4^h)
= Θ( n · h ) = Θ( n · log n ). ∎

Remarks.
- The midpoint constraint is crucial; it defeats the adjacent-sibling counterexample (which broke the round-robin scheme) by ensuring the first key of a new child is at distance ≥ s_v/8 from any already visited key in that parent’s scope and from keys outside the parent as well.
- We only used one access per child-boundary per node; no double counting occurs because each such boundary occurs at a distinct global time.

BST side: Wilber-1(T_ref) = O(n) and Tango upper bound

We select a static reference BST T_ref tailored to the decomposition.

Construction of T_ref. Recursively, for an interval I_v with children I_v(1)<I_v(2)<I_v(3)<I_v(4), make a BST node splitting I_v into L_v := I_v(1)∪I_v(2) and R_v := I_v(3)∪I_v(4) at the (unique) pivot separating L_v and R_v. Recurse on L_v and R_v. Fill to a full BST by any binary splits internal to the contiguous subintervals (these extra nodes may contribute at most O(1) alternations each; see below).

Lemma 4 (Alternations at decomposition splits). For any internal v, restricted to I_v, the left/right partition L_v vs R_v is visited in the order L_v, R_v, L_v, R_v (because the child order is 2,4,1,3), hence the alternation count contributed at this node is exactly 3.
Proof. S2⊂L_v, S4⊂R_v, S1⊂L_v, S3⊂R_v and no interleaving occurs across these four blocks at node v. ∎

Lemma 5 (Total Wilber-1 bound). The sum of alternations over all nodes of T_ref is O(n).
Proof. Each internal decomposition split contributes exactly 3 by Lemma 4, and there are (4^h−1)/3 such splits, giving O(n). The additional filler nodes split contiguous segments that the sequence traverses monotonically (as a single block) at that scale, so each such node sees at most one alternation. The number of filler nodes is O(n), hence their total adds O(n). ∎

Corollary 6 (BST upper bound via Tango). The Tango tree achieves an O(log log n) approximation of Wilber-1, hence there is an explicit BST algorithm with cost O(W_1·log log n) = O(n log log n). Therefore
OPT_BST(π_h) ≤ O(n log log n).

Combining with Theorem 3 yields the desired separation:
OPT_BST(π_h) / UB(π_h) = O(log log n / log n) = o(1).

Examples and sanity checks

- h=1 (n=4). π_1 over blocks I1<I2<I3<I4 is the order I2, I4, I1, I3. There are three child-boundaries at the root; each first key of a child is its midpoint, so each boundary contributes UB_i ≥ log(1 + 4/8) ≥ 1 (constant); the sum is Θ(log 4)=2, consistent with Θ(n log n)=Θ(4·2). Small-n constants are noisy, but the per-boundary mechanism is visible.
- h=2 (n=16). The root contributes three terms of size ≈ log(16/8)=log 2=1; its four children each contribute three terms of size ≈ log(4/8)=0 (truncated at log 1 in exact arithmetic), showing that small blocks contribute little, while large blocks supply the logarithmic mass. As h grows, the sum over all internal nodes concentrates around levels where s_v is large, yielding Θ(n log n).

Obstacles and discussion

- The midpoint constraint must be enforced at every scale (we baked it into the recursion). Without it, adjacent-in-key siblings (e.g., 1 vs 2 at a node) could produce Δ=O(1) witnesses and destroy the per-boundary lower bound.
- The UB lower bound uses only O(n) carefully chosen steps (child-boundaries). This skirts the double-counting pitfall: while many “first visits” at different scales coincide, each global step i is associated with a unique deepest node v(i) where the child changes, and we charge that boundary only.
- For the BST upper bound, I used Tango rather than Greedy. If one can show that Greedy (or a tailored algorithm) achieves O(n) on π_h (e.g., for permutations whose substitution decomposition uses only simple nodes of size ≤4), we would obtain the strong separation O(n) vs Ω(n log n). I do not claim that here; I instead rely on the standard O(log log n)-competitive guarantee of Tango w.r.t. Wilber-1.

Next steps

1) Strengthen the BST upper bound. Attempt to prove OPT_BST(π_h)=O(n). Two avenues: (a) prove that Greedy runs in O(n) on permutations whose substitution decomposition uses only 4-sized simple nodes (2413/3142); or (b) design an explicit rotation-on-search-path algorithm maintaining a decomposition-aware invariant that serves each boundary with O(1) amortized cost.
2) Validate numerically. Compute UB(π_h)/(n log n) for h up to, say, 10 and measure Tango’s cost in simulations to calibrate constants.
3) DFS UB=O(n). Provide a clean proof or citation (e.g., charge log-gaps to subtree sizes along the traversal). This is orthogonal but useful for the broader landscape.
4) Explore variants. The 2413 order is one choice; 3142 works similarly. Examine whether mixing these at nodes preserves UB=Θ(n log n) and W_1=Θ(n).

Summary of proven contributions

- Defined an explicit family π_h (n=4^h) via recursive 2413-inflation with midpoint-first children.
- Proved UB(π_h) ≥ c n log n by charging at child-boundary steps (Lemma 2 and Theorem 3).
- Constructed a reference BST with Wilber-1(π_h)=O(n) (Lemmas 4–5), hence OPT_BST(π_h) ≤ O(n log log n) via Tango.
- This yields OPT_BST(π_h) = o(UB(π_h)), solving the separation task (not yet in the strongest O(n) form).