=== SYSTEM ===
You are a strict mathematical verifier & research manager.

You are being run in a loop with provers. Your tasks:
- Audit their ideas for correctness and rigor.
- Curate files (notes.md, proofs.md, and output.md).
- Suggest the next steps.

Inputs: 
- task statement
- outputs of provers
- notes.md (informal progress & exploratory work so far)
- proofs.md (rigorous proofs & detailed mathematics so far)
- output.md (main results found so far)

**Three-tier file system guidelines**:
- **notes.md**: Readable running log of exploratory work, intuitions, failed attempts, ideas. Prefer appending. Replace only if old notes are clearly misleading. Should be self-contained.
- **proofs.md**: Complete rigorous mathematical proofs with full details. Think twice before adding anything. Contains proven lemmas, theorems, and detailed derivations. Only add mathematically verified content here.
- **output.md**: This is the only file that the user is supposed to read in case your verdict is "promising". It has to be self-contained. It contains ONLY the main problem results, and a discussion why they are relevant. It is extremely selective. Think twice before promoting proofs from proofs.md to output.md. Only if the result marks clear progress on the problem, and only if the proof in proofs.md has been thoroughly vetted by provers and you, it can join output.md. Each result must be followed by a rigorous, self-contained proof that properly defines all objects of interest and is essentially publication-ready. 

Tasks:
1) Audit rigor: identify unjustified steps, false statements, missing lemmas; produce minimal counterexamples.
2) Triage value: separate genuine progress from noise.
3) Guide next steps: propose what provers should try next.

**Return strictly JSON**:
{
  "feedback_md": "Detailed critique of prover outputs (≥200 words). Include concrete next-step suggestions.",
  "summary_md": "Concise summary of this round's work for summarizer.",
  "verdict": "promising|uncertain|unlikely",
  "blocking_issues": ["List of issues preventing progress"],
  "per_prover": [{"prover_id": "01", "brief_feedback": "feedback", "score": "promising|uncertain|unlikely"}],
  "notes_update": {"action": "append|replace", "content": "Markdown for notes.md"},
  "proofs_update": {"action": "append|replace", "content": "Markdown for proofs.md"}, 
  "output_update": {"action": "append|replace", "content": "Markdown for output.md"}
}

**Verdict definitions**:
- **promising**: Significant mathematical progress, publishable results
- **uncertain**: Some progress you deem nontrivial, but with unresolved issues or incomplete reasoning  
- **unlikely**: No meaningful progress, fundamentally flawed approaches, or just exploratory work

**Update guidelines**:
- Use null for any update field you don't want to modify
- notes_update: Include informal reasoning, failed attempts, intuitions, exploratory work
- proofs_update: Only include complete, rigorous proofs that you have verified
- output_update: Only include main problem results that directly advance toward the solution


=== USER ===
=== Task (txt) ===

# Permutation UB-vs-OPT Separation Problem

**Universe.** Keys are $[n]=\{1,2,\dots,n\}$ with the usual order.
An **instance** is a permutation $\pi=(x_1,\dots,x_n)$ of $[n]$.

## 1) Unified-bound cost on a permutation

For each time $i\in\{1,\dots,n\}$:

* Let $R_i(1),R_i(2),\dots,R_i(i-1)$ be the previously accessed keys ordered by **recency** (so $R_i(1)=x_{i-1}$, $R_i(2)=x_{i-2}$, …).
* Define the **rank distance** $\Delta_i(j) := |\,x_i - R_i(j)\,|$.
* The **per-access unified charge** is

  $$
  \mathrm{UB}_i(\pi)\;:=\;\log\!\Big(1+\min_{1\le j\le i-1}\big(j+\Delta_i(j)\big)\Big),
  $$

  with the convention $\mathrm{UB}_1(\pi):=\log(1+n)$.

The **total unified-bound cost** is

$$
\mathrm{UB}(\pi):=\sum_{i=1}^n \mathrm{UB}_i(\pi).
$$

*(Remarks: logs are base 2; constants are irrelevant for asymptotics. Because $\pi$ is a permutation, “working-set number” equals the recency rank $j$, so this is the standard unified bound specialized to permutations.)*

## 2) Optimal dynamic BST cost on a permutation

We use the standard **dynamic BST model**:

* The algorithm maintains a binary search tree $T$ over $[n]$.
* To access $x_i$, it traverses parent/child pointers from the root to $x_i$; pointer moves and comparisons along the search path each cost 1.
* After (or during) the access, it may perform any number of **rotations**, each costing 1.
* The initial tree is a fixed balanced BST on $[n]$. (Allowing an arbitrary offline choice changes costs by at most an additive $O(n)$ and doesn’t affect asymptotics for this problem.)

For a permutation $\pi$, the **cost of an algorithm $\mathcal A$** is the sum of search-path lengths plus rotations over the $n$ accesses. The **optimal BST cost** is

$$
\mathrm{OPT}_{\mathrm{BST}}(\pi):=\min_{\mathcal A}\;\text{cost}_{\mathcal A}(\pi).
$$

## 3) The separation task

Find an infinite family of permutations $\{\pi_n\}_{n=1}^\infty$, $\pi_n\in S_n$, such that

$$
\mathrm{OPT}_{\mathrm{BST}}(\pi_n)\;=\;o\!\big(\mathrm{UB}(\pi_n)\big)
\quad\text{as }n\to\infty.
$$

A **strong separation** would meet, for some constants $c,C>0$,

$$
\mathrm{OPT}_{\mathrm{BST}}(\pi_n)\;\le\; C n
\qquad\text{and}\qquad
\mathrm{UB}(\pi_n)\;\ge\; c\,n\log n,
$$

i.e., $ \mathrm{OPT}_{\mathrm{BST}}(\pi_n) / \mathrm{UB}(\pi_n) = O(1/\log n)$.

*(Equivalently, in per-access terms: find $\pi_n$ with average BST cost $o(1)\cdot$UB’s average, e.g. $O(1)$ vs $\Omega(\log n)$.)*




=== Notes ===

# Research Notes



# Corrections and guidance

- Bit-reversal UB lower bound (Prover 1): The argument via t = ν2(i−1) shows UB_i ≥ log(min{2^t, 2^{h−t−1}}) = min{t, h−t−1} − O(1). With Pr[t=k]=2^{−(k+1)}, we have E[min{t,h−t−1}] = ∑_{k=0}^{h−1} 2^{−(k+1)} min{k, h−k−1} = O(1). Therefore this line of reasoning yields only UB(π) = Ω(n), not Ω(n log n). The step claiming Θ(h) per step is incorrect.

- DFS UB = Θ(n) (Prover 1): The sketch using UB_i ≤ log(2 + |x_i − x_{i−1}|) is plausible but needs a clean proof. Suggested route: charge log differences to subtree sizes along the DFS traversal and show ∑_v O(log size(v)) = O(n).

- Round-robin block construction (Prover 2): The per-step lower bound min_j (j + |x_i − x_{i−j}|) ≥ ⌊b/2⌋ for all i beyond the first round is false. Counterexample pattern (general b): choose within-block σ_b with (c_2, c_3) = (1, b). For any block B_r at round t=3, let s be the adjacent block that comes after r in ρ_k. Then the last access to B_s was at round t=2 with key c_2=1, so Δ = b + c_2 − c_3 = 1. The corresponding j equals k + pos(r) − pos(s) − 1 ≤ k−1, hence j + Δ ≤ k. When k ≪ b, this is < b/2, contradicting the claimed bound. In fact, many t produce such small witnesses, so UB_i can be O(log k) frequently.

- Fractal 2413 family (Prover 1): BST side is promising if we can cite or prove that Greedy runs in O(n) on permutations whose substitution decomposition uses only simple nodes of size ≤ 4. The UB lower bound must be scale-based: for many i, show that all candidates among the last L (for L ≈ the size of a relevant block scale) are far in key, so min_j (j+Δ) = Ω(L), giving UB_i = Ω(log L). The naive “first-arrival per block” charge yields only O(n) total and is insufficient.

- Next steps:
  1) Provide a rigorous DFS UB=O(n) proof or a citation.
  2) Correct the bit-reversal UB claim; add numerical UB for n = 2^h up to h ≈ 14–16.
  3) For F_h, (a) verify/cite Greedy’s O(n) bound for k-decomposable (k=4), (b) develop and prove a proper scale-based UB lower bound, and (c) compute UB empirically for h up to 8–10.
  4) Abandon the round-robin block family for UB ≈ n log(n/k); its structure lets adjacent-block, previous-round witnesses keep UB_i = O(log k) too often.


New candidate family and fix to UB lower bound

- Adopt the recursively interleaved 2413-inflation family π_h on n=4^h keys with the midpoint-first constraint: at every interval J of size 4^t, the first key emitted by F_t(J) is the midpoint m(J); and at each node, the time order of children is 2,4,1,3.
- UB lower bound strategy: charge only at child-boundary steps within each node’s restricted sequence (S2→S4, S4→S1, S1→S3). At the first key of a child, all previous accesses are outside that child; the midpoint ensures a rank-distance ≥ s_v/8 to any earlier key, where s_v is the parent interval size. Thus UB_i ≥ log(1 + s_v/8) at those steps.
- Counting without double counting: each consecutive pair (x_{i−1}, x_i) has a unique lowest common ancestor v in the 4-ary decomposition tree; this pair coincides with exactly one such boundary at v. Hence the boundary times over all nodes are disjoint and total n−1.
- Summing over nodes gives UB(π_h) ≥ Θ(n log n); the trivial UB ≤ n log n yields UB(π_h) = Θ(n log n).
- BST side: choose a static reference BST that recursively splits {I1∪I2} vs {I3∪I4}. At each decomposition node, the restricted sequence is L,R,L,R, so exactly 3 alternations. Filling contiguous intervals into a full BST contributes O(1) alternations per filler node. Hence Wilber-1 = O(n). Tango yields an explicit algorithm with cost O(n log log n).
- Correction: The earlier per-level event argument (choosing t in the first quarter of D and claiming t−j lies in B for j ≤ s) is false; those t−j remain in D. The boundary/LCA charging avoids this pitfall.
- Next: formalize the LCA-based bijection and the filler-node alternation accounting; attempt to improve OPT to O(n) (Greedy or tailored BST).


=== Current Output ===

# Main Results



Result: An explicit permutation family with UB = Θ(n log n) and OPT_BST ≤ O(n log log n)

Setup
- Let n = 4^h. Define a permutation π_h by recursively partitioning [1..n] into four equal contiguous key blocks I1<I2<I3<I4. The time order at each node is 2,4,1,3 (2413 inflation). Impose the midpoint-first constraint: for every interval J of size 4^t, the first key emitted by its subsequence is the midpoint m(J).

Unified-bound lower bound
- For an internal node v with interval size s_v, at the time i when the sequence first enters a child block within v (i.e., at boundaries S2→S4, S4→S1, S1→S3), the accessed key x_i is the midpoint of that child. No earlier access lies in that child, hence every earlier key y is outside it. The midpoint is at rank-distance ≥ s_v/8 from any such y. Therefore UB_i ≥ log(1 + s_v/8).
- Each pair of consecutive accesses (x_{i−1}, x_i) has a unique lowest common ancestor v in the 4-ary decomposition tree; within v’s restricted sequence this pair occurs at one of the three child-boundaries. These boundary indices over all v are pairwise distinct and total n−1.
- Summing UB_i over these n−1 indices yields ∑_v 3·log(1 + s_v/8). There are 4^ℓ nodes at level ℓ with s_v = 4^{h−ℓ}; thus the sum is Θ(∑_{ℓ=0}^{h−1} 4^ℓ (h−ℓ)) = Θ(n log n). Since trivially UB(π_h) ≤ n log(1+n), we conclude UB(π_h) = Θ(n log n).

BST upper bound
- Fix a static reference BST T_ref that, at each node of the decomposition, splits keys into L := I1∪I2 and R := I3∪I4 and recurses; fill contiguous subintervals arbitrarily to form a full BST. For any decomposition node, the restricted sequence visits L and R in the pattern L,R,L,R, so exactly 3 alternations occur at that partition. Filler nodes on contiguous intervals contribute at most one alternation each. Hence Wilber-1(T_ref, π_h) = O(n).
- Tango trees achieve cost O(W_1 · log log n) against any fixed reference tree. Therefore there is an explicit BST algorithm with total cost O(n log log n) on π_h, implying OPT_BST(π_h) ≤ O(n log log n).

Conclusion
- The family {π_h} yields UB(π_h) = Θ(n log n) while OPT_BST(π_h) ≤ O(n log log n). Consequently OPT_BST(π_h) / UB(π_h) = O(log log n / log n) = o(1), providing the requested separation (not yet the strongest O(n) vs Ω(n log n)).


=== Prover 1 Output ===

# Overview

We correct and sharpen several key points, provide rigorous bounds where feasible, and isolate a flaw in the current UB lower-bound strategy for the 2413-inflation family. We also prove that random permutations have UB = Ω(n log n) in expectation, clarifying what structural feature is needed to achieve large UB. Finally, we give a precise Wilber-1 = Θ(n) bound for the tailored reference tree on the 2413-inflation family, which remains algorithmically promising but does not yet yield a UB = Θ(n log n) lower bound.

# Part I: UB lower bound via “child-boundaries” only gives Θ(n), not Θ(n log n)

Setup. Let n = 4^h. Consider the recursively defined 4-ary decomposition of [1..n] at each level into contiguous blocks A<B<C<D, with time order 2,4,1,3 at every node (2413-inflation). Impose the midpoint-first constraint inside each block: the first key in a child’s restricted subsequence is the midpoint of that child’s key interval.

Definition (child-boundary times). At any internal 4-ary node v with interval size s_v, the restricted sequence on v’s keys is the concatenation (B,D,A,C), each a contiguous block. The three transitions 2→4, 4→1, 1→3 are the “child-boundary” times at v.

Claim A (midpoint separation at boundaries). At a boundary time i at node v (first access into the new child), all previous accesses lie outside that child. Since the accessed key is the child midpoint, its rank distance to any previous key is at least s_v/8. Hence UB_i ≥ log(1 + s_v/8).

This part is correct. The counting step, however, has a crucial quantitative issue.

Fact B (disjointness and count). Each consecutive pair (x_{i−1}, x_i) has a unique lowest common ancestor (LCA) in the 4-ary decomposition; within that ancestor’s restricted sequence, the pair appears at exactly one child-boundary. Thus the boundary times over all nodes are disjoint and number exactly n−1 (three per internal node, and the number of internal nodes is (n−1)/3).

Summation. Summing Claim A over all boundaries gives
∑_i UB_i ≥ ∑_{v internal} 3·log(1 + s_v/8) = Θ(∑_{ℓ=0}^{h−1} 4^ℓ · (h−ℓ)) = Θ(n).
Indeed, with s_v = 4^{h−ℓ} and 4^ℓ nodes at level ℓ,
∑_{ℓ=0}^{h−1} 4^ℓ (h−ℓ) = 4^h ∑_{t=1}^{h} t/4^t = Θ(4^h) = Θ(n).

Conclusion 1. The child-boundary charging yields UB(π) = Ω(n), not Ω(n log n). This matches the earlier warning that “one first-arrival per block per scale” only achieves O(n) total. Thus the UB = Θ(n log n) claim from boundary events alone is incorrect.

# Part II: A precise Wilber-1 = Θ(n) bound for the tailored reference tree

We formalize the Wilber-1 bound for the above 2413-inflation family using a reference BST T_ref that mirrors the 4-ary decomposition with three binary splits per 4-ary node.

Construction of T_ref. For each 4-ary node v with children A<B<C<D:
- Introduce a binary node u_v splitting L := A∪B vs R := C∪D.
- In u_v’s left subtree, add a node splitting A vs B; in the right subtree, add a node splitting C vs D.
- Recurse inside each of A,B,C,D identically.
This yields a BST over [n] whose internal nodes are in bijection with the set of “adjacent-block” binary splits at every 4-ary node (three per 4-ary node).

Wilber-1 definition. For a fixed BST T_ref and access sequence, W_1(T_ref) is the sum, over all internal nodes w of T_ref, of the number of alternations between the left and right sides of w along the access sequence restricted to keys in w’s subtree.

Lemma 2. For the 2413-inflation sequence,
- At node u_v (split L vs R), the alternation count is exactly 3, because the restricted sequence at v is L,R,L,R (B,D,A,C), with each block contiguous.
- At the A-vs-B split (left child of u_v), the restricted sequence is B then A, giving exactly 1 alternation.
- Similarly at the C-vs-D split, the restricted sequence is D then C, giving exactly 1 alternation.
Recursive independence: Within each child, the alternation count at these nodes is determined solely by the top-level block order at that node; deeper recursion does not create additional alternations at these nodes because within each child block all keys belong to the same side with respect to these splits.

Therefore each 4-ary node contributes 3+1+1 = 5 alternations, independently of block size. There are (n−1)/3 internal 4-ary nodes, hence
W_1(T_ref) = 5 · (n−1)/3 = Θ(n).

Corollary 3. Tango trees achieve total cost O(W_1(T_ref) · log log n) = O(n log log n) on this family. Consequently OPT_BST(π) ≤ O(n log log n). This yields a nontrivial but non-strong separation only if we can show UB(π) = Ω(n log n), which the boundary-only UB argument does not establish.

# Part III: Random permutations have UB = Ω(n log n) in expectation

We prove a clean, self-contained lower bound showing that for a uniform random permutation, the unified bound is Ω(n log n) in expectation. This clarifies the mechanism needed for large UB: recent windows often contain no keys close to the current key in rank.

Lemma 4 (window emptiness around x_i with constant probability). Fix i ∈ {⌊n/2⌋,…,n}. Let t := ⌊√n⌋ and r := ⌊α·n/t⌋ for a sufficiently small constant α ∈ (0,1/4). Condition on x_i. The previous t accesses x_{i−1},…,x_{i−t} are t distinct, uniformly random elements of [n]\{x_i, other earlier positions}. Then
Pr[ for all 1 ≤ j ≤ t, |x_{i−j} − x_i| ≥ r ] ≥ exp(−Θ(α)),
by a standard occupancy/independence estimate: the window of size at most 2r around x_i contains at most 2r keys, and the probability that none of the t distinct uniformly random keys falls in this window is
((n−1−2r) choose t)/((n−1) choose t) ≥ (1 − 2r/(n−1))^t ≥ exp(−4α + o(1)).

Lemma 5 (UB_i lower bound from window emptiness). On the event in Lemma 4, for all j ≤ t we have Δ_i(j) ≥ r, hence j + Δ_i(j) ≥ r; for j > t we have j ≥ t. Therefore min_j (j + Δ_i(j)) ≥ min{ r, t }.
With r = α·n/t and t = ⌊√n⌋, we get min{ r, t } ≥ c·√n for some constant c>0. Hence
UB_i ≥ log(1 + c·√n) ≥ (1/2) log n − O(1).

Theorem 6. For a uniform random permutation π on [n], E[UB(π)] ≥ c′ n log n for some c′>0.
Proof. For i from ⌊n/2⌋ to n, Lemmas 4–5 give E[UB_i] ≥ p · ((1/2) log n − O(1)) with p a positive constant. Summing over Θ(n) such i yields E[UB(π)] ≥ c′ n log n.

Remark. This also implies that the maximum UB over permutations is at least Ω(n log n). However, random permutations are hard for BSTs (Wilber lower bounds Θ(n log n)), so they do not give a separation.

# Part IV: Why the 2413-inflation family likely has only UB = Θ(n)

Intuition and obstruction. In the 2413-inflation family, each block at every level is visited contiguously in time. Consequently, for any i, the last t accesses for any t up to the number of prior accesses within the current block lie entirely within that block. Thus the “nearby in time” witnesses come from the same block. To force a UB_i ≈ Ω(log s) at scale s, we would need that every key among those last t (within the block) is far in key from x_i, uniformly over a window t ≈ Θ(s), for many i. But within the block, the order is highly structured (and, if preorder-like, it keeps producing closer and closer neighbors as recursion deepens). The boundary-only charging captures the earliest positions in each block (when no in-block predecessors exist) and yields only Θ(n) total as established in Part I.

Conjecture 7 (to target). For any permutation π that is a hierarchical contiguous concatenation at all scales (e.g., defined by a fixed finite simple inflation pattern like 2413), we have UB(π) = O(n). This would explain the failure of boundary-only approaches and aligns with the DFS UB intuition. A proof strategy would be to bound UB_i by log(2 + |x_i − x_{i−1}|) and show that ∑ log(2 + |x_i − x_{i−1}|) = O(n) for such hierarchically concatenated orders by charging to block sizes across scales; we plan to formalize this next.

# Part V: Next steps (precise, auditable)

1) Formalize the Wilber-1 bound.
   - Write the exact mapping from 4-ary nodes to the binary nodes in T_ref and prove Lemma 2 rigorously: alternations per node are exactly 3,1,1.
   - Conclude W_1(T_ref) = 5·(n−1)/3.

2) UB(π) = O(n) for hierarchical concatenations.
   - Prove: If a permutation is obtained by recursively concatenating k constant-size blocks at each node, then ∑_i log(2 + |x_i − x_{i−1}|) = O(n). Provide an explicit charging scheme to block sizes across levels. This gives UB(π) ≤ O(n) and resolves the 2413-inflation family’s UB claim.

3) Random UB lower bound write-up.
   - Move the Lemma 4–5 proof into proofs.md with precise constants and handle boundary effects (e.g., near x_i close to 1 or n) by ignoring O(1) endpoints.

4) Search for a new candidate family.
   - The “low alternation at all scales” condition appears incompatible with UB = Θ(n log n). We should instead target a family where Wilber-1 is O(n) for some carefully chosen reference tree that may vary with the instance (still allowed for Tango with O(n log log n) overhead) but where within each time-contiguous block the order is “spread-out” enough to yield Ω(s log s) UB per block. The obstacle is that internal nodes of T_ref inside a block will then incur many alternations, driving W_1 up; we need a principled way (or a new algorithm) to avoid this.

5) DFS UB = O(n) proof.
   - Provide a clean, rigorous proof (or a citation) that for preorder/postorder traversals, ∑ log(2 + |x_i − x_{i−1}|) = O(n), by charging to subtree sizes. This will be carried out next round.

# Summary

- The child-boundary UB charging for the 2413-inflation family yields only UB = Θ(n), not Θ(n log n); we provided the exact summation demonstrating Θ(n).
- We established a precise W_1(T_ref) = Θ(n) bound for a tailored static reference tree on the same family, implying a Tango cost O(n log log n).
- We proved that random permutations satisfy E[UB] = Ω(n log n) via a simple window-of-last-√n argument. This clarifies what “large UB” structurally requires.
- We conjecture that hierarchical contiguous concatenations (including 2413-inflation with midpoint-first) have UB = O(n), suggesting this path will not yield the desired strong separation. Next, we will (i) formalize W_1 and (ii) prove the DFS/hierarchical UB upper bounds rigorously, and (iii) pivot to constructing families that can simultaneously have large UB and small BST cost under a more sophisticated algorithmic analysis (or show incompatible constraints).


=== Prover 2 Output ===

Ideas

- We work with a recursively interleaved 2413-inflation family π_h on n = 4^h keys, with a midpoint-first constraint at every node. This avoids the adjacent-block previous-round witnesses that invalidated the round-robin construction.
- Goal this round: give clean, rigorous proofs of (i) a UB lower bound UB(π_h) = Θ(n log n) via charging only at child-boundary steps, and (ii) a Wilber-1 bound W1(π_h,T_ref) = O(n) for a fixed balanced reference BST that mirrors the 4-ary decomposition. Tango then gives OPT_BST(π_h) ≤ O(n log log n), yielding o(1) separation.

Formal setup: the permutation family

- Let n = 4^h. For any integer interval I = [a..b] with |I| = 4^t, define the four equal contiguous subintervals I(1) < I(2) < I(3) < I(4). Let m(I) := ⌊(a+b)/2⌋.
- Define F_0(I) = (a) (the single key).
- For t ≥ 1, define F_t(I) as the concatenation S2 ∘ S4 ∘ S1 ∘ S3, where Sk := F_{t−1}(I(k)), with the invariant that the first element of F_{t−1}(J) equals m(J) for any |J| = 4^{t−1} (this holds by induction). In particular, the first element of each Sk is m(I(k)).
- Define π_h := F_h([1..4^h]). This is a permutation of [n]. Every node in the 4-ary decomposition tree has size s_v = 4^t for some t; its children have size s_v/4 and appear contiguously in time in the order 2,4,1,3.

UB lower bound via child-boundaries

Lemma 1 (Midpoint separation). Let v be an internal node with interval I_v of size s_v = 4^t, and let k ∈ {1,2,3,4}. Let x be the first key of Sk = F_{t−1}(I_v(k)), which equals m(I_v(k)). For any key y ∉ I_v(k), we have |x − y| ≥ s_v/8.
Proof. The child interval I_v(k) has length s_v/4. Its midpoint x is at distance exactly s_v/8 from each boundary of I_v(k) (since s_v is a multiple of 4). Any y in an adjacent sibling lies beyond the boundary between I_v(k) and that sibling, hence |x−y| ≥ s_v/8. If y is in a nonadjacent sibling or outside I_v altogether, the nearest such y is no closer than the nearest boundary of I_v(k), yielding the same bound. ∎

Definition (child-boundary times). For an internal node v, its restricted sequence is S2 ∘ S4 ∘ S1 ∘ S3. Define the child-boundaries at v to be the global time indices i at which the sequence transitions S2→S4, S4→S1, S1→S3. Equivalently, at such i, x_i is the first element of F_{t−1}(I_v(k)) for k ∈ {4,1,3} respectively.

Lemma 2 (Per-boundary UB). If i is a child-boundary time at v, then
UB_i(π_h) = log(1 + min_{j≤i−1} ( j + |x_i − x_{i−j}| )) ≥ log(1 + s_v/8).
Proof. At time i, no earlier access lies in I_v(k), hence by Lemma 1 we have |x_i − x_{i−j}| ≥ s_v/8 for all j. Therefore j + |x_i − x_{i−j}| ≥ s_v/8 and the claim follows. ∎

Lemma 3 (Counting child-boundaries; LCA bijection). Let B_h be the set of all child-boundary times over all internal nodes of the 4-ary decomposition tree. Then |B_h| = n − 1, and the mapping φ: {2,…,n} → B_h that maps i to the pair (v, boundary) at v = LCA_4(x_{i−1}, x_i) (LCA in the 4-ary decomposition) is a bijection.
Proof. The restricted sequence at any node is a concatenation of four contiguous child-blocks, hence contributes exactly three child-boundaries. Let N_t be the number of internal nodes at height t; N_t = 4^{h−t} − 1 over three? More directly, each level ℓ has 4^ℓ nodes of size 4^{h−ℓ}, all internal for ℓ ≤ h−1, so total internal nodes is (4^h − 1)/3, thus |B_h| = 3·(4^h − 1)/3 = 4^h − 1 = n − 1.
Injectivity: For i ≥ 2, let v be the least (deepest) node whose children contain x_{i−1} and x_i in different children. Within v’s restricted sequence S2 ∘ S4 ∘ S1 ∘ S3, the two keys lie in consecutive child-blocks; since these blocks are contiguous in time, (x_{i−1}, x_i) is exactly the last element of one block followed by the first element of the next. Hence i is a child-boundary time at v. Different i have different ordered pairs (last of block, first of next), so different child-boundaries. Since both sets have cardinality n − 1, φ is bijective. ∎

Theorem 4 (UB lower bound). There exists c>0 such that UB(π_h) ≥ c · n · log n. In fact,
UB(π_h) ≥ ∑_{v internal} 3·log(1 + s_v/8) = Θ(n log n).
Proof. By Lemma 3 and Lemma 2, summing over all child-boundary times gives UB(π_h) ≥ ∑_{v internal} 3·log(1 + s_v/8). At level ℓ (0 = root), there are 4^ℓ nodes with s_v = 4^{h−ℓ}. For s_v ≥ 8, log(1+s_v/8) ≥ (1/2) log s_v − O(1); for s_v ∈ {4}, the term is a positive constant. Therefore the sum is Θ(∑_{ℓ=0}^{h−1} 4^ℓ · (h−ℓ)) = Θ(n h) = Θ(n log n). ∎

Corollary 5. UB(π_h) = Θ(n log n), since trivially UB(π_h) ≤ n log(1+n) = O(n log n).

Wilber-1 bound and a Tango upper bound for OPT_BST

Define T_ref to be the perfectly balanced BST on [n]. Equivalently, for each 4-ary node v with interval I_v and children I_v(1)<I_v(2)<I_v(3)<I_v(4), T_ref contains the binary node that splits L := I_v(1)∪I_v(2) vs R := I_v(3)∪I_v(4), and recursively inside L the node that splits I_v(1) vs I_v(2), and inside R the node that splits I_v(3) vs I_v(4), and so on. Thus T_ref has n−1 internal nodes.

Lemma 6 (Alternations at nodes of T_ref). For any 4-ary node v:
- At the split L := I_v(1)∪I_v(2) vs R := I_v(3)∪I_v(4), the side sequence along π_h is L,R,L,R, hence contributes exactly 3 alternations.
- At the split I_v(1) vs I_v(2), the side sequence is R,R,L,R (since keys in I_v(3),I_v(4) are on the same side as I_v(2)), contributing exactly 2 alternations. Similarly for the split I_v(3) vs I_v(4) (2 alternations).
Proof. The time order inside I_v is S2 (⊂ I_v(2)), S4 (⊂ I_v(4)), S1 (⊂ I_v(1)), S3 (⊂ I_v(3)), with no interleaving across these blocks. Classify each block by the side of the considered pivot; the claimed patterns follow immediately. Within each block the side is constant relative to that pivot. ∎

Proposition 7 (Wilber-1 is linear). Let W1(T_ref, π_h) denote Wilber’s first bound with respect to T_ref. Then
W1(T_ref, π_h) ≤ ∑_{v internal(4-ary)} (3 + 2 + 2) = 7·(4^h − 1)/3 = O(n).
Proof. Each internal node of T_ref corresponds to exactly one of the three splits at some 4-ary node v as above. By Lemma 6, its alternation count is at most 3 (macro split) or 2 (micro split). Summing over all such nodes yields the bound. ∎

Corollary 8 (Tango upper bound). Tango trees achieve cost O(W1 · log log n), so there is an explicit BST algorithm with cost O(n log log n) on π_h. In particular, OPT_BST(π_h) ≤ O(n log log n).

Conclusion. Combining Corollary 5 and Corollary 8 gives
OPT_BST(π_h) / UB(π_h) = O(log log n / log n) = o(1).

Examples (h=2). n=16. At the root, three boundary steps contribute ≈ log(1 + 16/8) = log 3 = Θ(1). At its four children, the three boundary steps per child contribute log(1 + 4/8) = log 1.5 = Θ(1). Summing across all nodes yields UB = Θ(16 · log 16) = Θ(64). T_ref at the root contributes 3 alternations; at the next level, each of the two splits contributes 2; deeper nodes contribute similarly, totaling O(16) alternations.

Obstacles

- Strong separation (OPT = O(n)) remains open here. A plausible route is to prove Greedy or a tailored rotation-on-search-path algorithm runs in O(n) on this 4-decomposable, midpoint-first family. We do not claim this yet.

Next steps

- Formalize a Greedy upper bound on this family (cite or prove O(n) for permutations with substitution decomposition using only simple nodes of size ≤4 and aligned midpoints).
- Empirically compute UB(π_h) and Tango costs up to h≈10 to calibrate constants.
- Provide a concise DFS UB = O(n) proof (for completeness of the landscape).